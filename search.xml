<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>how to build a private docker registry</title>
    <url>/2015/07/21/how-to-build-a-private-docker-registry/</url>
    <content><![CDATA[<h1 id="如何搭建docker私服"><a href="#如何搭建docker私服" class="headerlink" title="如何搭建docker私服"></a>如何搭建docker私服</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>软件包：</p>
<ul>
<li><p>centos6.5_x86_64</p>
</li>
<li><p>docker-engine-1.7.0-1.el6.x86_64.rpm</p>
</li>
</ul>
<p>docker环境搭建,请参照官方说明，本文采用的是官方的rpm包</p>
<h2 id="何谓私服"><a href="#何谓私服" class="headerlink" title="何谓私服"></a>何谓私服</h2><p>官方的image镜像站位dockerhub,因为伟大的墙的缘故,所以下载镜像是很痛苦的一件事。当然你可以采用其他科学上网或者镜像加速的方法来获取image。<br>docker官方也提供了一个私服镜像,大家可以通过<code>docker search registry</code>来查找该镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME                                     DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">registry                                 Containerized docker registry                   320       [OK]       </span><br><span class="line">atcol/docker-registry-ui                 A web UI for easy private/local Docker Reg...   55                   [OK]</span><br><span class="line">konradkleine/docker-registry-frontend    Browse and modify your Docker registry in ...   40                   [OK]</span><br><span class="line">samalba/docker-registry                                                                  35</span><br></pre></td></tr></table></figure>
<h2 id="下载官方registry镜像"><a href="#下载官方registry镜像" class="headerlink" title="下载官方registry镜像"></a>下载官方registry镜像</h2><ul>
<li>下载镜像</li>
</ul>
<p>使用命令<code>docker pull registry</code>执行下载镜像。</p>
<ul>
<li>查看镜像</li>
</ul>
<p>下载完毕后,通过<code>docker images</code> 查看该镜像。</p>
<ul>
<li>给镜像打标签</li>
</ul>
<p>执行这个命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag registry:latest localhost:5000/registry:latest</span><br></pre></td></tr></table></figure>
<h2 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -e SETTINGS_FLAVOR=dev -e STORAGE_PATH=/tmp/registry -v /opt/data/registry:/tmp/registry  -p 5000:5000 registry</span><br></pre></td></tr></table></figure>
<p>这里有几个参数说明下:</p>
<ul>
<li>1.<code>-e STORAGE_PATH=/tmp/registry</code> :强制使用存储路径</li>
<li>2.<code>-v /opt/data/registry:/tmp/registry</code> :绑定本地镜像存储路径</li>
<li>3.<code>-p 5000:5000</code>:映射容器5000端口到本地5000端口</li>
</ul>
<h2 id="查看镜像状态"><a href="#查看镜像状态" class="headerlink" title="查看镜像状态"></a>查看镜像状态</h2><p><code>docker ps</code></p>
<h2 id="查看私服状态"><a href="#查看私服状态" class="headerlink" title="查看私服状态"></a>查看私服状态</h2><p><code>curl http://localhost:5000</code></p>
<p>显示如下信息,证明registry启动成功:</p>
<p><code>&quot;\&quot;docker-registry server\&quot;&quot;</code></p>
<h2 id="推送本地镜像库到registry私服"><a href="#推送本地镜像库到registry私服" class="headerlink" title="推送本地镜像库到registry私服"></a>推送本地镜像库到registry私服</h2><h3 id="1-第一步-给本地镜像-打tag"><a href="#1-第一步-给本地镜像-打tag" class="headerlink" title="1. 第一步 给本地镜像 打tag"></a>1. 第一步 给本地镜像 打tag</h3><p>例如给官方的nginx镜像打tag,执行下面的命令行</p>
<p><code>docker pull nginx</code></p>
<p><code>docker tag nginx:latest localhost:5000/nginx:latest</code></p>
<p>查看镜像库,发现<code>localhost:5000/nginx</code>的镜像已经有了。</p>
<h3 id="2-第二步-推送tag到registry私服"><a href="#2-第二步-推送tag到registry私服" class="headerlink" title="2. 第二步 推送tag到registry私服"></a>2. 第二步 推送tag到registry私服</h3><p><code>docker push localhost:5000/nginx:latest</code></p>
<h3 id="3-第三步-查看私服镜像列表"><a href="#3-第三步-查看私服镜像列表" class="headerlink" title="3. 第三步 查看私服镜像列表"></a>3. 第三步 查看私服镜像列表</h3><p><code>curl http://localhost：5000/V1/search</code></p>
<p>看到类似这样的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;"num_results": 5, "query": "", "results": [&#123;"description": null, "name": "correl/erlang"&#125;, &#123;"description": null, "name": "linfeng/cmd"&#125;, &#123;"description": null, "name": "library/my_nodejs_image"&#125;, &#123;"description": null, "name": "library/centos"&#125;, &#123;"description": "", "name": "library/nginx"&#125;]&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拉取私服镜像"><a href="#拉取私服镜像" class="headerlink" title="拉取私服镜像"></a>拉取私服镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull 192.168.20.85:5000/library/centos:7</span><br></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这只是演示如何搭建一个简单的registry私服。因为只有通过命令行方式才能查看私服信息,所以不是很便于操作。下面的博文将演示如何给registry添加web界面。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>registry</tag>
        <tag>registry-ui</tag>
      </tags>
  </entry>
  <entry>
    <title>how git changing author info</title>
    <url>/2016/09/22/how-git-changing-author-info/</url>
    <content><![CDATA[<h1 id="how-git-changing-author-info"><a href="#how-git-changing-author-info" class="headerlink" title="how git changing author info"></a>how git changing author info</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ol>
<li><code>gitlab</code>中的统计视图是根据用户的信息统计工作量 </li>
<li>迁移git repo中经常会遇到用户和邮箱不一致的情况</li>
</ol>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>那么如何修改已经推送到远程的author信息呢?</p>
<p> <code>github</code> 官方提供的建议<a href="https://help.github.com/articles/changing-author-info/" target="_blank" rel="noopener">如何变更用户信息</a></p>
<p>同时也有类似的项托管在<code>github</code>上，<a href="https://github.com/jayphelps/git-blame-someone-else" target="_blank" rel="noopener">git-tips-blame-someone-else</a></p>
<p>思路基本一致,就是替换提交记录、分支、标签里的author信息。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="1-打开终端或命令行-git-bash"><a href="#1-打开终端或命令行-git-bash" class="headerlink" title="1.打开终端或命令行(git bash)"></a>1.打开终端或命令行(<code>git bash</code>)</h3><h3 id="2-创建一个你项目的全新裸库"><a href="#2-创建一个你项目的全新裸库" class="headerlink" title="2.创建一个你项目的全新裸库"></a>2.创建一个你项目的全新裸库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --bare https://github.com/user/repo.git</span><br><span class="line">cd repo.git</span><br></pre></td></tr></table></figure>
<h3 id="3-复制粘贴脚本-并根据你的信息修改下面的变量"><a href="#3-复制粘贴脚本-并根据你的信息修改下面的变量" class="headerlink" title="3.复制粘贴脚本,并根据你的信息修改下面的变量:"></a>3.复制粘贴脚本,并根据你的信息修改下面的变量:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OLD_EMAIL</span><br><span class="line">CORRECT_NAME</span><br><span class="line">CORRECT_EMAIL</span><br></pre></td></tr></table></figure>
<p>脚本<code>replace.sh</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">git filter-branch --env-filter &apos;</span><br><span class="line"></span><br><span class="line">OLD_EMAIL=&quot;your-old-email@example.com&quot;</span><br><span class="line">CORRECT_NAME=&quot;Your Correct Name&quot;</span><br><span class="line">CORRECT_EMAIL=&quot;your-correct-email@example.com&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">&apos; --tag-name-filter cat -- --branches --tags</span><br></pre></td></tr></table></figure></p>
<h3 id="4-执行这个脚本"><a href="#4-执行这个脚本" class="headerlink" title="4.执行这个脚本"></a>4.执行这个脚本</h3><p><code>sh replace.sh</code></p>
<h3 id="5-察看Git历史有没有错误"><a href="#5-察看Git历史有没有错误" class="headerlink" title="5.察看Git历史有没有错误"></a>5.察看Git历史有没有错误</h3><p><code>git log</code></p>
<h3 id="6-强制推送到远程"><a href="#6-强制推送到远程" class="headerlink" title="6.强制推送到远程"></a>6.强制推送到远程</h3><p><code>git push --force --tags origin &#39;refs/heads/*&#39;</code></p>
<h3 id="7-清除repo-git仓库"><a href="#7-清除repo-git仓库" class="headerlink" title="7.清除repo.git仓库"></a>7.清除repo.git仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">rm -rf repo.git</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>first-blog</title>
    <url>/2015/04/17/first-blog/</url>
    <content><![CDATA[<p>#第一个博客</p>
<p>##记录使用hexo的各种填坑。</p>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>how to build a private docker registry</title>
    <url>/2015/07/21/how-to-build-a-private-docker-registry/</url>
    <content><![CDATA[<h1 id="如何搭建docker私服"><a href="#如何搭建docker私服" class="headerlink" title="如何搭建docker私服"></a>如何搭建docker私服</h1><p>##环境准备</p>
<p>软件包：</p>
<ul>
<li><p>centos6.5_x86_64</p>
</li>
<li><p>docker-engine-1.7.0-1.el6.x86_64.rpm</p>
</li>
</ul>
<p>docker环境搭建,请参照官方说明，本文采用的是官方的rpm包</p>
<p>##何谓私服</p>
<p>官方的image镜像站位dockerhub,因为伟大的墙的缘故,所以下载镜像是很痛苦的一件事。当然你可以采用其他科学上网或者镜像加速的方法来获取image。<br>docker官方也提供了一个私服镜像,大家可以通过<code>docker search registry</code>来查找该镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME                                     DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">registry                                 Containerized docker registry                   320       [OK]       </span><br><span class="line">atcol/docker-registry-ui                 A web UI for easy private/local Docker Reg...   55                   [OK]</span><br><span class="line">konradkleine/docker-registry-frontend    Browse and modify your Docker registry in ...   40                   [OK]</span><br><span class="line">samalba/docker-registry                                                                  35</span><br></pre></td></tr></table></figure>
<p>##下载官方registry镜像</p>
<ul>
<li>下载镜像</li>
</ul>
<p>使用命令<code>docker pull registry</code>执行下载镜像。</p>
<ul>
<li>查看镜像</li>
</ul>
<p>下载完毕后,通过<code>docker images</code> 查看该镜像。</p>
<ul>
<li>给镜像打标签</li>
</ul>
<p>执行这个命令<br><code>docker tag registry:latest localhost:5000/registry:latest</code></p>
<p>##启动镜像 </p>
<p><code>docker run -d -e SETTINGS_FLAVOR=dev -e STORAGE_PATH=/tmp/registry -v /opt/data/registry:/tmp/registry  -p 5000:5000 registry</code></p>
<p>这里有几个参数说明下:</p>
<ul>
<li>1.<code>-e STORAGE_PATH=/tmp/registry</code> :强制使用存储路径</li>
<li>2.<code>-v /opt/data/registry:/tmp/registry</code> :绑定本地镜像存储路径</li>
<li>3.<code>-p 5000:5000</code>:映射容器5000端口到本地5000端口</li>
</ul>
<p>##查看镜像状态</p>
<p><code>docker ps</code></p>
<p>##查看私服状态</p>
<p><code>curl http://localhost:5000</code></p>
<p>显示如下信息,证明registry启动成功:</p>
<p><code>&quot;\&quot;docker-registry server\&quot;&quot;</code></p>
<p>##推送本地镜像库到registry私服</p>
<p>###1. 第一步 给本地镜像 打tag<br>例如给官方的nginx镜像打tag,执行下面的命令行<br><code>docker pull nginx</code><br><code>docker tag nginx:latest localhost:5000/nginx:latest</code><br>查看镜像库,发现<code>localhost:5000/nginx</code>的镜像已经有了。</p>
<p>###2. 第二步 推送tag到registry私服</p>
<p><code>docker push localhost:5000/nginx:latest</code></p>
<p>###3. 第三步 查看私服镜像列表</p>
<p><code>curl http://localhost：5000/V1/search</code></p>
<p>看到类似这样的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;&quot;num_results&quot;: 5, &quot;query&quot;: &quot;&quot;, &quot;results&quot;: [&#123;&quot;description&quot;: null, &quot;name&quot;: &quot;correl/erlang&quot;&#125;, &#123;&quot;description&quot;: null, &quot;name&quot;: &quot;linfeng/cmd&quot;&#125;, &#123;&quot;description&quot;: null, &quot;name&quot;: &quot;library/my_nodejs_image&quot;&#125;, &#123;&quot;description&quot;: null, &quot;name&quot;: &quot;library/centos&quot;&#125;, &#123;&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/nginx&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure>
<p>##拉取私服镜像</p>
<p><code>docker pull 192.168.20.85:5000/library/centos:7</code></p>
<p>##结论</p>
<p>这只是演示如何搭建一个简单的registry私服。因为只有通过命令行方式才能查看私服信息,所以不是很便于操作。下面的博文将演示如何给registry添加web界面。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>registry</tag>
        <tag>registry-ui</tag>
      </tags>
  </entry>
  <entry>
    <title>how to understand git detached HEAD</title>
    <url>/2016/08/08/how-to-understand-git-detached-HEAD/</url>
    <content><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>远程有一个develop分支，我想获取到本地,但是clone该项目的时候这个远程分支还没有创建,于是执行 <code>git checkout commit_id(develop)</code> 提示如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout f7c774b</span><br><span class="line">Checking out files: 100% (357/357), done.</span><br><span class="line">Note: checking out &apos;f7c774b&apos;.</span><br><span class="line"></span><br><span class="line">You are in &apos;detached HEAD&apos; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b new_branch_name</span><br><span class="line"></span><br><span class="line">HEAD is now at f7c774b... update jeffsui.github.io</span><br></pre></td></tr></table></figure>
<h2 id="出现-detached-from"><a href="#出现-detached-from" class="headerlink" title="出现 detached from ..."></a>出现 <code>detached from ...</code></h2><p>此时用<code>git branch -av</code>察看分支<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -av</span><br><span class="line">* (detached from f7c774b) f7c774b update jeffsui.github.io</span><br><span class="line">  master                  6ce1857 Site updated: 2016-08-07 22:09:10</span><br><span class="line">  remotes/origin/HEAD     -&gt; origin/master</span><br><span class="line">  remotes/origin/develop  f7c774b update jeffsui.github.io</span><br><span class="line">  remotes/origin/gh-pages 1eee93f Site updated: 2016-02-13 21:03:46</span><br><span class="line">  remotes/origin/master   6ce1857 Site updated: 2016-08-07 22:09:10</span><br></pre></td></tr></table></figure></p>
<p>所谓的 <code>detached HEAD</code> 其实就是<code>HEAD</code>指向的是一个<code>commit</code>而不指向任何一个<code>branch</code>的临时分支,翻译过来就是<code>游离</code>.</p>
<p>众所周知,每一个分支都对应了一个commit,<code>git checkout</code>其实就是修改<code>HEAD</code>文件内容,让它指向不同的分支.</p>
<h2 id="如何让detached-HEAD所处分支指向远程分支"><a href="#如何让detached-HEAD所处分支指向远程分支" class="headerlink" title="如何让detached HEAD所处分支指向远程分支"></a>如何让<code>detached HEAD</code>所处分支指向远程分支</h2><p>此时的分支你可以执行<code>commit</code>操作,但是无法<code>push</code>到远程分支。<br>那么我们如何把游离状态的分支指向我们指定的远程分支呢。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git fetch origin develop:develop</span><br><span class="line">From https://github.com/jeffsui/jeffsui.github.io</span><br><span class="line"> * [new branch]      develop    -&gt; develop</span><br></pre></td></tr></table></figure></p>
<p>继续执行<code>git branch -av</code> 命令查看分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -av</span><br><span class="line">* (detached from f7c774b) f7c774b update jeffsui.github.io</span><br><span class="line">  develop                 f7c774b update jeffsui.github.io</span><br><span class="line">  master                  6ce1857 Site updated: 2016-08-07 22:09:10</span><br><span class="line">  remotes/origin/HEAD     -&gt; origin/master</span><br><span class="line">  remotes/origin/develop  f7c774b update jeffsui.github.io</span><br><span class="line">  remotes/origin/gh-pages 1eee93f Site updated: 2016-02-13 21:03:46</span><br><span class="line">  remotes/origin/master   6ce1857 Site updated: 2016-08-07 22:09:10</span><br></pre></td></tr></table></figure>
<p>此时我们发现多了一个<code>develop</code>分支指向了远程<code>develop</code> 分支，这样我们就可以通过命令<code>git push origin develop:develop</code>到远程分支了。</p>
<h2 id="更简洁的方法"><a href="#更简洁的方法" class="headerlink" title="更简洁的方法"></a>更简洁的方法</h2><p><code>git fetch origin develop:develop</code> </p>
<p>or </p>
<p><code>git checkount -b origin develop:develop</code> 这样可以直接获取远程分支并创建一个本地分支。</p>
]]></content>
      <tags>
        <tag>git</tag>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title>how to use nginx on windows</title>
    <url>/2016/09/27/how-to-use-nginx-on-windows/</url>
    <content><![CDATA[<h1 id="how-to-use-nginx-on-windows"><a href="#how-to-use-nginx-on-windows" class="headerlink" title="how to use nginx on windows"></a>how to use nginx on windows</h1><h2 id="1-Download-nginx-lastest-release-from-here"><a href="#1-Download-nginx-lastest-release-from-here" class="headerlink" title="1. Download nginx lastest release from here."></a>1. Download nginx lastest release from <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">here</a>.</h2><h2 id="2-unzip-to-your-local-driver-eg-c-apps-nginx"><a href="#2-unzip-to-your-local-driver-eg-c-apps-nginx" class="headerlink" title="2. unzip to your local driver. eg: c:/apps/nginx"></a>2. unzip to your local driver. eg: <code>c:/apps/nginx</code></h2><h2 id="3-start-nginx"><a href="#3-start-nginx" class="headerlink" title="3. start nginx"></a>3. start nginx</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd c:/apps/nginx</span><br><span class="line">start nginx</span><br></pre></td></tr></table></figure>
<h2 id="4-monitoring-nginx-process"><a href="#4-monitoring-nginx-process" class="headerlink" title="4. monitoring nginx process"></a>4. monitoring nginx process</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tasklist /fi &quot;imagename eq nginx.exe&quot;</span><br><span class="line">Image Name                     PID Session Name        Session#    Mem Usage</span><br><span class="line">========================= ======== ================ =========== ============</span><br><span class="line">nginx.exe                    11700 Console                    1     10,696 K</span><br><span class="line">nginx.exe                     1160 Console                    1     11,180 K</span><br></pre></td></tr></table></figure>
<p><strong>notice</strong><br>一个是主进程(main process),另一个是工作进程(work process).如果启动失败,请查看错误日志<code>logs\error.log</code></p>
<h2 id="5-visit-http-localhost-8080"><a href="#5-visit-http-localhost-8080" class="headerlink" title="5. visit http://localhost:8080"></a>5. visit <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></h2><h2 id="6-configuration-file-nginx-conf"><a href="#6-configuration-file-nginx-conf" class="headerlink" title="6. configuration file nginx.conf"></a>6. configuration file <code>nginx.conf</code></h2><p><em>reference config</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error_log  logs/error.log;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    server &#123;</span><br><span class="line">                listen       8080;</span><br><span class="line">                server_name  localhost;</span><br><span class="line">                location / &#123;</span><br><span class="line">                    root   html;</span><br><span class="line">                    index  index.html index.htm;</span><br><span class="line">                &#125;</span><br><span class="line">                error_page   500 502 503 504  /50x.html;</span><br><span class="line">                location = /50x.html &#123;</span><br><span class="line">                    root   html;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-the-command-list-of-nginx："><a href="#7-the-command-list-of-nginx：" class="headerlink" title="7. the command list of nginx："></a>7. the command list of nginx：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s stop   快速退出</span><br><span class="line">nginx -s quit   优雅退出</span><br><span class="line">nginx -s reload 更换配置，启动新的工作进程，优雅的关闭以往的工作进程</span><br><span class="line">nginx -s reopen 重新打开日志文件</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>my-angle</title>
    <url>/2016/02/15/my-angle/</url>
    <content><![CDATA[<ul>
<li><img src="http://7xindo.com1.z0.glb.clouddn.com/photoIMG_20160210_132300.jpg" alt></li>
<li><img src="http://7xindo.com1.z0.glb.clouddn.com/photoIMG_20160210_132850.jpg" alt></li>
<li><img src="http://7xindo.com1.z0.glb.clouddn.com/photoIMG_20160210_132209.jpg" alt></li>
<li><img src="http://7xindo.com1.z0.glb.clouddn.com/photoIMG_20160210_132106.jpg" alt></li>
<li><img src="http://7xindo.com1.z0.glb.clouddn.com/photoIMG_20160210_131838.jpg" alt></li>
<li><img src="http://7xindo.com1.z0.glb.clouddn.com/photoIMG_20160210_131523.jpg" alt></li>
</ul>
]]></content>
      <tags>
        <tag>photo</tag>
      </tags>
  </entry>
  <entry>
    <title>copy maven dependencies to a folder</title>
    <url>/2016/09/30/copy-maven-dependencies-to-a-folder/</url>
    <content><![CDATA[<h1 id="copy-maven-dependencies-to-a-folder"><a href="#copy-maven-dependencies-to-a-folder" class="headerlink" title="copy maven dependencies to a folder"></a>copy maven dependencies to a folder</h1><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>一个简单的需求,当你的同事需要调试代码的时候,他并不想建立maven环境,这时候依赖的jar包 该如何导出呢?</p>
<h2 id="no-code-say-nothing"><a href="#no-code-say-nothing" class="headerlink" title="no code say nothing"></a>no code say nothing</h2><p>这时候你需要的是<a href="http://maven.apache.org/plugins/maven-dependency-plugin/" target="_blank" rel="noopener">maven-dependency-plugin</a>。</p>
<h3 id="添加依赖配置"><a href="#添加依赖配置" class="headerlink" title="添加依赖配置"></a>添加依赖配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.eclipse.m2e&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;lifecycle-mapping&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;lifecycleMappingMetadata&gt;</span><br><span class="line">                        &lt;pluginExecutions&gt;</span><br><span class="line">                            &lt;!-- copy-dependency plugin --&gt;</span><br><span class="line">                            &lt;pluginExecution&gt;</span><br><span class="line">                                &lt;pluginExecutionFilter&gt;</span><br><span class="line">                                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                                    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</span><br><span class="line">                                    &lt;versionRange&gt;[1.0.0,)&lt;/versionRange&gt;</span><br><span class="line">                                    &lt;goals&gt;</span><br><span class="line">                                        &lt;goal&gt;copy-dependencies&lt;/goal&gt;</span><br><span class="line">                                    &lt;/goals&gt;</span><br><span class="line">                                    &lt;configuration&gt;</span><br><span class="line">                                        &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/alternateLocation&lt;/outputDirectory&gt;</span><br><span class="line">                                        &lt;overWriteReleases&gt;false&lt;/overWriteReleases&gt;</span><br><span class="line">                                        &lt;overWriteSnapshots&gt;false&lt;/overWriteSnapshots&gt;</span><br><span class="line">                                        &lt;overWriteIfNewer&gt;true&lt;/overWriteIfNewer&gt;</span><br><span class="line">                                    &lt;/configuration&gt;</span><br><span class="line">                                &lt;/pluginExecutionFilter&gt;</span><br><span class="line">                                &lt;action&gt;</span><br><span class="line">                                    &lt;ignore /&gt;</span><br><span class="line">                                &lt;/action&gt;</span><br><span class="line">                            &lt;/pluginExecution&gt;</span><br><span class="line">                        &lt;/pluginExecutions&gt;</span><br><span class="line">                    &lt;/lifecycleMappingMetadata&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br></pre></td></tr></table></figure>
<p>此处的<code>&lt;outputDirectory&gt;</code> 指定了你导出jar包的路径.</p>
<h3 id="执行命令-mvn-dependency-copy-dependencies"><a href="#执行命令-mvn-dependency-copy-dependencies" class="headerlink" title="执行命令 mvn dependency:copy-dependencies"></a>执行命令 <code>mvn dependency:copy-dependencies</code></h3><h3 id="查看项目多了一个-alternateLocation目录-并且依赖的jar包都下载到这个目录下了。"><a href="#查看项目多了一个-alternateLocation目录-并且依赖的jar包都下载到这个目录下了。" class="headerlink" title="查看项目多了一个/alternateLocation目录,并且依赖的jar包都下载到这个目录下了。"></a>查看项目多了一个<code>/alternateLocation</code>目录,并且依赖的jar包都下载到这个目录下了。</h3>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>how git version rollback</title>
    <url>/2015/05/16/how-git-version-rollback/</url>
    <content><![CDATA[<h1 id="Git如何进行远程版本回退……"><a href="#Git如何进行远程版本回退……" class="headerlink" title="Git如何进行远程版本回退……"></a>Git如何进行远程版本回退……</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>一切都要从一个蛋疼的需求开始,老板说,能给远程仓库的版本回退吗？我说为毛？他说我就是试试看git好使不,我……</p>
</blockquote>
<h2 id="咋搞"><a href="#咋搞" class="headerlink" title="咋搞"></a>咋搞</h2><ul>
<li>背景 </li>
</ul>
<p>gitcafe 国内知名的源码托管平台</p>
<ul>
<li>分析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1、git checkout the_branch</span><br><span class="line"></span><br><span class="line">2、git pull</span><br><span class="line"></span><br><span class="line">3、git branch the_branch_backup //备份一下这个分支当前的情况</span><br><span class="line"></span><br><span class="line">4、git reset --hard the_commit_id //把the_branch本地回滚到the_commit_id</span><br><span class="line"></span><br><span class="line">5、git push origin :the_branch //删除远程 the_branch</span><br><span class="line"></span><br><span class="line">6、git push origin the_branch //用回滚后的本地分支重新建立远程分支</span><br><span class="line"></span><br><span class="line">7、git push origin :the_branch_backup //如果前面都成功了，删除这个备份分支</span><br></pre></td></tr></table></figure>
<ul>
<li>删除远程分支</li>
</ul>
<p>首先,任何一个git源码托管平台都会告诉你,别删除远程master分支,因为它是默认的分支……,请移步<a href="https://gitcafe.com/GitCafe/Help/wiki/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4-Master-%E5%88%86%E6%94%AF" target="_blank" rel="noopener">这里</a> </p>
<ul>
<li>操作步骤 </li>
</ul>
<p>如果远程只有一个master分支,请你创建一个非master分支,然后推送到远程。<br>有人会问我为什么？打个比方,你见过上旱厕的时候,给自己脚下站着的板子抽走吗？</p>
<p>脚本类似下面这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git branch the_master_backup</span><br><span class="line"></span><br><span class="line">git push origin the_master_backup</span><br></pre></td></tr></table></figure>
<p>此时你查看远程分支应该有两个:master和the_master_backup</p>
<p>设置默认的分支为 the_master_backup</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git branch -D branch_name //删除本地master分支</span><br><span class="line"></span><br><span class="line">git push :master //推送一个空分支,相当于删除远程master分支</span><br></pre></td></tr></table></figure>
<p>然后你在the_master_backup分支上 回滚到你要回滚的commit_id,然后重建master分支并推送到远程,顺便删除the_master_backup分支(包括远程the_master_backup分支)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git checkout the_master_backup</span><br><span class="line"></span><br><span class="line">git reset --hard commit_id</span><br><span class="line"></span><br><span class="line">git branch master //重新创建master分支</span><br><span class="line"></span><br><span class="line">git push origin master //重新推送master分支</span><br><span class="line"></span><br><span class="line">git branch -D the_master_backup //删除本地the_master_backup分支</span><br><span class="line"></span><br><span class="line">git push origin :the_master_backup//删除远程the_master_backup分支</span><br></pre></td></tr></table></figure>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol>
<li>忘记设置默认分支为非master分支</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">remote: error: By default, deleting the current branch is denied, because the ne</span><br><span class="line">xt</span><br><span class="line">remote: error: &apos;git clone&apos; won&apos;t result in any file checked out, causing confusi</span><br><span class="line">on.</span><br><span class="line">remote: error:</span><br><span class="line">remote: error: You can set &apos;receive.denyDeleteCurrent&apos; configuration variable to</span><br><span class="line"></span><br><span class="line">remote: error: &apos;warn&apos; or &apos;ignore&apos; in the remote repository to allow deleting the</span><br><span class="line"></span><br><span class="line">remote: error: current branch, with or without a warning message.</span><br><span class="line">remote: error:</span><br><span class="line">remote: error: To squelch this message, you can set it to &apos;refuse&apos;.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你遇到的是所有提交只有master分支,那么希望我这个博文能帮到你。当然git强大的分支功能你基本也用不到了。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>版本管理</tag>
        <tag>gitcafe</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript oop 15 min programming</title>
    <url>/2015/04/23/javascript-oop-15-min-programming/</url>
    <content><![CDATA[<h1 id="javascript的面向对象15分钟教程"><a href="#javascript的面向对象15分钟教程" class="headerlink" title="javascript的面向对象15分钟教程"></a>javascript的面向对象15分钟教程</h1><h2 id="第一种面向对象的写法"><a href="#第一种面向对象的写法" class="headerlink" title="第一种面向对象的写法"></a>第一种面向对象的写法</h2><h3 id="创建空对象"><a href="#创建空对象" class="headerlink" title="创建空对象"></a>创建空对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> bill =&#123;&#125;;<span class="comment">//创建一个空对象</span></span><br></pre></td></tr></table></figure>
<h3 id="给对象添加属性和方法"><a href="#给对象添加属性和方法" class="headerlink" title="给对象添加属性和方法"></a>给对象添加属性和方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bill.name = <span class="string">"Bill Goat"</span>;</span><br><span class="line">bill.work = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"programming...."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="一步完成上面的两件事"><a href="#一步完成上面的两件事" class="headerlink" title="一步完成上面的两件事"></a>一步完成上面的两件事</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> bill =&#123;</span><br><span class="line">    name : <span class="string">"Bill Goat"</span>;</span><br><span class="line">    work : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"programming...."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="访问对象和属性"><a href="#访问对象和属性" class="headerlink" title="访问对象和属性"></a>访问对象和属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bill.name);</span><br><span class="line">bill.work();</span><br></pre></td></tr></table></figure>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bill.name = <span class="string">"Bill Goat"</span>;</span><br><span class="line">bill.work =<span class="function"><span class="keyword">function</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"programming for "</span>+who);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="通过this关键字访问内部属性"><a href="#通过this关键字访问内部属性" class="headerlink" title="通过this关键字访问内部属性"></a>通过this关键字访问内部属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bill.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bill's name  is"</span>+<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> silly = bill;</span><br><span class="line"><span class="built_in">console</span>.log(silly.name);</span><br><span class="line">sally.name = <span class="string">"Silly"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(silly.name);</span><br><span class="line"><span class="built_in">console</span>.log(bill.name);</span><br></pre></td></tr></table></figure>
<h3 id="另一个方式引用"><a href="#另一个方式引用" class="headerlink" title="另一个方式引用"></a>另一个方式引用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bill.name = <span class="string">"Bill Goat"</span>;</span><br><span class="line">bill.say();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sayName = bill.say();</span><br><span class="line">sayName;</span><br><span class="line">sayName();</span><br></pre></td></tr></table></figure>
<h3 id="有意思的地方-：全局属性"><a href="#有意思的地方-：全局属性" class="headerlink" title="有意思的地方 ：全局属性"></a>有意思的地方 ：全局属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Global"</span>;</span><br><span class="line">bill.say();</span><br></pre></td></tr></table></figure>
<p>发现此时输出的是<br><code>bill&#39;s name is Global</code></p>
<h2 id="另一种面向对象的写法"><a href="#另一种面向对象的写法" class="headerlink" title="另一种面向对象的写法"></a>另一种面向对象的写法</h2><h3 id="定义对象及属性"><a href="#定义对象及属性" class="headerlink" title="定义对象及属性"></a>定义对象及属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Game</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DF = <span class="keyword">new</span> Game();</span><br></pre></td></tr></table></figure>
<h3 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">DF.title = <span class="string">"星际争霸2"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Game</span> (<span class="params">title</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.title = <span class="keyword">typeof</span> title !== <span class="string">'undifined'</span> ? title :<span class="string">""</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d3 = <span class="keyword">new</span> Game(<span class="string">"d3"</span>);</span><br><span class="line">d3.title;</span><br><span class="line">d3.title =<span class="string">"starcraft2"</span>;</span><br></pre></td></tr></table></figure>
<p><code>this.title = typeof title !== &#39;undifined&#39; ? title :&quot;&quot;;</code>相当于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> title !== <span class="string">"undifined"</span>）&#123;</span><br><span class="line">	<span class="keyword">this</span>.title = title;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.title = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建一个方法来访问这个属性"><a href="#创建一个方法来访问这个属性" class="headerlink" title="创建一个方法来访问这个属性"></a>创建一个方法来访问这个属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">d3.loveTitle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"I love "</span>+<span class="keyword">this</span>.title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更好的写法"><a href="#更好的写法" class="headerlink" title="更好的写法"></a>更好的写法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Game.prototype.heartIt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"I love "</span>+<span class="keyword">this</span>.title);</span><br><span class="line">&#125;</span><br><span class="line">d3.heartIt();</span><br></pre></td></tr></table></figure>
<p>下次详解javascript的原生对象模型</p>
<p>to be continued~~~~</p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>oop</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript asynchronous programming learning :event</title>
    <url>/2015/04/20/javascript-asynchronous-programming-learning-event/</url>
    <content><![CDATA[<h1 id="javascript异步编程读书笔记之事件机制"><a href="#javascript异步编程读书笔记之事件机制" class="headerlink" title="javascript异步编程读书笔记之事件机制"></a>javascript异步编程读书笔记之事件机制</h1><h2 id="事件的调度"><a href="#事件的调度" class="headerlink" title="事件的调度"></a>事件的调度</h2><ul>
<li>异步执行</li>
</ul>
<p><code>setTimeout</code>函数的解释:给定一个回调及n毫秒的延迟,setTimeout会在n毫秒后运行该回调。</p>
<p>代码清单1:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 3; i++) &#123;</span><br><span class="line">	setTimeout(function()&#123; </span><br><span class="line">		console.log(i); &#125;, </span><br><span class="line">	0);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<ul>
<li><p>线程阻塞<br>代码清单2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var start = new Date;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">var end = new Date;</span><br><span class="line">console.log(&apos;Time elapsed:&apos;, end - start, &apos;ms&apos;);</span><br><span class="line">&#125;, 500);</span><br><span class="line">while (new Date - start &lt; 1000) &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>队列</p>
</li>
</ul>
<p>javascript使用队列的方式来循环处理请求,这种机制被称为<strong>事件循环</strong>。</p>
]]></content>
      <categories>
        <category>javascript</category>
        <category>异步</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>how make cygwin multi-color</title>
    <url>/2015/08/12/how-make-cygwin-multi-color/</url>
    <content><![CDATA[<h2 id="打开-bashrc"><a href="#打开-bashrc" class="headerlink" title="打开.bashrc"></a>打开.bashrc</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Default to human readable figures</span><br><span class="line"># alias df=&apos;df -h&apos;</span><br><span class="line"># alias du=&apos;du -h&apos;</span><br><span class="line">#</span><br><span class="line"># Misc  </span><br><span class="line"># alias less=&apos;less -r&apos;                          # raw control characters</span><br><span class="line"># alias whence=&apos;type -a&apos;                        # where, of a sort</span><br><span class="line"># alias grep=&apos;grep --color&apos;                     # show differences in colour</span><br><span class="line"># alias egrep=&apos;egrep --color=auto&apos;              # show differences in colour</span><br><span class="line"># alias fgrep=&apos;fgrep --color=auto&apos;              # show differences in colour</span><br><span class="line">#</span><br><span class="line"># Some shortcuts for different directory listings</span><br><span class="line"># alias ls=&apos;ls -hF --color=tty&apos;                 # classify files in colour</span><br><span class="line"># alias dir=&apos;ls --color=auto --format=vertical&apos;</span><br><span class="line"># alias vdir=&apos;ls --color=auto --format=long&apos;</span><br><span class="line"># alias ll=&apos;ls -l&apos;                              # long list</span><br><span class="line"># alias la=&apos;ls -A&apos;                              # all but . and ..</span><br><span class="line"># alias l=&apos;ls -CF&apos;                              #</span><br></pre></td></tr></table></figure>
<h2 id="而我们要做的只是去掉-，启动即可："><a href="#而我们要做的只是去掉-，启动即可：" class="headerlink" title="而我们要做的只是去掉#，启动即可："></a>而我们要做的只是去掉#，启动即可：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Default to human readable figures</span><br><span class="line">alias df=&apos;df -h&apos;</span><br><span class="line">alias du=&apos;du -h&apos;</span><br><span class="line">#</span><br><span class="line"># Misc  </span><br><span class="line">alias less=&apos;less -r&apos;                          # raw control characters</span><br><span class="line">alias whence=&apos;type -a&apos;                        # where, of a sort</span><br><span class="line">alias grep=&apos;grep --color&apos;                     # show differences in colour</span><br><span class="line">alias egrep=&apos;egrep --color=auto&apos;              # show differences in colour</span><br><span class="line">alias fgrep=&apos;fgrep --color=auto&apos;              # show differences in colour</span><br><span class="line">#</span><br><span class="line"># Some shortcuts for different directory listings</span><br><span class="line">alias ls=&apos;ls -hF --color=tty&apos;                 # classify files in colour</span><br><span class="line">alias dir=&apos;ls --color=auto --format=vertical&apos;</span><br><span class="line">alias vdir=&apos;ls --color=auto --format=long&apos;</span><br><span class="line">alias ll=&apos;ls -l&apos;                              # long list</span><br><span class="line">alias la=&apos;ls -A&apos;                              # all but . and ..</span><br><span class="line">alias l=&apos;ls -CF&apos;                              #</span><br></pre></td></tr></table></figure>
<h2 id="然后保存一下，再重启cygwin（或者直接用：source-bashrc）"><a href="#然后保存一下，再重启cygwin（或者直接用：source-bashrc）" class="headerlink" title="然后保存一下，再重启cygwin（或者直接用：source ~/.bashrc）"></a>然后保存一下，再重启cygwin（或者直接用：<code>source ~/.bashrc</code>）</h2>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>cygwin</tag>
      </tags>
  </entry>
  <entry>
    <title>push-hexo-to-github</title>
    <url>/2015/04/17/push-hexo-to-github/</url>
    <content><![CDATA[<h1 id="如何使用hexo在github上建立静态博客"><a href="#如何使用hexo在github上建立静态博客" class="headerlink" title="如何使用hexo在github上建立静态博客"></a>如何使用hexo在github上建立静态博客</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol>
<li><p>hexo环境搭建</p>
<p> 请参考 hexo.io <a href="http://hexo.io/" title="官方站点" target="_blank" rel="noopener">官方站点</a>,<br> <strong>强烈建议</strong>给<em>基本操作</em>下的内容快速浏览一遍,下面的操作是我一个一个命令敲出来的,遇到的坑也会记录下来,希望大家能少走弯路。</p>
</li>
<li><p>github上建立静态博客</p>
<ol>
<li>github账号申请（略）</li>
<li>建立一个github项目</li>
<li><code>git clone 项目地址</code> 到本地</li>
<li>项目初始化<br><code><pre><br>cd 项目名<br>echo # hexo 实例站点 &gt;&gt; README.md<br>git init<br>git add README.md<br>git commit -m “first blood”<br>git remote add origin 项目地址<br>git push -u origin master<br></pre></code></li>
<li><p>github免费站点建立规则,请仔细阅读这个规则<br><a href="https://help.github.com/articles/user-organization-and-project-pages/" target="_blank" rel="noopener">https://help.github.com/articles/user-organization-and-project-pages/</a></p>
</li>
<li><p>默认github域名</p>
<p>默认github 分配了 一个name.github.io的域名,<br>还有一个name.github.io/project_name的二级域名,<br>请参照github的提示设置URL。</p>
</li>
</ol>
</li>
</ol>
<h2 id="华丽的分割线"><a href="#华丽的分割线" class="headerlink" title="华丽的分割线"></a>华丽的分割线</h2><ol>
<li><p>站点配置流程</p>
<ol>
<li>建立站点文件夹,并站点初始化</li>
<li>安装hexo依赖</li>
<li>修改node_module/hexo-server/index.js,用于本地调试</li>
<li>安装hexo-git-deployer插件</li>
<li><p>修改全局配置文件_config.yml,配置<code>deploy</code><br><code><pre><br># Site 站点配置<br>title: 凭海临风的测试江湖<br>subtitle:<br>description: 凭海临风的博客<br>author: Jeff Sui<br>language: zh-CN<br>timezone</pre></code></p>
<pre><code>&lt;/code&gt;&lt;/pre&gt;
</code></pre><p><code><pre><br># URL 站点链接<br>## If your site is put in a subdirectory, set url as ‘<a href="http://yoursite.com/child&#39;" target="_blank" rel="noopener">http://yoursite.com/child&#39;</a> and root as ‘/child/‘<br>url: <a href="http://jeffsui.github.io" target="_blank" rel="noopener">http://jeffsui.github.io</a><br>root: /pinghailinfeng_blog/<br>permalink: :year/:month/:day/:title/<br>permalink_defaults:<br>  </pre></code></p>
<p><code><pre><br># Deployment<br>## Docs: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="noopener">http://hexo.io/docs/deployment.html</a><br>deploy:<br> type: git<br> repo: <a href="https://github.com/jeffsui/pinghailinfeng_blog.git" target="_blank" rel="noopener">https://github.com/jeffsui/pinghailinfeng_blog.git</a><br> branch : master<br> message :<br>  </pre></code></p>
<p><em>以上配置仅供参考</em></p>
</li>
</ol>
</li>
<li><p>创建文章</p>
<ul>
<li><p>执行<code>hexo new</code> 命令</p>
<p>例如:hexo new post my-first-blog</p>
<p><em>将会自动在source/_posts下创建一个my-first-blog.md的文件,使用的是scaffolds下的post.md模板</em></p>
</li>
<li><p>修改并保存my-first-blog.md文件</p>
</li>
<li><p>站点生成<code>hexo g</code></p>
</li>
<li><p>站点部署 <code>hexo d</code></p>
<p>如果没有报错,恭喜你已经成功推送到 项目的master分支。</p>
</li>
</ul>
</li>
<li><p>创建gh-pages分支并推送到远程<br> <code><pre><br> git fetch origin master<br> git checkout gh-pages<br> git merge master<br> git push origin gh-pages<br> </pre></code></p>
</li>
<li>访问<a href="http://jeffsui.github.io/pinghailinfeng_blog/" title="站点" target="_blank" rel="noopener">http://jeffsui.github.io/pinghailinfeng_blog/</a></li>
</ol>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol>
<li>github站点的规则不熟悉,url配置浪费我2个小时。项目建立的是二级域名,所以必须要按照我说的那样配置。</li>
<li>本地预览有可能不加载样式,重新删除<code>node_module</code>下所有,执行<code>npm install</code>,再<code>hexo g</code>,<code>hexo server -i 127.0.0.1 -s -o</code>即可。</li>
<li>hexo3.0版本的git插件必须要独立安装。</li>
<li>其他坑,自己填吧。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><em>大坑各种有,github特别多,还有伟大的墙,兄弟们,github好上,填坑需谨慎！</em></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>搭建</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>maven3-jdk1.7-problem-fixed</title>
    <url>/2016/02/13/maven3-jdk1-7-problem-fixed/</url>
    <content><![CDATA[<h1 id="maven3下jdk1-7编译错误解决"><a href="#maven3下jdk1-7编译错误解决" class="headerlink" title="maven3下jdk1.7编译错误解决"></a>maven3下jdk1.7编译错误解决</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Apache Maven <span class="number">3.3</span>.<span class="number">3</span> (<span class="number">7994120775791599</span>e205a5524ec3e0dfe41d4a06; <span class="number">2015</span><span class="literal">-04</span><span class="literal">-22T19</span>:<span class="number">57</span>:<span class="number">3</span></span><br><span class="line"><span class="number">7</span>+<span class="number">08</span>:<span class="number">00</span>)</span><br><span class="line">Maven home: d:\tools\apache<span class="literal">-maven</span><span class="literal">-3</span>.<span class="number">3.3</span></span><br><span class="line">Java version: <span class="number">1.7</span>.<span class="number">0</span>_45, vendor: Oracle Corporation</span><br><span class="line">Java home: c:\Program Files\Java\jdk1.<span class="number">7.0</span>_45\jre</span><br><span class="line">Default locale: zh_CN, platform encoding: GBK</span><br><span class="line">OS name: <span class="string">"windows 7"</span>, version: <span class="string">"6.1"</span>, arch: <span class="string">"amd64"</span>, family: <span class="string">"windows"</span></span><br></pre></td></tr></table></figure>
<h2 id="使用maven命令行创建java项目"><a href="#使用maven命令行创建java项目" class="headerlink" title="使用maven命令行创建java项目"></a>使用<code>maven</code>命令行创建java项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=org.linfeng -DartifactId=mavendemo -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false</span><br></pre></td></tr></table></figure>
<ul>
<li>创建成功</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> cd mavendemo &amp;&amp; ls</span><br><span class="line">pom.xml  src</span><br></pre></td></tr></table></figure>
<ul>
<li>pom.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.linfeng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mavendemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavendemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行maven命令</li>
</ul>
<p><code>mvn test</code></p>
<ul>
<li>错误信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project mavendemo: Compilation failure</span><br><span class="line">[ERROR] No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK?</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>修改<code>settings.xml</code>,添加jdk1.7相关内容</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.7<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em>缺点</em>:修改所有项目的jre环境</p>
<ul>
<li>修改当前项目的<code>pom.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>重新执行<code>mvn build</code> 成功！</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>Maven官方文档有如下描述：</p>
<blockquote>
<p>编译器插件用来编译项目的源文件.从3.0版本开始, 用来编译Java源文件的默认编译器是javax.tools.JavaCompiler (如果你是用的是java 1.6) . 如果你想强制性的让插件使用javac,你必须配置插件选项 forceJavacCompilerUse.<br>同时需要注意的是目前source选项和target 选项的默认设置都是1.5, 与运行Maven时的JDK版本无关.如果你想要改变这些默认设置, 可以参考 Setting the -source and -target of the Java Compiler中的描述来设置 source 和target 选项.</p>
</blockquote>
<p>#参考资料</p>
<ul>
<li><a href="http://stackoverflow.com/questions/15220392/maven-package-compilation-error" target="_blank" rel="noopener">http://stackoverflow.com/questions/15220392/maven-package-compilation-error</a></li>
<li><a href="http://www.cnblogs.com/leo100w/p/4017647.html" target="_blank" rel="noopener">http://www.cnblogs.com/leo100w/p/4017647.html</a></li>
</ul>
]]></content>
      <categories>
        <category>ci</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>jdk</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title>sublime run slow problem</title>
    <url>/2015/04/17/sublime-run-slow-problem/</url>
    <content><![CDATA[<h1 id="解决sublime-Text2运行缓慢的方法"><a href="#解决sublime-Text2运行缓慢的方法" class="headerlink" title="解决sublime Text2运行缓慢的方法"></a>解决sublime Text2运行缓慢的方法</h1><p>今天打开<code>sublime</code>想写博客发现整个页面打开很慢,切换tab要等好几秒。<br>发现了一个帖子,说<code>GitGutter</code>这个插件在st2下会影响切换tab速度。</p>
<p>于是 <code>ctrl+shift+p</code>调出命令,remove package,选择<code>GitGutter</code>,回车。<br>重启sublime,世界都变得清静了。</p>
]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>sublime</tag>
        <tag>GitGutter</tag>
      </tags>
  </entry>
  <entry>
    <title>我的新文章</title>
    <url>/2015/04/17/my-new-post/</url>
    <content><![CDATA[<p>#我的新文章</p>
<p>   这是我的第一篇在<code>github</code>上的博客。记录下我的工作和生活,慢慢给其他的文章都更新到这里。嬉笑怒骂也好,喜怒哀乐也罢,我就是一个俗人罢了。</p>
]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>博客</tag>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title>use-shorturl and two-dimensional-barcodes to beautify blog</title>
    <url>/2015/04/20/use-shorturl-and-two-dimensional-barcodes-to-beautify-blog/</url>
    <content><![CDATA[<h1 id="如何使用短网址和二维码简化网站访问"><a href="#如何使用短网址和二维码简化网站访问" class="headerlink" title="如何使用短网址和二维码简化网站访问"></a>如何使用短网址和二维码简化网站访问</h1><ol>
<li>短网址(shorturl)<br> web2.0时代的潮流,借助短网址您可以用简短的网址替代原来冗长的网址，让使用者可以更容易的分享链接。<br>这里我使用的是百度的短网址服务:<a href="http://dwz.cn/" title="百度短网址" target="_blank" rel="noopener">http://dwz.cn/</a><ol>
<li>访问<a href="http://dwz.cn/主页" target="_blank" rel="noopener">http://dwz.cn/主页</a><br><img src="http://7xindo.com1.z0.glb.clouddn.com/百度短网址.png" alt></li>
<li>输入你的博客地址<br>我输入<a href="http://jeffsui.github.io/pinghailinfeng_blog/" target="_blank" rel="noopener">http://jeffsui.github.io/pinghailinfeng_blog/</a></li>
<li>复制短网址<br><img src="http://7xindo.com1.z0.glb.clouddn.com/百度短网址生成.png" alt></li>
</ol>
</li>
<li>二维码(two-dimensional-barcodes)<br>微信时代,不知道二维码的基本都属于外星球人了。<br>这里我选择的是草料二维码:<br><a href="http://cli.im/" title="草料二维码" target="_blank" rel="noopener">http://cli.im/</a><ol>
<li>输入二维码地址<br><img src="http://7xindo.com1.z0.glb.clouddn.com/在线二维码输入地址.jpg" alt></li>
<li>进行一些基本设置<br>包括前景色、背景色、渐变色等等。</li>
<li>嵌入图片</li>
<li>选用你喜欢的模板</li>
<li>保存二维码</li>
</ol>
</li>
<li>在线存储<br><del>这里我选择国内知名的七牛云存储</del>（七牛不免费了,我迁移到了github）<br> <img src="http://7xindo.com1.z0.glb.clouddn.com/云存储图片.jpg" alt></li>
<li>在博客中引用图片地址就可以了</li>
</ol>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>美化</tag>
        <tag>短网址</tag>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title>talk about software engineering</title>
    <url>/2015/04/22/talk-about-software-engineering/</url>
    <content><![CDATA[<h1 id="关于软件工程的讨论–质量篇"><a href="#关于软件工程的讨论–质量篇" class="headerlink" title="关于软件工程的讨论–质量篇"></a>关于软件工程的讨论–质量篇</h1><blockquote>
<p>那为什么软件系统的质量不容易高呢？我觉得主要原因是流程不完善。那为什么不完善？需求容易变。为什么容易变？是因为不论程序员自己，还是需求方，其实潜意识都认为自己做的东西是变更成本较低的。</p>
</blockquote>
<blockquote>
<p>试想一下，为什么没人在盖高楼盖一半变更需求？为什么没人修大桥修一半变更需求？甚至做衣服做一半的时候变更需求，理发到一半变更需求，都会被人认为是不讲理。但是在软件领域，好像这倒成了普遍现象。</p>
</blockquote>
<blockquote>
<p>因为整个软件系统的实现，都是虚拟的，看不见摸不着，并不消耗什么物料，所以从这个角度想，变起来当然是容易的。但软件系统的架构，其实也跟实体的没本质区别，变更时候要考虑很多关联因素，并不是就那么孤立的看一小块地方，当然，也会有一些不影响全局的变更。打个比方说，如果你在盖房子盖到一半，那变更外墙颜色肯定是要比变更窗户大小容易的。要是想变得太多，估计只好拆了重来。</p>
</blockquote>
<p>下面的讨论更加精彩:</p>
<p>A:其实不是流程问题，老板和甲方问题</p>
<p>A:甲方尤其关键 </p>
<p>A:尼玛，要8层楼房，付2层费用</p>
<p>……</p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>windows-mongodb-install</title>
    <url>/2016/02/13/windows-mongodb-install/</url>
    <content><![CDATA[<h1 id="windows下mongodb安装"><a href="#windows下mongodb安装" class="headerlink" title="windows下mongodb安装"></a>windows下mongodb安装</h1><h2 id="下载mongodb"><a href="#下载mongodb" class="headerlink" title="下载mongodb"></a>下载mongodb</h2><p><a href="http://www.mongodb.org/downloads" target="_blank" rel="noopener">http://www.mongodb.org/downloads</a></p>
<h2 id="选择自定义安装"><a href="#选择自定义安装" class="headerlink" title="选择自定义安装"></a>选择自定义安装</h2><p>本机路径为:<code>d:\tools\mongodb</code></p>
<h2 id="建立如下文件目录"><a href="#建立如下文件目录" class="headerlink" title="建立如下文件目录"></a>建立如下文件目录</h2><p>数据库路径:<code>d:\tools\mongodb\db</code><br>日志路径:<code>d:\tools\mongodb\log</code><br>配置文件目录<code>d:\tools\mongodb\etc</code><br>建立配置文件<code>d:\tools\mongodb\etc\mongodb.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dbpath=d:\tools\mongodb\db #数据库路径</span><br><span class="line">logpath=d:\tools\mongodb\log\mongodb.log #日志输出文件路径</span><br><span class="line">logappend=true #错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件</span><br><span class="line">journal=true #启用日志文件，默认启用</span><br><span class="line">quiet=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false</span><br><span class="line">port=27017 #端口号 默认为27017</span><br></pre></td></tr></table></figure>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>切换到<code>d:\tools\mongodb\bin</code> 目录下:</p>
<ul>
<li>普通启动</li>
</ul>
<p><code>mongod --config d:\tools\mongodb\etc\mongodb.conf</code></p>
<ul>
<li>注册为windows服务</li>
</ul>
<p><code>mongod --config d:\tools\mongodb\etc\mongodb.conf --install</code></p>
<p><strong>补充</strong> </p>
<ul>
<li>windows服务卸载</li>
</ul>
<p><code>mongod --remove --serviceName &quot;MongoDB&quot;</code></p>
<ul>
<li>启动服务<br><code>net start mongodb</code></li>
</ul>
<p>启动成功后,通过浏览器访问 <code>http://localhost:27017</code> ,看到下面的文字,证明启动服务成功！</p>
<blockquote>
<p>It looks like you are trying to access MongoDB over HTTP on the native driver port.</p>
</blockquote>
<ul>
<li>关闭服务<br><code>net stop mongodb</code> </li>
</ul>
<h2 id="图形化工具"><a href="#图形化工具" class="headerlink" title="图形化工具"></a>图形化工具</h2><p>官方提供的很全:<a href="https://docs.mongodb.org/ecosystem/tools/administration-interfaces/" target="_blank" rel="noopener">https://docs.mongodb.org/ecosystem/tools/administration-interfaces/</a></p>
<ul>
<li><p><a href="http://www.npmjs.org/package/mongo-express" target="_blank" rel="noopener">mongo express </a> –Nodejs</p>
</li>
<li><p><a href="http://mongobooster.com" target="_blank" rel="noopener">MongoBooster </a></p>
</li>
<li><p><a href="http://edgytech.com/umongo/" target="_blank" rel="noopener">UMongo </a></p>
</li>
<li><p><a href="https://github.com/fotonauts/MongoHub-Mac" target="_blank" rel="noopener">MongoHub </a></p>
</li>
<li><p><a href="http://blog.mongovue.com/" target="_blank" rel="noopener">MongoVUE</a> –.NET </p>
</li>
</ul>
]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>Build path entry is missing /src/test/java missing问题解决</title>
    <url>/2019/06/03/Maven-webapp-buildpath-missing-test-folder/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="[问题描述]"></a>[问题描述]</h2><p>通过maven构建webapp,发现缺少java和test目录</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="[解决方案]"></a>[解决方案]</h2><blockquote>
<p>project –right click –build path– config build path – libraries – double click “JRE System Library”–choose “workspace default JRE”  OK</p>
</blockquote>
<p>如下图所示<br><img src="https://i.loli.net/2019/06/03/5cf4e41a0d68921253.png" alt></p>
]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/05/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>how-to-fix-cannot-change-version-of-project-dynamic-web-module-to-3.1-in-Eclipse</title>
    <url>/2019/06/03/how-to-fix-cannot-change-version-of-project-dynamic-web-module-to-3.1-in-Eclipse/</url>
    <content><![CDATA[<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h2><p><img src="https://cdn.crunchify.com/wp-content/uploads/2015/06/Cannot-change-version-of-project-facet-Dynamic-Web-Module-to-3.0.png" alt></p>
<p>试图转换Dynamic Web Module 发生如下错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cannot change version of project facet Dynamic Web Module to 3.0 </span><br><span class="line">One or more constraints have not been satisfied</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>操作步骤：</p>
<ol>
<li><p>右键点击项目</p>
</li>
<li><p>选择Properties</p>
</li>
<li><p>点击Project facet 选项</p>
</li>
<li><p>更改Dynamic Web Module, 2.3 到 3.1 ,如下图</p>
<p><img src="https://i.loli.net/2019/06/03/5cf4ab68ec48777079.png" alt></p>
</li>
</ol>
<h2 id="2-解决步骤"><a href="#2-解决步骤" class="headerlink" title="2. 解决步骤"></a>2. 解决步骤</h2><h3 id="Step-1："><a href="#Step-1：" class="headerlink" title="Step 1："></a>Step 1：</h3><ul>
<li><p>选择navigator 视图 </p>
<p><img src="https://i.loli.net/2019/06/03/5cf4aa24278d257489.png" alt></p>
</li>
</ul>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2:"></a>Step 2:</h3><ul>
<li><p>打开<code>org.eclipse.wst.common.project.facet.core.xml</code></p>
</li>
<li><p>修改jst.web 的值2.3 为 3.1</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">faceted-project</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fixed</span> <span class="attr">facet</span>=<span class="string">"wst.jsdt.web"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">installed</span> <span class="attr">facet</span>=<span class="string">"jst.jaxrs"</span> <span class="attr">version</span>=<span class="string">"2.0"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">installed</span> <span class="attr">facet</span>=<span class="string">"wst.jsdt.web"</span> <span class="attr">version</span>=<span class="string">"1.0"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">installed</span> <span class="attr">facet</span>=<span class="string">"java"</span> <span class="attr">version</span>=<span class="string">"1.8"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">installed</span> <span class="attr">facet</span>=<span class="string">"jst.web"</span> <span class="attr">version</span>=<span class="string">"3.1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">faceted-project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><em>注意</em> jst.web版本3.1,那么java版本必须是1.7以上才可以</p>
<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3:"></a>Step 3:</h3><ul>
<li><p>刷新项目</p>
<ul>
<li>鼠标右键点击项目</li>
<li>F5刷新项目</li>
</ul>
</li>
<li><p>清理项目</p>
<ul>
<li><p>点击顶部菜单栏 Project</p>
</li>
<li><p>选择Clean</p>
<p><img src="https://i.loli.net/2019/06/03/5cf496162a2e253063.png" alt></p>
</li>
</ul>
</li>
<li><p>maven更新</p>
<ul>
<li><p>鼠标右键点击项目名称</p>
</li>
<li><p>选择Maven</p>
</li>
<li><p>选择Update project</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-问题总结"><a href="#3-问题总结" class="headerlink" title="3. 问题总结"></a>3. 问题总结</h2><p>没有清理项目就直接更新,缓存造成更新失败。</p>
<p>参考链接</p>
<ul>
<li><a href="https://crunchify.com/how-to-fix-cannot-change-version-of-project-facet-dynamic-web-module-to-3-0-error-in-eclipse/" target="_blank" rel="noopener">how-to-fix-cannot-change-version-of-project-dynamic-web-module-to-3.1-in-Eclipse</a></li>
</ul>
]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>python创建字典的几种方法</title>
    <url>/2019/05/28/python%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="python创建字典的几种方法"><a href="#python创建字典的几种方法" class="headerlink" title="python创建字典的几种方法"></a>python创建字典的几种方法</h1><h2 id="1-创建空字典"><a href="#1-创建空字典" class="headerlink" title="1. 创建空字典"></a>1. 创建空字典</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; type(dic)</span><br><span class="line">&lt;type &apos;dict&apos;&gt;</span><br></pre></td></tr></table></figure>
<p>另一种形式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp = dict()</span><br><span class="line">temp[&apos;name&apos;] = &apos;xiaoming&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-直接赋值创建"><a href="#2-直接赋值创建" class="headerlink" title="2. 直接赋值创建"></a>2. 直接赋值创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = &#123;&apos;spam&apos;:1, &apos;egg&apos;:2, &apos;bar&apos;:3&#125;</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;&apos;bar&apos;: 3, &apos;egg&apos;: 2, &apos;spam&apos;: 1&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-通过关键字dict和关键字参数创建"><a href="#3-通过关键字dict和关键字参数创建" class="headerlink" title="3. 通过关键字dict和关键字参数创建"></a>3. 通过关键字dict和关键字参数创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = dict(spam = 1, egg = 2, bar =3)</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;&apos;bar&apos;: 3, &apos;egg&apos;: 2, &apos;spam&apos;: 1&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="4-通过二元组列表创建"><a href="#4-通过二元组列表创建" class="headerlink" title="4. 通过二元组列表创建"></a>4. 通过二元组列表创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; list = [(&apos;spam&apos;, 1), (&apos;egg&apos;, 2), (&apos;bar&apos;, 3)]</span><br><span class="line">&gt;&gt;&gt; dic = dict(list)</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;&apos;bar&apos;: 3, &apos;egg&apos;: 2, &apos;spam&apos;: 1&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-dict和zip结合创建"><a href="#5-dict和zip结合创建" class="headerlink" title="5. dict和zip结合创建"></a>5. dict和zip结合创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = dict(zip(&apos;abc&apos;, [1, 2, 3]))</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;&apos;a&apos;: 1, &apos;c&apos;: 3, &apos;b&apos;: 2&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-通过字典推导式创建"><a href="#6-通过字典推导式创建" class="headerlink" title="6. 通过字典推导式创建"></a>6. 通过字典推导式创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = &#123;i:2*i for i in range(3)&#125;</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;0: 0, 1: 2, 2: 4&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-通过dict-fromkeys-创建"><a href="#7-通过dict-fromkeys-创建" class="headerlink" title="7. 通过dict.fromkeys()创建"></a>7. 通过dict.fromkeys()创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = dict.fromkeys(range(3), &apos;x&apos;)</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;0: &apos;x&apos;, 1: &apos;x&apos;, 2: &apos;x&apos;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; list = [&apos;x&apos;, 1, &apos;y&apos;, 2, &apos;z&apos;, 3]</span><br><span class="line">&gt;&gt;&gt; dic = dict(zip(list[::2], list[1::2]))</span><br><span class="line">&gt;&gt;&gt; dic</span><br><span class="line">&#123;&apos;y&apos;: 2, &apos;x&apos;: 1, &apos;z&apos;: 3&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript-undefined-description</title>
    <url>/2019/06/11/javascript-undefined-description/</url>
    <content><![CDATA[<h2 id="Javascript-基础拾遗之undefined"><a href="#Javascript-基础拾遗之undefined" class="headerlink" title="Javascript 基础拾遗之undefined"></a>Javascript 基础拾遗之undefined</h2><p>先看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(a)); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>javascript中的数据类型包括<code>undefined</code>，<code>null</code>,<code>boolean</code>,<code>number</code>,<code>string</code>,<code>boolean</code>六种类型(ECMAScript 2015)</p>
<h3 id="undefined-小结"><a href="#undefined-小结" class="headerlink" title="undefined 小结"></a>undefined 小结</h3><p>undefined 类型的意思是当前对象未定义,适用于下面几种情况</p>
<ol>
<li>变量声明,但未赋值</li>
<li>对象没有赋值的属性,该属性的值为undefined</li>
<li>调用函数参数,但是未提供参数，该参数的值为undefined</li>
<li>函数没有返回值时,默认返回undefined</li>
</ol>
<p>再看下面的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(o.p);</span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);    <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="comment">//4.</span></span><br><span class="line">myfunc()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myfunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//console.log("my function.");</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myfunc());</span><br></pre></td></tr></table></figure>
<p>需要区别下面这个情况,不同浏览器提示信息可能会不同(Chrome和IE测试)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>
<h3 id="如何判断为空"><a href="#如何判断为空" class="headerlink" title="如何判断为空"></a>如何判断为空</h3><p>下面三种判断方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> age === <span class="string">'undefined'</span>)</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="keyword">if</span>(age === <span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">// 方式3</span></span><br><span class="line"><span class="keyword">if</span>(varName) <span class="comment">//万能判断,包括boolean</span></span><br></pre></td></tr></table></figure>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener">火狐JavaScript教程</a></p>
<p><a href="https://stackoverflow.com/questions/2559318/how-to-check-for-an-undefined-or-null-variable-in-javascript" target="_blank" rel="noopener">stackoverflow如何检查undefined</a></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title>python操作sqlite3</title>
    <url>/2019/05/28/python%E6%93%8D%E4%BD%9Csqlite3/</url>
    <content><![CDATA[<h2 id="sqlite3-简介"><a href="#sqlite3-简介" class="headerlink" title="sqlite3 简介"></a>sqlite3 简介</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQLite数据库是一款非常小巧的嵌入式开源数据库软件，也就是说</span><br><span class="line">没有独立的维护进程，所有的维护都来自于程序本身。</span><br><span class="line">在python中，使用sqlite3创建数据库的连接，当我们指定的数据库文件不存在的时候</span><br><span class="line">连接对象会自动创建数据库文件；如果数据库文件已经存在，则连接对象不会再创建</span><br><span class="line">数据库文件，而是直接打开该数据库文件。</span><br><span class="line">    连接对象可以是硬盘上面的数据库文件，也可以是建立在内存中的，在内存中的数据库</span><br><span class="line">    执行完任何操作后，都不需要提交事务的(commit)</span><br><span class="line"></span><br><span class="line">    创建在硬盘上面： conn = sqlite3.connect(&apos;c:\\test\\test.db&apos;)</span><br><span class="line">    创建在内存上面： conn = sqlite3.connect(&apos;&quot;memory:&apos;)</span><br><span class="line"></span><br><span class="line">    下面我们一硬盘上面创建数据库文件为例来具体说明：</span><br><span class="line">    conn = sqlite3.connect(&apos;c:\\test\\hongten.db&apos;)</span><br><span class="line">    其中conn对象是数据库链接对象，而对于数据库链接对象来说，具有以下操作：</span><br><span class="line"></span><br><span class="line">        commit()            --事务提交</span><br><span class="line">        rollback()          --事务回滚</span><br><span class="line">        close()             --关闭一个数据库链接</span><br><span class="line">        cursor()            --创建一个游标</span><br><span class="line"></span><br><span class="line">    cu = conn.cursor()</span><br><span class="line">    这样我们就创建了一个游标对象：cu</span><br><span class="line">    在sqlite3中，所有sql语句的执行都要在游标对象的参与下完成</span><br><span class="line">    对于游标对象cu，具有以下具体操作：</span><br><span class="line"></span><br><span class="line">        execute()           --执行一条sql语句</span><br><span class="line">        executemany()       --执行多条sql语句</span><br><span class="line">        close()             --游标关闭</span><br><span class="line">        fetchone()          --从结果中取出一条记录</span><br><span class="line">        fetchmany()         --从结果中取出多条记录</span><br><span class="line">        fetchall()          --从结果中取出所有记录</span><br><span class="line">        scroll()            --游标滚动</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="sqlite3常用操作"><a href="#sqlite3常用操作" class="headerlink" title="sqlite3常用操作"></a>sqlite3常用操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Date    : 2019-03-14 16:10:24</span><br><span class="line"># @Author  : Jeff.Sui (215687736@qq.com)</span><br><span class="line"># @Link    : http://example.org</span><br><span class="line"># @Version : $Id$</span><br><span class="line">import sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(&quot;:memory:&quot;)</span><br><span class="line"></span><br><span class="line">c = con.cursor()</span><br><span class="line"></span><br><span class="line"># Create table</span><br><span class="line">c.execute(&apos;&apos;&apos;CREATE TABLE stocks</span><br><span class="line">             (date text, trans text, symbol text, qty real, price real)&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line"># Insert a row of data</span><br><span class="line">c.execute(&quot;INSERT INTO stocks VALUES (?,?,?,?,?)&quot;, (&apos;2006-03-27&apos;,&apos;BUY&apos;,&apos;RHAT&apos;,100,60.14))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Larger example that inserts many records at a time</span><br><span class="line">purchases = [(&apos;2006-03-28&apos;, &apos;BUY&apos;, &apos;IBM&apos;, 1000, 45.00),</span><br><span class="line">             (&apos;2006-04-05&apos;, &apos;BUY&apos;, &apos;MSFT&apos;, 1000, 72.00),</span><br><span class="line">             (&apos;2006-04-06&apos;, &apos;SELL&apos;, &apos;IBM&apos;, 500, 53.00),</span><br><span class="line">             (&apos;2006-04-07&apos;, &apos;SELL&apos;, &apos;MSFT&apos;, 500, 74.00),</span><br><span class="line">             (&apos;2006-04-08&apos;, &apos;SELL&apos;, &apos;IBM&apos;, 500, 54.00),</span><br><span class="line">             (&apos;2006-04-09&apos;, &apos;SELL&apos;, &apos;MSFT&apos;, 500, 73.00),</span><br><span class="line">             (&apos;2006-04-10&apos;, &apos;SELL&apos;, &apos;MSFT&apos;, 500, 75.00),</span><br><span class="line">             (&apos;2006-04-12&apos;, &apos;SELL&apos;, &apos;IBM&apos;, 500, 55.00),</span><br><span class="line">            ]</span><br><span class="line">c.executemany(&apos;INSERT INTO stocks VALUES (?,?,?,?,?)&apos;, purchases)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Save (commit) the changes</span><br><span class="line">con.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Do this instead</span><br><span class="line">t = (&apos;RHAT&apos;,)</span><br><span class="line">c.execute(&apos;SELECT * FROM stocks WHERE symbol=?&apos;, t)</span><br><span class="line">#print(c.fetchone())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#for row in c.execute(&apos;SELECT * FROM stocks ORDER BY price&apos;):</span><br><span class="line">#    print(row)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">#for row in c.execute(&apos;SELECT * FROM stocks LIMIT 5 OFFSET 0&apos;):</span><br><span class="line">#    print(row)</span><br><span class="line">for row in c.execute(&apos;SELECT * FROM stocks LIMIT 5 OFFSET 1&apos;):</span><br><span class="line">    print(row)</span><br><span class="line">#Select Top N * From</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ====================================================================================</span><br><span class="line"># SQLite 日期 &amp; 时间</span><br><span class="line"># ====================================================================================</span><br><span class="line">print(&apos;=&apos;*30)</span><br><span class="line">print(&apos;SQLite 日期 &amp; 时间&apos;)</span><br><span class="line">print(&apos;=&apos;*30)</span><br><span class="line"></span><br><span class="line"># 计算当前日期</span><br><span class="line">c.execute(&quot;SELECT date(&apos;now&apos;)&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 计算当前月份的最后一天：</span><br><span class="line">c.execute(&quot;SELECT date(&apos;now&apos;,&apos;start of month&apos;,&apos;+1 month&apos;,&apos;-1 day&apos;);&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 计算给定 UNIX 时间戳 1092941466 的日期和时间：</span><br><span class="line">c.execute(&quot;SELECT datetime(1092941466, &apos;unixepoch&apos;);&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 计算给定 UNIX 时间戳 1092941466 相对本地时区的日期和时间：</span><br><span class="line">c.execute(&quot;SELECT datetime(1092941466, &apos;unixepoch&apos;, &apos;localtime&apos;);&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 计算当前的 UNIX 时间戳：</span><br><span class="line">c.execute(&quot;SELECT datetime(1092941466, &apos;unixepoch&apos;, &apos;localtime&apos;);&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 计算美国&quot;独立宣言&quot;签署以来的天数：</span><br><span class="line">c.execute(&quot;SELECT julianday(&apos;now&apos;) - julianday(&apos;1776-07-04&apos;);&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 计算从 2004 年某一特定时刻以来的秒数：</span><br><span class="line">c.execute(&quot;SELECT strftime(&apos;%s&apos;,&apos;now&apos;) - strftime(&apos;%s&apos;,&apos;2004-01-01 02:34:56&apos;);&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 计算当年 10 月的第一个星期二的日期：</span><br><span class="line">c.execute(&quot;SELECT date(&apos;now&apos;,&apos;start of year&apos;,&apos;+9 months&apos;,&apos;weekday 2&apos;);&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 计算从 UNIX 纪元算起的以秒为单位的时间（类似 strftime(&apos;%s&apos;,&apos;now&apos;) ，不同的是这里有包括小数部分）：</span><br><span class="line">c.execute(&quot;SELECT (julianday(&apos;now&apos;) - 2440587.5)*86400.0;&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 在 UTC 与本地时间值之间进行转换，当格式化日期时，使用 utc 或 localtime 修饰符，如下所示：</span><br><span class="line">c.execute(&quot;SELECT time(&apos;12:00&apos;, &apos;localtime&apos;);&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># </span><br><span class="line">c.execute(&quot;SELECT time(&apos;12:00&apos;, &apos;utc&apos;);&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line">con.close()</span><br><span class="line"></span><br><span class="line"># ====================================================================================</span><br><span class="line"># SQLite 常用函数</span><br><span class="line"># ====================================================================================</span><br><span class="line"></span><br><span class="line">print(&apos;=&apos;*30)</span><br><span class="line">print(&apos;SQLite 常用函数&apos;)</span><br><span class="line">print(&apos;=&apos;*30)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(&quot;:memory:&quot;)</span><br><span class="line"></span><br><span class="line">c = con.cursor()</span><br><span class="line"></span><br><span class="line"># Create table</span><br><span class="line">c.execute(&apos;&apos;&apos;CREATE TABLE COMPANY</span><br><span class="line">            (ID integer, NAME text, AGE integer, ADDRESS text, SALARY real)&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line"># Larger example that inserts many records at a time</span><br><span class="line">purchases = [(1,&apos;Paul&apos;,32,&apos;California&apos;,20000.0),</span><br><span class="line">             (2,&apos;Allen&apos;,25,&apos;Texas&apos;,15000.0),</span><br><span class="line">             (3,&apos;Teddy&apos;,23,&apos;Norway&apos;,20000.0),</span><br><span class="line">             (4,&apos;Mark&apos;,25,&apos;Rich-Mond&apos;,65000.0),</span><br><span class="line">             (5,&apos;David&apos;,27,&apos;Texas&apos;,85000.0),</span><br><span class="line">             (6,&apos;Kim&apos;,22,&apos;South-Hall&apos;,45000.0),</span><br><span class="line">             (7,&apos;James&apos;,24,&apos;Houston&apos;,10000.0)]</span><br><span class="line">c.executemany(&apos;INSERT INTO COMPANY VALUES (?,?,?,?,?)&apos;, purchases)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Save (commit) the changes</span><br><span class="line">con.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 返回数据库表最后 n 行记录</span><br><span class="line"># 先计算一个数据库表中的行数</span><br><span class="line">c.execute(&quot;SELECT count(*) FROM COMPANY;&quot;)</span><br><span class="line">last = c.fetchone()[0]</span><br><span class="line">n = 5</span><br><span class="line">c.execute(&quot;SELECT * FROM COMPANY LIMIT ? OFFSET ?;&quot;, (n, last-n))</span><br><span class="line">for row in c:</span><br><span class="line">    print(row)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 计算一个数据库表中的行数</span><br><span class="line">c.execute(&quot;SELECT count(*) FROM COMPANY;&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 选择某列的最大值</span><br><span class="line">c.execute(&quot;SELECT max(salary) FROM COMPANY;&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 选择某列的最小值</span><br><span class="line">c.execute(&quot;SELECT min(salary) FROM COMPANY;&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 计算某列的平均值</span><br><span class="line">c.execute(&quot;SELECT avg(salary) FROM COMPANY;&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 为一个数值列计算总和</span><br><span class="line">c.execute(&quot;SELECT sum(salary) FROM COMPANY;&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 返回一个介于 -9223372036854775808 和 +9223372036854775807 之间的伪随机整数</span><br><span class="line">c.execute(&quot;SELECT random() AS Random;&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 返回数值参数的绝对值</span><br><span class="line">c.execute(&quot;SELECT abs(5), abs(-15), abs(NULL), abs(0), abs(&apos;ABC&apos;);&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 把字符串转换为大写字母</span><br><span class="line">c.execute(&quot;SELECT upper(name) FROM COMPANY;&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 把字符串转换为小写字母</span><br><span class="line">c.execute(&quot;SELECT lower(name) FROM COMPANY;&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 返回字符串的长度</span><br><span class="line">c.execute(&quot;SELECT name, length(name) FROM COMPANY;&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># 返回 SQLite 库的版本</span><br><span class="line">c.execute(&quot;SELECT sqlite_version() AS &apos;SQLite Version&apos;;&quot;)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"># </span><br><span class="line">c.execute(&quot;SELECT CURRENT_TIMESTAMP;&quot;)</span><br><span class="line">print(c.fetchone())</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sqlite3</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium元素操作封装</title>
    <url>/2019/05/28/selenium%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h1 id="selenium-常用的元素定位操作"><a href="#selenium-常用的元素定位操作" class="headerlink" title="selenium 常用的元素定位操作"></a>selenium 常用的元素定位操作</h1><h2 id="Selenium提供了8种定位方式。"><a href="#Selenium提供了8种定位方式。" class="headerlink" title="Selenium提供了8种定位方式。"></a>Selenium提供了8种定位方式。</h2><ul>
<li>id</li>
<li>name</li>
<li>class name</li>
<li>tag name</li>
<li>link text</li>
<li>partial link text</li>
<li>xpath</li>
<li>css selector</li>
</ul>
<h2 id="这8种定位方式在Python-selenium中所对应的方法为："><a href="#这8种定位方式在Python-selenium中所对应的方法为：" class="headerlink" title="这8种定位方式在Python selenium中所对应的方法为："></a>这8种定位方式在Python selenium中所对应的方法为：</h2><ul>
<li><p>find_element_by_id()</p>
</li>
<li><p>find_element_by_name()</p>
</li>
<li><p>find_element_by_class_name()</p>
</li>
<li><p>find_element_by_tag_name()</p>
</li>
<li><p>find_element_by_link_text()</p>
</li>
<li><p>find_element_by_partial_link_text()</p>
</li>
<li><p>find_element_by_xpath()</p>
</li>
<li><p>find_element_by_css_selector()</p>
</li>
</ul>
<a id="more"></a>
<h2 id="常用元素定位封装"><a href="#常用元素定位封装" class="headerlink" title="常用元素定位封装"></a>常用元素定位封装</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_locate_element</span><span class="params">(self, selector)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    to locate element by selector</span></span><br><span class="line"><span class="string">    :arg</span></span><br><span class="line"><span class="string">    selector should be passed by an example with "i,xxx"</span></span><br><span class="line"><span class="string">    "x,//*[@id='langs']/button"</span></span><br><span class="line"><span class="string">    :returns</span></span><br><span class="line"><span class="string">    DOM element</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> self.by_char <span class="keyword">not</span> <span class="keyword">in</span> selector:</span><br><span class="line">        <span class="keyword">return</span> self.base_driver.find_element_by_id(selector)</span><br><span class="line"></span><br><span class="line">    selector_by = selector.split(self.by_char)[<span class="number">0</span>].strip()</span><br><span class="line">    selector_value = selector.split(self.by_char)[<span class="number">1</span>].strip()</span><br><span class="line">    <span class="keyword">if</span> selector_by == <span class="string">"i"</span> <span class="keyword">or</span> selector_by == <span class="string">'id'</span>:</span><br><span class="line">        element = self.base_driver.find_element_by_id(selector_value)</span><br><span class="line">    <span class="keyword">elif</span> selector_by == <span class="string">"n"</span> <span class="keyword">or</span> selector_by == <span class="string">'name'</span>:</span><br><span class="line">        element = self.base_driver.find_element_by_name(selector_value)</span><br><span class="line">    <span class="keyword">elif</span> selector_by == <span class="string">"c"</span> <span class="keyword">or</span> selector_by == <span class="string">'class_name'</span>:</span><br><span class="line">        element = self.base_driver.find_element_by_class_name(selector_value)</span><br><span class="line">    <span class="keyword">elif</span> selector_by == <span class="string">"l"</span> <span class="keyword">or</span> selector_by == <span class="string">'link_text'</span>:</span><br><span class="line">        element = self.base_driver.find_element_by_link_text(selector_value)</span><br><span class="line">    <span class="keyword">elif</span> selector_by == <span class="string">"p"</span> <span class="keyword">or</span> selector_by == <span class="string">'partial_link_text'</span>:</span><br><span class="line">        element = self.base_driver.find_element_by_partial_link_text(selector_value)</span><br><span class="line">    <span class="keyword">elif</span> selector_by == <span class="string">"t"</span> <span class="keyword">or</span> selector_by == <span class="string">'tag_name'</span>:</span><br><span class="line">        element = self.base_driver.find_element_by_tag_name(selector_value)</span><br><span class="line">    <span class="keyword">elif</span> selector_by == <span class="string">"x"</span> <span class="keyword">or</span> selector_by == <span class="string">'xpath'</span>:</span><br><span class="line">        element = self.base_driver.find_element_by_xpath(selector_value)</span><br><span class="line">    <span class="keyword">elif</span> selector_by == <span class="string">"s"</span> <span class="keyword">or</span> selector_by == <span class="string">'css_selector'</span>:</span><br><span class="line">        element = self.base_driver.find_element_by_css_selector(selector_value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> NameError(<span class="string">"Please enter a valid type of targeting elements."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> element</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>web test</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo建站搭建流程</title>
    <url>/2019/05/31/hexo%E5%BB%BA%E7%AB%99%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<ol>
<li><p>下载并安装 Visual Studio Code, <a href="https://www.visualstudio.com/" target="_blank" rel="noopener">官方下载</a></p>
</li>
<li><p>下载并安装 Nodejs, <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">官方下载</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>npm 镜像源修改为 淘宝NPM镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载并安装 Git, <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">官方下载</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#配置名字和邮箱</span><br><span class="line">git config --global user.name &quot;test&quot;</span><br><span class="line">git config --global user.email &quot;test@.com&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>安装 Hexo, <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p>初始化博客目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd D</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">cnpm install</span><br></pre></td></tr></table></figure>
<p>启动服务器,本地预览</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<ol start="5">
<li><p>Hexo 常用站点配置_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#网站标题</span><br><span class="line">title: test</span><br><span class="line">#作者昵称</span><br><span class="line">author: test</span><br><span class="line">#站点描述[签名]</span><br><span class="line">description: 站点描述</span><br><span class="line">#网站地址</span><br><span class="line">url: http://www.test.com</span><br><span class="line">#文章的链接格式</span><br><span class="line">permalink: :title.html</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#生成文件路径 source/tags/index.md</span><br><span class="line">hexo new page tags</span><br><span class="line">#编辑index.md,添加type</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#生成文件路径 source/categories/index.md</span><br><span class="line">hexo new page categories</span><br><span class="line">#编辑index.md,添加type</span><br><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文章添加标签与分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - hexo</span><br><span class="line">tags:</span><br><span class="line">  - hexo</span><br><span class="line">  - github</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置阅读全文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在文章中使用 &lt;!-- more --&gt; 手动截断 </span><br><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Hexo 主题,这里选择 <strong>Next</strong>, <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Github地址</a> <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">文档</a><br>安装 Next 主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>启用主题并设置语言,站点配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure>
<p>主题常用配置,themes/next/_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#主题外观设定</span><br><span class="line">scheme: Gemini</span><br><span class="line">#设置菜单</span><br><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">#设置代码高亮主题</span><br><span class="line">highlight_theme: night eighties</span><br><span class="line">#添加友情链接</span><br><span class="line">links:</span><br><span class="line">  test: http://www.test.com</span><br><span class="line">#文章自动添加版权声明</span><br><span class="line">post_copyright:</span><br><span class="line">  enable: true</span><br><span class="line">#返回顶部按钮显示百分比</span><br><span class="line">sidebar:</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>
<p>设置RSS,安装<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
<p>安装hexo-generator-searchdb,添加百度/谷歌/本地 自定义站点内容搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>启用搜索,主题配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<p>配置搜索,站点配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 7777</span><br></pre></td></tr></table></figure>
<p>设置favicon.ico,将favicon.ico上传至站点根目录/source 目录下,主题配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: favicon.ico</span><br><span class="line">  medium: favicon.ico</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署Hexo至Github<br>安装 hexo-deployer-git</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>站点配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/github账号/github账号.github.io.git</span><br></pre></td></tr></table></figure>
<p>生成并部署</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>Github 自定义域名,由于Hexo每次部署到Github都会覆盖Github的域名配置,所以直接在Hexo配置,然后再部署,在根目录下的source目录下新建CNAME文件,无后缀名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#自定义域名</span><br><span class="line">xxx.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析域名到 github.io,记录类型 = CNAME, 记录值 = github账号.github.io</p>
</li>
<li><p>码云新建一个项目, 路径 <a href="https://gitee.com/test/test.git" target="_blank" rel="noopener">https://gitee.com/test/test.git</a></p>
</li>
<li><p>Hexo 目录说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.deploy_git Hexo默认的.git配置文件夹</span><br><span class="line">public 根据source文件夹内容自动生成</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入 Hexo根目录,执行以下命令,先删除 themes/next 目录下的 .gitignore 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#初始化仓库</span><br><span class="line">git init</span><br><span class="line">#添加远程主机</span><br><span class="line">git remote add origin https://gitee.com/test/test.git</span><br><span class="line">#添加目录下所有文件,不包含 .gitignore 声明的文件</span><br><span class="line">git add .</span><br><span class="line">#添加更新说明</span><br><span class="line">git commit -m &quot;hexo first commit&quot;</span><br><span class="line">#推送更新到云端服务器</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 test 目录,将 Git 的内容同步到本地并安装Hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">cd test</span><br><span class="line">git init</span><br><span class="line">git remote add origin https://gitee.com/test/test.git</span><br><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br><span class="line">cnpm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>blog 目录是A电脑, test 目录是B电脑, 更新文章后的同步操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#A电脑修改了 test.md,添加更新说明并推送到远程仓库,使用git status查看状态会显示刚刚更改过的文件状态</span><br><span class="line">git commit -m &quot;update test.md&quot;</span><br><span class="line">git push origin master</span><br><span class="line">git status</span><br><span class="line">#B电脑同步更新</span><br><span class="line">git pull origin master</span><br><span class="line">#可以通过指定当前目录工作分支与远程仓库分支之间的链接关系</span><br><span class="line">git branch --set-upstream-to=origin/master master</span><br></pre></td></tr></table></figure>
</li>
<li><p>hexo 数据文件,通用配置文件,新建 source/_data 目录, 主题的配置可以在此目录下配置,以 Next 主题为例,在此目录下新建 next.yml, 则 next.yml 的配置会覆盖 themes/next/_config.yml 的相同配置</p>
</li>
</ol>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title>使用selenium访问爱奇艺网站</title>
    <url>/2019/05/28/using-selenium-visit-iqiyi-website/</url>
    <content><![CDATA[<h1 id="使用selenium访问爱奇艺网站"><a href="#使用selenium访问爱奇艺网站" class="headerlink" title="使用selenium访问爱奇艺网站"></a>使用<code>selenium</code>访问爱奇艺网站</h1><blockquote>
<p>selenium 是一种常用的自动化测试工具。它支持各种浏览器，包括 Chrome，Safari，Firefox 等主流界面式浏览器，如果你在这些浏览器里面安装一个 Selenium 的插件，还可以通过录制，快速生成脚本。</p>
<p>selenium 支持多种主流的开发语言，比如<code>Ruby</code>，<code>java</code>，<code>python</code>，<code>javascript</code>。</p>
</blockquote>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>python3.7.3</p>
<p>运行 <code>pip install selenium</code> 就可以直接下载最新的selenium版本</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>浏览器:chrome 70.0.3538.77 </p>
<p>操作系统：win7</p>
<p>selenium版本: 3.14.1</p>
<p>chromedriver: <a href="https://npm.taobao.org/mirrors/chromedriver/70.0.3538.97/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/chromedriver/70.0.3538.97/</a></p>
<h2 id="使用selenium-打开和关闭浏览器"><a href="#使用selenium-打开和关闭浏览器" class="headerlink" title="使用selenium 打开和关闭浏览器"></a>使用selenium 打开和关闭浏览器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"http://www.iqiyi.com/"</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="定位搜索框"><a href="#定位搜索框" class="headerlink" title="定位搜索框"></a>定位搜索框</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">search_xpath=<span class="string">r"//*[@id='nav_searchboxIn']/input"</span></span><br><span class="line">driver.find_element_by_xpath(search_xpath).send_keys(<span class="string">"复仇者联盟"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="点击搜索图片"><a href="#点击搜索图片" class="headerlink" title="点击搜索图片"></a>点击搜索图片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">search_button=<span class="string">r"//*[@id='nav_searchboxOut']/span"</span></span><br><span class="line">driver.find_element_by_xpath(search_button).click()</span><br></pre></td></tr></table></figure>
<h2 id="切换tab页"><a href="#切换tab页" class="headerlink" title="切换tab页"></a>切换tab页</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入键盘操作--20190528更新</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="comment">#此处通过键盘操作切换tab页</span></span><br><span class="line">driver.find_element_by_tag_name(<span class="string">"body"</span>).send_keys(Keys.CONTROL + <span class="string">"t"</span>)</span><br><span class="line"><span class="comment">#all_handles 保存所有已经打开的tab窗体</span></span><br><span class="line">all_handles = driver.window_handles</span><br><span class="line">print(driver.window_handles)</span><br><span class="line">index_handle=driver.current_window_handle</span><br><span class="line">print(index_handle)</span><br><span class="line"><span class="comment">#用switch_to方法切换到tab窗体</span></span><br><span class="line"><span class="keyword">for</span> handle <span class="keyword">in</span> all_handles:</span><br><span class="line">    <span class="keyword">if</span> handle!=index_handle:</span><br><span class="line">        print(<span class="string">'now is search window'</span>)</span><br><span class="line">        search_handle = handle</span><br><span class="line">driver.switch_to.window(search_handle)</span><br></pre></td></tr></table></figure>
<h2 id="打印页面的title，并截图"><a href="#打印页面的title，并截图" class="headerlink" title="打印页面的title，并截图"></a>打印页面的<code>title</code>，并截图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(driver.title)</span><br><span class="line">driver.get_screenshot_as_file(<span class="string">"aqiyi.png"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了自动化工具<code>selenium</code>的基本使用，如何对页面元素进行基本操作，实现自动抓取关键字图片功能。</p>
]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>web test</tag>
      </tags>
  </entry>
  <entry>
    <title>how to Sort Python Dictionaries by Key or Value</title>
    <url>/2019/07/28/how-to-Sort-Python-Dictionaries-by-Key-or-Value/</url>
    <content><![CDATA[<blockquote>
<p>众所周知,python中字典是无序的,那么该如何对字典排序呢？</p>
</blockquote>
<p>例如下面的字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = &#123;<span class="string">'second'</span>: <span class="number">2</span>,<span class="string">'first'</span>: <span class="number">1</span>,  <span class="string">'third'</span>: <span class="number">3</span>, <span class="string">'Fourth'</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过list()函数打印value,<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;list(numbers)</span><br><span class="line">[<span class="string">'second'</span>, <span class="string">'first'</span>, <span class="string">'third'</span>, <span class="string">'Fourth'</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>备注</strong>: </p>
<blockquote>
<p>python3.6.4 以上的版本,字典根据插入的顺序自动排序</p>
</blockquote>
<h3 id="如何根据key-对字典排序"><a href="#如何根据key-对字典排序" class="headerlink" title="如何根据key 对字典排序"></a>如何根据key 对字典排序</h3><p>可以使用python的内置函数<code>sorted</code> 来对字典排序,如下面的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(numbers)</span><br><span class="line">[<span class="string">'Fourth'</span>, <span class="string">'first'</span>, <span class="string">'second'</span>, <span class="string">'third'</span>]</span><br></pre></td></tr></table></figure>
<p>结果有点差强人意,因为默认<code>sorted</code>函数是根据字母的顺序升序排列的,这里的字典中 key 恰好是字母，所以才会显示这个结果。</p>
<h3 id="根据value对字典排序"><a href="#根据value对字典排序" class="headerlink" title="根据value对字典排序"></a>根据value对字典排序</h3><p>用同样的方法,我们可以根据value来排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(numbers.values())</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="如何根据自定义的规则对字典排序"><a href="#如何根据自定义的规则对字典排序" class="headerlink" title="如何根据自定义的规则对字典排序"></a>如何根据自定义的规则对字典排序</h2><p><code>sorted</code>函数还有一个可选参数叫key,注意这里的<code>key</code>和字典的<code>key</code>没有关系,根据指定的<code>key</code> 来进行排序,实现的机制类似迭代器。来看这个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(numbers,key=numbers.__getitem__)</span><br><span class="line">[<span class="string">'first'</span>, <span class="string">'second'</span>, <span class="string">'third'</span>, <span class="string">'Fourth'</span>]</span><br></pre></td></tr></table></figure>
<p>这里我们使用了字典类中内置函数<code>__getitem__</code> 在遍历字典值的过程中,获取对应的值来对字典排序</p>
<p>关于<code>__getitem__</code> 函数的详细说明，请参考官方文档。</p>
<p>当然我们也可以使用<a href="https://www.pythoncentral.io/list-comprehension-in-python/" target="_blank" rel="noopener">列表推导</a>的方式来进行排序(实质上是转化成了列表来进行排序)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(numbers,key=numbers.__getitem__,reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">'Fourth'</span>, <span class="string">'third'</span>, <span class="string">'second'</span>, <span class="string">'first'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[value <span class="keyword">for</span> (key,value) <span class="keyword">in</span> sorted(numbers.items(),reverse=<span class="literal">True</span>)]</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h3 id="字典的key是数字或者字母的情况下对字典排序"><a href="#字典的key是数字或者字母的情况下对字典排序" class="headerlink" title="字典的key是数字或者字母的情况下对字典排序"></a>字典的key是数字或者字母的情况下对字典排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(numbers,key=str.lower)</span><br><span class="line">[<span class="string">'first'</span>, <span class="string">'Fourth'</span>, <span class="string">'second'</span>, <span class="string">'third'</span>]</span><br></pre></td></tr></table></figure>
<p>我们定义一个新的字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>month = dict(one=<span class="string">'January'</span>,</span><br><span class="line">                 two=<span class="string">'February'</span>,</span><br><span class="line">                 three=<span class="string">'March'</span>,</span><br><span class="line">                 four=<span class="string">'April'</span>,</span><br><span class="line">                 five=<span class="string">'May'</span>)</span><br></pre></td></tr></table></figure>
<p>通过<code>__getitem__</code>方法比较 我们定义的字典month中对应的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbermap = &#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'four'</span>: <span class="number">4</span>, <span class="string">'five'</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(month, key=numbermap.__getitem__)</span><br><span class="line">[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>]</span><br></pre></td></tr></table></figure>
<p>同样的原理,可以使用列表推导来实现排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[month[i] <span class="keyword">for</span> i <span class="keyword">in</span> sorted(month,key=numbermap.__getitem__)]</span><br><span class="line">[<span class="string">'January'</span>, <span class="string">'February'</span>, <span class="string">'March'</span>, <span class="string">'April'</span>, <span class="string">'May'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="定义一个方法来定义我们自己的排序规则"><a href="#定义一个方法来定义我们自己的排序规则" class="headerlink" title="定义一个方法来定义我们自己的排序规则"></a>定义一个方法来定义我们自己的排序规则</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeats</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="comment"># Lower the case in the string</span></span><br><span class="line">    string = string.lower()</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Get a set of the unique letters</span></span><br><span class="line">    uniques = set(string)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Count the max occurrences of each unique letter</span></span><br><span class="line">    counts = [string.count(letter) <span class="keyword">for</span> letter <span class="keyword">in</span> uniques]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> max(counts)</span><br></pre></td></tr></table></figure>
<p>根据字母小写排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(month.values(), key=repeats, reverse=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">'February'</span>, <span class="string">'January'</span>, <span class="string">'March'</span>, <span class="string">'April'</span>, <span class="string">'May'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="使用lambda表达式排序"><a href="#使用lambda表达式排序" class="headerlink" title="使用lambda表达式排序"></a>使用lambda表达式排序</h3><p>使用lambda表达式  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(month.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">[(<span class="string">'four'</span>, <span class="string">'April'</span>), (<span class="string">'two'</span>, <span class="string">'February'</span>), (<span class="string">'one'</span>, <span class="string">'January'</span>), (<span class="string">'three'</span>, <span class="string">'March'</span>), (<span class="string">'five'</span>, <span class="string">'May'</span>)]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(month.items(),key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">[(<span class="string">'five'</span>, <span class="string">'May'</span>), (<span class="string">'four'</span>, <span class="string">'April'</span>), (<span class="string">'one'</span>, <span class="string">'January'</span>), (<span class="string">'three'</span>, <span class="string">'March'</span>), (<span class="string">'two'</span>, <span class="string">'February'</span>)]</span><br></pre></td></tr></table></figure>
<p>其中： </p>
<ul>
<li>lambda x:x[1] 表明根据值排序 </li>
<li>lambda x:x[0] 表明根据键排序 </li>
</ul>
<p>以上就是python中对字典排序的一个总结,希望能帮到大家。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>dict</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>how to add 163 music to hexo</title>
    <url>/2019/09/06/how-to-add-163-music-to-hexo/</url>
    <content><![CDATA[<h2 id="如何给hexo添加网易音乐"><a href="#如何给hexo添加网易音乐" class="headerlink" title="如何给hexo添加网易音乐"></a>如何给hexo添加网易音乐</h2><h2 id="先看看效果"><a href="#先看看效果" class="headerlink" title="先看看效果"></a>先看看效果</h2><p><img src="https://i.loli.net/2019/09/06/3W96u4wDtHpeAa7.png" alt="博客添加网易音乐.png"></p>
<h3 id="1-访问网易云首页，选择你喜欢的音乐，点击生成外链-我不希望音乐一直播放-如果来访的朋友想听-点击下播放就好。"><a href="#1-访问网易云首页，选择你喜欢的音乐，点击生成外链-我不希望音乐一直播放-如果来访的朋友想听-点击下播放就好。" class="headerlink" title="1.访问网易云首页，选择你喜欢的音乐，点击生成外链,我不希望音乐一直播放,如果来访的朋友想听,点击下播放就好。"></a>1.访问网易云首页，选择你喜欢的音乐，点击生成外链,我不希望音乐一直播放,如果来访的朋友想听,点击下播放就好。</h3><blockquote>
<p>这里我选择二十岁的某一天</p>
</blockquote>
<a id="more"></a>
<h3 id="2-复制iframe插件下的src里的地址"><a href="#2-复制iframe插件下的src里的地址" class="headerlink" title="2. 复制iframe插件下的src里的地址"></a>2. 复制iframe插件下的src里的地址</h3><p><img src="https://i.loli.net/2019/09/06/5y4bDzKHTVpAJGF.png" alt="外链地址网易音乐.png"></p>
<h3 id="3-修改themes-next-layout-sidebar-swig文件"><a href="#3-修改themes-next-layout-sidebar-swig文件" class="headerlink" title="3. 修改themes/next/layout/sidebar.swig文件"></a>3. 修改themes/next/layout/sidebar.swig文件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.background_music %&#125;</span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"210"</span> <span class="attr">height</span>=<span class="string">"110"</span> <span class="attr">src</span>=<span class="string">"&#123;&#123; theme.background_music &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-添加音乐地址到主题"><a href="#4-添加音乐地址到主题" class="headerlink" title="4.添加音乐地址到主题"></a>4.添加音乐地址到主题</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">background_music :</span> <span class="string">//music.163.com/outchain/player?type=2&amp;id=247172&amp;auto=1&amp;height=66</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>网易音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中Boolean_Object与Boolean_Primitives</title>
    <url>/2019/09/20/javascript%E4%B8%ADBoolean-Object%E4%B8%8EBoolean-Primitives/</url>
    <content><![CDATA[<p>先看下面的脚本，预测下结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(flag));<span class="comment">//boolean</span></span><br><span class="line"><span class="keyword">var</span> fa = <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(fa));<span class="comment">//boolean</span></span><br><span class="line"><span class="keyword">var</span> ff = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(ff)); <span class="comment">//Object</span></span><br></pre></td></tr></table></figure>
<p>在 jslint中明确提示 new Boolean(true)；<code>do not use Boolean as a constructor. (W053)jshint(W053)</code></p>
<p>接下来的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"true is true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fa)&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"Boolean is  true"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ff)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Object Boolean is true"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> is <span class="literal">true</span></span><br><span class="line"><span class="built_in">Boolean</span> is  <span class="literal">true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="built_in">Boolean</span> is <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>修改脚本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">false</span>));<span class="comment">//boolean</span></span><br><span class="line"><span class="keyword">var</span> fa = <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(fa));<span class="comment">//boolean</span></span><br><span class="line"><span class="keyword">var</span> ff = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(ff)); <span class="comment">//Object</span></span><br></pre></td></tr></table></figure>
<p>结果竟然显示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="built_in">Boolean</span> is <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>后来查阅资料发现,</p>
<p>JavaScript的其他数据类型都可以转换成Boolean类型，注意！！！<strong>只有这几种类型会转换为false</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">-0</span></span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="string">""</span>  (空字符串)</span><br></pre></td></tr></table></figure>
<p>其他都转化为true,包括空对象{}，空数组[] ， 负数 ，false的对象包装等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">-1</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'-1转换为true'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(&#123;&#125;)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'&#123;&#125;转换为true'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>([])&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[]转换为true'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'new Boolean(false)转换为true'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new Boolean(false)是布尔值的包装对象    <strong>typeof (new Boolean(false))  // ‘object’</strong>  ,所以 转换为boolean是true，而不是false。</p>
<p>从另一个层面也证明了为啥<code>jslint</code> 禁止在构造方法里使用Boolean类型的数据。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>Boolean.valueOf() 可以返回Boolean对象对应的值类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="comment">if(ff.valueOf())&#123;</span></span><br><span class="line"><span class="comment">     console.log("Object Boolean is true");</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>对于数字<code>0</code> 连续使用两次!! 仍旧返回false.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fa = <span class="built_in">Boolean</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fa); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="number">0</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol>
<li><p><a href="https://www.cnblogs.com/shapeY/p/7609593.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/shapeY/p/7609593.html" target="_blank" rel="noopener">JavaScript Boolean( new Boolean(false) ) 其实是true</a></a></p>
</li>
<li><p><a href="http://adripofjavascript.com/blog/drips/the-difference-between-boolean-objects-and-boolean-primitives-in-javascript.html" target="_blank" rel="noopener">The Difference Between Boolean Objects and Boolean Primitives in JavaScript</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>Boolean</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript get checkbox checked value</title>
    <url>/2019/09/28/javascript-get-checkbox-checked-value/</url>
    <content><![CDATA[<h1 id="javascript如何获取checkbox被选中的值"><a href="#javascript如何获取checkbox被选中的值" class="headerlink" title="javascript如何获取checkbox被选中的值"></a>javascript如何获取checkbox被选中的值</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>javascript dom 常用方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>document.getElementById</td>
<td>返回给定id属性值的元素节点相对应的对象</td>
<td><input type="checkbox" name="hobbies" id="hobbies"></td>
</tr>
<tr>
<td>document.getElementsByTagName</td>
<td>返回给定name属性的元素节点对应的元素集合</td>
<td>var hobbies = document.getElementsByName(“hobbies”);</td>
</tr>
<tr>
<td>element.nextSibling</td>
<td>返回该元素紧跟的一个节点</td>
<td></td>
</tr>
<tr>
<td>nodeValue</td>
<td>获取节点中的文本值 ,例如：跑步</td>
<td><input type="checkbox" name="hobbies" id="hobbies" class="hobbies" value="2">跑步</td>
</tr>
</tbody>
</table>
<p>数组常用方法：</p>
<table>
<thead>
<tr>
<th>方法 或者 属性</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>arrayObject.length</td>
<td>属性：数组长度</td>
<td></td>
</tr>
<tr>
<td>arrayObject.push()</td>
<td>向数组末尾添加一个或多个元素</td>
<td>var arr = new Array(3) <br>arr[0] = “George” <br>arr[1] = “John” <br>arr[2] = “Thomas”</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="页面如下："><a href="#页面如下：" class="headerlink" title="页面如下："></a>页面如下：</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>javascript获取复选框值方法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobbies"</span> <span class="attr">id</span>=<span class="string">"hobbies"</span> <span class="attr">class</span>=<span class="string">"hobbies"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>游泳</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobbies"</span> <span class="attr">id</span>=<span class="string">"hobbies"</span> <span class="attr">class</span>=<span class="string">"hobbies"</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>跑步</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn1"</span>&gt;</span>获取复选框值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><blockquote>
<p>通过复选框的name属性,遍历后将被选中的复选框的值输出</p>
<p><strong>checkbox[index].nextSibling.nodeValue</strong>: 获取的是checkbox中标签包裹的文本值 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_checkbox_val</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> hobbies = <span class="built_in">document</span>.getElementsByName(<span class="string">"hobbies"</span>);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; hobbies.length; index++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (hobbies[index].checked) &#123;</span><br><span class="line">                  alert(hobbies[index].value + <span class="string">","</span> + hobbies[index].nextSibling.nodeValue);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><blockquote>
<p>建立一个数组,使用<code>push</code>方法将被选中的元素保存到数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_checkbox_val_with_array</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> arr = [];</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; hobbies.length; index++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (hobbies[index].checked) &#123;</span><br><span class="line">                  arr.push(hobbies[index].value);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          alert(arr);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><blockquote>
<p>通过class选择器 获取被选中的复选框的值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_checkbox_val_with_selector</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> hobbies = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'hobbies'</span>);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; hobbies.length; index++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (hobbies[index].checked) &#123;</span><br><span class="line">                 checkedValue = hobbies[index].value;</span><br><span class="line">                 alert(hobbies[index].value + <span class="string">","</span> + hobbies[index].nextSibling.nodeValue);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用jquery"><a href="#使用jquery" class="headerlink" title="使用jquery"></a>使用jquery</h3><blockquote>
<p>需要引入jquery,这里我使用国内的cdn</p>
<p>jquery中通过each() 方法遍历所有被选中的复选框的值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">         $('#btn1').click(function () &#123;</span></span><br><span class="line"><span class="regexp">            $("input[name='hobbies']:checked").each(function () &#123;</span></span><br><span class="line"><span class="regexp">                alert($(this).val());</span></span><br><span class="line"><span class="regexp">            &#125;);</span></span><br><span class="line"><span class="regexp">        &#125;);</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">     </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>==tips== :  </p>
<ul>
<li>$(“input[name=’xxxx’]:checked”) 被选中的复选框对象集合</li>
</ul>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>checkbox</tag>
      </tags>
  </entry>
  <entry>
    <title>git diff usage</title>
    <url>/2019/11/21/git-diff-usage/</url>
    <content><![CDATA[<h1 id="Git-中-diff-命令使用"><a href="#Git-中-diff-命令使用" class="headerlink" title="Git 中 diff 命令使用"></a>Git 中 diff 命令使用</h1><p>整理总结工作中常用的<code>git</code> 命令, 今天是一个非常有用的命令 <code>git diff</code></p>
<p>主要作用是用来比较差异，包括 <code>commits</code>之间,<code>commit</code> 和 工作区间 差异 </p>
<p>命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff [&lt;options&gt;] [&lt;commit&gt;] [--] [&lt;path&gt;…​]</span><br><span class="line">git diff [&lt;options&gt;] --cached [&lt;commit&gt;] [--] [&lt;path&gt;…​]</span><br><span class="line">git diff [&lt;options&gt;] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…​]</span><br><span class="line">git diff [&lt;options&gt;] &lt;blob&gt; &lt;blob&gt;</span><br><span class="line">git diff [&lt;options&gt;] --no-index [--] &lt;path&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure>
<h2 id="1-比较工作区与暂存区"><a href="#1-比较工作区与暂存区" class="headerlink" title="1. 比较工作区与暂存区"></a>1. 比较工作区与暂存区</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff 不加参数</span><br></pre></td></tr></table></figure>
<h2 id="2-比较暂存区与-本地-最新版本-最后一次commit"><a href="#2-比较暂存区与-本地-最新版本-最后一次commit" class="headerlink" title="2. 比较暂存区与 本地 最新版本 (最后一次commit)"></a>2. 比较暂存区与 本地 最新版本 (最后一次commit)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure>
<h2 id="3-比较工作区与最新本地版本库"><a href="#3-比较工作区与最新本地版本库" class="headerlink" title="3. 比较工作区与最新本地版本库"></a>3. 比较工作区与最新本地版本库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure>
<h2 id="4-比较工作区与commit-id的差异"><a href="#4-比较工作区与commit-id的差异" class="headerlink" title="4. 比较工作区与commit-id的差异"></a>4. 比较工作区与commit-id的差异</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff commit-id</span><br></pre></td></tr></table></figure>
<h2 id="5-比较暂存区与指定commit-id的差异"><a href="#5-比较暂存区与指定commit-id的差异" class="headerlink" title="5. 比较暂存区与指定commit-id的差异"></a>5. <strong>比较暂存区与指定commit-id的差异</strong></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --cached commit-id</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="6-比较两个commit-id之间的差异"><a href="#6-比较两个commit-id之间的差异" class="headerlink" title="6. 比较两个commit-id之间的差异"></a>6. <strong>比较两个commit-id之间的差异</strong></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff commit-id commit-id</span><br></pre></td></tr></table></figure>
<h2 id="7-比较不同本地分支的差异"><a href="#7-比较不同本地分支的差异" class="headerlink" title="7.  比较不同本地分支的差异"></a>7.  比较不同本地分支的差异</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff dev # 当前所处分支为master</span><br></pre></td></tr></table></figure>
<h2 id="8-比较本地分支和远程分支之间的差异"><a href="#8-比较本地分支和远程分支之间的差异" class="headerlink" title="8. 比较本地分支和远程分支之间的差异"></a>8. 比较本地分支和远程分支之间的差异</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch origin master</span><br><span class="line">git diff master origin/master</span><br></pre></td></tr></table></figure>
<h2 id="9-比较差异只显示文件名"><a href="#9-比较差异只显示文件名" class="headerlink" title="9. 比较差异只显示文件名"></a>9. 比较差异只显示文件名</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --name-only</span><br></pre></td></tr></table></figure>
<h2 id="10-比较差异-显示更改文件状态"><a href="#10-比较差异-显示更改文件状态" class="headerlink" title="10 . 比较差异 显示更改文件状态"></a>10 . 比较差异 显示更改文件状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --name-status</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>版本管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>ios devices list</title>
    <url>/2019/12/02/ios-devices-list/</url>
    <content><![CDATA[<h1 id="ios-设备一览表"><a href="#ios-设备一览表" class="headerlink" title="ios 设备一览表"></a>ios 设备一览表</h1><h2 id="iPhone"><a href="#iPhone" class="headerlink" title="iPhone"></a>iPhone</h2><table>
<thead>
<tr>
<th>设备</th>
<th>时间</th>
<th>CPU</th>
<th>分辨率</th>
<th>大小</th>
<th>密度</th>
<th>@Nx</th>
<th>iOS系统</th>
</tr>
</thead>
<tbody>
<tr>
<td>iPhone</td>
<td>2007</td>
<td>armv6</td>
<td>320 x 480</td>
<td>3.5</td>
<td>165</td>
<td>@1x</td>
<td>1.0 - 3.1.3</td>
</tr>
<tr>
<td>iPhone 3G</td>
<td>2008</td>
<td>armv6</td>
<td>320 x 480</td>
<td>3.5</td>
<td>165</td>
<td>@1x</td>
<td>2.0 - 4.2.1</td>
</tr>
<tr>
<td>iPhone 3GS</td>
<td>2009</td>
<td>armv7</td>
<td>320 x 480</td>
<td>3.5</td>
<td>165</td>
<td>@1x</td>
<td>3.0 - 6.1.4</td>
</tr>
<tr>
<td>iPhone 4 (GSM)</td>
<td>2010</td>
<td>armv7</td>
<td>640 x 960</td>
<td>3.5</td>
<td>330</td>
<td>@2x</td>
<td>4.0 - 7.1.2</td>
</tr>
<tr>
<td>iPhone 4 (CDMA)</td>
<td>2011</td>
<td>armv7</td>
<td>640 x 960</td>
<td>3.5</td>
<td>330</td>
<td>@2x</td>
<td>4.2.4 - 7.1.2</td>
</tr>
<tr>
<td>iPhone 4S</td>
<td>2011</td>
<td>armv7</td>
<td>640 x 960</td>
<td>3.5</td>
<td>330</td>
<td>@2x</td>
<td>5.0 - 9.3.5</td>
</tr>
<tr>
<td>iPhone 5</td>
<td>2012</td>
<td>armv7s</td>
<td>640 x 1136</td>
<td>4</td>
<td>326</td>
<td>@2x</td>
<td>6.0 - 10.3.3</td>
</tr>
<tr>
<td>iPhone 5c</td>
<td>2013</td>
<td>armv7s</td>
<td>640 x 1136</td>
<td>4</td>
<td>326</td>
<td>@2x</td>
<td>7.0 - 10.3.3</td>
</tr>
<tr>
<td>iPhone 5s</td>
<td>2013</td>
<td>arm64</td>
<td>640 x 1136</td>
<td>4</td>
<td>326</td>
<td>@2x</td>
<td>7.0 -</td>
</tr>
<tr>
<td>iPhone 6</td>
<td>2014</td>
<td>arm64</td>
<td>750 x 1334</td>
<td>4.7</td>
<td>326</td>
<td>@2x</td>
<td>8.0 -</td>
</tr>
<tr>
<td>iPhone 6 Plus</td>
<td>2014</td>
<td>arm64</td>
<td>1242 x 2208</td>
<td>5.5</td>
<td>461</td>
<td>@3x</td>
<td>8.0 -</td>
</tr>
<tr>
<td>iPhone 6s</td>
<td>2015</td>
<td>arm64</td>
<td>750 x 1334</td>
<td>4.7</td>
<td>326</td>
<td>@2x</td>
<td>9.0 -</td>
</tr>
<tr>
<td>iPhone 6s Plus</td>
<td>2015</td>
<td>arm64</td>
<td>1242 x 2208</td>
<td>5.5</td>
<td>461</td>
<td>@3x</td>
<td>9.0 -</td>
</tr>
<tr>
<td>iPhone SE</td>
<td>2016</td>
<td>arm64</td>
<td>640 x 1136</td>
<td>4</td>
<td>326</td>
<td>@2x</td>
<td>9.3 -</td>
</tr>
<tr>
<td>iPhone 7</td>
<td>2016</td>
<td>arm64</td>
<td>750 x 1334</td>
<td>4.7</td>
<td>326</td>
<td>@2x</td>
<td>10.0 -</td>
</tr>
<tr>
<td>iPhone 7 Plus</td>
<td>2016</td>
<td>arm64</td>
<td>1242 x 2208</td>
<td>5.5</td>
<td>461</td>
<td>@3x</td>
<td>10.0 -</td>
</tr>
<tr>
<td>iPhone 8</td>
<td>2017</td>
<td>arm64</td>
<td>750 x 1334</td>
<td>4.7</td>
<td>326</td>
<td>@2x</td>
<td>11.0 -</td>
</tr>
<tr>
<td>iPhone 8 Plus</td>
<td>2017</td>
<td>arm64</td>
<td>1242 x 2208</td>
<td>5.5</td>
<td>461</td>
<td>@3x</td>
<td>11.0 -</td>
</tr>
<tr>
<td>iPhone X</td>
<td>2017</td>
<td>arm64</td>
<td>1125 x 2436</td>
<td>5.8</td>
<td>463</td>
<td>@3x</td>
<td>11.0 -</td>
</tr>
<tr>
<td>iPhone XS</td>
<td>2018</td>
<td>arm64</td>
<td>1125 x 2436</td>
<td>5.8</td>
<td>463</td>
<td>@3x</td>
<td>12.0 -</td>
</tr>
<tr>
<td>iPhone XS Max</td>
<td>2018</td>
<td>arm64</td>
<td>1242 x 2688</td>
<td>6.5</td>
<td>458</td>
<td>@3x</td>
<td>12.0 -</td>
</tr>
<tr>
<td>iPhone XR</td>
<td>2018</td>
<td>arm64</td>
<td>828 x 1792</td>
<td>6.1</td>
<td>326</td>
<td>@2x</td>
<td>12.0 -</td>
</tr>
<tr>
<td>iPhone 11</td>
<td>2019</td>
<td>arm64</td>
<td>828 x 1792</td>
<td>6.1</td>
<td>326</td>
<td>@2x</td>
<td>13.0 -</td>
</tr>
<tr>
<td>iPhone 11 Pro</td>
<td>2019</td>
<td>arm64</td>
<td>1125 x 2436</td>
<td>5.8</td>
<td>458</td>
<td>@3x</td>
<td>13.0 -</td>
</tr>
<tr>
<td>iPhone 11 Pro Max</td>
<td>2019</td>
<td>arm64</td>
<td>1242 x 2688</td>
<td>6.5</td>
<td>458</td>
<td>@3x</td>
<td>13.0 -</td>
</tr>
</tbody>
</table>
<p>注：屏幕分辨率单位为英寸(inch)，分辨率密度单位为ppi</p>
<a id="more"></a>
<h2 id="iPad"><a href="#iPad" class="headerlink" title="iPad"></a>iPad</h2><table>
<thead>
<tr>
<th>设备</th>
<th>发布年份</th>
<th>CPU架构</th>
<th>分辨率</th>
<th>@Nx</th>
<th>iOS系统</th>
</tr>
</thead>
<tbody>
<tr>
<td>iPad</td>
<td>2010</td>
<td>armv7</td>
<td>768 x 1024</td>
<td>@1x</td>
<td>3.2 - 5.1.1</td>
</tr>
<tr>
<td>iPad 2</td>
<td>2011</td>
<td>armv7</td>
<td>768 x 1024</td>
<td>@1x</td>
<td>4.3 - 9.3.5</td>
</tr>
<tr>
<td>iPad (3rd)</td>
<td>2012</td>
<td>armv7</td>
<td>1536 x 2048</td>
<td>@2x</td>
<td>5.1 - 9.3.5</td>
</tr>
<tr>
<td>iPad mini</td>
<td>2012</td>
<td>armv7s</td>
<td>768 x 1024</td>
<td>@1x</td>
<td>6.0 - 9.3.5</td>
</tr>
<tr>
<td>iPad (4rd)</td>
<td>2012</td>
<td>armv7s</td>
<td>1536 x 2048</td>
<td>@2x</td>
<td>6.0 -</td>
</tr>
<tr>
<td>iPad Air</td>
<td>2013</td>
<td>arm64</td>
<td>1536 x 2048</td>
<td>@2x</td>
<td>7.0 -</td>
</tr>
<tr>
<td>iPad mini Retina</td>
<td>2013</td>
<td>arm64</td>
<td>1536 x 2048</td>
<td>@2x</td>
<td>7.0 -</td>
</tr>
<tr>
<td>iPad Air 2</td>
<td>2014</td>
<td>arm64</td>
<td>1536 x 2048</td>
<td>@2x</td>
<td>8.1 -</td>
</tr>
<tr>
<td>iPad mini 3</td>
<td>2014</td>
<td>arm64</td>
<td>1536 x 2048</td>
<td>@2x</td>
<td>8.1 -</td>
</tr>
<tr>
<td>iPad mini 4</td>
<td>2015</td>
<td>arm64</td>
<td>1536 x 2048</td>
<td>@2x</td>
<td>9.0 -</td>
</tr>
<tr>
<td>iPad Pro (12.9)</td>
<td>2015</td>
<td>arm64</td>
<td>2048 x 2732</td>
<td>@2x</td>
<td>9.1 -</td>
</tr>
<tr>
<td>iPad Pro (9.7)</td>
<td>2016</td>
<td>arm64</td>
<td>1536 x 2048</td>
<td>@2x</td>
<td>9.3 -</td>
</tr>
<tr>
<td>iPad (5rd)</td>
<td>2017</td>
<td>arm64</td>
<td>1536 x 2048</td>
<td>@2x</td>
<td>10.2.1 -</td>
</tr>
<tr>
<td>iPad Pro (10.5)</td>
<td>2017</td>
<td>arm64</td>
<td>1668 x 2224</td>
<td>@2x</td>
<td>10.3.2 -</td>
</tr>
<tr>
<td>iPad Pro (12.9-2)</td>
<td>2017</td>
<td>arm64</td>
<td>2048 x 2732</td>
<td>@2x</td>
<td>10.3.2 -</td>
</tr>
<tr>
<td>iPad (10.2)</td>
<td>2019</td>
<td>arm64</td>
<td>1620 x 2160</td>
<td>@2x</td>
<td>iPadOS</td>
</tr>
</tbody>
</table>
<h2 id="iPod-touch"><a href="#iPod-touch" class="headerlink" title="iPod touch"></a>iPod touch</h2><table>
<thead>
<tr>
<th>设备</th>
<th>发布年份</th>
<th>CPU架构</th>
<th>分辨率</th>
<th>@Nx</th>
<th>iOS系统</th>
</tr>
</thead>
<tbody>
<tr>
<td>iPod touch</td>
<td>2007</td>
<td>armv6</td>
<td>320 x 480</td>
<td>@1x</td>
<td>1.1 - 3.1.3</td>
</tr>
<tr>
<td>iPod touch (2nd)</td>
<td>2008</td>
<td>armv6</td>
<td>320 x 480</td>
<td>@1x</td>
<td>2.1.1 - 4.2.1</td>
</tr>
<tr>
<td>iPod touch (3rd)</td>
<td>2009</td>
<td>armv7</td>
<td>320 x 480</td>
<td>@1x</td>
<td>3.1 - 5.1.1</td>
</tr>
<tr>
<td>iPod touch (4th)</td>
<td>2010</td>
<td>armv7</td>
<td>640 x 960</td>
<td>@2x</td>
<td>4.1 - 6.1.4</td>
</tr>
<tr>
<td>iPod touch (5th)</td>
<td>2012</td>
<td>armv7</td>
<td>640 x 1136</td>
<td>@2x</td>
<td>6.0 - 9.3.5</td>
</tr>
<tr>
<td>iPod touch (6th)</td>
<td>2015</td>
<td>arm64</td>
<td>640 x 1136</td>
<td>@2x</td>
<td>8.4 -</td>
</tr>
</tbody>
</table>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.jianshu.com/p/2671829b86ab" target="_blank" rel="noopener">iOS设备一览表</a></p>
]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>app</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode Cannot edit in read-only editor</title>
    <url>/2019/12/12/vscode-Cannot-edit-in-read-only-editor/</url>
    <content><![CDATA[<h1 id="vscode-Cannot-edit-in-read-only-editor-错误解决"><a href="#vscode-Cannot-edit-in-read-only-editor-错误解决" class="headerlink" title="vscode Cannot edit in read-only editor 错误解决"></a>vscode Cannot edit in read-only editor 错误解决</h1><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><blockquote>
<p>使用了<code>Run Code</code>插件,output是只读的</p>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>将 run code设置为在Terminal中运行</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">File -&gt; Preferences -&gt; Settings</span><br></pre></td></tr></table></figure>
<p>找到 <code>run code in terminal</code> 打上 √</p>
<p>或 在settings.json文件中,添加一行配置信息</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"code-runner.runInTerminal": true</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>IDEs</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Install python3.8 on Centos6.5</title>
    <url>/2019/12/03/Install-python3-8-on-Centos6-5/</url>
    <content><![CDATA[<h3 id="1-安装必要的工具"><a href="#1-安装必要的工具" class="headerlink" title="1. 安装必要的工具"></a>1. 安装必要的工具</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install yum-utils</span><br></pre></td></tr></table></figure>
<h3 id="2-使用-yum-builddep-命令-设置-python-编译环境，下载缺少的依赖"><a href="#2-使用-yum-builddep-命令-设置-python-编译环境，下载缺少的依赖" class="headerlink" title="2. 使用 yum-builddep 命令 设置 python 编译环境，下载缺少的依赖"></a>2. 使用 yum-builddep 命令 设置 python 编译环境，下载缺少的依赖</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-builddep python</span><br></pre></td></tr></table></figure>
<h3 id="3-下载-python3-的源代码"><a href="#3-下载-python3-的源代码" class="headerlink" title="3. 下载 python3 的源代码"></a>3. 下载 python3 的源代码</h3><p>源代码可以在 <a href="https://www.python.org/ftp/" target="_blank" rel="noopener">https://www.python.org/ftp/python/ </a> 下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O https://www.python.org/ftp/python/3.8.0/Python-3.8.0a1.tgz</span><br></pre></td></tr></table></figure>
<h3 id="4-对源代码进行解压并编译安装"><a href="#4-对源代码进行解压并编译安装" class="headerlink" title="4. 对源代码进行解压并编译安装"></a>4. 对源代码进行解压并编译安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar xf Python-3.8.0a1.tgz</span><br><span class="line">cd Python-3.8.0a1</span><br><span class="line">./configure</span><br><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="5-现在-python3-已经完成安装，使用-python3-version-查看版本号"><a href="#5-现在-python3-已经完成安装，使用-python3-version-查看版本号" class="headerlink" title="5. 现在 python3 已经完成安装，使用 python3 -version 查看版本号"></a>5. 现在 python3 已经完成安装，使用 python3 -version 查看版本号</h3><p>显示 Python 3.8.0a1 表示已经成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 --version</span><br></pre></td></tr></table></figure>
<h3 id="6-如果你想把-python3-作为默认python-解析器，可以进行如下设置"><a href="#6-如果你想把-python3-作为默认python-解析器，可以进行如下设置" class="headerlink" title="6. 如果你想把 python3 作为默认python 解析器，可以进行如下设置"></a>6. 如果你想把 python3 作为默认python 解析器，可以进行如下设置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias python='/usr/local/bin/python3.8'</span><br></pre></td></tr></table></figure>
<h3 id="7-配置阿里pip源"><a href="#7-配置阿里pip源" class="headerlink" title="7. 配置阿里pip源"></a>7. 配置阿里pip源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[root@localhost ~]# cd </span><br><span class="line">[root@localhost ~]# mkdir .pip</span><br><span class="line">[root@localhost ~]# cd .pip</span><br><span class="line">[root@localhost .pip]# vim pip.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">文件内容如下</span></span><br><span class="line">[global]</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple </span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>python_standard_library_1_string</title>
    <url>/2019/12/20/python-standard-library-1-string/</url>
    <content><![CDATA[<h1 id="python-标准库学习笔记-–-string"><a href="#python-标准库学习笔记-–-string" class="headerlink" title="python 标准库学习笔记 – string"></a>python 标准库学习笔记 – string</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天是2019年12月20日,刚刚晴朗的天</p>
<p><a href="https://postimg.cc/mcq3BC7F" target="_blank" rel="noopener"><img src="https://i.postimg.cc/xCj6GPCg/20191220.jpg" alt="20191220.jpg"></a></p>
<p>入冬以来的第二场雪就悄然而至</p>
<p><a href="https://postimg.cc/9rHxR2ZD" target="_blank" rel="noopener"><img src="https://i.postimg.cc/ZKCXQKqx/20191220-1.jpg" alt="20191220-1.jpg"></a></p>
<p>从今天开始,坚持更新博文100天,也算是对python学习的总结。那么从哪里开始呢？</p>
<p>那就从<a href="&quot;https://docs.python.org/zh-cn/3.8/library&quot;">python标准库</a>开始撸吧。</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>win7 sp1 64位 标准版</th>
</tr>
</thead>
<tbody>
<tr>
<td>python版本</td>
<td>3.8</td>
</tr>
<tr>
<td>工具</td>
<td>vscode</td>
</tr>
</tbody>
</table>
<h2 id="标准库基础"><a href="#标准库基础" class="headerlink" title="标准库基础"></a>标准库基础</h2><p>在不同操作系统,标准库的路径有所不同,以windows平台为例,我的python安装在<code>C:\Python38</code></p>
<p>标准库文件就在<code>C:\Python38\Lib</code> 文件夹下</p>
<p>标准库分为几个部分,参考<a href="https://docs.python.org/zh-cn/3.8/library/index.html" target="_blank" rel="noopener">标准库介绍</a></p>
<ul>
<li><p>内置函数:不需要<code>import</code>就可以使用的函数,例如 <code>print</code></p>
</li>
<li><p>内置异常</p>
</li>
<li><p>内置模块</p>
<ul>
<li><p>文本</p>
</li>
<li><p>二进制数据</p>
</li>
<li><p>数据类型</p>
</li>
<li><p>数学</p>
</li>
<li><p>函数式编程模块</p>
</li>
<li><p>文件和目录访问</p>
</li>
<li><p>数据持久化</p>
</li>
<li><p>文件格式</p>
</li>
<li><p>加密服务</p>
</li>
<li><p>并发执行</p>
</li>
<li><p>网络和进程间通信</p>
</li>
<li><p>互联网数据处理</p>
</li>
<li><p>互联网协议和支持</p>
</li>
<li><p>多媒体服务</p>
</li>
<li><p>国际化</p>
</li>
<li><p>程序框架</p>
</li>
<li><p>Tk图形用户界面</p>
</li>
<li><p>开发工具</p>
</li>
<li><p>调试和分析</p>
</li>
<li><p>软件打包和分发</p>
</li>
<li><p>python运行时服务</p>
</li>
<li><p>自定义python解释器</p>
</li>
<li><p>导入模块</p>
</li>
<li><p>Python语言服务</p>
</li>
<li><p>杂项服务</p>
</li>
<li><p>Windows系统相关模块</p>
</li>
<li><p>Unix专有服务</p>
</li>
<li><p>被取代的模块</p>
</li>
</ul>
</li>
</ul>
<h2 id="day1-标准库-string"><a href="#day1-标准库-string" class="headerlink" title="day1  标准库 string"></a>day1  标准库 string</h2><p>参考：<a href="https://docs.python.org/zh-cn/3.8/library/string.html#helper-functions" target="_blank" rel="noopener">文本处理服务 string常见字符串操作</a> </p>
<h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [<span class="string">"ascii_letters"</span>, <span class="string">"ascii_lowercase"</span>, <span class="string">"ascii_uppercase"</span>, <span class="string">"capwords"</span>,</span><br><span class="line">           <span class="string">"digits"</span>, <span class="string">"hexdigits"</span>, <span class="string">"octdigits"</span>, <span class="string">"printable"</span>, <span class="string">"punctuation"</span>,</span><br><span class="line">           <span class="string">"whitespace"</span>, <span class="string">"Formatter"</span>, <span class="string">"Template"</span>]</span><br></pre></td></tr></table></figure>
<p>测试如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">print(string.__all__)</span><br><span class="line"></span><br><span class="line">print(string.ascii_letters) <span class="comment">#abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</span></span><br><span class="line">print(string.ascii_lowercase) <span class="comment">#abcdefghijklmnopqrstuvwxyz</span></span><br><span class="line">print(string.ascii_uppercase) <span class="comment">#ABCDEFGHIJKLMNOPQRSTUVWXYZ</span></span><br><span class="line">print(string.digits)<span class="comment"># 十进制数字常数 0123456789</span></span><br><span class="line">print(string.hexdigits)<span class="comment">#十六进制数字常数 0123456789abcdefABCDEF</span></span><br><span class="line">print(string.octdigits)<span class="comment">#八进制数字常数 01234567</span></span><br><span class="line">print(string.punctuation)</span><br><span class="line">print(string.printable)</span><br><span class="line">print(string.whitespace)</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>string.whitespace ：由被视为空白符号的 ASCII 字符组成的字符串。 其中包括空格、制表、换行、回车、进纸和纵向制表符。</li>
</ul>
<h2 id="自定义字符串格式化"><a href="#自定义字符串格式化" class="headerlink" title="自定义字符串格式化"></a>自定义字符串格式化</h2><table>
<thead>
<tr>
<th>主要函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>format(format_string, *args, **kwargs)</td>
<td>它采用格式字符串和一组任意位置和关键字参数。它只是一个调用vformat（）的包装器。</td>
</tr>
<tr>
<td>vformat(format_string, args, kwargs)</td>
<td>执行格式化的实际工作</td>
</tr>
<tr>
<td>parse(format_string)</td>
<td>循环遍历format_string并返回一个可迭代的元组（literal_text，field_name，format_spec，conversion）。</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">data = (<span class="string">"Pi = "</span>,<span class="number">3.1415926</span>)</span><br><span class="line">strtmp = <span class="string">"This is a test:&#123;&#125;&#123;:.4f&#125;"</span></span><br><span class="line">formatter = string.Formatter()</span><br><span class="line">strtmp = formatter.vformat(strtmp,data,&#123;&#125;)</span><br><span class="line">print(strtmp) <span class="comment">#This is a test:&#123;&#125;&#123;:.4f&#125;</span></span><br><span class="line"></span><br><span class="line">data =&#123;<span class="string">"key1"</span>:<span class="number">3.1415926</span>,<span class="string">"key2"</span>:<span class="string">"Pi: ="</span>&#125;</span><br><span class="line">strtmp = <span class="string">"This is a test:&#123;key2&#125;&#123;key1&#125;"</span></span><br><span class="line">formatter = string.Formatter()</span><br><span class="line">strtmp = formatter.vformat(strtmp,(),data)</span><br><span class="line">print(strtmp)</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">data = (<span class="string">"Pi="</span>,<span class="number">3.1415926</span>)</span><br><span class="line">strtmp = <span class="string">"This is a test:&#123;&#125;&#123;:.4f&#125;"</span></span><br><span class="line">formatter = string.Formatter()</span><br><span class="line">formatter.vformat(strtmp,data,&#123;&#125;)</span><br><span class="line">print(strtmp) <span class="comment">#This is a test:&#123;&#125;&#123;:.4f&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data =&#123;<span class="string">"key1"</span>:<span class="number">3.1415926</span>,<span class="string">"key2"</span>:<span class="string">"Pi: ="</span>&#125;</span><br><span class="line">strtmp = <span class="string">"This is a test:&#123;key2&#125;&#123;key1&#125;"</span></span><br><span class="line">formatter = string.Formatter()</span><br><span class="line">strtmp = formatter.vformat(strtmp,(),data)</span><br><span class="line">print(strtmp)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">strtmp = <span class="string">"This is a test:&#123;&#125;&#123;:.4f&#125;"</span></span><br><span class="line">formatter  = string.Formatter()</span><br><span class="line">strtuple = formatter.parse(strtmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(strtuple):</span><br><span class="line">    print(i, v)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    0 ('This is a test:', '', '', None)</span></span><br><span class="line"><span class="string">    1 ('', '', '.4f', None)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">strtmp = <span class="string">"This is a test:&#123;Key2&#125;&#123;Key1&#125;"</span></span><br><span class="line">formatter  = string.Formatter()</span><br><span class="line">strtuple = formatter.parse(strtmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(strtuple):</span><br><span class="line">    print(i, v)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    0 ('This is a test:', 'Key2', '', None)</span></span><br><span class="line"><span class="string">    1 ('', 'Key1', '', None)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"><span class="comment"># string.Formatter.parse(format_string) End</span></span><br></pre></td></tr></table></figure>
<h2 id="格式化字符串范例"><a href="#格式化字符串范例" class="headerlink" title="格式化字符串范例"></a>格式化字符串范例</h2><h3 id="按位置访问参数"><a href="#按位置访问参数" class="headerlink" title="按位置访问参数"></a>按位置访问参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tupdata = (<span class="string">"This"</span>,<span class="string">"is"</span>,<span class="string">"a"</span>,<span class="string">"test"</span>) <span class="comment"># 元组</span></span><br><span class="line">formatstr = <span class="string">'&#123;0&#125; &#123;1&#125; &#123;2&#125; &#123;3&#125;'</span>.format(<span class="string">"This"</span>,<span class="string">"is"</span>,<span class="string">"a"</span>,<span class="string">"test"</span>) </span><br><span class="line">print(formatstr)    <span class="comment"># This is a test</span></span><br><span class="line">formatstr = <span class="string">'&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;'</span>.format(*tupdata) <span class="comment"># *data 解包参数序列</span></span><br><span class="line">print(formatstr)    <span class="comment"># This is a test</span></span><br><span class="line">formatstr = <span class="string">'&#123;3&#125; &#123;2&#125; &#123;1&#125; &#123;0&#125;'</span>.format(*tupdata) <span class="comment"># *data 解包参数序列</span></span><br><span class="line">print(formatstr)    <span class="comment"># test a is This</span></span><br><span class="line">formatstr = <span class="string">'&#123;2&#125; &#123;3&#125; &#123;1&#125; &#123;2&#125; &#123;3&#125;'</span>.format(*tupdata)  <span class="comment"># 参数可以重复</span></span><br><span class="line">print(formatstr)    <span class="comment"># a test is a test</span></span><br></pre></td></tr></table></figure>
<h3 id="按关键字访问参数"><a href="#按关键字访问参数" class="headerlink" title="按关键字访问参数"></a>按关键字访问参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dicdata = &#123;<span class="string">'Author'</span>:<span class="string">'leacoder'</span>,<span class="string">'Time'</span>:<span class="string">'2019/04/17'</span>&#125;</span><br><span class="line">formatstr = <span class="string">'The author is &#123;Author&#125;，The time is &#123;Time&#125;'</span>.format(Author=<span class="string">'leacoder'</span>,Time=<span class="string">'2019/04/17'</span>)</span><br><span class="line">print(formatstr)    <span class="comment"># The author is leacoder，The time is 2019/04/17</span></span><br><span class="line">formatstr = <span class="string">'The author is &#123;Author&#125;，The time is &#123;Time&#125;'</span>.format(**dicdata)</span><br><span class="line">print(formatstr)    <span class="comment"># The author is leacoder，The time is 2019/04/17</span></span><br></pre></td></tr></table></figure>
<h3 id="访问参数的属性"><a href="#访问参数的属性" class="headerlink" title="访问参数的属性"></a>访问参数的属性</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        self.x ,self.y = x, y</span><br><span class="line">point = Point(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line">formatstr = <span class="string">'Thie point is (&#123;key.x&#125;,&#123;key.y&#125;)'</span>.format(key = point) <span class="comment"># key 可为其他 </span></span><br><span class="line">print(formatstr)  <span class="comment"># Thie point is (4,2)</span></span><br><span class="line">formatstr = <span class="string">'Thie point is (&#123;point.x&#125;,&#123;point.y&#125;)'</span>.format(point = point) <span class="comment"># point 可为其他 </span></span><br><span class="line">print(formatstr)  <span class="comment"># Thie point is (4,2)</span></span><br></pre></td></tr></table></figure>
<h2 id="访问参数的各项"><a href="#访问参数的各项" class="headerlink" title="访问参数的各项"></a>访问参数的各项</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tupdata = (<span class="string">"leacoder"</span>,<span class="string">"2019/04/17"</span>) <span class="comment"># 元组</span></span><br><span class="line">formatstr = <span class="string">'The author is &#123;0[0]&#125;,The time is &#123;0[1]&#125;'</span>.format(tupdata)</span><br><span class="line">print(formatstr)    <span class="comment"># The author is leacoder,The time is 2019/04/17</span></span><br><span class="line">formatstr = <span class="string">'The author is &#123;0[0]&#125;,The time is &#123;0[1]&#125;'</span>.format(*tupdata)  <span class="comment"># 注意区别</span></span><br><span class="line">print(formatstr)    <span class="comment"># The author is l,The time is e</span></span><br></pre></td></tr></table></figure>
<h3 id="对齐文本并指定宽度"><a href="#对齐文本并指定宽度" class="headerlink" title="对齐文本并指定宽度"></a>对齐文本并指定宽度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">formatstr = <span class="string">'&#123;:&lt;30&#125;'</span>.format(<span class="string">'left aligned'</span>) <span class="comment"># 左对齐 30位</span></span><br><span class="line">print(formatstr)    <span class="comment"># ‘left aligned                  ’  为了体现位数加了‘’</span></span><br><span class="line">formatstr = <span class="string">'&#123;:&gt;30&#125;'</span>.format(<span class="string">'right aligned'</span>)    <span class="comment"># 右对齐 30位</span></span><br><span class="line">print(formatstr)    <span class="comment"># ‘                 right aligned’</span></span><br><span class="line">formatstr = <span class="string">'&#123;:^30&#125;'</span>.format(<span class="string">'centered'</span>)  <span class="comment"># 中间对齐 30位</span></span><br><span class="line">print(formatstr)    <span class="comment"># ‘           centered           ’</span></span><br><span class="line">formatstr =  <span class="string">'&#123;:*^30&#125;'</span>.format(<span class="string">'centered'</span>)  <span class="comment"># 使用* 作为填充字符</span></span><br><span class="line">print(formatstr)    <span class="comment"># ‘***********centered***********’</span></span><br></pre></td></tr></table></figure>
<h3 id="Replacing-f-f-and-f-and-specifying-a-sign-替换％-f，％-f和％f并指定符号"><a href="#Replacing-f-f-and-f-and-specifying-a-sign-替换％-f，％-f和％f并指定符号" class="headerlink" title="Replacing %+f, %-f, and % f and specifying a sign: 替换％+ f，％ - f和％f并指定符号:"></a>Replacing %+f, %-f, and % f and specifying a sign: 替换％+ f，％ - f和％f并指定符号:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">formatstr = <span class="string">'&#123;:+f&#125;; &#123;:+f&#125;'</span>.format(<span class="number">3.14</span>, <span class="number">-3.14</span>)  <span class="comment"># 总是显示它符号</span></span><br><span class="line">print(formatstr)    <span class="comment"># ‘+3.140000; -3.140000’</span></span><br><span class="line">formatstr = <span class="string">'&#123;: f&#125;; &#123;: f&#125;'</span>.format(<span class="number">3.14</span>, <span class="number">-3.14</span>)  <span class="comment"># 正数前显示空格</span></span><br><span class="line">print(formatstr)    <span class="comment"># ‘ 3.140000; -3.140000’</span></span><br><span class="line">formatstr = <span class="string">'&#123;:-f&#125;; &#123;:-f&#125;'</span>.format(<span class="number">3.14</span>, <span class="number">-3.14</span>)  <span class="comment"># 只显示负号 同 '&#123;:f&#125;; &#123;:f&#125;'</span></span><br><span class="line">print(formatstr)    <span class="comment"># ‘3.140000; -3.140000’</span></span><br></pre></td></tr></table></figure>
<h3 id="Replacing-x-and-o-and-converting-the-value-to-different-bases-替换％x和％o并将值转换为不同的进制"><a href="#Replacing-x-and-o-and-converting-the-value-to-different-bases-替换％x和％o并将值转换为不同的进制" class="headerlink" title="Replacing %x and %o and converting the value to different bases: 替换％x和％o并将值转换为不同的进制"></a>Replacing %x and %o and converting the value to different bases: 替换％x和％o并将值转换为不同的进制</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">formatstr = <span class="string">"int: &#123;0:d&#125;;  hex: &#123;0:x&#125;;  oct: &#123;0:o&#125;;  bin: &#123;0:b&#125;"</span>.format(<span class="number">64</span>)</span><br><span class="line">print(formatstr)  <span class="comment"># int: 64;  hex: 40;  oct: 100;  bin: 1000000</span></span><br><span class="line">formatstr = <span class="string">"int: &#123;0:d&#125;;  hex: &#123;0:#x&#125;;  oct: &#123;0:#o&#125;;  bin: &#123;0:#b&#125;"</span>.format(<span class="number">64</span>)</span><br><span class="line">print(formatstr)  <span class="comment"># int: 64;  hex: 0x40;  oct: 0o100;  bin: 0b1000000</span></span><br><span class="line">formatstr = <span class="string">"int: &#123;0:d&#125;;  hex: &#123;0:#x&#125;;  oct: &#123;0:#o&#125;;  bin: &#123;0:#b&#125;"</span>.format(<span class="number">0b1000001</span>) <span class="comment"># 也支持其他进制</span></span><br><span class="line">print(formatstr)  <span class="comment"># int: 65;  hex: 0x41;  oct: 0o101;  bin: 0b100000</span></span><br></pre></td></tr></table></figure>
<h3 id="使用逗号作为千位分隔符"><a href="#使用逗号作为千位分隔符" class="headerlink" title="使用逗号作为千位分隔符"></a>使用逗号作为千位分隔符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">points = <span class="number">1</span></span><br><span class="line">total = <span class="number">3</span></span><br><span class="line">formatstr = <span class="string">'points / total = &#123;:.2%&#125;'</span>.format(points/total)</span><br><span class="line">print(formatstr)    <span class="comment"># points / total = 33.33%</span></span><br></pre></td></tr></table></figure>
<h3 id="使用特定类型的格式"><a href="#使用特定类型的格式" class="headerlink" title="使用特定类型的格式"></a>使用特定类型的格式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">d = datetime.datetime(<span class="number">2019</span>, <span class="number">4</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">49</span>, <span class="number">2</span>) <span class="comment"># 2019/04/17 22:49:02</span></span><br><span class="line">formatstr = <span class="string">'&#123;:%Y-%m-%d %H:%M:%S&#125;'</span>.format(d)</span><br><span class="line">print(formatstr)    <span class="comment"># 2019-04-17 22:49:02</span></span><br></pre></td></tr></table></figure>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><h3 id="模板字符串规则"><a href="#模板字符串规则" class="headerlink" title="模板字符串规则"></a>模板字符串规则</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">模板字符串提供更简单的字符串替换，如PEP 292中所述 https://www.python.org/dev/peps/pep-0292/</span></span><br><span class="line"><span class="string">模板字符串支持基于$的替换，使用以下规则：</span></span><br><span class="line"><span class="string">    1、$$是转义; 它被替换为单个$。</span></span><br><span class="line"><span class="string">    2、$identifier 一个替换占位符，用于匹配映射关键字“identifier”默认情况下，</span></span><br><span class="line"><span class="string">    “标识符”仅限于以下划线或ASCII字母开头的任何不区分大小写的ASCII字母数字字符串（包括下划线）。$字符后面的第一个非标识符字符结束此占位符。</span></span><br><span class="line"><span class="string">    3、$ &#123;identifier&#125;相当于$ identifier。当有效标识符字符跟随占位符但不是占位符的一部分时，例如“$ &#123;noun&#125; ification”，则需要它。</span></span><br><span class="line"><span class="string">    4、字符串中$的任何其他形式都将导致引发ValueError。</span></span><br><span class="line"><span class="string">字符串模块提供实现这些规则的Template类。class string.Template(template)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h2 id="class-string-Template-template"><a href="#class-string-Template-template" class="headerlink" title="class string.`Template`(template)"></a><em>class</em> <code>string.`</code>Template`(<em>template</em>)</h2><h3 id="substitute-mapping-kwargs"><a href="#substitute-mapping-kwargs" class="headerlink" title="substitute(mapping,**kwargs)"></a>substitute(mapping,**kwargs)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行模板替换，返回一个新字符串。 mapping 为任意字典类对象，其中的键将匹配模板中的占位符。 或者你也可以提供一组关键字参数，其中的关键字即对应占位符。 当同时给出 mapping 和 kwds 并且存在重复时，则以 kwds 中的占位符为优先</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">s = Template(<span class="string">'The Author is $Author, The Time is $Time'</span>)    <span class="comment"># 使用Template类构造函数</span></span><br><span class="line">kewds = &#123;<span class="string">'Author'</span>:<span class="string">'leacoder'</span>, <span class="string">'Time'</span>:<span class="string">'2019/04/18 00:01:38'</span>&#125;</span><br><span class="line">templatestr = s.substitute(Author=<span class="string">'leacoder'</span>, Time=<span class="string">'2019/04/18 00:01:38'</span>)  <span class="comment"># **kewds</span></span><br><span class="line">print(templatestr)  <span class="comment"># The Author is leacoder, The Time is 2019/04/18 00:01:38</span></span><br><span class="line">templatestr = s.substitute(**kewds)  <span class="comment"># **kewds</span></span><br><span class="line">print(templatestr)  <span class="comment"># The Author is leacoder, The Time is 2019/04/18 00:01:38</span></span><br><span class="line">templatestr = s.substitute(kewds)  <span class="comment"># mapping</span></span><br><span class="line">print(templatestr)  <span class="comment"># The Author is leacoder, The Time is 2019/04/18 00:01:38</span></span><br><span class="line">templatestr = s.substitute(kewds,Author=<span class="string">'250'</span>,Time = <span class="string">'No Time'</span>)  <span class="comment"># mapping  **kewds</span></span><br><span class="line">print(templatestr)  <span class="comment"># The Author is 250, The Time is No Time</span></span><br><span class="line"></span><br><span class="line">kewds1 = &#123;<span class="string">'Author'</span>:<span class="string">'leacoder'</span>&#125;</span><br><span class="line">templatestr = s.substitute(kewds1)</span><br><span class="line">print(templatestr)  <span class="comment"># KeyError: 'Time'</span></span><br><span class="line"><span class="comment"># substitute(mapping, **kwds) End</span></span><br></pre></td></tr></table></figure>
<h3 id="safe-substitute-mapping-kwds"><a href="#safe-substitute-mapping-kwds" class="headerlink" title="safe_substitute(mapping, **kwds)"></a>safe_substitute(mapping, **kwds)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">类似于 substitute()，不同之处是如果有占位符未在 mapping 和 kwds 中找到，不是引发 KeyError 异常，而是将原始占位符不加修改地显示在结果字符串中。 另一个与 substitute() 的差异是任何在其他情况下出现的 $ 将简单地返回 $ 而不是引发 ValueError。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># safe_substitute(mapping, **kwds)</span></span><br><span class="line">kewds1 = &#123;<span class="string">'Author'</span>:<span class="string">'leacoder'</span>&#125;</span><br><span class="line">templatestr = s.safe_substitute(kewds1)</span><br><span class="line">print(templatestr)  <span class="comment"># The Author is leacoder, The Time is $Time</span></span><br><span class="line"><span class="comment"># safe_substitute(mapping, **kwds) End</span></span><br></pre></td></tr></table></figure>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><h3 id="string-capwords-s-sep-None）"><a href="#string-capwords-s-sep-None）" class="headerlink" title="string.`capwords`(s, sep=None）"></a><code>string.`</code>capwords`(<em>s</em>, <em>sep=None</em>）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">使用 str.split() 将参数拆分为单词，使用 str.capitalize() 将单词转为大写形式，使用 str.join() 将大写的单词进行拼接。 如果可选的第二个参数 sep 被省略或为 None，则连续的空白字符会被替换为单个空格符并且开头和末尾的空白字符会被移除，否则 sep 会被用来拆分和拼接单词</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library -2 dictionary</title>
    <url>/2019/12/23/python-standard-library-2-dictionary/</url>
    <content><![CDATA[<h1 id="python-标准库学习笔记-–-dictionary"><a href="#python-标准库学习笔记-–-dictionary" class="headerlink" title="python 标准库学习笔记 – dictionary"></a>python 标准库学习笔记 – dictionary</h1><h2 id="0-0-前言"><a href="#0-0-前言" class="headerlink" title="0.0 前言"></a>0.0 前言</h2><p>家里孩子发烧了,延迟更新标准库学习笔记</p>
<p>折腾了三个晚上,一家三口都累倒了。</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20191223_rear-view-of-man-in-knit-hat.jpg?raw=true" alt></p>
<p>人生就好比一个蹒跚学步的孩童,很容易被外界环境影响。</p>
<h2 id="1-0-标准库-内置函数"><a href="#1-0-标准库-内置函数" class="headerlink" title="1.0 标准库- 内置函数"></a>1.0 标准库- 内置函数</h2><p>参考文档:  <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#mapping-types-dict" target="_blank" rel="noopener">内置类型-字典</a></p>
<p>python中主要内置类型包括<code>numbers</code>,<code>sequences</code>,<code>mappings</code>,<code>classes</code>,<code>instance</code>和<code>exception</code>。</p>
<h3 id="1-1-逻辑值检测"><a href="#1-1-逻辑值检测" class="headerlink" title="1.1 逻辑值检测"></a>1.1 逻辑值检测</h3><p>任何对象都可以进行逻辑值检测,以便在<code>if</code> 或<code>while</code>作为条件或是作为上下文所指返回值是布尔类型的表达式来使用。所以就有下面的用法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = []</span><br><span class="line"><span class="keyword">if</span>(L):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">while</span>(L):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>一个对象在默认情况下被认为是<code>True</code>,除非该对象定义了<code>__boolean__()</code> 方法且返回<code>False</code> 或者定义<code>__len__()</code>方法且返回零。下面三种情况的内置对象都会被认为是逻辑假值。</p>
<ul>
<li><p>None 或 False</p>
</li>
<li><p>任何数值类型的零</p>
</li>
<li><p>空的序列和多项集 包括 空字符串、空列表、空集合、空字典、空元组以及空数列(reange(0))</p>
<a id="more"></a>
</li>
</ul>
<h3 id="1-2-布尔运算-–-and-or-not"><a href="#1-2-布尔运算-–-and-or-not" class="headerlink" title="1.2 布尔运算 – and,or,not"></a>1.2 布尔运算 – and,or,not</h3><table>
<thead>
<tr>
<th>运算</th>
<th>结果</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x or y</code></td>
<td>if <em>x</em> is false, then <em>y</em>, else <em>x</em></td>
<td>短路运算,只有第一个为假的时候才会对第二个求值</td>
</tr>
<tr>
<td><code>x and y</code></td>
<td>if <em>x</em> is false, then <em>x</em>, else <em>y</em></td>
<td>短路运算,只有第二个为真的时候才会对第二个求值</td>
</tr>
<tr>
<td><code>not x</code></td>
<td>if <em>x</em> is false, then <code>True</code>, else <code>False</code></td>
<td>逻辑取反</td>
</tr>
</tbody>
</table>
<h3 id="1-3-比较运算"><a href="#1-3-比较运算" class="headerlink" title="1.3 比较运算"></a>1.3 比较运算</h3><table>
<thead>
<tr>
<th>运算</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;</code></td>
<td>严格小于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于或等于</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>严格大于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于或等于</td>
</tr>
<tr>
<td><code>==</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>is</code></td>
<td>对象标识</td>
</tr>
<tr>
<td><code>is not</code></td>
<td>否定的对象标识</td>
</tr>
</tbody>
</table>
<p>==tips== </p>
<ol>
<li>不同类型的对象之间不能使用比较运算,除非定义了对应的方法，例如<code>__lt__()</code>,<code>__eq__()</code>这样的函数</li>
<li>具有不同标识的类的实例,比较结果为False,除非你自己定义了<code>__eq__()</code>方法</li>
<li>一个类实例不能与相同类或的其他实例或其他类型的对象进行排序,除非定义了对应的方法，包括 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__lt__" target="_blank" rel="noopener"><code>__lt__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__le__" target="_blank" rel="noopener"><code>__le__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__gt__" target="_blank" rel="noopener"><code>__gt__()</code></a> 以及 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__ge__" target="_blank" rel="noopener"><code>__ge__()</code></a> </li>
</ol>
<h3 id="1-4-数字类型-–-int、float、complex"><a href="#1-4-数字类型-–-int、float、complex" class="headerlink" title="1.4 数字类型 – int、float、complex"></a>1.4 数字类型 – int、float、complex</h3><p>python中存在三种不同的数字类型: 整数<em>, </em>浮点数<em> 和 </em>复数*。</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>结果</th>
<th>注释</th>
<th>完整文档</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x + y</code></td>
<td><em>x</em> 和 <em>y</em> 的和</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>x - y</code></td>
<td><em>x</em> 和 <em>y</em> 的差</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>x * y</code></td>
<td><em>x</em> 和 <em>y</em> 的乘积</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>x / y</code></td>
<td><em>x</em> 和 <em>y</em> 的商</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>x // y</code></td>
<td><em>x</em> 和 <em>y</em> 的商数</td>
<td>取整</td>
<td></td>
</tr>
<tr>
<td><code>x % y</code></td>
<td>remainder of <code>x / y</code></td>
<td>不可用于负数</td>
<td></td>
</tr>
<tr>
<td><code>-x</code></td>
<td><em>x</em> 取反</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>+x</code></td>
<td><em>x</em> 不变</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>abs(x)</code></td>
<td><em>x</em> 的绝对值或大小</td>
<td></td>
<td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#abs" target="_blank" rel="noopener"><code>abs()</code></a></td>
</tr>
<tr>
<td><code>int(x)</code></td>
<td>将 <em>x</em> 转换为整数</td>
<td>小数会被截断</td>
<td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int()</code></a></td>
</tr>
<tr>
<td><code>float(x)</code></td>
<td>将 <em>x</em> 转换为浮点数</td>
<td>(4)(6)</td>
<td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float()</code></a></td>
</tr>
<tr>
<td><code>complex(re, im)</code></td>
<td>一个带有实部 <em>re</em> 和虚部 <em>im</em> 的复数。<em>im</em> 默认为0。</td>
<td>(6)</td>
<td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#complex" target="_blank" rel="noopener"><code>complex()</code></a></td>
</tr>
<tr>
<td><code>c.conjugate()</code></td>
<td>复数 <em>c</em> 的共轭</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>divmod(x, y)</code></td>
<td><code>(x // y, x % y)</code></td>
<td>(2)</td>
<td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#divmod" target="_blank" rel="noopener"><code>divmod()</code></a></td>
</tr>
<tr>
<td><code>pow(x, y)</code></td>
<td><em>x</em> 的 <em>y</em> 次幂</td>
<td>(5)</td>
<td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#pow" target="_blank" rel="noopener"><code>pow()</code></a></td>
</tr>
<tr>
<td><code>x ** y</code></td>
<td><em>x</em> 的 <em>y</em> 次幂</td>
<td>(5)</td>
</tr>
</tbody>
</table>
<p>所有的<code>numbers.Real</code>类型（包括<code>int</code> 和 <code>float</code>)还包括以下运算:</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.trunc" target="_blank" rel="noopener"><code>math.trunc(x)</code></a></td>
<td><em>x</em> 截断为 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Integral" target="_blank" rel="noopener"><code>Integral</code></a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#round" target="_blank" rel="noopener"><code>round(x[, n\])</code></a></td>
<td><em>x</em> 舍入到 <em>n</em> 位小数，半数值会舍入到偶数。 如果省略 <em>n</em>，则默认为 0。</td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.floor" target="_blank" rel="noopener"><code>math.floor(x)</code></a></td>
<td>&lt;= <em>x</em> 的最大 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Integral" target="_blank" rel="noopener"><code>Integral</code></a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.ceil" target="_blank" rel="noopener"><code>math.ceil(x)</code></a></td>
<td>&gt;= <em>x</em> 的最小 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Integral" target="_blank" rel="noopener"><code>Integral</code></a></td>
</tr>
</tbody>
</table>
<h3 id="1-5-整数类型的附加方法"><a href="#1-5-整数类型的附加方法" class="headerlink" title="1.5 整数类型的附加方法"></a>1.5 整数类型的附加方法</h3><h4 id="int-bit-length"><a href="#int-bit-length" class="headerlink" title="int.bit_length()"></a>int.bit_length()</h4><blockquote>
<p> 返回以二进制表示一个整数锁需要的位数，不包括符号位和前面的零</p>
</blockquote>
<h3 id="1-6-浮点数类型的附加方法"><a href="#1-6-浮点数类型的附加方法" class="headerlink" title="1.6 浮点数类型的附加方法"></a>1.6 浮点数类型的附加方法</h3><h4 id="float-as-integer-ratio"><a href="#float-as-integer-ratio" class="headerlink" title="float.as_integer_ratio()"></a><code>float.as_integer_ratio</code>()</h4><blockquote>
<p>返回一对整数，其比率正好等于原浮点数并且分母为正数。 无穷大会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a> 而 NaN 则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。</p>
</blockquote>
<h4 id="float-is-integer"><a href="#float-is-integer" class="headerlink" title="float.is_integer()"></a><code>float.is_integer</code>()</h4><blockquote>
<p> 如果 float 实例可用有限位整数表示则返回 <code>True</code>，否则返回 <code>False</code>:</p>
</blockquote>
<h4 id="float-hex"><a href="#float-hex" class="headerlink" title="float.hex()"></a><code>float.hex</code>()</h4><blockquote>
<p> 以十六进制字符串的形式返回一个浮点数表示。 对于有限浮点数，这种表示法将总是包含前导的 <code>0x</code> 和尾随的 <code>p</code> 加指数。</p>
</blockquote>
<h4 id="classmethod-float-fromhex-s"><a href="#classmethod-float-fromhex-s" class="headerlink" title="classmethod float.fromhex(s)"></a><em>classmethod</em> <code>float.fromhex</code>(<em>s</em>)</h4><blockquote>
<p> 返回以十六进制字符串 <em>s</em> 表示的浮点数的类方法。 字符串 <em>s</em> 可以带有前导和尾随的空格。</p>
</blockquote>
<p>==tips==: <code>float.hex()</code> 是实例方法, <code>float.fromhex(s)</code>是类方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>float.fromhex(<span class="string">'0x3.a7p10'</span>)</span><br><span class="line"><span class="number">3740.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float.hex(<span class="number">3740.0</span>)</span><br><span class="line"><span class="string">'0x1.d380000000000p+11'</span></span><br></pre></td></tr></table></figure>
<h3 id="1-7-数字类型的哈希运算"><a href="#1-7-数字类型的哈希运算" class="headerlink" title="1.7 数字类型的哈希运算"></a>1.7 数字类型的哈希运算</h3><p>一个例子说明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash_fraction</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    <span class="string">"""Compute the hash of a rational number m / n.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Assumes m and n are integers, with n positive.</span></span><br><span class="line"><span class="string">    Equivalent to hash(fractions.Fraction(m, n)).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    P = sys.hash_info.modulus</span><br><span class="line">    <span class="comment"># Remove common factors of P.  (Unnecessary if m and n already coprime.)</span></span><br><span class="line">    <span class="keyword">while</span> m % P == n % P == <span class="number">0</span>:</span><br><span class="line">        m, n = m // P, n // P</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n % P == <span class="number">0</span>:</span><br><span class="line">        hash_value = sys.hash_info.inf</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Fermat's Little Theorem: pow(n, P-1, P) is 1, so</span></span><br><span class="line">        <span class="comment"># pow(n, P-2, P) gives the inverse of n modulo P.</span></span><br><span class="line">        hash_value = (abs(m) % P) * pow(n, P - <span class="number">2</span>, P) % P</span><br><span class="line">    <span class="keyword">if</span> m &lt; <span class="number">0</span>:</span><br><span class="line">        hash_value = -hash_value</span><br><span class="line">    <span class="keyword">if</span> hash_value == <span class="number">-1</span>:</span><br><span class="line">        hash_value = <span class="number">-2</span></span><br><span class="line">    <span class="keyword">return</span> hash_value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash_float</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""Compute the hash of a float x."""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> math.isnan(x):</span><br><span class="line">        <span class="keyword">return</span> sys.hash_info.nan</span><br><span class="line">    <span class="keyword">elif</span> math.isinf(x):</span><br><span class="line">        <span class="keyword">return</span> sys.hash_info.inf <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> -sys.hash_info.inf</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> hash_fraction(*x.as_integer_ratio())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash_complex</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="string">"""Compute the hash of a complex number z."""</span></span><br><span class="line"></span><br><span class="line">    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)</span><br><span class="line">    <span class="comment"># do a signed reduction modulo 2**sys.hash_info.width</span></span><br><span class="line">    M = <span class="number">2</span>**(sys.hash_info.width - <span class="number">1</span>)</span><br><span class="line">    hash_value = (hash_value &amp; (M - <span class="number">1</span>)) - (hash_value &amp; M)</span><br><span class="line">    <span class="keyword">if</span> hash_value == <span class="number">-1</span>:</span><br><span class="line">        hash_value = <span class="number">-2</span></span><br><span class="line">    <span class="keyword">return</span> hash_value</span><br></pre></td></tr></table></figure>
<h3 id="1-8-映射类型-–-dict"><a href="#1-8-映射类型-–-dict" class="headerlink" title="1.8 映射类型 – dict"></a>1.8 映射类型 – dict</h3><p>python中目前只有一种映射类型, <code>字典</code>,映射属于可变对象。映射类型会将<code>hashtable</code>值映射到任意对象.</p>
<p>字典的键 <em>几乎</em>可以是任意值， 可<code>hash</code>的任意值,也就是包含列表、字典和其他可变类型的值,不可以用来充当字典中的键。</p>
<h4 id="1-创建字典"><a href="#1-创建字典" class="headerlink" title="1.创建字典"></a>1.创建字典</h4><p>字典可以通过将以逗号分隔的 <code>键: 值</code> 对列表包含于花括号之内来创建，例如: <code>{&#39;jack&#39;: 4098, &#39;sjoerd&#39;: 4127}</code> 或 <code>{4098: &#39;jack&#39;, 4127: &#39;sjoerd&#39;}</code>，也可以通过 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 构造器来创建。</p>
<h4 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h4><p><em>class</em> <code>dict</code>(<em>**kwarg</em>)</p>
<p><em>class</em> <code>dict</code>(<em>mapping</em>, <em>**kwarg</em>)</p>
<p><em>class</em> <code>dict</code>(<em>iterable</em>, <em>**kwarg</em>)</p>
<h4 id="3-其他函数"><a href="#3-其他函数" class="headerlink" title="3. 其他函数"></a>3. 其他函数</h4><table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>list(d)</td>
<td>返回字典 <em>d</em> 中使用的所有键的列表。</td>
<td></td>
</tr>
<tr>
<td><strong>len(d)</strong></td>
<td>返回字典 <em>d</em> 中的项数。</td>
<td></td>
</tr>
<tr>
<td><strong>d[key]</strong></td>
<td>返回 <em>d</em> 中以 <em>key</em> 为键的项。 如果映射中不存在 <em>key</em> 则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。</td>
<td>[1]</td>
</tr>
<tr>
<td><strong>d[key] = value</strong></td>
<td>给d[key]的值设为value</td>
<td></td>
</tr>
<tr>
<td><strong>del d[key]</strong></td>
<td>将 <code>d[key]</code> 从 <em>d</em> 中移除。 如果映射中不存在 <em>key</em> 则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。</td>
<td></td>
</tr>
<tr>
<td><strong>key in d</strong></td>
<td>如果 <em>d</em> 中存在键 <em>key</em> 则返回 <code>True</code>，否则返回 <code>False</code>。</td>
<td></td>
</tr>
<tr>
<td><strong>key not in d</strong></td>
<td>等价于 <code>not key in d</code>。</td>
<td></td>
</tr>
<tr>
<td><strong>iter(d)</strong></td>
<td>返回以字典的键为元素的迭代器</td>
<td></td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>移除字典中的所有元素。</td>
<td></td>
</tr>
<tr>
<td><code>copy</code>()</td>
<td>返回原字典的浅拷贝。</td>
<td></td>
</tr>
<tr>
<td><em>classmethod</em> <code>fromkeys</code>(<em>iterable</em>[, <em>value</em>])</td>
<td>使用来自 <em>iterable</em> 的键创建一个新字典，并将键值设为 <em>value</em>。</td>
<td></td>
</tr>
<tr>
<td><code>get</code>(<em>key</em>[, <em>default</em>])</td>
<td>如果 <em>key</em> 存在于字典中则返回 <em>key</em> 的值，否则返回 <em>default</em>。 如果 <em>default</em> 未给出则默认为 <code>None</code>，因而此方法绝不会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。</td>
<td></td>
</tr>
<tr>
<td><code>items</code>()</td>
<td>返回由字典项 (<code>(键, 值)</code> 对) 组成的一个新视图。</td>
<td></td>
</tr>
<tr>
<td><code>keys</code>()</td>
<td>返回由字典键组成的一个新视图</td>
<td></td>
</tr>
<tr>
<td><code>pop</code>(<em>key</em>[, <em>default</em>])</td>
<td>如果 <em>key</em> 存在于字典中则将其移除并返回其值，否则返回 <em>default</em>。 如果 <em>default</em> 未给出且 <em>key</em> 不存在于字典中，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。</td>
<td></td>
</tr>
<tr>
<td><code>popitem</code>()</td>
<td>从字典中移除并返回一个 <code>(键, 值)</code> 对。 键值对会按 LIFO 的顺序被返回。</td>
<td></td>
</tr>
<tr>
<td><strong>reversed(d)</strong></td>
<td>返回一个逆序获取字典键的迭代器</td>
<td></td>
</tr>
<tr>
<td><code>setdefault</code>(<em>key</em>[, <em>default</em>])</td>
<td>如果字典存在键 <em>key</em> ，返回它的值。如果不存在，插入值为 <em>default</em> 的键 <em>key</em> ，并返回 <em>default</em> 。 <em>default</em> 默认为 <code>None</code>。</td>
<td></td>
</tr>
<tr>
<td><code>update</code>([<em>other</em>])</td>
<td>使用来自 <em>other</em> 的键/值对更新字典，覆盖原有的键。</td>
<td></td>
</tr>
<tr>
<td><code>values</code>()</td>
<td>返回由字典值组成的一个新视图</td>
<td>[2]</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#[1] 如果字典的子类定义了方法 __missing__() 并且 key 不存在，则 d[key] 操作将调用该方法并附带键 key 作为参数。 d[key] 随后将返回或引发 __missing__(key) 调用所返回或引发的任何对象或异常。 没有其他操作或方法会发起调用 __missing__()。 如果未定义 __missing__()，则会引发 KeyError。 __missing__() 必须是一个方法；它不能是一个实例变量:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Counter</span><span class="params">(dict)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">'red'</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">'red'</span>] += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">'red'</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">#[2]两个 dict.values() 视图之间的相等性比较将总是返回 False。 这在 dict.values() 与其自身比较时也同样适用: </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'a'</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.values() == d.values()</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>字典比较</strong>:</p>
<p>两个字典的比较当且仅当它们具有相同的 <code>(键, 值)</code> 对时才会相等（不考虑顺序）。 排序比较 (‘&lt;’, ‘&lt;=’, ‘&gt;=’, ‘&gt;’) 会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p>
<p>字典会保留插入时的顺序。 请注意对键的更新不会影响顺序。 删除并再次添加的键将被插入到末尾。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>, <span class="string">"three"</span>: <span class="number">3</span>, <span class="string">"four"</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'four'</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(d)</span><br><span class="line">[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(d.values())</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">"one"</span>] = <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'one'</span>: <span class="number">42</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'four'</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d[<span class="string">"two"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">"two"</span>] = <span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'one'</span>: <span class="number">42</span>, <span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'four'</span>: <span class="number">4</span>, <span class="string">'two'</span>: <span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-字典视图对象"><a href="#4-字典视图对象" class="headerlink" title="4.字典视图对象"></a>4.字典视图对象</h4><p>由 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.keys" target="_blank" rel="noopener"><code>dict.keys()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.values" target="_blank" rel="noopener"><code>dict.values()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.items" target="_blank" rel="noopener"><code>dict.items()</code></a> 所返回的对象是 <em>视图对象</em>。 该对象提供字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。</p>
<table>
<thead>
<tr>
<th>字典视图函数</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>len(dictview)</strong></td>
<td>返回字典中的条目数</td>
<td></td>
</tr>
<tr>
<td><strong>iter(dictview)</strong></td>
<td>返回字典中的键、值或项（以 <code>(键, 值)</code> 为元素的元组表示）的迭代器</td>
<td>[1]</td>
</tr>
<tr>
<td><strong>x in dictview</strong></td>
<td>如果 <em>x</em> 是对应字典中存在的键、值或项（在最后一种情况下 <em>x</em> 应为一个 <code>(键, 值)</code> 元组） 则返回 <code>True</code></td>
<td></td>
</tr>
<tr>
<td><strong>reversed(dictview)</strong></td>
<td>返回一个逆序获取字典键、值或项的迭代器。 视图将按与插入时相反的顺序进行迭代。</td>
<td>[2]</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#键视图类似于集合，因为其条目不重复且可哈希。 如果所有值都是可哈希的，即 (键, 值) 对也是不重复且可哈希的，那么条目视图也会类似于集合。 （值视图则不被视为类似于集合，因其条目通常都是有重复的。） 对于类似于集合的视图，为抽象基类 collections.abc.Set 所定义的全部操作都是有效的 (例如 ==, &lt; 或 ^)。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dishes = &#123;<span class="string">'eggs'</span>: <span class="number">2</span>, <span class="string">'sausage'</span>: <span class="number">1</span>, <span class="string">'bacon'</span>: <span class="number">1</span>, <span class="string">'spam'</span>: <span class="number">500</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys = dishes.keys()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values = dishes.values()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># iteration</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> val <span class="keyword">in</span> values:</span><br><span class="line"><span class="meta">... </span>    n += val</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(n)</span><br><span class="line"><span class="number">504</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># keys and values are iterated over in the same order (insertion order)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(keys)</span><br><span class="line">[<span class="string">'eggs'</span>, <span class="string">'sausage'</span>, <span class="string">'bacon'</span>, <span class="string">'spam'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(values)</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">500</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># view objects are dynamic and reflect dict changes</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> dishes[<span class="string">'eggs'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> dishes[<span class="string">'sausage'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(keys)</span><br><span class="line">[<span class="string">'bacon'</span>, <span class="string">'spam'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># set operations</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys &amp; &#123;<span class="string">'eggs'</span>, <span class="string">'bacon'</span>, <span class="string">'salad'</span>&#125;</span><br><span class="line">&#123;<span class="string">'bacon'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys ^ &#123;<span class="string">'sausage'</span>, <span class="string">'juice'</span>&#125;</span><br><span class="line">&#123;<span class="string">'juice'</span>, <span class="string">'sausage'</span>, <span class="string">'bacon'</span>, <span class="string">'spam'</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-0-小结"><a href="#2-0-小结" class="headerlink" title="2.0 小结"></a>2.0 小结</h2><ol>
<li><p>字典是可变类型,键只能是由非hash的数据类型充当</p>
</li>
<li><p>字典子类的<code>__missing__</code>方法。</p>
</li>
<li><p>字典视图的元素为不重复且可哈希。</p>
<p>一张图总结如下</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/python%E5%AD%97%E5%85%B8%E6%80%BB%E7%BB%93.png?raw=true" alt></p>
</li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>记得五年前听过的一句话,赠给自己,也赠给凑巧看到这篇博文的有缘人。</p>
<blockquote>
<h3 id="种一棵树最好的时间是在十年前，其次是现在。"><a href="#种一棵树最好的时间是在十年前，其次是现在。" class="headerlink" title="种一棵树最好的时间是在十年前，其次是现在。"></a>种一棵树最好的时间是在十年前，其次是现在。</h3></blockquote>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>dictionary</tag>
      </tags>
  </entry>
  <entry>
    <title>using python venv to create virtual environment</title>
    <url>/2019/12/26/using-python-venv-to-create-virtual-environment/</url>
    <content><![CDATA[<h1 id="python-env-创建虚拟环境"><a href="#python-env-创建虚拟环境" class="headerlink" title="python env 创建虚拟环境"></a>python env 创建虚拟环境</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又断更了,长此以往,我可能无法完成100天打卡任务了。</p>
<p>红包是刺激自己前进的动力。</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20191223_blog_3.jpg?raw=true" alt></p>
<h2 id="python-标准库03之虚拟环境创建"><a href="#python-标准库03之虚拟环境创建" class="headerlink" title="python 标准库03之虚拟环境创建"></a>python 标准库03之虚拟环境创建</h2><p><a href="https://docs.python.org/zh-cn/3/library/venv.html" target="_blank" rel="noopener">参考文档</a></p>
<p>python目前官方推荐的工具是<code>venv</code></p>
<p>顺便介绍下目前常用的python虚拟环境工具</p>
<ul>
<li>virsualenv</li>
<li>pyvenv (3.3,3.4中推荐的虚拟环境创建工具,3.6中被弃用)</li>
<li>venv(3.6以后推荐的虚拟环境创建工具)</li>
</ul>
<a id="more"></a>
<h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><p>使用下面的命令创建一个虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m venv /path/to/new/virtual/environment</span><br></pre></td></tr></table></figure>
<p>windows下使用venv来创建虚拟环境</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">c:\&gt;c:\Python35\python <span class="literal">-m</span> venv c:\path\to\myenv</span><br></pre></td></tr></table></figure>
<p>使用<code>-h</code>参数可以查看<code>venv</code>命令行的帮助文档</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">usage: venv [-<span class="type">h</span>] [--<span class="type">system</span>-<span class="type">site</span>-<span class="type">packages</span>] [--<span class="type">symlinks</span> | --<span class="type">copies</span>] [--<span class="type">clear</span>]</span><br><span class="line">            [--<span class="type">upgrade</span>] [--<span class="type">without</span>-<span class="type">pip</span>] [--<span class="type">prompt</span> <span class="type">PROMPT</span>]</span><br><span class="line">            ENV_DIR [<span class="type">ENV_DIR</span> <span class="type">...</span>]</span><br><span class="line"></span><br><span class="line">Creates virtual Python environments <span class="keyword">in</span> one or more target directories.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  ENV_DIR               A directory to create the environment in.</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  <span class="literal">-h</span>, -<span class="literal">-help</span>            show this help message and <span class="keyword">exit</span></span><br><span class="line">  -<span class="literal">-system</span><span class="literal">-site</span><span class="literal">-packages</span></span><br><span class="line">                        Give the virtual environment access to the system</span><br><span class="line">                        site<span class="literal">-packages</span> dir.</span><br><span class="line">  -<span class="literal">-symlinks</span>            <span class="keyword">Try</span> to use symlinks rather than copies, when symlinks</span><br><span class="line">                        are not the default <span class="keyword">for</span> the platform.</span><br><span class="line">  -<span class="literal">-copies</span>              <span class="keyword">Try</span> to use copies rather than symlinks, even when</span><br><span class="line">                        symlinks are the default <span class="keyword">for</span> the platform.</span><br><span class="line">  -<span class="literal">-clear</span>               Delete the contents of the environment directory <span class="keyword">if</span> it</span><br><span class="line">                        already exists, before environment creation.</span><br><span class="line">  -<span class="literal">-upgrade</span>             Upgrade the environment directory to use this version</span><br><span class="line">                        of Python, assuming Python has been upgraded <span class="keyword">in</span><span class="literal">-place</span>.</span><br><span class="line">  -<span class="literal">-without</span><span class="literal">-pip</span>         Skips installing or upgrading pip <span class="keyword">in</span> the virtual</span><br><span class="line">                        environment (pip is bootstrapped by default)</span><br><span class="line">  -<span class="literal">-prompt</span> PROMPT       Provides an alternative prompt prefix <span class="keyword">for</span> this</span><br><span class="line">                        environment.</span><br></pre></td></tr></table></figure>
<p>除非你使用了<code>--without-pip</code> 参数,否则 <a href="https://docs.python.org/zh-cn/3/library/ensurepip.html#module-ensurepip" target="_blank" rel="noopener">ensurepip</a> 模块会默认安装<code>pip</code>指令到创建好的虚拟环境中。</p>
<p>一旦一个虚拟环境被创建，可以通过下面的命令激活这个虚拟环境。不同平台下的激活方式略有不同,下面总结了各个平台下虚拟环境的激活命令脚本,请参考。</p>
<h3 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h3><table>
<thead>
<tr>
<th>平台</th>
<th>Shell</th>
<th>用于激活虚拟环境的命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>POSIX</td>
<td>bash/zsh</td>
<td>$ source <venv>/bin/activate</venv></td>
</tr>
<tr>
<td></td>
<td>fish</td>
<td>$ . <venv>/bin/activate.fish</venv></td>
</tr>
<tr>
<td></td>
<td>csh/tcsh</td>
<td>$ source <venv>/bin/activate.csh</venv></td>
</tr>
<tr>
<td></td>
<td>PowerShell Core</td>
<td>$ <venv>/bin/Activate.ps1</venv></td>
</tr>
<tr>
<td>Windows</td>
<td>cmd.exe</td>
<td>C:> <venv>\Scripts\activate.bat</venv></td>
</tr>
<tr>
<td></td>
<td>PowerShell</td>
<td>PS C:> <venv>\Scripts\Activate.ps1</venv></td>
</tr>
</tbody>
</table>
<p>You don’t specifically <em>need</em> to activate an environment; activation just prepends the virtual environment’s binary directory to your path, so that “python” invokes the virtual environment’s Python interpreter and you can run installed scripts without having to use their full path. However, all scripts installed in a virtual environment should be runnable without activating it, and run with the virtual environment’s Python automatically.</p>
<p>You can deactivate a virtual environment by typing “deactivate” in your shell. The exact mechanism is platform-specific and is an internal implementation detail (typically a script or shell function will be used).</p>
<p>你无需关心如何激活一个虚拟环境；使用相对于项目当前路径下的可执行方法,python解析器就可以激活虚拟环境。已经激活的虚拟环境, 就可以使用python的命令直接执行脚本或者安装其他软件包到当前的虚拟环境，而不需要关心是否会污染本地python环境的问题。同样，使用deactivate 就可以退出当前的虚拟环境。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>下面展示的是一个使用<code>EnvBuilder</code> 创建一个自定义虚拟环境的脚本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">class venv.EnvBuilder(system_site_packages=False, clear=False, symlinks=False, upgrade=False, with_pip=False, prompt=None)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>create</code>(<em>env_dir</em>)</p>
<ul>
<li><code>system_site_packages</code> – 一个Boolean值,是否将<code>site-packages</code>添加到虚拟环境中 默认是False.</li>
<li><code>clear</code> – 一个Boolean值,如果为真,将会在创建环境之前清除已经存在的目标路径.</li>
<li><code>symlinks</code> – 一个Boolean值,如果为真,将会在创建环境前删除包含内容的目录  </li>
<li><code>upgrade</code> –  一个Boolean值,如果为真, 则将用正在运行的Python升级现有环境 - 用于在Python就地升级（默认为False）时使用。.</li>
<li><code>with_pip</code> – 一个Boolean值,如果为真,pip命令将会安装到虚拟环境中 ,使用 <a href="https://docs.python.org/zh-cn/3/library/ensurepip.html#module-ensurepip" target="_blank" rel="noopener"><code>ensurepip</code></a> 的默认 <code>--default-pip</code> 参数选项.</li>
<li><code>prompt</code> – 在激活虚拟环境后使用的字符串（默认为None表示将使用环境的目录名称）。.</li>
</ul>
</li>
</ul>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, env_dir)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create a virtualized Python environment in a directory.</span></span><br><span class="line"><span class="string">    env_dir is the target directory to create an environment in.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    env_dir = os.path.abspath(env_dir)</span><br><span class="line">    context = self.ensure_directories(env_dir)</span><br><span class="line">    self.create_configuration(context)</span><br><span class="line">    self.setup_python(context)</span><br><span class="line">    self.setup_scripts(context)</span><br><span class="line">    self.post_setup(context)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>ensure_directories</code>(<em>env_dir</em>)  </p>
<blockquote>
<p>创建环境目录和所有必需的目录，并返回一个上下文对象。这只是属性（如路径）的<br>持有者，供其他方法使用。这些目录已被允许存在，只要其中一个clear或被upgrade<br>指定为允许在现有环境目录上进行操作即可。</p>
</blockquote>
</li>
<li><p><code>create_configuration</code>(<em>context</em>) </p>
<blockquote>
<p>pyvenv.cfg在环境中创建配置文件。</p>
</blockquote>
</li>
<li><p><code>setup_python</code>(<em>context</em>) </p>
<blockquote>
<p>在环境中创建Python可执行文件（以及Windows下的DLL）的副本。在POSIX系统<br>中，如果一个特定的可执行文件 python3.x使用，符号链接python和python3将创建指<br>向该可执行文件，除非已存在具有这些名称的文件。</p>
</blockquote>
</li>
<li><p><code>setup_scripts</code>(<em>context</em>) </p>
<blockquote>
<p>将适合该平台的激活脚本安装到虚拟环境中。</p>
</blockquote>
</li>
<li><p><code>post_setup</code>(<em>context</em>)</p>
<blockquote>
<p>一种占位符方法，可以在第三方实现中重写，以在虚拟环境中预安装包或执行其他后<br>创建步骤。</p>
</blockquote>
<p>此外，EnvBuilder提供这种工具方法，可以从被称为setup_scripts()或post_setup()在子<br>类中，以协助安装自定义脚本到虚拟环境中。<br>install_scripts（上下文，路径）<br>路径是应包含子目录“common”，“posix”，“nt”的目录的路径，每个目录都包含指向环<br>境中bin目录的脚本。os.name经过一些文本替换占位符后，“common”的内容和相应的<br>目录被复制：</p>
<ul>
<li><p><code>__VENV_DIR__</code> 被替换为环境目录的绝对路径。</p>
</li>
<li><p><code>__VENV_NAME__</code> 被替换为环境名称（环境目录的最终路径段）。</p>
</li>
<li><p><code>__VENV_PROMPT__</code> 被提示符替换（环境名称由括号括起来，并带有下面的空格）</p>
</li>
<li><p><code>__VENV_BIN_NAME__</code>被替换为bin目录的名称（bin或者Scripts）。</p>
</li>
<li><p><code>__VENV_PYTHON__</code>被替换为环境可执行文件的绝对路径。<br>允许目录存在（用于在现有环境正在升级时）。</p>
<p>还有一个模块级的便利功能：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">venv.create（env_dir，system_site_packages = False，clear = False，symlinks =</span><br><span class="line">False，with_pip = False ）</span><br></pre></td></tr></table></figure>
<p><code>EnvBuilder</code>用给定的关键字参数创建一个参数，并调用create()并使用<code>env_dir</code>参数。</p>
</li>
</ul>
</li>
</ul>
<h3 id="一个扩展EnvBuilder例子"><a href="#一个扩展EnvBuilder例子" class="headerlink" title="一个扩展EnvBuilder例子"></a>一个扩展<code>EnvBuilder</code>例子</h3><p>以下脚本展示了如何<code>EnvBuilder</code>通过实现将<code>setuptools</code>和<code>pip</code>安装到创建的虚拟环境中的子类来进行扩展：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen, PIPE</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"><span class="keyword">import</span> venv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedEnvBuilder</span><span class="params">(venv.EnvBuilder)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    This builder installs setuptools and pip so that you can pip or</span></span><br><span class="line"><span class="string">    easy_install other packages into the created virtual environment.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param nodist: If true, setuptools and pip are not installed into the</span></span><br><span class="line"><span class="string">                   created virtual environment.</span></span><br><span class="line"><span class="string">    :param nopip: If true, pip is not installed into the created</span></span><br><span class="line"><span class="string">                  virtual environment.</span></span><br><span class="line"><span class="string">    :param progress: If setuptools or pip are installed, the progress of the</span></span><br><span class="line"><span class="string">                     installation can be monitored by passing a progress</span></span><br><span class="line"><span class="string">                     callable. If specified, it is called with two</span></span><br><span class="line"><span class="string">                     arguments: a string indicating some progress, and a</span></span><br><span class="line"><span class="string">                     context indicating where the string is coming from.</span></span><br><span class="line"><span class="string">                     The context argument can have one of three values:</span></span><br><span class="line"><span class="string">                     'main', indicating that it is called from virtualize()</span></span><br><span class="line"><span class="string">                     itself, and 'stdout' and 'stderr', which are obtained</span></span><br><span class="line"><span class="string">                     by reading lines from the output streams of a subprocess</span></span><br><span class="line"><span class="string">                     which is used to install the app.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     If a callable is not specified, default progress</span></span><br><span class="line"><span class="string">                     information is output to sys.stderr.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.nodist = kwargs.pop(<span class="string">'nodist'</span>, <span class="literal">False</span>)</span><br><span class="line">        self.nopip = kwargs.pop(<span class="string">'nopip'</span>, <span class="literal">False</span>)</span><br><span class="line">        self.progress = kwargs.pop(<span class="string">'progress'</span>, <span class="literal">None</span>)</span><br><span class="line">        self.verbose = kwargs.pop(<span class="string">'verbose'</span>, <span class="literal">False</span>)</span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_setup</span><span class="params">(self, context)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Set up any packages which need to be pre-installed into the</span></span><br><span class="line"><span class="string">        virtual environment being created.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param context: The information for the virtual environment</span></span><br><span class="line"><span class="string">                        creation request being processed.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        os.environ[<span class="string">'VIRTUAL_ENV'</span>] = context.env_dir</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.nodist:</span><br><span class="line">            self.install_setuptools(context)</span><br><span class="line">        <span class="comment"># Can't install pip without setuptools</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.nopip <span class="keyword">and</span> <span class="keyword">not</span> self.nodist:</span><br><span class="line">            self.install_pip(context)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">(self, stream, context)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Read lines from a subprocess' output stream and either pass to a progress</span></span><br><span class="line"><span class="string">        callable (if specified) or write progress information to sys.stderr.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        progress = self.progress</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            s = stream.readline()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> progress <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                progress(s, context)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.verbose:</span><br><span class="line">                    sys.stderr.write(<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sys.stderr.write(s.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">                sys.stderr.flush()</span><br><span class="line">        stream.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">install_script</span><span class="params">(self, context, name, url)</span>:</span></span><br><span class="line">        _, _, path, _, _, _ = urlparse(url)</span><br><span class="line">        fn = os.path.split(path)[<span class="number">-1</span>]</span><br><span class="line">        binpath = context.bin_path</span><br><span class="line">        distpath = os.path.join(binpath, fn)</span><br><span class="line">        <span class="comment"># Download script into the virtual environment's binaries folder</span></span><br><span class="line">        urlretrieve(url, distpath)</span><br><span class="line">        progress = self.progress</span><br><span class="line">        <span class="keyword">if</span> self.verbose:</span><br><span class="line">            term = <span class="string">'\n'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            term = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> progress <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            progress(<span class="string">'Installing %s ...%s'</span> % (name, term), <span class="string">'main'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sys.stderr.write(<span class="string">'Installing %s ...%s'</span> % (name, term))</span><br><span class="line">            sys.stderr.flush()</span><br><span class="line">        <span class="comment"># Install in the virtual environment</span></span><br><span class="line">        args = [context.env_exe, fn]</span><br><span class="line">        p = Popen(args, stdout=PIPE, stderr=PIPE, cwd=binpath)</span><br><span class="line">        t1 = Thread(target=self.reader, args=(p.stdout, <span class="string">'stdout'</span>))</span><br><span class="line">        t1.start()</span><br><span class="line">        t2 = Thread(target=self.reader, args=(p.stderr, <span class="string">'stderr'</span>))</span><br><span class="line">        t2.start()</span><br><span class="line">        p.wait()</span><br><span class="line">        t1.join()</span><br><span class="line">        t2.join()</span><br><span class="line">        <span class="keyword">if</span> progress <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            progress(<span class="string">'done.'</span>, <span class="string">'main'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sys.stderr.write(<span class="string">'done.\n'</span>)</span><br><span class="line">        <span class="comment"># Clean up - no longer needed</span></span><br><span class="line">        os.unlink(distpath)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">install_setuptools</span><span class="params">(self, context)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Install setuptools in the virtual environment.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param context: The information for the virtual environment</span></span><br><span class="line"><span class="string">                        creation request being processed.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        url = <span class="string">'https://bitbucket.org/pypa/setuptools/downloads/ez_setup.py'</span></span><br><span class="line">        self.install_script(context, <span class="string">'setuptools'</span>, url)</span><br><span class="line">        <span class="comment"># clear up the setuptools archive which gets downloaded</span></span><br><span class="line">        pred = <span class="keyword">lambda</span> o: o.startswith(<span class="string">'setuptools-'</span>) <span class="keyword">and</span> o.endswith(<span class="string">'.tar.gz'</span>)</span><br><span class="line">        files = filter(pred, os.listdir(context.bin_path))</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">            f = os.path.join(context.bin_path, f)</span><br><span class="line">            os.unlink(f)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">install_pip</span><span class="params">(self, context)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Install pip in the virtual environment.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param context: The information for the virtual environment</span></span><br><span class="line"><span class="string">                        creation request being processed.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        url = <span class="string">'https://raw.github.com/pypa/pip/master/contrib/get-pip.py'</span></span><br><span class="line">        self.install_script(context, <span class="string">'pip'</span>, url)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(args=None)</span>:</span></span><br><span class="line">    compatible = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> sys.version_info &lt; (<span class="number">3</span>, <span class="number">3</span>):</span><br><span class="line">        compatible = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> hasattr(sys, <span class="string">'base_prefix'</span>):</span><br><span class="line">        compatible = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> compatible:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'This script is only for use with '</span></span><br><span class="line">                         <span class="string">'Python 3.3 or later'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">        parser = argparse.ArgumentParser(prog=__name__,</span><br><span class="line">                                         description=<span class="string">'Creates virtual Python '</span></span><br><span class="line">                                                     <span class="string">'environments in one or '</span></span><br><span class="line">                                                     <span class="string">'more target '</span></span><br><span class="line">                                                     <span class="string">'directories.'</span>)</span><br><span class="line">        parser.add_argument(<span class="string">'dirs'</span>, metavar=<span class="string">'ENV_DIR'</span>, nargs=<span class="string">'+'</span>,</span><br><span class="line">                            help=<span class="string">'A directory in which to create the</span></span><br><span class="line"><span class="string">                                 '</span>virtual environment.<span class="string">')</span></span><br><span class="line"><span class="string">        parser.add_argument('</span>--no-setuptools<span class="string">', default=False,</span></span><br><span class="line"><span class="string">                            action='</span>store_true<span class="string">', dest='</span>nodist<span class="string">',</span></span><br><span class="line"><span class="string">                            help="Don'</span>t install setuptools <span class="keyword">or</span> pip <span class="keyword">in</span> the <span class="string">"</span></span><br><span class="line"><span class="string">                                 "</span>virtual environment.<span class="string">")</span></span><br><span class="line"><span class="string">        parser.add_argument('--no-pip', default=False,</span></span><br><span class="line"><span class="string">                            action='store_true', dest='nopip',</span></span><br><span class="line"><span class="string">                            help="</span>Don<span class="string">'t install pip in the virtual "</span></span><br><span class="line"><span class="string">                                 "environment.")</span></span><br><span class="line"><span class="string">        parser.add_argument('</span>--system-site-packages<span class="string">', default=False,</span></span><br><span class="line"><span class="string">                            action='</span>store_true<span class="string">', dest='</span>system_site<span class="string">',</span></span><br><span class="line"><span class="string">                            help='</span>Give the virtual environment access to the <span class="string">'</span></span><br><span class="line"><span class="string">                                 '</span>system site-packages dir.<span class="string">')</span></span><br><span class="line"><span class="string">        if os.name == '</span>nt<span class="string">':</span></span><br><span class="line"><span class="string">            use_symlinks = False</span></span><br><span class="line"><span class="string">        else:</span></span><br><span class="line"><span class="string">            use_symlinks = True</span></span><br><span class="line"><span class="string">        parser.add_argument('</span>--symlinks<span class="string">', default=use_symlinks,</span></span><br><span class="line"><span class="string">                            action='</span>store_true<span class="string">', dest='</span>symlinks<span class="string">',</span></span><br><span class="line"><span class="string">                            help='</span>Try to use symlinks rather than copies, <span class="string">'</span></span><br><span class="line"><span class="string">                                 '</span>when symlinks are <span class="keyword">not</span> the default <span class="keyword">for</span> <span class="string">'</span></span><br><span class="line"><span class="string">                                 '</span>the platform.<span class="string">')</span></span><br><span class="line"><span class="string">        parser.add_argument('</span>--clea<span class="string">r', default=False, action='</span>store_true<span class="string">',</span></span><br><span class="line"><span class="string">                            dest='</span>clea<span class="string">r', help='</span>Delete the contents of the <span class="string">'</span></span><br><span class="line"><span class="string">                                               '</span>virtual environment <span class="string">'</span></span><br><span class="line"><span class="string">                                               '</span>directory <span class="keyword">if</span> it already <span class="string">'</span></span><br><span class="line"><span class="string">                                               '</span>exists, before virtual <span class="string">'</span></span><br><span class="line"><span class="string">                                               '</span>environment creation.<span class="string">')</span></span><br><span class="line"><span class="string">        parser.add_argument('</span>--upgrade<span class="string">', default=False, action='</span>store_true<span class="string">',</span></span><br><span class="line"><span class="string">                            dest='</span>upgrade<span class="string">', help='</span>Upgrade the virtual <span class="string">'</span></span><br><span class="line"><span class="string">                                                 '</span>environment directory to <span class="string">'</span></span><br><span class="line"><span class="string">                                                 '</span>use this version of <span class="string">'</span></span><br><span class="line"><span class="string">                                                 '</span>Python, assuming Python <span class="string">'</span></span><br><span class="line"><span class="string">                                                 '</span>has been upgraded <span class="string">'</span></span><br><span class="line"><span class="string">                                                 '</span><span class="keyword">in</span>-place.<span class="string">')</span></span><br><span class="line"><span class="string">        parser.add_argument('</span>--verbose<span class="string">', default=False, action='</span>store_true<span class="string">',</span></span><br><span class="line"><span class="string">                            dest='</span>verbose<span class="string">', help='</span>Display the output <span class="string">'</span></span><br><span class="line"><span class="string">                                               '</span><span class="keyword">from</span> the scripts which <span class="string">'</span></span><br><span class="line"><span class="string">                                               '</span>install setuptools <span class="keyword">and</span> pip.<span class="string">')</span></span><br><span class="line"><span class="string">        options = parser.parse_args(args)</span></span><br><span class="line"><span class="string">        if options.upgrade and options.clear:</span></span><br><span class="line"><span class="string">            raise ValueError('</span>you cannot supply --upgrade <span class="keyword">and</span> --clear together.<span class="string">')</span></span><br><span class="line"><span class="string">        builder = ExtendedEnvBuilder(system_site_packages=options.system_site,</span></span><br><span class="line"><span class="string">                                       clear=options.clear,</span></span><br><span class="line"><span class="string">                                       symlinks=options.symlinks,</span></span><br><span class="line"><span class="string">                                       upgrade=options.upgrade,</span></span><br><span class="line"><span class="string">                                       nodist=options.nodist,</span></span><br><span class="line"><span class="string">                                       nopip=options.nopip,</span></span><br><span class="line"><span class="string">                                       verbose=options.verbose)</span></span><br><span class="line"><span class="string">        for d in options.dirs:</span></span><br><span class="line"><span class="string">            builder.create(d)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ == '</span>__main__<span class="string">':</span></span><br><span class="line"><span class="string">    rc = 1</span></span><br><span class="line"><span class="string">    try:</span></span><br><span class="line"><span class="string">        main()</span></span><br><span class="line"><span class="string">        rc = 0</span></span><br><span class="line"><span class="string">    except Exception as e:</span></span><br><span class="line"><span class="string">        print('</span>Error: %s<span class="string">' % e, file=sys.stderr)</span></span><br><span class="line"><span class="string">    sys.exit(rc)</span></span><br></pre></td></tr></table></figure>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在windows下<code>vscode</code>中通过venv 创建虚拟环境步骤:</p>
<ol>
<li><p><code>powershell</code>下,执行命令 <code>python -m venv .venv</code></p>
</li>
<li><p>执行激活命令 <code>.\Scripts\activate.ps1</code></p>
</li>
<li><p>退出虚拟环境  在项目目录下执行<code>deactivate</code> 即可。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>venv</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library csv</title>
    <url>/2020/01/02/python-standard-library-csv/</url>
    <content><![CDATA[<h1 id="python-标准库学习之csv"><a href="#python-标准库学习之csv" class="headerlink" title="python 标准库学习之csv"></a>python 标准库学习之<code>csv</code></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2019年立的flag,今年继续,标准库系列文章继续更新。</p>
<p>今天是真冷啊,屋里头才16℃,只能用一张图来表示我的心情。</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200102_not_cold.jpg?raw=true" alt></p>
<h2 id="标准库-csv"><a href="#标准库-csv" class="headerlink" title="标准库 csv"></a>标准库 csv</h2><h3 id="文档路径"><a href="#文档路径" class="headerlink" title="文档路径"></a>文档路径</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/csv.html" target="_blank" rel="noopener">python标准库csv</a></p>
<h3 id="CSV-文件格式"><a href="#CSV-文件格式" class="headerlink" title="CSV 文件格式"></a><code>CSV</code> 文件格式</h3><p>文件扩展名为.csv,通用的电子表格文件格式,经常使用在数据分析中。</p>
<p>分隔符可能有所差别, python中的csv模块提供了对csv文件的读写操作,非常方便。</p>
<h3 id="csv-常用方法"><a href="#csv-常用方法" class="headerlink" title="csv 常用方法"></a><code>csv</code> 常用方法</h3><h4 id="csv-reader-csvfile-dialect-39-excel-39-fmtparams"><a href="#csv-reader-csvfile-dialect-39-excel-39-fmtparams" class="headerlink" title="csv.reader(csvfile,dialect=&#39;excel&#39;, ***fmtparams)"></a><code>csv.reader(csvfile,dialect=&#39;excel&#39;, ***fmtparams)</code></h4><blockquote>
<p>返回一个reader对象,该对象遍历csvfile。csv对象可以是任何对象,只要这个对象支持iteratable协议,并在每次调用<code>__next__()</code>方法时都返回字符串即可。如果csvfile是文件对象,则打开它时应使用<code>newline=&#39;&#39;</code>。可选参数dialect是用于不同的csv文件类型,它可以是 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Dialect" target="_blank" rel="noopener"><code>Dialect</code></a> 类的子类的实例，也可以是 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.list_dialects" target="_blank" rel="noopener"><code>list_dialects()</code></a> 函数返回的字符串之一。完整的解释可以参考<a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv-fmt-params" target="_blank" rel="noopener">csv文件格式参数</a>。</p>
<p>csv文件的每一行都会默认当做字符串列表解析,除非指定了 <code>QUOTE_NONNUMERIC</code> 格式选项（在这种情况下，未加引号的字段会转换为浮点数），否则不会执行自动数据类型转换。</p>
</blockquote>
<p>一个读文件例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> csv</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'eggs.csv'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line"><span class="meta">... </span>    spamreader = csv.reader(csvfile, delimiter=<span class="string">' '</span>, quotechar=<span class="string">'|'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> row <span class="keyword">in</span> spamreader:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">', '</span>.join(row))</span><br><span class="line">Spam, Spam, Spam, Spam, Spam, Baked Beans</span><br><span class="line">Spam, Lovely Spam, Wonderful Spam</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="csv-writer-csvfile-dialect-39-excel-39-fmtparams"><a href="#csv-writer-csvfile-dialect-39-excel-39-fmtparams" class="headerlink" title="csv.writer(csvfile, dialect=&#39;excel&#39;, **fmtparams)"></a><code>csv.writer(csvfile, dialect=&#39;excel&#39;, **fmtparams)</code></h4><blockquote>
<p>返回一个 writer 对象，该对象负责将用户的数据在给定的文件类对象上转换为带分隔符的字符串。<em>csvfile</em> 可以是具有 <code>write()</code> 方法的任何对象。如果 <em>csvfile</em> 是文件对象，则打开它时应使用 <code>newline=&#39;&#39;</code>。</p>
<p>为了尽量简化与数据库 API 模块之间的对接，<a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 值会写入为空字符串。虽然这个转换是不可逆的，但它让 SQL 空数据值转储到 CSV 文件更容易，而无需预处理从 <code>cursor.fetch*</code> 调用返回的数据。写入前，所有非字符串数据都先用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a> 转化为字符串再写入。</p>
</blockquote>
<p>一个写文件例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'eggs.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    spamwriter = csv.writer(csvfile, delimiter=<span class="string">' '</span>,</span><br><span class="line">                            quotechar=<span class="string">'|'</span>, quoting=csv.QUOTE_MINIMAL)</span><br><span class="line">    spamwriter.writerow([<span class="string">'Spam'</span>] * <span class="number">5</span> + [<span class="string">'Baked Beans'</span>])</span><br><span class="line">    spamwriter.writerow([<span class="string">'Spam'</span>, <span class="string">'Lovely Spam'</span>, <span class="string">'Wonderful Spam'</span>])</span><br></pre></td></tr></table></figure>
<h4 id="csv-register-dialect-name-dialect-fmtparams"><a href="#csv-register-dialect-name-dialect-fmtparams" class="headerlink" title="csv.register_dialect(name[, dialect[, **fmtparams]])"></a><code>csv.register_dialect(name[, dialect[, **fmtparams]])</code></h4><blockquote>
<p>将 <em>name</em> 与 <em>dialect</em> 关联起来。<em>name</em> 必须是字符串。要指定变种 (dialect)，可以给出 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Dialect" target="_blank" rel="noopener"><code>Dialect</code></a> 的子类，或给出 <em>fmtparams</em> 关键字参数，或两者都给出（此时关键字参数会覆盖 <em>dialect</em> 参数）。 有关方言和格式设置参数的完整详细信息，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv-fmt-params" target="_blank" rel="noopener">方言格式参数</a> 部分。</p>
</blockquote>
<p>其他方法:</p>
<ul>
<li><p><code>csv.unregister_dialect(name)</code></p>
<p>从变种注册表中删除 <em>name</em> 对应的变种。如果 <em>name</em> 不是已注册的变种名称，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Error" target="_blank" rel="noopener"><code>Error</code></a> 异常。</p>
</li>
<li><p><code>csv.get_dialect(name)</code></p>
<p>返回 <em>name</em> 对应的变种。如果 <em>name</em> 不是已注册的变种名称，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Error" target="_blank" rel="noopener"><code>Error</code></a> 异常。该函数返回的是不可变的 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Dialect" target="_blank" rel="noopener"><code>Dialect</code></a> 对象。</p>
</li>
<li><p><code>csv.list_dialects()</code></p>
<p>返回所有已注册变种的名称。</p>
</li>
<li><p><code>csv.field_size_limit([new_limit])</code></p>
<p>返回解析器当前允许的最大字段大小。如果指定了 <em>new_limit</em>，则它将成为新的最大字段大小。</p>
</li>
</ul>
<h3 id="csv模块定义的类"><a href="#csv模块定义的类" class="headerlink" title="csv模块定义的类"></a>csv模块定义的类</h3><h4 id="class-csv-DictReader-f-fieldnames-None-restkey-None-restval-None-dialect-39-excel-39-args-kwds"><a href="#class-csv-DictReader-f-fieldnames-None-restkey-None-restval-None-dialect-39-excel-39-args-kwds" class="headerlink" title="class csv.DictReader(*f*, *fieldnames=None*, *restkey=None*, *restval=None*, *dialect=&#39;excel&#39;*, **args*, ***kwds*)"></a><code>class csv.DictReader(*f*, *fieldnames=None*, *restkey=None*, *restval=None*, *dialect=&#39;excel&#39;*, **args*, ***kwds*)</code></h4><blockquote>
<p>创建一个对象，该对象在操作上类似于常规 reader，但是将每行中的信息映射到一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>，该 dict 的键由 <em>fieldnames</em> 可选参数给出。</p>
<p><em>fieldnames</em> 参数是一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-sequence" target="_blank" rel="noopener">sequence</a>。如果省略 <em>fieldnames</em>，则文件 <em>f</em> 第一行中的值将用作字段名。无论字段名是如何确定的，字典都将保留其原始顺序。</p>
<p>如果某一行中的字段多于字段名，则其余字段将放入列表中，字段名由 <em>restkey</em> 指定（默认为 <code>None</code>）。如果非空白行的字段少于字段名，则缺少的值将用 <code>None</code> 填充。</p>
<p>所有其他可选或关键字参数都传递给底层的 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.reader" target="_blank" rel="noopener"><code>reader</code></a> 实例。</p>
<p>3.8 中,返回的行是 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 类型。</p>
</blockquote>
<p>一个使用<code>DictReader</code>例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> csv</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'names.csv'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line"><span class="meta">... </span>    reader = csv.DictReader(csvfile)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line"><span class="meta">... </span>        print(row[<span class="string">'first_name'</span>], row[<span class="string">'last_name'</span>])</span><br><span class="line">...</span><br><span class="line">Eric Idle</span><br><span class="line">John Cleese</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(row)</span><br><span class="line">&#123;<span class="string">'first_name'</span>: <span class="string">'John'</span>, <span class="string">'last_name'</span>: <span class="string">'Cleese'</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="class-csv-DictWriter-f-fieldnames-restval-39-39-extrasaction-39-raise-39-dialect-39-excel-39-args-kwds"><a href="#class-csv-DictWriter-f-fieldnames-restval-39-39-extrasaction-39-raise-39-dialect-39-excel-39-args-kwds" class="headerlink" title="class csv.DictWriter(f, fieldnames, restval=&#39;&#39;, extrasaction=&#39;raise&#39;, dialect=&#39;excel&#39;, **args, **kwds)"></a><code>class csv.DictWriter(f, fieldnames, restval=&#39;&#39;, extrasaction=&#39;raise&#39;, dialect=&#39;excel&#39;, **args, **kwds)</code></h4><blockquote>
<p>创建一个对象，该对象在操作上类似常规 writer，但会将字典映射到输出行。 <em>fieldnames</em> 参数是由键组成的 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#module-collections.abc" target="_blank" rel="noopener"><code>序列</code></a>，它指定字典中值的顺序，这些值会按指定顺序传递给 <code>writerow()</code> 方法并写入文件 <em>f</em>。 如果字典缺少 <em>fieldnames</em> 中的键，则可选参数 <em>restval</em> 用于指定要写入的值。 如果传递给 <code>writerow()</code> 方法的字典的某些键在 <em>fieldnames</em> 中找不到，则可选参数 <em>extrasaction</em> 用于指定要执行的操作。 如果将其设置为默认值 <code>&#39;raise&#39;</code>，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。 如果将其设置为 <code>&#39;ignore&#39;</code>，则字典中的其他键值将被忽略。 所有其他可选或关键字参数都传递给底层的 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.writer" target="_blank" rel="noopener"><code>writer</code></a> 实例。</p>
<p>注意，与 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.DictReader" target="_blank" rel="noopener"><code>DictReader</code></a> 类不同，<a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.DictWriter" target="_blank" rel="noopener"><code>DictWriter</code></a> 类的 <em>fieldnames</em> 参数不是可选参数</p>
</blockquote>
<p>一个使用<code>DictWriter</code>写入文件例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'names.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    fieldnames = [<span class="string">'first_name'</span>, <span class="string">'last_name'</span>]</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line"></span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerow(&#123;<span class="string">'first_name'</span>: <span class="string">'Baked'</span>, <span class="string">'last_name'</span>: <span class="string">'Beans'</span>&#125;)</span><br><span class="line">    writer.writerow(&#123;<span class="string">'first_name'</span>: <span class="string">'Lovely'</span>, <span class="string">'last_name'</span>: <span class="string">'Spam'</span>&#125;)</span><br><span class="line">    writer.writerow(&#123;<span class="string">'first_name'</span>: <span class="string">'Wonderful'</span>, <span class="string">'last_name'</span>: <span class="string">'Spam'</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>其他方法:</p>
<ul>
<li><p><em>class</em> <code>csv.Dialect</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Dialect" target="_blank" rel="noopener"><code>Dialect</code></a> 类是主要依赖于其属性的容器类，用于将定义好的参数传递给特定的 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.reader" target="_blank" rel="noopener"><code>reader</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.writer" target="_blank" rel="noopener"><code>writer</code></a> 实例。</p>
</li>
<li><p><em>class</em> <code>csv.excel</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.excel" target="_blank" rel="noopener"><code>excel</code></a> 类定义了 Excel 生成的 CSV 文件的常规属性。它在变种注册表中的名称是 <code>&#39;excel&#39;</code>。</p>
</li>
<li><p><em>class</em> <code>csv.excel_tab</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.excel_tab" target="_blank" rel="noopener"><code>excel_tab</code></a> 类定义了 Excel 生成的、制表符分隔的 CSV 文件的常规属性。它在变种注册表中的名称是 <code>&#39;excel-tab&#39;</code>。</p>
</li>
<li><p><em>class</em> <code>csv.unix_dialect</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.unix_dialect" target="_blank" rel="noopener"><code>unix_dialect</code></a> 类定义了在 UNIX 系统上生成的 CSV 文件的常规属性，即使用 <code>&#39;\n&#39;</code> 作为换行符，且所有字段都有引号包围。它在变种注册表中的名称是 <code>&#39;unix&#39;</code>。</p>
</li>
</ul>
<h4 id="class-csv-Sniffer"><a href="#class-csv-Sniffer" class="headerlink" title="class csv.Sniffer"></a><code>class csv.Sniffer</code></h4><p><a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Sniffer" target="_blank" rel="noopener"><code>Sniffer</code></a> 类用于推断 CSV 文件的格式。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Sniffer" target="_blank" rel="noopener"><code>Sniffer</code></a> 类提供了两个方法：</p>
<ul>
<li><p><code>sniff</code>(<em>sample</em>, <em>delimiters=None</em>)</p>
<p>分析给定的 <em>sample</em> 并返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Dialect" target="_blank" rel="noopener"><code>Dialect</code></a> 子类，该子类中包含了分析出的格式参数。如果给出可选的 <em>delimiters</em> 参数，则该参数会被解释为字符串，该字符串包含了可能的有效定界符。</p>
</li>
<li><p><code>has_header</code>(<em>sample</em>)</p>
<p>分析示例文本（假定为 CSV 格式），如果第一行很可能是一系列列标题，则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>。</p>
</li>
</ul>
<p>一个使用Sniffer的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ith open(<span class="string">'example.csv'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    dialect = csv.Sniffer().sniff(csvfile.read(<span class="number">1024</span>))</span><br><span class="line">    csvfile.seek(<span class="number">0</span>)</span><br><span class="line">    reader = csv.reader(csvfile, dialect)</span><br><span class="line">    <span class="comment"># ... process CSV file contents here ...</span></span><br></pre></td></tr></table></figure>
<h3 id="csv-中定义的常量"><a href="#csv-中定义的常量" class="headerlink" title="csv 中定义的常量"></a>csv 中定义的常量</h3><ul>
<li><p><code>csv.`</code>QUOTE_ALL`</p>
<p>指示 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.writer" target="_blank" rel="noopener"><code>writer</code></a> 对象给所有字段加上引号。</p>
</li>
<li><p><code>csv.`</code>QUOTE_MINIMAL`</p>
<p>指示 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.writer" target="_blank" rel="noopener"><code>writer</code></a> 对象仅为包含特殊字符（例如 <em>定界符</em>、<em>引号字符</em> 或 <em>行结束符</em> 中的任何字符）的字段加上引号。</p>
</li>
<li><p><code>csv.`</code>QUOTE_NONNUMERIC`</p>
<p>指示 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.writer" target="_blank" rel="noopener"><code>writer</code></a> 对象为所有非数字字段加上引号。指示 reader 将所有未用引号引出的字段转换为 <em>float</em> 类型。</p>
</li>
<li><p><code>csv.`</code>QUOTE_NONE`</p>
<p>指示 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.writer" target="_blank" rel="noopener"><code>writer</code></a> 对象不使用引号引出字段。当 <em>定界符</em> 出现在输出数据中时，其前面应该有 <em>转义符</em>。如果未设置 <em>转义符</em>，则遇到任何需要转义的字符时，writer 都会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Error" target="_blank" rel="noopener"><code>Error</code></a> 异常。指示 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.reader" target="_blank" rel="noopener"><code>reader</code></a> 不对引号字符进行特殊处理。</p>
</li>
</ul>
<h3 id="csv模块定义了以下异常："><a href="#csv模块定义了以下异常：" class="headerlink" title="csv模块定义了以下异常："></a><code>csv</code>模块定义了以下异常：</h3><ul>
<li><p><em>exception</em> <code>csv.`</code>Error`</p>
<p>该异常可能由任何发生错误的函数抛出。</p>
</li>
</ul>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>如果没有指定 <code>newline=&#39;&#39;</code>，则嵌入引号中的换行符将无法正确解析，并且在写入时，使用 <code>\r\n</code> 换行的平台会有多余的 <code>\r</code> 写入。由于 csv 模块会执行自己的（<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-universal-newlines" target="_blank" rel="noopener">通用</a>）换行符处理，因此指定 <code>newline=&#39;&#39;</code> 应该总是安全的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>csv模块是一个非常实用的处理csv文件的标准库，提供了两个核心类。一个是把csv文件对象当作字符串列表解析csv文件的类，另一个是把csv文件对象当作字典解析的类。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>csv</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library webbrowser</title>
    <url>/2020/01/03/python-standard-library-webbrowser/</url>
    <content><![CDATA[<h1 id="python-标准库之-webbrowser"><a href="#python-标准库之-webbrowser" class="headerlink" title="python 标准库之 webbrowser"></a>python 标准库之 webbrowser</h1><h2 id="没啥前提"><a href="#没啥前提" class="headerlink" title="没啥前提"></a>没啥前提</h2><p>一张图表示我现在的心情</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200103_cold.jpg?raw=true" alt="冷啊"></p>
<h2 id="标准库-webbrowser"><a href="#标准库-webbrowser" class="headerlink" title="标准库 webbrowser"></a>标准库 webbrowser</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#module-webbrowser" target="_blank" rel="noopener"><code>webbrowser</code></a> 模块提供了一个高级接口，允许向用户显示基于Web的文档。 在大多数情况下，只需从该模块调用 <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.open" target="_blank" rel="noopener"><code>open()</code></a> 函数就可以了。</p>
<p>在 Unix 下，图形浏览器在 X11 下是首选，但如果图形浏览器不可用或 X11 显示不可用，则将使用文本模式浏览器。 如果使用文本模式浏览器，则调用进程将阻塞，直到用户退出浏览器。</p>
<p>如果存在环境变量 <code>BROWSER</code> ，则将其解释为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pathsep" target="_blank" rel="noopener"><code>os.pathsep</code></a> 分隔的浏览器列表，以便在平台默认值之前尝试。 当列表部分的值包含字符串 <code>％s</code> 时，它被解释为一个文字浏览器命令行，用于替换 <code>％s</code> 的参数 URL ；如果该部分不包含 <code>％s</code>，则它只被解释为要启动的浏览器的名称。</p>
<p>脚本 <strong>webbrowser</strong> 可以用作模块的命令行界面。它接受一个 URL 作为参数。还接受以下可选参数：<code>-n</code> 如果可能，在新的浏览器窗口中打开 URL ； <code>-t</code> 在新的浏览器页面（“标签”）中打开 URL。这些选择当然是相互排斥的。用法示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m webbrowser -t <span class="string">"https://jeffsui.github.io"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><em>exception</em> <code>webbrowser.`</code>Error`</p>
<p>发生浏览器控件错误时引发异常。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p><code>webbrowser.`</code>open`(<em>url</em>, <em>new=0</em>, <em>autoraise=True</em>)</p>
<p>使用默认浏览器显示 <em>url</em>。 如果 <em>new</em> 为 0，则尽可能在同一浏览器窗口中打开 <em>url</em>。 如果 <em>new</em> 为 1，则尽可能打开新的浏览器窗口。 如果 <em>new</em> 为 2，则尽可能打开新的浏览器页面（“标签”）。 如果 <em>autoraise</em> 为 “True”，则会尽可能置前窗口（请注意，在许多窗口管理器下，无论此变量的设置如何，都会置前窗口）。请注意，在某些平台上，尝试使用此函数打开文件名，可能会起作用并启动操作系统的关联程序。 但是，这种方式不被支持也不可移植。使用 <code>url</code> 参数会引发 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">auditing event</a> <code>webbrowser.open</code> 。</p>
</li>
<li><p><code>webbrowser.open_new(url)</code></p>
<p>如果可能，在默认浏览器的新窗口中打开 <em>url</em>，否则，在唯一的浏览器窗口中打开 <em>url</em>。</p>
</li>
<li><p><code>webbrowser.open_new_tab(url)</code></p>
<p>如果可能，在默认浏览器的新页面（“标签”）中打开 <em>url</em>，否则等效于 <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.open_new" target="_blank" rel="noopener"><code>open_new()</code></a>。</p>
</li>
<li><p><code>webbrowser.get(*using=None*)</code></p>
<p>返回浏览器类型为 <em>using</em> 指定的控制器对象。 如果 <em>using</em> 为 <code>None</code>，则返回适用于调用者环境的默认浏览器的控制器。</p>
</li>
<li><p><code>webbrowser.register</code>(<em>name</em>, <em>constructor</em>, <em>instance=None</em>, <em>**, </em>preferred=False*)</p>
<p>注册 <em>name</em> 浏览器类型。 注册浏览器类型后， <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.get" target="_blank" rel="noopener"><code>get()</code></a> 函数可以返回该浏览器类型的控制器。 如果没有提供 <em>instance</em>，或者为 <code>None</code>，<em>constructor</em> 将在没有参数的情况下被调用，以在需要时创建实例。 如果提供了 <em>instance</em>，则永远不会调用 <em>constructor</em>，并且可能是 <code>None</code>。将 <em>preferred</em> 设置为 <code>True</code> 使得这个浏览器成为 <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.get" target="_blank" rel="noopener"><code>get()</code></a> 不带参数调用的首选结果。 否则，只有在您计划设置 <code>BROWSER</code> 变量，或使用与您声明的处理程序的名称相匹配的非空参数调用 <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.get" target="_blank" rel="noopener"><code>get()</code></a> 时，此入口点才有用。</p>
</li>
</ul>
<h3 id="浏览器类型"><a href="#浏览器类型" class="headerlink" title="浏览器类型"></a>浏览器类型</h3><p>预定义了许多浏览器类型。 此表给出了可以传递给 <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.get" target="_blank" rel="noopener"><code>get()</code></a> 函数的类型名称以及控制器类的相应实例化，这些都在此模块中定义。</p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>类名</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&#39;mozilla&#39;</code></td>
<td><code>Mozilla(&#39;mozilla&#39;)</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;firefox&#39;</code></td>
<td><code>Mozilla(&#39;mozilla&#39;)</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;netscape&#39;</code></td>
<td><code>Mozilla(&#39;netscape&#39;)</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;galeon&#39;</code></td>
<td><code>Galeon(&#39;galeon&#39;)</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;epiphany&#39;</code></td>
<td><code>Galeon(&#39;epiphany&#39;)</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;skipstone&#39;</code></td>
<td><code>BackgroundBrowser(&#39;skipstone&#39;)</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;kfmclient&#39;</code></td>
<td><code>Konqueror()</code></td>
<td>(1)</td>
</tr>
<tr>
<td><code>&#39;konqueror&#39;</code></td>
<td><code>Konqueror()</code></td>
<td>(1)</td>
</tr>
<tr>
<td><code>&#39;kfm&#39;</code></td>
<td><code>Konqueror()</code></td>
<td>(1)</td>
</tr>
<tr>
<td><code>&#39;mosaic&#39;</code></td>
<td><code>BackgroundBrowser(&#39;mosaic&#39;)</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;opera&#39;</code></td>
<td><code>Opera()</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;grail&#39;</code></td>
<td><code>Grail()</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;links&#39;</code></td>
<td><code>GenericBrowser(&#39;links&#39;)</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;elinks&#39;</code></td>
<td><code>Elinks(&#39;elinks&#39;)</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;lynx&#39;</code></td>
<td><code>GenericBrowser(&#39;lynx&#39;)</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;w3m&#39;</code></td>
<td><code>GenericBrowser(&#39;w3m&#39;)</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;windows-default&#39;</code></td>
<td><code>WindowsDefault</code></td>
<td>(2)</td>
</tr>
<tr>
<td><code>&#39;macosx&#39;</code></td>
<td><code>MacOSX(&#39;default&#39;)</code></td>
<td>(3)</td>
</tr>
<tr>
<td><code>&#39;safari&#39;</code></td>
<td><code>MacOSX(&#39;safari&#39;)</code></td>
<td>(3)</td>
</tr>
<tr>
<td><code>&#39;google-chrome&#39;</code></td>
<td><code>Chrome(&#39;google-chrome&#39;)</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;chrome&#39;</code></td>
<td><code>Chrome(&#39;chrome&#39;)</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;chromium&#39;</code></td>
<td><code>Chromium(&#39;chromium&#39;)</code></td>
<td></td>
</tr>
<tr>
<td><code>&#39;chromium-browser&#39;</code></td>
<td><code>Chromium(&#39;chromium-browser&#39;)</code></td>
</tr>
</tbody>
</table>
<p>简单的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">'http://docs.python.org/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Open URL in a new tab, if a browser window is already open.</span></span><br><span class="line">webbrowser.open_new_tab(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Open URL in new window, raising the window if possible.</span></span><br><span class="line">webbrowser.open_new(url)</span><br></pre></td></tr></table></figure>
<h3 id="浏览器控制器对象"><a href="#浏览器控制器对象" class="headerlink" title="浏览器控制器对象"></a>浏览器控制器对象</h3><p>浏览器控制器提供三个与模块级便捷函数相同的方法：</p>
<ul>
<li><p><code>controller.open</code>(<em>url</em>, <em>new=0</em>, <em>autoraise=True</em>)`</p>
<p>使用此控制器处理的浏览器显示 <em>url</em>。 如果 <em>new</em> 为 1，则尽可能打开新的浏览器窗口。 如果 <em>new</em> 为 2，则尽可能打开新的浏览器页面（“标签”）。</p>
</li>
<li><p><code>controller.open_new</code>(<em>url</em>)`</p>
<p>如果可能，在此控制器处理的浏览器的新窗口中打开 <em>url</em> ，否则，在唯一的浏览器窗口中打开 <em>url</em> 。 别名 <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.open_new" target="_blank" rel="noopener"><code>open_new()</code></a>。</p>
</li>
<li><p><code>controller.open_new_tab</code>(<em>url</em>)`</p>
<p>如果可能，在此控制器处理的浏览器的新页面（“标签”）中打开 <em>url</em>，否则等效于 <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.open_new" target="_blank" rel="noopener"><code>open_new()</code></a></p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>标准库中的webbrowser只提供了一个简单的操作本地浏览器的接口。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>webbrowser</tag>
      </tags>
  </entry>
  <entry>
    <title>windows jupyter notebook nbextension usage</title>
    <url>/2020/01/04/windows-jupyter-notebook-nbextension-usage/</url>
    <content><![CDATA[<h1 id="windows下jupyter-安装nbextension-插件填坑记"><a href="#windows下jupyter-安装nbextension-插件填坑记" class="headerlink" title="windows下jupyter 安装nbextension 插件填坑记"></a>windows下jupyter 安装nbextension 插件填坑记</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200104_cold.png?raw=true" alt></p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><table>
<thead>
<tr>
<th>软件和操作系统</th>
<th>版本号</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>win7 64位 sp1</td>
</tr>
<tr>
<td>python版本</td>
<td>3.6.2</td>
</tr>
<tr>
<td>jupyter core</td>
<td>4.5.0</td>
</tr>
<tr>
<td>jupyter notebook</td>
<td>6.0.0</td>
</tr>
</tbody>
</table>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>本来以为给jupyter安装个插件,分分钟搞定的事,结果三天了还是没解决。</p>
<p>我回家用win10的电脑,5分钟搞定。</p>
<p>尝试了各种方式,卸载重装,修改环境变量,换不同的python版本。后来我快要放放弃的时候，我终于搞定了。</p>
<a id="more"></a>
<h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>我突然想到,是不是因为我安装了anaconda,于是增加了搜索关键字,终于发现了问题所在。</p>
<h2 id="正确操作步骤"><a href="#正确操作步骤" class="headerlink" title="正确操作步骤"></a>正确操作步骤</h2><ol>
<li><p>确定是已经安装好<code>anaconda</code></p>
</li>
<li><p>要在<strong><code>anaconda prompt</code></strong>模式下(重要的事情说三遍,三遍,三遍，此处省略一万字,万马奔腾)</p>
</li>
<li><p><code>pip install jupyter_contrib_nbextensions</code></p>
</li>
<li><p>配置：<code>jupyter contrib nbextension install --user --skip-running-check</code></p>
</li>
<li><p>启动<code>jupyter notebook</code>，“Nbextensions”出现在导航栏中，在勾选目录。  </p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20190418142848765.png?raw=true" alt></p>
</li>
</ol>
<h2 id="查看-jupyter-版本"><a href="#查看-jupyter-版本" class="headerlink" title="查看 jupyter 版本"></a>查看 jupyter 版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) C:\Users\Mr.Sui&gt;jupyter --version</span><br><span class="line">jupyter core     : 4.5.0</span><br><span class="line">jupyter-notebook : 6.0.0</span><br><span class="line">qtconsole        : 4.5.1</span><br><span class="line">ipython          : 7.6.1</span><br><span class="line">ipykernel        : 5.1.1</span><br><span class="line">jupyter client   : 5.3.1</span><br><span class="line">jupyter lab      : 1.0.2</span><br><span class="line">nbconvert        : 5.5.0</span><br><span class="line">ipywidgets       : 7.5.0</span><br><span class="line">nbformat         : 4.4.0</span><br><span class="line">traitlets        : 4.3.2</span><br></pre></td></tr></table></figure>
<h2 id="有用的插件"><a href="#有用的插件" class="headerlink" title="有用的插件"></a>有用的插件</h2><ol>
<li>代码导航功能 Table of Contents</li>
<li>变量检查器 Variable Inspector</li>
<li>显示单元格运行的时间和长度 Excute time</li>
<li>折叠/放下标题 Collapsible Headings</li>
<li>折叠代码 Codefolding</li>
<li>隐藏代码 hide input 隐藏选定代码 hide input all 隐藏所有代码</li>
<li>代码自动补全 Hinterland</li>
<li>通知 Notify Jupyter Notebook</li>
</ol>
<blockquote>
<p>首先你要勾选Notify扩展，其次再点击按钮正式启动。你选择的时间是Jupyter Notebook运行的最短时间，到点后它会向你发送通知</p>
</blockquote>
<ol start="9">
<li><p>隐藏活动状态栏 zenmode</p>
</li>
<li><p>tqdm_notebook 为循环代码显示执行进度条</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 先安装 tqdm ：pip install tqdm</span><br><span class="line"># 使用时导入：from tqdm import tqdm_notebook</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>脚本自动保存 AutoSaveTime</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/install.html#install-the-python-package" target="_blank" rel="noopener">官网教程</a></p>
<p><a href="https://blog.csdn.net/qq_34705900/article/details/80197956" target="_blank" rel="noopener">jupyter notebook的插件拓展—-jupyter_contrib_nbextensions</a></p>
<p><a href="https://www.cnblogs.com/noticeable/p/9010881.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/noticeable/p/9010881.html" target="_blank" rel="noopener">使用Jupyter Notebook编写技术文档</a></a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>python</tag>
        <tag>juypter</tag>
        <tag>nbextension</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library http.server</title>
    <url>/2020/01/05/python-standard-library-http-server/</url>
    <content><![CDATA[<h1 id="python-标准库之-http-server"><a href="#python-标准库之-http-server" class="headerlink" title="python 标准库之 http.server"></a>python 标准库之 http.server</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200105_with_my_angle.jpg?raw=true" alt></p>
<p>今天下午主要是陪我闺女,组装完成一个桌面足球,很开心的一下午。</p>
<p>孩子的童年只有一次,有时间多陪陪孩子吧。</p>
<h2 id="python-标准库-http-server"><a href="#python-标准库-http-server" class="headerlink" title="python 标准库 http.server"></a>python 标准库 http.server</h2><p>从python2时代开始 SimpleHttpServer就陪伴我走过那些快乐的时光。可以自己建立一个简单的文件服务器,让同事们通过浏览器就可以访问我电脑上的资源,而不需要http server或者 ftp软件。</p>
<p>到了python3时代,这个模块被合并进了http.server。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.server.html" target="_blank" rel="noopener">参考网址</a></p>
<p>这个模块定义了实现 HTTP 服务器（ Web 服务器）的类 。</p>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.HTTPServer" target="_blank" rel="noopener"><code>HTTPServer</code></a> 是 <a href="https://docs.python.org/zh-cn/3.8/library/socketserver.html#socketserver.TCPServer" target="_blank" rel="noopener"><code>socketserver.TCPServer</code></a> 的一个子类。它会创建和侦听 HTTP 套接字，并将请求调度给处理程序。用于创建和运行服务器的代码看起来像这样 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(server_class=HTTPServer, handler_class=BaseHTTPRequestHandler)</span>:</span></span><br><span class="line">    server_address = (<span class="string">''</span>, <span class="number">8000</span>)</span><br><span class="line">    httpd = server_class(server_address, handler_class)</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure>
<h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><p><code>class http.server.HTTPServer(server_address, RequestHandlerClass)</code></p>
<blockquote>
<p> 该类基于 <a href="https://docs.python.org/zh-cn/3.8/library/socketserver.html#socketserver.TCPServer" target="_blank" rel="noopener"><code>TCPServer</code></a> 类，并会将服务器地址存入名为 <code>server_name</code> 和 <code>server_port</code> 的实例变量中。服务器可被处理程序通过 <code>server</code> 实例变量访问。 </p>
</blockquote>
<p><code>class http.server.ThreadingHTTPServer(server_address, RequestHandlerClass)</code></p>
<blockquote>
<p>根据官方说明,这是一个基于 <a href="https://docs.python.org/zh-cn/3.8/library/socketserver.html#socketserver.ThreadingMixIn" target="_blank" rel="noopener"><code>ThreadingMixIn</code></a>的类,主要功能是使用线程处理请求。</p>
</blockquote>
<a id="more"></a>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler" target="_blank" rel="noopener"><code>BaseHTTPRequestHandler</code></a> has the following instance variables:</p>
<ul>
<li><p><code>client_address</code></p>
<p>包含指向客户地址的元组类型数据(host,port)</p>
</li>
<li><p><code>server</code></p>
<p>包含Server实例</p>
</li>
<li><p><code>close_connection</code></p>
<p>返回一个Boolean类型数据,在<a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.handle_one_request" target="_blank" rel="noopener"><code>handle_one_request()</code></a> ,表明另一个请求开始,或者当前请求关闭。</p>
</li>
<li><p><code>requestline</code></p>
<p>包含http请求行，. 这个属性应该用 <a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.handle_one_request" target="_blank" rel="noopener"><code>handle_one_request()</code></a>设置. 如果一个不存在的请求被执行,应将其设置成空字符串。</p>
</li>
<li><p><code>command</code></p>
<p>包含Http请求类型,例如:’Get’</p>
</li>
<li><p><code>path</code></p>
<p>包含请求url路径</p>
</li>
<li><p><code>request_version</code></p>
<p>包含请求的版本,例如:’ HTTP/1.0 ‘</p>
</li>
<li><p><code>headers</code></p>
<p>包含通过<a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.MessageClass" target="_blank" rel="noopener"><code>MessageClass</code></a> 类声明的变量。实例会转化为http请求。<a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#module-http.client" target="_blank" rel="noopener"><code>http.client</code></a> 中<a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.parse_headers" target="_blank" rel="noopener"><code>parse_headers()</code></a> 方法可以验证一个非法的请求头,参照 <a href="https://tools.ietf.org/html/rfc2822.html" target="_blank" rel="noopener"><strong>RFC 2822</strong></a> 中请求头说明。</p>
</li>
<li><p><code>rfile</code></p>
<p>一个<a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.BufferedIOBase" target="_blank" rel="noopener"><code>io.BufferedIOBase</code></a> 输入流对象，读取可能输入数据。</p>
</li>
<li><p><code>wfile</code></p>
<p>根据客户端请求,返回数据</p>
</li>
</ul>
<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><ul>
<li><p><code>server_version</code></p>
<p>格式化输出服务器版本信息,例如<code>&#39;BaseHTTP/0.2&#39;</code>.</p>
</li>
<li><p><code>sys_version</code></p>
<p>包含系统版本,使用<a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.version_string" target="_blank" rel="noopener"><code>version_string</code></a> 方法和<a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.server_version" target="_blank" rel="noopener"><code>server_version</code></a> 类变量,例如:<code>&#39;Python/1.4&#39;</code>.</p>
</li>
<li><p><code>error_message_format</code></p>
<p>声明错误信息</p>
</li>
<li><p><code>error_content_type</code></p>
<p>声明错误上下文类型默认值是 <code>&#39;text/html&#39;</code>.</p>
</li>
<li><p><code>protocol_version</code></p>
<p>声明HTTP协议版本,例如:<code>&#39;HTTP/1.1&#39;</code>, 服务器会保持连接。</p>
</li>
<li><p><code>MessageClass</code></p>
<p>声明<code>email.message.Message</code>](<a href="https://docs.python.org/zh-cn/3.8/library/email.compat32-message.html#email.message.Message)-like" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3.8/library/email.compat32-message.html#email.message.Message)-like</a> 类处理请求头。通常不用重写,默认指向<code>http.client.HTTPMessage</code>属性。.</p>
</li>
<li><p><code>responses</code></p>
<p>回应 通常使用<a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.send_response_only" target="_blank" rel="noopener"><code>send_response_only()</code></a> 和<a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.send_error" target="_blank" rel="noopener"><code>send_error()</code></a> 方法实现。</p>
</li>
</ul>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li><p><code>handle</code>()</p>
<p>调用<a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.handle_one_request" target="_blank" rel="noopener"><code>handle_one_request()</code></a> 方法一次(如果保持连接,会调用多次) 来管理http请求。. 此方法不需要重写,除此以外,可以重写 <code>do_*()</code> 等方法实现处理请求。</p>
</li>
<li><p><code>handle_one_request</code>()</p>
<p>此方法不需要重写,实现处理 <code>do_*()</code>等方法.</p>
</li>
<li><p><code>handle_expect_100</code>()</p>
<p>当 HTTP/1.1 请求时,服务器期望返回  100-continue 并返回 <code>200</code>响应码。如果想拒绝客户端连接,会抛出一个异常。</p>
</li>
<li><p><code>send_error</code>(<em>code</em>, <em>message=None</em>, <em>explain=None</em>) </p>
</li>
<li><p><code>send_response</code>(<em>code</em>, <em>message=None</em>) </p>
</li>
<li><p><code>send_header</code>(<em>keyword</em>, <em>value</em>) </p>
</li>
<li><p><code>send_response_only</code>(<em>code</em>, <em>message=None</em>) </p>
</li>
<li><p><code>end_headers</code>() </p>
</li>
<li><p><code>flush_headers</code>() </p>
</li>
<li><p><code>log_request</code>(<em>code=’-‘</em>, <em>size=’-‘</em>) </p>
</li>
<li><p><code>log_error</code>(<em>…</em>) </p>
</li>
<li><p><code>log_message</code>(<em>format</em>, <em>…</em>) </p>
</li>
<li><p><code>version_string</code>() </p>
</li>
<li><p><code>date_time_string</code>(<em>timestamp=None</em>) </p>
</li>
<li><p><code>log_date_time_string</code>() </p>
</li>
<li><p><code>address_string</code>() </p>
</li>
</ul>
<h3 id="创建一个简易服务器"><a href="#创建一个简易服务器" class="headerlink" title="创建一个简易服务器"></a>创建一个简易服务器</h3><p>例如下面的代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> http.server</span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line">PORT = <span class="number">8000</span></span><br><span class="line"></span><br><span class="line">Handler = http.server.SimpleHTTPRequestHandler</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socketserver.TCPServer((<span class="string">""</span>, PORT), Handler) <span class="keyword">as</span> httpd:</span><br><span class="line">    print(<span class="string">"serving at port"</span>, PORT)</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure>
<p>当然也可以通过命令行方式创建,例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m http.server <span class="number">8000</span></span><br></pre></td></tr></table></figure>
<p>默认绑定本机的ip地址。</p>
<p>当然你可以指定一个ip地址,加入<code>--bind</code>参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m http.server <span class="number">8000</span> --bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<p>3.8 新增 支持绑定ipv6地址</p>
<p>3.7 新增支持绑定一个cgi程序,例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m http.server --cgi <span class="number">8000</span></span><br></pre></td></tr></table></figure>
<h3 id="一个具体应用的实例"><a href="#一个具体应用的实例" class="headerlink" title="一个具体应用的实例"></a>一个具体应用的实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</span><br><span class="line"> </span><br><span class="line"><span class="comment"># HTTPRequestHandler class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testHTTPServer_RequestHandler</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment"># GET</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Send response status code</span></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># Send headers</span></span><br><span class="line">        self.send_header(<span class="string">'Content-type'</span>,<span class="string">'text/html'</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># Send message back to client</span></span><br><span class="line">        message = <span class="string">"Hello world!"</span></span><br><span class="line">        <span class="comment"># Write content as utf-8 data</span></span><br><span class="line">        self.wfile.write(bytes(message, <span class="string">"utf8"</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'starting server...'</span>)</span><br><span class="line"> </span><br><span class="line">  <span class="comment"># Server settings</span></span><br><span class="line">  <span class="comment"># Choose port 8080, for port 80, which is normally used for a http server, you need root access</span></span><br><span class="line">  server_address = (<span class="string">'127.0.0.1'</span>, <span class="number">8081</span>)</span><br><span class="line">  httpd = HTTPServer(server_address, testHTTPServer_RequestHandler)</span><br><span class="line">  print(<span class="string">'running server...'</span>)</span><br><span class="line">  httpd.serve_forever()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">run()</span><br></pre></td></tr></table></figure>
<p><strong>备注</strong>: 此处<code>wfile.write</code>方法 需要转成 byte类型,</p>
<p>可以参考stackoverflow上的关于这个问题的讨论:: </p>
<p><a href="https://stackoverflow.com/questions/23264569/python-3-x-basehttpserver-or-http-server" target="_blank" rel="noopener">python-3-x-basehttpserver-or-http-server</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>看完http.server 深有感触,一个简单的服务器学习了这么多http协议实现,看来还得继续深入理解。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>http.server</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library textwrap</title>
    <url>/2020/01/06/python-standard-library-textwrap/</url>
    <content><![CDATA[<h1 id="Python-标准库-之-textwrap"><a href="#Python-标准库-之-textwrap" class="headerlink" title="Python 标准库 之 textwrap"></a>Python 标准库 之 textwrap</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200106_code_2.jpg?raw=true" alt></p>
<h2 id="今天给大家介绍-python标准库中的-textwrap"><a href="#今天给大家介绍-python标准库中的-textwrap" class="headerlink" title="今天给大家介绍 python标准库中的 textwrap"></a>今天给大家介绍 python标准库中的 textwrap</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html" target="_blank" rel="noopener">参考文档</a></p>
<p>标准库 <code>textwrap</code> 是一个关于文本自动换行和填充的模块。</p>
<p>关于这个模块官网介绍如下:</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#module-textwrap" target="_blank" rel="noopener"><code>textwrap</code></a> 模块提供了一些快捷函数，以及可以完成所有工作的类 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper" target="_blank" rel="noopener"><code>TextWrapper</code></a>。 </p>
<p>如果你只是要对一两个文本字符串进行自动换行或填充，快捷函数应该就够用了；</p>
<p>否则的话，你应该使用 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper" target="_blank" rel="noopener"><code>TextWrapper</code></a> 的实例来提高效率。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><code>textwrap.wrap(*text*, *width=70*, kwargs)</code></li>
</ul>
<p>对 <em>text</em> (字符串) 中的单独段落自动换行以使每行长度最多为 <em>width</em> 个字符。 返回由输出行组成的列表，行尾不带换行符。</p>
<ul>
<li><code>textwrap.fill</code>(<em>text</em>, <em>width=70</em>, kwargs)</li>
</ul>
<p>对 <em>text</em> 中的单独段落自动换行，并返回一个包含被自动换行段落的单独字符串。 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.fill" target="_blank" rel="noopener"><code>fill()</code></a> 是以下语句的快捷方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"\n"</span>.join(wrap(text, ...))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>textwrap.shorten(text, width, kwargs)</code></li>
</ul>
<p>折叠并截短给定的 <em>text</em> 以符合给定的 <em>width</em>。</p>
<a id="more"></a>
<ul>
<li><code>textwrap.dedent</code>(<em>text</em>)`</li>
</ul>
<p>移除 <em>text</em> 中每一行的任何相同前缀空白符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># end first line with \ to avoid the empty line!</span></span><br><span class="line">s = <span class="string">'''\</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">  world</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(repr(s))          <span class="comment"># prints '    hello\n      world\n    '</span></span><br><span class="line">print(repr(dedent(s)))  <span class="comment"># prints 'hello\n  world\n'</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>textwrap.</code>indent(<em>text</em>, <em>prefix</em>, predicate=None)`</li>
</ul>
<p>将 <em>prefix</em> 添加到 <em>text</em> 中选定行的开头。</p>
<p>通过调用 <code>text.splitlines(True)</code> 来对行进行拆分。</p>
<p>默认情况下，<em>prefix</em> 会被添加到所有不是只由空白符（包括任何行结束符）组成的行。</p>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'hello\n\n \nworld'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>indent(s, <span class="string">'  '</span>)</span><br><span class="line"><span class="string">'  hello\n\n \n  world'</span></span><br></pre></td></tr></table></figure>
<p>可选的 <em>predicate</em> 参数可用来控制哪些行要缩进。 例如，可以很容易地为空行或只有空白符的行添加 <em>prefix</em>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(indent(s, <span class="string">'+ '</span>, <span class="keyword">lambda</span> line: <span class="literal">True</span>))</span><br><span class="line">+ hello</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">+ world</span><br></pre></td></tr></table></figure>
<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><ul>
<li><p><code>width</code></p>
<p>(默认: <code>70</code>) 自动换行的最大行长度。 只要输入文本中没有长于 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.width" target="_blank" rel="noopener"><code>width</code></a> 的单个单词，<a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper" target="_blank" rel="noopener"><code>TextWrapper</code></a> 就能保证没有长于 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.width" target="_blank" rel="noopener"><code>width</code></a> 个字符的输出行。</p>
</li>
<li><p><code>expand_tabs</code></p>
<p>(默认: <code>True</code>) 如果为真值，则 <em>text</em> 中所有的制表符将使用 <em>text</em> 的 <code>expandtabs()</code> 方法扩展为空格符。</p>
</li>
<li><p><code>tabsize</code></p>
<p>(默认: <code>8</code>) 如果 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.expand_tabs" target="_blank" rel="noopener"><code>expand_tabs</code></a> 为真值，则 <em>text</em> 中所有的制表符将扩展为零个或多个空格，具体取决于当前列位置和给定的制表宽度。</p>
</li>
<li><p><code>replace_whitespace</code></p>
<p>(default: <code>True</code>) 如果为真值，在制表符扩展之后、自动换行之前，<a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.wrap" target="_blank" rel="noopener"><code>wrap()</code></a> 方法将把每个空白字符都替换为单个空格。 会被替换的空白字符如下：制表，换行，垂直制表，进纸和回车 (<code>&#39;\t\n\v\f\r&#39;</code>)。注解 如果 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.expand_tabs" target="_blank" rel="noopener"><code>expand_tabs</code></a> 为假值且 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.replace_whitespace" target="_blank" rel="noopener"><code>replace_whitespace</code></a> 为真值，每个制表符将被替换为单个空格，这与制表符扩展是 <em>不</em> 一样的。注解 如果 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.replace_whitespace" target="_blank" rel="noopener"><code>replace_whitespace</code></a> 为假值，在一行的中间有可能出现换行符并导致怪异的输出。 因此，文本应当（使用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str.splitlines" target="_blank" rel="noopener"><code>str.splitlines()</code></a> 或类似方法）拆分为段落并分别进行自动换行。</p>
</li>
<li><p><code>drop_whitespace</code></p>
<p>(默认: <code>True</code>) 如果为真值，每一行开头和末尾的空白字符（在包装之后、缩进之前）会被丢弃。 但是段落开头的空白字符如果后面不带任何非空白字符则不会被丢弃。 如果被丢弃的空白字符占据了一个整行，则该整行将被丢弃。</p>
</li>
<li><p><code>initial_indent</code></p>
<p>(默认: <code>&#39;&#39;</code>) 将被添加到被自动换行输出内容的第一行的字符串。 其长度会被计入第一行的长度。 空字符串不会被缩进。</p>
</li>
<li><p><code>subsequent_indent</code></p>
<p>(default: <code>&#39;&#39;</code>) 将被添加到被自动换行输出内容除第一行外的所有行的字符串。 其长度会被计入除行一行外的所有行的长度。</p>
</li>
<li><p><code>fix_sentence_endings</code></p>
<p>(默认: <code>False</code>) 如果为真值，<a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper" target="_blank" rel="noopener"><code>TextWrapper</code></a> 将尝试检测句子结尾并确保句子间总是以恰好两个空格符分隔。 对于使用等宽字体的文本来说通常都需要这样。 但是，句子检测算法并不完美：它假定句子结尾是一个小写字母加字符 <code>&#39;.&#39;</code>, <code>&#39;!&#39;</code> 或 <code>&#39;?&#39;</code> 中的一个，并可能带有字符 <code>&#39;&quot;&#39;</code> 或 <code>&quot;&#39;&quot;</code>，最后以一个空格结束。 此算法的问题之一是它无法区分以下文本中的 “Dr.”<code>[...] Dr. Frankenstein&#39;s monster [...]</code>和以下文本中的 “Spot.”<code>[...] See Spot. See Spot run [...]</code><a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.fix_sentence_endings" target="_blank" rel="noopener"><code>fix_sentence_endings</code></a> 默认为假值。由于句子检测算法依赖于 <code>string.lowercase</code> 来确定“小写字母”，以及约定在句点后使用两个空格来分隔处于同一行的句子，因此只适用于英语文本。</p>
</li>
<li><p><code>break_long_words</code></p>
<p>(默认: <code>True</code>) 如果为真值，则长度超过 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.width" target="_blank" rel="noopener"><code>width</code></a> 的单词将被分开以保证行的长度不会超过 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.width" target="_blank" rel="noopener"><code>width</code></a>。 如果为假值，超长单词不会被分开，因而某些行的长度可能会超过 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.width" target="_blank" rel="noopener"><code>width</code></a>。 （超长单词将被单独作为一行，以尽量减少超出 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.width" target="_blank" rel="noopener"><code>width</code></a> 的情况。）</p>
</li>
<li><p><code>break_on_hyphens</code></p>
<p>(默认: <code>True</code>) 如果为真值，将根据英语的惯例首选在空白符和复合词的连字符之后自动换行。 如果为假值，则只有空白符会被视为合适的潜在断行位置，但如果你确实不希望出现分开的单词则你必须将 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.break_long_words" target="_blank" rel="noopener"><code>break_long_words</code></a> 设为假值。 之前版本的默认行为总是允许分开带有连字符的单词。</p>
</li>
<li><p><code>max_lines</code></p>
<p>(默认: <code>None</code>) 如果不为 <code>None</code>，则输出内容将最多包含 <em>max_lines</em> 行，并使 <em>placeholder</em> 出现在输出内容的末尾。</p>
</li>
<li><p><code>placeholder</code></p>
<p>(默认: <code>&#39; [...]&#39;</code>) 该文本将在输出文本被截短时出现在文本末尾。</p>
</li>
</ul>
<h2 id="公有方法"><a href="#公有方法" class="headerlink" title="公有方法"></a>公有方法</h2><ul>
<li><p><code>wrap</code>(<em>text</em>)</p>
<p>对 <em>text</em> (字符串) 中的单独段落自动换行以使每行长度最多为 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.width" target="_blank" rel="noopener"><code>width</code></a> 个字符。 所有自动换行选项均获取自 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper" target="_blank" rel="noopener"><code>TextWrapper</code></a> 实例的实例属性。 返回由输出行组成的列表，行尾不带换行符。 如果自动换行输出结果没有任何内容，则返回空列表。</p>
</li>
<li><p><code>fill</code>(<em>text</em>)</p>
<p>对 <em>text</em> 中的单独段落自动换行并返回包含被自动换行段落的单独字符串。</p>
</li>
</ul>
<h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><p>比如我想格式化一个文本,每一行要求输出的文字固定字符的长度30,就可以使用textwrap这个模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> textwrap <span class="keyword">import</span> wrap</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = <span class="string">'This is python programming language. One of its kind, it is also one of the most popular language in the world.'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = wrap(text = string, width = <span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'This is python programming'</span>, <span class="string">'language. One of its kind, it'</span>, <span class="string">'is also one of the most'</span>, <span class="string">'popular language in the world.'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">	<span class="keyword">print</span> i</span><br><span class="line"> </span><br><span class="line">This <span class="keyword">is</span> python programming</span><br><span class="line">language. One of its kind, it</span><br><span class="line"><span class="keyword">is</span> also one of the most</span><br><span class="line">popular language <span class="keyword">in</span> the world.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library glob</title>
    <url>/2020/01/07/python-standard-library-glob/</url>
    <content><![CDATA[<h1 id="python-标准库之-glob"><a href="#python-标准库之-glob" class="headerlink" title="python 标准库之 glob"></a>python 标准库之 glob</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200107_cold.jpg?raw=true" alt></p>
<p>在严寒的冬季,温暖人的只有笑脸了吧。</p>
<h2 id="今天继续给大家介绍python标准库-glob"><a href="#今天继续给大家介绍python标准库-glob" class="headerlink" title="今天继续给大家介绍python标准库 glob"></a>今天继续给大家介绍python标准库 glob</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/glob.html" target="_blank" rel="noopener">参考文档</a></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/glob.html#module-glob" target="_blank" rel="noopener"><code>glob</code></a> 模块可根据 Unix 终端所用规则找出所有匹配特定模式的路径名，但会按不确定的顺序返回结果。支持查找文件只用到三个匹配符：’*’, “?”, “[ ]”，不包括波浪线~,因为这个符号在linux代表当前用户的home目录。</p>
<p>对于波浪号和终端变量扩展，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.expanduser" target="_blank" rel="noopener"><code>os.path.expanduser()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.expandvars" target="_blank" rel="noopener"><code>os.path.expandvars()</code></a>)。</p>
<p>根据阅读代码发现,这个底层使用cpython实现, 有兴趣的童鞋可以移步到源代码: <a href="https://github.com/python/cpython/tree/3.8/Lib/glob.py" target="_blank" rel="noopener">Lib/glob.py</a></p>
<p>相对于高级面向对象路径查找模块<a href="https://docs.python.org/zh-cn/3.8/library/pathlib.html#module-pathlib" target="_blank" rel="noopener">pathlib</a>  ,glob更偏向底层实现。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p><code>glob.glob(pathname, *, recursive=False)</code></p>
<blockquote>
<p>返回匹配 <em>pathname</em> 的可能为空的路径名列表，其中的元素必须为包含一个路径信息的字符串。 <em>pathname</em> 可以是绝对路径 (如 <code>/usr/src/Python-1.5/Makefile</code>) 或相对路径 (如 <code>../../Tools/*/*.gif</code>)，并且可包含 shell 风格的通配符。 结果也将包含无效的符号链接 (与在 shell 中一致)。 结果是否排序取决于具体文件系统。</p>
<p>如果 <em>recursive</em> 为真值，则模式 “<code>**</code>“ 将匹配目录中的任何文件以及零个或多个目录、子目录和符号链接。 如果模式加了一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sep" target="_blank" rel="noopener"><code>os.sep</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.altsep" target="_blank" rel="noopener"><code>os.altsep</code></a> 则将不匹配文件。</p>
</blockquote>
<p><strong>备注</strong>：在一个较大的目录树中使用 “<code>**</code>“ 模式可能会消耗非常多的时间。 <em>3.5 版更改:</em> 支持使用 “<code>**</code>“ 的递归 glob</p>
</li>
<li><p><code>glob.iglob(pathname, *, recursive=False)</code></p>
<blockquote>
<p>返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a>，它会产生与 <a href="https://docs.python.org/zh-cn/3.8/library/glob.html#module-glob" target="_blank" rel="noopener"><code>glob()</code></a> 相同的结果，但不会实际地同时保存它们。</p>
</blockquote>
</li>
<li><p><code>glob.escape(pathname)</code></p>
<blockquote>
<p>转义所有特殊字符 (<code>&#39;?&#39;</code>, <code>&#39;*&#39;</code> 和 <code>&#39;[&#39;</code>)。 这适用于当你想要匹配可能带有特殊字符的任意字符串字面值的情况。 在 drive/UNC 共享点中的特殊字符不会被转义，例如在 Windows 上 <code>escape(&#39;//?/c:/Quo vadis?.txt&#39;)</code> 将返回 <code>&#39;//?/c:/Quo vadis[?].txt&#39;</code>。</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例如，考虑一个包含以下内容的目录：文件 1.gif, 2.txt, card.gif 以及一个子目录 sub 其中只包含一个文件 3.txt. glob() 将产生如下结果。 请注意路径的任何开头部分都将被保留。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'./[0-9].*'</span>)</span><br><span class="line">[<span class="string">'./1.gif'</span>, <span class="string">'./2.txt'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'*.gif'</span>)</span><br><span class="line">[<span class="string">'1.gif'</span>, <span class="string">'card.gif'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'?.gif'</span>)</span><br><span class="line">[<span class="string">'1.gif'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'**/*.txt'</span>, recursive=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">'2.txt'</span>, <span class="string">'sub/3.txt'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'./**/'</span>, recursive=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">'./'</span>, <span class="string">'./sub/'</span>]</span><br></pre></td></tr></table></figure>
<p>如果目录包含以 <code>.</code> 打头的文件，它们默认将不会被匹配。 例如，考虑一个包含 <code>card.gif</code> 和 <code>.card.gif</code> 的目录:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'*.gif'</span>)</span><br><span class="line">[<span class="string">'card.gif'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'.c*'</span>)</span><br><span class="line">[<span class="string">'.card.gif'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><blockquote>
<p> ”*”匹配任意0个或多个字符；”?”匹配任意单个字符；”[ ]”匹配指定范围内的字符，如：[0-9]匹配数字。</p>
</blockquote>
<p>如下图所示的文件结构</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200107_snapshot.PNG?raw=true" alt></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="comment"># 返回上一级所有目录</span></span><br><span class="line">print(glob.glob(<span class="string">r"../*"</span>))</span><br><span class="line"><span class="comment"># 返回上本级所有目录</span></span><br><span class="line">print(glob.glob(<span class="string">r"./*"</span>))</span><br><span class="line"><span class="comment"># 本级所有文件</span></span><br><span class="line">print(glob.glob(<span class="string">r"./*.*"</span>))</span><br><span class="line"><span class="comment"># 本级所有.py文件</span></span><br><span class="line">print(glob.glob(<span class="string">'./*.py'</span>))</span><br><span class="line"><span class="comment">#两级目录所有的.py文件</span></span><br><span class="line">print(glob.glob(<span class="string">'./*/*.py'</span>))</span><br><span class="line"><span class="comment"># c盘所有文件</span></span><br><span class="line">print(glob.glob(<span class="string">r'c:/*'</span>))</span><br><span class="line"><span class="comment">#C盘所有包含pr/po/br/bo的目录</span></span><br><span class="line">print(glob.glob(<span class="string">'C:/*[PB][RO]*'</span>))</span><br><span class="line"><span class="comment">#C盘所有包含P_o的目录</span></span><br><span class="line">print(glob.glob(<span class="string">'C:/*P?O*'</span>))</span><br><span class="line"><span class="comment">#C盘两级目录所有的.txt文件</span></span><br><span class="line">print(glob.glob(<span class="string">'C:/*/*.txt'</span>))</span><br></pre></td></tr></table></figure>
<p>显示内容如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">['..\\class_demo.py', '..\\excel', '..\\flask_test', '..\\glob', '..\\image', '..\\mymodule', '..\\numpy', '..\\opencv', '..\\opencv_demo', '..\\othermodule', '..\\ppt', '..\\python_enuerate.py', '..\\python速成', '..\\selenium_test', '..\\交换算法.py', '..\\爬虫']</span><br><span class="line">['.\\app', '.\\config', '.\\data', '.\\glob_demo.py', '.\\other.py', '.\\readme.md']</span><br><span class="line">['.\\glob_demo.py', '.\\other.py', '.\\readme.md']</span><br><span class="line">['.\\glob_demo.py', '.\\other.py']</span><br><span class="line">['.\\app\\__init__.py', '.\\config\\config.py']</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>阅读源码中发现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""Filename globbing utility."""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> fnmatch</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">"glob"</span>, <span class="string">"iglob"</span>, <span class="string">"escape"</span>]</span><br></pre></td></tr></table></figure>
<p>顺便把<code>__all__</code>用法整理下,算是查漏补缺,</p>
<h2 id="all"><a href="#all" class="headerlink" title="__all__"></a><code>__all__</code></h2><p>问题描述:</p>
<blockquote>
<p>在研读pythonmodel源码时,会看到一些<em>.py文件或者<strong>init</strong>.py中会使用<strong>all</strong>。对于<strong>all</strong>具体所其的作用是什么?在此对查取结果进行总结下。2.总结(1)在<strong>init</strong>.py文件中表示形式:<strong>all</strong>=[“module_a”,”module_b”]在使用frompackage_nameimport</em>时,表示import该package中的两个module及两个module相关的类、方</p>
</blockquote>
<p>表示形式: <code>__all__=[&quot;class_name&quot;,&quot;function_name&quot;]</code></p>
<p>在使用 from module_name import * 时,表示import 该module中的<strong>all</strong>中所列出的。</p>
<p>使用注意事项:</p>
<p>(1) 在普通的*.py中, 使用<strong>all</strong> 时,可以使用<strong>all</strong>列出的 类、函数、变量等,不使用<strong>all</strong>时会使用module中的所有不以下划线开头的成员。</p>
<p>(2)<strong>all</strong>只能影响到 from import * 这种import 方式, 对于from import 的 import 方式没有影响。</p>
<p>(3) <strong>all</strong> 的数据类型:List or Tuple </p>
<h2 id="关联的模块"><a href="#关联的模块" class="headerlink" title="关联的模块"></a>关联的模块</h2><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/fnmatch.html#module-fnmatch" target="_blank" rel="noopener"><code>fnmatch</code></a></p>
<p>Shell 风格文件名（而非路径）扩展</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>glob</tag>
        <tag>__all__</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library http</title>
    <url>/2020/01/08/python-standard-library-http/</url>
    <content><![CDATA[<h1 id="python-标准库之-http"><a href="#python-标准库之-http" class="headerlink" title="python 标准库之 http"></a>python 标准库之 http</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20191223_blog_2.jpg?raw=true" alt></p>
<p>山雨欲来风满楼,最近不是很太平,希望世界和平吧。</p>
<h2 id="python-标准库学习-之-http"><a href="#python-标准库学习-之-http" class="headerlink" title="python 标准库学习 之  http"></a>python 标准库学习 之  http</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/http.html#module-http" target="_blank" rel="noopener"><code>http</code></a> 是一个包，它收集了多个用于处理超文本传输协议的模块:</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.html" target="_blank" rel="noopener">参考文档</a></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#module-http.client" target="_blank" rel="noopener"><code>http.client</code></a> 是一个低层级的 HTTP 协议客户端；对于高层级的 URL 访问请使用 <a href="https://docs.python.org/zh-cn/3.8/library/urllib.request.html#module-urllib.request" target="_blank" rel="noopener"><code>urllib.request</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#module-http.server" target="_blank" rel="noopener"><code>http.server</code></a> 包含基于 <a href="https://docs.python.org/zh-cn/3.8/library/socketserver.html#module-socketserver" target="_blank" rel="noopener"><code>socketserver</code></a> 的基本 HTTP 服务类</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/http.cookies.html#module-http.cookies" target="_blank" rel="noopener"><code>http.cookies</code></a> 包含一些有用来实现通过 cookies 进行状态管理的工具</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/http.cookiejar.html#module-http.cookiejar" target="_blank" rel="noopener"><code>http.cookiejar</code></a> 提供了 cookies 的持久化</li>
</ul>
<p>本次只整理 http.client的内容,后面持续更新。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><code>class http.HTTPStatus</code></p>
<p>使用方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> http <span class="keyword">import</span> HTTPStatus</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>HTTPStatus.OK</span><br><span class="line">&lt;HTTPStatus.OK: <span class="number">200</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>HTTPStatus.OK == <span class="number">200</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>HTTPStatus.OK.value</span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>HTTPStatus.OK.phrase</span><br><span class="line"><span class="string">'OK'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>HTTPStatus.OK.description</span><br><span class="line"><span class="string">'Request fulfilled, document follows'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(HTTPStatus)</span><br><span class="line">[&lt;HTTPStatus.CONTINUE: <span class="number">100</span>&gt;, &lt;HTTPStatus.SWITCHING_PROTOCOLS: <span class="number">101</span>&gt;, ...]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>映射名</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>100</code></td>
<td><code>CONTINUE</code></td>
<td>HTTP/1.1 <a href="https://tools.ietf.org/html/rfc7231.html" target="_blank" rel="noopener"><strong>RFC 7231</strong></a>, 6.2.1 节</td>
</tr>
<tr>
<td><code>101</code></td>
<td><code>SWITCHING_PROTOCOLS</code></td>
<td>HTTP/1.1 RFC 7231, 6.2.2 节</td>
</tr>
<tr>
<td><code>102</code></td>
<td><code>PROCESSING</code></td>
<td>WebDAV RFC 2518, 10.1 节</td>
</tr>
<tr>
<td><code>200</code></td>
<td><code>OK</code></td>
<td>HTTP/1.1 RFC 7231, 6.3.1 节</td>
</tr>
<tr>
<td><code>201</code></td>
<td><code>CREATED</code></td>
<td>HTTP/1.1 RFC 7231, 6.3.2 节</td>
</tr>
<tr>
<td><code>202</code></td>
<td><code>ACCEPTED</code></td>
<td>HTTP/1.1 RFC 7231, 6.3.3 节</td>
</tr>
<tr>
<td><code>203</code></td>
<td><code>NON_AUTHORITATIVE_INFORMATION</code></td>
<td>HTTP/1.1 RFC 7231, 6.3.4 节</td>
</tr>
<tr>
<td><code>204</code></td>
<td><code>NO_CONTENT</code></td>
<td>HTTP/1.1 RFC 7231, 6.3.5 节</td>
</tr>
<tr>
<td><code>205</code></td>
<td><code>RESET_CONTENT</code></td>
<td>HTTP/1.1 RFC 7231, 6.3.6 节</td>
</tr>
<tr>
<td><code>206</code></td>
<td><code>PARTIAL_CONTENT</code></td>
<td>HTTP/1.1 RFC 7233, 4.1 节</td>
</tr>
<tr>
<td><code>207</code></td>
<td><code>MULTI_STATUS</code></td>
<td>WebDAV RFC 4918, 11.1 节</td>
</tr>
<tr>
<td><code>208</code></td>
<td><code>ALREADY_REPORTED</code></td>
<td>WebDAV Binding Extensions RFC 5842, 7.1 节（实验性）</td>
</tr>
<tr>
<td><code>226</code></td>
<td><code>IM_USED</code></td>
<td>Delta Encoding in HTTP RFC 3229, 10.4.1 节</td>
</tr>
<tr>
<td><code>300</code></td>
<td><code>MULTIPLE_CHOICES</code>：有多种资源可选择</td>
<td>HTTP/1.1 RFC 7231, 6.4.1 节</td>
</tr>
<tr>
<td><code>301</code></td>
<td><code>MOVED_PERMANENTLY</code>：永久移动</td>
<td>HTTP/1.1 RFC 7231, 6.4.2 节</td>
</tr>
<tr>
<td><code>302</code></td>
<td><code>FOUND</code>：临时移动</td>
<td>HTTP/1.1 RFC 7231, 6.4.3 节</td>
</tr>
<tr>
<td><code>303</code></td>
<td><code>SEE_OTHER</code>：已经移动</td>
<td>HTTP/1.1 RFC 7231, 6.4.4 节</td>
</tr>
<tr>
<td><code>304</code></td>
<td><code>NOT_MODIFIED</code>：没有修改</td>
<td>HTTP/1.1 RFC 7232, 4.1 节</td>
</tr>
<tr>
<td><code>305</code></td>
<td><code>USE_PROXY</code>：使用代理</td>
<td>HTTP/1.1 RFC 7231, 6.4.5 节</td>
</tr>
<tr>
<td><code>307</code></td>
<td><code>TEMPORARY_REDIRECT</code>：临时重定向</td>
<td>HTTP/1.1 <a href="https://tools.ietf.org/html/rfc7231.html" target="_blank" rel="noopener"><strong>RFC 7231</strong></a>, 6.4.7 节</td>
</tr>
<tr>
<td><code>308</code></td>
<td><code>PERMANENT_REDIRECT</code>：永久重定向</td>
<td>Permanent Redirect <a href="https://tools.ietf.org/html/rfc7238.html" target="_blank" rel="noopener"><strong>RFC 7238</strong></a>, Section 3 (Experimental)</td>
</tr>
<tr>
<td><code>400</code></td>
<td><code>BAD_REQUEST</code>：错误请求</td>
<td>HTTP/1.1 RFC 7231, 6.5.1 节</td>
</tr>
<tr>
<td><code>401</code></td>
<td><code>UNAUTHORIZED</code>：未授权</td>
<td>HTTP/1.1 Authentication RFC 7235, 3.1 节</td>
</tr>
<tr>
<td><code>402</code></td>
<td><code>PAYMENT_REQUIRED</code>：保留，将来使用</td>
<td>HTTP/1.1 RFC 7231, 6.5.2 节</td>
</tr>
<tr>
<td><code>403</code></td>
<td><code>FORBIDDEN</code>：禁止</td>
<td>HTTP/1.1 RFC 7231, 6.5.3 节</td>
</tr>
<tr>
<td><code>404</code></td>
<td><code>NOT_FOUND</code>：没有找到</td>
<td>HTTP/1.1 RFC 7231, 6.5.4 节</td>
</tr>
<tr>
<td><code>405</code></td>
<td><code>METHOD_NOT_ALLOWED</code>：该请求方法不允许</td>
<td>HTTP/1.1 RFC 7231, 6.5.5 节</td>
</tr>
<tr>
<td><code>406</code></td>
<td><code>NOT_ACCEPTABLE</code>：不可接受</td>
<td>HTTP/1.1 RFC 7231, 6.5.6 节</td>
</tr>
<tr>
<td><code>407</code></td>
<td><code>PROXY_AUTHENTICATION_REQUIRED</code>：要求使用代理验证身份</td>
<td>HTTP/1.1 Authentication RFC 7235, 3.1 节</td>
</tr>
<tr>
<td><code>408</code></td>
<td><code>REQUEST_TIMEOUT</code>：请求超时</td>
<td>HTTP/1.1 <a href="https://tools.ietf.org/html/rfc7231.html" target="_blank" rel="noopener"><strong>RFC 7231</strong></a>, 6.5.7 节</td>
</tr>
<tr>
<td><code>409</code></td>
<td><code>CONFLICT</code>：冲突</td>
<td>HTTP/1.1 RFC 7231, 6.5.8 节</td>
</tr>
<tr>
<td><code>410</code></td>
<td><code>GONE</code>：已经不在了</td>
<td>HTTP/1.1 RFC 7231, 6.5.9 节</td>
</tr>
<tr>
<td><code>411</code></td>
<td><code>LENGTH_REQUIRED</code>：长度要求</td>
<td>HTTP/1.1 RFC 7231, 6.5.10 节</td>
</tr>
<tr>
<td><code>412</code></td>
<td><code>PRECONDITION_FAILED</code>：前提条件错误</td>
<td>HTTP/1.1 RFC 7232, 4.2 节</td>
</tr>
<tr>
<td><code>413</code></td>
<td><code>REQUEST_ENTITY_TOO_LARGE</code>：请求体太大了</td>
<td>HTTP/1.1 RFC 7231, 6.5.11 节</td>
</tr>
<tr>
<td><code>414</code></td>
<td><code>REQUEST_URI_TOO_LONG</code>：请求URI太长了</td>
<td>HTTP/1.1 RFC 7231, 6.5.12 节</td>
</tr>
<tr>
<td><code>415</code></td>
<td><code>UNSUPPORTED_MEDIA_TYPE</code>：不支持的媒体格式</td>
<td>HTTP/1.1 RFC 7231, 6.5.13 节</td>
</tr>
<tr>
<td><code>416</code></td>
<td><code>REQUESTED_RANGE_NOT_SATISFIABLE</code></td>
<td>HTTP/1.1 Range Requests RFC 7233, 4.4 节</td>
</tr>
<tr>
<td><code>417</code></td>
<td><code>EXPECTATION_FAILED</code>：期望失败</td>
<td>HTTP/1.1 RFC 7231, 6.5.14 节</td>
</tr>
<tr>
<td><code>421</code></td>
<td><code>MISDIRECTED_REQUEST</code></td>
<td>HTTP/2 <a href="https://tools.ietf.org/html/rfc7540.html" target="_blank" rel="noopener"><strong>RFC 7540</strong></a>, 9.1.2 节</td>
</tr>
<tr>
<td><code>422</code></td>
<td><code>UNPROCESSABLE_ENTITY</code>：可加工实体</td>
<td>WebDAV RFC 4918, 11.2 节</td>
</tr>
<tr>
<td><code>423</code></td>
<td><code>LOCKED</code>：锁着</td>
<td>WebDAV RFC 4918, 11.3 节</td>
</tr>
<tr>
<td><code>424</code></td>
<td><code>FAILED_DEPENDENCY</code>：失败的依赖</td>
<td>WebDAV RFC 4918, 11.4 节</td>
</tr>
<tr>
<td><code>426</code></td>
<td><code>UPGRADE_REQUIRED</code>：升级需要</td>
<td>HTTP/1.1 RFC 7231, 6.5.15 节</td>
</tr>
<tr>
<td><code>428</code></td>
<td><code>PRECONDITION_REQUIRED</code>：先决条件要求</td>
<td>Additional HTTP Status Codes RFC 6585</td>
</tr>
<tr>
<td><code>429</code></td>
<td><code>TOO_MANY_REQUESTS</code>：太多的请求</td>
<td>Additional HTTP Status Codes RFC 6585</td>
</tr>
<tr>
<td><code>431</code></td>
<td><code>REQUEST_HEADER_FIELDS_TOO_LARGE</code>：请求头太大</td>
<td>Additional HTTP Status Codes RFC 6585</td>
</tr>
<tr>
<td><code>451</code></td>
<td><code>UNAVAILABLE_FOR_LEGAL_REASONS</code></td>
<td>HTTP 状态码用于报告法律障碍 <a href="https://tools.ietf.org/html/rfc7725.html" target="_blank" rel="noopener"><strong>RFC 7725</strong></a></td>
</tr>
<tr>
<td><code>500</code></td>
<td><code>INTERNAL_SERVER_ERROR</code>：内部服务错误</td>
<td>HTTP/1.1 RFC 7231, 6.6.1 节</td>
</tr>
<tr>
<td><code>501</code></td>
<td><code>NOT_IMPLEMENTED</code>：不可执行</td>
<td>HTTP/1.1 RFC 7231, 6.6.2 节</td>
</tr>
<tr>
<td><code>502</code></td>
<td><code>BAD_GATEWAY</code>：无效网关</td>
<td>HTTP/1.1 RFC 7231, 6.6.3 节</td>
</tr>
<tr>
<td><code>503</code></td>
<td><code>SERVICE_UNAVAILABLE</code>：服务不可用</td>
<td>HTTP/1.1 RFC 7231, 6.6.4 节</td>
</tr>
<tr>
<td><code>504</code></td>
<td><code>GATEWAY_TIMEOUT</code>：网关超时</td>
<td>HTTP/1.1 RFC 7231, 6.6.5 节</td>
</tr>
<tr>
<td><code>505</code></td>
<td><code>HTTP_VERSION_NOT_SUPPORTED</code>：HTTP版本不支持</td>
<td>HTTP/1.1 RFC 7231, 6.6.6 节</td>
</tr>
<tr>
<td><code>506</code></td>
<td><code>VARIANT_ALSO_NEGOTIATES</code>：服务器存在内部配置错误</td>
<td>透明内容协商在： HTTP <a href="https://tools.ietf.org/html/rfc2295.html" target="_blank" rel="noopener"><strong>RFC 2295</strong></a>, 8.1 节（实验性）</td>
</tr>
<tr>
<td><code>507</code></td>
<td><code>INSUFFICIENT_STORAGE</code>：存储不足</td>
<td>WebDAV RFC 4918, 11.5 节</td>
</tr>
<tr>
<td><code>508</code></td>
<td><code>LOOP_DETECTED</code>：循环检测</td>
<td>WebDAV Binding Extensions RFC 5842, 7.2 节（实验性）</td>
</tr>
<tr>
<td><code>510</code></td>
<td><code>NOT_EXTENDED</code>：不扩展</td>
<td>WebDAV Binding Extensions RFC 5842, 7.2 节（实验性）</td>
</tr>
<tr>
<td><code>511</code></td>
<td><code>NETWORK_AUTHENTICATION_REQUIRED</code>：要求网络身份验证</td>
<td>Additional HTTP Status Codes <a href="https://tools.ietf.org/html/rfc6585.html" target="_blank" rel="noopener"><strong>RFC 6585</strong></a>, 6 节</td>
</tr>
</tbody>
</table>
<p>为了保持向后兼容性，枚举值也以常量形式出现在 <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#module-http.client" target="_blank" rel="noopener"><code>http.client</code></a> 模块中，。 枚举名等于常量名 (例如 <code>http.HTTPStatus.OK</code> 也可以是 <code>http.client.OK</code>)。</p>
<h2 id="http-client-对象"><a href="#http-client-对象" class="headerlink" title="http.client 对象"></a>http.client 对象</h2><p>这个模块定义了实现 HTTP 和 HTTPS 协议客户端的类。 它通常不直接使用 — 模块 <a href="https://docs.python.org/zh-cn/3.8/library/urllib.request.html#module-urllib.request" target="_blank" rel="noopener"><code>urllib.request</code></a> 用它来处理使用 HTTP 和 HTTPS 的 URL。</p>
<p>参见 The <a href="https://requests.readthedocs.io/en/master/" target="_blank" rel="noopener">Requests</a> 是一个高级的实现http协议的http客户端接口库.</p>
<p><strong>注意</strong>: HTTPS 支持仅在编译 Python 时启用了 SSL 支持的情况下（通过 <a href="https://docs.python.org/zh-cn/3.8/library/ssl.html#module-ssl" target="_blank" rel="noopener"><code>ssl</code></a> 模块）可用。</p>
<p>强烈建议看源代码 <a href="https://github.com/python/cpython/tree/3.8/Lib/http/client.py" target="_blank" rel="noopener">Lib/http/client.py</a></p>
<p>我摘取其中关于http请求状态的描述</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> (null)</span><br><span class="line">   |</span><br><span class="line">   | HTTPConnection()</span><br><span class="line">   v</span><br><span class="line"> Idle</span><br><span class="line">   |</span><br><span class="line">   | putrequest()</span><br><span class="line">   v</span><br><span class="line"> Request-started</span><br><span class="line">   |</span><br><span class="line">   | ( putheader() )*  endheaders()</span><br><span class="line">   v</span><br><span class="line"> Request-sent</span><br><span class="line">   |\_____________________________</span><br><span class="line">   |                              | getresponse() raises</span><br><span class="line">   | response = getresponse()     | ConnectionError</span><br><span class="line">   v                              v</span><br><span class="line"> Unread-response                Idle</span><br><span class="line"> [Response-headers-read]</span><br><span class="line">   |\____________________</span><br><span class="line">   |                     |</span><br><span class="line">   | response.read()     | putrequest()</span><br><span class="line">   v                     v</span><br><span class="line"> Idle                  Req-started-unread-response</span><br><span class="line">                  ______/|</span><br><span class="line">                /        |</span><br><span class="line">response.read() |        | ( putheader() )*  endheaders()</span><br><span class="line">                v        v</span><br><span class="line">    Request-started    Req-sent-unread-response</span><br><span class="line">                         |</span><br><span class="line">                         | response.read()</span><br><span class="line">                         v</span><br><span class="line">                       Request-sent</span><br></pre></td></tr></table></figure>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li><code>class http.client.HTTPConnection(*host*, *port=None*, [*timeout*, ]*source_address=None*, *blocksize=8192*)</code></li>
</ul>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPConnection" target="_blank" rel="noopener"><code>HTTPConnection</code></a> 的实例代表与 HTTP 的一个连接事务。 它的实例化应当传入一个主机和可选的端口号。 如果没有传入端口号，如果主机字符串的形式为 <code>主机:端口</code> 则会从中提取端口，否则将使用默认的 HTTP 端口（80）。 如果给出了可选的 <em>timeout</em> 参数，则阻塞操作（例如连接尝试）将在指定的秒数之后超时（如果未给出，则使用全局默认超时设置）。 可选的 <em>source_address</em> 参数可以为一个 (主机, 端口) 元组，用作进行 HTTP 连接的源地址。 可选的 <em>blocksize</em> 参数可以字节为单位设置缓冲区的大小，用来发送文件类消息体。</p>
<p>举个例子，以下调用都是创建连接到同一主机和端口的服务器的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h1 = http.client.HTTPConnection(<span class="string">'www.python.org'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h2 = http.client.HTTPConnection(<span class="string">'www.python.org:80'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h3 = http.client.HTTPConnection(<span class="string">'www.python.org'</span>, <span class="number">80</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h4 = http.client.HTTPConnection(<span class="string">'www.python.org'</span>, <span class="number">80</span>, timeout=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>`<em>class</em> http.client.HTTPSConnection(<em>host</em>, <em>port=None</em>, <em>key_file=None</em>, <em>cert_file=None</em>, [<em>timeout</em>, ]<em>source_address=None</em>, <em>**, </em>context=None<em>, </em>check_hostname=None<em>, </em>blocksize=8192*)<a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPSConnection" target="_blank" rel="noopener">¶</a></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPConnection" target="_blank" rel="noopener"><code>HTTPConnection</code></a> 的子类，使用 SSL 与安全服务器进行通信。 默认端口为 <code>443</code>。 如果指定了 <em>context</em>，它必须为一个描述 SSL 各选项的 <a href="https://docs.python.org/zh-cn/3.8/library/ssl.html#ssl.SSLContext" target="_blank" rel="noopener"><code>ssl.SSLContext</code></a> 实例。</p>
</li>
<li><p><code>class http.client.`</code>HTTPResponse`(<em>sock</em>, <em>debuglevel=0</em>, <em>method=None</em>, <em>url=None</em>)</p>
</li>
</ul>
<p>在成功连接后返回类的实例，而不是由用户直接实例化。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li><p><em>exception</em> <code>http.client.`</code>HTTPException`</p>
<p>此模块中其他异常的基类。 它是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>http.client.`</code>NotConnected`</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>http.client.`</code>InvalidURL`</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类，如果给出了一个非数字或为空值的端口就会被引发。</p>
</li>
<li><p><em>exception</em> <code>http.client.`</code>UnknownProtocol`</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>http.client.`</code>UnknownTransferEncoding`</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>http.client.`</code>UnimplementedFileMode`</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>http.client.`</code>IncompleteRead`</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>http.client.`</code>ImproperConnectionState`</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>http.client.`</code>CannotSendRequest`</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.ImproperConnectionState" target="_blank" rel="noopener"><code>ImproperConnectionState</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>http.client.`</code>CannotSendHeader`</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.ImproperConnectionState" target="_blank" rel="noopener"><code>ImproperConnectionState</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>http.client.`</code>ResponseNotReady`</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.ImproperConnectionState" target="_blank" rel="noopener"><code>ImproperConnectionState</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>http.client.`</code>BadStatusLine`</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。 如果服务器反馈了一个我们不理解的 HTTP 状态码就会被引发。</p>
</li>
<li><p><em>exception</em> <code>http.client.`</code>LineTooLong`</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。 如果在 HTTP 协议中从服务器接收到过长的行就会被引发。</p>
</li>
<li><p><em>exception</em> <code>http.client.`</code>RemoteDisconnected`</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionResetError" target="_blank" rel="noopener"><code>ConnectionResetError</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.BadStatusLine" target="_blank" rel="noopener"><code>BadStatusLine</code></a> 的一个子类。 当尝试读取响应时的结果是未从连接读取到数据时由 <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPConnection.getresponse" target="_blank" rel="noopener"><code>HTTPConnection.getresponse()</code></a> 引发，表明远端已关闭连接。</p>
</li>
</ul>
<h3 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h3><ul>
<li><p><code>http.client.`</code>HTTP_PORT`</p>
<p>HTTP 协议默认的端口号 (总是 <code>80</code>)。</p>
</li>
<li><p><code>http.client.`</code>HTTPS_PORT`</p>
<p>HTTPS 协议默认的端口号 (总是 <code>443</code>)。</p>
</li>
<li><p><code>http.client.`</code>responses`</p>
<p>这个字典把 HTTP 1.1 状态码映射到 W3C 名称。例如：<code>http.client.responses[http.client.NOT_FOUND]</code> 是 <code>&#39;NOT FOUND</code> （未发现）。</p>
</li>
</ul>
<h2 id="HTTPConnection-对象"><a href="#HTTPConnection-对象" class="headerlink" title="HTTPConnection 对象"></a>HTTPConnection 对象</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>HTTPConnection.request</code>(<em>method</em>, <em>url</em>, <em>body=None</em>, <em>headers={}</em>, <em>, </em>encode_chunked=False*)</li>
</ul>
<p>这会使用 HTTP 请求方法 <em>method</em> 和选择器 <em>url</em> 向服务器发送请求。</p>
<p>如果给定 <em>body</em>，那么给定的数据会在信息头完成之后发送。它可能是一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 、一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 、一个打开的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a>，或者 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 迭代器。如果 <em>body</em> 是字符串，它会按 HTTP 默认的 ISO-8859-1 编码；如果是一个字节类对象，它会按原样发送；如果是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> ，文件的内容会被发送，这个文件对象应该支持 <code>read()</code> 方法。如果这个文件对象是一个 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.TextIOBase" target="_blank" rel="noopener"><code>io.TextIOBase</code></a> 实例， <code>read()</code> 方法返回的数据会按 ISO-8859-1 编码，否则 <code>read()</code> 方法返回的数据会按原样发送；如果 <em>body</em> 是一个迭代器，迭代器中的元素会被发送，直到迭代器耗尽。</p>
<p><em>headers</em> 参数应是额外的随请求发送的 HTTP 信息头的字典。</p>
<p>如果 <em>headers</em> 既不包含 Content-Length 也没有 Transfer-Encoding，但存在请求正文，那么这些头字段中的一个会自动设定。如果 <em>body</em> 是 <code>None</code>，那么对于要求正文的方法 (<code>PUT</code>，<code>POST</code>，和 <code>PATCH</code>)，Content-Length 头会被设为 <code>0</code>。如果 <em>body</em> 是字符串或者类似字节的对象，并且也不是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">文件</a>，Content-Length 头会设为正文的长度。任何其他类型的 <em>body</em> （一般是文件或迭代器）会按块编码，这时会自动设定 Transfer-Encoding 头以代替 Content-Length。</p>
<p>在 <em>headers</em> 中指定 Transfer-Encoding 时， <em>encode_chunked</em> 是唯一相关的参数。如果 <em>encode_chunked</em> 为 <code>False</code>，HTTPConnection 对象会假定所有的编码都由调用代码处理。如果为 <code>True</code>，正文会按块编码。</p>
<ul>
<li><p><code>HTTPConnection.`</code>set_debuglevel`(<em>level</em>)</p>
<p>设置调试等级。 默认的调试等级为 <code>0</code>，意味着不会打印调试输出。 任何大于 <code>0</code> 的值将使得所有当前定义的调试输出被打印到 stdout。 <code>debuglevel</code> 会被传给任何新创建的 <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPResponse" target="_blank" rel="noopener"><code>HTTPResponse</code></a> 对象。</p>
</li>
<li><p><code>HTTPConnection.`</code>set_tunnel`(<em>host</em>, <em>port=None</em>, <em>headers=None</em>)</p>
<p>为 HTTP 连接隧道设置主机和端口。 这将允许通过代理服务器运行连接。</p>
<p>host 和 port 参数指明隧道连接的位置（即 CONNECT 请求所包含的地址，而 <em>不是</em> 代理服务器的地址）。</p>
<p>headers 参数应为一个随 CONNECT 请求发送的额外 HTTP 标头的映射。</p>
<p>例如，要通过一个运行于本机 8080 端口的 HTTPS 代理服务器隧道，我们应当向 <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPSConnection" target="_blank" rel="noopener"><code>HTTPSConnection</code></a> 构造器传入代理的地址，并将我们最终想要访问的主机地址传给 <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPConnection.set_tunnel" target="_blank" rel="noopener"><code>set_tunnel()</code></a> 方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> http.client</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = http.client.HTTPSConnection(<span class="string">"localhost"</span>, <span class="number">8080</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.set_tunnel(<span class="string">"www.python.org"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.request(<span class="string">"HEAD"</span>,<span class="string">"/index.html"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTPConnection.connect()</p>
<p>当对象被创建后连接到指定的服务器。 默认情况下，如果客户端还未建立连接，此函数会在发送请求时自动被调用。</p>
</li>
<li><p><code>HTTPConnection.close()</code></p>
<p>关闭到服务器的连接。</p>
</li>
<li><p><code>HTTPConnection.blocksize</code></p>
<p>用于发送文件类消息体的缓冲区大小。</p>
</li>
<li><p><code>HTTPConnection.send(data)</code></p>
<p>发送数据到服务器 。这个方法直接使用将会在<a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPConnection.endheaders" target="_blank" rel="noopener">endheaders()</a>方法后和   <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPConnection.getresponse" target="_blank" rel="noopener"><code>getresponse()</code></a> 方法调用之前被调用</p>
</li>
</ul>
<h2 id="HTTPResponse-对象"><a href="#HTTPResponse-对象" class="headerlink" title="HTTPResponse 对象"></a>HTTPResponse 对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPResponse" target="_blank" rel="noopener"><code>HTTPResponse</code></a> 对象实例绑定从服务器返回的 Http response 内容。 response是一个可迭代对象,可以使用with上下文语句来管理。</p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p><code>HTTPResponse.read</code>([<em>amt</em>])</p>
<p>读取并返回response body</p>
</li>
<li><p><code>HTTPResponse.`</code>readinto`(<em>b</em>)</p>
<p>读取从 response body 的b长度的字节放到 buffer b中，并返回这个字节b。</p>
</li>
<li><p><code>HTTPResponse.getheader</code>(<em>name</em>, <em>default=None</em>)</p>
<p>如果有匹配的header name,则返回 header name的值。如果不止一个header name的名字，则返回所有的值的字符串,通过逗号连接。</p>
</li>
<li><p><code>HTTPResponse.getheaders()</code></p>
<p>返回一个包含header和value的元组元素的列表</p>
</li>
<li><p><code>HTTPResponse.fileno()</code></p>
<p>Return the <code>fileno</code> of the underlying socket.</p>
<p>返回底层套接字的fileno</p>
</li>
<li><p><code>HTTPResponse.msg</code></p>
<p>一个<code>http.client.HTTPMessage</code> 消息的实例,包含response header。 <code>http.client.HTTPMessage</code> 是 <a href="https://docs.python.org/zh-cn/3.8/library/email.compat32-message.html#email.message.Message" target="_blank" rel="noopener"><code>email.message.Message</code></a>的子类</p>
</li>
<li><p><code>HTTPResponse.version</code></p>
<p>Http response版本号,例如  HTTP/1.0, 11 for HTTP/1.1.</p>
</li>
<li><p><code>HTTPResponse.`</code>status`</p>
<p>由服务器返回的状态码。</p>
</li>
<li><p><code>HTTPResponse.reason</code></p>
<p>从服务器返回的状态码</p>
</li>
<li><p><code>HTTPResponse.debuglevel</code></p>
<p>一个 debugging hook. 如果 <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPResponse.debuglevel" target="_blank" rel="noopener"><code>debuglevel</code></a> 大于0, 消息将会被打印到控制台。</p>
</li>
<li><p><code>HTTPResponse.closed</code></p>
<p>如果stream关闭,返回true</p>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h3><p>一个使用get请求的实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> http.client</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = http.client.HTTPSConnection(<span class="string">"www.python.org"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.request(<span class="string">"GET"</span>, <span class="string">"/"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r1 = conn.getresponse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(r1.status, r1.reason)</span><br><span class="line"><span class="number">200</span> OK</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data1 = r1.read()  <span class="comment"># This will return entire content.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># The following example demonstrates reading data in chunks.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.request(<span class="string">"GET"</span>, <span class="string">"/"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r1 = conn.getresponse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> chunk := r1.read(<span class="number">200</span>):</span><br><span class="line"><span class="meta">... </span>    print(repr(chunk))</span><br><span class="line"><span class="string">b'&lt;!doctype html&gt;\n&lt;!--[if"...</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; # Example of an invalid request</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; conn = http.client.HTTPSConnection("docs.python.org")</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; conn.request("GET", "/parrot.spam")</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; r2 = conn.getresponse()</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(r2.status, r2.reason)</span></span><br><span class="line"><span class="string">404 Not Found</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; data2 = r2.read()</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; conn.close()</span></span><br></pre></td></tr></table></figure>
<p>一个使用<code>head</code>方法的实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> http.client</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = http.client.HTTPSConnection(<span class="string">"www.python.org"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.request(<span class="string">"HEAD"</span>, <span class="string">"/"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = conn.getresponse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(res.status, res.reason)</span><br><span class="line"><span class="number">200</span> OK</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = res.read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(len(data))</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data == <span class="string">b''</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>一个使用<code>post</code>提交请求的实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> http.client, urllib.parse</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>params = urllib.parse.urlencode(&#123;<span class="string">'@number'</span>: <span class="number">12524</span>, <span class="string">'@type'</span>: <span class="string">'issue'</span>, <span class="string">'@action'</span>: <span class="string">'show'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>headers = &#123;<span class="string">"Content-type"</span>: <span class="string">"application/x-www-form-urlencoded"</span>,</span><br><span class="line"><span class="meta">... </span>           <span class="string">"Accept"</span>: <span class="string">"text/plain"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = http.client.HTTPConnection(<span class="string">"bugs.python.org"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.request(<span class="string">"POST"</span>, <span class="string">""</span>, params, headers)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = conn.getresponse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.status, response.reason)</span><br><span class="line"><span class="number">302</span> Found</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = response.read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data</span><br><span class="line"><span class="string">b'Redirecting to &lt;a href="http://bugs.python.org/issue12524"&gt;http://bugs.python.org/issue12524&lt;/a&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.close()</span><br></pre></td></tr></table></figure>
<p>一个使用<code>HTTP PUT</code>请求的实例 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># This creates an HTTP message</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># with the content of BODY as the enclosed representation</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># for the resource http://localhost:8080/file</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> http.client</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>BODY = <span class="string">"***filecontents***"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = http.client.HTTPConnection(<span class="string">"localhost"</span>, <span class="number">8080</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.request(<span class="string">"PUT"</span>, <span class="string">"/file"</span>, BODY)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = conn.getresponse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.status, response.reason)</span><br><span class="line"><span class="number">200</span>, OK</span><br></pre></td></tr></table></figure>
<h2 id="HTTPMessage-对象"><a href="#HTTPMessage-对象" class="headerlink" title="HTTPMessage 对象"></a>HTTPMessage 对象</h2><p>一个 <code>http.client.HTTPMessage</code>的实例包含了http response 请求头. 是 <a href="https://docs.python.org/zh-cn/3.8/library/email.compat32-message.html#email.message.Message" target="_blank" rel="noopener"><code>email.message.Message</code></a>类的具体实现.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过阅读源码加深了对http协议的理解,看python实现的方式受益良多。继续加油!</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library http.cookies</title>
    <url>/2020/01/09/python-standard-library-http-cookies/</url>
    <content><![CDATA[<h1 id="python-标准库-http-cookies"><a href="#python-标准库-http-cookies" class="headerlink" title="python 标准库 http.cookies"></a>python 标准库 http.cookies</h1><p>最近需要教孩子自然拼读,所以我想还是每天用一个关键词描述吧。</p>
<blockquote>
<p>traffic  .n UK /træf.ɪk/  US /ˈtræf.ɪk/  交通(拥堵)</p>
<p><em>There was heavy/a lot of traffic on the roads this morning.</em>今天早晨道路上车流量很大。</p>
<p><em>We got stuck in traffic for several hours.</em>我们碰上交通阻塞被堵了好几个小时。</p>
<p><em>New measures have been introduced to try and ease traffic congestion in the city.</em>这个城市已经采取了新措施，试图缓解交通拥堵。</p>
<p><em>Five people were injured in a traffic accident (= one involving vehicles).</em>有5人在交通事故中受伤。</p>
<p>US <em>I heard about the accident on the traffic report on the radio this morning.</em>我在今早电台的交通节目中听到了这起事故。</p>
<p><em>Air traffic has increased 30 percent in the last decade.</em>在过去的10年里，空中交通量增加了30%。</p>
</blockquote>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200109_traffic.jpg?raw=true" alt></p>
<h2 id="python-标准库学习-http-cookies"><a href="#python-标准库学习-http-cookies" class="headerlink" title="python 标准库学习   http.cookies"></a>python 标准库学习   http.cookies</h2><p>http.cookies 模块定义了类实现了http状态管理机制和cookies概念。不仅支持字符串格式化的cookie值,还支持任何序列化对象的cookie值。</p>
<p>模块的实现完全遵循 <a href="https://tools.ietf.org/html/rfc2109.html" target="_blank" rel="noopener"><strong>RFC 2109</strong></a> 和  <a href="https://tools.ietf.org/html/rfc2068.html" target="_blank" rel="noopener"><strong>RFC 2068</strong></a> 协议规范。但MSIE 3.0x不遵循那些规范中概述的字符规则，并且当涉及Cookie处理时，许多当今的浏览器和服务器已经放宽了解析规则。</p>
<p>Cookie名定义字符集中非法字符囊括在 <code>string.ascii_letters</code>,<code>string.digits</code> 和 <code>!#$%&amp;&#39;*+-.^_</code>|~:`中。    </p>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><ul>
<li><p><em>exception</em> <code>http.cookies.CookieError</code></p>
<p>违反<a href="https://tools.ietf.org/html/rfc2109.html" target="_blank" rel="noopener"><strong>RFC 2109</strong></a> 规范中的错误,例如:不正确的属性或不正确的Set-Cookies header</p>
</li>
<li><p><em>class</em> <code>http.cookies.BaseCookie([*input*])</code></p>
<p>这个类是一个字典类型的对象,键是字符串,值是 <a href="https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.Morsel" target="_blank" rel="noopener"><code>Morsel</code></a> 的实例。</p>
<p>如果设置参数<code>input</code>,实际上是通过<a href="https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.BaseCookie.load" target="_blank" rel="noopener"><code>load()</code></a> 方法设置。</p>
</li>
<li><p><em>class</em> <code>http.cookies.SimpleCookie([*input*])</code></p>
<p>这个类是从<a href="https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.BaseCookie" target="_blank" rel="noopener"><code>BaseCookie</code></a> 继承过来并重写了   <code>value_decode()</code> and <code>value_encode()</code>方法。</p>
<p>SimpleCookies支持字符串格式的cookie values.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p>
</li>
</ul>
<a id="more"></a>
<h3 id="Cookie对象"><a href="#Cookie对象" class="headerlink" title="Cookie对象"></a>Cookie对象</h3><ul>
<li><p><code>BaseCookie.value_decode(val)</code></p>
<p>以字符串形式返回 一个元组(real_value,coded_value)。其中<code>real_value</code>可以是任意类型。此方法在[<code>BaseCookie</code>]（<a href="https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.BaseCookie）中不进行解码,---因为已经存在被重写了。" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.BaseCookie）中不进行解码,---因为已经存在被重写了。</a></p>
</li>
<li><p><code>BaseCookie.value_encode</code>(<em>val</em>)</p>
<p>以字符串形式返回 一个元组(real_value,coded_value)。其中<code>val</code>可以是任意类型,<code>coded_value</code> 通常被转换为字符串类型。</p>
</li>
<li><p><code>BaseCookie.output(*attrs=None*, *header=&#39;Set-Cookie:&#39;*, *sep=&#39;\r\n&#39;*)</code></p>
<p>返回一个字符串表示的 用来适配 Http请求头,属性的相关方法。分隔符默认使用<code>\r\n</code>（CRLF）。</p>
</li>
<li><p><code>BaseCookie.js_output(*attrs=None*)</code></p>
<p>返回一个绑定Javascript脚本的对象,如果运行的浏览器支持Javascript脚本,作为输出和 out_put()的实现一样。</p>
</li>
<li><p><code>BaseCookie.load</code>(<em>rawdata</em>)`</p>
<p>如果参数rawdata 是字符串,转化为 HTTP_COOKIE对象,并添加值。</p>
<p>如果参数是字典类型,可以这样取值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> rawdata.items():     </span><br><span class="line">     cookie[k] = v</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Morsel-对象"><a href="#Morsel-对象" class="headerlink" title="Morsel 对象"></a>Morsel 对象</h3><p><em>class</em> <code>http.cookies.Morsel</code></p>
<p>部分实现了  <a href="https://tools.ietf.org/html/rfc2109.html" target="_blank" rel="noopener"><strong>RFC 2109</strong></a>  规范的键值对抽象类。</p>
<p>Morsels是一个字典类型的对象, 里面的键是一个常量,同<a href="https://tools.ietf.org/html/rfc2109.html" target="_blank" rel="noopener"><strong>RFC 2109</strong></a>  规范,如下面所示:</p>
<ul>
<li><code>expires</code></li>
<li><code>path</code></li>
<li><code>comment</code></li>
<li><code>domain</code></li>
<li><code>max-age</code></li>
<li><code>secure</code></li>
<li><code>version</code></li>
<li><code>httponly</code></li>
<li><code>samesite</code></li>
</ul>
<p><code>httponly</code> 属性声明了cookie只能通过HTTP 请求传输,并且包括Javascript脚本。这将会被合并到跨站脚本部分。</p>
<p><code>samesite</code> 声明了浏览器是否允许发送跨站请求的cookie。这将会避免CSRF 攻击。无效的值包括  “Strict” and “Lax”。</p>
<p>这些键是大小写敏感的.默认值是<code>&#39;&#39;</code>.</p>
<ul>
<li><p><code>Morsel.value</code></p>
<p>Cookie的值。</p>
</li>
<li><p><code>Morsel.coded_value</code><br>编码后的cookie值。</p>
</li>
<li><p><code>Morsel.key</code></p>
<p>cookie的名字</p>
</li>
<li><p><code>Morsel.set</code>(<em>key</em>, <em>value</em>, <em>coded_value</em>)</p>
<p>设置<code>key</code> ,<code>value</code>和 <code>coded_value* attributes</code> 属性。</p>
</li>
<li><p><code>Morsel.isReservedKey(*K*)</code></p>
<p>判断 键 知否是 <a href="https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.Morsel" target="_blank" rel="noopener"><code>Morsel</code></a>  里的键的成员。</p>
</li>
<li><p><code>Morsel.output(*attrs=None*, *header=&#39;Set-Cookie:&#39;*)</code></p>
<p>返回字符串格式的  <a href="https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.Morsel" target="_blank" rel="noopener"><code>Morsel</code></a> 。默认包括所有的属性,除非指定声明attrs 属性,<code>header</code> 参数默认值是<code>&quot;Set-Cookie:&quot;</code>.</p>
</li>
<li><p><code>Morsel.js_output(*attrs=None*)</code></p>
<p>返回一个绑定Javascript脚本的对象,如果运行的浏览器支持Javascript脚本,作为输出和 out_put()的实现一样。</p>
</li>
<li><p><code>Morsel.OutputString(*attrs=None*)</code></p>
<p>返回一个字符串格式的 Morsel,不包括Http或Javascript。</p>
</li>
<li><p><code>Morsel.update(*values*)</code></p>
<p>根据参数值更新Morsel 字典。如果参数不在字典中则引发异常。具体可以参考  <a href="https://tools.ietf.org/html/rfc2109.html" target="_blank" rel="noopener"><strong>RFC 2109</strong></a> </p>
</li>
<li><p><code>Morsel.copy(*value*)</code></p>
<p>返回一个 Morsel 对象的浅拷贝。</p>
</li>
<li><p><code>Morsel.setdefault(*key*, *value=None*)</code></p>
<p>Raise an error if key is not a valid <a href="https://tools.ietf.org/html/rfc2109.html" target="_blank" rel="noopener"><strong>RFC 2109</strong></a> attribute, otherwise behave the same as <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.setdefault" target="_blank" rel="noopener"><code>dict.setdefault()</code></a>.</p>
</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> http <span class="keyword">import</span> cookies</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = cookies.SimpleCookie()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"fig"</span>] = <span class="string">"newton"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"sugar"</span>] = <span class="string">"wafer"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C) <span class="comment"># generate HTTP headers</span></span><br><span class="line">Set-Cookie: fig=newton</span><br><span class="line">Set-Cookie: sugar=wafer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C.output()) <span class="comment"># same thing</span></span><br><span class="line">Set-Cookie: fig=newton</span><br><span class="line">Set-Cookie: sugar=wafer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = cookies.SimpleCookie()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"rocky"</span>] = <span class="string">"road"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"rocky"</span>][<span class="string">"path"</span>] = <span class="string">"/cookie"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C.output(header=<span class="string">"Cookie:"</span>))</span><br><span class="line">Cookie: rocky=road; Path=/cookie</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C.output(attrs=[], header=<span class="string">"Cookie:"</span>))</span><br><span class="line">Cookie: rocky=road</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = cookies.SimpleCookie()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.load(<span class="string">"chips=ahoy; vienna=finger"</span>) <span class="comment"># load from a string (HTTP header)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C)</span><br><span class="line">Set-Cookie: chips=ahoy</span><br><span class="line">Set-Cookie: vienna=finger</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = cookies.SimpleCookie()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.load(<span class="string">'keebler="E=everybody; L=\\"Loves\\"; fudge=\\012;";'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C)</span><br><span class="line">Set-Cookie: keebler=<span class="string">"E=everybody; L=\"Loves\"; fudge=\012;"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = cookies.SimpleCookie()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"oreo"</span>] = <span class="string">"doublestuff"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"oreo"</span>][<span class="string">"path"</span>] = <span class="string">"/"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C)</span><br><span class="line">Set-Cookie: oreo=doublestuff; Path=/</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = cookies.SimpleCookie()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"twix"</span>] = <span class="string">"none for you"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"twix"</span>].value</span><br><span class="line"><span class="string">'none for you'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = cookies.SimpleCookie()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"number"</span>] = <span class="number">7</span> <span class="comment"># equivalent to C["number"] = str(7)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"string"</span>] = <span class="string">"seven"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"number"</span>].value</span><br><span class="line"><span class="string">'7'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"string"</span>].value</span><br><span class="line"><span class="string">'seven'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C)</span><br><span class="line">Set-Cookie: number=<span class="number">7</span></span><br><span class="line">Set-Cookie: string=seven</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>顺便了解了下http协议的相关内容,附链接。</p>
<p>RFC 2068 ：<a href="http://www.blogjava.net/sunchaojin/archive/2013/12/18/279164.html#407729" target="_blank" rel="noopener">http超文本传输协议1.0</a></p>
<p>RFC 2616 ：<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">http超文本传输协议1.1</a></p>
<p>RFC 2109:  <a href="http://www.stupidbeauty.com/Blog/article/1134/RFC2109%E7%BF%BB%E8%AF%91%EF%BC%9AHTTP%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%9AHTTP%20State%20Management%20Mechanism" target="_blank" rel="noopener">http状态管理机制</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>http</tag>
        <tag>cookies</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library operator</title>
    <url>/2020/01/10/python-standard-library-operator/</url>
    <content><![CDATA[<h1 id="python-标准库-operator"><a href="#python-标准库-operator" class="headerlink" title="python 标准库 operator"></a>python 标准库 operator</h1><p>今天的关键词: trouble </p>
<blockquote>
<p>trouble</p>
<p>[英]  [ˈtrʌbl]</p>
<p>[美] [ˈtrʌbəl]</p>
<p>n.麻烦； 烦恼； 故障； 动乱；</p>
<p>vi.费心； 烦恼；</p>
<p>vt.麻烦； 使烦恼； 折磨；</p>
</blockquote>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200110_fan2.jpg?raw=true" alt></p>
<h2 id="python-标准库学习-operator"><a href="#python-标准库学习-operator" class="headerlink" title="python 标准库学习  operator"></a>python 标准库学习  operator</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/operator.html#module-operator" target="_blank" rel="noopener"><code>operator</code></a> 模块提供了一套与Python的内置运算符对应的高效率函数。例如，<code>operator.add(x, y)</code> 与表达式 <code>x+y</code> 相同。 许多函数名与特殊方法名相同，只是没有双下划线。为了向后兼容性，也保留了许多包含双下划线的函数。为了表述清楚，建议使用没有双下划线的函数。</p>
<p>函数包含的种类有：对象的比较运算、逻辑运算、数学运算以及序列运算。</p>
<p>对象比较函数适用于所有的对象，函数名根据它们对应的比较运算符命名。</p>
<h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><p><code>operator.lt(*a*, *b*)</code></p>
<p><code>operator.le(*a*, *b*)</code></p>
<p><code>operator.eq(*a*, *b*)</code></p>
<p><code>operator.ne*a*, *b*)</code></p>
<p><code>operator.ge*a*, *b*)</code></p>
<p><code>operator.gt*a*, *b*)</code></p>
<p><code>operator.__lt__*a*, *b*)</code></p>
<p><code>operator.__le__*a*, *b*)</code></p>
<p><code>operator.__eq__*a*, *b*)</code></p>
<p><code>operator.__ne__*a*, *b*)</code></p>
<p><code>operator.__ge__*a*, *b*)</code></p>
<p><code>operator.__gt__*a*, *b*)</code></p>
<a id="more"></a>
<h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><ul>
<li><p><code>operator.not_(*obj*)`</code></p>
</li>
<li><p><code>operator.__not__(*obj*)</code></p>
<p>返回 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#not" target="_blank" rel="noopener"><code>not</code></a><code>*obj* 的结果。 （请注意对象实例并没有 [</code><strong>not</strong>()<code>](https://docs.python.org/zh-cn/3.8/library/operator.html#operator.__not__) 方法；只有解释器核心可定义此操作。 结果会受 [</code><strong>bool</strong>()<code>](https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__bool__) 和 [</code><strong>len</strong>()`](<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__len__" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__len__</a>) 方法影响。）</p>
</li>
<li><p>`operator.truth(<em>obj</em>)</p>
<p>如果 <em>obj</em> 为真值则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>，否则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>。 这等价于使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#bool" target="_blank" rel="noopener"><code>bool</code></a> 构造器。</p>
</li>
<li><p><code>operator.is_(*a*, *b*)</code></p>
<p>返回 <code>a is b</code>。 检测对象标识。</p>
</li>
<li><p><code>operator.is_not(*a*, *b*)</code></p>
<p>返回 <code>a is not b</code>。 检测对象标识。</p>
</li>
</ul>
<h3 id="数学运算和位运算"><a href="#数学运算和位运算" class="headerlink" title="数学运算和位运算"></a>数学运算和位运算</h3><ul>
<li><p><code>operator.abs(*obj*)</code></p>
</li>
<li><p><code>operator.__abs__(*obj*)</code></p>
<p>返回 <em>obj</em> 的绝对值。</p>
</li>
<li><p><code>operator.add(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__add__(*a*, *b*)</code></p>
<p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a + b</code>。</p>
</li>
<li><p><code>operator.and_(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__and__(*a*, *b*)</code></p>
<p>返回 <em>x</em> 和 <em>y</em> 按位与的结果。</p>
</li>
<li><p><code>operator.floordiv(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__floordiv__(*a*, *b*)</code></p>
<p>返回 <code>a // b</code>。</p>
</li>
<li><p><code>operator.index(*a*)</code></p>
</li>
<li><p><code>operator.__index__(*a*)</code></p>
<p>返回 <em>a</em> 转换为整数的结果。 等价于 <code>a.__index__()`</code>。</p>
</li>
<li><p><code>operator.inv(*obj*)</code></p>
</li>
<li><p><code>operator.invert(*obj*)</code></p>
</li>
<li><p><code>operator.__inv__(*obj*)</code></p>
</li>
<li><p><code>operator.__invert__(*obj*)</code></p>
<p>返回数字 <em>obj</em> 按位取反的结果。 这等价于 <code>~obj</code>。</p>
</li>
<li><p><code>operator.lshift(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__lshift__(*a*, *b*)</code></p>
<p>返回 <em>a</em> 左移 <em>b</em> 位的结果。</p>
</li>
<li><p><code>operator.mod(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__mod__(*a*, *b*)</code></p>
<p>返回 <code>a % b</code>。</p>
</li>
<li><p><code>operator.mul(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__mul__(*a*, *b*)</code></p>
<p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a * b</code>。</p>
</li>
<li><p><code>operator.matmul(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__matmul__(*a*, *b*)</code></p>
<p>返回 <code>a @ b</code>。</p>
</li>
<li><p><code>operator.neg(*obj*)</code></p>
</li>
<li><p><code>operator.__neg__(*obj*)</code></p>
<p>返回 <em>obj</em> 取负的结果 (<code>-obj</code>)`。</p>
</li>
<li><p><code>operator.or_(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__or__(*a*, *b*)</code></p>
<p>返回 <em>a</em> 和 <em>b</em> 按位或的结果。</p>
</li>
<li><p><code>operator.pos(*obj*)</code></p>
</li>
<li><p><code>operator.__pos__(*obj*)</code></p>
<p>返回 <em>obj</em> 取正的结果 (<code>+obj</code>)`。</p>
</li>
<li><p><code>operator.pow(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__pow__(*a*, *b*)</code></p>
<p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a ** b</code>。</p>
</li>
<li><p><code>operator.rshift(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__rshift__(*a*, *b*)</code></p>
<p>返回 <em>a</em> 右移 <em>b</em> 位的结果。</p>
</li>
<li><p><code>operator.sub(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__sub__(*a*, *b*)</code></p>
<p>返回 <code>a - b</code>。</p>
</li>
<li><p><code>operator.truediv(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__truediv__(*a*, *b*)</code></p>
<p>返回 <code>a / b</code> 例如 2/3 将等于 .66 而不是 0。 这也被称为“真”除法。</p>
</li>
<li><p><code>operator.xor(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__xor__(*a*, *b*)</code></p>
<p>返回 <em>a</em> 和 <em>b</em> 按位异或的结果。</p>
</li>
</ul>
<p>适用于序列的操作（其中一些也适用于映射）包括：</p>
<ul>
<li><p><code>operator.concat(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__concat__(*a*, *b*)</code></p>
<p>对于序列 <em>a</em> 和 <em>b</em>，返回 <code>a + b</code>。</p>
</li>
<li><p><code>operator.contains(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__contains__(*a*, *b*)</code></p>
<p>返回 <code>b in a</code> 检测的结果。 请注意操作数是反序的。</p>
</li>
<li><p><code>operator.countOf(*a*, *b*)</code></p>
<p>返回 <em>b</em> 在 <em>a</em> 中的出现次数。</p>
</li>
<li><p><code>operator.delitem(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__delitem__(*a*, *b*)</code></p>
<p>移除索引号 <em>b</em> 上的值 <em>a</em>。</p>
</li>
<li><p><code>operator.getitem(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__getitem__(*a*, *b*)</code></p>
<p>返回索引号 <em>b</em> 上的值 <em>a</em>。</p>
</li>
<li><p><code>operator.indexOf(*a*, *b*)</code></p>
<p>返回 <em>b</em> 在 <em>a</em> 中首次出现所在的索引号。</p>
</li>
<li><p><code>operator.setitem(*a*, *b*, *c*)</code></p>
</li>
<li><p><code>operator.__setitem__(*a*, *b*, *c*)</code></p>
<p>将索引号 <em>b</em> 上的值 <em>a</em> 设为 <em>c</em>。</p>
</li>
<li><p><code>operator.length_hint(*obj*, *default=0*)</code></p>
<p>返回对象 <em>o</em> 的估计长度。 首先尝试返回其实际长度，再使用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__length_hint__" target="_blank" rel="noopener"><code>object.__length_hint__()</code></a> 得出估计值，最后返回默认值。</p>
</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><code>operator.attrgetter(*attr*)</code></p>
<p><code>operator.attrgetter(**attrs*)</code></p>
<p>返回一个可从操作数中获取 <em>attr</em> 的可调用对象。 如果请求了一个以上的属性，则返回一个属性元组。 属性名称还可包含点号。 例如：</p>
<ul>
<li>在 <code>f = attrgetter(&#39;name&#39;)</code> 之后，调用 <code>f(b)</code> 将返回 <code>b.name</code>。</li>
<li>在 <code>f = attrgetter(&#39;name&#39;, &#39;date&#39;)</code> 之后，调用 <code>f(b)</code> 将返回 (b.name, b.date)`。</li>
<li>在 <code>f = attrgetter(&#39;name.first&#39;, &#39;name.last&#39;)</code> 之后，调用 <code>f(b)</code> 将返回 (b.name.first, b.name.last)`。</li>
</ul>
<p>`operator.itemgetter(<em>item</em>)</p>
<p>`operator.itemgetter(*<em>items</em>)</p>
<p>返回一个使用操作数的 <a href="https://docs.python.org/zh-cn/3.8/library/operator.html#operator.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法从操作数中获取 <em>item</em> 的可调用对象。 如果指定了多个条目，则返回一个查找值的元组。 例如：</p>
<ul>
<li>在 <code>f = itemgetter(2)</code> 之后，调用 <code>f(r)</code> 将返回 <code>r[2]</code>。</li>
<li>在 <code>g = itemgetter(2, 5, 3)</code> 之后，调用 <code>g(r)</code> 将返回 (r[2], r[5], r[3])`。</li>
</ul>
<h3 id="将运算符映射到函数"><a href="#将运算符映射到函数" class="headerlink" title="将运算符映射到函数"></a>将运算符映射到函数</h3><table>
<thead>
<tr>
<th>运算</th>
<th>语法</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>加法</td>
<td><code>a + b</code></td>
<td><code>add(a, b)</code></td>
</tr>
<tr>
<td>字符串拼接</td>
<td><code>seq1 + seq2</code></td>
<td><code>concat(seq1, seq2)</code></td>
</tr>
<tr>
<td>包含测试</td>
<td><code>obj in seq</code></td>
<td><code>contains(seq, obj)</code></td>
</tr>
<tr>
<td>除法</td>
<td><code>a / b</code></td>
<td><code>truediv(a, b)</code></td>
</tr>
<tr>
<td>除法</td>
<td><code>a // b</code></td>
<td><code>floordiv(a, b)</code></td>
</tr>
<tr>
<td>按位与</td>
<td><code>a &amp; b</code></td>
<td><code>and_(a, b)</code></td>
</tr>
<tr>
<td>按位异或</td>
<td><code>a ^ b</code></td>
<td><code>xor(a, b)</code></td>
</tr>
<tr>
<td>按位取反</td>
<td><code>~ a</code></td>
<td><code>invert(a)</code></td>
</tr>
<tr>
<td>按位或</td>
<td>`a</td>
<td>b`</td>
<td><code>or_(a, b)</code></td>
</tr>
<tr>
<td>取幂</td>
<td><code>a ** b</code></td>
<td><code>pow(a, b)</code></td>
</tr>
<tr>
<td>标识</td>
<td><code>a is b</code></td>
<td><code>is_(a, b)</code></td>
</tr>
<tr>
<td>标识</td>
<td><code>a is not b</code></td>
<td><code>is_not(a, b)</code></td>
</tr>
<tr>
<td>索引赋值</td>
<td><code>obj[k] = v</code></td>
<td><code>setitem(obj, k, v)</code></td>
</tr>
<tr>
<td>索引删除</td>
<td><code>del obj[k]</code></td>
<td><code>delitem(obj, k)</code></td>
</tr>
<tr>
<td>索引取值</td>
<td><code>obj[k]</code></td>
<td><code>getitem(obj, k)</code></td>
</tr>
<tr>
<td>左移</td>
<td><code>a &lt;&lt; b</code></td>
<td><code>lshift(a, b)</code></td>
</tr>
<tr>
<td>取模</td>
<td><code>a % b</code></td>
<td><code>mod(a, b)</code></td>
</tr>
<tr>
<td>乘法</td>
<td><code>a * b</code></td>
<td><code>mul(a, b)</code></td>
</tr>
<tr>
<td>矩阵乘法</td>
<td><code>a @ b</code></td>
<td><code>matmul(a, b)</code></td>
</tr>
<tr>
<td>取反（算术）</td>
<td><code>- a</code></td>
<td><code>neg(a)</code></td>
</tr>
<tr>
<td>取反（逻辑）</td>
<td><code>not a</code></td>
<td><code>not_(a)</code></td>
</tr>
<tr>
<td>正数</td>
<td><code>+ a</code></td>
<td><code>pos(a)</code></td>
</tr>
<tr>
<td>右移</td>
<td><code>a &gt;&gt; b</code></td>
<td><code>rshift(a, b)</code></td>
</tr>
<tr>
<td>切片赋值</td>
<td><code>seq[i:j] = values</code></td>
<td><code>setitem(seq, slice(i, j), values)</code></td>
</tr>
<tr>
<td>切片删除</td>
<td><code>del seq[i:j]</code></td>
<td><code>delitem(seq, slice(i, j))</code></td>
</tr>
<tr>
<td>切片取值</td>
<td><code>seq[i:j]</code></td>
<td><code>getitem(seq, slice(i, j))</code></td>
</tr>
<tr>
<td>字符串格式化</td>
<td><code>s % obj</code></td>
<td><code>mod(s, obj)</code></td>
</tr>
<tr>
<td>减法</td>
<td><code>a - b</code></td>
<td><code>sub(a, b)</code></td>
</tr>
<tr>
<td>真值测试</td>
<td><code>obj</code></td>
<td><code>truth(obj)</code></td>
</tr>
<tr>
<td>比较</td>
<td><code>a &lt; b</code></td>
<td><code>lt(a, b)</code></td>
</tr>
<tr>
<td>比较</td>
<td><code>a &lt;= b</code></td>
<td><code>le(a, b)</code></td>
</tr>
<tr>
<td>相等</td>
<td><code>a == b</code></td>
<td><code>eq(a, b)</code></td>
</tr>
<tr>
<td>不等</td>
<td><code>a != b</code></td>
<td><code>ne(a, b)</code></td>
</tr>
<tr>
<td>比较</td>
<td><code>a &gt;= b</code></td>
<td><code>ge(a, b)</code></td>
</tr>
<tr>
<td>比较</td>
<td><code>a &gt; b</code></td>
<td><code>gt(a, b)</code></td>
</tr>
</tbody>
</table>
<h3 id="原地运算符"><a href="#原地运算符" class="headerlink" title="原地运算符"></a>原地运算符</h3><ul>
<li><p><code>operator.iadd(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__iadd__(*a*, *b*)</code></p>
<p><code>a = iadd(a, b)</code> 等价于 <code>a += b</code>。</p>
</li>
<li><p><code>operator.iand(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__iand__(*a*, *b*)</code></p>
<p><code>a = iand(a, b)</code> 等价于 <code>a &amp;= b</code>。</p>
</li>
<li><p><code>operator.iconcat(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__iconcat__(*a*, *b*)</code></p>
<p><code>a = iconcat(a, b)</code> 等价于 <code>a += b</code> 其中 <em>a</em> 和 <em>b</em> 为序列。</p>
</li>
<li><p><code>operator.ifloordiv(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__ifloordiv__(*a*, *b*)</code></p>
<p><code>a = ifloordiv(a, b)</code> 等价于 <code>a //= b</code>。</p>
</li>
<li><p><code>operator.ilshift(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__ilshift__(*a*, *b*)</code></p>
<p><code>a = ilshift(a, b)</code> 等价于 <code>a &lt;&lt;= b</code>。</p>
</li>
<li><p><code>operator.imod(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__imod__(*a*, *b*)</code></p>
<p><code>a = imod(a, b)</code> 等价于 <code>a %= b</code>。</p>
</li>
<li><p><code>operator.imul(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__imul__(*a*, *b*)</code></p>
<p><code>a = imul(a, b)</code> 等价于 <code>a *= b</code>。</p>
</li>
<li><p><code>operator.imatmul(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__imatmul__(*a*, *b*)</code></p>
<p><code>a = imatmul(a, b)</code> 等价于 <code>a @= b</code>。<em>3.5 新版功能.</em></p>
</li>
<li><p><code>operator.ior(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__ior__(*a*, *b*)</code></p>
<p><code>a = ior(a, b)</code> 等价于 <code>a |= b</code>。</p>
</li>
<li><p><code>operator.ipow(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__ipow__(*a*, *b*)</code></p>
<p><code>a = ipow(a, b)</code> 等价于 <code>a **= b</code>。</p>
</li>
<li><p><code>operator.irshift(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__irshift__(*a*, *b*)</code></p>
<p><code>a = irshift(a, b)</code> 等价于 <code>a &gt;&gt;= b</code>。</p>
</li>
<li><p><code>operator.isub(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__isub__(*a*, *b*)</code></p>
<p><code>a = isub(a, b)</code> 等价于 <code>a -= b</code>。</p>
</li>
<li><p><code>operator.itruediv(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__itruediv__(*a*, *b*)</code></p>
<p><code>a = itruediv(a, b)</code> 等价于 <code>a /= b</code>。</p>
</li>
<li><p><code>operator.ixor(*a*, *b*)</code></p>
</li>
<li><p><code>operator.__ixor__(*a*, *b*)</code></p>
<p><code>a = ixor(a, b)</code> 等价于 <code>a ^= b</code>。</p>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>朋友建议我说,别光说标准库的基本使用,最好有一些实际的例子,接下来我会在每一篇博客的最后给大家一些实际应用的例子，欢迎大家批评指正。</p>
<p>稍后我会在对应的文章下面开通gitalk,大家可以及时给我留言。</p>
<p>实现一个简单的计算器,不使用if else</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculator</span><span class="params">(a, b, k)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'+'</span>: add,</span><br><span class="line">        <span class="string">'-'</span>: sub,</span><br><span class="line">        <span class="string">'*'</span>: mul,</span><br><span class="line">        <span class="string">'/'</span>: truediv,</span><br><span class="line">        <span class="string">'**'</span>: pow</span><br><span class="line">    &#125;[k](a, b)</span><br><span class="line"></span><br><span class="line">calculator(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'+'</span>)  <span class="comment"># 3</span></span><br><span class="line">calculator(<span class="number">3</span>, <span class="number">4</span>, <span class="string">'**'</span>)  <span class="comment"># 81</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>operator</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library context-manager-types</title>
    <url>/2020/01/11/python-standard-library-context-manager-types/</url>
    <content><![CDATA[<h1 id="python-标准库-上下文管理类型"><a href="#python-标准库-上下文管理类型" class="headerlink" title="python 标准库 上下文管理类型"></a>python 标准库 上下文管理类型</h1><p>每日一词:</p>
<blockquote>
<p>intresting : </p>
<p>US [‘ɪntrəstɪŋ]  UK [‘ɪntrəstɪŋ]</p>
<ul>
<li><strong>adj.</strong>有趣的；有吸引力的</li>
<li><strong>v.</strong>“interest”的现在分词</li>
<li><strong>Web</strong>有意思的；令人感兴趣的；引人入胜的</li>
</ul>
<p>比较级：more interesting<br>最高级：most interesting</p>
</blockquote>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200111_heihei.jpg?raw=true" alt></p>
<blockquote>
<p> 大部分时候,你都是一个人在默默努力,这样,距离成功才会更进一步。</p>
<p>​                                                        – 凭海临风语录</p>
</blockquote>
<h2 id="python-标准库学习-上下文管理"><a href="#python-标准库学习-上下文管理" class="headerlink" title="python 标准库学习  上下文管理"></a>python 标准库学习  上下文管理</h2><p>什么是上下文管理器？上下文管理器就是一个用装饰器实现上下文协议管理的对象。主要用于保存和恢复各种全局状态,例如关闭文件等。下面我们来了解具体的内容。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p><code>contextmanager.__enter__()</code></p>
<p>进入运行时上下文并返回此对象或关联到该运行时上下文的其他对象。 此方法的返回值会绑定到使用此上下文管理器的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的 <code>as</code> 子句中的标识符。一个返回其自身的上下文管理器的例子是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a>。 文件对象会从 <strong>enter</strong>() 返回其自身，以允许 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 被用作 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中的上下文表达式。一个返回关联对象的上下文管理器的例子是 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.localcontext" target="_blank" rel="noopener"><code>decimal.localcontext()</code></a> 所返回的对象。 此种管理器会将活动的 decimal 上下文设为原始 decimal 上下文的一个副本并返回该副本。 这允许对 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的语句体中的当前 decimal 上下文进行更改，而不会影响 <code>with</code> 语句以外的代码。</p>
</li>
<li><p><code>contextmanager.__exit__(*exc_type*, *exc_val*, *exc_tb*)</code></p>
<p>退出运行时上下文并返回一个布尔值旗标来表明所发生的任何异常是否应当被屏蔽。 如果在执行 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的语句体期间发生了异常，则参数会包含异常的类型、值以及回溯信息。 在其他情况下三个参数均为 <code>None</code>。自此方法返回一个真值将导致 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句屏蔽异常并继续执行紧随在 <code>with</code> 语句之后的语句。 否则异常将在此方法结束执行后继续传播。 在此方法执行期间发生的异常将会取代 <code>with</code> 语句的语句体中发生的任何异常。传入的异常绝对不应当被显式地重新引发 —— 相反地，此方法应当返回一个假值以表明方法已成功完成并且不希望屏蔽被引发的异常。 这允许上下文管理代码方便地检测 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#contextmanager.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 方法是否确实已失败。</p>
</li>
</ul>
<h4 id="一个文件操作实例"><a href="#一个文件操作实例" class="headerlink" title="一个文件操作实例"></a>一个文件操作实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">"/etc/hosts"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> file:</span><br><span class="line"><span class="meta">... </span>    dir(file)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__enter__'</span>, <span class="string">'__exit__'</span>, <span class="string">'__format__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'close'</span>, <span class="string">'closed'</span>, <span class="string">'encoding'</span>, <span class="string">'errors'</span>, <span class="string">'fileno'</span>, <span class="string">'flush'</span>, <span class="string">'isatty'</span>, <span class="string">'mode'</span>, <span class="string">'name'</span>, <span class="string">'newlines'</span>, <span class="string">'next'</span>, <span class="string">'read'</span>, <span class="string">'readinto'</span>, <span class="string">'readline'</span>, <span class="string">'readlines'</span>, <span class="string">'seek'</span>, <span class="string">'softspace'</span>, <span class="string">'tell'</span>, <span class="string">'truncate'</span>, <span class="string">'write'</span>, <span class="string">'writelines'</span>, <span class="string">'xreadlines'</span>]</span><br></pre></td></tr></table></figure>
<p>此时的open返回的对象file,就实现了管理打开文件、关闭文件的上下文管理协议。</p>
<a id="more"></a>
<h3 id="with-语句上下文管理器"><a href="#with-语句上下文管理器" class="headerlink" title="with 语句上下文管理器"></a>with 语句上下文管理器</h3><p><em>上下文管理器</em> 是一个对象，它定义了在执行 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句时要建立的运行时上下文。 上下文管理器处理进入和退出所需运行时上下文以执行代码块。 通常使用 <code>with</code> 语句（在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener">with 语句</a> 中描述），但是也可以通过直接调用它们的方法来使用。</p>
<p>上下文管理器的典型用法包括保存和恢复各种全局状态，锁定和解锁资源，关闭打开的文件等等。</p>
<p>要了解上下文管理器的更多信息，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#typecontextmanager" target="_blank" rel="noopener">上下文管理器类型</a>。</p>
<ul>
<li><p><code>object.__enter__</code>(<em>self</em>)</p>
<p>进入与此对象相关的运行时上下文。 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句将会绑定这个方法的返回值到 <code>as</code> 子句中指定的目标，如果有的话。</p>
</li>
<li><p><code>object.__exit__</code>(<em>self</em>, <em>exc_type</em>, <em>exc_value</em>, <em>traceback</em>)</p>
<p>退出关联到此对象的运行时上下文。 各个参数描述了导致上下文退出的异常。 如果上下文是无异常地退出的，三个参数都将为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。如果提供了异常，并且希望方法屏蔽此异常（即避免其被传播），则应当返回真值。 否则的话，异常将在退出此方法时按正常流程处理。请注意 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 方法不应该重新引发被传入的异常，这是调用者的责任。</p>
</li>
</ul>
<blockquote>
<p>可以参考</p>
<ul>
<li><p><a href="https://www.python.org/dev/peps/pep-0343" target="_blank" rel="noopener"><strong>PEP 343</strong></a> - “with” 语句</p>
<p>Python <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的规范描述、背景和示例。</p>
</li>
</ul>
</blockquote>
<h3 id="自定义上下文管理"><a href="#自定义上下文管理" class="headerlink" title="自定义上下文管理"></a>自定义上下文管理</h3><p>实现<code>__enter__</code> 和 <code>__exit__</code> 方法就是一个实现了上下文管理的类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'__init__()'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'__enter__()'</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"__exit__()"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ContextManager():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"OK, we can do something here~~"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">__init__()</span><br><span class="line">__enter__()</span><br><span class="line">OK, we can do something here~~</span><br><span class="line">__exit__()</span><br></pre></td></tr></table></figure>
<p>另一个不返回当前类的上下文管理器的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerContext</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'InnerContext.__init__(%s)'</span> % obj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'InnerContext.do_something()'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'InnerContext.__del__()'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__init__()'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__enter__()'</span></span><br><span class="line">        <span class="keyword">return</span> InnerContext(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"ContextManager.__exit__()"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ContextManager() <span class="keyword">as</span> obj:</span><br><span class="line">    obj.do_something()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"OK, we can do something here~~"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">ContextManager.__init__()</span><br><span class="line">ContextManager.__enter__()</span><br><span class="line">InnerContext.__init__(&lt;__main__.ContextManager object at <span class="number">0x1012f95d0</span>&gt;)</span><br><span class="line">InnerContext.do_something()</span><br><span class="line">OK, we can do something here~~</span><br><span class="line">ContextManager.__exit__()</span><br><span class="line">InnerContext.__del__()</span><br></pre></td></tr></table></figure>
<p>异常处理的例子 ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, flag)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__init__(%s)'</span> % flag</span><br><span class="line">        self.flag = flag</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__enter__()'</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__exit__(%s, %s, %s)'</span> % (exc_type, exc_val, exc_tb)</span><br><span class="line">        <span class="keyword">return</span> self.flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ContextManager(<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">'error message handled'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">with</span> ContextManager(<span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">'error message propagated'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">ContextManager.__init__(<span class="literal">True</span>)</span><br><span class="line">ContextManager.__enter__()</span><br><span class="line">ContextManager.__exit__(&lt;type <span class="string">'exceptions.RuntimeError'</span>&gt;, error message handled, &lt;traceback object at <span class="number">0x10d69dbd8</span>&gt;)</span><br><span class="line"></span><br><span class="line">ContextManager.__init__(<span class="literal">False</span>)</span><br><span class="line">ContextManager.__enter__()</span><br><span class="line">ContextManager.__exit__(&lt;type <span class="string">'exceptions.RuntimeError'</span>&gt;, error message propagated, &lt;traceback object at <span class="number">0x109e0fbd8</span>&gt;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"ContextManager.py"</span>, line <span class="number">19</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">'error message propagated'</span>)</span><br><span class="line">RuntimeError: error message propagated</span><br></pre></td></tr></table></figure>
<h3 id="contextlib-模块"><a href="#contextlib-模块" class="headerlink" title="contextlib 模块"></a>contextlib 模块</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/contextlib.html#contextlib.contextmanager" target="_blank" rel="noopener">参考文档</a></p>
<p>源代码 <a href="https://github.com/python/cpython/tree/3.8/Lib/contextlib.py" target="_blank" rel="noopener">Lib/contextlib.py</a></p>
<p>这个内置模块实现了上下文管理,使用<code>with</code>关键字。</p>
<p>主要方法如下(节选自源码):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [<span class="string">"asynccontextmanager"</span>, <span class="string">"contextmanager"</span>, <span class="string">"closing"</span>, <span class="string">"nullcontext"</span>,</span><br><span class="line">           <span class="string">"AbstractContextManager"</span>, <span class="string">"AbstractAsyncContextManager"</span>,</span><br><span class="line">           <span class="string">"AsyncExitStack"</span>, <span class="string">"ContextDecorator"</span>, <span class="string">"ExitStack"</span>,</span><br><span class="line">           <span class="string">"redirect_stdout"</span>, <span class="string">"redirect_stderr"</span>, <span class="string">"suppress"</span>]</span><br></pre></td></tr></table></figure>
<h4 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h4><p><em>class</em> <code>contextlib.AbstractContextManager</code></p>
<blockquote>
<p>同步的上下文管理类</p>
</blockquote>
<p><em>class</em> <code>contextlib.AbstractAsyncContextManager</code></p>
<blockquote>
<p>异步的上下文管理类</p>
</blockquote>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><ul>
<li><p><a href="mailto:`@contextlib.contextmanager" target="_blank" rel="noopener">`@contextlib.contextmanager</a>`</p>
<p>一个实现了上下文资源管理的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">managed_resource</span><span class="params">(*args, **kwds)</span>:</span></span><br><span class="line">    <span class="comment"># Code to acquire resource, e.g.:</span></span><br><span class="line">    resource = acquire_resource(*args, **kwds)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> resource</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># Code to release resource, e.g.:</span></span><br><span class="line">        release_resource(resource)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> managed_resource(timeout=<span class="number">3600</span>) <span class="keyword">as</span> resource:</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># Resource is released at the end of this block,</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># even if code in the block raises an exception</span></span><br></pre></td></tr></table></figure>
<p>==tips== : 注意这里 返回的是generator对象，每次迭代器只会yield一个对象出来,这个值会用在<code>with</code>语句中,绑定到<code>as</code> 后的对象上。 </p>
</li>
<li><p>@contextlib.asynccontextmanager`</p>
<p>下面是一个实现了异步上下文管理器的实例,关于操作数据库对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> asynccontextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_connection</span><span class="params">()</span>:</span></span><br><span class="line">    conn = <span class="keyword">await</span> acquire_db_connection()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> conn</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">await</span> release_db_connection(conn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_all_users</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> get_connection() <span class="keyword">as</span> conn:</span><br><span class="line">        <span class="keyword">return</span> conn.query(<span class="string">'SELECT ...'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul>
<li><p><code>contextlib.closing</code>(<em>thing</em>)</p>
<p>返回一个上下文管理对象,在语句结束之前被调用</p>
<p>相当于下面的实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closing</span><span class="params">(thing)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> thing</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        thing.close()</span><br></pre></td></tr></table></figure>
<p>也可以这样实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> closing</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> closing(urlopen(<span class="string">'http://www.python.org'</span>)) <span class="keyword">as</span> page:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> page:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>contextlib.nullcontext</code></p>
<blockquote>
<p>返回一个上下文管理对象( 实现了<code>__enter__</code>方法)</p>
</blockquote>
<p>一个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunction</span><span class="params">(arg, ignore_exceptions=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> ignore_exceptions:</span><br><span class="line">        <span class="comment"># Use suppress to ignore all exceptions.</span></span><br><span class="line">        cm = contextlib.suppress(Exception)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Do not ignore any exceptions, cm has no effect.</span></span><br><span class="line">        cm = contextlib.nullcontext()</span><br><span class="line">    <span class="keyword">with</span> cm:</span><br><span class="line">        <span class="comment"># Do something</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  另一个例子</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_file</span><span class="params">(file_or_path)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(file_or_path, str):</span><br><span class="line">        <span class="comment"># If string, open file</span></span><br><span class="line">        cm = open(file_or_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Caller is responsible for closing file</span></span><br><span class="line">        cm = nullcontext(file_or_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> cm <span class="keyword">as</span> file:</span><br><span class="line">        <span class="comment"># Perform processing on the file</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>contextlib.suppress</code></p>
<blockquote>
<p>返回一个声明的异常对象的上下文管理</p>
</blockquote>
<p>一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> suppress</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> suppress(FileNotFoundError):</span><br><span class="line">    os.remove(<span class="string">'somefile.tmp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> suppress(FileNotFoundError):</span><br><span class="line">    os.remove(<span class="string">'someotherfile.tmp'</span>)</span><br></pre></td></tr></table></figure>
<p>和下面的代码等价</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.remove(<span class="string">'somefile.tmp'</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.remove(<span class="string">'someotherfile.tmp'</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>contextlib.redirect_stdout</code></p>
<blockquote>
<p>临时输出标准输出的上下文管理器</p>
</blockquote>
</li>
<li><p><code>contextlib.redirect_stderr</code></p>
<blockquote>
<p>临时输出标准错误的上下文管理器</p>
</blockquote>
</li>
<li><p><em>class</em> <code>contextlib.ContextDecorator</code></p>
</li>
</ul>
<blockquote>
<p>允许一个类像装饰器那样使用,<code>ContextDecorator</code> 正好实现了<code>__enter__</code> and <code>__exit__</code> 方法。</p>
<p>使用contextlib就自动调用这个装饰器。</p>
</blockquote>
<p> 一个实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> ContextDecorator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontext</span><span class="params">(ContextDecorator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Starting'</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *exc)</span>:</span></span><br><span class="line">        print(<span class="string">'Finishing'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@mycontext()</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'The bit in the middle'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>function()</span><br><span class="line">Starting</span><br><span class="line">The bit <span class="keyword">in</span> the middle</span><br><span class="line">Finishing</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> mycontext():</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'The bit in the middle'</span>)</span><br><span class="line">...</span><br><span class="line">Starting</span><br><span class="line">The bit <span class="keyword">in</span> the middle</span><br><span class="line">Finishing</span><br></pre></td></tr></table></figure>
<p>其实本质上就是实现了语法糖</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> cm():</span><br><span class="line">        <span class="comment"># Do stuff</span></span><br></pre></td></tr></table></figure>
<p><code>ContextDecorator</code> 允许你这样使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@cm()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Do stuff</span></span><br></pre></td></tr></table></figure>
<p>允许你通过继承ContextBaseClass和ContextDecorator,实现Mixin class(我也不知道该如何翻译,姑且翻译成混合继承吧)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> ContextDecorator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontext</span><span class="params">(ContextBaseClass, ContextDecorator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *exc)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li><em>class</em> <code>contextlib.ExitStack</code></li>
</ul>
<blockquote>
<p>一个上下文管理器可以被设计成自动合并其他上下文管理器,清除方法(栈),尤其是那些需要输入数据的功能实现。</p>
<p>这里我看了源码,通过一个栈结构管理上下文管理， 其实就是实现了一个上下文管理器栈</p>
<p>下面是一个例子:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> ExitStack() <span class="keyword">as</span> stack:</span><br><span class="line">    files = [stack.enter_context(open(fname)) <span class="keyword">for</span> fname <span class="keyword">in</span> filenames]</span><br><span class="line">    <span class="comment"># All opened files will automatically be closed at the end of</span></span><br><span class="line">    <span class="comment"># the with statement, even if attempts to open files later</span></span><br><span class="line">    <span class="comment"># in the list raise an exception</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>个人理解这是一个低级的api,内部实现了,你无需关心何时该调用该方法,由python内部去处理。</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>最近恰好看flask的源码,flask的生命周期管理也是使用上下文管理装饰器实现。</p>
<p>等有空再更新一篇吧。</p>
<p>今天就到这里,祝大家周末愉快！</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>context-manager-types</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library collections.abc</title>
    <url>/2020/01/12/python-standard-library-collections-abc/</url>
    <content><![CDATA[<h1 id="python-标准库-之-collections-abc"><a href="#python-标准库-之-collections-abc" class="headerlink" title="python 标准库 之 collections.abc"></a>python 标准库 之 collections.abc</h1><p>每日一词: wrong</p>
<blockquote>
<p><em>adj.</em> 不道德的, 不正当的, 不义的</p>
<p>不确实的, 不正确的, 错误的</p>
<p>不合要求的, 不适合的, 并非合意的</p>
<p>有故障, 有毛病</p>
<p><em>adv.</em> 方式或方向错误地; 错误地; 结果错误地</p>
<p><em>n.</em> 罪过, 过失, 罪恶</p>
<p>不义的行为, 不公正的事</p>
<p>时 态: wronged, wronging, wrongs<br>名 词: wronger<br>副 词: wrongly<br>名 词: wrongness</p>
<p> 词语：</p>
<p><em>confound right and wrong</em></p>
<p>混淆是非，黑白不分</p>
<p><em>get one wrong</em></p>
<p>误会某人；误会</p>
<p> <em>right or wrong</em><br><em>adv.</em> 不管如何 </p>
<p><em>something wrong with</em></p>
<p>…出了毛病；…有问题；…不对头</p>
</blockquote>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200112update1.jpg?raw=true" alt></p>
<h2 id="python-标准库学习之-抽象基类-collection-abc"><a href="#python-标准库学习之-抽象基类-collection-abc" class="headerlink" title="python 标准库学习之 抽象基类 collection.abc"></a>python 标准库学习之 抽象基类 collection.abc</h2><p>众所周知,python3中所有类默认继承自object类,意味着父类中所有的方法,子类都继承了。</p>
<p>我个人理解,抽象基类是无法被实例化的,只能子类实现</p>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html" target="_blank" rel="noopener">参考文档</a></p>
<p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/_collections_abc.py" target="_blank" rel="noopener">Lib/_collections_abc.py</a> </p>
<p> 该模块定义了一些 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class" target="_blank" rel="noopener">抽象基类</a>，它们可用于判断一个具体类是否具有某一特定的接口；例如，这个类是否可哈希，或其是否为映射类。 </p>
<p>模块里方法一览,摘自源码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [<span class="string">"Awaitable"</span>, <span class="string">"Coroutine"</span>,</span><br><span class="line">           <span class="string">"AsyncIterable"</span>, <span class="string">"AsyncIterator"</span>, <span class="string">"AsyncGenerator"</span>,</span><br><span class="line">           <span class="string">"Hashable"</span>, <span class="string">"Iterable"</span>, <span class="string">"Iterator"</span>, <span class="string">"Generator"</span>, <span class="string">"Reversible"</span>,</span><br><span class="line">           <span class="string">"Sized"</span>, <span class="string">"Container"</span>, <span class="string">"Callable"</span>, <span class="string">"Collection"</span>,</span><br><span class="line">           <span class="string">"Set"</span>, <span class="string">"MutableSet"</span>,</span><br><span class="line">           <span class="string">"Mapping"</span>, <span class="string">"MutableMapping"</span>,</span><br><span class="line">           <span class="string">"MappingView"</span>, <span class="string">"KeysView"</span>, <span class="string">"ItemsView"</span>, <span class="string">"ValuesView"</span>,</span><br><span class="line">           <span class="string">"Sequence"</span>, <span class="string">"MutableSequence"</span>,</span><br><span class="line">           <span class="string">"ByteString"</span>,</span><br><span class="line">           ]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="容器抽象基类"><a href="#容器抽象基类" class="headerlink" title="容器抽象基类"></a>容器抽象基类</h2><p> 这个容器模块提供了以下 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class" target="_blank" rel="noopener">ABCs</a>: </p>
<table>
<thead>
<tr>
<th style="text-align:left">抽象基类</th>
<th style="text-align:left">继承自</th>
<th style="text-align:left">抽象方法</th>
<th style="text-align:left">Mixin 方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Container" target="_blank" rel="noopener"><code>Container</code></a></td>
<td style="text-align:left"></td>
<td style="text-align:left"><code>__contains__</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Hashable" target="_blank" rel="noopener"><code>Hashable</code></a></td>
<td style="text-align:left"></td>
<td style="text-align:left"><code>__hash__</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a></td>
<td style="text-align:left"></td>
<td style="text-align:left"><code>__iter__</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterator" target="_blank" rel="noopener"><code>Iterator</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a></td>
<td style="text-align:left"><code>__next__</code></td>
<td style="text-align:left"><code>__iter__</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Reversible" target="_blank" rel="noopener"><code>Reversible</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a></td>
<td style="text-align:left"><code>__reversed__</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Generator" target="_blank" rel="noopener"><code>Generator</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterator" target="_blank" rel="noopener"><code>Iterator</code></a></td>
<td style="text-align:left"><code>send</code>, <code>throw</code></td>
<td style="text-align:left"><code>close</code>, <code>__iter__</code>, <code>__next__</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sized" target="_blank" rel="noopener"><code>Sized</code></a></td>
<td style="text-align:left"></td>
<td style="text-align:left"><code>__len__</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Callable" target="_blank" rel="noopener"><code>Callable</code></a></td>
<td style="text-align:left"></td>
<td style="text-align:left"><code>__call__</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sized" target="_blank" rel="noopener"><code>Sized</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Container" target="_blank" rel="noopener"><code>Container</code></a></td>
<td style="text-align:left"><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Reversible" target="_blank" rel="noopener"><code>Reversible</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td>
<td style="text-align:left"><code>__getitem__</code>, <code>__len__</code></td>
<td style="text-align:left"><code>__contains__</code>, <code>__iter__</code>, <code>__reversed__</code>, <code>index</code>, and <code>count</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableSequence" target="_blank" rel="noopener"><code>MutableSequence</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a></td>
<td style="text-align:left"><code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__len__</code>, <code>insert</code></td>
<td style="text-align:left">继承自 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a> 的方法，以及 <code>append</code>, <code>reverse</code>, <code>extend</code>, <code>pop</code>, <code>remove</code>，和 <code>__iadd__</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.ByteString" target="_blank" rel="noopener"><code>ByteString</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a></td>
<td style="text-align:left"><code>__getitem__</code>, <code>__len__</code></td>
<td style="text-align:left">继承自 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a> 的方法</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td>
<td style="text-align:left"><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code></td>
<td style="text-align:left"><code>__le__</code>, <code>__lt__</code>, <code>__eq__</code>, <code>__ne__</code>, <code>__gt__</code>, <code>__ge__</code>, <code>__and__</code>, <code>__or__</code>, <code>__sub__</code>, <code>__xor__</code>, and <code>isdisjoint</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableSet" target="_blank" rel="noopener"><code>MutableSet</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a></td>
<td style="text-align:left"><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code>, <code>add</code>, <code>discard</code></td>
<td style="text-align:left">继承自 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> 的方法以及 <code>clear</code>, <code>pop</code>, <code>remove</code>, <code>__ior__</code>, <code>__iand__</code>, <code>__ixor__</code>，和 <code>__isub__</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Mapping" target="_blank" rel="noopener"><code>Mapping</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td>
<td style="text-align:left"><code>__getitem__</code>, <code>__iter__</code>, <code>__len__</code></td>
<td style="text-align:left"><code>__contains__</code>, <code>keys</code>, <code>items</code>, <code>values</code>, <code>get</code>, <code>__eq__</code>, and <code>__ne__</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableMapping" target="_blank" rel="noopener"><code>MutableMapping</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Mapping" target="_blank" rel="noopener"><code>Mapping</code></a></td>
<td style="text-align:left"><code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__iter__</code>, <code>__len__</code></td>
<td style="text-align:left">继承自 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Mapping" target="_blank" rel="noopener"><code>Mapping</code></a> 的方法以及 <code>pop</code>, <code>popitem</code>, <code>clear</code>, <code>update</code>，和 <code>setdefault</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MappingView" target="_blank" rel="noopener"><code>MappingView</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sized" target="_blank" rel="noopener"><code>Sized</code></a></td>
<td style="text-align:left"></td>
<td style="text-align:left"><code>__len__</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.ItemsView" target="_blank" rel="noopener"><code>ItemsView</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MappingView" target="_blank" rel="noopener"><code>MappingView</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a></td>
<td style="text-align:left"></td>
<td style="text-align:left"><code>__contains__</code>, <code>__iter__</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.KeysView" target="_blank" rel="noopener"><code>KeysView</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MappingView" target="_blank" rel="noopener"><code>MappingView</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a></td>
<td style="text-align:left"></td>
<td style="text-align:left"><code>__contains__</code>, <code>__iter__</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.ValuesView" target="_blank" rel="noopener"><code>ValuesView</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MappingView" target="_blank" rel="noopener"><code>MappingView</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td>
<td style="text-align:left"></td>
<td style="text-align:left"><code>__contains__</code>, <code>__iter__</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Awaitable" target="_blank" rel="noopener"><code>Awaitable</code></a></td>
<td style="text-align:left"></td>
<td style="text-align:left"><code>__await__</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Coroutine" target="_blank" rel="noopener"><code>Coroutine</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Awaitable" target="_blank" rel="noopener"><code>Awaitable</code></a></td>
<td style="text-align:left"><code>send</code>, <code>throw</code></td>
<td style="text-align:left"><code>close</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncIterable" target="_blank" rel="noopener"><code>AsyncIterable</code></a></td>
<td style="text-align:left"></td>
<td style="text-align:left"><code>__aiter__</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncIterator" target="_blank" rel="noopener"><code>AsyncIterator</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncIterable" target="_blank" rel="noopener"><code>AsyncIterable</code></a></td>
<td style="text-align:left"><code>__anext__</code></td>
<td style="text-align:left"><code>__aiter__</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncGenerator" target="_blank" rel="noopener"><code>AsyncGenerator</code></a></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncIterator" target="_blank" rel="noopener"><code>AsyncIterator</code></a></td>
<td style="text-align:left"><code>asend</code>, <code>athrow</code></td>
<td style="text-align:left"><code>aclose</code>, <code>__aiter__</code>, <code>__anext__</code></td>
</tr>
</tbody>
</table>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li><p><em>class</em> <code>collections.abc.Container</code></p>
</li>
<li><p><em>class</em> <code>collections.abc.Hashable</code></p>
</li>
<li><p><em>class</em> <code>collections.abc.Sized</code></p>
</li>
<li><p><em>class</em> <code>collections.abc.Callable</code></p>
<p>分别提供了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__contains__" target="_blank" rel="noopener"><code>__contains__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__len__" target="_blank" rel="noopener"><code>__len__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__call__" target="_blank" rel="noopener"><code>__call__()</code></a> 方法的抽象基类。</p>
</li>
<li><p><em>class</em> <code>collections.abc.Iterable</code></p>
<p>提供了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 方法的抽象基类。使用 <code>isinstance(obj, Iterable)</code> 可以检测一个类是否已经注册到了 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a> 或者实现了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 函数，但是无法检测这个类是否能够使用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法进行迭代。检测一个对象是否是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterable" target="_blank" rel="noopener">iterable</a> 的唯一可信赖的方法是调用 <code>iter(obj)</code>。</p>
</li>
<li><p><em>class</em> <code>collections.abc.Collection</code></p>
<p>集合了 Sized 和 Iterable 类的抽象基类。</p>
</li>
<li><p><em>class</em> <code>collections.abc.Iterator</code></p>
<p>提供了 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法的抽象基类。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a> 的定义。</p>
</li>
<li><p><em>class</em> <code>collections.abc.Reversible</code></p>
<p>为可迭代类提供了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__reversed__" target="_blank" rel="noopener"><code>__reversed__()</code></a> 方法的抽象基类。<em>3.6 新版功能.</em></p>
</li>
<li><p><em>class</em> <code>collections.abc.Generator</code></p>
<p>生成器类，实现了 <a href="https://www.python.org/dev/peps/pep-0342" target="_blank" rel="noopener"><strong>PEP 342</strong></a> 中定义的协议，继承并扩展了迭代器，提供了 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.send" target="_blank" rel="noopener"><code>send()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.throw" target="_blank" rel="noopener"><code>throw()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.close" target="_blank" rel="noopener"><code>close()</code></a> 方法。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 的定义。<em>3.5 新版功能.</em></p>
</li>
<li><p><em>class</em> <code>collections.abc.Sequence</code></p>
</li>
<li><p><em>class</em> <code>collections.abc.MutableSequence</code></p>
</li>
<li><p><em>class</em> <code>collections.abc.ByteString</code></p>
<p>只读且可变的序列 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-sequence" target="_blank" rel="noopener">sequences</a> 的抽象基类。实现笔记：一些混入（Maxin）方法比如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__reversed__" target="_blank" rel="noopener"><code>__reversed__()</code></a> 和 <code>index()</code> 会重复调用底层的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法。因此，如果实现的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 是常数级访问速度，那么相应的混入方法会有一个线性的表现；然而，如果底层方法是线性实现（例如链表），那么混入方法将会是平方级的表现，这也许就需要被重构了。<em>在 3.5 版更改:</em> index() 方法支持 <em>stop</em> 和 <em>start</em> 参数。</p>
</li>
<li><p><em>class</em> <code>collections.abc.Set</code></p>
</li>
<li><p><em>class</em> <code>collections.abc.MutableSet</code></p>
<p>只读且可变的集合的抽象基类。</p>
</li>
<li><p><em>class</em> <code>collections.abc.Mapping</code></p>
</li>
<li><p><em>class</em> <code>collections.abc.MutableMapping</code></p>
<p>只读且可变的映射 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-mapping" target="_blank" rel="noopener">mappings</a> 的抽象基类。</p>
</li>
<li><p><em>class</em> <code>collections.abc.MappingView</code></p>
</li>
<li><p><em>class</em> <code>collections.abc.ItemsView</code></p>
</li>
<li><p><em>class</em> <code>collections.abc.KeysView</code></p>
</li>
<li><p><em>class</em> <code>collections.abc.ValuesView</code></p>
<p>映射及其键和值的视图 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-dictionary-view" target="_blank" rel="noopener">views</a> 的抽象基类。</p>
</li>
<li><p><em>class</em> <code>collections.abc.Awaitable</code></p>
<p>为可等待对象 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a> 提供的类，可以被用于 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#await" target="_blank" rel="noopener"><code>await</code></a> 表达式中。习惯上必须实现 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 方法。协程对象 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">Coroutine</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Coroutine" target="_blank" rel="noopener"><code>Coroutine</code></a> 抽象基类的实例都是这个抽象基类的实例。</p>
</li>
<li><p><em>class</em> <code>collections.abc.Coroutine</code></p>
<p>用于协程兼容类的抽象基类。实现了如下定义在 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine-objects" target="_blank" rel="noopener">协程对象</a>: 里的方法： <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine.send" target="_blank" rel="noopener"><code>send()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine.throw" target="_blank" rel="noopener"><code>throw()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine.close" target="_blank" rel="noopener"><code>close()</code></a>。通常的实现里还需要实现 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 方法。所有的 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Coroutine" target="_blank" rel="noopener"><code>Coroutine</code></a> 实例都必须是 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Awaitable" target="_blank" rel="noopener"><code>Awaitable</code></a> 实例。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 的定义。注解 在 CPython 里，基于生成器的协程（使用 <a href="https://docs.python.org/zh-cn/3.8/library/types.html#types.coroutine" target="_blank" rel="noopener"><code>types.coroutine()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.coroutine" target="_blank" rel="noopener"><code>asyncio.coroutine()</code></a> 包装的生成器）都是 <em>可等待对象</em>，即使他们不含有 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 方法。使用 <code>isinstance(gencoro, Coroutine)</code> 来检测他们会返回 <code>False</code>。要使用 <a href="https://docs.python.org/zh-cn/3.8/library/inspect.html#inspect.isawaitable" target="_blank" rel="noopener"><code>inspect.isawaitable()</code></a> 来检测他们。</p>
</li>
<li><p><em>class</em> <code>collections.abc.AsyncIterable</code></p>
<p>提供了 <code>__aiter__</code> 方法的抽象基类。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterable" target="_blank" rel="noopener">asynchronous iterable</a> 的定义。<em>3.5 新版功能.</em></p>
</li>
<li><p><em>class</em> <code>collections.abc.AsyncIterator</code></p>
<p>提供了 <code>__aiter__</code> 和 <code>__anext__</code> 方法的抽象基类。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterator" target="_blank" rel="noopener">asynchronous iterator</a> 的定义。<em>3.5 新版功能.</em></p>
</li>
<li><p><em>class</em> <code>collections.abc.AsyncGenerator</code></p>
<p>为异步生成器类提供的抽象基类，这些类实现了定义在 <a href="https://www.python.org/dev/peps/pep-0525" target="_blank" rel="noopener"><strong>PEP 525</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 里的协议。</p>
<p>这些抽象基类让我们可以确定类和示例拥有某些特定的函数，例如： </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">size = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> isinstance(myvar, collections.abc.Sized):</span><br><span class="line">    size = len(myvar)</span><br></pre></td></tr></table></figure>
<p> 有些抽象基类也可以用作混入类（mixin），这可以更容易地开发支持容器 API 的类。例如，要写一个支持完整 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> API 的类，只需要提供下面这三个方法： <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__contains__" target="_blank" rel="noopener"><code>__contains__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__len__" target="_blank" rel="noopener"><code>__len__()</code></a>。抽象基类会补充上其余的方法，比如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__and__" target="_blank" rel="noopener"><code>__and__()</code></a> 和 <code>isdisjoint()</code>: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListBasedSet</span><span class="params">(collections.abc.Set)</span>:</span></span><br><span class="line">    <span class="string">''' Alternate set implementation favoring space over speed</span></span><br><span class="line"><span class="string">        and not requiring the set elements to be hashable. '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self.elements = lst = []</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line">            <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> lst:</span><br><span class="line">                lst.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.elements)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> value <span class="keyword">in</span> self.elements</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.elements)</span><br><span class="line"></span><br><span class="line">s1 = ListBasedSet(<span class="string">'abcdef'</span>)</span><br><span class="line">s2 = ListBasedSet(<span class="string">'defghi'</span>)</span><br><span class="line">overlap = s1 &amp; s2            <span class="comment"># The __and__() method is supported automatically</span></span><br></pre></td></tr></table></figure>
<p>当把 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableSet" target="_blank" rel="noopener"><code>MutableSet</code></a> 用作混入类时需注意：</p>
<ol>
<li>由于某些集合操作会创建新集合，默认的混入方法需要一种从可迭代对象里创建新实例的方法。假如其类构造函数签名形如 <code>ClassName(iterable)</code> ，则其会调用一个内部的类方法 <code>_from_iterable()</code>，其中调用了 <code>cls(iterable)</code> 来生成一个新集合。如果这个 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> 混入类在类中被使用，但其构造函数的签名却是不同的形式，那么你就需要重载 <code>_from_iterable()</code> 方法，将其编写成一个类方法，并且它能够从可迭代对象参数中构造一个新实例。</li>
<li>重载比较符时时（想必是为了速度，因为其语义都是固定的），只需要重定义 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__le__" target="_blank" rel="noopener"><code>__le__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__ge__" target="_blank" rel="noopener"><code>__ge__()</code></a> 函数，然后其他的操作会自动跟进。</li>
<li>混入集合类 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> 提供了一个 <code>_hash()</code> 方法为集合计算哈希值，然而， <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 函数却没有被定义，因为并不是所有集合都是可哈希并且不可变的。为了使用混入类为集合添加哈希能力，可以同时继承 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Hashable" target="_blank" rel="noopener"><code>Hashable()</code></a> 类，然后定义 <code>__hash__ = Set._hash</code>。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我看了官方文档的描述,一头雾水。下面就我个人理解谈谈这个模块。</p>
<p>abc模块应用的场景</p>
<h3 id="1-判定某个对象的类型"><a href="#1-判定某个对象的类型" class="headerlink" title="1. 判定某个对象的类型"></a>1. 判定某个对象的类型</h3><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200112_collection_abc1.png?raw=true" alt></p>
<h3 id="2-强制子类实现某些父类方法"><a href="#2-强制子类实现某些父类方法" class="headerlink" title="2. 强制子类实现某些父类方法"></a>2. 强制子类实现某些父类方法</h3><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200112_collection_abc1.png?raw=true" alt></p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200112_collection_abc2.png?raw=true" alt></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>collections.abc</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library array type</title>
    <url>/2020/01/13/python-standard-library-array-type/</url>
    <content><![CDATA[<p>每日一词: underdog</p>
<blockquote>
<p>英 [ˈʌndədɒg]   美 [ˈʌndərdɔg]</p>
<p>n.失败者； 退居下风的人； 受压迫者； 打败了的选手</p>
<p>复数： <a href="http://www.iciba.com/underdogs" target="_blank" rel="noopener">underdogs</a></p>
</blockquote>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200113underdogs.webp?raw=true" alt></p>
<blockquote>
<p> 这个词来自1887年出现，原指在斗狗比赛中战败的狗。后来词义引申至人，指的是各类竞赛和对碰中不被看好的一方，或是指处在逆境中的人和团体。</p>
<p>被看好的一方，即Topdog，从来不缺喝彩和支持。而Underdog的路则注定孤独许多。不被人看好，较少人支持。</p>
<p>所幸的是，正如倪匡先生感言：太多的时候，孤独最好。  </p>
<p>若能与孤独为师,又何须担心underdog呢？</p>
</blockquote>
<h2 id="python-标准库学习-array"><a href="#python-标准库学习-array" class="headerlink" title="python 标准库学习 array"></a>python 标准库学习 array</h2><p>此模块定义了一种对象类型，可以紧凑地表示基本类型值的数组：字符、整数、浮点数等。 数组属于序列类型，其行为与列表非常相似，不同之处在于其中存储的对象类型是受限的。 类型在对象创建时使用单个字符的 <em>类型码</em> 来指定。 已定义的类型码如下：</p>
<table>
<thead>
<tr>
<th>类型码</th>
<th>C 类型</th>
<th>Python 类型</th>
<th>以字节表示的最小尺寸</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&#39;b&#39;</code></td>
<td>signed char</td>
<td>int</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td><code>&#39;B&#39;</code></td>
<td>unsigned char</td>
<td>int</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td><code>&#39;u&#39;</code></td>
<td>Py_UNICODE</td>
<td>Unicode 字符</td>
<td>2</td>
<td>(1)</td>
</tr>
<tr>
<td><code>&#39;h&#39;</code></td>
<td>signed short</td>
<td>int</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td><code>&#39;H&#39;</code></td>
<td>unsigned short</td>
<td>int</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td><code>&#39;i&#39;</code></td>
<td>signed int</td>
<td>int</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td><code>&#39;I&#39;</code></td>
<td>无符号整型</td>
<td>int</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td><code>&#39;l&#39;</code></td>
<td>signed long</td>
<td>int</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td><code>&#39;L&#39;</code></td>
<td>无符号长整型</td>
<td>int</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td><code>&#39;q&#39;</code></td>
<td>signed long long</td>
<td>int</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td><code>&#39;Q&#39;</code></td>
<td>无符号 long long</td>
<td>int</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td><code>&#39;f&#39;</code></td>
<td>float</td>
<td>float</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td><code>&#39;d&#39;</code></td>
<td>double</td>
<td>float</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>==注释== </p>
<blockquote>
<p>‘u’类型码在<code>python3</code>已经被废除,默认python的字符串就是<code>unicode</code>字符</p>
</blockquote>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li><p><em>class</em> <code>array.array</code>(<em>typecode</em>[, <em>initializer</em>])</p>
<p>一个包含由 <em>typecode</em> 限制类型的条目的新数组，并由可选的 <em>initializer</em> 值进行初始化，该值必须为一个列表、<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 或包含正确类型元素的可迭代对象。如果给定一个列表或字符串，该 initializer 会被传给新数组的 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromlist" target="_blank" rel="noopener"><code>fromlist()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.frombytes" target="_blank" rel="noopener"><code>frombytes()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromunicode" target="_blank" rel="noopener"><code>fromunicode()</code></a> 方法（见下文）以将初始条目添加到数组中。 否则会将可迭代对象作为 initializer 传给 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.extend" target="_blank" rel="noopener"><code>extend()</code></a> 方法。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审核事件</a> <code>array.__new__</code> 附带参数 <code>typecode</code>, <code>initializer</code>。</p>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p><code>array.typecodes</code></p>
<p>包含所有可用类型码的字符串。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import array</span><br><span class="line">&gt;&gt;&gt; array.typecodes</span><br><span class="line">&apos;bBuhHiIlLqQfd&apos;</span><br></pre></td></tr></table></figure>
<p>数组对象支持普通的序列操作如索引、切片、拼接和重复等。 当使用切片赋值时，所赋的值必须为具有相同类型码的数组对象；所有其他情况都将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 数组对象也实现了缓冲区接口，可以用于所有支持 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 的场合。</p>
<a id="more"></a>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>以下数据项和方法也受到支持：</p>
<ul>
<li><p><code>array.typecode</code></p>
<p>用于创建数组的类型码字符。</p>
</li>
<li><p><code>array.itemsize</code></p>
<p>在内部表示中一个数组项的字节长度。</p>
</li>
<li><p><code>array.append</code>(<em>x</em>)</p>
<p>添加一个值为 <em>x</em> 的新项到数组末尾。</p>
</li>
<li><p><code>array.buffer_info</code>()</p>
<p>返回一个元组 <code>(address, length)</code> 以给出用于存放数组内容的缓冲区元素的当前内存地址和长度。 以字节表示的内存缓冲区大小可通过 <code>array.buffer_info()[1] * array.itemsize</code> 来计算。 这在使用需要内存地址的低层级（因此不够安全） I/O 接口时会很有用，例如某些 <code>ioctl()</code> 操作。 只要数组存在并且没有应用改变长度的操作，返回数值就是有效的。注解 当在 C 或 C++ 编写的代码中使用数组对象时（这是有效使用此类信息的唯一方式），使用数组对象所支持的缓冲区接口更为适宜。 此方法仅保留用作向下兼容，应避免在新代码中使用。 缓冲区接口的文档参见 <a href="https://docs.python.org/zh-cn/3.8/c-api/buffer.html#bufferobjects" target="_blank" rel="noopener">缓冲协议</a>。</p>
</li>
<li><p><code>array.byteswap</code>()</p>
<p>“字节对调”所有数组项。 此方法只支持大小为 1, 2, 4 或 8 字节的值；对于其他值类型将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 它适用于从不同字节序机器所生成的文件中读取数据的情况。</p>
</li>
<li><p><code>array.count</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 在数组中的出现次数。</p>
</li>
<li><p><code>array.extend</code>(<em>iterable</em>)</p>
<p>将来自 <em>iterable</em> 的项添加到数组末尾。 如果 <em>iterable</em> 是另一个数组，它必须具有 <em>完全</em> 相同的类型码；否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 如果 <em>iterable</em> 不是一个数组，则它必须为可迭代对象并且其元素必须为可添加到数组的适当类型。</p>
</li>
<li><p><code>array.frombytes</code>(<em>s</em>)</p>
<p>添加来自字符串的项，将字符串解读为机器值的数组（相当于使用 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromfile" target="_blank" rel="noopener"><code>fromfile()</code></a> 方法从文件中读取数据）。<em>3.2 新版功能:</em> <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromstring" target="_blank" rel="noopener"><code>fromstring()</code></a> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.frombytes" target="_blank" rel="noopener"><code>frombytes()</code></a> 以使其含义更清晰。</p>
</li>
<li><p><code>array.fromfile</code>(<em>f</em>, <em>n</em>)</p>
<p>从 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> <em>f</em> 中读取 <em>n</em> 项（解读为机器值）并将它们添加到数组末尾。 如果可读取数据少于 <em>n</em> 项则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EOFError" target="_blank" rel="noopener"><code>EOFError</code></a>，但有效的项仍然会被插入数组。 <em>f</em> 必须为一个真实的内置文件对象；不支持带有 <code>read()</code> 方法的其它对象。</p>
</li>
<li><p><code>array.fromlist</code>(<em>list</em>)</p>
<p>添加来自 list 的项。 这等价于 <code>for x in list: a.append(x)</code>，区别在于如果发生类型错误，数组将不会被改变。</p>
</li>
<li><p><code>array.fromstring</code>()</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.frombytes" target="_blank" rel="noopener"><code>frombytes()</code></a> 的已弃用别名。<em>Deprecated since version 3.2, will be removed in version 3.9.</em></p>
</li>
<li><p><code>array.fromunicode</code>(<em>s</em>)</p>
<p>使用来自给定 Unicode 字符串的数组扩展数组。 数组必须是类型为 <code>&#39;u&#39;</code> 的数组；否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。 请使用 <code>array.frombytes(unicodestring.encode(enc))</code> 来将 Unicode 数据添加到其他类型的数组。</p>
</li>
<li><p><code>array.index</code>(<em>x</em>)</p>
<p>返回最小的 <em>i</em> 使得 <em>i</em> 为 <em>x</em> 在数组中首次出现的序号。</p>
</li>
<li><p><code>array.insert</code>(<em>i</em>, <em>x</em>)</p>
<p>将值 <em>x</em> 作为新项插入数组的 <em>i</em> 位置之前。 负值将被视为相对于数组末尾的位置。</p>
</li>
<li><p><code>array.pop</code>([<em>i</em>])</p>
<p>从数组中移除序号为 <em>i</em> 的项并将其返回。 可选参数值默认为 <code>-1</code>，因此默认将移除并返回末尾项。</p>
</li>
<li><p><code>array.remove</code>(<em>x</em>)</p>
<p>从数组中移除首次出现的 <em>x</em>。</p>
</li>
<li><p><code>array.reverse</code>()</p>
<p>反转数组中各项的顺序。</p>
</li>
<li><p><code>array.tobytes</code>()</p>
<p>将数组转换为一个机器值数组并返回其字节表示（即相当与通过 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.tofile" target="_blank" rel="noopener"><code>tofile()</code></a> 方法写入到文件的字节序列。）<em>3.2 新版功能:</em> <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.tostring" target="_blank" rel="noopener"><code>tostring()</code></a> 被重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.tobytes" target="_blank" rel="noopener"><code>tobytes()</code></a> 以使其含义更清晰。</p>
</li>
<li><p><code>array.tofile</code>(<em>f</em>)</p>
<p>将所有项（作为机器值）写入到 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> <em>f</em>。</p>
</li>
<li><p><code>array.tolist</code>()</p>
<p>将数组转换为包含相同项的普通列表。</p>
</li>
<li><p><code>array.tostring</code>()</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.tobytes" target="_blank" rel="noopener"><code>tobytes()</code></a> 的已弃用别名。<em>Deprecated since version 3.2, will be removed in version 3.9.</em></p>
</li>
<li><p><code>array.tounicode</code>()</p>
<p>将数组转换为一个 Unicode 字符串。 数组必须是类型为 <code>&#39;u&#39;</code> 的数组；否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。 请使用 <code>array.tobytes().decode(enc)</code> 来从其他类型的数组生成 Unicode 字符串。</p>
</li>
</ul>
<p>当一个数组对象被打印或转换为字符串时，它会表示为 <code>array(typecode, initializer)</code>。 如果数组为空则 <em>initializer</em> 会被省略，否则如果 <em>typecode</em> 为 <code>&#39;u&#39;</code> 则它是一个字符串，否则它是一个数字列表。 使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 保证能将字符串转换回具有相同类型和值的数组，只要 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array" target="_blank" rel="noopener"><code>array</code></a> 类已通过 <code>from array import array</code> 被引入。 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line">array(<span class="string">'l'</span>)</span><br><span class="line">array(<span class="string">'u'</span>, <span class="string">'hello \u2641'</span>)</span><br><span class="line">array(<span class="string">'l'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">array(<span class="string">'d'</span>, [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.14</span>])</span><br></pre></td></tr></table></figure>
<p>更高效数组处理的可以详见 <a href="https://docs.scipy.org/doc/" target="_blank" rel="noopener">numpy</a> 库</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原来python标准库里就有专门操作array对象的方法,这里我理解array和list的区别在于,list里包含的元素可以是任意数据类型,处理数据的时候不是很方便,而array里的数据类型是一致的,这样处理数据效率更高。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library iterator and generator</title>
    <url>/2020/01/15/python-standard-library-iterator-and-generator/</url>
    <content><![CDATA[<h1 id="python-标准库-类型：-迭代器-和-生成器"><a href="#python-标准库-类型：-迭代器-和-生成器" class="headerlink" title="python 标准库 类型： 迭代器 和 生成器"></a>python 标准库 类型： 迭代器 和 生成器</h1><p>每日英语:</p>
<blockquote>
<p> miracle n </p>
<p> [英]   <strong>[</strong>ˈmɪrəkl<strong>]</strong>   [美] [ <strong>ˈmɪrəkəl</strong> ]</p>
<p> 奇迹，圣迹，神迹； 令人惊奇的人（或事） </p>
</blockquote>
<p>推荐一个老电影：</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200115_miracle.jpg?raw=true" alt></p>
<p>每个人终将都会踏上自己的绿色旅程,善恶就在一念之间。愿世界美好,温情以待。</p>
<p>先看一张图:</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200115_python_iterator_generator.jpg?raw=true" alt></p>
<blockquote>
<p>1，迭代器协议：对象需要提供next()方法，它要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代。</p>
<p>2，可迭代对象：实现了迭代器协议对象。list、tuple、dict都是Iterable（可迭代对象），但不是Iterator（迭代器对象）。但可以使用内建函数iter()，把这些都变成Iterable（可迭代器对象）。</p>
<p>3，for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束</p>
</blockquote>
<a id="more"></a>
<h2 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h2><p>Python 支持在容器中进行迭代的概念。 这是通过使用两个单独方法来实现的；它们被用于允许用户自定义类对迭代的支持。 将在下文中详细描述的序列总是支持迭代方法。</p>
<p>容器对象要提供迭代支持，必须定义一个方法:</p>
<ul>
<li><p><code>container.__iter__</code>()</p>
<p>返回一个迭代器对象。 该对象需要支持下文所述的迭代器协议。 如果容器支持不同的迭代类型，则可以提供额外的方法来专门地请求不同迭代类型的迭代器。 （支持多种迭代形式的对象的例子有同时支持广度优先和深度优先遍历的树结构。） 此方法对应于 Python/C API 中 Python 对象类型结构体的 <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_iter" target="_blank" rel="noopener"><code>tp_iter</code></a> 槽位。</p>
</li>
</ul>
<p>迭代器对象自身需要支持以下两个方法，它们共同组成了 <em>迭代器协议</em>:</p>
<ul>
<li><p><code>iterator.__iter__</code>()</p>
<p>返回迭代器对象本身。 这是同时允许容器和迭代器配合 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a> 语句使用所必须的。 此方法对应于 Python/C API 中 Python 对象类型结构体的 <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_iter" target="_blank" rel="noopener"><code>tp_iter</code></a> 槽位。</p>
</li>
<li><p><code>iterator.__next__</code>()</p>
<p>从容器中返回下一项。 如果已经没有项可返回，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 异常。 此方法对应于 Python/C API 中 Python 对象类型结构体的 <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_iternext" target="_blank" rel="noopener"><code>tp_iternext</code></a> 槽位。</p>
</li>
</ul>
<p>Python 定义了几种迭代器对象以支持对一般和特定序列类型、字典和其他更特别的形式进行迭代。 除了迭代器协议的实现，特定类型的其他性质对迭代操作来说都不重要。</p>
<p>一旦迭代器的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法引发了 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a>，它必须一直对后续调用引发同样的异常。 不遵循此行为特性的实现将无法正常使用。</p>
<p>迭代器使用实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随便定义一个list</span></span><br><span class="line">listArray=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 使用iter()函数</span></span><br><span class="line">iterName=iter(listArray)</span><br><span class="line">print(iterName)</span><br><span class="line"><span class="comment"># 结果如下：是一个列表list的迭代器</span></span><br><span class="line"><span class="comment"># &lt;list_iterator object at 0x0000017B0D984278&gt;</span></span><br><span class="line"></span><br><span class="line">print(next(iterName))</span><br><span class="line">print(next(iterName))</span><br><span class="line">print(next(iterName))</span><br><span class="line">print(next(iterName))<span class="comment">#没有迭代到下一个元素，直接抛出异常</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File "python_iterator.py", line 32, in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure>
<p>自定义迭代器实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span></span><br><span class="line">        super(Fib, self).__init__()</span><br><span class="line">        self.max = max</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fib = self.a</span><br><span class="line">        <span class="keyword">if</span> fib &gt; self.max:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">return</span> fib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个main函数，循环遍历每一个菲波那切数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 20以内的数</span></span><br><span class="line">    fib = Fib(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fib:</span><br><span class="line">        print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="生成器类型"><a href="#生成器类型" class="headerlink" title="生成器类型"></a>生成器类型</h3><p>Python 的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 提供了一种实现迭代器协议的便捷方式。 如果容器对象 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 方法被实现为一个生成器，它将自动返回一个迭代器对象（从技术上说是一个生成器对象），该对象提供 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法。 有关生成器的更多信息可以参阅 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#yieldexpr" target="_blank" rel="noopener">yield 表达式的文档</a>。</p>
<h4 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 菲波那切数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'亲！没有数据了...'</span></span><br><span class="line"><span class="comment"># 调用方法，生成出10个数来</span></span><br><span class="line">f=Fib(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 使用一个循环捕获最后return 返回的值，保存在异常StopIteration的value中</span></span><br><span class="line"><span class="keyword">while</span>  <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x=next(f)</span><br><span class="line">        print(<span class="string">"f:"</span>,x)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"生成器最后的返回值是："</span>,e.value)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h4 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个列表</span></span><br><span class="line">xiaoke=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 生成器generator，类似于list，但是是把[]改为()</span></span><br><span class="line">gen=(a <span class="keyword">for</span> a  <span class="keyword">in</span> xiaoke)</span><br><span class="line"><span class="keyword">for</span>  i  <span class="keyword">in</span> gen:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment">#结果是：</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么要使用生成器？因为效率。</span></span><br><span class="line"><span class="comment"># 使用生成器表达式取代列表推导式可以同时节省 cpu 和 内存(RAM)。</span></span><br><span class="line"><span class="comment"># 如果你构造一个列表(list)的目的仅仅是传递给别的函数,</span></span><br><span class="line"><span class="comment"># 比如 传递给tuple()或者set(), 那就用生成器表达式替代吧!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本案例是直接把列表转化为元组</span></span><br><span class="line">kk=tuple(a <span class="keyword">for</span> a <span class="keyword">in</span> xiaoke)</span><br><span class="line">print(kk)</span><br><span class="line"><span class="comment">#结果是：</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python内置的一些函数，可以识别这是生成器表达式，外面有一对小括号，就是生成器</span></span><br><span class="line">result1=sum(a <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line">print(result1)</span><br><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">result2=sum([a <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">3</span>)])</span><br><span class="line">print(result2)</span><br></pre></td></tr></table></figure>
<h4 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h4><p>使用yield关键字实现生成器函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span>  </span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">while</span> a &lt; max:  </span><br><span class="line">        <span class="keyword">yield</span> a <span class="comment">#这时a,b值分别为1,1，当然，程序也在执行到这时，返回  </span></span><br><span class="line">        a, b = b, a+b</span><br></pre></td></tr></table></figure>
<p>使用yield关键字实现自定义生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span>  </span><br><span class="line">        self.max = max  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.a = <span class="number">0</span>  </span><br><span class="line">        self.b = <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">return</span> self  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        fib = self.a  </span><br><span class="line">        <span class="keyword">if</span> fib &gt; self.max:  </span><br><span class="line">            <span class="keyword">raise</span> StopIteration  </span><br><span class="line">        self.a, self.b = self.b, self.a + self.b  </span><br><span class="line">        <span class="keyword">return</span> fib  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> Fib(<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">print</span> f</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>iterator</tag>
        <tag>generator</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library calendar</title>
    <url>/2020/01/16/python-standard-library-calendar/</url>
    <content><![CDATA[<h1 id="python-标准库-calendar"><a href="#python-标准库-calendar" class="headerlink" title="python 标准库 calendar"></a>python 标准库 calendar</h1><p>每日一词:</p>
<blockquote>
<p>calendar</p>
<p> <strong>英</strong> [ˈkælɪndə(r)]    <strong>美</strong> [ˈkælɪndər] </p>
<ul>
<li>n. 日历；[天] 历法；日程表</li>
<li>vt. 将…列入表中；将…排入日程表</li>
</ul>
<p>短语</p>
<p><strong><a href="http://dict.youdao.com/w/eng/chinese_calendar/#keyfrom=dict.phrase.wordgroup" target="_blank" rel="noopener">chinese calendar</a></strong> 中国传统历法 ; 阴历 ; 中国农历</p>
<p><strong><a href="http://dict.youdao.com/w/eng/lunar_calendar/#keyfrom=dict.phrase.wordgroup" target="_blank" rel="noopener">lunar calendar</a></strong> 阴历 ; 夏历 ; 来自日月星辰的力量 ; 太阴历</p>
<p><strong><a href="http://dict.youdao.com/w/eng/solar_calendar/#keyfrom=dict.phrase.wordgroup" target="_blank" rel="noopener">solar calendar</a></strong> 太阳历 ; 公历 ; 阳历与阴历</p>
</blockquote>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200116_canlendar_3.png?raw=true" alt></p>
<p>还有几天就过年了,2020年充满了期待,你呢？</p>
<p>今天我们学习python 标准库 calendar 。</p>
<blockquote>
<p>输出像 Unix <strong>cal</strong> 那样的日历，它还提供了其它与日历相关的实用函数。 默认情况下，这些日历把星期一当作一周的第一天，星期天为一周的最后一天（按照欧洲惯例）。 可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.setfirstweekday" target="_blank" rel="noopener"><code>setfirstweekday()</code></a> 方法设置一周的第一天为星期天 (6) 或者其它任意一天。 使用整数作为指定日期的参数。 更多相关的函数，参见 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#module-datetime" target="_blank" rel="noopener"><code>datetime</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块。 </p>
</blockquote>
<p> 在这个模块中定义的函数和类都基于一个理想化的日历，现行公历向过去和未来两个方向无限扩展。这与 Dershowitz 和 Reingold 的书 “历法计算” 中所有计算的基本日历 – “proleptic Gregorian” 日历的定义相符合。 ISO 8601标准还规定了 0 和 负数年份。0年指公元前1年， -1年指公元前2年，依此类推 .</p>
<a id="more"></a>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p> <strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/calendar.py" target="_blank" rel="noopener">Lib/calendar.py</a> </p>
<p>主要类和方法,节选自源码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [<span class="string">"IllegalMonthError"</span>, <span class="string">"IllegalWeekdayError"</span>, <span class="string">"setfirstweekday"</span>,</span><br><span class="line">           <span class="string">"firstweekday"</span>, <span class="string">"isleap"</span>, <span class="string">"leapdays"</span>, <span class="string">"weekday"</span>, <span class="string">"monthrange"</span>,</span><br><span class="line">           <span class="string">"monthcalendar"</span>, <span class="string">"prmonth"</span>, <span class="string">"month"</span>, <span class="string">"prcal"</span>, <span class="string">"calendar"</span>,</span><br><span class="line">           <span class="string">"timegm"</span>, <span class="string">"month_name"</span>, <span class="string">"month_abbr"</span>, <span class="string">"day_name"</span>, <span class="string">"day_abbr"</span>,</span><br><span class="line">           <span class="string">"Calendar"</span>, <span class="string">"TextCalendar"</span>, <span class="string">"HTMLCalendar"</span>, <span class="string">"LocaleTextCalendar"</span>,</span><br><span class="line">           <span class="string">"LocaleHTMLCalendar"</span>, <span class="string">"weekheader"</span>]</span><br></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="class-calendar-Calendar-firstweekday-0-¶"><a href="#class-calendar-Calendar-firstweekday-0-¶" class="headerlink" title="class calendar.Calendar(firstweekday=0)¶"></a><em>class</em> <code>calendar.Calendar</code>(<em>firstweekday=0</em>)<a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar" target="_blank" rel="noopener">¶</a></h3><p>创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar" target="_blank" rel="noopener"><code>Calendar</code></a> 对象。 <em>firstweekday</em> 是一个整数，用于指定一周的第一天。 <code>0</code> 是星期一（默认值），<code>6</code> 是星期天。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar" target="_blank" rel="noopener"><code>Calendar</code></a> 对象提供了一些可被用于准备日历数据格式化的方法。 这个类本身不执行任何格式化操作。 这部分任务应由子类来完成。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar" target="_blank" rel="noopener"><code>Calendar</code></a> 类的实例有下列方法：</p>
<ul>
<li><p><code>iterweekdays</code>()</p>
<p>返回一个迭代器，迭代器的内容为一星期的数字。迭代器的第一个值与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.firstweekday" target="_blank" rel="noopener"><code>firstweekday</code></a> 属性的值一至。</p>
</li>
<li><p><code>itermonthdates</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个迭代器，迭代器的内容为 <em>year</em> 年 <em>month</em> 月(1-12)的日期。这个迭代器返回当月的所有日期 ( <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 对象)，日期包含了本月头尾用于组成完整一周的日期。</p>
</li>
<li><p><code>itermonthdays</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个迭代器，迭代器的内容与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.itermonthdates" target="_blank" rel="noopener"><code>itermonthdates()</code></a> 类似，为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 范围限制。返回的日期为当月每一天的日期对应的天数。对于不在当月的日期，显示为 <code>0</code>。</p>
</li>
<li><p><code>itermonthdays2</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个迭代器，迭代器的内容与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.itermonthdates" target="_blank" rel="noopener"><code>itermonthdates()</code></a> 类似为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 范围的限制。迭代器中的元素为一个由日期和代表星期几的数字组成的的元组。</p>
</li>
<li><p><code>itermonthdays3</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个迭代器，迭代器的内容与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.itermonthdates" target="_blank" rel="noopener"><code>itermonthdates()</code></a> 类似为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 范围的限制。迭代器的元素为一个由年，月，日组成的元组。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>itermonthdays4</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个迭代器，迭代器的内容与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.itermonthdates" target="_blank" rel="noopener"><code>itermonthdates()</code></a> 类似为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 范围的限制。迭代器的元素为一个由年，月，日和代表星期几的数字组成的元组。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>monthdatescalendar</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个表示指定年月的周列表。周列表由七个 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 对象组成。</p>
</li>
<li><p><code>monthdays2calendar</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个表示指定年月的周列表。周列表由七个代表日期的数字和代表周几的数字组成的二元元组。</p>
</li>
<li><p><code>monthdayscalendar</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个表示指定年月的周列表。周列表由七个代表日期的数字组成。</p>
</li>
<li><p><code>yeardatescalendar</code>(<em>year</em>, <em>width=3</em>)</p>
<p>返回可以用来格式化的指定年月的数据。返回的值是一个列表，列表是月份组成的行。每一行包含了最多 <em>width</em> 个月(默认为3)。每个月包含了4到6周，每周包含1–7天。每一天使用 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 对象。</p>
</li>
<li><p><code>yeardays2calendar</code>(<em>year</em>, <em>width=3</em>)</p>
<p>返回可以用来模式化的指定年月的数据(与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.yeardatescalendar" target="_blank" rel="noopener"><code>yeardatescalendar()</code></a> 类似)。周列表的元素是由表示日期的数字和表示星期几的数字组成的元组。不在这个月的日子为0。</p>
</li>
<li><p><code>yeardayscalendar</code>(<em>year</em>, <em>width=3</em>)</p>
<p>返回可以用来模式化的指定年月的数据(与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.yeardatescalendar" target="_blank" rel="noopener"><code>yeardatescalendar()</code></a> 类似)。周列表的元素是表示日期的数字。不在这个月的日子为0。</p>
</li>
</ul>
<h3 id="class-calendar-TextCalendar-firstweekday-0"><a href="#class-calendar-TextCalendar-firstweekday-0" class="headerlink" title="class calendar.TextCalendar(firstweekday=0)"></a><em>class</em> <code>calendar.TextCalendar</code>(<em>firstweekday=0</em>)</h3><p>可以使用这个类生成纯文本日历。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar" target="_blank" rel="noopener"><code>TextCalendar</code></a> 实例有以下方法：</p>
<ul>
<li><p><code>formatmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p>
<p>返回一个多行字符串来表示指定年月的日历。<em>w</em> 为日期的宽度，但始终保持日期居中。<em>l</em> 指定了每星期占用的行数。以上这些还依赖于构造器或者 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.setfirstweekday" target="_blank" rel="noopener"><code>setfirstweekday()</code></a> 方法指定的周的第一天是哪一天。</p>
</li>
<li><p><code>prmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p>
<p>与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar.formatmonth" target="_blank" rel="noopener"><code>formatmonth()</code></a> 方法一样，返回一个月的日历。</p>
</li>
<li><p><code>formatyear</code>(<em>theyear</em>, <em>w=2</em>, <em>l=1</em>, <em>c=6</em>, <em>m=3</em>)</p>
<p>返回一个多行字符串，这个字符串为一个 <em>m</em> 列日历。可选参数 <em>w</em>, <em>l</em>, 和 <em>c</em> 分别表示日期列数， 周的行数， 和月之间的间隔。同样，以上这些还依赖于构造器或者 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.setfirstweekday" target="_blank" rel="noopener"><code>setfirstweekday()</code></a> 指定哪一天为一周的第一天。日历的第一年由平台依赖于使用的平台。</p>
</li>
<li><p><code>pryear</code>(<em>theyear</em>, <em>w=2</em>, <em>l=1</em>, <em>c=6</em>, <em>m=3</em>)</p>
<p>与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar.formatyear" target="_blank" rel="noopener"><code>formatyear()</code></a> 方法一样，返回一整年的日历。</p>
</li>
</ul>
<h3 id="class-calendar-HTMLCalendar-firstweekday-0"><a href="#class-calendar-HTMLCalendar-firstweekday-0" class="headerlink" title="class calendar.HTMLCalendar(firstweekday=0)"></a><em>class</em> <code>calendar.HTMLCalendar</code>(<em>firstweekday=0</em>)</h3><p>可以使用这个类生成 HTML 日历。<code>HTMLCalendar</code> 实例有以下方法：<code>formatmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>withyear=True</em>)返回一个 HTML 表格作为指定年月的日历。 <em>withyear</em> 为真，则年份将会包含在表头，否则只显示月份。<code>formatyear</code>(<em>theyear</em>, <em>width=3</em>)返回一个 HTML 表格作为指定年份的日历。 <em>width</em> (默认为3) 用于规定每一行显示月份的数量。<code>formatyearpage</code>(<em>theyear</em>, <em>width=3</em>, <em>css=’calendar.css’</em>, <em>encoding=None</em>)返回一个完整的 HTML 页面作为指定年份的日历。 <em>width\</em>(默认为3) 用于规定每一行显示的月份数量。 *css<em> 为层叠样式表的名字。如果不使用任何层叠样式表，可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 。 </em>encoding* 为输出页面的编码 (默认为系统的默认编码)。<code>HTMLCalendar</code> 有以下属性，你可以重载它们来自定义应用日历的样式。</p>
<ul>
<li><strong><code>cssclasses</code></strong>一个对应星期一到星期天的 CSS class 列表。默认列表为</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cssclasses = [<span class="string">"mon"</span>, <span class="string">"tue"</span>, <span class="string">"wed"</span>, <span class="string">"thu"</span>, <span class="string">"fri"</span>, <span class="string">"sat"</span>, <span class="string">"sun"</span>]</span><br></pre></td></tr></table></figure>
<p> 可以向每天加入其它样式 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cssclasses = [<span class="string">"mon text-bold"</span>, <span class="string">"tue"</span>, <span class="string">"wed"</span>, <span class="string">"thu"</span>, <span class="string">"fri"</span>, <span class="string">"sat"</span>, <span class="string">"sun red"</span>]</span><br></pre></td></tr></table></figure>
<p> 需要注意的是，列表的长度必须为7。 </p>
<ul>
<li><p><strong>cssclass_noday</strong> </p>
<p>工作日的 CSS 类在上个月或下个月发生。 </p>
</li>
<li><p><code>cssclasses_weekday_head</code></p>
<p>用于标题行中的工作日名称的 CSS 类 列表。默认值与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.HTMLCalendar.cssclasses" target="_blank" rel="noopener"><code>cssclasses</code></a> 相同。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>cssclass_month_head</code></p>
<p>月份的头 CSS 类（由 <code>formatmonthname()</code> 使用）。默认值为 <code>&quot;month&quot;</code> 。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>cssclass_month</code></p>
<p>某个月的月历的 CSS 类（由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.HTMLCalendar.formatmonth" target="_blank" rel="noopener"><code>formatmonth()</code></a> 使用）。默认值为 <code>&quot;month&quot;</code> 。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>cssclass_year</code></p>
<p>某年的年历的 CSS 类（由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.HTMLCalendar.formatyear" target="_blank" rel="noopener"><code>formatyear()</code></a> 使用）。默认值为 <code>&quot;year&quot;</code> 。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>cssclass_year_head</code></p>
<p>年历的·表头 CSS 类（由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.HTMLCalendar.formatyear" target="_blank" rel="noopener"><code>formatyear()</code></a> 使用）。默认值为 <code>&quot;year&quot;</code> 。<em>3.7 新版功能.</em></p>
</li>
</ul>
<p>需要注意的是，尽管上面命名的样式类都是单独出现的(如： <code>cssclass_month</code> <code>cssclass_noday</code>), 但我们可以使用空格将样式类列表中的多个元素分隔开，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"text-bold text-red"</span></span><br></pre></td></tr></table></figure>
<p> 下面是一个如何自定义 <code>HTMLCalendar</code> 的示例 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLCal</span><span class="params">(calendar.HTMLCalendar)</span>:</span></span><br><span class="line">    cssclasses = [style + <span class="string">" text-nowrap"</span> <span class="keyword">for</span> style <span class="keyword">in</span></span><br><span class="line">                  calendar.HTMLCalendar.cssclasses]</span><br><span class="line">    cssclass_month_head = <span class="string">"text-center month-head"</span></span><br><span class="line">    cssclass_month = <span class="string">"text-center month"</span></span><br><span class="line">    cssclass_year = <span class="string">"text-italic lead"</span></span><br></pre></td></tr></table></figure>
<h3 id="class-calendar-LocaleTextCalendar-firstweekday-0-locale-None"><a href="#class-calendar-LocaleTextCalendar-firstweekday-0-locale-None" class="headerlink" title="class calendar.LocaleTextCalendar(firstweekday=0, locale=None)"></a><em>class</em> <code>calendar.LocaleTextCalendar</code>(<em>firstweekday=0</em>, <em>locale=None</em>)</h3><p>这个子类 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar" target="_blank" rel="noopener"><code>TextCalendar</code></a> 可以在构造函数中传递一个语言环境名称，并且返回月份和星期几的名称在特定语言环境中。如果此语言环境包含编码，则包含月份和工作日名称的所有字符串将作为 unicode 返回。</p>
<h3 id="class-calendar-LocaleHTMLCalendar-firstweekday-0-locale-None"><a href="#class-calendar-LocaleHTMLCalendar-firstweekday-0-locale-None" class="headerlink" title="class calendar.LocaleHTMLCalendar(firstweekday=0, locale=None)"></a><em>class</em> <code>calendar.LocaleHTMLCalendar</code>(<em>firstweekday=0</em>, <em>locale=None</em>)</h3><ul>
<li><p><code>calendar.setfirstweekday</code>(<em>weekday</em>)</p>
<p>设置每一周的开始(<code>0</code> 表示星期一，<code>6</code> 表示星期天)。calendar还提供了 <code>MONDAY</code>, <code>TUESDAY</code>, <code>WEDNESDAY</code>, <code>THURSDAY</code>, <code>FRIDAY</code>, <code>SATURDAY</code> 和 <code>SUNDAY</code> 几个常量方便使用。例如，设置每周的第一天为星期天</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line">calendar.setfirstweekday(calendar.SUNDAY)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>calendar.firstweekday</code>()</p>
<p>返回当前设置的每星期的第一天的数值。</p>
</li>
<li><p><code>calendar.isleap</code>(<em>year</em>)</p>
<p>如果 <em>year</em> 是闰年则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a> ,否则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>。</p>
</li>
<li><p><code>calendar.leapdays</code>(<em>y1</em>, <em>y2</em>)</p>
<p>返回在范围 <em>y1</em> 至 <em>y2</em> （包含 y1 和 y2 ）之间的闰年的年数，其中 <em>y1</em> 和 <em>y2</em> 是年份。此函数适用于跨越一个世纪变化的范围。</p>
</li>
<li><p><code>calendar.weekday</code>(<em>year</em>, <em>month</em>, <em>day</em>)</p>
<p>返回某年（ <code>1970</code> – …），某月（ <code>1</code> – <code>12</code> ），某日（ <code>1</code> – <code>31</code> ）是星期几（ <code>0</code> 是星期一）。</p>
</li>
<li><p><code>calendar.weekheader</code>(<em>n</em>)</p>
<p>返回一个包含星期几的缩写名的头。 <em>n</em> 指定星期几缩写的字符宽度。</p>
</li>
<li><p><code>calendar.monthrange</code>(<em>year</em>, <em>month</em>)</p>
<p>返回指定 <em>年份</em> 的指定 <em>月份</em> 的第一天是星期几和这个月的天数。</p>
</li>
<li><p><code>calendar.monthcalendar</code>(<em>year</em>, <em>month</em>)</p>
<p>返回表示一个月的日历的矩阵。每一行代表一周；此月份外的日子由零表示。除非由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.setfirstweekday" target="_blank" rel="noopener"><code>setfirstweekday()</code></a> 设置，否则每周以周一为始。</p>
</li>
<li><p><code>calendar.prmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p>
<p>打印由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.month" target="_blank" rel="noopener"><code>month()</code></a> 返回的一个月的日历。</p>
</li>
<li><p><code>calendar.month</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p>
<p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar" target="_blank" rel="noopener"><code>TextCalendar</code></a> 类的 <code>formatmonth()</code> 以多行字符串形式返回月份日历。</p>
</li>
<li><p><code>calendar.prcal</code>(<em>year</em>, <em>w=0</em>, <em>l=0</em>, <em>c=6</em>, <em>m=3</em>)</p>
<p>打印由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#module-calendar" target="_blank" rel="noopener"><code>calendar()</code></a> 返回的整年的日历。</p>
</li>
<li><p><code>calendar.calendar</code>(<em>year</em>, <em>w=2</em>, <em>l=1</em>, <em>c=6</em>, <em>m=3</em>)</p>
<p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar" target="_blank" rel="noopener"><code>TextCalendar</code></a> 类的 <code>formatyear()</code> 返回整年的3列的日历以多行字符串的形式。</p>
</li>
<li><p><code>calendar.timegm</code>(<em>tuple</em>)</p>
<p>一个不相关但很好用的函数，它接受一个时间元组例如 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块中的 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#time.gmtime" target="_blank" rel="noopener"><code>gmtime()</code></a> 函数的返回并返回相应的 Unix 时间戳值，假定 1970 年开始计数， POSIX 编码。实际上， <a href="https://docs.python.org/zh-cn/3.8/library/time.html#time.gmtime" target="_blank" rel="noopener"><code>time.gmtime()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.timegm" target="_blank" rel="noopener"><code>timegm()</code></a> 是彼此相反的。</p>
</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li><p><code>calendar.day_name</code></p>
<p>在当前语言环境下表示星期几的数组。</p>
</li>
<li><p><code>calendar.day_abbr</code></p>
<p>在当前语言环境下表示星期几缩写的数组。</p>
</li>
<li><p><code>calendar.month_name</code></p>
<p>在当前语言环境下表示一年中月份的数组。这遵循一月的月号为 1 的通常惯例，所以它的长度为 13 且 <code>month_name[0]</code> 是空字符串。</p>
</li>
<li><p><code>calendar.month_abbr</code></p>
<p>在当前语言环境下表示月份简写的数组。这遵循一月的月号为 1 的通常惯例，所以它的长度为 13 且 <code>month_abbr[0]</code> 是空字符串。</p>
</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200116_canlendar_4.png?raw=true" alt></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> 默认情况下，这些日历将星期一作为一周的第一天，将星期日作为一周的最后一天(欧洲惯例)。不过，我们可以使用<code>setfirstweekday()</code>方法来设置一周的第一天为星期日或h者其他工作日，指定的日期以整数形式给出。 </p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>calendar</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard libary heapq</title>
    <url>/2020/01/17/python-standard-library-heapq/</url>
    <content><![CDATA[<h2 id="python-标准库-堆队列算法-heapq"><a href="#python-标准库-堆队列算法-heapq" class="headerlink" title="python 标准库  堆队列算法 heapq"></a>python 标准库  堆队列算法 heapq</h2><p>每日一词:</p>
<blockquote>
<p>Pollen </p>
<p>n 花粉</p>
<p>例句:</p>
<p>Good news for all you hay fever and asthma sufferers<br>对于花粉症和哮喘病患者是个好消息</p>
</blockquote>
<p>今天是小年,祝大家心想事成</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200117_happiness.jpg?raw=true" alt></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><strong>源码：</strong><a href="https://github.com/python/cpython/tree/3.8/Lib/heapq.py" target="_blank" rel="noopener">Lib/heapq.py</a></p>
<p>主要模块和方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [<span class="string">'heappush'</span>, <span class="string">'heappop'</span>, <span class="string">'heapify'</span>, <span class="string">'heapreplace'</span>, <span class="string">'merge'</span>,</span><br><span class="line">           <span class="string">'nlargest'</span>, <span class="string">'nsmallest'</span>, <span class="string">'heappushpop'</span>]</span><br></pre></td></tr></table></figure>
<p>这个模块提供了堆队列算法的实现，也称为优先队列算法。</p>
<p>堆是一个二叉树，它的每个父节点的值都只会小于或大于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的 <em>k</em> ，都有 <code>heap[k] &lt;= heap[2*k+1]</code> 和 <code>heap[k] &lt;= heap[2*k+2]</code>。 为了便于比较，不存在的元素被认为是无限大。 堆最有趣的特性在于最小的元素总是在根结点：<code>heap[0]</code>。</p>
<a id="more"></a>
<p>这个API与教材的堆算法实现有所不同，具体区别有两方面：（a）我们使用了从零开始的索引。这使得节点和其孩子节点索引之间的关系不太直观但更加适合，因为 Python 使用从零开始的索引。 （b）我们的 pop 方法返回最小的项而不是最大的项（这在教材中称为“最小堆”；而“最大堆”在教材中更为常见，因为它更适用于原地排序）。</p>
<p>基于这两方面，把堆看作原生的Python list也没什么奇怪的： <code>heap[0]</code> 表示最小的元素，同时 <code>heap.sort()</code> 维护了堆的不变性！</p>
<p>要创建一个堆，可以使用list来初始化为 <code>[]</code> ，或者你可以通过一个函数 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heapify" target="_blank" rel="noopener"><code>heapify()</code></a> ，来把一个list转换成堆。</p>
<p>定义了以下函数：</p>
<ul>
<li><p><code>heapq.heappush</code>(<em>heap</em>, <em>item</em>)</p>
<p>将 <em>item</em> 的值加入 <em>heap</em> 中，保持堆的不变性。</p>
</li>
<li><p><code>heapq.heappop</code>(<em>heap</em>)</p>
<p>弹出并返回 <em>heap</em> 的最小的元素，保持堆的不变性。如果堆为空，抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 。使用 <code>heap[0]</code> ，可以只访问最小的元素而不弹出它。</p>
</li>
<li><p><code>heapq.heappushpop</code>(<em>heap</em>, <em>item</em>)</p>
<p>将 <em>item</em> 放入堆中，然后弹出并返回 <em>heap</em> 的最小元素。该组合操作比先调用  <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappush" target="_blank" rel="noopener"><code>heappush()</code></a> 再调用 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappop" target="_blank" rel="noopener"><code>heappop()</code></a> 运行起来更有效率。</p>
</li>
<li><p><code>heapq.heapify</code>(<em>x</em>)</p>
<p>将list <em>x</em> 转换成堆，原地，线性时间内。</p>
</li>
<li><p><code>heapq.heapreplace</code>(<em>heap</em>, <em>item</em>)</p>
<p>弹出并返回 <em>heap</em> 中最小的一项，同时推入新的 <em>item</em>。 堆的大小不变。 如果堆为空则引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a>。这个单步骤操作比 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappop" target="_blank" rel="noopener"><code>heappop()</code></a> 加 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappush" target="_blank" rel="noopener"><code>heappush()</code></a> 更高效，并且在使用固定大小的堆时更为适宜。 pop/push 组合总是会从堆中返回一个元素并将其替换为 <em>item</em>。返回的值可能会比添加的 <em>item</em> 更大。 如果不希望如此，可考虑改用 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappushpop" target="_blank" rel="noopener"><code>heappushpop()</code></a>。 它的 push/pop 组合会返回两个值中较小的一个，将较大的值留在堆中。</p>
</li>
</ul>
<p>该模块还提供了三个基于堆的通用功能函数。</p>
<ul>
<li><p><code>heapq.merge</code>(*<em>iterables</em>, <em>key=None</em>, <em>reverse=False</em>)</p>
<p>将多个已排序的输入合并为一个已排序的输出（例如，合并来自多个日志文件的带时间戳的条目）。 返回已排序值的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a>。类似于 <code>sorted(itertools.chain(*iterables))</code> 但返回一个可迭代对象，不会一次性地将数据全部放入内存，并假定每个输入流都是已排序的（从小到大）。具有两个可选参数，它们都必须指定为关键字参数。<em>key</em> 指定带有单个参数的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-key-function" target="_blank" rel="noopener">key function</a>，用于从每个输入元素中提取比较键。 默认值为 <code>None</code> (直接比较元素)。<em>reverse</em> 为一个布尔值。 如果设为 <code>True</code>，则输入元素将按比较结果逆序进行合并。 要达成与 <code>sorted(itertools.chain(*iterables), reverse=True)</code> 类似的行为，所有可迭代对象必须是已从大到小排序的。<em>在 3.5 版更改:</em> 添加了可选的 <em>key</em> 和 <em>reverse</em> 形参。</p>
</li>
<li><p><code>heapq.nlargest</code>(<em>n</em>, <em>iterable</em>, <em>key=None</em>)</p>
<p>从 <em>iterable</em> 所定义的数据集中返回前 <em>n</em> 个最大元素组成的列表。 如果提供了 <em>key</em> 则其应指定一个单参数的函数，用于从 <em>iterable</em> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key, reverse=True)[:n]</code>。</p>
</li>
<li><p><code>heapq.nsmallest</code>(<em>n</em>, <em>iterable</em>, <em>key=None</em>)</p>
<p>从 <em>iterable</em> 所定义的数据集中返回前 <em>n</em> 个最小元素组成的列表。 如果提供了 <em>key</em> 则其应指定一个单参数的函数，用于从 <em>iterable</em> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key)[:n]</code>。</p>
</li>
</ul>
<p>后两个函数在 <em>n</em> 值较小时性能最好。 对于更大的值，使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> 函数会更有效率。 此外，当 <code>n==1</code> 时，使用内置的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#min" target="_blank" rel="noopener"><code>min()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#max" target="_blank" rel="noopener"><code>max()</code></a> 函数会更有效率。 如果需要重复使用这些函数，请考虑将可迭代对象转为真正的堆。</p>
<h3 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h3><p><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">堆排序</a> 可以通过将所有值推入堆中然后每次弹出一个最小值项来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span><span class="params">(iterable)</span>:</span></span><br><span class="line"><span class="meta">... </span>    h = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line"><span class="meta">... </span>        heappush(h, value)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> [heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(h))]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapsort([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>])</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>这类似于 <code>sorted(iterable)</code>，但与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> 不同的是这个实现是不稳定的。</p>
<p>堆元素可以为元组。</p>
<p> 这适用于将比较值（例如任务优先级）与跟踪的主记录进行赋值的场合:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">5</span>, <span class="string">'write code'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">7</span>, <span class="string">'release product'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">1</span>, <span class="string">'write spec'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">3</span>, <span class="string">'create tests'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappop(h)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'write spec'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="优先队列实现说明"><a href="#优先队列实现说明" class="headerlink" title="优先队列实现说明"></a>优先队列实现说明</h3><p><a href="https://en.wikipedia.org/wiki/Priority_queue" target="_blank" rel="noopener">优先队列</a> 是堆的常用场合，并且它的实现包含了多个挑战：</p>
<ul>
<li>排序稳定性：你该如何令相同优先级的两个任务按它们最初被加入时的顺序返回？</li>
<li>如果优先级相同且任务没有默认比较顺序，则 (priority, task) 对的元组比较将会中断。</li>
<li>如果任务优先级发生改变，你该如何将其移至堆中的新位置？</li>
<li>或者如果一个挂起的任务需要被删除，你该如何找到它并将其移出队列？</li>
</ul>
<p>针对前两项挑战的一种解决方案是将条目保存为包含优先级、条目计数和任务对象 3 个元素的列表。 条目计数可用来打破平局，这样具有相同优先级的任务将按它们的添加顺序返回。 并且由于没有哪两个条目计数是相同的，元组比较将永远不会直接比较两个任务。</p>
<p>不可比较任务问题的另一种解决方案是创建一个忽略任务条目并且只比较优先级字段的包装器类:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Any</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass(order=True)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedItem</span>:</span></span><br><span class="line">    priority: int</span><br><span class="line">    item: Any=field(compare=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>其余的挑战主要包括找到挂起的任务并修改其优先级或将其完全移除。 找到一个任务可使用一个指向队列中条目的字典来实现。</p>
<p>移除条目或改变其优先级的操作实现起来更为困难，因为它会破坏堆结构不变量。 因此，一种可能的解决方案是将条目标记为已移除，再添加一个改变了优先级的新条目:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq = []                         <span class="comment"># list of entries arranged in a heap</span></span><br><span class="line">entry_finder = &#123;&#125;               <span class="comment"># mapping of tasks to entries</span></span><br><span class="line">REMOVED = <span class="string">'&lt;removed-task&gt;'</span>      <span class="comment"># placeholder for a removed task</span></span><br><span class="line">counter = itertools.count()     <span class="comment"># unique sequence count</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_task</span><span class="params">(task, priority=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'Add a new task or update the priority of an existing task'</span></span><br><span class="line">    <span class="keyword">if</span> task <span class="keyword">in</span> entry_finder:</span><br><span class="line">        remove_task(task)</span><br><span class="line">    count = next(counter)</span><br><span class="line">    entry = [priority, count, task]</span><br><span class="line">    entry_finder[task] = entry</span><br><span class="line">    heappush(pq, entry)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_task</span><span class="params">(task)</span>:</span></span><br><span class="line">    <span class="string">'Mark an existing task as REMOVED.  Raise KeyError if not found.'</span></span><br><span class="line">    entry = entry_finder.pop(task)</span><br><span class="line">    entry[<span class="number">-1</span>] = REMOVED</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pop_task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'Remove and return the lowest priority task. Raise KeyError if empty.'</span></span><br><span class="line">    <span class="keyword">while</span> pq:</span><br><span class="line">        priority, count, task = heappop(pq)</span><br><span class="line">        <span class="keyword">if</span> task <span class="keyword">is</span> <span class="keyword">not</span> REMOVED:</span><br><span class="line">            <span class="keyword">del</span> entry_finder[task]</span><br><span class="line">            <span class="keyword">return</span> task</span><br><span class="line">    <span class="keyword">raise</span> KeyError(<span class="string">'pop from an empty priority queue'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>堆是通过数组来实现的，其中的元素从 0 开始计数，对于所有的 <em>k</em> 都有 <code>a[k] &lt;= a[2*k+1]</code> 且 <code>a[k] &lt;= a[2*k+2]</code>。 为了便于比较，不存在的元素被视为无穷大。 堆最有趣的特性在于 <code>a[0]</code> 总是其中最小的元素。</p>
<p>上面的特殊不变量是用来作为一场锦标赛的高效内存表示。 下面的数字是 <em>k</em> 而不是 <code>a[k]</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">                                 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">              <span class="number">1</span>                               <span class="number">2</span></span><br><span class="line"></span><br><span class="line">      <span class="number">3</span>               <span class="number">4</span>                <span class="number">5</span>               <span class="number">6</span></span><br><span class="line"></span><br><span class="line">  <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span>      <span class="number">11</span>      <span class="number">12</span>      <span class="number">13</span>      <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span> <span class="number">16</span>   <span class="number">17</span> <span class="number">18</span>   <span class="number">19</span> <span class="number">20</span>   <span class="number">21</span> <span class="number">22</span>   <span class="number">23</span> <span class="number">24</span>   <span class="number">25</span> <span class="number">26</span>   <span class="number">27</span> <span class="number">28</span>   <span class="number">29</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>在上面的树中，每个 <em>k</em> 单元都位于 <code>2*k+1</code> 和 <code>2*k+2</code> 之上。 体育运动中我们经常见到二元锦标赛模式，每个胜者单元都位于另两个单元之上，并且我们可以沿着树形图向下追溯胜者所遇到的所有对手。 但是，在许多采用这种锦标赛模式的计算机应用程序中，我们并不需要追溯胜者的历史。 为了获得更高的内存利用效率，当一个胜者晋级时，我们会用较低层级的另一条目来替代它，因此规则变为一个单元和它之下的两个单元包含三个不同条目，上方单元“胜过”了两个下方单元。</p>
<p>如果此堆的不变量始终受到保护，则序号 0 显然是最后的赢家。 删除它并找出“下一个”赢家的最简单算法方式是家某个输家（让我们假定是上图中的 30 号单元）移至 0 号位置，然后将这个新的 0 号沿树下行，不断进行值的交换，直到不变量重新建立。 这显然会是树中条目总数的对数。 通过迭代所有条目，你将得到一个 O(n log n) 复杂度的排序。</p>
<p>此排序有一个很好的特性就是你可以在排序进行期间高效地插入新条目，前提是插入的条目不比你最近取出的 0 号元素“更好”。 这在模拟上下文时特别有用，在这种情况下树保存的是所有传入事件，“胜出”条件是最小调度时间。 当一个事件将其他事件排入执行计划时，它们的调试时间向未来方向延长，这样它们可方便地入堆。 因此，堆结构很适宜用来实现调度器，我的 MIDI 音序器就是用的这个 :-)。</p>
<p>用于实现调度器的各种结构都得到了充分的研究，堆是非常适宜的一种，因为它们的速度相当快，并且几乎是恒定的，最坏的情况与平均情况没有太大差别。 虽然还存在其他总体而言更高效的实现方式，但其最坏的情况却可能非常糟糕。</p>
<p>堆在大磁盘排序中也非常有用。 你应该已经了解大规模排序会有多个“运行轮次”（即预排序的序列，其大小通常与 CPU 内存容量相关），随后这些轮次会进入合并通道，轮次合并的组织往往非常巧妙 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#id2" target="_blank" rel="noopener">1</a>。 非常重要的一点是初始排序应产生尽可能长的运行轮次。 锦标赛模式是达成此目标的好办法。 如果你使用全部有用内存来进行锦标赛，替换和安排恰好适合当前运行轮次的条目，你将可以对于随机输入生成两倍于内存大小的运行轮次，对于模糊排序的输入还会有更好的效果。</p>
<p>另外，如果你输出磁盘上的第 0 个条目并获得一个可能不适合当前锦标赛的输入（因为其值要“胜过”上一个输出值），它无法被放入堆中，因此堆的尺寸将缩小。 被释放的内存可以被巧妙地立即重用以逐步构建第二个堆，其增长速度与第一个堆的缩减速度正好相同。 当第一个堆完全消失时，你可以切换新堆并启动新的运行轮次。 这样做既聪明又高效！</p>
<p>总之，堆是值得了解的有用内存结构。 我在一些应用中用到了它们，并且认为保留一个 ‘heap’ 模块是很有意义的。 :-)</p>
<h3 id="堆排序图例"><a href="#堆排序图例" class="headerlink" title="堆排序图例"></a>堆排序图例</h3><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200117_heapq.gif?raw=true" alt></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>heapq</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library numbers</title>
    <url>/2020/01/18/python-standard-library-numbers/</url>
    <content><![CDATA[<h1 id="python-标准库数字的抽象基类-numbers"><a href="#python-标准库数字的抽象基类-numbers" class="headerlink" title="python 标准库数字的抽象基类 numbers"></a>python 标准库数字的抽象基类 numbers</h1><p>昨天深夜 红薯 一篇博文 <a href="https://my.oschina.net/javayou/blog/3159653" target="_blank" rel="noopener">悼 @宏哥</a> ,让我久久不能平静。</p>
<p>时间定格在了2020年1月16号。</p>
<p>还依稀记得几年前和宏哥聊天,听说他去创业了。</p>
<p>还记得那时意气风发,舌战群儒,没想到如今阴阳两隔。</p>
<p>创业这条路,真的不好走。</p>
<p>愿天堂没有代码。</p>
<p>大家都好好活着吧。</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200118_hongge_blog.PNG?raw=true" alt></p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200118_sad.jpg?raw=tru" alt></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1398821876&auto=0&height=66"></iframe>

<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/numbers.py" target="_blank" rel="noopener">Lib/numbers.py</a></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#module-numbers" target="_blank" rel="noopener"><code>numbers</code></a> 模块 (<a href="https://www.python.org/dev/peps/pep-3141" target="_blank" rel="noopener"><strong>PEP 3141</strong></a>) 定义了数字 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class" target="_blank" rel="noopener">抽象基类</a> 的层次结构，其中逐级定义了更多操作。 此模块中所定义的类型都不可被实例化。</p>
<h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><p><em>class</em> <code>numbers.Number</code></p>
<blockquote>
<p>数字的层次结构的基础。如果你只想确认参数 <em>x</em> 是不是数字而不关心其类型，则使用isinstance(x, Number)。</p>
</blockquote>
<a id="more"></a>
<h2 id="数字的层次"><a href="#数字的层次" class="headerlink" title="数字的层次"></a>数字的层次</h2><ul>
<li><p><em>class</em> <code>numbers.Complex</code></p>
<p>内置在类型 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#complex" target="_blank" rel="noopener"><code>complex</code></a> 里的子类描述了复数和它的运算操作。这些操作有：转化至 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#complex" target="_blank" rel="noopener"><code>complex</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#bool" target="_blank" rel="noopener"><code>bool</code></a>， <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.real" target="_blank" rel="noopener"><code>real</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.imag" target="_blank" rel="noopener"><code>imag</code></a>、<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#abs" target="_blank" rel="noopener"><code>abs()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.conjugate" target="_blank" rel="noopener"><code>conjugate()</code></a>、 <code>==</code> 和 <code>!=</code>。 所有的异常，<code>-</code> 和 <code>!=</code> ，都是抽象的。<code>real</code>抽象的。得到该数字的实数部分。<code>imag</code>抽象的。得到该数字的虚数部分。<em>abstractmethod</em> <code>conjugate</code>()抽象的。返回共轭复数。例如 <code>(1+3j).conjugate() == (1-3j)</code>。</p>
</li>
<li><p><em>class</em> <code>numbers.Real</code></p>
<p>相对于 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex" target="_blank" rel="noopener"><code>Complex</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Real" target="_blank" rel="noopener"><code>Real</code></a> 加入了只有实数才能进行的操作。简单的说，它们是：转化至 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.trunc" target="_blank" rel="noopener"><code>math.trunc()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#round" target="_blank" rel="noopener"><code>round()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.floor" target="_blank" rel="noopener"><code>math.floor()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.ceil" target="_blank" rel="noopener"><code>math.ceil()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#divmod" target="_blank" rel="noopener"><code>divmod()</code></a>、 <code>//</code>、 <code>%</code>、 <code>&lt;</code>、 <code>&lt;=</code>、 <code>&gt;</code>、 和 <code>&gt;=</code>。实数同样默认支持 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#complex" target="_blank" rel="noopener"><code>complex()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.real" target="_blank" rel="noopener"><code>real</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.imag" target="_blank" rel="noopener"><code>imag</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.conjugate" target="_blank" rel="noopener"><code>conjugate()</code></a>。</p>
</li>
<li><p><em>class</em> <code>numbers.Rational</code></p>
<p>子类型 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Real" target="_blank" rel="noopener"><code>Real</code></a> 并加入 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational.numerator" target="_blank" rel="noopener"><code>numerator</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational.denominator" target="_blank" rel="noopener"><code>denominator</code></a> 两种属性，这两种属性应该属于最低的级别。加入后，这默认支持 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float()</code></a>。<code>numerator</code>摘要。<code>denominator</code>摘要。</p>
</li>
<li><p><em>class</em> <code>numbers.Integral</code></p>
<p>子类型 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational" target="_blank" rel="noopener"><code>Rational</code></a> 加上转化至 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>。 默认支持 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational.numerator" target="_blank" rel="noopener"><code>numerator</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational.denominator" target="_blank" rel="noopener"><code>denominator</code></a>。 在 <code>**</code> 中加入抽象方法和比特字符串的操作： <code>&lt;&lt;</code>、 <code>&gt;&gt;</code>、 <code>&amp;</code>、 <code>^</code>、 <code>|</code>、 <code>~</code>。</p>
</li>
</ul>
<h2 id="类型接口注解"><a href="#类型接口注解" class="headerlink" title="类型接口注解"></a>类型接口注解</h2><p>实现者需要注意使相等的数字相等并拥有同样的值。当这两个数使用不同的扩展模块时，这其中的差异是很微妙的。例如，用 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>fractions.Fraction</code></a> 实现 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#hash" target="_blank" rel="noopener"><code>hash()</code></a> 如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.denominator == <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># Get integers right.</span></span><br><span class="line">        <span class="keyword">return</span> hash(self.numerator)</span><br><span class="line">    <span class="comment"># Expensive check, but definitely correct.</span></span><br><span class="line">    <span class="keyword">if</span> self == float(self):</span><br><span class="line">        <span class="keyword">return</span> hash(float(self))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Use tuple's hash to avoid a high collision rate on</span></span><br><span class="line">        <span class="comment"># simple fractions.</span></span><br><span class="line">        <span class="keyword">return</span> hash((self.numerator, self.denominator))</span><br></pre></td></tr></table></figure>
<h3 id="添加更多数字的ABC-创造自定义的数字子类"><a href="#添加更多数字的ABC-创造自定义的数字子类" class="headerlink" title="添加更多数字的ABC(创造自定义的数字子类)"></a>添加更多数字的ABC(创造自定义的数字子类)</h3><p>当然，这里有更多支持数字的ABC，如果不加入这些，就将缺少层次感。你可以用如下方法在 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex" target="_blank" rel="noopener"><code>Complex</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Real" target="_blank" rel="noopener"><code>Real</code></a> 中加入MyFoo：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFoo</span><span class="params">(Complex)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">MyFoo.register(Real)</span><br></pre></td></tr></table></figure>
<h3 id="实现算数运算"><a href="#实现算数运算" class="headerlink" title="实现算数运算"></a>实现算数运算</h3><p>我们希望实现计算，因此，混合模式操作要么调用一个作者知道参数类型的实现，要么转变成为最接近的内置类型并对这个执行操作。对于子类 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Integral" target="_blank" rel="noopener"><code>Integral</code></a>，这意味着 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__radd__" target="_blank" rel="noopener"><code>__radd__()</code></a> 必须用如下方式定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIntegral</span><span class="params">(Integral)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(other, MyIntegral):</span><br><span class="line">            <span class="keyword">return</span> do_my_adding_stuff(self, other)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, OtherTypeIKnowAbout):</span><br><span class="line">            <span class="keyword">return</span> do_my_other_adding_stuff(self, other)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(other, MyIntegral):</span><br><span class="line">            <span class="keyword">return</span> do_my_adding_stuff(other, self)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, OtherTypeIKnowAbout):</span><br><span class="line">            <span class="keyword">return</span> do_my_other_adding_stuff(other, self)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, Integral):</span><br><span class="line">            <span class="keyword">return</span> int(other) + int(self)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, Real):</span><br><span class="line">            <span class="keyword">return</span> float(other) + float(self)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, Complex):</span><br><span class="line">            <span class="keyword">return</span> complex(other) + complex(self)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure>
<p>复数的子类上的混合操作有五种情况。前述的代码中除去MyIntegral和OtherTypeIKnow的文本将作为下面描述的样板。a是A的实例，并且使复数的子类（a：A&lt;：Complex），b是B的实例，也是复数的子类。我们以a+b做如下讨论：</p>
<ol>
<li>如果 <code>A</code> 被定义成一个承认b 的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a>，一切都没有问题。</li>
<li>如果 <code>A</code> 转回成“模板”失败，它将返回一个属于 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 的值，我们需要避免 <code>B</code> 定义了一个更加智能的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__radd__" target="_blank" rel="noopener"><code>__radd__()</code></a>，因此模板需要返回一个属于 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#NotImplemented" target="_blank" rel="noopener"><code>NotImplemented</code></a> 。（或者 <code>A</code> 可能完全不实现 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 。）</li>
<li>接着看 <code>B</code> 的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__radd__" target="_blank" rel="noopener"><code>__radd__()</code></a> 。如果它接受<code>a</code> ，一切都将完美。</li>
<li>如果没有成功回退到模板，就没有更多的方法可以去尝试，因此这里将使用默认的实现。</li>
<li>如果 <code>B &lt;: A</code> ， Python 在 <code>A.__add__</code> 之前尝试 <code>B.__radd__</code> 。 这是可行的，是通过对 <code>A</code> 的认识实现的，因此这可以在交给 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex" target="_blank" rel="noopener"><code>Complex</code></a> 处理之前处理这些实例。</li>
</ol>
<p>如果 <code>A &lt;: Complex</code> 和 <code>B &lt;: Real</code> 没有共享任何资源，那么适当的共享操作涉及内置的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#complex" target="_blank" rel="noopener"><code>complex</code></a> ，并且分别获得 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__radd__" target="_blank" rel="noopener"><code>__radd__()</code></a> ，因此 <code>a+b == b+a</code>。</p>
<p>由于对任何一直类型的大部分操作是十分相似的，可以定义一个帮助函数，即一个生成后续或相反的实例的生成器。例如，使用 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>fractions.Fraction</code></a> 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_operator_fallbacks</span><span class="params">(monomorphic_operator, fallback_operator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(b, (int, Fraction)):</span><br><span class="line">            <span class="keyword">return</span> monomorphic_operator(a, b)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(b, float):</span><br><span class="line">            <span class="keyword">return</span> fallback_operator(float(a), b)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(b, complex):</span><br><span class="line">            <span class="keyword">return</span> fallback_operator(complex(a), b)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    forward.__name__ = <span class="string">'__'</span> + fallback_operator.__name__ + <span class="string">'__'</span></span><br><span class="line">    forward.__doc__ = monomorphic_operator.__doc__</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(b, a)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(a, Rational):</span><br><span class="line">            <span class="comment"># Includes ints.</span></span><br><span class="line">            <span class="keyword">return</span> monomorphic_operator(a, b)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(a, numbers.Real):</span><br><span class="line">            <span class="keyword">return</span> fallback_operator(float(a), float(b))</span><br><span class="line">        <span class="keyword">elif</span> isinstance(a, numbers.Complex):</span><br><span class="line">            <span class="keyword">return</span> fallback_operator(complex(a), complex(b))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    reverse.__name__ = <span class="string">'__r'</span> + fallback_operator.__name__ + <span class="string">'__'</span></span><br><span class="line">    reverse.__doc__ = monomorphic_operator.__doc__</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> forward, reverse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""a + b"""</span></span><br><span class="line">    <span class="keyword">return</span> Fraction(a.numerator * b.denominator +</span><br><span class="line">                    b.numerator * a.denominator,</span><br><span class="line">                    a.denominator * b.denominator)</span><br><span class="line"></span><br><span class="line">__add__, __radd__ = _operator_fallbacks(_add, operator.add)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library pickle</title>
    <url>/2020/01/14/python-standard-library-pickle/</url>
    <content><![CDATA[<h1 id="python-标准库-pickle"><a href="#python-标准库-pickle" class="headerlink" title="python 标准库 pickle"></a>python 标准库 pickle</h1><p>快过年了,准备了一些过节用的英语</p>
<blockquote>
<ol>
<li><p>传统中国节日：traditional Chinese festival</p>
</li>
<li><p>农历：lunar calendar</p>
</li>
<li><p>腊八节：Laba Festival</p>
</li>
<li><p>小年：Little New Year</p>
</li>
<li><p>除夕：Lunar New Year’s Eve</p>
</li>
<li><p>春节：the Spring Festival</p>
</li>
<li><p>正月初一：the lunar New Year’s Day</p>
</li>
<li><p>元宵节：the Lantern Festival</p>
</li>
<li><p>正月：the first month of the lunar year</p>
</li>
<li><p>二月二：Dragon Heads-raising Day</p>
</li>
</ol>
</blockquote>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200114_guonian1.jpg?raw=true" alt></p>
<p>时间过得好快,又是一年过去了。</p>
<h2 id="python-标准库学习之-pickle"><a href="#python-标准库学习之-pickle" class="headerlink" title="python 标准库学习之 pickle"></a>python 标准库学习之 pickle</h2><p>常用的文本处理 除了文件,数据库,json,xml 以外,python还提供了一种存储方案,这就是<code>pickle</code>。</p>
<blockquote>
<p>模块 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 实现了对一个 Python 对象结构的二进制序列化和反序列化。<em>“pickling”</em> 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 <em>“unpickling”</em> 是相反的操作，会将（来自一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a> 或者 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 的）字节流转化回一个对象层次结构。 pickling（和 unpickling）也被称为“序列化”, “编组” 或者 “平面化”。而为了避免混乱，此处采用术语 “封存 (pickling)” 和 “解封 (unpickling)”。</p>
</blockquote>
<blockquote>
<p><em>警告</em> :  <code>pickle</code> 模块<strong>并不安全</strong>。你只应该对你信任的数据进行unpickle操作。构建恶意的 pickle 数据来<strong>在解封时执行任意代码</strong>是可能的。绝对不要对不信任来源的数据和可能被篡改过的数据进行解封。请考虑使用 <a href="https://docs.python.org/zh-cn/3/library/hmac.html#module-hmac" target="_blank" rel="noopener"><code>hmac</code></a> 来对数据进行签名，确保数据没有被篡改。在你处理不信任数据时，更安全的序列化格式如 <a href="https://docs.python.org/zh-cn/3/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 可能更为适合。参见 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#comparison-with-json" target="_blank" rel="noopener">与 json 模块的比较</a> </p>
</blockquote>
<h3 id="源代码：-Lib-pickle-py"><a href="#源代码：-Lib-pickle-py" class="headerlink" title="源代码： Lib/pickle.py"></a><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/pickle.py" target="_blank" rel="noopener">Lib/pickle.py</a></h3><p>本节内容比较多,先看下类层次结构,有一个大体的概念(节选自源码)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Classes:</span><br><span class="line">    Pickler</span><br><span class="line">    Unpickler</span><br><span class="line">Functions:</span><br><span class="line">    dump(object, file)</span><br><span class="line">    dumps(object) -&gt; string</span><br><span class="line">    load(file) -&gt; object</span><br><span class="line">    loads(string) -&gt; object</span><br><span class="line">Misc variables:</span><br><span class="line">    __version__</span><br><span class="line">    format_version</span><br><span class="line">    compatible_formats</span><br><span class="line">    </span><br><span class="line">__all__ = [<span class="string">"PickleError"</span>, <span class="string">"PicklingError"</span>, <span class="string">"UnpicklingError"</span>, <span class="string">"Pickler"</span>,</span><br><span class="line">           <span class="string">"Unpickler"</span>, <span class="string">"dump"</span>, <span class="string">"dumps"</span>, <span class="string">"load"</span>, <span class="string">"loads"</span>]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="数据流格式"><a href="#数据流格式" class="headerlink" title="数据流格式"></a>数据流格式</h3><p><a href="https://docs.python.org/zh-cn/3/library/pickletools.html#module-pickletools" target="_blank" rel="noopener"><code>pickletools</code></a> 模块包含了相应的工具用于分析 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 生成的数据流。<a href="https://docs.python.org/zh-cn/3/library/pickletools.html#module-pickletools" target="_blank" rel="noopener"><code>pickletools</code></a> 源码中包含了对 pickle 协议使用的操作码的大量注释。</p>
<p>当前共有 6 种不同的协议可用于封存操作。 使用的协议版本越高，读取所生成 pickle 对象所需的 Python 版本就要越新。</p>
<ul>
<li>v0 版协议是原始的“人类可读”协议，并且向后兼容早期版本的 Python。</li>
<li>v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容。</li>
<li>v2 版协议是在 Python 2.3 中引入的。它为存储 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-new-style-class" target="_blank" rel="noopener">new-style class</a> 提供了更高效的机制。欲了解有关第 2 版协议带来的改进，请参阅 <a href="https://www.python.org/dev/peps/pep-0307" target="_blank" rel="noopener"><strong>PEP 307</strong></a>。</li>
<li>v3 版协议是在 Python 3.0 中引入的。 它显式地支持 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 字节对象，不能使用 Python 2.x 解封。这是 Python 3.0-3.7 的默认协议。</li>
<li>v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化。它是Python 3.8使用的默认协议。有关第 4 版协议带来改进的信息，请参阅 <a href="https://www.python.org/dev/peps/pep-3154" target="_blank" rel="noopener"><strong>PEP 3154</strong></a>。</li>
<li>第 5 版协议是在 Python 3.8 中加入的。 它增加了对带外数据的支持，并可加速带内数据处理。 请参阅 <a href="https://www.python.org/dev/peps/pep-0574" target="_blank" rel="noopener"><strong>PEP 574</strong></a> 了解第 5 版协议所带来的改进的详情。</li>
</ul>
<h3 id="模块接口"><a href="#模块接口" class="headerlink" title="模块接口"></a>模块接口</h3><p>要序列化某个包含层次结构的对象，只需调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dumps" target="_blank" rel="noopener"><code>dumps()</code></a> 函数即可。同样，要反序列化数据流，可以调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.loads" target="_blank" rel="noopener"><code>loads()</code></a> 函数。但是，如果要对序列化和反序列化加以更多的控制，可以分别创建 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> 对象。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块包含了以下常量：</p>
<ul>
<li><p><code>pickle.HIGHEST_PROTOCOL</code></p>
<p>整数，可用的最高 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-protocols" target="_blank" rel="noopener">协议版本</a>。此值可以作为 <em>协议</em> 值传递给 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dump" target="_blank" rel="noopener"><code>dump()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dumps" target="_blank" rel="noopener"><code>dumps()</code></a> 函数，以及 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的构造函数。</p>
</li>
<li><p><code>pickle.DEFAULT_PROTOCOL</code></p>
<p>整数，用于 pickle 数据的默认 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-protocols" target="_blank" rel="noopener">协议版本</a>。它可能小于 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.HIGHEST_PROTOCOL" target="_blank" rel="noopener"><code>HIGHEST_PROTOCOL</code></a>。当前默认协议是 v4，它在 Python 3.4 中首次引入，与之前的版本不兼容。<em>在 3.8 版更改:</em> 默认协议版本还是 4。</p>
</li>
</ul>
<h3 id="模块方法"><a href="#模块方法" class="headerlink" title="模块方法"></a>模块方法</h3><ul>
<li><p><code>pickle.dump</code>(<em>obj</em>, <em>file</em>, <em>protocol=None</em>, <em>**, </em>fix_imports=True<em>, </em>buffer_callback=None*)</p>
<p>将对象 <em>obj</em> 封存以后的对象写入已打开的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> <em>file</em>。它等同于 <code>Pickler(file, protocol).dump(obj)</code>。参数 <em>file</em>、<em>protocol</em>、<em>fix_imports</em> 和 <em>buffer_callback</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的构造函数中的含义相同。<em>在 3.8 版更改:</em> 加入了 <em>buffer_callback</em> 参数。</p>
</li>
<li><p><code>pickle.dumps</code>(<em>obj</em>, <em>protocol=None</em>, <em>**, </em>fix_imports=True<em>, </em>buffer_callback=None*)</p>
<p>将 <em>obj</em> 封存以后的对象作为 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型直接返回，而不是将其写入到文件。参数 <em>protocol</em>、<em>fix_imports</em> 和 <em>buffer_callback</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的构造函数中的含义相同。<em>在 3.8 版更改:</em> 加入了 <em>buffer_callback</em> 参数。</p>
</li>
<li><p><code>pickle.load</code>(<em>file</em>, <em>**, </em>fix_imports=True<em>, </em>encoding=”ASCII”<em>, </em>errors=”strict”<em>, </em>buffers=None*)</p>
<p>从已打开的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> <em>文件</em> 中读取封存后的对象，重建其中特定对象的层次结构并返回。它相当于 <code>Unpickler(file).load()</code>。Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。封存对象以外的其他字节将被忽略。参数 <em>file</em>、<em>fix_imports</em>、<em>encoding</em>、<em>errors</em>、<em>strict</em> 和 <em>buffers</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> 的构造函数中的含义相同。<em>在 3.8 版更改:</em> 加入了 <em>buffers</em> 参数。</p>
</li>
<li><p><code>pickle.loads</code>(<em>bytes_object</em>, <em>**, </em>fix_imports=True<em>, </em>encoding=”ASCII”<em>, </em>errors=”strict”<em>, </em>buffers=None*)</p>
<p>对于封存生成的对象 <em>bytes_object</em>，还原出原对象的结构并返回。Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。封存对象以外的其他字节将被忽略。参数 <em>file</em>、<em>fix_imports</em>、<em>encoding</em>、<em>errors</em>、<em>strict</em> 和 <em>buffers</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> 的构造函数中的含义相同。</p>
</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块定义了以下 3 个异常：</p>
<ul>
<li><p><em>exception</em> <code>pickle.PickleError</code></p>
<p>其他 pickle 异常的基类。它是 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>pickle.PicklingError</code></p>
<p>当 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 遇到无法解封的对象时抛出此错误。它是 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleError" target="_blank" rel="noopener"><code>PickleError</code></a> 的子类。参考 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-picklable" target="_blank" rel="noopener">可以被封存/解封的对象</a> 来了解哪些对象可以被封存。</p>
</li>
<li><p><em>exception</em> <code>pickle.UnpicklingError</code></p>
<p>当解封出错时抛出此异常，例如数据损坏或对象不安全。它是 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleError" target="_blank" rel="noopener"><code>PickleError</code></a> 的子类。注意，解封时可能还会抛出其他异常，包括（但不限于） AttributeError、EOFError、ImportError 和 IndexError。</p>
</li>
</ul>
<h3 id="模块中的类"><a href="#模块中的类" class="headerlink" title="模块中的类"></a>模块中的类</h3><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块包含了 3 个类，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a>、<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a>：</p>
<h4 id="Pickler"><a href="#Pickler" class="headerlink" title="Pickler"></a>Pickler</h4><p><em>class</em> <code>pickle.Pickler</code>(<em>file</em>, <em>protocol=None</em>, <em>**, </em>fix_imports=True<em>, </em>buffer_callback=None*)</p>
<p>它接受一个二进制文件用于写入 pickle 数据流。</p>
<p>可选参数 <em>protocol</em> 是一个整数，告知 pickler 使用指定的协议，可选择的协议范围从 0 到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.HIGHEST_PROTOCOL" target="_blank" rel="noopener"><code>HIGHEST_PROTOCOL</code></a>。如果没有指定，这一参数默认值为 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.DEFAULT_PROTOCOL" target="_blank" rel="noopener"><code>DEFAULT_PROTOCOL</code></a>。指定一个负数就相当于指定 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.HIGHEST_PROTOCOL" target="_blank" rel="noopener"><code>HIGHEST_PROTOCOL</code></a>。</p>
<p>参数 <em>file</em> 必须有一个 write() 方法，该 write() 方法要能接收字节作为其唯一参数。因此，它可以是一个打开的磁盘文件（用于写入二进制内容），也可以是一个 <a href="https://docs.python.org/zh-cn/3/library/io.html#io.BytesIO" target="_blank" rel="noopener"><code>io.BytesIO</code></a> 实例，也可以是满足这一接口的其他任何自定义对象。</p>
<p>如果 <em>fix_imports</em> 为 True 且 <em>protocol</em> 小于 3，pickle 将尝试将 Python 3 中的新名称映射到 Python 2 中的旧模块名称，因此 Python 2 也可以读取封存的数据流。</p>
<p>如果 <em>buffer_callback</em> 为 None（默认情况），缓冲区视图（buffer view）将会作为 pickle 流的一部分被序列化到 <em>file</em> 中。</p>
<p>如果 <em>buffer_callback</em> 不为 None，那它可以用缓冲区视图调用任意次。如果某次调用返回了 False 值（例如 None），则给定的缓冲区是 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-oob" target="_blank" rel="noopener">带外的</a>，否则缓冲区是带内的（例如保存在了 pickle 流里面）。</p>
<p>如果 <em>buffer_callback</em> 不是 None 且 <em>protocol</em> 是 None 或小于 5，就会出错。</p>
<p><em>在 3.8 版更改:</em> 加入了 <em>buffer_callback</em> 参数。</p>
<ul>
<li><p><code>dump</code>(<em>obj</em>)</p>
<p>将 <em>obj</em> 封存后的内容写入已打开的文件对象，该文件对象已经在构造函数中指定。</p>
</li>
<li><p><code>persistent_id</code>(<em>obj</em>)</p>
<p>默认无动作，子类继承重载时使用。如果 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.persistent_id" target="_blank" rel="noopener"><code>persistent_id()</code></a> 返回 <code>None</code>，<em>obj</em> 会被照常 pickle。如果返回其他值，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 会将这个函数的返回值作为 <em>obj</em> 的持久化 ID（Pickler 本应得到序列化数据流并将其写入文件，若此函数有返回值，则得到此函数的返回值并写入文件）。这个持久化 ID 的解释应当定义在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.persistent_load" target="_blank" rel="noopener"><code>Unpickler.persistent_load()</code></a> 中（该方法定义还原对象的过程，并返回得到的对象）。注意，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.persistent_id" target="_blank" rel="noopener"><code>persistent_id()</code></a> 的返回值本身不能拥有持久化 ID。参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-persistent" target="_blank" rel="noopener">持久化外部对象</a> 获取详情和使用示例。</p>
</li>
<li><p><code>dispatch_table</code></p>
<p>Pickler 对象的 dispatch 表是 <a href="https://docs.python.org/zh-cn/3/library/copyreg.html#copyreg.pickle" target="_blank" rel="noopener"><code>copyreg.pickle()</code></a> 中用到的 <em>reduction 函数</em> 的注册。dispatch 表本身是一个 class 到其 reduction 函数的映射键值对。一个 reduction 函数只接受一个参数，就是其关联的 class，函数行为应当遵守 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 接口规范。Pickler 对象默认并没有 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 属性，该对象默认使用 <a href="https://docs.python.org/zh-cn/3/library/copyreg.html#module-copyreg" target="_blank" rel="noopener"><code>copyreg</code></a> 模块中定义的全局 dispatch 表。如果要为特定 Pickler 对象自定义序列化过程，可以将 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 属性设置为类字典对象（dict-like object）。另外，如果 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的子类设置了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 属性，则该子类的实例会使用这个表作为默认的 dispatch 表。参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-dispatch" target="_blank" rel="noopener">Dispatch 表</a> 获取使用示例。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>reducer_override</code>(<em>self</em>, <em>obj</em>)</p>
<p>可以在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的子类中定义的特殊 reducer。此方法的优先级高于 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 中的任何 reducer。它应该与 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 方法遵循相同的接口，它也可以返回 <code>NotImplemented</code>，这将使用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 里注册的 reducer 来封存 <code>obj</code>。</p>
</li>
</ul>
<h4 id="Unpickler"><a href="#Unpickler" class="headerlink" title="Unpickler"></a>Unpickler</h4><p><em>class</em> <code>pickle.Unpickler</code>(<em>file</em>, <em>**, </em>fix_imports=True<em>, </em>encoding=”ASCII”<em>, </em>errors=”strict”<em>, </em>buffers=None*)</p>
<p>它接受一个二进制文件用于读取 pickle 数据流。</p>
<p>Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。</p>
<p>参数 <em>file</em> 必须有三个方法，read() 方法接受一个整数参数，readinto() 方法接受一个缓冲区作为参数，readline() 方法不需要参数，这与 <a href="https://docs.python.org/zh-cn/3/library/io.html#io.BufferedIOBase" target="_blank" rel="noopener"><code>io.BufferedIOBase</code></a> 里定义的接口是相同的。因此 <em>file</em> 可以是一个磁盘上用于二进制读取的文件，也可以是一个 <a href="https://docs.python.org/zh-cn/3/library/io.html#io.BytesIO" target="_blank" rel="noopener"><code>io.BytesIO</code></a> 实例，也可以是满足这一接口的其他任何自定义对象。</p>
<p>可选的参数是 <em>fix_imports</em>, <em>encoding</em> 和 <em>errors</em>，用于控制由Python 2 生成的 pickle 流的兼容性。如果 <em>fix_imports</em> 为 True，则 pickle 将尝试将旧的 Python 2 名称映射到 Python 3 中对应的新名称。<em>encoding</em> 和 <em>errors</em> 参数告诉 pickle 如何解码 Python 2 存储的 8 位字符串实例；这两个参数默认分别为 ‘ASCII’ 和 ‘strict’。<em>encoding</em> 参数可置为 ‘bytes’ 来将这些 8 位字符串实例读取为字节对象。读取 NumPy array 和 Python 2 存储的 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime" target="_blank" rel="noopener"><code>datetime</code></a>、<a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>date</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" target="_blank" rel="noopener"><code>time</code></a> 实例时，请使用 <code>encoding=&#39;latin1&#39;</code>。</p>
<p>如果 <em>buffers</em> 为 None（默认值），则反序列化所需的所有数据都必须包含在 pickle 流中。这意味着在实例化 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 时（或调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dump" target="_blank" rel="noopener"><code>dump()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dumps" target="_blank" rel="noopener"><code>dumps()</code></a> 时），参数 <em>buffer_callback</em> 为 None。</p>
<p>如果 <em>buffers</em> 不为 None，则每次 pickle 流引用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-oob" target="_blank" rel="noopener">带外</a> 缓冲区视图时，消耗的对象都应该是可迭代的启用缓冲区的对象。这样的缓冲区应该按顺序地提供给 Pickler 对象的 <em>buffer_callback</em> 方法。</p>
<p><em>在 3.8 版更改:</em> 加入了 <em>buffers</em> 参数。</p>
<ul>
<li><p><code>load</code>()</p>
<p>从构造函数中指定的文件对象里读取封存好的对象，重建其中特定对象的层次结构并返回。封存对象以外的其他字节将被忽略。</p>
</li>
<li><p><code>persistent_load</code>(<em>pid</em>)</p>
<p>默认抛出 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.UnpicklingError" target="_blank" rel="noopener"><code>UnpicklingError</code></a> 异常。如果定义了此方法，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.persistent_load" target="_blank" rel="noopener"><code>persistent_load()</code></a> 应当返回持久化 ID <em>pid</em> 所指定的对象。 如果遇到无效的持久化 ID，则应当引发 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.UnpicklingError" target="_blank" rel="noopener"><code>UnpicklingError</code></a>。参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-persistent" target="_blank" rel="noopener">持久化外部对象</a> 获取详情和使用示例。</p>
</li>
<li><p><code>find_class</code>(<em>module</em>, <em>name</em>)</p>
<p>如有必要，导入 <em>module</em> 模块并返回其中名叫 <em>name</em> 的对象，其中 <em>module</em> 和 <em>name</em> 参数都是 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 对象。注意，不要被这个函数的名字迷惑， <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.find_class" target="_blank" rel="noopener"><code>find_class()</code></a> 同样可以用来导入函数。子类可以重载此方法，来控制加载对象的类型和加载对象的方式，从而尽可能降低安全风险。参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-restrict" target="_blank" rel="noopener">限制全局变量</a> 获取更详细的信息。引发一个 <a href="https://docs.python.org/zh-cn/3/library/sys.html#auditing" target="_blank" rel="noopener">审核事件</a> <code>pickle.find_class</code> 附带参数 <code>module</code>、<code>name</code>。</p>
</li>
</ul>
<h4 id="PickleBuffer"><a href="#PickleBuffer" class="headerlink" title="PickleBuffer"></a>PickleBuffer</h4><p><em>class</em> <code>pickle.PickleBuffer</code>(<em>buffer</em>)</p>
<p>缓冲区的包装器 (wrapper)，缓冲区中包含着可封存的数据。<em>buffer</em> 必须是一个 <a href="https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects" target="_blank" rel="noopener">buffer-providing</a> 对象，比如 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 或多维数组。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 本身就可以生成缓冲区对象，因此可以将其传递给需要缓冲区生成器的其他 API，比如 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview</code></a>。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 对象只能用 pickle 版本 5 及以上协议进行序列化。它们符合 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-oob" target="_blank" rel="noopener">带外序列化</a> 的条件。</p>
<p><em>3.8 新版功能.</em></p>
<ul>
<li><p><code>raw</code>()</p>
<p>返回该缓冲区底层内存区域的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview</code></a>。 返回的对象是一维的、C 连续布局的 memoryview，格式为 <code>B</code> (无符号字节)。 如果缓冲区既不是 C 连续布局也不是 Fortran 连续布局的，则抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#BufferError" target="_blank" rel="noopener"><code>BufferError</code></a> 异常。</p>
</li>
<li><p><code>release</code>()</p>
<p>释放由 PickleBuffer 占用的底层缓冲区。</p>
</li>
</ul>
<h3 id="可以被封存-解封的对象"><a href="#可以被封存-解封的对象" class="headerlink" title="可以被封存/解封的对象"></a>可以被封存/解封的对象</h3><p>下列类型可以被封存：</p>
<ul>
<li><code>None</code>、<code>True</code> 和 <code>False</code></li>
<li>整数、浮点数、复数</li>
<li>str、byte、bytearray</li>
<li>只包含可封存对象的集合，包括 tuple、list、set 和 dict</li>
<li>定义在模块最外层的函数（使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#def" target="_blank" rel="noopener"><code>def</code></a> 定义，<a href="https://docs.python.org/zh-cn/3/reference/expressions.html#lambda" target="_blank" rel="noopener"><code>lambda</code></a> 函数则不可以）</li>
<li>定义在模块最外层的内置函数</li>
<li>定义在模块最外层的类</li>
<li>某些类实例，这些类的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 属性值或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a> 函数的返回值可以被封存（详情参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-inst" target="_blank" rel="noopener">封存类实例</a> 这一段）。</li>
</ul>
<p>尝试封存不能被封存的对象会抛出 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PicklingError" target="_blank" rel="noopener"><code>PicklingError</code></a> 异常，异常发生时，可能有部分字节已经被写入指定文件中。尝试封存递归层级很深的对象时，可能会超出最大递归层级限制，此时会抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RecursionError" target="_blank" rel="noopener"><code>RecursionError</code></a> 异常，可以通过 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.setrecursionlimit" target="_blank" rel="noopener"><code>sys.setrecursionlimit()</code></a> 调整递归层级，不过请谨慎使用这个函数，因为可能会导致解释器崩溃。</p>
<p><strong>注意</strong></p>
<ol>
<li><p>函数封存</p>
<blockquote>
<p>函数（内置函数或用户自定义函数）在被封存时，引用的是函数全名。<a href="https://docs.python.org/zh-cn/3/library/pickle.html#id8" target="_blank" rel="noopener">2</a> 这意味着只有函数所在的模块名，与函数名会被封存，函数体及其属性不会被封存。因此，在解封的环境中，函数所属的模块必须是可以被导入的，而且模块必须包含这个函数被封存时的名称，否则会抛出异常。</p>
</blockquote>
</li>
<li><p>类封存</p>
<blockquote>
<p>类也只封存名称，所以在解封环境中也有和函数相同的限制。注意，类体及其数据不会被封存，所以在下面的例子中类属性 <code>attr</code> 不会存在于解封后的环境中：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    attr = <span class="string">'A class attribute'</span></span><br><span class="line"></span><br><span class="line">picklestring = pickle.dumps(Foo)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>类的实例封存</p>
<blockquote>
<p>在封存类的实例时，其类体和类数据不会跟着实例一起被封存，只有实例数据会被封存。这样设计是有目的的，在将来修复类中的错误、给类增加方法之后，仍然可以载入原来版本类实例的封存数据来还原该实例。如果你准备长期使用一个对象，可能会同时存在较多版本的类体，可以为对象添加版本号，这样就可以通过类的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 方法将老版本转换成新版本</p>
</blockquote>
</li>
</ol>
<h3 id="封存类实例"><a href="#封存类实例" class="headerlink" title="封存类实例"></a>封存类实例</h3><blockquote>
<p>通常，使一个实例可被封存不需要附加任何代码。Pickle 默认会通过 Python 的内省机制获得实例的类及属性。而当实例解封时，它的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法通常 <em>不会</em> 被调用。其默认动作是：先创建一个未初始化的实例，然后还原其属性，下面的代码展示了这种行为的实现机制：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (obj.__class__, obj.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(cls, attributes)</span>:</span></span><br><span class="line">    obj = cls.__new__(cls)</span><br><span class="line">    obj.__dict__.update(attributes)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>
<p>类可以改变默认行为，只需定义以下一种或几种特殊方法：</p>
<ul>
<li><p><code>object.__getnewargs_ex__</code>()</p>
<p>对于使用第 2 版或更高版协议的 pickle，实现了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a> 方法的类可以控制在解封时传给 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 方法的参数。本方法必须返回一对 <code>(args, kwargs)</code> 用于构建对象，其中 <em>args</em> 是表示位置参数的 tuple，而 <em>kwargs</em> 是表示命名参数的 dict。它们会在解封时传递给 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 方法。如果类的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 方法只接受关键字参数，则应当实现这个方法。否则，为了兼容性，更推荐实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs__" target="_blank" rel="noopener"><code>__getnewargs__()</code></a> 方法。<em>在 3.6 版更改:</em> <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a> 现在可用于第 2 和第 3 版协议。</p>
</li>
<li><p><code>object.__getnewargs__</code>()</p>
<p>这个方法与上一个 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a> 方法类似，但仅支持位置参数。它要求返回一个 tuple 类型的 <code>args</code>，用于解封时传递给 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 方法。如果定义了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a>，那么 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs__" target="_blank" rel="noopener"><code>__getnewargs__()</code></a> 就不会被调用。<em>在 3.6 版更改:</em> 在 Python 3.6 前，第 2、3 版协议会调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs__" target="_blank" rel="noopener"><code>__getnewargs__()</code></a>，更高版本协议会调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a>。</p>
</li>
<li><p><code>object.__getstate__</code>()</p>
<p>类还可以进一步控制其实例的封存过程。如果类定义了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a>，它就会被调用，其返回的对象是被当做实例内容来封存的，否则封存的是实例的 <strong>dict</strong>。如果 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a> 未定义，实例的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 会被照常封存。</p>
</li>
<li><p><code>object.__setstate__</code>(<em>state</em>)</p>
<p>当解封时，如果类定义了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a>，就会在已解封状态下调用它。此时不要求实例的 state 对象必须是 dict。没有定义此方法的话，先前封存的 state 对象必须是 dict，且该 dict 内容会在解封时赋给新实例的 <strong>dict</strong>。</p>
<p>==备注==： 如果 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a> 返回 False，那么在解封时就不会调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 方法。 </p>
</li>
<li><p><code>object.__reduce__</code>()</p>
<p>该接口当前定义如下。<a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 方法不带任何参数，并且应返回字符串或最好返回一个元组（返回的对象通常称为“reduce 值”）。如果返回字符串，该字符串会被当做一个全局变量的名称。它应该是对象相对于其模块的本地名称，pickle 模块会搜索模块命名空间来确定对象所属的模块。这种行为常在单例模式使用。如果返回的是元组，则应当包含 2 到 6 个元素，可选元素可以省略或设置为 <code>None</code>。每个元素代表的意义如下：一个可调用对象，该对象会在创建对象的最初版本时调用。可调用对象的参数，是一个元组。如果可调用对象不接受参数，必须提供一个空元组。可选元素，用于表示对象的状态，将被传给前述的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 方法。 如果对象没有此方法，则这个元素必须是字典类型，并会被添加至 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 属性中。可选元素，一个返回连续项的迭代器（而不是序列）。这些项会被 <code>obj.append(item)</code> 逐个加入对象，或被 <code>obj.extend(list_of_items)</code> 批量加入对象。这个元素主要用于 list 的子类，也可以用于那些正确实现了 <code>append()</code> 和 <code>extend()</code> 方法的类。（具体是使用 <code>append()</code> 还是 <code>extend()</code> 取决于 pickle 协议版本以及待插入元素的项数，所以这两个方法必须同时被类支持。）可选元素，一个返回连续键值对的迭代器（而不是序列）。这些键值对将会以 <code>obj[key] = value</code> 的方式存储于对象中。该元素主要用于 dict 子类，也可以用于那些实现了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__setitem__" target="_blank" rel="noopener"><code>__setitem__()</code></a> 的类。可选元素，一个带有 <code>(obj, state)</code> 签名的可调用对象。该可调用对象允许用户以编程方式控制特定对象的状态更新行为，而不是使用 <code>obj</code> 的静态 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 方法。如果此处不是 <code>None</code>，则此可调用对象的优先级高于 <code>obj</code> 的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a>。<em>3.8 新版功能:</em> 新增了元组的第 6 项，可选元素 <code>(obj, state)</code>。</p>
</li>
<li><p><code>object.__reduce_ex__</code>(<em>protocol</em>)</p>
<p>作为替代选项，也可以实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce_ex__" target="_blank" rel="noopener"><code>__reduce_ex__()</code></a> 方法。 此方法的唯一不同之处在于它应接受一个整型参数用于指定协议版本。 如果定义了这个函数，则会覆盖 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 的行为。 此外，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 方法会自动成为扩展版方法的同义词。 这个函数主要用于为以前的 Python 版本提供向后兼容的 reduce 值。</p>
</li>
</ul>
<h3 id="持久化外部对象"><a href="#持久化外部对象" class="headerlink" title="持久化外部对象"></a>持久化外部对象</h3><p>为了获取对象持久化的利益， <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块支持引用已封存数据流之外的对象。 这样的对象是通过一个持久化 ID 来引用的，它应当是一个由字母数字类字符组成的字符串 (对于第 0 版协议) <a href="https://docs.python.org/zh-cn/3/library/pickle.html#id11" target="_blank" rel="noopener">5</a> 或是一个任意对象 (用于任意新版协议)。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块不提供对持久化 ID 的解析工作，它将解析工作分配给用户定义的方法，分别是 pickler 中的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.persistent_id" target="_blank" rel="noopener"><code>persistent_id()</code></a> 方法和 unpickler 中的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.persistent_load" target="_blank" rel="noopener"><code>persistent_load()</code></a> 方法。</p>
<p>要通过持久化 ID 将外部对象封存，必须在 pickler 中实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.persistent_id" target="_blank" rel="noopener"><code>persistent_id()</code></a> 方法，该方法接受需要被封存的对象作为参数，返回一个 <code>None</code> 或返回该对象的持久化 ID。如果返回 <code>None</code>，该对象会被按照默认方式封存为数据流。如果返回字符串形式的持久化 ID，则会封存这个字符串并加上一个标记，这样 unpickler 才能将其识别为持久化 ID。</p>
<p>要解封外部对象，Unpickler 必须实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.persistent_load" target="_blank" rel="noopener"><code>persistent_load()</code></a> 方法，接受一个持久化 ID 对象作为参数并返回一个引用的对象。</p>
<p>下面是一个全面的例子，展示了如何使用持久化 ID 来封存外部对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Simple example presenting how persistent ID can be used to pickle</span></span><br><span class="line"><span class="comment"># external objects by reference.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># Simple class representing a record in our database.</span></span><br><span class="line">MemoRecord = namedtuple(<span class="string">"MemoRecord"</span>, <span class="string">"key, task"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBPickler</span><span class="params">(pickle.Pickler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">persistent_id</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="comment"># Instead of pickling MemoRecord as a regular class instance, we emit a</span></span><br><span class="line">        <span class="comment"># persistent ID.</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, MemoRecord):</span><br><span class="line">            <span class="comment"># Here, our persistent ID is simply a tuple, containing a tag and a</span></span><br><span class="line">            <span class="comment"># key, which refers to a specific record in the database.</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="string">"MemoRecord"</span>, obj.key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># If obj does not have a persistent ID, return None. This means obj</span></span><br><span class="line">            <span class="comment"># needs to be pickled as usual.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBUnpickler</span><span class="params">(pickle.Unpickler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, file, connection)</span>:</span></span><br><span class="line">        super().__init__(file)</span><br><span class="line">        self.connection = connection</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">persistent_load</span><span class="params">(self, pid)</span>:</span></span><br><span class="line">        <span class="comment"># This method is invoked whenever a persistent ID is encountered.</span></span><br><span class="line">        <span class="comment"># Here, pid is the tuple returned by DBPickler.</span></span><br><span class="line">        cursor = self.connection.cursor()</span><br><span class="line">        type_tag, key_id = pid</span><br><span class="line">        <span class="keyword">if</span> type_tag == <span class="string">"MemoRecord"</span>:</span><br><span class="line">            <span class="comment"># Fetch the referenced record from the database and return it.</span></span><br><span class="line">            cursor.execute(<span class="string">"SELECT * FROM memos WHERE key=?"</span>, (str(key_id),))</span><br><span class="line">            key, task = cursor.fetchone()</span><br><span class="line">            <span class="keyword">return</span> MemoRecord(key, task)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Always raises an error if you cannot return the correct object.</span></span><br><span class="line">            <span class="comment"># Otherwise, the unpickler will think None is the object referenced</span></span><br><span class="line">            <span class="comment"># by the persistent ID.</span></span><br><span class="line">            <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">"unsupported persistent object"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> io</span><br><span class="line">    <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize and populate our database.</span></span><br><span class="line">    conn = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(<span class="string">"CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)"</span>)</span><br><span class="line">    tasks = (</span><br><span class="line">        <span class="string">'give food to fish'</span>,</span><br><span class="line">        <span class="string">'prepare group meeting'</span>,</span><br><span class="line">        <span class="string">'fight with a zebra'</span>,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        cursor.execute(<span class="string">"INSERT INTO memos VALUES(NULL, ?)"</span>, (task,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Fetch the records to be pickled.</span></span><br><span class="line">    cursor.execute(<span class="string">"SELECT * FROM memos"</span>)</span><br><span class="line">    memos = [MemoRecord(key, task) <span class="keyword">for</span> key, task <span class="keyword">in</span> cursor]</span><br><span class="line">    <span class="comment"># Save the records using our custom DBPickler.</span></span><br><span class="line">    file = io.BytesIO()</span><br><span class="line">    DBPickler(file).dump(memos)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Pickled records:"</span>)</span><br><span class="line">    pprint.pprint(memos)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update a record, just for good measure.</span></span><br><span class="line">    cursor.execute(<span class="string">"UPDATE memos SET task='learn italian' WHERE key=1"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load the records from the pickle data stream.</span></span><br><span class="line">    file.seek(<span class="number">0</span>)</span><br><span class="line">    memos = DBUnpickler(file, conn).load()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Unpickled records:"</span>)</span><br><span class="line">    pprint.pprint(memos)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="自定义封存-Dispatch-表"><a href="#自定义封存-Dispatch-表" class="headerlink" title="自定义封存 Dispatch 表"></a>自定义封存 Dispatch 表</h3><p>如果想对某些类进行自定义封存，而又不想在类中增加用于封存的代码，就可以创建带有特殊 dispatch 表的 pickler。</p>
<p>在 <a href="https://docs.python.org/zh-cn/3/library/copyreg.html#module-copyreg" target="_blank" rel="noopener"><code>copyreg</code></a> 模块的 <code>copyreg.dispatch_table</code> 中定义了全局 dispatch 表。因此，可以使用 <code>copyreg.dispatch_table</code> 修改后的副本作为自有 dispatch 表。</p>
<p>例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = io.BytesIO()</span><br><span class="line">p = pickle.Pickler(f)</span><br><span class="line">p.dispatch_table = copyreg.dispatch_table.copy()</span><br><span class="line">p.dispatch_table[SomeClass] = reduce_SomeClass</span><br></pre></td></tr></table></figure>
<p>创建了一个带有自有 dispatch 表的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>pickle.Pickler</code></a> 实例，它可以对 <code>SomeClass</code> 类进行特殊处理。另外，下列代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPickler</span><span class="params">(pickle.Pickler)</span>:</span></span><br><span class="line">    dispatch_table = copyreg.dispatch_table.copy()</span><br><span class="line">    dispatch_table[SomeClass] = reduce_SomeClass</span><br><span class="line">f = io.BytesIO()</span><br><span class="line">p = MyPickler(f)</span><br></pre></td></tr></table></figure>
<p>完成了相同的操作，但所有 <code>MyPickler</code> 的实例都会共用同一份 dispatch 表。使用 <a href="https://docs.python.org/zh-cn/3/library/copyreg.html#module-copyreg" target="_blank" rel="noopener"><code>copyreg</code></a> 模块实现的等效代码是</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">copyreg.pickle(SomeClass, reduce_SomeClass)</span><br><span class="line">f = io.BytesIO()</span><br><span class="line">p = pickle.Pickler(f)</span><br></pre></td></tr></table></figure>
<h3 id="处理有状态的对象"><a href="#处理有状态的对象" class="headerlink" title="处理有状态的对象"></a>处理有状态的对象</h3><blockquote>
<p>下面的示例展示了如何修改类在封存时的行为。其中 <code>TextReader</code> 类打开了一个文本文件，每次调用其 <code>readline()</code> 方法则返回行号和该行的字符。 在封存这个 <code>TextReader</code> 的实例时，<em>除了</em> 文件对象，其他属性都会被保存。 当解封实例时，需要重新打开文件，然后从上次的位置开始继续读取。实现这些功能需要实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a> 方法。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextReader</span>:</span></span><br><span class="line">    <span class="string">"""Print and number lines in a text file."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.file = open(filename)</span><br><span class="line">        self.lineno = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readline</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.lineno += <span class="number">1</span></span><br><span class="line">        line = self.file.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> line.endswith(<span class="string">'\n'</span>):</span><br><span class="line">            line = line[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"%i: %s"</span> % (self.lineno, line)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getstate__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Copy the object's state from self.__dict__ which contains</span></span><br><span class="line">        <span class="comment"># all our instance attributes. Always use the dict.copy()</span></span><br><span class="line">        <span class="comment"># method to avoid modifying the original state.</span></span><br><span class="line">        state = self.__dict__.copy()</span><br><span class="line">        <span class="comment"># Remove the unpicklable entries.</span></span><br><span class="line">        <span class="keyword">del</span> state[<span class="string">'file'</span>]</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setstate__</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        <span class="comment"># Restore instance attributes (i.e., filename and lineno).</span></span><br><span class="line">        self.__dict__.update(state)</span><br><span class="line">        <span class="comment"># Restore the previously opened file's state. To do so, we need to</span></span><br><span class="line">        <span class="comment"># reopen it and read from it until the line count is restored.</span></span><br><span class="line">        file = open(self.filename)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.lineno):</span><br><span class="line">            file.readline()</span><br><span class="line">        <span class="comment"># Finally, save the file.</span></span><br><span class="line">        self.file = file</span><br></pre></td></tr></table></figure>
<p>使用方法如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reader = TextReader(<span class="string">"hello.txt"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reader.readline()</span><br><span class="line"><span class="string">'1: Hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reader.readline()</span><br><span class="line"><span class="string">'2: I am line number two.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_reader = pickle.loads(pickle.dumps(reader))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_reader.readline()</span><br><span class="line"><span class="string">'3: Goodbye!'</span></span><br></pre></td></tr></table></figure>
<h3 id="除了Dispatcher-类型和函数及其他对象自定义规约"><a href="#除了Dispatcher-类型和函数及其他对象自定义规约" class="headerlink" title="除了Dispatcher,类型和函数及其他对象自定义规约"></a>除了Dispatcher,类型和函数及其他对象自定义规约</h3><blockquote>
<p>有时，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 可能不够灵活。 特别是当我们想要基于对象类型以外的其他规则来对封存进行定制，或是当我们想要对函数和类的封存进行定制的时候。</p>
<p>对于那些情况，可能要基于 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 类进行子类化并实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.reducer_override" target="_blank" rel="noopener"><code>reducer_override()</code></a> 方法。 此方法可返回任意的归约元组 (参见 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a>)。 它也可以选择返回 <code>NotImplemented</code> 来回退到传统行为。</p>
<p>如果同时定义了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.reducer_override" target="_blank" rel="noopener"><code>reducer_override()</code></a>，则 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.reducer_override" target="_blank" rel="noopener"><code>reducer_override()</code></a> 方法具有优先权。</p>
</blockquote>
<p><strong>注解</strong>：出于性能理由，可能不会为以下对象调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.reducer_override" target="_blank" rel="noopener"><code>reducer_override()</code></a>: <code>None</code>, <code>True</code>, <code>False</code>, 以及 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset" target="_blank" rel="noopener"><code>frozenset</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#tuple" target="_blank" rel="noopener"><code>tuple</code></a> 的具体实例。</p>
<p>以下是一个简单的例子，其中我们允许封存并重新构建一个给定的类:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    my_attribute = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPickler</span><span class="params">(pickle.Pickler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer_override</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="string">"""Custom reducer for MyClass."""</span></span><br><span class="line">        <span class="keyword">if</span> getattr(obj, <span class="string">"__name__"</span>, <span class="literal">None</span>) == <span class="string">"MyClass"</span>:</span><br><span class="line">            <span class="keyword">return</span> type, (obj.__name__, obj.__bases__,</span><br><span class="line">                          &#123;<span class="string">'my_attribute'</span>: obj.my_attribute&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># For any other object, fallback to usual reduction</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line">f = io.BytesIO()</span><br><span class="line">p = MyPickler(f)</span><br><span class="line">p.dump(MyClass)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> MyClass</span><br><span class="line"></span><br><span class="line">unpickled_class = pickle.loads(f.getvalue())</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> isinstance(unpickled_class, type)</span><br><span class="line"><span class="keyword">assert</span> unpickled_class.__name__ == <span class="string">"MyClass"</span></span><br><span class="line"><span class="keyword">assert</span> unpickled_class.my_attribute == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="外部缓冲区"><a href="#外部缓冲区" class="headerlink" title="外部缓冲区"></a>外部缓冲区</h3><p>在某些场景中，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块会被用来传输海量的数据。 因此，最小化内存复制次数以保证性能和节省资源是很重要的。 但是 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块的正常运作会将图类对象结构转换为字节序列流，因此在本质上就要从封存流中来回复制数据。</p>
<p>如果 <em>provider</em> (待传输对象类型的实现) 和 <em>consumer</em> (通信系统的实现) 都支持 pickle 第 5 版或更高版本所提供的外部传输功能，则此约束可以被撤销。</p>
<h3 id="提供方API"><a href="#提供方API" class="headerlink" title="提供方API"></a>提供方API</h3><p>大的待封存数据对象必须实现协议 5 及以上版本专属的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce_ex__" target="_blank" rel="noopener"><code>__reduce_ex__()</code></a> 方法，该方法将为任意大的数据返回一个 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 实例（而不是 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 对象等）。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 对象会 <em>表明</em> 底层缓冲区可被用于外部数据传输。 那些对象仍将保持与 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块的正常用法兼容。 但是，使用方也可以选择告知 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 它们将自行处理那些缓冲区。</p>
<h3 id="使用方API"><a href="#使用方API" class="headerlink" title="使用方API"></a>使用方API</h3><p>当序列化一个对象图时，通信系统可以启用对所生成 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 对象的定制处理。</p>
<p>发送端需要传递 <em>buffer_callback</em> 参数到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> (或是到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dump" target="_blank" rel="noopener"><code>dump()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dumps" target="_blank" rel="noopener"><code>dumps()</code></a> 函数)，该回调函数将在封存对象图时附带每个所生成的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 被调用。 由 <em>buffer_callback</em> 所累积的缓冲区的数据将不会被拷贝到 pickle 流，而是仅插入一个简单的标记。</p>
<p>接收端需要传递 <em>buffers</em> 参数到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> (或是到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.load" target="_blank" rel="noopener"><code>load()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.loads" target="_blank" rel="noopener"><code>loads()</code></a> 函数)，其值是一个由缓冲区组成的可迭代对象，它会被传递给 <em>buffer_callback</em>。 该可迭代对象应当按其被传递给 <em>buffer_callback</em> 时的顺序产生缓冲区。 这些缓冲区将提供对象重构造器所期望的数据，对这些数据的封存产生了原本的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 对象。</p>
<p>在发送端和接受端之间，通信系统可以自由地实现它自己用于外部缓冲区的传输机制。 潜在的优化包括使用共享内存或基于特定数据类型的压缩等。</p>
<p>实例:下面是一个小例子，在其中我们实现了一个 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 的子类，能够用于外部缓冲区封存:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroCopyByteArray</span><span class="params">(bytearray)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce_ex__</span><span class="params">(self, protocol)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> protocol &gt;= <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> type(self)._reconstruct, (PickleBuffer(self),), <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># PickleBuffer is forbidden with pickle protocols &lt;= 4.</span></span><br><span class="line">            <span class="keyword">return</span> type(self)._reconstruct, (bytearray(self),)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_reconstruct</span><span class="params">(cls, obj)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> memoryview(obj) <span class="keyword">as</span> m:</span><br><span class="line">            <span class="comment"># Get a handle over the original buffer object</span></span><br><span class="line">            obj = m.obj</span><br><span class="line">            <span class="keyword">if</span> type(obj) <span class="keyword">is</span> cls:</span><br><span class="line">                <span class="comment"># Original buffer object is a ZeroCopyByteArray, return it</span></span><br><span class="line">                <span class="comment"># as-is.</span></span><br><span class="line">                <span class="keyword">return</span> obj</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> cls(obj)</span><br></pre></td></tr></table></figure>
<p>重构造器 (<code>_reconstruct</code> 类方法) 会在缓冲区的提供对象具有正确类型时返回该对象。 在此小示例中这是模拟零拷贝行为的便捷方式。</p>
<p>在使用方，我们可以按通常方式封存那些对象，它们在反序列化时将提供原始对象的一个副本:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = ZeroCopyByteArray(<span class="string">b"abc"</span>)</span><br><span class="line">data = pickle.dumps(b, protocol=<span class="number">5</span>)</span><br><span class="line">new_b = pickle.loads(data)</span><br><span class="line">print(b == new_b)  <span class="comment"># True</span></span><br><span class="line">print(b <span class="keyword">is</span> new_b)  <span class="comment"># False: a copy was made</span></span><br></pre></td></tr></table></figure>
<p>但是如果我们传入 <em>buffer_callback</em> 然后在反序列化时给回累积的缓冲区，我们就能够取回原始对象:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = ZeroCopyByteArray(<span class="string">b"abc"</span>)</span><br><span class="line">buffers = []</span><br><span class="line">data = pickle.dumps(b, protocol=<span class="number">5</span>, buffer_callback=buffers.append)</span><br><span class="line">new_b = pickle.loads(data, buffers=buffers)</span><br><span class="line">print(b == new_b)  <span class="comment"># True</span></span><br><span class="line">print(b <span class="keyword">is</span> new_b)  <span class="comment"># True: no copy was made</span></span><br></pre></td></tr></table></figure>
<p>这个例子受限于 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 会自行分配内存这一事实：你无法基于另一个对象的内存创建 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 的实例。 但是，第三方数据类型例如 NumPy 数组则没有这种限制，允许在单独进程或系统间传输时使用零拷贝的封存（或是尽可能少地拷贝） 。</p>
<blockquote>
<p>参见：<a href="https://www.python.org/dev/peps/pep-0574" target="_blank" rel="noopener"><strong>PEP 574</strong></a> – 带有外部数据缓冲区的 pickle 协议 5</p>
</blockquote>
<h3 id="限制全局变量"><a href="#限制全局变量" class="headerlink" title="限制全局变量"></a>限制全局变量</h3><p>默认情况下，解封将会导入在 pickle 数据中找到的任何类或函数。 对于许多应用来说，此行为是不可接受的，因为它会允许解封器导入并发起调用任意代码。 只须考虑当这个手工构建的 pickle 数据流被加载时会做什么:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.loads(<span class="string">b"cos\nsystem\n(S'echo hello world'\ntR."</span>)</span><br><span class="line">hello world</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在这个例子里，解封器导入 <a href="https://docs.python.org/zh-cn/3/library/os.html#os.system" target="_blank" rel="noopener"><code>os.system()</code></a> 函数然后应用字符串参数 “echo hello world”。 虽然这个例子不具攻击性，但是不难想象别人能够通过此方式对你的系统造成损害。</p>
<p>出于这样的理由，你可能会希望通过定制 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.find_class" target="_blank" rel="noopener"><code>Unpickler.find_class()</code></a> 来控制要解封的对象。 与其名称所提示的不同，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.find_class" target="_blank" rel="noopener"><code>Unpickler.find_class()</code></a> 会在执行对任何全局对象（例如一个类或一个函数）的请求时被调用。 因此可以完全禁止全局对象或是将它们限制在一个安全的子集中。</p>
<p>下面的例子是一个解封器，它只允许某一些安全的来自 <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a> 模块的类被加载:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">safe_builtins = &#123;</span><br><span class="line">    <span class="string">'range'</span>,</span><br><span class="line">    <span class="string">'complex'</span>,</span><br><span class="line">    <span class="string">'set'</span>,</span><br><span class="line">    <span class="string">'frozenset'</span>,</span><br><span class="line">    <span class="string">'slice'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestrictedUnpickler</span><span class="params">(pickle.Unpickler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_class</span><span class="params">(self, module, name)</span>:</span></span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">"builtins"</span> <span class="keyword">and</span> name <span class="keyword">in</span> safe_builtins:</span><br><span class="line">            <span class="keyword">return</span> getattr(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">"global '%s.%s' is forbidden"</span> %</span><br><span class="line">                                     (module, name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restricted_loads</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""Helper function analogous to pickle.loads()."""</span></span><br><span class="line">    <span class="keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</span><br></pre></td></tr></table></figure>
<p>我们这个解封器的一个示例用法所达成的目标:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>restricted_loads(pickle.dumps([<span class="number">1</span>, <span class="number">2</span>, range(<span class="number">15</span>)]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, range(<span class="number">0</span>, <span class="number">15</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>restricted_loads(<span class="string">b"cos\nsystem\n(S'echo hello world'\ntR."</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">pickle.UnpicklingError: <span class="keyword">global</span> <span class="string">'os.system'</span> <span class="keyword">is</span> forbidden</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>restricted_loads(<span class="string">b'cbuiltins\neval\n'</span></span><br><span class="line"><span class="meta">... </span>                 <span class="string">b'(S\'getattr(__import__("os"), "system")'</span></span><br><span class="line"><span class="meta">... </span>                 <span class="string">b'("echo hello world")\'\ntR.'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">pickle.UnpicklingError: <span class="keyword">global</span> <span class="string">'builtins.eval'</span> <span class="keyword">is</span> forbidden</span><br></pre></td></tr></table></figure>
<p>正如我们这个例子所显示的，对于允许解封的对象你必须要保持谨慎。 因此如果要保证安全，你可以考虑其他选择例如 <a href="https://docs.python.org/zh-cn/3/library/xmlrpc.client.html#module-xmlrpc.client" target="_blank" rel="noopener"><code>xmlrpc.client</code></a> 中的编组 API 或是第三方解决方案。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>较新版本的 pickle 协议（第 2 版或更高）具有针对某些常见特性和内置类型的高效二进制编码格式。 此外，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块还拥有一个以 C 编写的透明优化器。</p>
<p>实例</p>
<p>对于最简单的代码，请使用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dump" target="_blank" rel="noopener"><code>dump()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.load" target="_blank" rel="noopener"><code>load()</code></a> 函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="comment"># An arbitrary collection of objects supported by pickle.</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'a'</span>: [<span class="number">1</span>, <span class="number">2.0</span>, <span class="number">3</span>, <span class="number">4</span>+<span class="number">6j</span>],</span><br><span class="line">    <span class="string">'b'</span>: (<span class="string">"character string"</span>, <span class="string">b"byte string"</span>),</span><br><span class="line">    <span class="string">'c'</span>: &#123;<span class="literal">None</span>, <span class="literal">True</span>, <span class="literal">False</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data.pickle'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># Pickle the 'data' dictionary using the highest protocol available.</span></span><br><span class="line">    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)</span><br></pre></td></tr></table></figure>
<p>以下示例读取之前封存的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data.pickle'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># The protocol version used is detected automatically, so we do not</span></span><br><span class="line">    <span class="comment"># have to specify it.</span></span><br><span class="line">    data = pickle.load(f)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>pickle</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library filecmp</title>
    <url>/2020/01/22/python-standard-library-filecmp/</url>
    <content><![CDATA[<h1 id="python-标准库-filecmp"><a href="#python-标准库-filecmp" class="headerlink" title="python 标准库 filecmp"></a>python 标准库 filecmp</h1><p>每日一词:</p>
<blockquote>
<p>病毒</p>
<p> germs、bacteria 還是 viruses </p>
<h3 id="Germ-微生物"><a href="#Germ-微生物" class="headerlink" title="Germ: 微生物"></a><strong>Germ</strong>: 微生物</h3><h3 id="Bacterium-這是「細菌」的意思，它是微小且單細胞的有機體。注意喔這個字的單數是-bacterium，複數要寫作-bacteria"><a href="#Bacterium-這是「細菌」的意思，它是微小且單細胞的有機體。注意喔這個字的單數是-bacterium，複數要寫作-bacteria" class="headerlink" title="Bacterium: 這是「細菌」的意思，它是微小且單細胞的有機體。注意喔這個字的單數是 bacterium，複數要寫作 bacteria"></a><strong>Bacterium</strong>: 這是「細菌」的意思，它是微小且單細胞的有機體。注意喔這個字的單數是 bacterium，複數要寫作 bacteria</h3><h3 id="Virus-病菌"><a href="#Virus-病菌" class="headerlink" title="Virus:病菌"></a><strong>Virus</strong>:病菌</h3><p> 茲卡病毒（Zika virus）、諾羅病毒（Norovirus）、愛滋病毒（Human Immunodeficiency Virus，縮寫即是 HIV）、輪狀病毒（Rotavirus）等。 </p>
</blockquote>
<p><img src="http://a1.att.hudong.com/20/29/01300000333999124281293520625.jpg" alt></p>
<a id="more"></a>
<p>继续学习关于文件操作的模块 filecmp</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p> <strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/filecmp.py" target="_blank" rel="noopener">Lib/filecmp.py</a> </p>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#module-filecmp" target="_blank" rel="noopener"><code>filecmp</code></a> 模块定义了用于比较文件及目录的函数，并且可以选取多种关于时间和准确性的折衷方案。对于文件的比较，另见 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#module-difflib" target="_blank" rel="noopener"><code>difflib</code></a> 模块。 </p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p> <a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#module-filecmp" target="_blank" rel="noopener"><code>filecmp</code></a> 模块定义了如下函数： </p>
<ul>
<li><code>filecmp.`</code>cmp`(<em>f1</em>, <em>f2</em>, <em>shallow=True</em>) </li>
<li><code>filecmp.`</code>cmpfiles`(<em>dir1</em>, <em>dir2</em>, <em>common</em>, <em>shallow=True</em>) </li>
<li><code>filecmp.`</code>clear_cache`() </li>
</ul>
<h2 id="dircmp-类"><a href="#dircmp-类" class="headerlink" title="dircmp 类"></a><a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.dircmp" target="_blank" rel="noopener"><code>dircmp</code></a> 类</h2><p> <em>class</em> <code>filecmp.`</code>dircmp`(<em>a</em>, <em>b</em>, <em>ignore=None</em>, <em>hide=None</em>) </p>
<p>创建一个用于比较目录 <em>a</em> 和 <em>b</em> 的新的目录比较对象。 <em>ignore</em> 是需要忽略的文件名列表，且默认为 <a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.DEFAULT_IGNORES" target="_blank" rel="noopener"><code>filecmp.DEFAULT_IGNORES</code></a> 。 <em>hide</em> 是需要隐藏的文件名列表，且默认为 <code>[os.curdir, os.pardir]</code> 。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.dircmp" target="_blank" rel="noopener"><code>dircmp</code></a> 类如 <a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.cmp" target="_blank" rel="noopener"><code>filecmp.cmp()</code></a> 中所描述的那样对文件进行 <em>shallow</em> 比较。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.dircmp" target="_blank" rel="noopener"><code>dircmp</code></a> 类提供以下方法：</p>
<ul>
<li><p><code>report</code>()</p>
<p>将 <em>a</em> 与 <em>b</em> 之间的比较打印（到 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdout" target="_blank" rel="noopener"><code>sys.stdout</code></a> ）。</p>
</li>
<li><p><code>report_partial_closure</code>()</p>
<p>打印 <em>a</em> 与 <em>b</em> 及共同直接子目录的比较结果。</p>
</li>
<li><p><code>report_full_closure</code>()</p>
<p>打印 <em>a</em> 与 <em>b</em> 及共同子目录比较结果（递归地）。</p>
</li>
</ul>
<p><a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.dircmp" target="_blank" rel="noopener"><code>dircmp</code></a> 类提供了一些有趣的属性，用以得到关于参与比较的目录树的各种信息。</p>
<p>需要注意，通过 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getattr__" target="_blank" rel="noopener"><code>__getattr__()</code></a> 钩子，所有的属性将会惰性求值，因此如果只使用那些计算简便的属性，将不会有速度损失。</p>
<ul>
<li><p><code>left</code></p>
<p>目录 <em>a</em> 。</p>
</li>
<li><p><code>right</code></p>
<p>目录 <em>b</em> 。</p>
</li>
<li><p><code>left_list</code></p>
<p>经 <em>hide</em> 和 <em>ignore</em> 过滤，目录 <em>a</em> 中的文件与子目录。</p>
</li>
<li><p><code>right_list</code></p>
<p>经 <em>hide</em> 和 <em>ignore</em> 过滤，目录 <em>b</em> 中的文件与子目录。</p>
</li>
<li><p><code>common</code></p>
<p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的文件和子目录。</p>
</li>
<li><p><code>left_only</code></p>
<p>仅在目录 <em>a</em> 中的文件和子目录。</p>
</li>
<li><p><code>right_only</code></p>
<p>仅在目录 <em>b</em> 中的文件和子目录。</p>
</li>
<li><p><code>common_dirs</code></p>
<p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的子目录。</p>
</li>
<li><p><code>common_files</code></p>
<p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的文件。</p>
</li>
<li><p><code>common_funny</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中类型不同的名字，或者那些 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 报告错误的名字。</p>
</li>
<li><p><code>same_files</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中使用类的文件比较操作符相等的文件。</p>
</li>
<li><p><code>diff_files</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中，根据类的文件比较操作符判定内容不等的文件。</p>
</li>
<li><p><code>funny_files</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中无法比较的文件。</p>
</li>
<li><p><code>subdirs</code></p>
<p>一个将 <a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.dircmp.common_dirs" target="_blank" rel="noopener"><code>common_dirs</code></a> 中名称映射为 <a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.dircmp" target="_blank" rel="noopener"><code>dircmp</code></a> 对象的字典。</p>
</li>
</ul>
<p><code>filecmp.`</code>DEFAULT_IGNORES` </p>
<p>下面是一个简单的例子，使用 <code>subdirs</code> 属性递归搜索两个目录以显示公共差异文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> filecmp <span class="keyword">import</span> dircmp</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_diff_files</span><span class="params">(dcmp)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> name <span class="keyword">in</span> dcmp.diff_files:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"diff_file %s found in %s and %s"</span> % (name, dcmp.left,</span><br><span class="line"><span class="meta">... </span>              dcmp.right))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> sub_dcmp <span class="keyword">in</span> dcmp.subdirs.values():</span><br><span class="line"><span class="meta">... </span>        print_diff_files(sub_dcmp)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dcmp = dircmp(<span class="string">'dir1'</span>, <span class="string">'dir2'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_diff_files(dcmp)</span><br></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> os,sys</span><br><span class="line"><span class="keyword">import</span> filecmp</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    校验源与备份目录的差异</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line">holderlist = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compareme</span><span class="params">(dir1,dir2)</span>:</span>    <span class="comment">#递归获取更新项函数</span></span><br><span class="line">    dircomp = filecmp.dircmp(dir1,dir2)</span><br><span class="line">    only_in_one = dircomp.left_only      <span class="comment">#源目录新文件或目录 </span></span><br><span class="line">    diff_in_one = dircomp.diff_files     <span class="comment">#不匹配文件，源目录文件已发生变化</span></span><br><span class="line">    dirpath = os.path.abspath(dir1)      <span class="comment">#定义源目录绝对路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#将更新文件或目录追加到holderlist</span></span><br><span class="line">    [ holderlist.append(os.path.abspath(os.path.join(dir1,x))) <span class="keyword">for</span> x <span class="keyword">in</span> only_in_one ]</span><br><span class="line">    [ holderlist.append(os.path.abspath(os.path.join(dir1,x))) <span class="keyword">for</span> x <span class="keyword">in</span> diff_in_one ]</span><br><span class="line">    <span class="keyword">if</span> len(dircomp.common_dirs) &gt; <span class="number">0</span>:  <span class="comment">#判断是否存在相同子目录，以便递归</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> dircomp.common_dirs:   <span class="comment">#递归子目录</span></span><br><span class="line">            compareme(os.path.abspath(os.path.join(dir1,item)),os.path.abspath(os.path.join(dir2,item)))</span><br><span class="line">    <span class="keyword">return</span> holderlist</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">2</span>:    <span class="comment">#输入源目录与备份目录</span></span><br><span class="line">        dir1 = sys.argv[<span class="number">1</span>]</span><br><span class="line">        dir2 = sys.argv[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        print(<span class="string">'Usage:'</span>,sys.argv[<span class="number">0</span>],<span class="string">'datadir backdir'</span>)</span><br><span class="line">        sys.exit()</span><br><span class="line">    source_files = compareme(dir1,dir2)    <span class="comment">#对比源目录与备份目录</span></span><br><span class="line">    dir1 = os.path.abspath(dir1)    <span class="comment">#取绝对路径后，后面不会自动加上'/'</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> dir2.endswith(<span class="string">'/'</span>):</span><br><span class="line">        dir2 = dir2+<span class="string">'/'</span>            <span class="comment">#备份目录路径加'/'</span></span><br><span class="line">    </span><br><span class="line">    dir2 = os.path.abspath(dir2)</span><br><span class="line">    destination_files = []</span><br><span class="line">    createdir_bool = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> source_files:     <span class="comment">#遍历返回的差异文件或目录清单</span></span><br><span class="line">        destination_dir = re.sub(dir1,dir2,item)    <span class="comment">#将源目录差异路径清单对应替换成备份目录,即需要在dir2中创建的差异目录和文件</span></span><br><span class="line">        destination_files.append(destination_dir)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(item):      <span class="comment">#如果差异路径为目录且不存在，则在备份目录中创建</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(destination_dir):</span><br><span class="line">                os.makedirs(destination_dir)</span><br><span class="line">                createdir_bool = <span class="literal">True</span>   <span class="comment">#再次调用copareme函数标记</span></span><br><span class="line">    <span class="keyword">if</span> createdir_bool :       <span class="comment">#重新调用compareme函数，重新遍历新创建目录的内容</span></span><br><span class="line">        destination_files = []</span><br><span class="line">        source_files = []</span><br><span class="line">        source_files = compareme(dir1,dir2)    <span class="comment">#调用compareme函数</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> source_files:           <span class="comment">#获取源目录差异路径清单，对应替换成备份目录</span></span><br><span class="line">            destination_dir = re.sub(dir1,dir2,item)</span><br><span class="line">            destination_files.append(destination_dir)</span><br><span class="line">            </span><br><span class="line">    print(<span class="string">'update item:'</span>)</span><br><span class="line">    print(source_files)     <span class="comment">#输出更新项列表清单</span></span><br><span class="line">    copy_pair = zip(source_files,destination_files)  <span class="comment">#将源目录与备份目录文件清单拆分成元组</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> copy_pair:</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(item[<span class="number">0</span>]):        <span class="comment">#判断是否为文件，是则进行复制操作</span></span><br><span class="line">            shutil.copyfile(item[<span class="number">0</span>],item[<span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span> :</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>filecmp</tag>
      </tags>
  </entry>
  <entry>
    <title>Understand Python GIL</title>
    <url>/2020/01/19/Understand-Python-GIL/</url>
    <content><![CDATA[<h1 id="python-标准库-threading"><a href="#python-标准库-threading" class="headerlink" title="python 标准库 threading"></a>python 标准库 threading</h1><p>每日一词:</p>
<blockquote>
<p>US[‘weðər]  UK[‘weðə(r)]</p>
<p>n.天气；气象；气象预报</p>
<p>v.变形；经受住</p>
<p>气候；天气预报；风化</p>
<p>给大家推荐一部电影: 气象先生</p>
</blockquote>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200119_weather_man.jpg?raw=tru" alt></p>
<blockquote>
<p>This shit life,we must chuck some things</p>
</blockquote>
<a id="more"></a>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/threading.py" target="_blank" rel="noopener">Lib/threading.py</a></p>
<h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><ul>
<li><p><code>threading.active_count</code>()</p>
<p>返回当前存活的线程类 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>Thread</code></a> 对象。返回的计数等于 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a> 返回的列表长度。</p>
</li>
<li><p><code>threading.current_thread</code>()</p>
<p>返回当前对应调用者的控制线程的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>Thread</code></a> 对象。如果调用者的控制线程不是利用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#module-threading" target="_blank" rel="noopener"><code>threading</code></a> 创建，会返回一个功能受限的虚拟线程对象。</p>
</li>
<li><p><code>threading.excepthook</code>(<em>args</em>, <em>/</em>)</p>
<p>参数可以是下面任意一种类型</p>
<ul>
<li><em>exc_type</em>: 异常类型</li>
<li><em>exc_value</em>: 异常值，可以是 <code>None</code>.</li>
<li><em>exc_traceback</em>: 异常回溯，可以是 <code>None</code>.</li>
<li><em>thread</em>: 线程跑出的异常 可以是<code>None</code>.</li>
</ul>
</li>
<li><p><code>threading.get_ident</code>()</p>
<p>返回当前线程的 “线程标识符”。它是一个非零的整数。它的值没有直接含义，主要是用作 magic cookie，比如作为含有线程相关数据的字典的索引。线程标识符可能会在线程退出，新线程创建时被复用。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>threading.get_native_id</code>()</p>
<p>返回内核分配给当前线程的原生集成线程 ID。 这是一个非负整数。 它的值可被用来在整个系统中唯一地标识这个特定线程（直到线程终结，在那之后该值可能会被 OS 回收再利用）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows, FreeBSD, Linux, macOS, OpenBSD, NetBSD, AIX。<em>3.8 新版功能.</em></p>
</li>
<li><p><code>threading.enumerate</code>()</p>
<p>以列表形式返回当前所有存活的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>Thread</code></a> 对象。 该列表包含守护线程，<a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.current_thread" target="_blank" rel="noopener"><code>current_thread()</code></a> 创建的虚拟线程对象和主线程。它不包含已终结的线程和尚未开始的线程。</p>
</li>
<li><p><code>threading.main_thread</code>()</p>
<p>返回主 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>Thread</code></a> 对象。一般情况下，主线程是Python解释器开始时创建的线程。<em>3.4 新版功能.</em></p>
</li>
<li><p><code>threading.settrace</code>(<em>func</em>)</p>
<p>为所有 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#module-threading" target="_blank" rel="noopener"><code>threading</code></a> 模块开始的线程设置追踪函数。在每个线程的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法被调用前，<em>func</em> 会被传递给 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.settrace" target="_blank" rel="noopener"><code>sys.settrace()</code></a> 。</p>
</li>
<li><p><code>threading.setprofile</code>(<em>func</em>)</p>
<p>为所有 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#module-threading" target="_blank" rel="noopener"><code>threading</code></a> 模块开始的线程设置性能测试函数。在每个线程的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法被调用前，<em>func</em> 会被传递给 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.setprofile" target="_blank" rel="noopener"><code>sys.setprofile()</code></a> 。</p>
</li>
<li><p><code>threading.stack_size</code>([<em>size</em>])</p>
<p>返回创建线程时用的堆栈大小。可选参数 <em>size</em> 指定之后新建的线程的堆栈大小，而且一定要是0（根据平台或者默认配置）或者最小是32,768(32KiB)的一个正整数。如果 <em>size</em> 没有指定，默认是0。如果不支持改变线程堆栈大小，会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 错误。如果指定的堆栈大小不合法，会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 错误并且不会修改堆栈大小。32KiB是当前最小的能保证解释器有足够堆栈空间的堆栈大小。需要注意的是部分平台对于堆栈大小会有特定的限制，例如要求大于32KiB的堆栈大小或者需要根据系统内存页面的整数倍进行分配 - 应当查阅平台文档有关详细信息（4KiB页面比较普遍，在没有更具体信息的情况下，建议的方法是使用4096的倍数作为堆栈大小）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">适用于</a>: Windows，具有 POSIX 线程的系统。</p>
</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><code>threading.TIMEOUT_MAX</code><a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.TIMEOUT_MAX" target="_blank" rel="noopener">¶</a></p>
<p>  阻塞函数（ <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>Lock.acquire()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock.acquire" target="_blank" rel="noopener"><code>RLock.acquire()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>Condition.wait()</code></a>, …）中形参 <em>timeout</em> 允许的最大值。传入超过这个值的 timeout 会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a> 异常。</p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="线程本地数据"><a href="#线程本地数据" class="headerlink" title="线程本地数据"></a>线程本地数据</h3><p>线程本地数据是特定线程的数据。管理线程本地数据，只需要创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.local" target="_blank" rel="noopener"><code>local</code></a> （或者一个子类型）的实例并在实例中储存属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mydata = threading.local()</span><br><span class="line">mydata.x = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在不同的线程中，实例的值会不同。</p>
<ul>
<li><p><em>class</em> <code>threading.local</code></p>
<p>一个代表线程本地数据的类。更多相关细节和大量示例，参见 <code>_threading_local</code> 模块的文档。</p>
</li>
</ul>
<h3 id="线程对象"><a href="#线程对象" class="headerlink" title="线程对象"></a>线程对象</h3><p>当线程对象一但被创建，其活动一定会因调用线程的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.start" target="_blank" rel="noopener"><code>start()</code></a> 方法开始。这会在独立的控制线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法。</p>
<p>一旦线程活动开始，该线程会被认为是 ‘存活的’ 。当它的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法终结了（不管是正常的还是抛出未被处理的异常），就不是’存活的’。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.is_alive" target="_blank" rel="noopener"><code>is_alive()</code></a> 方法用于检查线程是否存活。</p>
<p>其他线程可以调用一个线程的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 方法。这会阻塞调用该方法的线程，直到被调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 方法的线程终结。</p>
<p>线程有名字。名字可以传递给构造函数，也可以通过 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.name" target="_blank" rel="noopener"><code>name</code></a> 属性读取或者修改。</p>
<p>如果运行线程中的 <code>run()</code>抛出了异常, <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.excepthook" target="_blank" rel="noopener">threading.excepthook()`</a> 方法就会被调用,默认情况下,忽略 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a>.</p>
<p>一个线程可以被标记成一个“守护线程”。 这个标志的意义是，当剩下的线程都是守护线程时，整个 Python 程序将会退出。 初始值继承于创建线程。 这个标志可以通过 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.daemon" target="_blank" rel="noopener"><code>daemon</code></a> 特征属性或者 <em>daemon</em> 构造器参数来设置。</p>
<blockquote>
<p>守护线程在程序关闭时会突然关闭。他们的资源（例如已经打开的文档，数据库事务等等）可能没有被正确释放。如果你想你的线程正常停止，设置他们成为非守护模式并且使用合适的信号机制，例如： <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event" target="_blank" rel="noopener"><code>Event</code></a>。</p>
</blockquote>
<p>有个 “主线程” 对象；这对应Python程序里面初始的控制线程。它不是一个守护线程。</p>
<p>“虚拟线程对象” 是可以被创建的。这些是对应于“外部线程”的线程对象，它们是在线程模块外部启动的控制线程，例如直接来自C代码。虚拟线程对象功能受限；他们总是被认为是存活的和守护模式，不能被 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 。因为无法检测外来线程的终结，它们永远不会被删除。</p>
<p><em>class</em> <code>threading.Thread</code>(<em>group=None</em>, <em>target=None</em>, <em>name=None</em>, <em>args=()</em>, <em>kwargs={}</em>, <em>**, </em>daemon=None*)</p>
<p>调用这个构造函数时，必需带有关键字参数。参数如下：</p>
<p><em>group</em> 应该为 <code>None</code>；为了日后扩展 <code>ThreadGroup</code> 类实现而保留。</p>
<p><em>target</em> 是用于 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法调用的可调用对象。默认是 <code>None</code>，表示不需要调用任何方法。</p>
<p><em>name</em> 是线程名称。默认情况下，由 “Thread-<em>N</em>“ 格式构成一个唯一的名称，其中 <em>N</em> 是小的十进制数。</p>
<p><em>args</em> 是用于调用目标函数的参数元组。默认是 <code>()</code>。</p>
<p><em>kwargs</em> 是用于调用目标函数的关键字参数字典。默认是 <code>{}</code>。</p>
<ul>
<li><p><code>start</code>()</p>
<p>开始线程活动。它在一个线程里最多只能被调用一次。它安排对象的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法在一个独立的控制进程中调用。如果同一个线程对象中调用这个方法的次数大于一次，会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 。</p>
</li>
<li><p><code>run</code>()</p>
<p>代表线程活动的方法。你可以在子类型里重载这个方法。 标准的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法会对作为 <em>target</em> 参数传递给该对象构造器的可调用对象（如果存在）发起调用，并附带从 <em>args</em> 和 <em>kwargs</em> 参数分别获取的位置和关键字参数。</p>
</li>
<li><p><code>join</code>(<em>timeout=None</em>)</p>
<p>等待，直到线程终结。这会阻塞调用这个方法的线程，直到被调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 的线程终结 – 不管是正常终结还是抛出未处理异常 – 或者直到发生超时，超时选项是可选的。当 <em>timeout</em> 参数存在而且不是 <code>None</code> 时，它应该是一个用于指定操作超时的以秒为单位的浮点数（或者分数）。因为 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 总是返回 <code>None</code> ，所以你一定要在 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 后调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.is_alive" target="_blank" rel="noopener"><code>is_alive()</code></a> 才能判断是否发生超时 – 如果线程仍然存货，则 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 超时。当 <em>timeout</em> 参数不存在或者是 <code>None</code> ，这个操作会阻塞直到线程终结。一个线程可以被 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 很多次。如果尝试加入当前线程会导致死锁， <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 会引起 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常。如果尝试 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 一个尚未开始的线程，也会抛出相同的异常。</p>
</li>
<li><p><code>name</code></p>
<p>只用于识别的字符串。它没有语义。多个线程可以赋予相同的名称。 初始名称由构造函数设置。</p>
</li>
<li><p><code>getName</code>()</p>
</li>
<li><p><code>setName</code>()</p>
<p>旧的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.name" target="_blank" rel="noopener"><code>name</code></a> 取值/设值 API；直接当做特征属性使用它。</p>
</li>
<li><p><code>ident</code></p>
<p>这个线程的 ‘线程标识符’，如果线程尚未开始则为 <code>None</code> 。这是个非零整数。参见 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.get_ident" target="_blank" rel="noopener"><code>get_ident()</code></a> 函数。当一个线程退出而另外一个线程被创建，线程标识符会被复用。即使线程退出后，仍可得到标识符。</p>
</li>
<li><p><strong>native_id</strong></p>
<p>内部生成的线程id,一个非负的整数,如果为<code>None</code>意味着线程还没有启动。</p>
</li>
<li><p><code>is_alive</code>()</p>
<p>返回线程是否存活。当 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法刚开始直到 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法刚结束，这个方法返回 <code>True</code> 。模块函数 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a> 返回包含所有存活线程的列表。</p>
</li>
<li><p><code>daemon</code></p>
<p>一个表示这个线程是（True）否（False）守护线程的布尔值。一定要在调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.start" target="_blank" rel="noopener"><code>start()</code></a> 前设置好，不然会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 。初始值继承于创建线程；主线程不是守护线程，因此主线程创建的所有线程默认都是 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.daemon" target="_blank" rel="noopener"><code>daemon</code></a> = <code>False</code>。当没有存活的非守护线程时，整个Python程序才会退出。</p>
</li>
<li><p><code>isDaemon</code>()</p>
</li>
<li><p><code>setDaemon</code>()</p>
<p>旧的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.name" target="_blank" rel="noopener"><code>name</code></a> 取值/设值 API；建议直接当做特征属性使用它。</p>
</li>
</ul>
<p><strong>CPython implementation detail:</strong> CPython下，因为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-global-interpreter-lock" target="_blank" rel="noopener">Global Interpreter Lock</a>，一个时刻只有一个线程可以执行Python代码（尽管如此，某些性能导向的库可能会克服这个限制）。如果你想让你的应用更好的利用多核计算机的计算性能，推荐你使用 <a href="https://docs.python.org/zh-cn/3.8/library/multiprocessing.html#module-multiprocessing" target="_blank" rel="noopener"><code>multiprocessing</code></a> 或者 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>concurrent.futures.ProcessPoolExecutor</code></a> 。但是如果你想同时运行多个I/O绑定任务，线程仍然是一个合适的模型。</p>
<h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3><p>原始锁是一个在锁定时不属于特定线程的同步基元组件。在Python中，它是能用的最低级的同步基元组件，由 <a href="https://docs.python.org/zh-cn/3.8/library/_thread.html#module-_thread" target="_blank" rel="noopener"><code>_thread</code></a> 扩展模块直接实现。</p>
<p>原始锁处于 “锁定” 或者 “非锁定” 两种状态之一。它被创建时为非锁定状态。它有两个基本方法， <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> 。当状态为非锁定时， <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 将状态改为 锁定 并立即返回。当状态是锁定时， <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 将阻塞至其他线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> 将其改为非锁定状态，然后 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 调用重置其为锁定状态并返回。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> 只在锁定状态下调用； 它将状态改为非锁定并立即返回。如果尝试释放一个非锁定的锁，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>  异常。</p>
<p>锁同样支持 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#with-locks" target="_blank" rel="noopener">上下文管理协议</a>。</p>
<p>当多个线程在 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 等待状态转变为未锁定被阻塞，然后 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> 重置状态为未锁定时，只有一个线程能继续执行；至于哪个等待线程继续执行没有定义，并且会根据实现而不同。</p>
<p>所有方法的执行都是原子性的。</p>
<p><em>class</em> <code>threading.Lock</code></p>
<p>实现原始锁对象的类。一旦一个线程获得一个锁，会阻塞随后尝试获得锁的线程，直到它被释放；任何线程都可以释放它。</p>
<p>需要注意的是 <code>Lock</code> 其实是一个工厂函数，返回平台支持的具体锁类中最有效的版本的实例。</p>
<ul>
<li><p><code>acquire</code>(<em>blocking=True</em>, <em>timeout=-1</em>)</p>
<p>可以阻塞或非阻塞地获得锁。当调用时参数 <em>blocking</em> 设置为 <code>True</code> （缺省值），阻塞直到锁被释放，然后将锁锁定并返回 <code>True</code> 。在参数 <em>blocking</em> 被设置为 <code>False</code> 的情况下调用，将不会发生阻塞。如果调用时 <em>blocking</em> 设为 <code>True</code> 会阻塞，并立即返回 <code>False</code> ；否则，将锁锁定并返回 <code>True</code>。当浮点型 <em>timeout</em> 参数被设置为正值调用时，只要无法获得锁，将最多阻塞 <em>timeout</em> 设定的秒数。<em>timeout</em> 参数被设置为 <code>-1</code> 时将无限等待。当 <em>blocking</em> 为 false 时，<em>timeout</em> 指定的值将被忽略。如果成功获得锁，则返回 <code>True</code>，否则返回 <code>False</code> (例如发生 <em>超时</em> 的时候)。<em>在 3.2 版更改:</em> 新的 <em>timeout</em> 形参。<em>在 3.2 版更改:</em> 现在如果底层线程实现支持，则可以通过POSIX上的信号中断锁的获取。</p>
</li>
<li><p><code>release</code>()</p>
<p>释放一个锁。这个方法可以在任何线程中调用，不单指获得锁的线程。当锁被锁定，将它重置为未锁定，并返回。如果其他线程正在等待这个锁解锁而被阻塞，只允许其中一个允许。在未锁定的锁调用时，会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常。没有返回值。</p>
</li>
<li><p><code>locked</code>()</p>
<p>Return true if the lock is acquired.</p>
</li>
</ul>
<h3 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h3><p>重入锁是一个可以被同一个线程多次获取的同步基元组件。在内部，它在基元锁的锁定/非锁定状态上附加了 “所属线程” 和 “递归等级” 的概念。在锁定状态下，某些线程拥有锁 ； 在非锁定状态下， 没有线程拥有它。</p>
<p>若要锁定锁，线程调用其 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 方法；一旦线程拥有了锁，方法将返回。若要解锁，线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> 方法。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a>/<a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> 对可以嵌套；只有最终 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> (最外面一对的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> ) 将锁解开，才能让其他线程继续处理 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 阻塞。</p>
<p>递归锁也支持 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#with-locks" target="_blank" rel="noopener">上下文管理协议</a>。</p>
<p><em>class</em> <code>threading.RLock</code></p>
<p>此类实现了重入锁对象。重入锁必须由获取它的线程释放。一旦线程获得了重入锁，同一个线程再次获取它将不阻塞；线程必须在每次获取它时释放一次。需要注意的是 <code>RLock</code> 其实是一个工厂函数，返回平台支持的具体递归锁类中最有效的版本的实例。</p>
<ul>
<li><p><code>acquire</code>(<em>blocking=True</em>, <em>timeout=-1</em>)</p>
<p>可以阻塞或非阻塞地获得锁。</p>
<p>当无参数调用时： 如果这个线程已经拥有锁，递归级别增加一，并立即返回。否则，如果其他线程拥有该锁，则阻塞至该锁解锁。一旦锁被解锁(不属于任何线程)，则抢夺所有权，设置递归等级为一，并返回。如果多个线程被阻塞，等待锁被解锁，一次只有一个线程能抢到锁的所有权。在这种情况下，没有返回值。</p>
<p>当发起调用时将 <em>blocking</em> 参数设为真值，则执行与无参数调用时一样的操作，然后返回 <code>True</code>。</p>
<p>当发起调用时将 <em>blocking</em> 参数设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 <code>False</code>；在其他情况下，执行与无参数调用时一样的操作，然后返回 <code>True</code>。</p>
<p>当发起调用时将浮点数的 <em>timeout</em> 参数设为正值时，只要无法获得锁，将最多阻塞 <em>timeout</em> 所指定的秒数。 如果已经获得锁则返回 <code>True</code>，如果超时则返回假值。</p>
</li>
<li><p><code>release</code>()</p>
<p>释放锁，自减递归等级。如果减到零，则将锁重置为非锁定状态(不被任何线程拥有)，并且，如果其他线程正被阻塞着等待锁被解锁，则仅允许其中一个线程继续。如果自减后，递归等级仍然不是零，则锁保持锁定，仍由调用线程拥有。</p>
<p>只有当前线程拥有锁才能调用这个方法。如果锁被释放后调用这个方法，会引起 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常。</p>
<p>没有返回值。</p>
</li>
</ul>
<h3 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h3><p>条件变量总是与某种类型的锁对象相关联，锁对象可以通过传入获得，或者在缺省的情况下自动创建。当多个条件变量需要共享同一个锁时，传入一个锁很有用。锁是条件对象的一部分，你不必单独地跟踪它。</p>
<p>条件变量服从 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#with-locks" target="_blank" rel="noopener">上下文管理协议</a>：使用 <code>with</code> 语句会在它包围的代码块内获取关联的锁。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.release" target="_blank" rel="noopener"><code>release()</code></a> 方法也能调用关联锁的相关方法。</p>
<p>其它方法必须在持有关联的锁的情况下调用。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法释放锁，然后阻塞直到其它线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 方法或 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all" target="_blank" rel="noopener"><code>notify_all()</code></a> 方法唤醒它。一旦被唤醒， <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法重新获取锁并返回。它也可以指定超时时间。</p>
<p>The <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> method wakes up one of the threads waiting for the condition variable, if any are waiting. The <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all" target="_blank" rel="noopener"><code>notify_all()</code></a> method wakes up all threads waiting for the condition variable.</p>
<p>注意： <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 方法和 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all" target="_blank" rel="noopener"><code>notify_all()</code></a> 方法并不会释放锁，这意味着被唤醒的线程不会立即从它们的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法调用中返回，而是会在调用了 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 方法或 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all" target="_blank" rel="noopener"><code>notify_all()</code></a> 方法的线程最终放弃了锁的所有权后返回。</p>
<p>使用条件变量的典型编程风格是将锁用于同步某些共享状态的权限，那些对状态的某些特定改变感兴趣的线程，它们重复调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法，直到看到所期望的改变发生；而对于修改状态的线程，它们将当前状态改变为可能是等待者所期待的新状态后，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 方法或者 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all" target="_blank" rel="noopener"><code>notify_all()</code></a> 方法。例如，下面的代码是一个通用的无限缓冲区容量的生产者-消费者情形：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Consume one item</span><br><span class="line">with cv:</span><br><span class="line">    while not an_item_is_available():</span><br><span class="line">        cv.wait()</span><br><span class="line">    get_an_available_item()</span><br><span class="line"></span><br><span class="line"># Produce one item</span><br><span class="line">with cv:</span><br><span class="line">    make_an_item_available()</span><br><span class="line">    cv.notify()</span><br></pre></td></tr></table></figure>
<p>使用 <code>while</code> 循环检查所要求的条件成立与否是有必要的，因为 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法可能要经过不确定长度的时间后才会返回，而此时导致 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 方法调用的那个条件可能已经不再成立。这是多线程编程所固有的问题。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait_for" target="_blank" rel="noopener"><code>wait_for()</code></a> 方法可自动化条件检查，并简化超时计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Consume an item</span></span><br><span class="line"><span class="keyword">with</span> cv:</span><br><span class="line">    cv.wait_for(an_item_is_available)</span><br><span class="line">    get_an_available_item()</span><br></pre></td></tr></table></figure>
<p>选择 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 还是 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all" target="_blank" rel="noopener"><code>notify_all()</code></a> ，取决于一次状态改变是只能被一个还是能被多个等待线程所用。例如在一个典型的生产者-消费者情形中，添加一个项目到缓冲区只需唤醒一个消费者线程。</p>
<p><em>class</em> <code>threading.Condition</code>(<em>lock=None</em>)</p>
<p>实现条件变量对象的类。一个条件变量对象允许一个或多个线程在被其它线程所通知之前进行等待。</p>
<p>如果给出了非 <code>None</code> 的 <em>lock</em> 参数，则它必须为 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock" target="_blank" rel="noopener"><code>Lock</code></a> 或者 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock" target="_blank" rel="noopener"><code>RLock</code></a> 对象，并且它将被用作底层锁。否则，将会创建新的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock" target="_blank" rel="noopener"><code>RLock</code></a> 对象，并将其用作底层锁。</p>
<p><em>在 3.3 版更改:</em> 从工厂函数变为类。</p>
<ul>
<li><p><code>acquire</code>(*<em>args</em>)</p>
<p>请求底层锁。此方法调用底层锁的相应方法，返回值是底层锁相应方法的返回值。</p>
</li>
<li><p><code>release</code>()</p>
<p>释放底层锁。此方法调用底层锁的相应方法。没有返回值。</p>
</li>
<li><p><code>wait</code>(<em>timeout=None</em>)</p>
<p>等待直到被通知或发生超时。如果线程在调用此方法时没有获得锁，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常。这个方法释放底层锁，然后阻塞，直到在另外一个线程中调用同一个条件变量的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all" target="_blank" rel="noopener"><code>notify_all()</code></a> 唤醒它，或者直到可选的超时发生。一旦被唤醒或者超时，它重新获得锁并返回。当提供了 <em>timeout</em> 参数且不是 <code>None</code> 时，它应该是一个浮点数，代表操作的超时时间，以秒为单位（可以为小数）。当底层锁是个 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock" target="_blank" rel="noopener"><code>RLock</code></a> ，不会使用它的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.release" target="_blank" rel="noopener"><code>release()</code></a> 方法释放锁，因为当它被递归多次获取时，实际上可能无法解锁。相反，使用了 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock" target="_blank" rel="noopener"><code>RLock</code></a> 类的内部接口，即使多次递归获取它也能解锁它。 然后，在重新获取锁时，使用另一个内部接口来恢复递归级别。返回 <code>True</code> ，除非提供的 <em>timeout</em> 过期，这种情况下返回 <code>False</code>。<em>在 3.2 版更改:</em> 很明显，方法总是返回 <code>None</code>。</p>
</li>
<li><p><code>wait_for</code>(<em>predicate</em>, <em>timeout=None</em>)</p>
<p>等待，直到条件计算为真。 <em>predicate</em> 应该是一个可调用对象而且它的返回值可被解释为一个布尔值。可以提供 <em>timeout</em> 参数给出最大等待时间。这个实用方法会重复地调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> 直到满足判断式或者发生超时。返回值是判断式最后一个返回值，而且如果方法发生超时会返回 <code>False</code> 。忽略超时功能，调用此方法大致相当于编写:<code>while not predicate():     cv.wait()</code>因此，规则同样适用于 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> ：锁必须在被调用时保持获取，并在返回时重新获取。 随着锁定执行判断式。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>notify</code>(<em>n=1</em>)</p>
<p>默认唤醒一个等待这个条件的线程。如果调用线程在没有获得锁的情况下调用这个方法，会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常。这个方法唤醒最多 <em>n</em> 个正在等待这个条件变量的线程；如果没有线程在等待，这是一个空操作。当前实现中，如果至少有 <em>n</em> 个线程正在等待，准确唤醒 <em>n</em> 个线程。但是依赖这个行为并不安全。未来，优化的实现有时会唤醒超过 <em>n</em> 个线程。注意：被唤醒的线程实际上不会返回它调用的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> ，直到它可以重新获得锁。因为 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 不会释放锁，只有它的调用者应该这样做。</p>
</li>
<li><p><code>notify_all</code>()</p>
<p>唤醒所有正在等待这个条件的线程。这个方法行为与 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 相似，但并不只唤醒单一线程，而是唤醒所有等待线程。如果调用线程在调用这个方法时没有获得锁，会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常。</p>
</li>
</ul>
<h3 id="信号量对象"><a href="#信号量对象" class="headerlink" title="信号量对象"></a>信号量对象</h3><p>这是计算机科学史上最古老的同步原语之一，早期的荷兰科学家 Edsger W. Dijkstra 发明了它。（他使用名称 <code>P()</code> 和 <code>V()</code> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release" target="_blank" rel="noopener"><code>release()</code></a> ）。</p>
<p>一个信号量管理一个内部计数器，该计数器因 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 方法的调用而递减，因 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release" target="_blank" rel="noopener"><code>release()</code></a> 方法的调用而递增。 计数器的值永远不会小于零；当 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 方法发现计数器为零时，将会阻塞，直到其它线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release" target="_blank" rel="noopener"><code>release()</code></a> 方法。</p>
<p>信号量对象也支持 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#with-locks" target="_blank" rel="noopener">上下文管理协议</a> 。</p>
<ul>
<li><p><em>class</em> <code>threading.Semaphore</code>(<em>value=1</em>)</p>
<p>该类实现信号量对象。信号量对象管理一个原子性的计数器，代表 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release" target="_blank" rel="noopener"><code>release()</code></a> 方法的调用次数减去 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 的调用次数再加上一个初始值。如果需要， <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 方法将会阻塞直到可以返回而不会使得计数器变成负数。在没有显式给出 <em>value</em> 的值时，默认为1。</p>
<p>可选参数 <em>value</em> 赋予内部计数器初始值，默认值为 <code>1</code> 。如果 <em>value</em> 被赋予小于0的值，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。</p>
<ul>
<li><p><code>acquire</code>(<em>blocking=True</em>, <em>timeout=None</em>)</p>
<p>获取一个信号量。在不带参数的情况下调用时：如果在进入时内部计数器的值大于零，则将其减一并立即返回 <code>True</code>.如果在进入时内部计数器的值为零，则将会阻塞直到被对 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release" target="_blank" rel="noopener"><code>release()</code></a> 的调用唤醒。 一旦被唤醒（并且计数器的值大于 0），则将计数器减 1 并返回 <code>True</code>。 每次对 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release" target="_blank" rel="noopener"><code>release()</code></a> 的调用将只唤醒一个线程。 线程被唤醒的次序是不可确定的。当发起调用时将 <em>blocking</em> 设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 <code>False</code>；在其他情况下，执行与无参数调用时一样的操作，然后返回 <code>True</code>。当发起调用时如果 <em>timeout</em> 不为 <code>None</code>，则它将阻塞最多 <em>timeout</em> 秒。 请求在此时段时未能成功完成获取则将返回 <code>False</code>。 在其他情况下返回 <code>True</code>。<em>在 3.2 版更改:</em> 新的 <em>timeout</em> 形参。</p>
</li>
<li><p><code>release</code>()</p>
<p>释放一个信号量，将内部计数器的值增加1。当计数器原先的值为0且有其它线程正在等待它再次大于0时，唤醒正在等待的线程。</p>
</li>
</ul>
</li>
<li><p><em>class</em> <code>threading.BoundedSemaphore</code>(<em>value=1</em>)</p>
<p>该类实现有界信号量。有界信号量通过检查以确保它当前的值不会超过初始值。如果超过了初始值，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。在大多情况下，信号量用于保护数量有限的资源。如果信号量被释放的次数过多，则表明出现了错误。没有指定时， <em>value</em> 的值默认为1。<em>在 3.3 版更改:</em> 从工厂函数变为类。</p>
</li>
</ul>
<h4 id="Semaphore例子"><a href="#Semaphore例子" class="headerlink" title="Semaphore例子"></a><code>Semaphore</code>例子</h4><p>信号量通常用于保护数量有限的资源，例如数据库服务器。在资源数量固定的任何情况下，都应该使用有界信号量。在生成任何工作线程前，应该在主线程中初始化信号量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">maxconnections = <span class="number">5</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">pool_sema = BoundedSemaphore(value=maxconnections)</span><br></pre></td></tr></table></figure>
<p>工作线程生成后，当需要连接服务器时，这些线程将调用信号量的 acquire 和 release 方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conn = connectdb()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># ... use connection ...</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>
<p>使用有界信号量能减少这种编程错误：信号量的释放次数多于其请求次数。</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>这是线程之间通信的最简单机制之一：一个线程发出事件信号，而其他线程等待该信号。</p>
<p>一个事件对象管理一个内部标志，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.set" target="_blank" rel="noopener"><code>set()</code></a> 方法可将其设置为true，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.clear" target="_blank" rel="noopener"><code>clear()</code></a> 方法可将其设置为false，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法将进入阻塞直到标志为true。</p>
<ul>
<li><p><em>class</em> <code>threading.Event</code></p>
<p>实现事件对象的类。事件对象管理一个内部标志，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.set" target="_blank" rel="noopener"><code>set()</code></a> 方法可将其设置为true。调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.clear" target="_blank" rel="noopener"><code>clear()</code></a> 方法可将其设置为false。调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法将进入阻塞直到标志为true。这个标志初始时为false。<em>在 3.3 版更改:</em> 从工厂函数变为类。<code>is_set</code>()当且仅当内部旗标为时返回 <code>True</code>。<code>set</code>()将内部标志设置为true。所有正在等待这个事件的线程将被唤醒。当标志为true时，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法的线程不会被被阻塞。<code>clear</code>()将内部标志设置为false。之后调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法的线程将会被阻塞，直到调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.set" target="_blank" rel="noopener"><code>set()</code></a> 方法将内部标志再次设置为true。<code>wait</code>(<em>timeout=None</em>)阻塞线程直到内部变量为true。如果调用时内部标志为true，将立即返回。否则将阻塞线程，直到调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.set" target="_blank" rel="noopener"><code>set()</code></a> 方法将标志设置为true或者发生可选的超时。当提供了timeout参数且不是 <code>None</code> 时，它应该是一个浮点数，代表操作的超时时间，以秒为单位（可以为小数）。当且仅当内部旗标在等待调用之前或者等待开始之后被设为真值时此方法将返回 <code>True</code>，也就是说，它将总是返回 <code>True</code> 除非设定了超时且操作发生了超时。</p>
</li>
</ul>
<h3 id="定时器对象"><a href="#定时器对象" class="headerlink" title="定时器对象"></a>定时器对象</h3><p>此类表示一个操作应该在等待一定的时间之后运行 — 相当于一个定时器。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Timer" target="_blank" rel="noopener"><code>Timer</code></a> 类是 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>Thread</code></a> 类的子类，因此可以像一个自定义线程一样工作。</p>
<p>与线程一样，通过调用 <code>start()</code> 方法启动定时器。而 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Timer.cancel" target="_blank" rel="noopener"><code>cancel()</code></a> 方法可以停止计时器（在计时结束前）， 定时器在执行其操作之前等待的时间间隔可能与用户指定的时间间隔不完全相同。</p>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello, world"</span>)</span><br><span class="line"></span><br><span class="line">t = Timer(<span class="number">30.0</span>, hello)</span><br><span class="line">t.start()  <span class="comment"># after 30 seconds, "hello, world" will be printed</span></span><br></pre></td></tr></table></figure>
<p><em>class</em> <code>threading.Timer</code>(<em>interval</em>, <em>function</em>, <em>args=None</em>, <em>kwargs=None</em>)</p>
<p>创建一个定时器，在经过 <em>interval</em> 秒的间隔事件后，将会用参数 <em>args</em> 和关键字参数 <em>kwargs</em> 调用 <em>function</em>。如果 <em>args</em> 为 <code>None</code> （默认值），则会使用一个空列表。如果 <em>kwargs</em> 为 <code>None</code> （默认值），则会使用一个空字典。</p>
<ul>
<li><code>cancel</code>()<a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Timer.cancel" target="_blank" rel="noopener">¶</a></li>
</ul>
<p>停止定时器并取消执行计时器将要执行的操作。仅当计时器仍处于等待状态时有效。</p>
<h3 id="栅栏对象"><a href="#栅栏对象" class="headerlink" title="栅栏对象"></a>栅栏对象</h3><p>栅栏类提供一个简单的同步原语，用于应对固定数量的线程需要彼此相互等待的情况。线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法后将阻塞，直到所有线程都调用了 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法。此时所有线程将被同时释放。</p>
<p>栅栏对象可以被多次使用，但进程的数量不能改变。</p>
<p>这是一个使用简便的方法实现客户端进程与服务端进程同步的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = Barrier(<span class="number">2</span>, timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">()</span>:</span></span><br><span class="line">    start_server()</span><br><span class="line">    b.wait()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        connection = accept_connection()</span><br><span class="line">        process_server_connection(connection)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">()</span>:</span></span><br><span class="line">    b.wait()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        connection = make_connection()</span><br><span class="line">        process_client_connection(connection)</span><br></pre></td></tr></table></figure>
<p><em>class</em> <code>threading.Barrier</code>(<em>parties</em>, <em>action=None</em>, <em>timeout=None</em>)</p>
<p>创建一个需要 <em>parties</em> 个线程的栅栏对象。如果提供了可调用的 <em>action</em> 参数，它会在所有线程被释放时在其中一个线程中自动调用。 <em>timeout</em> 是默认的超时时间，如果没有在 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法中指定超时时间的话。</p>
<ul>
<li><p><code>wait</code>(<em>timeout=None</em>)</p>
<p>冲出栅栏。当栅栏中所有线程都已经调用了这个函数，它们将同时被释放。如果提供了 <em>timeout</em> 参数，这里的 <em>timeout</em> 参数优先于创建栅栏对象时提供的 <em>timeout</em> 参数。函数返回值是一个整数，取值范围在0到 <em>parties</em> – 1，在每个线程中的返回值不相同。可用于从所有线程中选择唯一的一个线程执行一些特别的工作。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = barrier.wait()</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># Only one thread needs to print this</span></span><br><span class="line">    print(<span class="string">"passed the barrier"</span>)</span><br></pre></td></tr></table></figure>
<p>如果创建栅栏对象时在构造函数中提供了 <em>action</em> 参数，它将在其中一个线程释放前被调用。如果此调用引发了异常，栅栏对象将进入损坏态。</p>
<p>如果发生了超时，栅栏对象将进入破损态。</p>
<p>如果栅栏对象进入破损态，或重置栅栏时仍有线程等待释放，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.BrokenBarrierError" target="_blank" rel="noopener"><code>BrokenBarrierError</code></a> 异常。</p>
</li>
<li><p><code>reset</code>()</p>
<p>重置栅栏为默认的初始态。如果栅栏中仍有线程等待释放，这些线程将会收到 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.BrokenBarrierError" target="_blank" rel="noopener"><code>BrokenBarrierError</code></a> 异常。</p>
</li>
<li><p><code>abort</code>()</p>
<p>Put the barrier into a broken state. This causes any active or future calls to <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier.wait" target="_blank" rel="noopener"><code>wait()</code></a> to fail with the <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.BrokenBarrierError" target="_blank" rel="noopener"><code>BrokenBarrierError</code></a>. Use this for example if one of the threads needs to abort, to avoid deadlocking the application.更好的方式是：创建栅栏时提供一个合理的超时时间，来自动避免某个线程出错。</p>
</li>
<li><p><code>parties</code></p>
<p>冲出栅栏所需要的线程数量。</p>
</li>
<li><p><code>n_waiting</code></p>
<p>当前时刻正在栅栏中阻塞的线程数量。</p>
</li>
<li><p><code>broken</code></p>
<p>一个布尔值，值为 <code>True</code> 表明栅栏为破损态。</p>
</li>
</ul>
<p><em>exception</em> <code>threading.BrokenBarrierError</code></p>
<p>异常类，是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常的子类，在 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier" target="_blank" rel="noopener"><code>Barrier</code></a> 对象重置时仍有线程阻塞时和对象进入破损态时被引发。</p>
<h3 id="在-with-语句中使用锁、条件和信号量"><a href="#在-with-语句中使用锁、条件和信号量" class="headerlink" title="在 with 语句中使用锁、条件和信号量"></a>在 <code>with</code> 语句中使用锁、条件和信号量</h3><p>这个模块提供的带有 <code>acquire()</code> 和 <code>release()</code> 方法的对象，可以被用作 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的上下文管理器。当进入语句块时 <code>acquire()</code> 方法会被调用，退出语句块时 <code>release()</code> 会被调用。因此，以下片段:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> some_lock:</span><br><span class="line">    <span class="comment"># do something...</span></span><br></pre></td></tr></table></figure>
<p>相当于:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">some_lock.acquire()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># do something...</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    some_lock.release()</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="GIL-原理"><a href="#GIL-原理" class="headerlink" title="GIL 原理"></a>GIL 原理</h3><p>参考 <a href="https://stackoverflow.com/questions/1294382/what-is-the-global-interpreter-lock-gil-in-cpython" target="_blank" rel="noopener">stackoverflow</a>上 大神的解释</p>
<blockquote>
<p>Python’s GIL is intended to serialize access to interpreter internals from different threads. On multi-core systems, it means that multiple threads can’t effectively make use of multiple cores. (If the GIL didn’t lead to this problem, most people wouldn’t care about the GIL - it’s only being raised as an issue because of the increasing prevalence of multi-core systems.) If you want to understand it in detail, you can view <a href="https://www.youtube.com/watch?v=ph374fJqFPE" target="_blank" rel="noopener">this video</a> or look at <a href="http://www.dabeaz.com/python/GIL.pdf" target="_blank" rel="noopener">this set of slides</a>. It might be too much information, but then you did ask for details :-)</p>
<p>Note that Python’s GIL is only really an issue for CPython, the reference implementation. Jython and IronPython don’t have a GIL. As a Python developer, you don’t generally come across the GIL unless you’re writing a C extension. C extension writers need to release the GIL when their extensions do blocking I/O, so that other threads in the Python process get a chance to run.</p>
</blockquote>
<p>简单说 所谓的全局线程锁,就是同步线程间信号的一种处理方式。</p>
<p>在多线程系统中,并不能充分利用多线程,来提高整体的性能。所以才有了 GIL。</p>
<p>根据我的理解,GIL的一个应用场景是<strong>在同一时刻只能跑一个线程，这样在跑多线程的情况下，只有当线程获取到全局解释器锁后才能运行，而全局解释器锁只有一个，因此即使在多核的情况下也只能发挥出单核的功能。</strong></p>
<p>如下图所示:</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200119_cpu_bound_tasks.png?raw=tru" alt></p>
<p><code>GIL</code>仅仅对cpython实现和扩展的模块起作用,jython或者ironpython没有GIL的概念。</p>
<p>到底是并行还是多线程,在很多场景中都有争论。</p>
<h3 id="GIL-对线程执行的影响："><a href="#GIL-对线程执行的影响：" class="headerlink" title="GIL 对线程执行的影响："></a>GIL 对线程执行的影响：</h3><p>首先理解什么是interval时间,和操作系统绑定:</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># The interval is set to 100 instructions:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getcheckinterval()</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>多线程环境中，python虚拟机按照以下方式执行：</p>
<ul>
<li>设置GIL</li>
<li>切换到一个线程去执行</li>
<li>运行代码，这里有两种机制： q<ul>
<li>指定数量的字节码指令（100个）</li>
<li>固定时间15ms线程主动让出控制</li>
</ul>
</li>
<li>把线程设置为睡眠状态</li>
<li>解锁GIL</li>
<li>再次重复以上步骤</li>
</ul>
<h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><p><strong>Code 1: CPU bound program that perform simple countdown</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread </span><br><span class="line">  </span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span> </span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>: </span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">start = time.time() </span><br><span class="line">countdown(COUNT) </span><br><span class="line">end = time.time() </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'Time taken in seconds -'</span>, end - start) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Time taken <span class="keyword">in</span> seconds - <span class="number">2.5236213207244873</span></span><br></pre></td></tr></table></figure>
<p><strong>Code 2: Two threads running parallel</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread </span><br><span class="line">  </span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span> </span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>: </span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">t1 = Thread(target = countdown, args =(COUNT//<span class="number">2</span>, )) </span><br><span class="line">t2 = Thread(target = countdown, args =(COUNT//<span class="number">2</span>, )) </span><br><span class="line">  </span><br><span class="line">start = time.time() </span><br><span class="line">t1.start() </span><br><span class="line">t2.start() </span><br><span class="line">t1.join() </span><br><span class="line">t2.join() </span><br><span class="line">end = time.time() </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'Time taken in seconds -'</span>, end - start) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Time taken <span class="keyword">in</span> seconds - <span class="number">2.183610439300537</span></span><br></pre></td></tr></table></figure>
<p><strong>python的解决方案</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing  </span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line">  </span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span> </span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>: </span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: </span><br><span class="line">    <span class="comment"># creating processes  </span></span><br><span class="line">    start = time.time() </span><br><span class="line">    p1 = multiprocessing.Process(target = countdown, args =(COUNT//<span class="number">2</span>, )) </span><br><span class="line">    p2 = multiprocessing.Process(target = countdown, args =(COUNT//<span class="number">2</span>, )) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># starting process 1  </span></span><br><span class="line">    p1.start() </span><br><span class="line">    <span class="comment"># starting process 2  </span></span><br><span class="line">    p2.start()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># wait until process 1 is finished  </span></span><br><span class="line">    p1.join()  </span><br><span class="line">    <span class="comment"># wait until process 2 is finished  </span></span><br><span class="line">    p2.join() </span><br><span class="line">    end = time.time() </span><br><span class="line">    print(<span class="string">'Time taken in seconds -'</span>, end - start) </span><br><span class="line">    &gt;&gt;&gt; Time taken <span class="keyword">in</span> seconds - <span class="number">2.5148496627807617</span></span><br></pre></td></tr></table></figure>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.dabeaz.com/python/UnderstandingGIL.pdf" target="_blank" rel="noopener">UnderstandingGIL</a></p>
<p><a href="https://callhub.io/understanding-python-gil/" target="_blank" rel="noopener">understanding-python-gil</a></p>
<p><a href="https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/" target="_blank" rel="noopener">what is the python interpreter lock gil</a></p>
<p><a href="https://www.scaler.com/topics/memory-management-in-python/" target="_blank" rel="noopener">What is Memory Management in Python?</a> </p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>thread</tag>
        <tag>GIL</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library difflib</title>
    <url>/2020/01/21/python-standard-library-difflib/</url>
    <content><![CDATA[<h1 id="python-标准库学习-difflib"><a href="#python-标准库学习-difflib" class="headerlink" title="python 标准库学习  difflib"></a>python 标准库学习  difflib</h1><p>每日一词:</p>
<blockquote>
<p>wink </p>
<p>US[wɪŋk]  UK[wɪŋk]</p>
<p>n.眼色；眨一只眼；眨眼示意</p>
<p>v.闪烁；眨眼示意（尤指使眼色或表示开玩笑）；明灭</p>
<p>网络瞬间；眨眼睛；你眨了眨眼</p>
<p>推荐一个电影：</p>
<p>记忆碎片👴</p>
<p>又是诺兰的大作,强烈推荐</p>
<p>推荐指数： 🌟🌟🌟🌟🌟</p>
</blockquote>
<p><img src="https://pic2.zhimg.com/2af9e3d253beebcab32903659da092d7_r.jpg" alt></p>
<a id="more"></a>
<p>马上就要过年了,尽量少去人流密集场所吧。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/difflib.py" target="_blank" rel="noopener">Lib/difflib.py</a></p>
<p>此模块提供用于比较序列的类和函数。 例如，它可以用于比较文件，并可以产生各种格式的不同信息，包括 HTML 和上下文以及统一格式的差异点。 有关目录和文件的比较，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#module-filecmp" target="_blank" rel="noopener"><code>filecmp</code></a> 模块。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><em>class</em> <code>difflib.SequenceMatcher</code></p>
<p>这是一个灵活的类，可用于比较任何类型的序列对，只要序列元素为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a> 对象。 其基本算法要早于由 Ratcliff 和 Obershelp 于 1980 年代末期发表并以“格式塔模式匹配”的夸张名称命名的算法，并且更加有趣一些。 其思路是找到不包含“垃圾”元素的最长连续匹配子序列；所谓“垃圾”元素是指其在某种意义上没有价值，例如空白行或空白符。 （处理垃圾元素是对 Ratcliff 和 Obershelp 算法的一个扩展。） 然后同样的思路将递归地应用于匹配序列的左右序列片段。 这并不能产生最小编辑序列，但确实能产生在人们看来“正确”的匹配。</p>
<p><strong>耗时:</strong> 基本 Ratcliff-Obershelp 算法在最坏情况下为立方时间而在一般情况下为平方时间。 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher" target="_blank" rel="noopener"><code>SequenceMatcher</code></a> 在最坏情况下为平方时间而在一般情况下的行为受到序列中有多少相同元素这一因素的微妙影响；在最佳情况下则为线性时间。</p>
<p><strong>自动垃圾启发式计算:</strong> <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher" target="_blank" rel="noopener"><code>SequenceMatcher</code></a> 支持使用启发式计算来自动将特定序列项视为垃圾。 这种启发式计算会统计每个单独项在序列中出现的次数。 如果某一项（在第一项之后）的重复次数超过序列长度的 1% 并且序列长度至少有 200 项，该项会被标记为“热门”并被视为序列匹配中的垃圾。 这种启发式计算可以通过在创建 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher" target="_blank" rel="noopener"><code>SequenceMatcher</code></a> 时将 <code>autojunk</code> 参数设为 <code>False</code> 来关闭。</p>
<p><em>class</em> <code>difflib.Differ</code></p>
<p>这个类的作用是比较由文本行组成的序列，并产生可供人阅读的差异或增量信息。 Differ 统一使用 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher" target="_blank" rel="noopener"><code>SequenceMatcher</code></a> 来完成行序列的比较以及相似（接近匹配）行内部字符序列的比较。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ" target="_blank" rel="noopener"><code>Differ</code></a> 增量的每一行均以双字母代码打头：</p>
<table>
<thead>
<tr>
<th>双字母代码</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&#39;- &#39;</code></td>
<td>行为序列 1 所独有</td>
</tr>
<tr>
<td><code>&#39;+ &#39;</code></td>
<td>行为序列 2 所独有</td>
</tr>
<tr>
<td><code>&#39;  &#39;</code></td>
<td>行在两序列中相同</td>
</tr>
<tr>
<td><code>&#39;? &#39;</code></td>
<td>行不存在于任一输入序列</td>
</tr>
</tbody>
</table>
<p>以 ‘<code>?</code>‘ 打头的行尝试将视线引至行以外而不存在于任一输入序列的差异。 如果序列包含制表符则这些行可能会令人感到迷惑。</p>
<p><em>class</em> <code>difflib.HtmlDiff</code></p>
<p>这个类可用于创建 HTML 表格（或包含表格的完整 HTML 文件）以并排地逐行显示文本比较，行间与行外的更改将突出显示。 此表格可以基于完全或上下文差异模式来生成。</p>
<p>这个类的构造函数：</p>
<ul>
<li><p><code>__init__</code>(<em>tabsize=8</em>, <em>wrapcolumn=None</em>, <em>linejunk=None</em>, <em>charjunk=IS_CHARACTER_JUNK</em>)</p>
<p>初始化 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.HtmlDiff" target="_blank" rel="noopener"><code>HtmlDiff</code></a> 的实例。</p>
<p><em>tabsize</em> 是一个可选关键字参数，指定制表位的间隔，默认值为 <code>8</code>。</p>
<p><em>wrapcolumn</em> 是一个可选关键字参数，指定行文本自动打断并换行的列位置，默认值为 <code>None</code> 表示不自动换行。</p>
<p><em>linejunk</em> 和 <em>charjunk</em> 均是可选关键字参数，会传入 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.ndiff" target="_blank" rel="noopener"><code>ndiff()</code></a> (被 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.HtmlDiff" target="_blank" rel="noopener"><code>HtmlDiff</code></a> 用来生成并排显示的 HTML 差异)。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.ndiff" target="_blank" rel="noopener"><code>ndiff()</code></a> 文档了解参数默认值及其说明。</p>
</li>
<li><p><code>make_file</code>(<em>fromlines</em>, <em>tolines</em>, <em>fromdesc=’’</em>, <em>todesc=’’</em>, <em>context=False</em>, <em>numlines=5</em>, <em>**, </em>charset=’utf-8’*)</p>
<p>比较 <em>fromlines</em> 和 <em>tolines</em> (字符串列表) 并返回一个字符串，表示一个完整 HTML 文件，其中包含各行差异的表格，行间与行外的更改将突出显示。</p>
<p><em>fromdesc</em> 和 <em>todesc</em> 均是可选关键字参数，指定来源/目标文件的列标题字符串（默认均为空白字符串）。</p>
<p><em>context</em> 和 <em>numlines</em> 均是可选关键字参数。 当只要显示上下文差异时就将 <em>context</em> 设为 <code>True</code>，否则默认值 <code>False</code> 为显示完整文件。 <em>numlines</em> 默认为 <code>5</code>。 当 <em>context</em> 为 <code>True</code> 时 <em>numlines</em> 将控制围绕突出显示差异部分的上下文行数。 当 <em>context</em> 为 <code>False</code> 时 <em>numlines</em> 将控制在使用 “next” 超链接时突出显示差异部分之前所显示的行数（设为零则会导致 “next” 超链接将下一个突出显示差异部分放在浏览器顶端，不添加任何前导上下文）。</p>
<blockquote>
<p><em>fromdesc</em> 和 <em>todesc</em> 会被当作未转义的 HTML 来解读，当接收不可信来源的输入时应该适当地进行转义。</p>
</blockquote>
</li>
<li><p><code>make_table</code>(<em>fromlines</em>, <em>tolines</em>, <em>fromdesc=’’</em>, <em>todesc=’’</em>, <em>context=False</em>, <em>numlines=5</em>)</p>
<p>比较 <em>fromlines</em> 和 <em>tolines</em> (字符串列表) 并返回一个字符串，表示一个包含各行差异的完整 HTML 表格，行间与行外的更改将突出显示。</p>
<p>此方法的参数与 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.HtmlDiff.make_file" target="_blank" rel="noopener"><code>make_file()</code></a> 方法的相同。</p>
<p><code>Tools/scripts/diff.py</code> 是这个类的命令行前端，其中包含一个很好的使用示例。</p>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>difflib.context_diff</code>(<em>a</em>, <em>b</em>, <em>fromfile=’’</em>, <em>tofile=’’</em>, <em>fromfiledate=’’</em>, <em>tofiledate=’’</em>, <em>n=3</em>, <em>lineterm=’\n’</em>)</p>
<p>比较 <em>a</em> 和 <em>b</em> (字符串列表)；返回上下文差异格式的增量信息 (一个产生增量行的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a>)。</p>
<p>所谓上下文差异是一种只显示有更改的行再加几个上下文行的紧凑形式。 更改被显示为之前/之后的样式。 上下文行数由 <em>n</em> 设定，默认为三行。</p>
<p>默认情况下，差异控制行（以 <code>***</code> or <code>---</code> 表示）是通过末尾换行符来创建的。 这样做的好处是从 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.readlines" target="_blank" rel="noopener"><code>io.IOBase.readlines()</code></a> 创建的输入将得到适用于 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.writelines" target="_blank" rel="noopener"><code>io.IOBase.writelines()</code></a> 的差异信息，因为输入和输出都带有末尾换行符。</p>
<p>对于没有末尾换行符的输入，应将 <em>lineterm</em> 参数设为 <code>&quot;&quot;</code>，这样输出内容将统一不带换行符。</p>
<p>上下文差异格式通常带有一个记录文件名和修改时间的标头。 这些信息的部分或全部可以使用字符串 <em>fromfile</em>, <em>tofile</em>, <em>fromfiledate</em> 和 <em>tofiledate</em> 来指定。 修改时间通常以 ISO 8601 格式表示。 如果未指定，这些字符串默认为空。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = [<span class="string">'bacon\n'</span>, <span class="string">'eggs\n'</span>, <span class="string">'ham\n'</span>, <span class="string">'guido\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = [<span class="string">'python\n'</span>, <span class="string">'eggy\n'</span>, <span class="string">'hamster\n'</span>, <span class="string">'guido\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.writelines(context_diff(s1, s2, fromfile=<span class="string">'before.py'</span>,tofile=<span class="string">'after.py'</span>))</span><br><span class="line">*** before.py</span><br><span class="line">--- after.py</span><br><span class="line">***************</span><br><span class="line">*** <span class="number">1</span>,<span class="number">4</span> ****</span><br><span class="line">! bacon</span><br><span class="line">! eggs</span><br><span class="line">! ham</span><br><span class="line">  guido</span><br><span class="line">--- <span class="number">1</span>,<span class="number">4</span> ----</span><br><span class="line">! python</span><br><span class="line">! eggy</span><br><span class="line">! hamster</span><br><span class="line">  guido</span><br></pre></td></tr></table></figure>
<p><code>difflib.get_close_matches</code>(<em>word</em>, <em>possibilities</em>, <em>n=3</em>, <em>cutoff=0.6</em>)</p>
<p>返回由最佳“近似”匹配构成的列表。 <em>word</em> 为一个指定目标近似匹配的序列（通常为字符串），<em>possibilities</em> 为一个由用于匹配 <em>word</em> 的序列构成的列表（通常为字符串列表）。</p>
<p>可选参数 <em>n</em> (默认为 <code>3</code>) 指定最多返回多少个近似匹配； <em>n</em> 必须大于 <code>0</code>.</p>
<p>可选参数 <em>cutoff</em> (默认为 <code>0.6</code>) 是一个 [0, 1] 范围内的浮点数。 与 <em>word</em> 相似度得分未达到该值的候选匹配将被忽略。</p>
<p>候选匹配中（不超过 <em>n</em> 个）的最佳匹配将以列表形式返回，按相似度得分排序，最相似的排在最前面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_close_matches(<span class="string">'appel'</span>, [<span class="string">'ape'</span>, <span class="string">'apple'</span>, <span class="string">'peach'</span>, <span class="string">'puppy'</span>])</span><br><span class="line">[<span class="string">'apple'</span>, <span class="string">'ape'</span>]</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> keyword</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_close_matches(<span class="string">'wheel'</span>, keyword.kwlist)</span><br><span class="line">[<span class="string">'while'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_close_matches(<span class="string">'pineapple'</span>, keyword.kwlist)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_close_matches(<span class="string">'accept'</span>, keyword.kwlist)</span><br><span class="line">[<span class="string">'except'</span>]</span><br></pre></td></tr></table></figure>
<p><code>difflib.ndiff</code>(<em>a</em>, <em>b</em>, <em>linejunk=None</em>, <em>charjunk=IS_CHARACTER_JUNK</em>)</p>
<p>比较 <em>a</em> 和 <em>b</em> (字符串列表)；返回 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ" target="_blank" rel="noopener"><code>Differ</code></a> 形式的增量信息 (一个产生增量行的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a>)。</p>
<p>可选关键字形参 <em>linejunk</em> 和 <em>charjunk</em> 均为过滤函数 (或为 <code>None</code>)：</p>
<p><em>linejunk</em>: 此函数接受单个字符串参数，如果其为垃圾字符串则返回真值，否则返回假值。 默认为 <code>None</code>。 此外还有一个模块层级的函数 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.IS_LINE_JUNK" target="_blank" rel="noopener"><code>IS_LINE_JUNK()</code></a>，它会过滤掉没有可见字符的行，除非该行添加了至多一个井号符 (<code>&#39;#&#39;</code>) – 但是下层的 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher" target="_blank" rel="noopener"><code>SequenceMatcher</code></a> 类会动态分析哪些行的重复频繁到足以形成噪音，这通常会比使用此函数的效果更好。</p>
<p><em>charjunk</em>: 此函数接受一个字符（长度为 1 的字符串)，如果其为垃圾字符则返回真值，否则返回假值。 默认为模块层级的函数 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.IS_CHARACTER_JUNK" target="_blank" rel="noopener"><code>IS_CHARACTER_JUNK()</code></a>，它会过滤掉空白字符（空格符或制表符；但包含换行符可不是个好主意！）。</p>
<p><code>Tools/scripts/ndiff.py</code> 是这个函数的命令行前端。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>diff = ndiff(<span class="string">'one\ntwo\nthree\n'</span>.splitlines(keepends=<span class="literal">True</span>),</span><br><span class="line"><span class="meta">... </span>            <span class="string">'ore\ntree\nemu\n'</span>.splitlines(keepends=<span class="literal">True</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">''</span>.join(diff), end=<span class="string">""</span>)</span><br><span class="line">- one</span><br><span class="line">?  ^</span><br><span class="line">+ ore</span><br><span class="line">?  ^</span><br><span class="line">- two</span><br><span class="line">- three</span><br><span class="line">?  -</span><br><span class="line">+ tree</span><br><span class="line">+ emu</span><br></pre></td></tr></table></figure>
<p><code>difflib.restore</code>(<em>sequence</em>, <em>which</em>)</p>
<p>返回两个序列中产生增量的那一个。</p>
<p>给出一个由 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ.compare" target="_blank" rel="noopener"><code>Differ.compare()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.ndiff" target="_blank" rel="noopener"><code>ndiff()</code></a> 产生的 <em>序列</em>，提取出来自文件 1 或 2 (<em>which</em> 形参) 的行，去除行前缀。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>diff = ndiff(<span class="string">'one\ntwo\nthree\n'</span>.splitlines(keepends=<span class="literal">True</span>),</span><br><span class="line"><span class="meta">... </span>            <span class="string">'ore\ntree\nemu\n'</span>.splitlines(keepends=<span class="literal">True</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>diff = list(diff) <span class="comment"># materialize the generated delta into a list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">''</span>.join(restore(diff, <span class="number">1</span>)), end=<span class="string">""</span>)</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">''</span>.join(restore(diff, <span class="number">2</span>)), end=<span class="string">""</span>)</span><br><span class="line">ore</span><br><span class="line">tree</span><br><span class="line">emu</span><br></pre></td></tr></table></figure>
<p><code>difflib.unified_diff</code>(<em>a</em>, <em>b</em>, <em>fromfile=’’</em>, <em>tofile=’’</em>, <em>fromfiledate=’’</em>, <em>tofiledate=’’</em>, <em>n=3</em>, <em>lineterm=’\n’</em>)</p>
<p>比较 <em>a</em> 和 <em>b</em> (字符串列表)；返回统一差异格式的增量信息 (一个产生增量行的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a>)。</p>
<p>所以统一差异是一种只显示有更改的行再加几个上下文行的紧凑形式。 更改被显示为内联的样式（而不是分开的之前/之后文本块）。 上下文行数由 <em>n</em> 设定，默认为三行。</p>
<p>默认情况下，差异控制行 (以 <code>---</code>, <code>+++</code> 或 <code>@@</code> 表示) 是通过末尾换行符来创建的。 这样做的好处是从 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.readlines" target="_blank" rel="noopener"><code>io.IOBase.readlines()</code></a> 创建的输入将得到适用于 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.writelines" target="_blank" rel="noopener"><code>io.IOBase.writelines()</code></a> 的差异信息，因为输入和输出都带有末尾换行符。</p>
<p>对于没有末尾换行符的输入，应将 <em>lineterm</em> 参数设为 <code>&quot;&quot;</code>，这样输出内容将统一不带换行符。</p>
<p>上下文差异格式通常带有一个记录文件名和修改时间的标头。 这些信息的部分或全部可以使用字符串 <em>fromfile</em>, <em>tofile</em>, <em>fromfiledate</em> 和 <em>tofiledate</em> 来指定。 修改时间通常以 ISO 8601 格式表示。 如果未指定，这些字符串默认为空。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = [<span class="string">'bacon\n'</span>, <span class="string">'eggs\n'</span>, <span class="string">'ham\n'</span>, <span class="string">'guido\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = [<span class="string">'python\n'</span>, <span class="string">'eggy\n'</span>, <span class="string">'hamster\n'</span>, <span class="string">'guido\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.writelines(unified_diff(s1, s2, fromfile=<span class="string">'before.py'</span>,tofile=<span class="string">'after.py'</span>))</span><br><span class="line">--- before.py</span><br><span class="line">+++ after.py</span><br><span class="line"><span class="meta">@@ -1,4 +1,4 @@</span></span><br><span class="line">-bacon</span><br><span class="line">-eggs</span><br><span class="line">-ham</span><br><span class="line">+python</span><br><span class="line">+eggy</span><br><span class="line">+hamster</span><br><span class="line"> guido</span><br></pre></td></tr></table></figure>
<p><code>difflib.diff_bytes</code>(<em>dfunc</em>, <em>a</em>, <em>b</em>, <em>fromfile=b’’</em>, <em>tofile=b’’</em>, <em>fromfiledate=b’’</em>, <em>tofiledate=b’’</em>, <em>n=3</em>, <em>lineterm=b’\n’</em>)</p>
<p>使用 <em>dfunc</em> 比较 <em>a</em> 和 <em>b</em> (字节串对象列表)；产生以 <em>dfunc</em> 所返回格式表示的差异行列表（也是字节串）。 <em>dfunc</em> 必须是可调用对象，通常为 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.unified_diff" target="_blank" rel="noopener"><code>unified_diff()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.context_diff" target="_blank" rel="noopener"><code>context_diff()</code></a>。</p>
<p>允许你比较编码未知或不一致的数据。 除 <em>n</em> 之外的所有输入都必须为字节串对象而非字符串。 作用方式为无损地将所有输入 (除 <em>n</em> 之外) 转换为字符串，并调用 <code>dfunc(a, b, fromfile, tofile, fromfiledate, tofiledate, n, lineterm)</code>。 <em>dfunc</em> 的输出会被随即转换回字节串，这样你所得到的增量行将具有与 <em>a</em> 和 <em>b</em> 相同的未知/不一致编码。</p>
<p><code>difflib.IS_LINE_JUNK</code>(<em>line</em>)</p>
<p>对于可忽略的行返回 <code>True</code>。 如果 <em>line</em> 为空行或只包含单个 <code>&#39;#&#39;</code> 则 <em>line</em> 行就是可忽略的，否则就是不可忽略的。 此函数被用作较旧版本 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.ndiff" target="_blank" rel="noopener"><code>ndiff()</code></a> 中 <em>linejunk</em> 形参的默认值。    </p>
<p><code>difflib.IS_CHARACTER_JUNK</code></p>
<p>对于可忽略的字符返回 <code>True</code>。 字符 <em>ch</em> 如果为空格符或制表符则 <em>ch</em> 就是可忽略的，否则就是不可忽略的。 此函数被用作 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.ndiff" target="_blank" rel="noopener"><code>ndiff()</code></a> 中 <em>charjunk</em> 形参的默认值。</p>
<h2 id="SequenceMatcher-对象"><a href="#SequenceMatcher-对象" class="headerlink" title="SequenceMatcher 对象"></a>SequenceMatcher 对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher" target="_blank" rel="noopener"><code>SequenceMatcher</code></a> 类具有这样的构造器：</p>
<p><em>class</em> <code>difflib.SequenceMatcher</code>(<em>isjunk=None</em>, <em>a=’’</em>, <em>b=’’</em>, <em>autojunk=True</em>)</p>
<p>可选参数 <em>isjunk</em> 必须为 <code>None</code> (默认值) 或为接受一个序列元素并当且仅当其为应忽略的“垃圾”元素时返回真值的单参数函数。 传入 <code>None</code> 作为 <em>isjunk</em> 的值就相当于传入 <code>lambda x: False</code>；也就是说不忽略任何值。 例如，传入:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x: x <span class="keyword">in</span> <span class="string">" \t"</span></span><br></pre></td></tr></table></figure>
<p>如果你以字符序列的形式对行进行比较，并且不希望区分空格符或硬制表符。</p>
<p>可选参数 <em>a</em> 和 <em>b</em> 为要比较的序列；两者默认为空字符串。 两个序列的元素都必须为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a>。</p>
<p>可选参数 <em>autojunk</em> 可用于启用自动垃圾启发式计算。</p>
<p>SequenceMatcher 对象接受三个数据属性: <em>bjunk</em> 是 <em>b</em> 当中 <em>isjunk</em> 为 <code>True</code> 的元素集合；<em>bpopular</em> 是被启发式计算（如果其未被禁用）视为热门候选的非垃圾元素集合；<em>b2j</em> 是将 <em>b</em> 当中剩余元素映射到一个它们出现位置列表的字典。 所有三个数据属性将在 <em>b</em> 通过 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.set_seqs" target="_blank" rel="noopener"><code>set_seqs()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.set_seq2" target="_blank" rel="noopener"><code>set_seq2()</code></a> 重置时被重置。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><code>set_seqs</code>(<em>a</em>, <em>b</em>)</li>
</ul>
<p>设置要比较的两个序列。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher" target="_blank" rel="noopener"><code>SequenceMatcher</code></a> 计算并缓存有关第二个序列的详细信息，这样如果你想要将一个序列与多个序列进行比较，可使用 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.set_seq2" target="_blank" rel="noopener"><code>set_seq2()</code></a> 一次性地设置该常用序列并重复地对每个其他序列各调用一次 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.set_seq1" target="_blank" rel="noopener"><code>set_seq1()</code></a>。</p>
<ul>
<li><p><code>set_seq1</code>(<em>a</em>)</p>
<p>设置要比较的第一个序列。 要比较的第二个序列不会改变。</p>
</li>
<li><p><code>set_seq2</code>(<em>b</em>)</p>
<p>设置要比较的第二个序列。 要比较的第一个序列不会改变。</p>
</li>
<li><p><code>find_longest_match</code>(<em>alo</em>, <em>ahi</em>, <em>blo</em>, <em>bhi</em>)</p>
<p>找出 <code>a[alo:ahi]</code> 和 <code>b[blo:bhi]</code> 中的最长匹配块。</p>
<p>如果 <em>isjunk</em> 被省略或为 <code>None</code>，<a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.find_longest_match" target="_blank" rel="noopener"><code>find_longest_match()</code></a> 将返回 <code>(i, j, k)</code> 使得 <code>a[i:i+k]</code> 等于 <code>b[j:j+k]</code>，其中 <code>alo &lt;= i &lt;= i+k &lt;= ahi</code> 并且 <code>blo &lt;= j &lt;= j+k &lt;= bhi</code>。 对于所有满足这些条件的 <code>(i&#39;, j&#39;, k&#39;)</code>，如果 <code>i == i&#39;</code>, <code>j &lt;= j&#39;</code> 也被满足，则附加条件 <code>k &gt;= k&#39;</code>, <code>i &lt;= i&#39;</code>。 换句话说，对于所有最长匹配块，返回在 <em>a</em> 当中最先出现的一个，而对于在 <em>a</em> 当中最先出现的所有最长匹配块，则返回在 <em>b</em> 当中最先出现的一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SequenceMatcher(<span class="literal">None</span>, <span class="string">" abcd"</span>, <span class="string">"abcd abcd"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.find_longest_match(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">Match(a=<span class="number">0</span>, b=<span class="number">4</span>, size=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>如果提供了 <em>isjunk</em>，将按上述规则确定第一个最长匹配块，但额外附加不允许块内出现垃圾元素的限制。 然后将通过（仅）匹配两边的垃圾元素来尽可能地扩展该块。 这样结果块绝对不会匹配垃圾元素，除非同样的垃圾元素正好与有意义的匹配相邻。</p>
<p>这是与之前相同的例子，但是将空格符视为垃圾。 这将防止 <code>&#39; abcd&#39;</code> 直接与第二个序列末尾的 <code>&#39; abcd&#39;</code> 相匹配。 而只可以匹配 <code>&#39;abcd&#39;</code>，并且是匹配第二个序列最左边的 <code>&#39;abcd&#39;</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SequenceMatcher(<span class="keyword">lambda</span> x: x==<span class="string">" "</span>, <span class="string">" abcd"</span>, <span class="string">"abcd abcd"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.find_longest_match(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">Match(a=<span class="number">1</span>, b=<span class="number">0</span>, size=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>如果未找到匹配块，此方法将返回 <code>(alo, blo, 0)</code>。</p>
<p>此方法将返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-named-tuple" target="_blank" rel="noopener">named tuple</a> <code>Match(a, b, size)</code>。</p>
</li>
<li><p><code>get_matching_blocks</code>()</p>
</li>
</ul>
<p>返回描述非重叠匹配子序列的三元组列表。 每个三元组的形式为 <code>(i, j, n)</code>，其含义为 <code>a[i:i+n] == b[j:j+n]</code>。 这些三元组按 <em>i</em> 和 <em>j</em> 单调递增排列。</p>
<p>最后一个三元组用于占位，其值为 <code>(len(a), len(b), 0)</code>。 它是唯一 <code>n == 0</code> 的三元组。 如果 <code>(i, j, n)</code> 和 <code>(i&#39;, j&#39;, n&#39;)</code> 是在列表中相邻的三元组，且后者不是列表中的最后一个三元组，则 <code>i+n &lt; i&#39;</code> 或 <code>j+n &lt; j&#39;</code>；换句话说，相邻的三元组总是描述非相邻的相等块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SequenceMatcher(<span class="literal">None</span>, <span class="string">"abxcd"</span>, <span class="string">"abcd"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.get_matching_blocks()</span><br><span class="line">[Match(a=<span class="number">0</span>, b=<span class="number">0</span>, size=<span class="number">2</span>), Match(a=<span class="number">3</span>, b=<span class="number">2</span>, size=<span class="number">2</span>), Match(a=<span class="number">5</span>, b=<span class="number">4</span>, size=<span class="number">0</span>)]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>get_opcodes</code>()</li>
</ul>
<p>返回描述如何将 <em>a</em> 变为 <em>b</em> 的 5 元组列表，每个元组的形式为 <code>(tag, i1, i2, j1, j2)</code>。 在第一个元组中 <code>i1 == j1 == 0</code>，而在其余的元组中 <em>i1</em> 等于前一个元组的 <em>i2</em>，并且 <em>j1</em> 也等于前一个元组的 <em>j2</em>。</p>
<p><em>tag</em> 值为字符串，其含义如下：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&#39;replace&#39;</code></td>
<td><code>a[i1:i2]</code> 应由 <code>b[j1:j2]</code> 替换。</td>
</tr>
<tr>
<td><code>&#39;delete&#39;</code></td>
<td><code>a[i1:i2]</code> 应被删除。 请注意在此情况下 <code>j1 == j2</code>。</td>
</tr>
<tr>
<td><code>&#39;insert&#39;</code></td>
<td><code>b[j1:j2]</code> 应插入到 <code>a[i1:i1]</code>。 请注意在此情况下 <code>i1 == i2</code>。</td>
</tr>
<tr>
<td><code>&#39;equal&#39;</code></td>
<td><code>a[i1:i2] == b[j1:j2]</code> (两个子序列相同)。</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"qabxcd"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"abycdf"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SequenceMatcher(<span class="literal">None</span>, a, b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> tag, i1, i2, j1, j2 <span class="keyword">in</span> s.get_opcodes():</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'&#123;:7&#125;   a[&#123;&#125;:&#123;&#125;] --&gt; b[&#123;&#125;:&#123;&#125;] &#123;!r:&gt;8&#125; --&gt; &#123;!r&#125;'</span>.format(</span><br><span class="line"><span class="meta">... </span>        tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2]))</span><br><span class="line">delete    a[0:1] --&gt; b[0:0]      'q' --&gt; ''</span><br><span class="line">equal     a[1:3] --&gt; b[0:2]     'ab' --&gt; 'ab'</span><br><span class="line">replace   a[3:4] --&gt; b[2:3]      'x' --&gt; 'y'</span><br><span class="line">equal     a[4:6] --&gt; b[3:5]     'cd' --&gt; 'cd'</span><br><span class="line">insert    a[6:6] --&gt; b[5:6]       '' --&gt; 'f'</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>get_grouped_opcodes</code>(<em>n=3</em>)</p>
<p>返回一个带有最多 <em>n</em> 行上下文的分组的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a>。从 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.get_opcodes" target="_blank" rel="noopener"><code>get_opcodes()</code></a> 所返回的组开始，此方法会拆分出较小的更改簇并消除没有更改的间隔区域。这些分组以与 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.get_opcodes" target="_blank" rel="noopener"><code>get_opcodes()</code></a> 相同的格式返回。</p>
</li>
<li><p><code>ratio</code>()</p>
<p>返回一个取值范围 [0, 1] 的浮点数作为序列相似性度量。其中 T 是两个序列中元素的总数量，M 是匹配的数量，即 2.0*M / T。 请注意如果两个序列完全相同则该值为 <code>1.0</code>，如果两者完全不同则为 <code>0.0</code>。如果 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.get_matching_blocks" target="_blank" rel="noopener"><code>get_matching_blocks()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.get_opcodes" target="_blank" rel="noopener"><code>get_opcodes()</code></a> 尚未被调用则此方法运算消耗较大，在此情况下你可能需要先调用 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.quick_ratio" target="_blank" rel="noopener"><code>quick_ratio()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.real_quick_ratio" target="_blank" rel="noopener"><code>real_quick_ratio()</code></a> 来获取一个上界。</p>
</li>
</ul>
<blockquote>
<p>注意: <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.ratio" target="_blank" rel="noopener"><code>ratio()</code></a> 调用的结果可能会取决于参数的顺序。 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; SequenceMatcher(<span class="literal">None</span>, <span class="string">'tide'</span>, <span class="string">'diet'</span>).ratio()</span><br><span class="line">&gt; <span class="number">0.25</span></span><br><span class="line">&gt; &gt;&gt;&gt; SequenceMatcher(<span class="literal">None</span>, <span class="string">'diet'</span>, <span class="string">'tide'</span>).ratio()</span><br><span class="line">&gt; <span class="number">0.5</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><code>quick_ratio</code>()</p>
<p>相对快速地返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.ratio" target="_blank" rel="noopener"><code>ratio()</code></a> 的上界。</p>
</li>
<li><p><code>real_quick_ratio</code>()</p>
<p>非常快速地返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.ratio" target="_blank" rel="noopener"><code>ratio()</code></a> 的上界。</p>
<p>这三个返回匹配部分占字符总数的比率的方法可能由于不同的近似级别而给出不一样的结果，但是 <code>quick_ratio()</code> 和 <code>real_quick_ratio()</code> 总是会至少与 <code>ratio()</code> 一样大：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SequenceMatcher(<span class="literal">None</span>, <span class="string">"abcd"</span>, <span class="string">"bcde"</span>)</span><br><span class="line">s.ratio()</span><br><span class="line"><span class="number">0.75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.quick_ratio()</span><br><span class="line"><span class="number">0.75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.real_quick_ratio()</span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<h2 id="SequenceMatcher-的示例"><a href="#SequenceMatcher-的示例" class="headerlink" title="SequenceMatcher 的示例"></a>SequenceMatcher 的示例</h2><p>以下示例比较两个字符串，并将空格视为“垃圾”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SequenceMatcher(<span class="keyword">lambda</span> x: x == <span class="string">" "</span>,</span><br><span class="line"><span class="meta">... </span>                   <span class="string">"private Thread currentThread;"</span>,</span><br><span class="line"><span class="meta">... </span>                   <span class="string">"private volatile Thread currentThread;"</span>)</span><br></pre></td></tr></table></figure>
<p><code>ratio()</code> 返回一个 [0, 1] 范围内的整数作为两个序列相似性的度量。 根据经验，<code>ratio()</code> 值超过 0.6 就意味着两个序列是近似匹配的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(round(s.ratio(), <span class="number">3</span>))</span><br><span class="line"><span class="number">0.866</span></span><br></pre></td></tr></table></figure>
<p>如果你只对两个序列相匹配的位置感兴趣，则 <code>get_matching_blocks()</code> 就很方便：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> block <span class="keyword">in</span> s.get_matching_blocks():</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"a[%d] and b[%d] match for %d elements"</span> % block)</span><br><span class="line">a[<span class="number">0</span>] <span class="keyword">and</span> b[<span class="number">0</span>] match <span class="keyword">for</span> <span class="number">8</span> elements</span><br><span class="line">a[<span class="number">8</span>] <span class="keyword">and</span> b[<span class="number">17</span>] match <span class="keyword">for</span> <span class="number">21</span> elements</span><br><span class="line">a[<span class="number">29</span>] <span class="keyword">and</span> b[<span class="number">38</span>] match <span class="keyword">for</span> <span class="number">0</span> elements</span><br></pre></td></tr></table></figure>
<p>请注意 <code>get_matching_blocks()</code> 返回的最后一个元组总是只用于占位的 <code>(len(a), len(b), 0)</code>，这也是元组末尾元素（匹配的元素数量）为 <code>0</code> 的唯一情况。</p>
<p>如果你想要知道如何将第一个序列转成第二个序列，可以使用 <code>get_opcodes()</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> opcode <span class="keyword">in</span> s.get_opcodes():</span><br><span class="line"><span class="meta">... </span>   print(<span class="string">"%6s a[%d:%d] b[%d:%d]"</span> % opcode)</span><br><span class="line"> equal a[<span class="number">0</span>:<span class="number">8</span>] b[<span class="number">0</span>:<span class="number">8</span>]</span><br><span class="line">insert a[<span class="number">8</span>:<span class="number">8</span>] b[<span class="number">8</span>:<span class="number">17</span>]</span><br><span class="line"> equal a[<span class="number">8</span>:<span class="number">29</span>] b[<span class="number">17</span>:<span class="number">38</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Differ-对象"><a href="#Differ-对象" class="headerlink" title="Differ 对象"></a>Differ 对象</h2><p>请注意 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ" target="_blank" rel="noopener"><code>Differ</code></a> 所生成的增量并不保证是 <strong>最小</strong> 差异。 相反，最小差异往往是违反直觉的，因为它们会同步任何可能的地方，有时甚至意外产生相距 100 页的匹配。 将同步点限制为连续匹配保留了一些局部性概念，这偶尔会带来产生更长差异的代价。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ" target="_blank" rel="noopener"><code>Differ</code></a> 类具有这样的构造器：</p>
<p><em>class</em> <code>difflib.Differ</code>(<em>linejunk=None</em>, <em>charjunk=None</em>)</p>
<p>可选关键字形参 <em>linejunk</em> 和 <em>charjunk</em> 均为过滤函数 (或为 <code>None</code>)：</p>
<p><em>linejunk</em>: 接受单个字符串作为参数的函数，如果其为垃圾字符串则返回真值。 默认值为 <code>None</code>，意味着没有任何行会被视为垃圾行。</p>
<p><em>charjunk</em>: 接受单个字符（长度为 1 的字符串）作为参数的函数，如果其为垃圾字符则返回真值。 默认值为 <code>None</code>，意味着没有任何字符会被视为垃圾字符。</p>
<p>这些垃圾过滤函数可加快查找差异的匹配速度，并且不会导致任何差异行或字符被忽略。 请阅读 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.find_longest_match" target="_blank" rel="noopener"><code>find_longest_match()</code></a> 方法的 <em>isjunk</em> 形参的描述了解详情。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ" target="_blank" rel="noopener"><code>Differ</code></a> 对象是通过一个单独方法来使用（生成增量）的：</p>
<ul>
<li><p><code>compare</code>(<em>a</em>, <em>b</em>)</p>
<p>比较两个由行组成的序列，并生成增量（一个由行组成的序列）。每个序列必须包含一个以换行符结尾的单行字符串。 这样的序列可以通过文件类对象的 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.readlines" target="_blank" rel="noopener"><code>readlines()</code></a> 方法来获取。 所生成的增量同样由以换行符结尾的字符串构成，可以通过文件类对象的 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.writelines" target="_blank" rel="noopener"><code>writelines()</code></a> 方法原样打印出来。</p>
</li>
</ul>
<h2 id="Differ-示例"><a href="#Differ-示例" class="headerlink" title="Differ 示例"></a>Differ 示例</h2><p>此示例比较两段文本。 首先我们设置文本为以换行符结尾的单行字符串构成的序列（这样的序列也可以通过文件类对象的 <code>readlines()</code> 方法来获取）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text1 = <span class="string">'''  1. Beautiful is better than ugly.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  2. Explicit is better than implicit.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  3. Simple is better than complex.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  4. Complex is better than complicated.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>'''</span>.splitlines(keepends=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(text1)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text1[<span class="number">0</span>][<span class="number">-1</span>]</span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text2 = <span class="string">'''  1. Beautiful is better than ugly.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  3.   Simple is better than complex.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  4. Complicated is better than complex.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  5. Flat is better than nested.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>'''</span>.splitlines(keepends=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>接下来我们实例化一个 Differ 对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Differ()</span><br></pre></td></tr></table></figure>
<p>请注意在实例化 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ" target="_blank" rel="noopener"><code>Differ</code></a> 对象时我们可以传入函数来过滤掉“垃圾”行和字符。 详情参见 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ" target="_blank" rel="noopener"><code>Differ()</code></a> 构造器说明。</p>
<p>最后，我们比较两个序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = list(d.compare</span><br></pre></td></tr></table></figure>
<p><code>result</code> 是一个字符串列表，让我们将其美化打印出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint(result)</span><br><span class="line">[<span class="string">'    1. Beautiful is better than ugly.\n'</span>,</span><br><span class="line"> <span class="string">'-   2. Explicit is better than implicit.\n'</span>,</span><br><span class="line"> <span class="string">'-   3. Simple is better than complex.\n'</span>,</span><br><span class="line"> <span class="string">'+   3.   Simple is better than complex.\n'</span>,</span><br><span class="line"> <span class="string">'?     ++\n'</span>,</span><br><span class="line"> <span class="string">'-   4. Complex is better than complicated.\n'</span>,</span><br><span class="line"> <span class="string">'?            ^                     ---- ^\n'</span>,</span><br><span class="line"> <span class="string">'+   4. Complicated is better than complex.\n'</span>,</span><br><span class="line"> <span class="string">'?           ++++ ^                      ^\n'</span>,</span><br><span class="line"> <span class="string">'+   5. Flat is better than nested.\n'</span>]</span><br></pre></td></tr></table></figure>
<p>作为单独的多行字符串显示出来则是这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.writelines(result)</span><br><span class="line">    <span class="number">1.</span> Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line">-   <span class="number">2.</span> Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line">-   <span class="number">3.</span> Simple <span class="keyword">is</span> better than complex.</span><br><span class="line">+   <span class="number">3.</span>   Simple <span class="keyword">is</span> better than complex.</span><br><span class="line">?     ++</span><br><span class="line">-   <span class="number">4.</span> Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">?            ^                     ---- ^</span><br><span class="line">+   <span class="number">4.</span> Complicated <span class="keyword">is</span> better than complex.</span><br><span class="line">?           ++++ ^                      ^</span><br><span class="line">+   <span class="number">5.</span> Flat <span class="keyword">is</span> better than nested.</span><br></pre></td></tr></table></figure>
<h2 id="difflib-的命令行接口"><a href="#difflib-的命令行接口" class="headerlink" title="difflib 的命令行接口"></a>difflib 的命令行接口</h2><p>这个实例演示了如何使用 difflib 来创建一个类似于 <code>diff</code> 的工具。 它同样包含在 Python 源码发布包中，文件名为 <code>Tools/scripts/diff.py</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">""" Command line interface to difflib.py providing diffs in four formats:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* ndiff:    lists every line and highlights interline changes.</span></span><br><span class="line"><span class="string">* context:  highlights clusters of changes in a before/after format.</span></span><br><span class="line"><span class="string">* unified:  highlights clusters of changes in an inline format.</span></span><br><span class="line"><span class="string">* html:     generates side by side comparison with change highlights.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os, difflib, argparse</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timezone</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_mtime</span><span class="params">(path)</span>:</span></span><br><span class="line">    t = datetime.fromtimestamp(os.stat(path).st_mtime,</span><br><span class="line">                               timezone.utc)</span><br><span class="line">    <span class="keyword">return</span> t.astimezone().isoformat()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'-c'</span>, action=<span class="string">'store_true'</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        help=<span class="string">'Produce a context format diff (default)'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-u'</span>, action=<span class="string">'store_true'</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        help=<span class="string">'Produce a unified format diff'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-m'</span>, action=<span class="string">'store_true'</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        help=<span class="string">'Produce HTML side by side diff '</span></span><br><span class="line">                             <span class="string">'(can use -c and -l in conjunction)'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-n'</span>, action=<span class="string">'store_true'</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        help=<span class="string">'Produce a ndiff format diff'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-l'</span>, <span class="string">'--lines'</span>, type=int, default=<span class="number">3</span>,</span><br><span class="line">                        help=<span class="string">'Set number of context lines (default 3)'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'fromfile'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'tofile'</span>)</span><br><span class="line">    options = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    n = options.lines</span><br><span class="line">    fromfile = options.fromfile</span><br><span class="line">    tofile = options.tofile</span><br><span class="line"></span><br><span class="line">    fromdate = file_mtime(fromfile)</span><br><span class="line">    todate = file_mtime(tofile)</span><br><span class="line">    <span class="keyword">with</span> open(fromfile) <span class="keyword">as</span> ff:</span><br><span class="line">        fromlines = ff.readlines()</span><br><span class="line">    <span class="keyword">with</span> open(tofile) <span class="keyword">as</span> tf:</span><br><span class="line">        tolines = tf.readlines()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> options.u:</span><br><span class="line">        diff = difflib.unified_diff(fromlines, tolines, fromfile, tofile, fromdate, todate, n=n)</span><br><span class="line">    <span class="keyword">elif</span> options.n:</span><br><span class="line">        diff = difflib.ndiff(fromlines, tolines)</span><br><span class="line">    <span class="keyword">elif</span> options.m:</span><br><span class="line">        diff = difflib.HtmlDiff().make_file(fromlines,tolines,fromfile,tofile,context=options.c,numlines=n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        diff = difflib.context_diff(fromlines, tolines, fromfile, tofile, fromdate, todate, n=n)</span><br><span class="line"></span><br><span class="line">    sys.stdout.writelines(diff)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="补充关于HtmlDiff类用法"><a href="#补充关于HtmlDiff类用法" class="headerlink" title="补充关于HtmlDiff类用法"></a>补充关于<code>HtmlDiff</code>类用法</h2><p>结合webbrowser创建差异比较页面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> difflib</span><br><span class="line"><span class="keyword">import</span> webbrowser</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_diff</span><span class="params">(self, index, wrapcolumn)</span>:</span></span><br><span class="line">       file1, file2 = self.differing[index]</span><br><span class="line">       <span class="keyword">with</span> open(file1, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">           content1 = f.read().splitlines()</span><br><span class="line">       <span class="keyword">with</span> open(file2, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">           content2 = f.read().splitlines()</span><br><span class="line">       htmlDiff = HtmlDiff(tabsize=<span class="number">2</span>,wrapcolumn=wrapcolumn)</span><br><span class="line">       <span class="keyword">with</span> open(<span class="string">'tmp.html'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">           f.write(htmlDiff.make_file(content1, content2, fromdesc=self.dir1, todesc=self.dir2))</span><br><span class="line">       webbrowser.open(<span class="string">'tmp.html'</span>)</span><br></pre></td></tr></table></figure>
<p>对比Nginx配置文件差异脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> difflib</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    textfile1 = sys.argv[<span class="number">1</span>]</span><br><span class="line">    textfile2 = sys.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    print(<span class="string">"Error:"</span> + str(e))</span><br><span class="line">    print(<span class="string">"Usage: xxxx.py filename1 filename2"</span>)</span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readfile</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fileHandle = open(filename,<span class="string">'r'</span>)</span><br><span class="line">        text = fileHandle.read().splitlines()</span><br><span class="line">        fileHandle.close()</span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line">    <span class="keyword">except</span> IOError <span class="keyword">as</span> error:</span><br><span class="line">        print(<span class="string">'Read file Error:'</span> + str(error))</span><br><span class="line">        sys.exit()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> textfile1 == <span class="string">""</span> <span class="keyword">or</span> textfile2 == <span class="string">""</span>:</span><br><span class="line">    print(<span class="string">"Usage:test.py filename1 filename2"</span>)</span><br><span class="line">    sys.exit()</span><br><span class="line"> </span><br><span class="line">text1_lines = readfile(textfile1)</span><br><span class="line">text2_lines = readfile(textfile2)</span><br><span class="line"> </span><br><span class="line">d = difflib.HtmlDiff()</span><br><span class="line">print(d.make_file(text1_lines,text2_lines))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>difflib</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library reprlib</title>
    <url>/2020/01/26/python-standard-library-reprlib/</url>
    <content><![CDATA[<h1 id="python-标准库-reprlib"><a href="#python-标准库-reprlib" class="headerlink" title="python 标准库 reprlib"></a>python 标准库 reprlib</h1><p><img src="https://n.sinaimg.cn/news/719/w600h919/20200126/eb39-innckcf7806867.png" alt></p>
<a id="more"></a>
<p><strong>武汉挺住！！！</strong></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#module-reprlib" target="_blank" rel="noopener"><code>reprlib</code></a> 模块提供了一种对象表示的产生方式，它会对结果字符串的大小进行限制。 该方式被用于 Python 调试器，也适用于某些其他场景。</p>
<p>此模块提供了一个类、一个实例和一个函数：</p>
<ul>
<li><p><em>class</em> <code>reprlib.Repr</code> </p>
<p>该类提供了格式化服务 适用于实现与内置 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 相似的方法；其中附加了针对不同对象类型的大小限制，以避免生成超长的表示。 </p>
</li>
<li><p><code>reprlib.aRepr</code> </p>
<p>这是 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr" target="_blank" rel="noopener"><code>Repr</code></a> 的一个实例，用于提供如下所述的 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.repr" target="_blank" rel="noopener"><code>repr()</code></a> 函数。 改变此对象的属性将会影响 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.repr" target="_blank" rel="noopener"><code>repr()</code></a> 和 Python 调试器所使用的大小限制。 </p>
</li>
<li><p><code>reprlib.repr</code>(<em>obj</em>) </p>
<p>这是 <code>aRepr</code> 的 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.repr" target="_blank" rel="noopener"><code>repr()</code></a> 方法。 它会返回与同名内置函数所返回字符串相似的字符串，区别在于附带了对多数类型的大小限制。 </p>
<p>在大小限制工具以外，此模块还提供了一个装饰器，用于检测对 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> 的递归调用并改用一个占位符来替换。 </p>
</li>
<li><p><a href="mailto:`@reprlib.recursiv" target="_blank" rel="noopener">`@reprlib.recursiv</a>e_repr`(<em>fillvalue=”…”</em>) </p>
<p>用于为 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> 方法检测同一线程内部递归调用的装饰器。 如果执行了递归调用，则会返回 <em>fillvalue</em>，否则执行正常的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> 调用。 例如： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> reprlib <span class="keyword">import</span> recursive_repr</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list)</span>:</span></span><br><span class="line">---   @recursive_repr()</span><br><span class="line">---   <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">---        <span class="keyword">return</span> <span class="string">'&lt;'</span> + <span class="string">'|'</span>.join(map(repr, self)) + <span class="string">'&gt;'</span></span><br><span class="line">---</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = MyList(<span class="string">'abc'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.append(m)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.append(<span class="string">'x'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(m)</span><br><span class="line">&lt;<span class="string">'a'</span>|<span class="string">'b'</span>|<span class="string">'c'</span>|...|<span class="string">'x'</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Repr-对象"><a href="#Repr-对象" class="headerlink" title="Repr 对象"></a>Repr 对象</h2><p> <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr" target="_blank" rel="noopener"><code>Repr</code></a> 实例对象包含一些属性可以用于为不同对象类型的表示提供大小限制，还包含一些方法可以格式化特定的对象类型。 </p>
<ul>
<li><p><code>Repr.maxlevel</code></p>
<p>创建递归表示形式的深度限制。 默认为 <code>6</code>。</p>
</li>
<li><p><code>Repr.maxdict</code></p>
</li>
<li><p><code>Repr.maxlist</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> reprlib  </span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line">reprlib.aRepr.maxlist = <span class="number">2</span>  </span><br><span class="line">print(reprlib.repr(a))  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Repr.maxtuple</code></p>
</li>
<li><p><code>Repr.maxset</code></p>
</li>
<li><p><code>Repr.maxfrozenset</code></p>
</li>
<li><p><code>Repr.maxdeque</code></p>
</li>
<li><p><code>Repr.maxarray</code></p>
<p>代表命名对象类型的条目数量限制。 对于 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.maxdict" target="_blank" rel="noopener"><code>maxdict</code></a> 的默认值为 <code>4</code>，对于 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.maxarray" target="_blank" rel="noopener"><code>maxarray</code></a> 为 <code>5</code>，对于其他则为 <code>6</code>。</p>
</li>
<li><p><code>Repr.maxlong</code></p>
<p>表示整数的最大字符数量。 数码会从中间被丢弃。 默认值为 <code>40</code>。</p>
</li>
<li><p><code>Repr.maxstring</code></p>
<p>表示字符串的字符数量限制。 请注意字符源会使用字符串的“正常”表示形式：如果表示中需要用到转义序列，在缩短表示时它们可能会被破坏。 默认值为 <code>30</code>。</p>
</li>
<li><p><code>Repr.maxother</code></p>
<p>此限制用于控制在 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr" target="_blank" rel="noopener"><code>Repr</code></a> 对象上没有特定的格式化方法可用的对象类型的大小。 它会以类似 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.maxstring" target="_blank" rel="noopener"><code>maxstring</code></a> 的方式被应用。 默认值为 <code>20</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">reprlib.aRepr.maxlevel = <span class="number">1</span></span><br><span class="line">print(reprlib.repr(a))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[...],<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>Repr.repr</code>(<em>obj</em>)</p>
<p>内置 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 的等价形式，它使用实例专属的格式化。</p>
</li>
<li><p><code>Repr.repr1</code>(<em>obj</em>, <em>level</em>)</p>
<p>供 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.repr" target="_blank" rel="noopener"><code>repr()</code></a> 使用的递归实现。 此方法使用 <em>obj</em> 的类型来确定要调用哪个格式化方法，并传入 <em>obj</em> 和 <em>level</em>。 类型专属的方法应当调用 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.repr1" target="_blank" rel="noopener"><code>repr1()</code></a> 来执行递归格式化，在递归调用中使用 <code>level - 1</code> 作为 <em>level</em> 的值。</p>
</li>
<li><p><code>Repr.repr_TYPE</code>(<em>obj</em>, <em>level</em>)</p>
<p>特定类型的格式化方法会被实现为基于类型名称来命名的方法。 在方法名称中，<strong>TYPE</strong> 会被替换为 <code>&#39;_&#39;.join(type(obj).__name__.split())</code>。 对这些方法的分派会由 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.repr1" target="_blank" rel="noopener"><code>repr1()</code></a> 来处理。 需要对值进行递归格式化的类型专属方法应当调用 <code>self.repr1(subobj, level - 1)</code>。</p>
</li>
</ul>
<h2 id="子类化-Repr-对象"><a href="#子类化-Repr-对象" class="headerlink" title="子类化 Repr 对象"></a>子类化 Repr 对象</h2><p> 通过 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.repr1" target="_blank" rel="noopener"><code>Repr.repr1()</code></a> 使用动态分派允许 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr" target="_blank" rel="noopener"><code>Repr</code></a> 的子类添加对额外内置对象类型的支持，或是修改对已支持类型的处理。 这个例子演示了如何添加对文件对象的特殊支持: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRepr</span><span class="params">(reprlib.Repr)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repr_TextIOWrapper</span><span class="params">(self, obj, level)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> obj.name <span class="keyword">in</span> &#123;<span class="string">'&lt;stdin&gt;'</span>, <span class="string">'&lt;stdout&gt;'</span>, <span class="string">'&lt;stderr&gt;'</span>&#125;:</span><br><span class="line">            <span class="keyword">return</span> obj.name</span><br><span class="line">        <span class="keyword">return</span> repr(obj)</span><br><span class="line"></span><br><span class="line">aRepr = MyRepr()</span><br><span class="line">print(aRepr.repr(sys.stdin))         <span class="comment"># prints '&lt;stdin&gt;'</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>reprlib</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library bisect</title>
    <url>/2020/01/24/python-standard-library-bisect/</url>
    <content><![CDATA[<h1 id="python-标准库-bisect-二分查找"><a href="#python-标准库-bisect-二分查找" class="headerlink" title="python 标准库 bisect 二分查找"></a>python 标准库 bisect 二分查找</h1><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200122/b1c38585d3a8429eaf0fee473dbcae7e.jpeg" alt></p>
<a id="more"></a>
<h2 id="何谓二分查找"><a href="#何谓二分查找" class="headerlink" title="何谓二分查找"></a>何谓二分查找</h2><p><img src="https://img-blog.csdn.net/20150821221951219" alt></p>
<h2 id="对比顺序查找"><a href="#对比顺序查找" class="headerlink" title="对比顺序查找"></a>对比顺序查找</h2><p><img src="http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/53%E9%80%92%E5%BD%92-%E4%BA%8C%E5%88%8623.gif" alt></p>
<p>通常我们实现二分查找是酱紫的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(li,find)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(li)<span class="number">-1</span> <span class="comment">## 需要减一否则会下标越界</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        middle = (low + high) /<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[middle] ==  find :</span><br><span class="line">            <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">elif</span> li[middle] &gt; find:</span><br><span class="line">            high = middle - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> li[middle] &lt; find:</span><br><span class="line">            low = middle + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    li = [x <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>,<span class="number">101</span>)]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">102</span>):</span><br><span class="line">        <span class="keyword">print</span> binary_search(li,x)</span><br></pre></td></tr></table></figure>
<p>python标准库中已经实现了二分查找。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p> <strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/bisect.py" target="_blank" rel="noopener">Lib/bisect.py</a> </p>
<p> 这个模块对有序列表提供了支持，使得他们可以在插入新数据仍然保持有序。对于长列表，如果其包含元素的比较操作十分昂贵的话，这可以是对更常见方法的改进。这个模块叫做 <a href="https://docs.python.org/zh-cn/3.8/library/bisect.html#module-bisect" target="_blank" rel="noopener"><code>bisect</code></a> 因为其使用了基本的二分（bisection）算法。源代码也可以作为很棒的算法示例（边界判断也做好啦！） </p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><code>bisect.bisect_left</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>) </li>
</ul>
<p>在 <em>a</em> 中找到 <em>x</em> 合适的插入点以维持有序。参数 <em>lo</em> 和 <em>hi</em> 可以被用于确定需要考虑的子集；默认情况下整个列表都会被使用。如果 <em>x</em> 已经在 <em>a</em> 里存在，那么插入点会在已存在元素之前（也就是左边）。如果 <em>a</em> 是列表（list）的话，返回值是可以被放在 <code>list.insert()</code> 的第一个参数的。</p>
<p>返回的插入点 <em>i</em> 可以将数组 <em>a</em> 分成两部分。左侧是 <code>all(val &lt; x for val in a[lo:i])</code> ，右侧是 <code>all(val &gt;= x for val in a[i:hi])</code> 。</p>
<ul>
<li><p><code>bisect.bisect_right</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>) </p>
</li>
<li><p><code>bisect.bisect</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>) </p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/bisect.html#bisect.bisect_left" target="_blank" rel="noopener"><code>bisect_left()</code></a>，但是返回的插入点是 <em>a</em> 中已存在元素 <em>x</em> 的右侧。</p>
<p>返回的插入点 <em>i</em> 可以将数组 <em>a</em> 分成两部分。左侧是 <code>all(val &lt;= x for val in a[lo:i])</code>，右侧是 <code>all(val &gt; x for val in a[i:hi])</code> for the right side。</p>
</li>
<li><p><code>bisect.insort_left</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>) </p>
<p>将 <em>x</em> 插入到一个有序序列 <em>a</em> 里，并维持其有序。如果 <em>a</em> 有序的话，这相当于 <code>a.insert(bisect.bisect_left(a, x, lo, hi), x)</code>。要注意搜索是 O(log n) 的，插入却是 O(n) 的。 </p>
</li>
<li><p><code>bisect.insort_right</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>) </p>
</li>
<li><p><code>bisect.insort</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>) </p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/bisect.html#bisect.insort_left" target="_blank" rel="noopener"><code>insort_left()</code></a>，但是把 <em>x</em> 插入到 <em>a</em> 中已存在元素 <em>x</em> 的右侧。 </p>
<blockquote>
<p> <a href="https://code.activestate.com/recipes/577197-sortedcollection/" target="_blank" rel="noopener">SortedCollection recipe</a> 使用 bisect 构造了一个功能完整的集合类，提供了直接的搜索方法和对用于搜索的 key 方法的支持。所有用于搜索的键都是预先计算的，以避免在搜索时对 key 方法的不必要调用。</p>
</blockquote>
</li>
</ul>
<h2 id="搜索有序列表"><a href="#搜索有序列表" class="headerlink" title="搜索有序列表"></a>搜索有序列表</h2><p> 上面的 <a href="https://docs.python.org/zh-cn/3.8/library/bisect.html#module-bisect" target="_blank" rel="noopener"><code>bisect()</code></a> 函数对于找到插入点是有用的，但在一般的搜索任务中可能会有点尴尬。下面 5 个函数展示了如何将其转变成有序列表中的标准查找函数 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'Locate the leftmost value exactly equal to x'</span></span><br><span class="line">    i = bisect_left(a, x)</span><br><span class="line">    <span class="keyword">if</span> i != len(a) <span class="keyword">and</span> a[i] == x:</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lt</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'Find rightmost value less than x'</span></span><br><span class="line">    i = bisect_left(a, x)</span><br><span class="line">    <span class="keyword">if</span> i:</span><br><span class="line">        <span class="keyword">return</span> a[i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_le</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'Find rightmost value less than or equal to x'</span></span><br><span class="line">    i = bisect_right(a, x)</span><br><span class="line">    <span class="keyword">if</span> i:</span><br><span class="line">        <span class="keyword">return</span> a[i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_gt</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'Find leftmost value greater than x'</span></span><br><span class="line">    i = bisect_right(a, x)</span><br><span class="line">    <span class="keyword">if</span> i != len(a):</span><br><span class="line">        <span class="keyword">return</span> a[i]</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_ge</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'Find leftmost item greater than or equal to x'</span></span><br><span class="line">    i = bisect_left(a, x)</span><br><span class="line">    <span class="keyword">if</span> i != len(a):</span><br><span class="line">        <span class="keyword">return</span> a[i]</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br></pre></td></tr></table></figure>
<h2 id="其他示例"><a href="#其他示例" class="headerlink" title="其他示例"></a>其他示例</h2><p> 函数 <a href="https://docs.python.org/zh-cn/3.8/library/bisect.html#module-bisect" target="_blank" rel="noopener"><code>bisect()</code></a> 还可以用于数字表查询。这个例子是使用 <a href="https://docs.python.org/zh-cn/3.8/library/bisect.html#module-bisect" target="_blank" rel="noopener"><code>bisect()</code></a> 从一个给定的考试成绩集合里，通过一个有序数字表，查出其对应的字母等级：90 分及以上是 ‘A’，80 到 89 是 ‘B’，以此类推 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(score, breakpoints=[<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>], grades=<span class="string">'FDCBA'</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    i = bisect(breakpoints, score)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> grades[i]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[grade(score) <span class="keyword">for</span> score <span class="keyword">in</span> [<span class="number">33</span>, <span class="number">99</span>, <span class="number">77</span>, <span class="number">70</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">100</span>]]</span><br><span class="line">[<span class="string">'F'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'A'</span>]</span><br></pre></td></tr></table></figure>
<p>与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> 函数不同，对于 <a href="https://docs.python.org/zh-cn/3.8/library/bisect.html#module-bisect" target="_blank" rel="noopener"><code>bisect()</code></a> 函数来说，<em>key</em> 或者 <em>reversed</em> 参数并没有什么意义。因为这会导致设计效率低下（连续调用 bisect 函数时，是不会 “记住” 过去查找过的键的）。</p>
<p>正相反，最好去搜索预先计算好的键列表，来查找相关记录的索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [(<span class="string">'red'</span>, <span class="number">5</span>), (<span class="string">'blue'</span>, <span class="number">1</span>), (<span class="string">'yellow'</span>, <span class="number">8</span>), (<span class="string">'black'</span>, <span class="number">0</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.sort(key=<span class="keyword">lambda</span> r: r[<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys = [r[<span class="number">1</span>] <span class="keyword">for</span> r <span class="keyword">in</span> data]         <span class="comment"># precomputed list of keys</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[bisect_left(keys, <span class="number">0</span>)]</span><br><span class="line">(<span class="string">'black'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[bisect_left(keys, <span class="number">1</span>)]</span><br><span class="line">(<span class="string">'blue'</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[bisect_left(keys, <span class="number">5</span>)]</span><br><span class="line">(<span class="string">'red'</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[bisect_left(keys, <span class="number">8</span>)]</span><br><span class="line">(<span class="string">'yellow'</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>bisect</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library timeit</title>
    <url>/2020/01/23/python-standard-library-timeit/</url>
    <content><![CDATA[<h1 id="python-标准库-timeit"><a href="#python-标准库-timeit" class="headerlink" title="python 标准库 timeit"></a>python 标准库 timeit</h1><p>每日一词:</p>
<blockquote>
<p>Pneumonia </p>
<p>n 肺炎</p>
<p> 2019 Novel coronavirus    (2019-nCoV)，<br>  世界卫生组织定义, 又名<strong>武汉冠状病毒</strong>（Wuhan coronavirus）、<strong>武汉肺炎</strong>（Wuhan pneumonia） </p>
<p> <strong>冠状病毒属</strong>的病毒是具外套膜（envelope） </p>
<p>例句:</p>
<p> The doctor diagnosed the illness as pneumonia .<br>医生诊断这病为肺炎。 </p>
<p> The doctor has cured her of pneumonia .<br>大夫把她的肺炎看好了。 </p>
<p> Fatalities usually come from pneumonia .<br>通常肺炎可引起死亡。 </p>
</blockquote>
<p><img src="https://img5.miaoshoucdn.com/2020/01/10/093040d3c8f09c598309db3381177ea2b2ec476497.jpg" alt></p>
<a id="more"></a>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/timeit.py" target="_blank" rel="noopener">Lib/timeit.py</a> </p>
<p> 该模块提供了一种简单的方法来计算一小段 Python 代码的耗时。它有 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#timeit-command-line-interface" target="_blank" rel="noopener">命令行界面</a> 以及一个 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#python-interface" target="_blank" rel="noopener">可调用</a> 方法。它避免了许多用于测量执行时间的常见陷阱。另见 Tim Peters 对 O’Reilly 出版的 <em>Python Cookbook</em> 中“算法”章节的介绍。 </p>
<h2 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h2><p> 以下示例显示了如何使用 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#timeit-command-line-interface" target="_blank" rel="noopener">命令行界面</a> 来比较三个不同的表达式： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python3 -m timeit <span class="string">'"-".join(str(n) for n in range(100))'</span></span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">5</span>: <span class="number">30.2</span> usec per loop</span><br><span class="line">$ python3 -m timeit <span class="string">'"-".join([str(n) for n in range(100)])'</span></span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">5</span>: <span class="number">27.5</span> usec per loop</span><br><span class="line">$ python3 -m timeit <span class="string">'"-".join(map(str, range(100)))'</span></span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">5</span>: <span class="number">23.2</span> usec per loop</span><br></pre></td></tr></table></figure>
<p> 这可以通过 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#python-interface" target="_blank" rel="noopener">Python 接口</a> 实现 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="string">'"-".join(str(n) for n in range(100))'</span>, number=<span class="number">10000</span>)</span><br><span class="line"><span class="number">0.3018611848820001</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="string">'"-".join([str(n) for n in range(100)])'</span>, number=<span class="number">10000</span>)</span><br><span class="line"><span class="number">0.2727368790656328</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="string">'"-".join(map(str, range(100)))'</span>, number=<span class="number">10000</span>)</span><br><span class="line"><span class="number">0.23702679807320237</span></span><br></pre></td></tr></table></figure>
<p> 从 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#python-interface" target="_blank" rel="noopener">Python 接口</a> 还可以传出一个可调用对象: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="keyword">lambda</span>: <span class="string">"-"</span>.join(map(str, range(<span class="number">100</span>))), number=<span class="number">10000</span>)</span><br><span class="line"><span class="number">0.19665591977536678</span></span><br></pre></td></tr></table></figure>
<p> 但请注意 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#timeit.timeit" target="_blank" rel="noopener"><code>timeit()</code></a> 仅在使用命令行界面时会自动确定重复次数。 在 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#timeit-examples" target="_blank" rel="noopener">示例</a> 一节你可以找到更多的进阶示例。 </p>
<h2 id="python接口"><a href="#python接口" class="headerlink" title="python接口"></a>python接口</h2><p> 该模块定义了三个便利函数和一个公共类： </p>
<ul>
<li><code>timeit.timeit</code>(<em>stmt=’pass’</em>, <em>setup=’pass’</em>, <em>timer=</em>, <em>number=1000000</em>, <em>globals=None</em>) </li>
<li><code>timeit.repeat</code>(<em>stmt=’pass’</em>, <em>setup=’pass’</em>, <em>timer=</em>, <em>repeat=5</em>, <em>number=1000000</em>, <em>globals=None</em>) </li>
<li><code>timeit.default_timer</code>() </li>
<li><em>class</em> <code>timeit.Timer</code>(<em>stmt=’pass’</em>, <em>setup=’pass’</em>, <em>timer=</em>, <em>globals=None</em>) <ul>
<li><code>timeit</code>(<em>number=1000000</em>) </li>
<li><code>autorange</code>(<em>callback=None</em>) </li>
<li><code>repeat</code>(<em>repeat=5</em>, <em>number=1000000</em>) </li>
<li><code>print_exc</code>(<em>file=None</em>) </li>
</ul>
</li>
</ul>
<h2 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h2><p> 从命令行调用程序时，使用以下表单: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m timeit [-n N] [-r N] [-u U] [-s S] [-h] [statement ...]</span><br></pre></td></tr></table></figure>
<p>如果了解以下选项：</p>
<ul>
<li><p><code>-n N, --number=N</code></p>
<p>执行 ‘语句’ 多少次</p>
</li>
<li><p><code>-r N, --repeat=N</code></p>
<p>重复计时器的次数（默认为5）</p>
</li>
<li><p><code>-s S, --setup=S</code></p>
<p>最初要执行一次的语句（默认为 <code>pass</code> ）</p>
</li>
<li><p>`-p, –process<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  测量进程时间，而不是 wallclock 时间，使用 [`time.process_time()`](https://docs.python.org/zh-cn/3.8/library/time.html#time.process_time) 而不是 [`time.perf_counter()`](https://docs.python.org/zh-cn/3.8/library/time.html#time.perf_counter) ，这是默认值*3.3 新版功能.*</span><br><span class="line"></span><br><span class="line">- `-u````, ``--unit``=U`</span><br><span class="line"></span><br><span class="line">  指定定时器输出的时间单位；可以选择 nsec，usec，msec或sec*3.5 新版功能.*</span><br><span class="line"></span><br><span class="line">- `-v````, ``--verbose</span><br></pre></td></tr></table></figure></p>
<p>打印原始计时结果；重复更多位数精度</p>
</li>
<li><p><code>-h```</code>, <code>--help`</code></p>
<p>打印一条简短的使用信息并退出</p>
</li>
</ul>
<p>可以通过将每一行指定为单独的语句参数来给出多行语句；通过在引号中包含参数并使用前导空格可以缩进行。多个 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#cmdoption-timeit-s" target="_blank" rel="noopener"><code>-s</code></a> 选项的处理方式相似。</p>
<p>如果 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#cmdoption-timeit-n" target="_blank" rel="noopener"><code>-n</code></a> 未给出，则通过尝试10的连续幂次来计算合适数量的循环，直到总时间至少为 0.2 秒。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#timeit.default_timer" target="_blank" rel="noopener"><code>default_timer()</code></a> 测量可能受到在同一台机器上运行的其他程序的影响，因此在需要精确计时时最好的做法是重复几次计时并使用最佳时间。 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#cmdoption-timeit-r" target="_blank" rel="noopener"><code>-r</code></a> 选项对此有利；在大多数情况下，默认的 5 次重复可能就足够了。 你可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#time.process_time" target="_blank" rel="noopener"><code>time.process_time()</code></a> 来测量CPU时间。</p>
<blockquote>
<p>执行 pass 语句会产生一定的基线开销。这里的代码不会试图隐藏它，但你应该知道它。可以通过不带参数调用程序来测量基线开销，并且Python版本之间可能会有所不同。</p>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p> 可以提供一个在开头只执行一次的 setup 语句： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -m timeit -s <span class="string">'text = "sample string"; char = "g"'</span>  <span class="string">'char in text'</span></span><br><span class="line"><span class="number">5000000</span> loops, best of <span class="number">5</span>: <span class="number">0.0877</span> usec per loop</span><br><span class="line">$ python -m timeit -s <span class="string">'text = "sample string"; char = "g"'</span>  <span class="string">'text.find(char)'</span></span><br><span class="line"><span class="number">1000000</span> loops, best of <span class="number">5</span>: <span class="number">0.342</span> usec per loop</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="string">'char in text'</span>, setup=<span class="string">'text = "sample string"; char = "g"'</span>)</span><br><span class="line"><span class="number">0.41440500499993504</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="string">'text.find(char)'</span>, setup=<span class="string">'text = "sample string"; char = "g"'</span>)</span><br><span class="line"><span class="number">1.7246671520006203</span></span><br></pre></td></tr></table></figure>
<p> 使用 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#timeit.Timer" target="_blank" rel="noopener"><code>Timer</code></a> 类及其方法可以完成同样的操作: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = timeit.Timer(<span class="string">'char in text'</span>, setup=<span class="string">'text = "sample string"; char = "g"'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.timeit()</span><br><span class="line"><span class="number">0.3955516149999312</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.repeat()</span><br><span class="line">[<span class="number">0.40183617287970225</span>, <span class="number">0.37027556854118704</span>, <span class="number">0.38344867356679524</span>, <span class="number">0.3712595970846668</span>, <span class="number">0.37866875250654886</span>]</span><br></pre></td></tr></table></figure>
<p> 以下示例显示如何计算包含多行的表达式。 在这里我们对比使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#hasattr" target="_blank" rel="noopener"><code>hasattr()</code></a> 与 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a>/<a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 的开销来测试缺失与提供对象属性: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -m timeit <span class="string">'try:'</span> <span class="string">'  str.__bool__'</span> <span class="string">'except AttributeError:'</span> <span class="string">'  pass'</span></span><br><span class="line"><span class="number">20000</span> loops, best of <span class="number">5</span>: <span class="number">15.7</span> usec per loop</span><br><span class="line">$ python -m timeit <span class="string">'if hasattr(str, "__bool__"): pass'</span></span><br><span class="line"><span class="number">50000</span> loops, best of <span class="number">5</span>: <span class="number">4.26</span> usec per loop</span><br><span class="line"></span><br><span class="line">$ python -m timeit <span class="string">'try:'</span> <span class="string">'  int.__bool__'</span> <span class="string">'except AttributeError:'</span> <span class="string">'  pass'</span></span><br><span class="line"><span class="number">200000</span> loops, best of <span class="number">5</span>: <span class="number">1.43</span> usec per loop</span><br><span class="line">$ python -m timeit <span class="string">'if hasattr(int, "__bool__"): pass'</span></span><br><span class="line"><span class="number">100000</span> loops, best of <span class="number">5</span>: <span class="number">2.23</span> usec per loop</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># attribute is missing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"""\</span></span><br><span class="line"><span class="string"><span class="meta">... </span>try:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    str.__bool__</span></span><br><span class="line"><span class="string"><span class="meta">... </span>except AttributeError:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    pass</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(stmt=s, number=<span class="number">100000</span>)</span><br><span class="line"><span class="number">0.9138244460009446</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"if hasattr(str, '__bool__'): pass"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(stmt=s, number=<span class="number">100000</span>)</span><br><span class="line"><span class="number">0.5829014980008651</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># attribute is present</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"""\</span></span><br><span class="line"><span class="string"><span class="meta">... </span>try:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    int.__bool__</span></span><br><span class="line"><span class="string"><span class="meta">... </span>except AttributeError:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    pass</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(stmt=s, number=<span class="number">100000</span>)</span><br><span class="line"><span class="number">0.04215312199994514</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"if hasattr(int, '__bool__'): pass"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(stmt=s, number=<span class="number">100000</span>)</span><br><span class="line"><span class="number">0.08588060699912603</span></span><br></pre></td></tr></table></figure>
<p> 要让 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#module-timeit" target="_blank" rel="noopener"><code>timeit</code></a> 模块访问你定义的函数，你可以传递一个包含 import 语句的 <em>setup</em> 参数: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Stupid test function"""</span></span><br><span class="line">    L = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> timeit</span><br><span class="line">    print(timeit.timeit(<span class="string">"test()"</span>, setup=<span class="string">"from __main__ import test"</span>))</span><br></pre></td></tr></table></figure>
<p> 另一种选择是将 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#globals" target="_blank" rel="noopener"><code>globals()</code></a> 传递给 <em>globals</em> 参数，这将导致代码在当前的全局命名空间中执行。这比单独指定 import 更方便 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line">print(timeit.timeit(<span class="string">'[func(42) for func in (f,g,h)]'</span>, globals=globals()))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>timeit</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library sqlite3</title>
    <url>/2020/01/20/python-standard-library-sqlite3/</url>
    <content><![CDATA[<h1 id="python-标准库-sqlite3"><a href="#python-标准库-sqlite3" class="headerlink" title="python 标准库 sqlite3"></a>python 标准库 sqlite3</h1><p>今天是二十四节气的大寒</p>
<blockquote>
<p>大寒，是<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8D%81%E5%9B%9B%E8%8A%82%E6%B0%94/191597" target="_blank" rel="noopener">二十四节气</a>中的最后一个节气。斗指丑；太阳<a href="https://baike.baidu.com/item/%E9%BB%84%E7%BB%8F/8303112" target="_blank" rel="noopener">黄经</a>为300°；公历1月20－21日交节。同小寒一样，大寒也是表示天气寒冷程度的节气。在我国部分地区，大寒不如小寒冷，但在某些年份和沿海少数地方，全年最低气温仍然会出现在大寒节气内。小寒、大寒是一年中雨水最少的时段。</p>
<p>兹大寒一过，新一年的节气就又轮回来了，正所谓冬去春来。大寒虽然寒冷，但因为已近春天，所以不会像大雪到冬至期间那样酷寒。这时节，人们开始忙着除旧饰新、腌制年肴、准备年货和各种祭祀供品、扫尘洁物，因为中国人最重要的节日——春节就要到了。</p>
<p>每日一词：</p>
<p>Cold </p>
<p>adj 冷,寒冷</p>
<p>例句：</p>
<p>  It is the last one in January 20th of each year twenty-four solar term solar term, before and after the sun reaches 300 degrees for it”. It is cold weather, meaning extreme.</p>
<p> 大寒是二十四节气中最后一个节气，每年1月20日前后太阳到达黄经300°时为”大寒”。大寒，是天气寒冷到极点的意思。</p>
</blockquote>
<p><img src="http://photos.tuchong.com/350832/f/4959845.jpg" alt></p>
<a id="more"></a>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/sqlite3/" target="_blank" rel="noopener">Lib/sqlite3/</a></p>
<p>SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL 查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再迁移到更大的数据库，比如 PostgreSQL 或 Oracle。</p>
<p>sqlite3 模块由 Gerhard Häring 编写。它提供了符合 DB-API 2.0 规范的接口，这个规范是 <a href="https://www.python.org/dev/peps/pep-0249" target="_blank" rel="noopener"><strong>PEP 249</strong></a>。</p>
<p>要使用这个模块，必须先创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象，它代表数据库。下面例子中，数据将存储在 <code>example.db</code> 文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line">conn = sqlite3.connect(<span class="string">'example.db'</span>)</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <code>:memory:</code> 来创建一个内存中的数据库</p>
<p>当有了 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象后，你可以创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 游标对象，然后调用它的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> 方法来执行 SQL 语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c = conn.cursor()</span><br><span class="line"></span><br><span class="line"># Create table</span><br><span class="line">c.execute(&apos;&apos;&apos;CREATE TABLE stocks</span><br><span class="line">             (date text, trans text, symbol text, qty real, price real)&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line"># Insert a row of data</span><br><span class="line">c.execute(&quot;INSERT INTO stocks VALUES (&apos;2006-01-05&apos;,&apos;BUY&apos;,&apos;RHAT&apos;,100,35.14)&quot;)</span><br><span class="line"></span><br><span class="line"># Save (commit) the changes</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"># We can also close the connection if we are done with it.</span><br><span class="line"># Just be sure any changes have been committed or they will be lost.</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<p>这些数据被持久化保存了，而且可以在之后的会话中使用它们：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line">conn = sqlite3.connect(<span class="string">'example.db'</span>)</span><br><span class="line">c = conn.cursor()</span><br></pre></td></tr></table></figure>
<p>通常你的 SQL 操作需要使用一些 Python 变量的值。你不应该使用 Python 的字符串操作来创建你的查询语句，因为那样做不安全；它会使你的程序容易受到 SQL 注入攻击（在 <a href="https://xkcd.com/327/" target="_blank" rel="noopener">https://xkcd.com/327/</a> 上有一个搞笑的例子，看看有什么后果）</p>
<p>推荐另外一种方法：使用 DB-API 的参数替换。在你的 SQL 语句中，使用 <code>?</code> 占位符来代替值，然后把对应的值组成的元组做为 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> 方法的第二个参数。（其他数据库可能会使用不同的占位符，比如 <code>%s</code> 或者 <code>:1</code>）例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Never do this -- insecure!</span></span><br><span class="line">symbol = <span class="string">'RHAT'</span></span><br><span class="line">c.execute(<span class="string">"SELECT * FROM stocks WHERE symbol = '%s'"</span> % symbol)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Do this instead</span></span><br><span class="line">t = (<span class="string">'RHAT'</span>,)</span><br><span class="line">c.execute(<span class="string">'SELECT * FROM stocks WHERE symbol=?'</span>, t)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Larger example that inserts many records at a time</span></span><br><span class="line">purchases = [(<span class="string">'2006-03-28'</span>, <span class="string">'BUY'</span>, <span class="string">'IBM'</span>, <span class="number">1000</span>, <span class="number">45.00</span>),</span><br><span class="line">             (<span class="string">'2006-04-05'</span>, <span class="string">'BUY'</span>, <span class="string">'MSFT'</span>, <span class="number">1000</span>, <span class="number">72.00</span>),</span><br><span class="line">             (<span class="string">'2006-04-06'</span>, <span class="string">'SELL'</span>, <span class="string">'IBM'</span>, <span class="number">500</span>, <span class="number">53.00</span>),</span><br><span class="line">            ]</span><br><span class="line">c.executemany(<span class="string">'INSERT INTO stocks VALUES (?,?,?,?,?)'</span>, purchases)</span><br></pre></td></tr></table></figure>
<p>要在执行 SELECT 语句后获取数据，你可以把游标作为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a>，然后调用它的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.fetchone" target="_blank" rel="noopener"><code>fetchone()</code></a> 方法来获取一条匹配的行，也可以调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.fetchall" target="_blank" rel="noopener"><code>fetchall()</code></a> 来得到包含多个匹配行的列表。</p>
<p>下面是一个使用迭代器形式的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> c.execute(<span class="string">'SELECT * FROM stocks ORDER BY price'</span>):</span><br><span class="line">        print(row)</span><br><span class="line"></span><br><span class="line">(<span class="string">'2006-01-05'</span>, <span class="string">'BUY'</span>, <span class="string">'RHAT'</span>, <span class="number">100</span>, <span class="number">35.14</span>)</span><br><span class="line">(<span class="string">'2006-03-28'</span>, <span class="string">'BUY'</span>, <span class="string">'IBM'</span>, <span class="number">1000</span>, <span class="number">45.0</span>)</span><br><span class="line">(<span class="string">'2006-04-06'</span>, <span class="string">'SELL'</span>, <span class="string">'IBM'</span>, <span class="number">500</span>, <span class="number">53.0</span>)</span><br><span class="line">(<span class="string">'2006-04-05'</span>, <span class="string">'BUY'</span>, <span class="string">'MSFT'</span>, <span class="number">1000</span>, <span class="number">72.0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="模块函数和常量"><a href="#模块函数和常量" class="headerlink" title="模块函数和常量"></a>模块函数和常量</h2><ul>
<li><code>sqlite3.version</code></li>
</ul>
<p>​       这个模块的版本号，是一个字符串。不是 SQLite 库的版本号。</p>
<ul>
<li><p><code>sqlite3.version_info</code></p>
<p>这个模块的版本号，是一个由整数组成的元组。不是 SQLite 库的版本号。</p>
</li>
<li><p><code>sqlite3.sqlite_version</code></p>
<p>使用中的 SQLite 库的版本号，是一个字符串。</p>
</li>
<li><p><code>sqlite3.sqlite_version_info</code></p>
<p>使用中的 SQLite 库的版本号，是一个整数组成的元组。</p>
</li>
<li><p><code>sqlite3.PARSE_DECLTYPES</code></p>
<p>这个常量可以作为 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.connect" target="_blank" rel="noopener"><code>connect()</code></a> 函数的 <em>detect_types</em> 参数。</p>
<p>设置这个参数后，<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块将解析它返回的每一列申明的类型。它会申明的类型的第一个单词，比如“integer primary key”，它会解析出“integer”，再比如“number(10)”，它会解析出“number”。然后，它会在转换器字典里查找那个类型注册的转换器函数，并调用它。</p>
</li>
<li><p><code>sqlite3.PARSE_COLNAMES</code></p>
</li>
<li><p><code>sqlite3.connect</code>(<em>database</em>[, <em>timeout</em>, <em>detect_types</em>, <em>isolation_level</em>, <em>check_same_thread</em>, <em>factory</em>, <em>cached_statements</em>, <em>uri</em>])</p>
</li>
</ul>
<p>连接 SQLite 数据库 <em>database</em>。默认返回 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象，除非使用了自定义的 <em>factory</em> 参数。</p>
<p><em>database</em> 是准备打开的数据库文件的路径（绝对路径或相对于当前目录的相对路径），它是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a>。你也可以用 <code>&quot;:memory:&quot;</code> 在内存中打开一个数据库。</p>
<p>当一个数据库被多个连接访问的时候，如果其中一个进程修改这个数据库，在这个事务提交之前，这个 SQLite 数据库将会被一直锁定。<em>timeout</em> 参数指定了这个连接等待锁释放的超时时间，超时之后会引发一个异常。这个超时时间默认是 5.0（5秒）。</p>
<p><em>isolation_level</em> 参数，请查看 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.isolation_level" target="_blank" rel="noopener"><code>isolation_level</code></a> 属性。</p>
<p>SQLite 原生只支持5种类型：TEXT，INTEGER，REAL，BLOB 和 NULL。如果你想用其它类型，你必须自己添加相应的支持。使用 <em>detect_types</em> 参数和模块级别的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.register_converter" target="_blank" rel="noopener"><code>register_converter()</code></a> 函数注册<strong>转换器</strong> 可以简单的实现。</p>
<p><em>detect_types</em> 默认为0（即关闭，没有类型检测）。你也可以组合 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.PARSE_DECLTYPES" target="_blank" rel="noopener"><code>PARSE_DECLTYPES</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.PARSE_COLNAMES" target="_blank" rel="noopener"><code>PARSE_COLNAMES</code></a> 来开启类型检测。</p>
<p>默认情况下，<em>check_same_thread</em> 为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>，只有当前的线程可以使用该连接。 如果设置为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>，则多个线程可以共享返回的连接。 当多个线程使用同一个连接的时候，用户应该把写操作进行序列化，以避免数据损坏。</p>
<p>默认情况下，当调用 connect 方法的时候，<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块使用了它的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 类。当然，你也可以创建 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 类的子类，然后创建提供了 <em>factory</em> 参数的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.connect" target="_blank" rel="noopener"><code>connect()</code></a> 方法。</p>
<p>详情请查阅当前手册的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3-types" target="_blank" rel="noopener">SQLite 与 Python 类型</a> 部分。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块在内部使用语句缓存来避免 SQL 解析开销。 如果要显式设置当前连接可以缓存的语句数，可以设置 <em>cached_statements</em> 参数。 当前实现的默认值是缓存100条语句。</p>
<p>如果 <em>uri</em> 为真，则 <em>database</em> 被解释为 URI。 它允许您指定选项。 例如，以只读模式打开数据库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">db = sqlite3.connect(<span class="string">'file:path/to/database?mode=ro'</span>, uri=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>有关此功能的更多信息，包括已知选项的列表，可以在 <code>SQLite URI 文档 &lt;&lt;https://www.sqlite.org/uri.html&gt;&gt;</code>_ 中找到。</p>
<ul>
<li><p><code>sqlite3.register_converter</code>(<em>typename</em>, <em>callable</em>)</p>
<p>注册一个回调对象 <em>callable</em>, 用来转换数据库中的字节串为自定的 Python 类型。所有类型为 <em>typename</em> 的数据库的值在转换时，都会调用这个回调对象。通过指定 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.connect" target="_blank" rel="noopener"><code>connect()</code></a> 函数的 <em>detect-types</em> 参数来设置类型检测的方式。注意，<em>typename</em> 与查询语句中的类型名进行匹配时不区分大小写。</p>
</li>
<li><p><code>sqlite3.register_adapter</code>(<em>type</em>, <em>callable</em>)</p>
<p>注册一个回调对象 <em>callable</em>，用来转换自定义Python类型为一个 SQLite 支持的类型。 这个回调对象 <em>callable</em> 仅接受一个 Python 值作为参数，而且必须返回以下某个类型的值：int，float，str 或 bytes。</p>
</li>
<li><p><code>sqlite3.complete_statement</code>(<em>sql</em>)</p>
<p>如果字符串 <em>sql</em> 包含一个或多个完整的 SQL 语句（以分号结束）则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>。它不会验证 SQL 语法是否正确，仅会验证字符串字面上是否完整，以及是否以分号结束。</p>
<p>它可以用来构建一个 SQLite shell，下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A minimal SQLite shell for experiments</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.isolation_level = <span class="literal">None</span></span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">buffer = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Enter your SQL commands to execute in sqlite3."</span>)</span><br><span class="line">print(<span class="string">"Enter a blank line to exit."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = input()</span><br><span class="line">    <span class="keyword">if</span> line == <span class="string">""</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    buffer += line</span><br><span class="line">    <span class="keyword">if</span> sqlite3.complete_statement(buffer):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            buffer = buffer.strip()</span><br><span class="line">            cur.execute(buffer)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> buffer.lstrip().upper().startswith(<span class="string">"SELECT"</span>):</span><br><span class="line">                print(cur.fetchall())</span><br><span class="line">        <span class="keyword">except</span> sqlite3.Error <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">"An error occurred:"</span>, e.args[<span class="number">0</span>])</span><br><span class="line">        buffer = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sqlite3.enable_callback_tracebacks</code>(<em>flag</em>)</p>
<p>默认情况下，您不会获得任何用户定义函数中的回溯消息，比如聚合，转换器，授权器回调等。如果要调试它们，可以设置 <em>flag</em> 参数为 <code>True</code> 并调用此函数。 之后，回调中的回溯信息将会输出到 <code>sys.stderr</code>。 再次使用 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a> 来禁用该功能。</p>
<h2 id="连接对象（Connection）"><a href="#连接对象（Connection）" class="headerlink" title="连接对象（Connection）"></a>连接对象（Connection）</h2></li>
</ul>
<p><em>class</em> <code>sqlite3.Connection</code></p>
<p>SQLite 数据库连接对象有如下的属性和方法：</p>
<ul>
<li><p><code>isolation_level</code></p>
<p>获取或设置当前默认的隔离级别。 表示自动提交模式的 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 以及 “DEFERRED”, “IMMEDIATE” 或 “EXCLUSIVE” 其中之一。 详细描述请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3-controlling-transactions" target="_blank" rel="noopener">控制事务</a>。</p>
</li>
<li><p><code>in_transaction</code></p>
<p>如果是在活动事务中（还没有提交改变），返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>，否则，返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>。它是一个只读属性。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>cursor</code>(<em>factory=Cursor</em>)</p>
<p>这个方法接受一个可选参数 <em>factory</em>，如果要指定这个参数，它必须是一个可调用对象，而且必须返回 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 类的一个实例或者子类。</p>
</li>
<li><p><code>commit</code>()</p>
<p>这个方法提交当前事务。如果没有调用这个方法，那么从上一次提交 <code>commit()</code> 以来所有的变化在其他数据库连接上都是不可见的。如果你往数据库里写了数据，但是又查询不到，请检查是否忘记了调用这个方法。</p>
</li>
<li><p><code>rollback</code>()</p>
<p>这个方法回滚从上一次调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.commit" target="_blank" rel="noopener"><code>commit()</code></a> 以来所有数据库的改变。</p>
</li>
<li><p><code>close</code>()</p>
<p>关闭数据库连接。注意，它不会自动调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.commit" target="_blank" rel="noopener"><code>commit()</code></a> 方法。如果在关闭数据库连接之前没有调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.commit" target="_blank" rel="noopener"><code>commit()</code></a>，那么你的修改将会丢失！</p>
</li>
<li><p><code>execute</code>(<em>sql</em>[, <em>parameters</em>])</p>
<p>这是一个非标准的快捷方法，它会调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.cursor" target="_blank" rel="noopener"><code>cursor()</code></a> 方法来创建一个游标对象，并使用给定的 <em>parameters</em> 参数来调用游标对象的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> 方法，最后返回这个游标对象。</p>
</li>
<li><p><code>executemany</code>(<em>sql</em>[, <em>parameters</em>])</p>
<p>这是一个非标准的快捷方法，它会调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.cursor" target="_blank" rel="noopener"><code>cursor()</code></a> 方法来创建一个游标对象，并使用给定的 <em>parameters</em> 参数来调用游标对象的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executemany" target="_blank" rel="noopener"><code>executemany()</code></a> 方法，最后返回这个游标对象。</p>
</li>
<li><p><code>executescript</code>(<em>sql_script</em>)</p>
<p>这是一个非标准的快捷方法，它会调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.cursor" target="_blank" rel="noopener"><code>cursor()</code></a> 方法来创建一个游标对象，并使用给定的 <em>sql_script</em> 参数来调用游标对象的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executescript" target="_blank" rel="noopener"><code>executescript()</code></a> 方法，最后返回这个游标对象。</p>
</li>
<li><p><code>create_function</code>(<em>name</em>, <em>num_params</em>, <em>func</em>, <em>**, </em>deterministic=False*)</p>
<p>创建一个可以在 SQL 语句中使用的用户自定义函数，函数名为 <em>name</em>。 <em>num_params</em> 为该函数所接受的形参个数（如果 <em>num_params</em> 为 -1，则该函数可接受任意数量的参数）， <em>func</em> 是一个 Python 可调用对象，它将作为 SQL 函数被调用。 如果 <em>deterministic</em> 为真值，则所创建的函数将被标记为 <a href="https://sqlite.org/deterministic.html" target="_blank" rel="noopener">deterministic</a>，这允许 SQLite 执行额外的优化。 此旗标在 SQLite 3.8.3 或更高版本中受到支持，如果在旧版本中使用将引发 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.NotSupportedError" target="_blank" rel="noopener"><code>NotSupportedError</code></a>。此函数可返回任何 SQLite 所支持的类型: bytes, str, int, float 和 <code>None</code>。<em>在 3.8 版更改:</em> 增加了 <em>deterministic</em> 形参。示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5sum</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(t).hexdigest()</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.create_function(<span class="string">"md5"</span>, <span class="number">1</span>, md5sum)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"select md5(?)"</span>, (<span class="string">b"foo"</span>,))</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>create_aggregate</code>(<em>name</em>, <em>num_params</em>, <em>aggregate_class</em>)</p>
<p>创建一个自定义的聚合函数。</p>
<p>参数中 <em>aggregate_class</em> 类必须实现两个方法：<code>step</code> 和 <code>finalize</code>。<code>step</code> 方法接受 <em>num_params</em> 个参数（如果 <em>num_params</em> 为 -1，那么这个函数可以接受任意数量的参数）；<code>finalize</code> 方法返回最终的聚合结果。</p>
<p><code>finalize</code> 方法可以返回任何 SQLite 支持的类型：bytes，str，int，float 和 <code>None</code>。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySum</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.count += value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finalize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.create_aggregate(<span class="string">"mysum"</span>, <span class="number">1</span>, MySum)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(i)"</span>)</span><br><span class="line">cur.execute(<span class="string">"insert into test(i) values (1)"</span>)</span><br><span class="line">cur.execute(<span class="string">"insert into test(i) values (2)"</span>)</span><br><span class="line">cur.execute(<span class="string">"select mysum(i) from test"</span>)</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>create_collation</code>(<em>name</em>, <em>callable</em>)</p>
<p>使用 <em>name</em> 和 <em>callable</em> 创建排序规则。这个 <em>callable</em> 接受两个字符串对象，如果第一个小于第二个则返回 -1， 如果两个相等则返回 0，如果第一个大于第二个则返回 1。注意，这是用来控制排序的（SQL 中的 ORDER BY），所以它不会影响其它的 SQL 操作。</p>
<p>注意，这个 <em>callable</em> 可调用对象会把它的参数作为 Python 字节串，通常会以 UTF-8 编码格式对它进行编码。</p>
<p>以下示例显示了使用“错误方式”进行排序的自定义排序规则：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collate_reverse</span><span class="params">(string1, string2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> string1 == string2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> string1 &lt; string2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.create_collation(<span class="string">"reverse"</span>, collate_reverse)</span><br><span class="line"></span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(x)"</span>)</span><br><span class="line">cur.executemany(<span class="string">"insert into test(x) values (?)"</span>, [(<span class="string">"a"</span>,), (<span class="string">"b"</span>,)])</span><br><span class="line">cur.execute(<span class="string">"select x from test order by x collate reverse"</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cur:</span><br><span class="line">    print(row)</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
<p>要移除一个排序规则，需要调用 <code>create_collation</code> 并设置 callable 参数为 <code>None</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">con.create_collation(<span class="string">"reverse"</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>interrupt</code>()</p>
<p>可以从不同的线程调用这个方法来终止所有查询操作，这些查询操作可能正在连接上执行。此方法调用之后， 查询将会终止，而且查询的调用者会获得一个异常。</p>
</li>
<li><p><code>set_authorizer</code>(<em>authorizer_callback</em>)</p>
<p>此方法注册一个授权回调对象。每次在访问数据库中某个表的某一列的时候，这个回调对象将会被调用。如果要允许访问，则返回 <code>SQLITE_OK</code>，如果要终止整个 SQL 语句，则返回 <code>SQLITE_DENY</code>，如果这一列需要当做 NULL 值处理，则返回 <code>SQLITE_IGNORE</code>。这些常量可以在 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块中找到。回调的第一个参数表示要授权的操作类型。 第二个和第三个参数将是参数或 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>，具体取决于第一个参数的值。 第 4 个参数是数据库的名称（“main”，“temp”等），如果需要的话。 第 5 个参数是负责访问尝试的最内层触发器或视图的名称，或者如果此访问尝试直接来自输入 SQL 代码，则为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。请参阅 SQLite 文档，了解第一个参数的可能值以及第二个和第三个参数的含义，具体取决于第一个参数。 所有必需的常量都可以在 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块中找到。</p>
</li>
<li><p><code>set_progress_handler</code>(<em>handler</em>, <em>n</em>)</p>
<p>此例程注册回调。 对SQLite虚拟机的每个多指令调用回调。 如果要在长时间运行的操作期间从SQLite调用（例如更新用户界面），这非常有用。如果要清除以前安装的任何进度处理程序，调用该方法时请将 <em>handler</em> 参数设置为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。从处理函数返回非零值将终止当前正在执行的查询并导致它引发 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.OperationalError" target="_blank" rel="noopener"><code>OperationalError</code></a> 异常。</p>
</li>
<li><p><code>set_trace_callback</code>(<em>trace_callback</em>)</p>
<p>为每个 SQLite 后端实际执行的 SQL 语句注册要调用的 <em>trace_callback</em>。传递给回调的唯一参数是正在执行的语句（作为字符串）。 回调的返回值将被忽略。 请注意，后端不仅运行传递给 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>Cursor.execute()</code></a> 方法的语句。 其他来源包括 Python 模块的事务管理和当前数据库中定义的触发器的执行。将传入的 <em>trace_callback</em> 设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 将禁用跟踪回调。</p>
</li>
<li><p><code>enable_load_extension</code>(<em>enabled</em>)</p>
<p>此例程允许/禁止SQLite引擎从共享库加载SQLite扩展。 SQLite扩展可以定义新功能，聚合或全新的虚拟表实现。 一个众所周知的扩展是与SQLite一起分发的全文搜索扩展。</p>
<p>默认情况下禁用可加载扩展。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable extension loading</span></span><br><span class="line">con.enable_load_extension(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the fulltext search extension</span></span><br><span class="line">con.execute(<span class="string">"select load_extension('./fts3.so')"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># alternatively you can load the extension using an API call:</span></span><br><span class="line"><span class="comment"># con.load_extension("./fts3.so")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># disable extension loading again</span></span><br><span class="line">con.enable_load_extension(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># example from SQLite wiki</span></span><br><span class="line">con.execute(<span class="string">"create virtual table recipe using fts3(name, ingredients)"</span>)</span><br><span class="line">con.executescript(<span class="string">"""</span></span><br><span class="line"><span class="string">    insert into recipe (name, ingredients) values ('broccoli stew', 'broccoli peppers cheese tomatoes');</span></span><br><span class="line"><span class="string">    insert into recipe (name, ingredients) values ('pumpkin stew', 'pumpkin onions garlic celery');</span></span><br><span class="line"><span class="string">    insert into recipe (name, ingredients) values ('broccoli pie', 'broccoli cheese onions flour');</span></span><br><span class="line"><span class="string">    insert into recipe (name, ingredients) values ('pumpkin pie', 'pumpkin sugar flour butter');</span></span><br><span class="line"><span class="string">    """</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> con.execute(<span class="string">"select rowid, name, ingredients from recipe where name match 'pie'"</span>):</span><br><span class="line">    print(row)</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>load_extension</code>(<em>path</em>)</p>
<p>此例程从共享库加载SQLite扩展。 在使用此例程之前，必须使用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.enable_load_extension" target="_blank" rel="noopener"><code>enable_load_extension()</code></a> 启用扩展加载。</p>
<p>默认情况下禁用可加载扩展。</p>
</li>
<li><p>row_factory<br>您可以将此属性更改为可接受游标和原始行作为元组的可调用对象，并将返回实际结果行。 这样，您可以实现更高级的返回结果的方法，例如返回一个可以按名称访问列的对象。<br>示例:   </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict_factory</span><span class="params">(cursor, row)</span>:</span></span><br><span class="line">   d = &#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> idx, col <span class="keyword">in</span> enumerate(cursor.description):</span><br><span class="line">       d[col[<span class="number">0</span>]] = row[idx]</span><br><span class="line">   <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.row_factory = dict_factory</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"select 1 as a"</span>)</span><br><span class="line">print(cur.fetchone()[<span class="string">"a"</span>])</span><br><span class="line"></span><br><span class="line">  con.close()</span><br></pre></td></tr></table></figure>
<p>如果返回一个元组是不够的，并且你想要对列进行基于名称的访问，你应该考虑将 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.row_factory" target="_blank" rel="noopener"><code>row_factory</code></a> 设置为高度优化的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Row" target="_blank" rel="noopener"><code>sqlite3.Row</code></a> 类型。 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Row" target="_blank" rel="noopener"><code>Row</code></a> 提供基于索引和不区分大小写的基于名称的访问，几乎没有内存开销。 它可能比您自己的基于字典的自定义方法甚至基于 db_row 的解决方案更好。</p>
<ul>
<li><p><strong>text_factory</strong></p>
<p>使用此属性可以控制为 <code>TEXT</code> 数据类型返回的对象。 默认情况下，此属性设置为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块将返回 <code>TEXT</code> 的 Unicode 对象。 如果要返回字节串，可以将其设置为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>。</p>
<p>您还可以将其设置为接受单个 bytestring 参数的任何其他可调用对象，并返回结果对象。</p>
<p>请参阅以下示例代码以进行说明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">AUSTRIA = <span class="string">"\xd6sterreich"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># by default, rows are returned as Unicode</span></span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (AUSTRIA,))</span><br><span class="line">row = cur.fetchone()</span><br><span class="line"><span class="keyword">assert</span> row[<span class="number">0</span>] == AUSTRIA</span><br><span class="line"></span><br><span class="line"><span class="comment"># but we can make sqlite3 always return bytestrings ...</span></span><br><span class="line">con.text_factory = bytes</span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (AUSTRIA,))</span><br><span class="line">row = cur.fetchone()</span><br><span class="line"><span class="keyword">assert</span> type(row[<span class="number">0</span>]) <span class="keyword">is</span> bytes</span><br><span class="line"><span class="comment"># the bytestrings will be encoded in UTF-8, unless you stored garbage in the</span></span><br><span class="line"><span class="comment"># database ...</span></span><br><span class="line"><span class="keyword">assert</span> row[<span class="number">0</span>] == AUSTRIA.encode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we can also implement a custom text_factory ...</span></span><br><span class="line"><span class="comment"># here we implement one that appends "foo" to all strings</span></span><br><span class="line">con.text_factory = <span class="keyword">lambda</span> x: x.decode(<span class="string">"utf-8"</span>) + <span class="string">"foo"</span></span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (<span class="string">"bar"</span>,))</span><br><span class="line">row = cur.fetchone()</span><br><span class="line"><span class="keyword">assert</span> row[<span class="number">0</span>] == <span class="string">"barfoo"</span></span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p>total_changes</p>
<p>返回自打开数据库连接以来已修改，插入或删除的数据库行的总数。</p>
</li>
<li><p><code>iterdump</code>()</p>
<p>返回以SQL文本格式转储数据库的迭代器。 保存内存数据库以便以后恢复时很有用。 此函数提供与 <strong>sqlite3</strong> shell 中的 .dump 命令相同的功能。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Convert file existing_db.db to SQL dump file dump.sql</span></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">'existing_db.db'</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dump.sql'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> con.iterdump():</span><br><span class="line">        f.write(<span class="string">'%s\n'</span> % line)</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>backup</code>(<em>target</em>, <em>**, </em>pages=0<em>, </em>progress=None<em>, </em>name=”main”<em>, </em>sleep=0.250*)</p>
<p>即使在 SQLite 数据库被其他客户端访问时，或者同时由同一连接访问，该方法也会对其进行备份。 该副本将写入强制参数 <em>target</em>，该参数必须是另一个 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 实例。</p>
<p>默认情况下，或者当 <em>pages</em> 为 <code>0</code> 或负整数时，整个数据库将在一个步骤中复制；否则该方法一次循环复制 <em>pages</em> 规定数量的页面。</p>
<p>示例一，将现有数据库复制到另一个数据库中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">progress</span><span class="params">(status, remaining, total)</span>:</span></span><br><span class="line">    print(<span class="string">f'Copied <span class="subst">&#123;total-remaining&#125;</span> of <span class="subst">&#123;total&#125;</span> pages...'</span>)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">'existing_db.db'</span>)</span><br><span class="line">bck = sqlite3.connect(<span class="string">'backup.db'</span>)</span><br><span class="line"><span class="keyword">with</span> bck:</span><br><span class="line">    con.backup(bck, pages=<span class="number">1</span>, progress=progress)</span><br><span class="line">bck.close()</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例二，将现有数据库复制到临时副本中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">source = sqlite3.connect(<span class="string">'existing_db.db'</span>)</span><br><span class="line">dest = sqlite3.connect(<span class="string">':memory:'</span>)</span><br><span class="line">source.backup(dest)</span><br></pre></td></tr></table></figure>
<p>可用性：SQLite 3.6.11 或以上版本</p>
</li>
</ul>
<h2 id="Cursor-对象"><a href="#Cursor-对象" class="headerlink" title="Cursor 对象"></a>Cursor 对象</h2><ul>
<li><p><em>class</em> <code>sqlite3.Cursor</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 游标实例具有以下属性和方法。</p>
<ul>
<li><p><code>execute</code>(<em>sql</em>[, <em>parameters</em>])</p>
<p>执行SQL语句。 可以是参数化 SQL 语句（即，在 SQL 语句中使用占位符）。<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块支持两种占位符：问号（qmark风格）和命名占位符（命名风格）。以下是两种风格的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table people (name_last, age)"</span>)</span><br><span class="line"></span><br><span class="line">who = <span class="string">"Yeltsin"</span></span><br><span class="line">age = <span class="number">72</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is the qmark style:</span></span><br><span class="line">cur.execute(<span class="string">"insert into people values (?, ?)"</span>, (who, age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># And this is the named style:</span></span><br><span class="line">cur.execute(<span class="string">"select * from people where name_last=:who and age=:age"</span>, &#123;<span class="string">"who"</span>: who, <span class="string">"age"</span>: age&#125;)</span><br><span class="line"></span><br><span class="line">print(cur.fetchone())</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> will only execute a single SQL statement. If you try to execute more than one statement with it, it will raise a <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Warning" target="_blank" rel="noopener"><code>Warning</code></a>. Use <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executescript" target="_blank" rel="noopener"><code>executescript()</code></a> if you want to execute multiple SQL statements with one call.</p>
</li>
</ul>
</li>
<li><p><code>executemany</code>(<em>sql</em>, <em>seq_of_parameters</em>)</p>
<p>通过所有参数序列或者映射参数 执行SQL 命令,同时支持使用<code>iterator</code>(可迭代对象) yield类型生成参数代替序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IterChars</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = ord(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.count &gt; ord(<span class="string">'z'</span>):</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (chr(self.count - <span class="number">1</span>),) <span class="comment"># this is a 1-tuple</span></span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table characters(c)"</span>)</span><br><span class="line"></span><br><span class="line">theIter = IterChars()</span><br><span class="line">cur.executemany(<span class="string">"insert into characters(c) values (?)"</span>, theIter)</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"select c from characters"</span>)</span><br><span class="line">print(cur.fetchall())</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
<p>这是一个使用生成器 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 的简短示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">char_generator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> string.ascii_lowercase:</span><br><span class="line">        <span class="keyword">yield</span> (c,)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table characters(c)"</span>)</span><br><span class="line"></span><br><span class="line">cur.executemany(<span class="string">"insert into characters(c) values (?)"</span>, char_generator())</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"select c from characters"</span>)</span><br><span class="line">print(cur.fetchall())</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>executescript</code>(<em>sql_script</em>)</p>
<p>这是一个非标准方式执行sql语句的方法,它首先执行<code>COMMIT</code>语句,然后执行作为参数传递而来的SQL语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.executescript(<span class="string">"""</span></span><br><span class="line"><span class="string">    create table person(</span></span><br><span class="line"><span class="string">        firstname,</span></span><br><span class="line"><span class="string">        lastname,</span></span><br><span class="line"><span class="string">        age</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    create table book(</span></span><br><span class="line"><span class="string">        title,</span></span><br><span class="line"><span class="string">        author,</span></span><br><span class="line"><span class="string">        published</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    insert into book(title, author, published)</span></span><br><span class="line"><span class="string">    values (</span></span><br><span class="line"><span class="string">        'Dirk Gently''s Holistic Detective Agency',</span></span><br><span class="line"><span class="string">        'Douglas Adams',</span></span><br><span class="line"><span class="string">        1987</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">    """</span>)</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>fetchone</code>()</p>
<p>获取查询语句结果中的一条记录集,返回一个单独的序列,当没有数据时返回<code>None</code>。</p>
</li>
<li><p><code>fetchmany</code>(<em>size=cursor.arraysize</em>)</p>
<p>提取查询结果的下一组行，返回列表。当没有更多行可用时，将返回一个空列表。每个调用要提取的行数由 [size] 参数指定。如果未提供，则游标的数组大小确定要提取的行数。该方法应尝试提取大小参数指示的行数。如果由于指定的行数不可用而无法这样做，则返回的行数可能更少。请注意，[size] 参数涉及性能注意事项。为了获得最佳性能，通常最好使用数组大小属性。如果使用 [size] 参数，则最好将其保留从<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.fetchmany" target="_blank" rel="noopener"><code>fetchmany()</code></a> 方法调用到下一个相同的值。</p>
</li>
</ul>
<p>​        返回list类型存储的所有结果的行。如果没有记录返回,返回一个空的list。</p>
<ul>
<li><p><code>close</code>()</p>
<p>立即关闭游标(无论<code>__del__</code>方法是否被调用)。当前游标无法再获取上下文对象,如果尝试访问该游标,则会引发<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.ProgrammingError" target="_blank" rel="noopener"><code>ProgrammingError</code></a> 异常。</p>
</li>
<li><p><code>rowcount</code></p>
<p>对于  <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executemany" target="_blank" rel="noopener"><code>executemany()</code></a> 语句，修改次数汇总为 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.rowcount" target="_blank" rel="noopener"><code>rowcount</code></a>.根据 Python DB API 规范的要求，<code>rowcount</code> 属性在游标上未执行<code>executeXX()</code>或最后一个操作的行计数无法由接口决定的情况下为 -1。这包括<code>SELECT</code>语句，因为我们无法确定在提取所有行之前生成的查询的行数。</p>
</li>
<li><p><code>lastrowid</code></p>
<p>这是一个只读属性取得最后一条修改记录的rowid。仅当使用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> 方法执行<code>INSERT</code> or a <code>REPLACE</code> 语句时设置该属性。或者 当执行<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executemany" target="_blank" rel="noopener"><code>executemany()</code></a> 方法时,该属性设置为<code>None</code>。如果<code>INSERT</code> 或 <code>REPLACE</code> 语句执行失败时,则返回最近一次成功执行的rowid。</p>
</li>
<li><p><code>arraysize</code></p>
<p>该属性可读写,主要控制 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.fetchmany" target="_blank" rel="noopener"><code>fetchmany()</code></a>方法返回的记录数量。默认值是1意味着返回一行结果。</p>
</li>
<li><p><code>description</code></p>
<p>此只读属性提供最后一次查询的列名称。为了保持与 Python DB API 的兼容，它为每个列返回一个 7 元组，其中每个元组的最后六个项为 <code>None</code>.</p>
</li>
<li><p><code>connection</code></p>
<p>此只读属性提供SQLite数据库的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 使用的游标对象。</p>
</li>
</ul>
<h2 id="行对象"><a href="#行对象" class="headerlink" title="行对象"></a>行对象</h2><p><em>class</em> <code>sqlite3.Row</code></p>
<ul>
<li><p><code>keys</code>()</p>
<p>该方法返回列名构成的列表。查询后,在 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.description" target="_blank" rel="noopener"><code>Cursor.description</code></a> 中元组数据的第一个元素.</p>
</li>
</ul>
<p>接下来我们在上面的例子中初始化一个table：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conn = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">c = conn.cursor()</span><br><span class="line">c.execute(<span class="string">'''create table stocks</span></span><br><span class="line"><span class="string">(date text, trans text, symbol text,</span></span><br><span class="line"><span class="string"> qty real, price real)'''</span>)</span><br><span class="line">c.execute(<span class="string">"""insert into stocks</span></span><br><span class="line"><span class="string">          values ('2006-01-05','BUY','RHAT',100,35.14)"""</span>)</span><br><span class="line">conn.commit()</span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure>
<p>我们使用<code>Row</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.row_factory = sqlite3.Row</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = conn.cursor()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.execute(<span class="string">'select * from stocks'</span>)</span><br><span class="line">&lt;sqlite3.Cursor object at <span class="number">0x7f4e7dd8fa80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = c.fetchone()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(r)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">sqlite3</span>.<span class="title">Row</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">tuple</span><span class="params">(r)</span></span></span><br><span class="line"><span class="class"><span class="params">(<span class="string">'2006-01-05'</span>, <span class="string">'BUY'</span>, <span class="string">'RHAT'</span>, <span class="number">100.0</span>, <span class="number">35.14</span>)</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">len</span><span class="params">(r)</span></span></span><br><span class="line"><span class="class">5</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">r</span>[2]</span></span><br><span class="line"><span class="class">'<span class="title">RHAT</span>'</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">r</span>.<span class="title">keys</span><span class="params">()</span></span></span><br><span class="line">['date', 'trans', 'symbol', 'qty', 'price']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r[<span class="string">'qty'</span>]</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> member <span class="keyword">in</span> r:</span><br><span class="line"><span class="meta">... </span>    print(member)</span><br><span class="line">...</span><br><span class="line"><span class="number">2006</span><span class="number">-01</span><span class="number">-05</span></span><br><span class="line">BUY</span><br><span class="line">RHAT</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="number">35.14</span></span><br></pre></td></tr></table></figure>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li><p><em>exception</em> <code>sqlite3.Warning</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>sqlite3.Error</code></p>
<p>此模块中其他异常的基类。 它是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>sqlite3.DatabaseError</code></p>
<p>抛出和数据库有关异常。</p>
</li>
<li><p><em>exception</em> <code>sqlite3.IntegrityError</code></p>
<p>抛出和关联标识符有关异常,例如外键检查失败,是<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.DatabaseError" target="_blank" rel="noopener"><code>DatabaseError</code></a>的一个子类。</p>
</li>
<li><p><em>exception</em> <code>sqlite3.ProgrammingError</code></p>
<p>抛出和程序有关的异常,例如：table未找到,或已经存在,SQL 语句异常,参数不正确, 是<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.DatabaseError" target="_blank" rel="noopener"><code>DatabaseError</code></a>的一个子类。</p>
</li>
<li><p><em>exception</em> <code>sqlite3.OperationalError</code></p>
<p>抛出和程序无法控制的数据库操作的异常,例如: 不可预料的数据库连接错误,数据源名字未找到,事务没有被执行,是<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.DatabaseError" target="_blank" rel="noopener"><code>DatabaseError</code></a>的一个子类。</p>
</li>
<li><p><em>exception</em> <code>sqlite3.NotSupportedError</code></p>
<p>抛出当一个方法对当前数据库不支持的异常,例如:调用 <code>rollback()</code>时,数据库事务不支持或者事务被关闭。是<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.DatabaseError" target="_blank" rel="noopener"><code>DatabaseError</code></a>的一个子类</p>
</li>
</ul>
<h2 id="SQLite-与-Python-类型"><a href="#SQLite-与-Python-类型" class="headerlink" title="SQLite 与 Python 类型"></a>SQLite 与 Python 类型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>SQLite 原生支持如下的类型： <code>NULL</code>，<code>INTEGER</code>，<code>REAL</code>，<code>TEXT</code>，<code>BLOB</code>。</p>
<table>
<thead>
<tr>
<th>Python 类型</th>
<th>SQLite 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a></td>
<td><code>NULL</code></td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a></td>
<td><code>INTEGER</code></td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a></td>
<td><code>REAL</code></td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a></td>
<td><code>TEXT</code></td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a></td>
<td><code>BLOB</code></td>
</tr>
</tbody>
</table>
<p>这是SQLite类型默认转换为Python类型的方式：</p>
<table>
<thead>
<tr>
<th>SQLite 类型</th>
<th>Python 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NULL</code></td>
<td><a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a></td>
</tr>
<tr>
<td><code>INTEGER</code></td>
<td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a></td>
</tr>
<tr>
<td><code>REAL</code></td>
<td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a></td>
</tr>
<tr>
<td><code>TEXT</code></td>
<td>取决于 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.text_factory" target="_blank" rel="noopener"><code>text_factory</code></a> , 默认为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a></td>
</tr>
<tr>
<td><code>BLOB</code></td>
<td><a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a></td>
</tr>
</tbody>
</table>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 中数据类型的扩展有两种途径: 一种是使用SQLite对象适配器扩展附加的Python数据类型；另一种是使用Python类型转换函数转换SQLite类型。</p>
<h3 id="使用适配器在SQLite中存储附加的python数据类型"><a href="#使用适配器在SQLite中存储附加的python数据类型" class="headerlink" title="使用适配器在SQLite中存储附加的python数据类型"></a>使用适配器在SQLite中存储附加的python数据类型</h3><p>正如之前描述的转换方法中说明的,SQLite只支持有限的几种数据类型。如果想在SQLite中使用Python的相关数据类型,你必须通过适配器,让SQLite的模块让SQLite支持诸如:  one of NoneType, int, float, str, bytes等类型。请看下面的例子:</p>
<h4 id="让对象自行调整"><a href="#让对象自行调整" class="headerlink" title="让对象自行调整"></a>让对象自行调整</h4><p>如果自己编写类，这是一种很好的方法。假设有这样的类：：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x, self.y = x, y</span><br></pre></td></tr></table></figure>
<p>我们想在SQLite中存储,首先选择何种数据类型存储这个<code>Point</code>类。</p>
<p>接下来使用类方法 <code>__conform__</code>返回转换后的值, 参数是 <code>PrepareProtocol</code>类型的<code>protocol</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__conform__</span><span class="params">(self, protocol)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> protocol <span class="keyword">is</span> sqlite3.PrepareProtocol:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"%f;%f"</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">4.0</span>, <span class="number">-3.2</span>)</span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (p,))</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
<h4 id="注册可调用的适配器"><a href="#注册可调用的适配器" class="headerlink" title="注册可调用的适配器"></a>注册可调用的适配器</h4><p>另一个可行的方法时创建一个可以转换string和其他类型的函数,使用<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.register_adapter" target="_blank" rel="noopener"><code>register_adapter()</code></a>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adapt_point</span><span class="params">(point)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"%f;%f"</span> % (point.x, point.y)</span><br><span class="line"></span><br><span class="line">sqlite3.register_adapter(Point, adapt_point)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">4.0</span>, <span class="number">-3.2</span>)</span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (p,))</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
<p>对于Python中的内置数据类型 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.datetime" target="_blank" rel="noopener"><code>datetime.datetime</code></a> ,我们可以存储 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.datetime" target="_blank" rel="noopener"><code>datetime.datetime</code></a> 使用ISO 实现而非 Unix 时间戳。请参考下面的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adapt_datetime</span><span class="params">(ts)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> time.mktime(ts.timetuple())</span><br><span class="line"></span><br><span class="line">sqlite3.register_adapter(datetime.datetime, adapt_datetime)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (now,))</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
<h3 id="将SQLite-值转换为自定义Python-类型"><a href="#将SQLite-值转换为自定义Python-类型" class="headerlink" title="将SQLite 值转换为自定义Python 类型"></a>将SQLite 值转换为自定义Python 类型</h3><p>让我们回到刚才定义的<code>Point</code> 类,在SQLite中存储<code>x</code>,<code>y</code>字符串类型参数。</p>
<p>首先我们定义一个转换函数,接收字符串类型的参数,转换为<code>Point</code>类的对象。</p>
<blockquote>
<p>转换函数通常处理的是<code>byte</code>类型对象,无论你传入的是什么类型 数据。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_point</span><span class="params">(s)</span>:</span></span><br><span class="line">    x, y = map(float, s.split(<span class="string">b";"</span>))</span><br><span class="line">    <span class="keyword">return</span> Point(x, y)</span><br></pre></td></tr></table></figure>
<p>现在我们需要让 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块知道你查询的是一个<code>point</code>对象，有两种方式实现:</p>
<ul>
<li>隐式的声明类型</li>
<li>显式的通过列名</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"(%f;%f)"</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adapt_point</span><span class="params">(point)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"%f;%f"</span> % (point.x, point.y)).encode(<span class="string">'ascii'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_point</span><span class="params">(s)</span>:</span></span><br><span class="line">    x, y = list(map(float, s.split(<span class="string">b";"</span>)))</span><br><span class="line">    <span class="keyword">return</span> Point(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register the adapter</span></span><br><span class="line">sqlite3.register_adapter(Point, adapt_point)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register the converter</span></span><br><span class="line">sqlite3.register_converter(<span class="string">"point"</span>, convert_point)</span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">4.0</span>, <span class="number">-3.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#########################</span></span><br><span class="line"><span class="comment"># 1) Using declared types</span></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>, detect_types=sqlite3.PARSE_DECLTYPES)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(p point)"</span>)</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"insert into test(p) values (?)"</span>, (p,))</span><br><span class="line">cur.execute(<span class="string">"select p from test"</span>)</span><br><span class="line">print(<span class="string">"with declared types:"</span>, cur.fetchone()[<span class="number">0</span>])</span><br><span class="line">cur.close()</span><br><span class="line">con.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################</span></span><br><span class="line"><span class="comment"># 1) Using column names</span></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>, detect_types=sqlite3.PARSE_COLNAMES)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(p)"</span>)</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"insert into test(p) values (?)"</span>, (p,))</span><br><span class="line">cur.execute(<span class="string">'select p as "p [point]" from test'</span>)</span><br><span class="line">print(<span class="string">"with column names:"</span>, cur.fetchone()[<span class="number">0</span>])</span><br><span class="line">cur.close()</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
<h3 id="默认适配器和转换器"><a href="#默认适配器和转换器" class="headerlink" title="默认适配器和转换器"></a>默认适配器和转换器</h3><p>对于时间和 日期时间类型, sqlite模块已经做了自动转换。</p>
<p>下面的示例演示了这一点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>, detect_types=sqlite3.PARSE_DECLTYPES|sqlite3.PARSE_COLNAMES)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(d date, ts timestamp)"</span>)</span><br><span class="line"></span><br><span class="line">today = datetime.date.today()</span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"insert into test(d, ts) values (?, ?)"</span>, (today, now))</span><br><span class="line">cur.execute(<span class="string">"select d, ts from test"</span>)</span><br><span class="line">row = cur.fetchone()</span><br><span class="line">print(today, <span class="string">"=&gt;"</span>, row[<span class="number">0</span>], type(row[<span class="number">0</span>]))</span><br><span class="line">print(now, <span class="string">"=&gt;"</span>, row[<span class="number">1</span>], type(row[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">'select current_date as "d [date]", current_timestamp as "ts [timestamp]"'</span>)</span><br><span class="line">row = cur.fetchone()</span><br><span class="line">print(<span class="string">"current_date"</span>, row[<span class="number">0</span>], type(row[<span class="number">0</span>]))</span><br><span class="line">print(<span class="string">"current_timestamp"</span>, row[<span class="number">1</span>], type(row[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
<h2 id="控制事务"><a href="#控制事务" class="headerlink" title="控制事务"></a>控制事务</h2><p>默认<code>sqlite3</code>中对于<code>autocommit</code> 默认是开启的,但是Python中的<code>sqlite3</code>模块默认并没有开启。</p>
<p><code>autocommit</code> 模式意味着当修改数据库时对数据库影响立即生效。一个<code>BEGIN</code> 和 <code>SAVEPOINT</code>的语句禁止<code>automode</code>,如果是<code>COMMIT</code>，<code>ROLLBACK</code> 或<code>RELASE</code> 语句执行后,<code>autocommit</code>模式才设置成启用。</p>
<p>Python  <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a>  默认在DDL 语句( (例如: <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>/<code>REPLACE</code>).)执行前执行<code>BEGIN</code> 语句。</p>
<p>你可以通过控制 <code>BEGIN</code> 语句,隐式执行<code>connect()</code>方法的 <em>isolation_level</em> 参数,或是connections的 <em>isolation_level</em> 属性来实现。如果你没有声明 isolation_level,那么使用的就是普通的<code>BEGIN</code>使用,和<code>DEFERRED</code>是一样的。其他可能的值还有<code>IMMEDIATE</code> 和 <code>EXCLUSIVE</code>。</p>
<p>你可以在代码中通过禁止 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块中设定 control the transaction state 的值为<code>BEGIN</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code>, and <code>RELEASE</code> 语句实现事务处理。</p>
<h2 id="有效使用-sqlite3"><a href="#有效使用-sqlite3" class="headerlink" title="有效使用 sqlite3"></a>有效使用 <code>sqlite3</code></h2><h3 id="使用快捷方式"><a href="#使用快捷方式" class="headerlink" title="使用快捷方式"></a>使用快捷方式</h3><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象的非标准 <code>execute()</code>, <code>executemany()</code> 和 <code>executescript()</code> 方法，可以更简洁地编写代码，因为不必显式创建（通常是多余的） <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 对象。相反， <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 对象是隐式创建的，这些快捷方法返回游标对象。这样，只需对 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象调用一次，就能直接执行 <code>SELECT</code> 语句并遍历对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">persons = [</span><br><span class="line">    (<span class="string">"Hugo"</span>, <span class="string">"Boss"</span>),</span><br><span class="line">    (<span class="string">"Calvin"</span>, <span class="string">"Klein"</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the table</span></span><br><span class="line">con.execute(<span class="string">"create table person(firstname, lastname)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the table</span></span><br><span class="line">con.executemany(<span class="string">"insert into person(firstname, lastname) values (?, ?)"</span>, persons)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the table contents</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> con.execute(<span class="string">"select firstname, lastname from person"</span>):</span><br><span class="line">    print(row)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"I just deleted"</span>, con.execute(<span class="string">"delete from person"</span>).rowcount, <span class="string">"rows"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># close is not a shortcut method and it's not called automatically,</span></span><br><span class="line"><span class="comment"># so the connection object should be closed manually</span></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
<h3 id="通过名称而不是索引访问索引"><a href="#通过名称而不是索引访问索引" class="headerlink" title="通过名称而不是索引访问索引"></a>通过名称而不是索引访问索引</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块的一个有用功能是内置的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Row" target="_blank" rel="noopener"><code>sqlite3.Row</code></a> 类，该类旨在用作行工厂。</p>
<p>该类的行装饰器可以用索引（如元组）和不区分大小写的名称访问：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.row_factory = sqlite3.Row</span><br><span class="line"></span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"select 'John' as name, 42 as age"</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cur:</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="number">0</span>] == row[<span class="string">"name"</span>]</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="string">"name"</span>] == row[<span class="string">"nAmE"</span>]</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="number">1</span>] == row[<span class="string">"age"</span>]</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="number">1</span>] == row[<span class="string">"AgE"</span>]</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
<h3 id="使用连接作为上下文管理器"><a href="#使用连接作为上下文管理器" class="headerlink" title="使用连接作为上下文管理器"></a>使用连接作为上下文管理器</h3><p>连接对象可以用来作为上下文管理器，它可以自动提交或者回滚事务。如果出现异常，事务会被回滚；否则，事务会被提交。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.execute(<span class="string">"create table person (id integer primary key, firstname varchar unique)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Successful, con.commit() is called automatically afterwards</span></span><br><span class="line"><span class="keyword">with</span> con:</span><br><span class="line">    con.execute(<span class="string">"insert into person(firstname) values (?)"</span>, (<span class="string">"Joe"</span>,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># con.rollback() is called after the with block finishes with an exception, the</span></span><br><span class="line"><span class="comment"># exception is still raised and must be caught</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> con:</span><br><span class="line">        con.execute(<span class="string">"insert into person(firstname) values (?)"</span>, (<span class="string">"Joe"</span>,))</span><br><span class="line"><span class="keyword">except</span> sqlite3.IntegrityError:</span><br><span class="line">    print(<span class="string">"couldn't add Joe twice"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connection object used as context manager only commits or rollbacks transactions,</span></span><br><span class="line"><span class="comment"># so the connection object should be closed manually</span></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>较老版本的 SQLite 在共享线程之间存在连接问题。这就是Python模块不允许线程之间共享连接和游标的原因。如果仍然尝试这样做，则在运行时会出现异常。</p>
<p>唯一的例外是调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.interrupt" target="_blank" rel="noopener"><code>interrupt()</code></a> 方法，该方法仅在从其他线程进行调用时才有意义。</p>
<h2 id="关于事务的补充说明"><a href="#关于事务的补充说明" class="headerlink" title="关于事务的补充说明"></a>关于事务的补充说明</h2><p><code>isolation_level</code> 到底控制的是什么,下图摘自SQLite官网。</p>
<p><img src="http://static.oschina.net/uploads/img/201607/27151258_jtqf.gif" alt></p>
<p>下面是一个在connect()中不传入 isolation_level的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">'''sqlite3事务总结:</span></span><br><span class="line"><span class="string">在connect()中不传入 isolation_level</span></span><br><span class="line"><span class="string">事务处理:</span></span><br><span class="line"><span class="string">    使用connection.commit()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">分析:</span></span><br><span class="line"><span class="string">    智能commit状态:</span></span><br><span class="line"><span class="string">        生成方式: 在connect()中不传入 isolation_level, 此时isolation_level==''</span></span><br><span class="line"><span class="string">            在进行 执行Data Modification Language (DML) 操作(INSERT/UPDATE/DELETE/REPLACE)时, 会自动打开一个事务,</span></span><br><span class="line"><span class="string">            在执行 非DML, 非query (非 SELECT 和上面提到的)语句时, 会隐式执行commit</span></span><br><span class="line"><span class="string">            可以使用 connection.commit()方法来进行提交</span></span><br><span class="line"><span class="string">        注意:</span></span><br><span class="line"><span class="string">            不能和cur.execute("COMMIT")共用</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    自动commit状态:</span></span><br><span class="line"><span class="string">        生成方式: 在connect()中传入 isolation_level=None</span></span><br><span class="line"><span class="string">            这样,在任何DML操作时,都会自动提交</span></span><br><span class="line"><span class="string">        事务处理</span></span><br><span class="line"><span class="string">            connection.execute("BEGIN TRANSACTION")</span></span><br><span class="line"><span class="string">            connection.execute("COMMIT")</span></span><br><span class="line"><span class="string">        如果不使用事务, 批量添加数据非常缓慢</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数据对比:</span></span><br><span class="line"><span class="string">    两种方式, 事务耗时差别不大</span></span><br><span class="line"><span class="string">    count = 100000</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.621</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.601</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.588</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.581</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.598</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.588</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.589</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.602</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.588</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.622</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elapse_time</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''耗时统计工具'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, prompt=<span class="string">''</span>)</span>:</span></span><br><span class="line">        self.prompt = prompt</span><br><span class="line">        self.start = time.time()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s耗时: %.3f'</span> % (self.prompt, time.time() - self.start))</span><br><span class="line">CElapseTime = Elapse_time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">'e:/temp/a.db'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepare</span><span class="params">(isolation_level = <span class="string">''</span>)</span>:</span></span><br><span class="line">    connection = sqlite3.connect(filename, isolation_level = isolation_level)</span><br><span class="line">    connection.execute(<span class="string">"create table IF NOT EXISTS  people (num, age)"</span>)</span><br><span class="line">    connection.execute(<span class="string">'delete from people'</span>)</span><br><span class="line">    connection.commit()</span><br><span class="line">    <span class="keyword">return</span> connection, connection.cursor()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db_insert_values</span><span class="params">(cursor, count)</span>:</span></span><br><span class="line">    num = <span class="number">1</span> </span><br><span class="line">    age = <span class="number">2</span> * num </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> num &lt;= count:</span><br><span class="line">        cursor.execute(<span class="string">"insert into people values (?, ?)"</span>, (num, age))</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        age = <span class="number">2</span> * num </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">study_case1_intelligent_commit</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    在智能commit状态下, 不能和cur.execute("COMMIT")共用</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    connection, cursor = prepare()</span><br><span class="line">    </span><br><span class="line">    elapse_time = Elapse_time(<span class="string">'  智能commit'</span>)</span><br><span class="line">    db_insert_values(cursor, count)</span><br><span class="line">    <span class="comment">#cursor.execute("COMMIT")  #产生异常</span></span><br><span class="line">    </span><br><span class="line">    cursor.execute(<span class="string">"select count(*) from people"</span>)</span><br><span class="line">    <span class="keyword">print</span> (cursor.fetchone())</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">study_case2_autocommit</span><span class="params">(count)</span>:</span></span><br><span class="line">    connection, cursor = prepare(isolation_level = <span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    elapse_time = Elapse_time(<span class="string">'  自动commit'</span>)</span><br><span class="line">    db_insert_values(cursor, count)</span><br><span class="line">    </span><br><span class="line">    cursor.execute(<span class="string">"select count(*) from people"</span>)    </span><br><span class="line">    <span class="keyword">print</span> (cursor.fetchone())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">study_case3_intelligent_commit_manual</span><span class="params">(count)</span>:</span></span><br><span class="line">    connection, cursor = prepare()</span><br><span class="line">    </span><br><span class="line">    elapse_time = Elapse_time(<span class="string">'  智能commit即时提交'</span>)</span><br><span class="line">    db_insert_values(cursor, count)</span><br><span class="line">    connection.commit()</span><br><span class="line">    </span><br><span class="line">    cursor.execute(<span class="string">"select count(*) from people"</span>)</span><br><span class="line">    <span class="keyword">print</span> (cursor.fetchone())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">study_case4_autocommit_transaction</span><span class="params">(count)</span>:</span></span><br><span class="line">    connection, cursor = prepare(isolation_level = <span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    elapse_time = Elapse_time(<span class="string">'  自动commit'</span>)</span><br><span class="line">    connection.execute(<span class="string">"BEGIN TRANSACTION;"</span>) <span class="comment"># 关键点</span></span><br><span class="line">    db_insert_values(cursor, count)</span><br><span class="line">    connection.execute(<span class="string">"COMMIT;"</span>)  <span class="comment">#关键点</span></span><br><span class="line">    </span><br><span class="line">    cursor.execute(<span class="string">"select count(*) from people;"</span>)</span><br><span class="line">    <span class="keyword">print</span> (cursor.fetchone())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    count = <span class="number">10000</span></span><br><span class="line">    prepare()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="comment">#study_case1_intelligent_commit(count) #不提交数据</span></span><br><span class="line">        <span class="comment">#study_case2_autocommit(count)  #非常缓慢</span></span><br><span class="line">        study_case3_intelligent_commit_manual(count)</span><br><span class="line">        study_case4_autocommit_transaction(count)</span><br></pre></td></tr></table></figure>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://my.oschina.net/tinyhare/blog/719039" target="_blank" rel="noopener">python sqlite3 事务控制</a></p>
<p><a href="https://www.cnblogs.com/yaoyu126/p/6413423.html" target="_blank" rel="noopener">python sqlite3 事务总结</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sqlite3</tag>
        <tag>standard_library</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library pprint</title>
    <url>/2020/01/27/python-standard-library-pprint/</url>
    <content><![CDATA[<h1 id="python-标准库-pprint"><a href="#python-标准库-pprint" class="headerlink" title="python 标准库 pprint"></a>python 标准库 pprint</h1><p><img src="https://s.yimg.com/ny/api/res/1.2/U9YwDsQH7.4w06Tgw2pHJg--~A/YXBwaWQ9aGlnaGxhbmRlcjtzbT0xO3c9MTI4MDtoPTk2MA--/https://media.zenfs.com/zh-tw/nownews.com/e25e4ab4f7a980ccfcaca403eafb3a15" alt></p>
<a id="more"></a>
<p><img src="http://i3.sinaimg.cn/ty/nba/2014-12-17/U4933P6T12D7449800F44DT20141217031102.jpg" alt></p>
<p><img src="https://p9.pstatp.com/large/2a3500018a7a07e8a548" alt></p>
<p>今天凌晨,突闻噩耗, 「黑曼巴」 Kobe Bryant（科比） 永远离开了我们,永远的24号,最伟大的nba球员,没有之一,R.I.P。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=31719570&auto=1&height=66"></iframe>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/pprint.py" target="_blank" rel="noopener">Lib/pprint.py</a> </p>
<p>主要类和函数,节选自<a href="https://github.com/python/cpython/tree/3.8/Lib/pprint.py" target="_blank" rel="noopener">源码</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [<span class="string">"pprint"</span>,<span class="string">"pformat"</span>,<span class="string">"isreadable"</span>,<span class="string">"isrecursive"</span>,<span class="string">"saferepr"</span>,</span><br><span class="line">           <span class="string">"PrettyPrinter"</span>, <span class="string">"pp"</span>]</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#module-pprint" target="_blank" rel="noopener"><code>pprint</code></a> 模块提供了“美化打印”任意 Python 数据结构的功能，这种美化形式可用作对解释器的输入。 如果经格式化的结构包含非基本 Python 类型的对象，则其美化形式可能无法被加载。 包含文件、套接字或类对象，以及许多其他不能用 Python 字面值来表示的对象都有可能导致这样的结果。</p>
<p>格式化后的形式会在可能的情况下以单行来表示对象，并在无法在允许宽度内容纳对象的情况下将其分为多行。 如果你需要调整宽度限制则应显式地构造 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 对象。</p>
<p>字典在计算其显示形式前会先根据键来排序。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p> <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#module-pprint" target="_blank" rel="noopener"><code>pprint</code></a> 模块定义了一个类： </p>
<ul>
<li><p><em>class</em> <code>pprint.PrettyPrinter</code>(<em>indent=1</em>, <em>width=80</em>, <em>depth=None</em>, <em>stream=None</em>, <em>**, </em>compact=False<em>, </em>sort_dicts=True*) </p>
<p> 构造一个 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 实例。 此构造器接受几个关键字形参。 使用 <em>stream</em> 关键字可设置输出流；流对象使用的唯一方法是文件协议的 <code>write()</code> 方法。 如果未指定此关键字，则 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 会选择 <code>sys.stdout</code>。 每个递归层次的缩进量由 <em>indent</em> 指定；默认值为一。 其他值可导致输出看起来有些怪异，，但可使得嵌套结构更易区分。 可被打印的层级数量由 <em>depth</em> 控制；如果数据结构的层级被打印得过深，其所包含的下一层级会被替换为 <code>...</code>。 在默认情况下，对被格式化对象的层级深度没有限制。 希望的输出宽度可使用 <em>width</em> 形参来限制；默认值为 80 个字符。 如果一个结构无法在限定宽度内被格式化，则将做到尽可能接近。 如果 <em>compact</em> 为假值（默认）则长序列的每一项将被格式化为单独的行。 如果 <em>compact</em> 为真值，则将在 <em>width</em> 可容纳的的情况下把尽可能多的项放入每个输出行。 如果 <em>sort_dicts</em> 为真值（默认），字典将被格式化为按键排序，否则将按插入顺序显示。 </p>
<p><em>在 3.8 版更改:</em> 增加了 <em>sort_dicts</em> 形参。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stuff = [<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>, <span class="string">'ni'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stuff.insert(<span class="number">0</span>, stuff[:])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp = pprint.PrettyPrinter(indent=<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp.pprint(stuff)</span><br><span class="line">[   [<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>, <span class="string">'ni'</span>],</span><br><span class="line">    <span class="string">'spam'</span>,</span><br><span class="line">    <span class="string">'eggs'</span>,</span><br><span class="line">    <span class="string">'lumberjack'</span>,</span><br><span class="line">    <span class="string">'knights'</span>,</span><br><span class="line">    <span class="string">'ni'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp = pprint.PrettyPrinter(width=<span class="number">41</span>, compact=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp.pprint(stuff)</span><br><span class="line">[[<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>,</span><br><span class="line">  <span class="string">'knights'</span>, <span class="string">'ni'</span>],</span><br><span class="line"> <span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>,</span><br><span class="line"> <span class="string">'ni'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup = (<span class="string">'spam'</span>, (<span class="string">'eggs'</span>, (<span class="string">'lumberjack'</span>, (<span class="string">'knights'</span>, (<span class="string">'ni'</span>, (<span class="string">'dead'</span>,</span><br><span class="line"><span class="meta">... </span>(<span class="string">'parrot'</span>, (<span class="string">'fresh fruit'</span>,))))))))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp = pprint.PrettyPrinter(depth=<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp.pprint(tup)</span><br><span class="line">(<span class="string">'spam'</span>, (<span class="string">'eggs'</span>, (<span class="string">'lumberjack'</span>, (<span class="string">'knights'</span>, (<span class="string">'ni'</span>, (<span class="string">'dead'</span>, (...)))))))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p> <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#module-pprint" target="_blank" rel="noopener"><code>pprint</code></a> 模块还提供了一些快捷函数： </p>
<ul>
<li><p><code>pprint.pformat</code>(<em>object</em>, <em>indent=1</em>, <em>width=80</em>, <em>depth=None</em>, <em>**, </em>compact=False<em>, </em>sort_dicts=True*)</p>
<p><em>object</em> 的格式化表示作为字符串返回。 <em>indent</em>, <em>width</em>, <em>depth</em>, <em>compact</em> 和 <em>sort_dicts</em> 将作为格式化形参被传入 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 构造器。<em>在 3.4 版更改:</em> 增加了 <em>compact</em> 形参。<em>在 3.8 版更改:</em> 增加了 <em>sort_dicts</em> 形参。</p>
</li>
<li><p><code>pprint.pp</code>(<em>object</em>, <strong>args<em>, </em>sort_dicts=False<em>, </em></strong>kwargs*)</p>
<p>打印 <em>object</em> 的格式化表示并附带一个换行符。 如果 <em>sort_dicts</em> 为假值（默认），字典将按键的插入顺序显示，否则将按字典键排序。 <em>args</em> 和 <em>kwargs</em> 将作为格式化形参被传给 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#module-pprint" target="_blank" rel="noopener"><code>pprint()</code></a>。<em>3.8 新版功能.</em></p>
</li>
<li><p><code>pprint.pprint</code>(<em>object</em>, <em>stream=None</em>, <em>indent=1</em>, <em>width=80</em>, <em>depth=None</em>, <em>**, </em>compact=False<em>, </em>sort_dicts=True*)</p>
<p>在 <em>stream</em> 上打打印 <em>object</em> 的格式化表示，并附带一个换行符。 如果 <em>stream</em> 为 <code>None</code>，则使用 <code>sys.stdout</code>。 这可以替代 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 函数在交互式解释器中使用以查看值（你甚至可以执行重新赋值 <code>print = pprint.pprint</code> 以在特定作用域中使用）。 <em>indent</em>, <em>width</em>, <em>depth</em>, <em>compact</em> 和 <em>sort_dicts</em> 将作为格式化形参被传给 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 构造器。</p>
<p><em>在 3.8 版更改:</em> 增加了 <em>sort_dicts</em> 形参。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stuff = [<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>, <span class="string">'ni'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stuff.insert(<span class="number">0</span>, stuff)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(stuff)</span><br><span class="line">[&lt;Recursion on list <span class="keyword">with</span> id=...&gt;,</span><br><span class="line"> <span class="string">'spam'</span>,</span><br><span class="line"> <span class="string">'eggs'</span>,</span><br><span class="line"> <span class="string">'lumberjack'</span>,</span><br><span class="line"> <span class="string">'knights'</span>,</span><br><span class="line"> <span class="string">'ni'</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="PrettyPrinter-对象"><a href="#PrettyPrinter-对象" class="headerlink" title="PrettyPrinter 对象"></a>PrettyPrinter 对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 的实例具有下列方法：</p>
<ul>
<li><p><code>PrettyPrinter.pformat</code>(<em>object</em>)</p>
<p>返回 <em>object</em> 格式化表示。 这会将传给 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 构造器的选项纳入考虑。</p>
</li>
<li><p><code>PrettyPrinter.pprint</code>(<em>object</em>)</p>
<p>在所配置的流上打印 <em>object</em> 的格式化表示，并附加一个换行符。</p>
</li>
</ul>
<p>下列方法提供了与同名函数相对应的实现。 在实例上使用这些方法效率会更高一些，因为不需要创建新的 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 对象。</p>
<ul>
<li><p><code>PrettyPrinter.isreadable</code>(<em>object</em>)</p>
<p>确定对象的格式化表示是否“可读”，或者是否可使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 重建对象值。 请注意此方法对于递归对象将返回 <code>False</code>。 如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 的 <em>depth</em> 形参并且对象深度超出允许范围，此方法将返回 <code>False</code>。</p>
</li>
<li><p><code>PrettyPrinter.isrecursive</code>(<em>object</em>)</p>
<p>确定对象是否需要递归表示。</p>
</li>
</ul>
<p>此方法作为一个钩子提供，允许子类修改将对象转换为字符串的方式。 默认实现使用 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.saferepr" target="_blank" rel="noopener"><code>saferepr()</code></a> 实现的内部方式。</p>
<ul>
<li><p><code>PrettyPrinter.format</code>(<em>object</em>, <em>context</em>, <em>maxlevels</em>, <em>level</em>)</p>
<p>返回三个值：字符串形式的 <em>object</em> 已格式化版本，指明结果是否可读的旗标，以及指明是否检测到递归的旗标。 第一个参数是要表示的对象。 第二个是以对象 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#id" target="_blank" rel="noopener"><code>id()</code></a> 为键的字典，这些对象是当前表示上下文的一部分（影响 <em>object</em> 表示的直接和间接容器）；如果需要呈现一个已经在 <em>context</em> 中表示的对象，则第三个返回值应当为 <code>True</code>。 对 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter.format" target="_blank" rel="noopener"><code>format()</code></a> 方法的递归调用应当将容器的附加条目添加到此字典中。 第三个参数 <em>maxlevels</em> 给出了对递归的请求限制；如果没有请求限制则其值将为 <code>0</code>。 此参数应当不加修改地传给递归调用。 第四个参数 <em>level</em> 给出于当前层级；传给递归调用的参数值应当小于当前调用的值。</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>为了演示 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#module-pprint" target="_blank" rel="noopener"><code>pprint()</code></a> 函数及其形参的几种用法，让我们从 <a href="https://pypi.org/" target="_blank" rel="noopener">PyPI</a> 获取关于某个项目的信息:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> urlopen(<span class="string">'https://pypi.org/pypi/sampleproject/json'</span>) <span class="keyword">as</span> resp:</span><br><span class="line"><span class="meta">... </span>    project_info = json.load(resp)[<span class="string">'info'</span>]</span><br></pre></td></tr></table></figure>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#module-pprint" target="_blank" rel="noopener"><code>pprint()</code></a> 以其基本形式显示了整个对象: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(project_info)</span><br><span class="line">&#123;<span class="string">'author'</span>: <span class="string">'The Python Packaging Authority'</span>,</span><br><span class="line"> <span class="string">'author_email'</span>: <span class="string">'pypa-dev@googlegroups.com'</span>,</span><br><span class="line"> <span class="string">'bugtrack_url'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'classifiers'</span>: [<span class="string">'Development Status :: 3 - Alpha'</span>,</span><br><span class="line">                 <span class="string">'Intended Audience :: Developers'</span>,</span><br><span class="line">                 <span class="string">'License :: OSI Approved :: MIT License'</span>,</span><br><span class="line">                 <span class="string">'Programming Language :: Python :: 2'</span>,</span><br><span class="line">                 <span class="string">'Programming Language :: Python :: 2.6'</span>,</span><br><span class="line">                 <span class="string">'Programming Language :: Python :: 2.7'</span>,</span><br><span class="line">                 <span class="string">'Programming Language :: Python :: 3'</span>,</span><br><span class="line">                 <span class="string">'Programming Language :: Python :: 3.2'</span>,</span><br><span class="line">                 <span class="string">'Programming Language :: Python :: 3.3'</span>,</span><br><span class="line">                 <span class="string">'Programming Language :: Python :: 3.4'</span>,</span><br><span class="line">                 <span class="string">'Topic :: Software Development :: Build Tools'</span>],</span><br><span class="line"> <span class="string">'description'</span>: <span class="string">'A sample Python project\n'</span></span><br><span class="line">                <span class="string">'=======================\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'This is the description file for the project.\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'The file should use UTF-8 encoding and be written using '</span></span><br><span class="line">                <span class="string">'ReStructured Text. It\n'</span></span><br><span class="line">                <span class="string">'will be used to generate the project webpage on PyPI, and '</span></span><br><span class="line">                <span class="string">'should be written for\n'</span></span><br><span class="line">                <span class="string">'that purpose.\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'Typical contents for this file would include an overview of '</span></span><br><span class="line">                <span class="string">'the project, basic\n'</span></span><br><span class="line">                <span class="string">'usage examples, etc. Generally, including the project '</span></span><br><span class="line">                <span class="string">'changelog in here is not\n'</span></span><br><span class="line">                <span class="string">'a good idea, although a simple "What\'s New" section for the '</span></span><br><span class="line">                <span class="string">'most recent version\n'</span></span><br><span class="line">                <span class="string">'may be appropriate.'</span>,</span><br><span class="line"> <span class="string">'description_content_type'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'docs_url'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'download_url'</span>: <span class="string">'UNKNOWN'</span>,</span><br><span class="line"> <span class="string">'downloads'</span>: &#123;<span class="string">'last_day'</span>: <span class="number">-1</span>, <span class="string">'last_month'</span>: <span class="number">-1</span>, <span class="string">'last_week'</span>: <span class="number">-1</span>&#125;,</span><br><span class="line"> <span class="string">'home_page'</span>: <span class="string">'https://github.com/pypa/sampleproject'</span>,</span><br><span class="line"> <span class="string">'keywords'</span>: <span class="string">'sample setuptools development'</span>,</span><br><span class="line"> <span class="string">'license'</span>: <span class="string">'MIT'</span>,</span><br><span class="line"> <span class="string">'maintainer'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'maintainer_email'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'name'</span>: <span class="string">'sampleproject'</span>,</span><br><span class="line"> <span class="string">'package_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/'</span>,</span><br><span class="line"> <span class="string">'platform'</span>: <span class="string">'UNKNOWN'</span>,</span><br><span class="line"> <span class="string">'project_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/'</span>,</span><br><span class="line"> <span class="string">'project_urls'</span>: &#123;<span class="string">'Download'</span>: <span class="string">'UNKNOWN'</span>,</span><br><span class="line">                  <span class="string">'Homepage'</span>: <span class="string">'https://github.com/pypa/sampleproject'</span>&#125;,</span><br><span class="line"> <span class="string">'release_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/1.2.0/'</span>,</span><br><span class="line"> <span class="string">'requires_dist'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'requires_python'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'summary'</span>: <span class="string">'A sample Python project'</span>,</span><br><span class="line"> <span class="string">'version'</span>: <span class="string">'1.2.0'</span>&#125;</span><br></pre></td></tr></table></figure>
<p> 结果可以被限制到特定的 <em>depth</em> (更深层的内容将使用省略号): </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(project_info, depth=<span class="number">1</span>)</span><br><span class="line">&#123;<span class="string">'author'</span>: <span class="string">'The Python Packaging Authority'</span>,</span><br><span class="line"> <span class="string">'author_email'</span>: <span class="string">'pypa-dev@googlegroups.com'</span>,</span><br><span class="line"> <span class="string">'bugtrack_url'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'classifiers'</span>: [...],</span><br><span class="line"> <span class="string">'description'</span>: <span class="string">'A sample Python project\n'</span></span><br><span class="line">                <span class="string">'=======================\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'This is the description file for the project.\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'The file should use UTF-8 encoding and be written using '</span></span><br><span class="line">                <span class="string">'ReStructured Text. It\n'</span></span><br><span class="line">                <span class="string">'will be used to generate the project webpage on PyPI, and '</span></span><br><span class="line">                <span class="string">'should be written for\n'</span></span><br><span class="line">                <span class="string">'that purpose.\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'Typical contents for this file would include an overview of '</span></span><br><span class="line">                <span class="string">'the project, basic\n'</span></span><br><span class="line">                <span class="string">'usage examples, etc. Generally, including the project '</span></span><br><span class="line">                <span class="string">'changelog in here is not\n'</span></span><br><span class="line">                <span class="string">'a good idea, although a simple "What\'s New" section for the '</span></span><br><span class="line">                <span class="string">'most recent version\n'</span></span><br><span class="line">                <span class="string">'may be appropriate.'</span>,</span><br><span class="line"> <span class="string">'description_content_type'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'docs_url'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'download_url'</span>: <span class="string">'UNKNOWN'</span>,</span><br><span class="line"> <span class="string">'downloads'</span>: &#123;...&#125;,</span><br><span class="line"> <span class="string">'home_page'</span>: <span class="string">'https://github.com/pypa/sampleproject'</span>,</span><br><span class="line"> <span class="string">'keywords'</span>: <span class="string">'sample setuptools development'</span>,</span><br><span class="line"> <span class="string">'license'</span>: <span class="string">'MIT'</span>,</span><br><span class="line"> <span class="string">'maintainer'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'maintainer_email'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'name'</span>: <span class="string">'sampleproject'</span>,</span><br><span class="line"> <span class="string">'package_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/'</span>,</span><br><span class="line"> <span class="string">'platform'</span>: <span class="string">'UNKNOWN'</span>,</span><br><span class="line"> <span class="string">'project_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/'</span>,</span><br><span class="line"> <span class="string">'project_urls'</span>: &#123;...&#125;,</span><br><span class="line"> <span class="string">'release_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/1.2.0/'</span>,</span><br><span class="line"> <span class="string">'requires_dist'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'requires_python'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'summary'</span>: <span class="string">'A sample Python project'</span>,</span><br><span class="line"> <span class="string">'version'</span>: <span class="string">'1.2.0'</span>&#125;</span><br></pre></td></tr></table></figure>
<p> 此外，还可以设置建议的最大字符 <em>width</em>。 如果一个对象无法被拆分，则将超出指定宽度: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(project_info, depth=<span class="number">1</span>, width=<span class="number">60</span>)</span><br><span class="line">&#123;<span class="string">'author'</span>: <span class="string">'The Python Packaging Authority'</span>,</span><br><span class="line"> <span class="string">'author_email'</span>: <span class="string">'pypa-dev@googlegroups.com'</span>,</span><br><span class="line"> <span class="string">'bugtrack_url'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'classifiers'</span>: [...],</span><br><span class="line"> <span class="string">'description'</span>: <span class="string">'A sample Python project\n'</span></span><br><span class="line">                <span class="string">'=======================\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'This is the description file for the '</span></span><br><span class="line">                <span class="string">'project.\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'The file should use UTF-8 encoding and be '</span></span><br><span class="line">                <span class="string">'written using ReStructured Text. It\n'</span></span><br><span class="line">                <span class="string">'will be used to generate the project '</span></span><br><span class="line">                <span class="string">'webpage on PyPI, and should be written '</span></span><br><span class="line">                <span class="string">'for\n'</span></span><br><span class="line">                <span class="string">'that purpose.\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'Typical contents for this file would '</span></span><br><span class="line">                <span class="string">'include an overview of the project, '</span></span><br><span class="line">                <span class="string">'basic\n'</span></span><br><span class="line">                <span class="string">'usage examples, etc. Generally, including '</span></span><br><span class="line">                <span class="string">'the project changelog in here is not\n'</span></span><br><span class="line">                <span class="string">'a good idea, although a simple "What\'s '</span></span><br><span class="line">                <span class="string">'New" section for the most recent version\n'</span></span><br><span class="line">                <span class="string">'may be appropriate.'</span>,</span><br><span class="line"> <span class="string">'description_content_type'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'docs_url'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'download_url'</span>: <span class="string">'UNKNOWN'</span>,</span><br><span class="line"> <span class="string">'downloads'</span>: &#123;...&#125;,</span><br><span class="line"> <span class="string">'home_page'</span>: <span class="string">'https://github.com/pypa/sampleproject'</span>,</span><br><span class="line"> <span class="string">'keywords'</span>: <span class="string">'sample setuptools development'</span>,</span><br><span class="line"> <span class="string">'license'</span>: <span class="string">'MIT'</span>,</span><br><span class="line"> <span class="string">'maintainer'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'maintainer_email'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'name'</span>: <span class="string">'sampleproject'</span>,</span><br><span class="line"> <span class="string">'package_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/'</span>,</span><br><span class="line"> <span class="string">'platform'</span>: <span class="string">'UNKNOWN'</span>,</span><br><span class="line"> <span class="string">'project_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/'</span>,</span><br><span class="line"> <span class="string">'project_urls'</span>: &#123;...&#125;,</span><br><span class="line"> <span class="string">'release_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/1.2.0/'</span>,</span><br><span class="line"> <span class="string">'requires_dist'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'requires_python'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'summary'</span>: <span class="string">'A sample Python project'</span>,</span><br><span class="line"> <span class="string">'version'</span>: <span class="string">'1.2.0'</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="1-常用格式化"><a href="#1-常用格式化" class="headerlink" title="1. 常用格式化"></a>1. 常用格式化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [(<span class="number">1</span>,&#123;<span class="string">'a'</span>:<span class="string">'A'</span>,<span class="string">'b'</span>:<span class="string">'B'</span>,<span class="string">'c'</span>:<span class="string">'C'</span>,<span class="string">'d'</span>:<span class="string">'D'</span>&#125;),(<span class="number">2</span>,&#123;<span class="string">'e'</span>:<span class="string">'E'</span>,<span class="string">'f'</span>:<span class="string">'F'</span>,<span class="string">'g'</span>:<span class="string">'G'</span>,<span class="string">'h'</span>:<span class="string">'H'</span>,<span class="string">'i'</span>:<span class="string">'I'</span>,<span class="string">'j'</span>:<span class="string">'J'</span>,<span class="string">'k'</span>:<span class="string">'K'</span>,<span class="string">'l'</span>:<span class="string">'L'</span>&#125;),]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(data)</span><br><span class="line">[(<span class="number">1</span>, &#123;<span class="string">'a'</span>: <span class="string">'A'</span>, <span class="string">'b'</span>: <span class="string">'B'</span>, <span class="string">'c'</span>: <span class="string">'C'</span>, <span class="string">'d'</span>: <span class="string">'D'</span>&#125;),</span><br><span class="line"> (<span class="number">2</span>,</span><br><span class="line">  &#123;<span class="string">'e'</span>: <span class="string">'E'</span>,</span><br><span class="line">   <span class="string">'f'</span>: <span class="string">'F'</span>,</span><br><span class="line">   <span class="string">'g'</span>: <span class="string">'G'</span>,</span><br><span class="line">   <span class="string">'h'</span>: <span class="string">'H'</span>,</span><br><span class="line">   <span class="string">'i'</span>: <span class="string">'I'</span>,</span><br><span class="line">   <span class="string">'j'</span>: <span class="string">'J'</span>,</span><br><span class="line">   <span class="string">'k'</span>: <span class="string">'K'</span>,</span><br><span class="line">   <span class="string">'l'</span>: <span class="string">'L'</span>&#125;)]</span><br></pre></td></tr></table></figure>
<h3 id="2-格式化序列"><a href="#2-格式化序列" class="headerlink" title="2. 格式化序列"></a>2. 格式化序列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [(<span class="number">1</span>,&#123;<span class="string">'a'</span>:<span class="string">'A'</span>,<span class="string">'b'</span>:<span class="string">'B'</span>,<span class="string">'c'</span>:<span class="string">'C'</span>,<span class="string">'d'</span>:<span class="string">'D'</span>&#125;),(<span class="number">2</span>,&#123;<span class="string">'e'</span>:<span class="string">'E'</span>,<span class="string">'f'</span>:<span class="string">'F'</span>,<span class="string">'g'</span>:<span class="string">'G'</span>,<span class="string">'h'</span>:<span class="string">'H'</span>,<span class="string">'i'</span>:<span class="string">'I'</span>,<span class="string">'j'</span>:<span class="string">'J'</span>,<span class="string">'k'</span>:<span class="string">'K'</span>,<span class="string">'l'</span>:<span class="string">'L'</span>&#125;),]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result=pprint.pformat(data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> result.splitlines():</span><br><span class="line">	print(key)</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">[(<span class="number">1</span>, &#123;<span class="string">'a'</span>: <span class="string">'A'</span>, <span class="string">'b'</span>: <span class="string">'B'</span>, <span class="string">'c'</span>: <span class="string">'C'</span>, <span class="string">'d'</span>: <span class="string">'D'</span>&#125;),</span><br><span class="line"> (<span class="number">2</span>,</span><br><span class="line">  &#123;<span class="string">'e'</span>: <span class="string">'E'</span>,</span><br><span class="line">   <span class="string">'f'</span>: <span class="string">'F'</span>,</span><br><span class="line">   <span class="string">'g'</span>: <span class="string">'G'</span>,</span><br><span class="line">   <span class="string">'h'</span>: <span class="string">'H'</span>,</span><br><span class="line">   <span class="string">'i'</span>: <span class="string">'I'</span>,</span><br><span class="line">   <span class="string">'j'</span>: <span class="string">'J'</span>,</span><br><span class="line">   <span class="string">'k'</span>: <span class="string">'K'</span>,</span><br><span class="line">   <span class="string">'l'</span>: <span class="string">'L'</span>&#125;)]</span><br></pre></td></tr></table></figure>
<h3 id="3-复杂的格式化-用于调试代码"><a href="#3-复杂的格式化-用于调试代码" class="headerlink" title="3. 复杂的格式化,用于调试代码"></a>3. 复杂的格式化,用于调试代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pprint;</span><br><span class="line"><span class="keyword">import</span> re;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pprintDemo</span><span class="params">()</span>:</span></span><br><span class="line">    varsList = [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="string">"ab"</span>, <span class="string">"c"</span>, <span class="string">"def"</span>],</span><br><span class="line">        re.compile(<span class="string">"\w+"</span>),</span><br><span class="line">        (<span class="string">"123"</span>, <span class="string">"abc"</span>),</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"key1"</span>:<span class="string">"value1"</span>,</span><br><span class="line">            <span class="string">"key2"</span>:<span class="string">"value2"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> varsList:</span><br><span class="line">        print(value);</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">"-"</span>*<span class="number">80</span>)</span><br><span class="line"> </span><br><span class="line">    pp = pprint.PrettyPrinter(indent=<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> varsList:</span><br><span class="line">        pp.pprint(value);</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">"-"</span>*<span class="number">80</span>)</span><br><span class="line">    stuff = [<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>, <span class="string">'ni'</span>];</span><br><span class="line">    stuff.insert(<span class="number">0</span>, stuff[:])</span><br><span class="line">    <span class="keyword">print</span> stuff;</span><br><span class="line">    print(<span class="string">"-"</span>*<span class="number">80</span>)</span><br><span class="line">    pp.pprint(stuff)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pprintDemo();</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="string">'ab'</span>, <span class="string">'c'</span>, <span class="string">'def'</span>]</span><br><span class="line">&lt;_sre.SRE_Pattern object at <span class="number">0x00000000030DD378</span>&gt;</span><br><span class="line">(<span class="string">'123'</span>, <span class="string">'abc'</span>)</span><br><span class="line">&#123;<span class="string">'key2'</span>: <span class="string">'value2'</span>, <span class="string">'key1'</span>: <span class="string">'value1'</span>&#125;</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="string">'ab'</span>, <span class="string">'c'</span>, <span class="string">'def'</span>]</span><br><span class="line">&lt;_sre.SRE_Pattern object at <span class="number">0x00000000030DD378</span>&gt;</span><br><span class="line">(<span class="string">'123'</span>, <span class="string">'abc'</span>)</span><br><span class="line">&#123;   <span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</span><br><span class="line">================================================================================</span><br><span class="line">[[<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>, <span class="string">'ni'</span>], <span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>, <span class="string">'ni'</span>]</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[   [<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>, <span class="string">'ni'</span>],</span><br><span class="line">    <span class="string">'spam'</span>,</span><br><span class="line">    <span class="string">'eggs'</span>,</span><br><span class="line">    <span class="string">'lumberjack'</span>,</span><br><span class="line">    <span class="string">'knights'</span>,</span><br><span class="line">    <span class="string">'ni'</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>pprint</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library dataclasses</title>
    <url>/2020/01/25/python-standard-library-dataclasses/</url>
    <content><![CDATA[<h1 id="python-标准库-dataclasses"><a href="#python-标准库-dataclasses" class="headerlink" title="python 标准库 dataclasses"></a>python 标准库 dataclasses</h1><p><img src="https://img.zcool.cn/community/01b9205e2af974a8012165188cc6ad.jpg@1280w_1l_2o_100sh.jpg" alt></p>
<a id="more"></a>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dataclasses.py" target="_blank" rel="noopener">Lib/dataclasses.py</a> </p>
<p>主要类结构层次,节选自<a href="[Lib/dataclasses.py](https://github.com/python/cpython/tree/3.8/Lib/dataclasses.py">源码</a> )</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [<span class="string">'dataclass'</span>,</span><br><span class="line">           <span class="string">'field'</span>,</span><br><span class="line">           <span class="string">'Field'</span>,</span><br><span class="line">           <span class="string">'FrozenInstanceError'</span>,</span><br><span class="line">           <span class="string">'InitVar'</span>,</span><br><span class="line">           <span class="string">'MISSING'</span>,</span><br><span class="line"></span><br><span class="line">           <span class="comment"># Helper functions.</span></span><br><span class="line">           <span class="string">'fields'</span>,</span><br><span class="line">           <span class="string">'asdict'</span>,</span><br><span class="line">           <span class="string">'astuple'</span>,</span><br><span class="line">           <span class="string">'make_dataclass'</span>,</span><br><span class="line">           <span class="string">'replace'</span>,</span><br><span class="line">           <span class="string">'is_dataclass'</span>,</span><br><span class="line">           ]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DataclassParams</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'init'</span>,</span><br><span class="line">                 <span class="string">'repr'</span>,</span><br><span class="line">                 <span class="string">'eq'</span>,</span><br><span class="line">                 <span class="string">'order'</span>,</span><br><span class="line">                 <span class="string">'unsafe_hash'</span>,</span><br><span class="line">                 <span class="string">'frozen'</span>,</span><br><span class="line">                 )</span><br></pre></td></tr></table></figure>
<p> 这个模块提供了一个装饰器和一些函数，用于自动添加生成的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-special-method" target="_blank" rel="noopener">special method</a>s ，例如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> 到用户定义的类。 它最初描述于 <a href="https://www.python.org/dev/peps/pep-0557" target="_blank" rel="noopener"><strong>PEP 557</strong></a> 。 </p>
<p> 在这些生成的方法中使用的成员变量使用 <a href="https://www.python.org/dev/peps/pep-0526" target="_blank" rel="noopener"><strong>PEP 526</strong></a> 类型注释定义。例如这段代码: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryItem</span>:</span></span><br><span class="line">    <span class="string">'''Class for keeping track of an item in inventory.'''</span></span><br><span class="line">    name: str</span><br><span class="line">    unit_price: float</span><br><span class="line">    quantity_on_hand: int = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_cost</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">return</span> self.unit_price * self.quantity_on_hand</span><br></pre></td></tr></table></figure>
<p> 除其他事情外，将添加 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> ，其看起来像: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name: str, unit_price: float, quantity_on_hand: int=<span class="number">0</span>)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.unit_price = unit_price</span><br><span class="line">    self.quantity_on_hand = quantity_on_hand</span><br></pre></td></tr></table></figure>
<p> 请注意，此方法会自动添加到类中：它不会在上面显示的 <code>InventoryItem</code> 定义中直接指定。 </p>
<h2 id="模块级装饰器、类和函数"><a href="#模块级装饰器、类和函数" class="headerlink" title="模块级装饰器、类和函数"></a>模块级装饰器、类和函数</h2><ul>
<li><p><a href="mailto:`@dataclasses.dataclass" target="_blank" rel="noopener">`@dataclasses.dataclass</a>`(<em>**, </em>init=True<em>, </em>repr=True<em>, </em>eq=True<em>, </em>order=False<em>, </em>unsafe_hash=False<em>, </em>frozen=False*) </p>
<p>这个函数是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-decorator" target="_blank" rel="noopener">decorator</a> ，用于将生成的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-special-method" target="_blank" rel="noopener">special method</a> 添加到类中，如下所述。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 装饰器检查类以找到 <code>field</code>。 <code>field</code> 被定义为具有 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-variable-annotation" target="_blank" rel="noopener">类型标注</a> 的类变量。除了下面描述的两个例外，在 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 中没有任何内容检查变量标注中指定的类型。</p>
<p>所有生成的方法中的字段顺序是它们在类定义中出现的顺序。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 装饰器将向类中添加各种“dunder”方法，如下所述。如果类中已存在任何添加的方法，则行为取决于参数，如下所述。装饰器返回被调用的同一个类；没有创建新类。</p>
<p>如果 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 仅用作没有参数的简单装饰器，它就像它具有此签名中记录的默认值一样。也就是说，这三种 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 用法是等价的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 的参数有： </p>
<ul>
<li><p><code>init</code>: 如果为真值（默认），将生成一个 <code>__ init__()</code> 方法。 </p>
<p>如果类已定义 <code>__ init__()</code> ，则忽略此参数。 </p>
</li>
<li><p><code>repr</code> ：如果为真值（默认），将生成一个 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> 方法。 生成的 repr 字符串将具有类名以及每个字段的名称和 repr ，按照它们在类中定义的顺序。不包括标记为从 repr 中排除的字段。 例如：<code>InventoryItem(name=&#39;widget&#39;, unit_price=3.0, quantity_on_hand=10)</code>。 </p>
<p>如果类已定义 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> ，则忽略此参数。 </p>
</li>
<li><p><code>eq</code> ：如果为true（默认值），将生成 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> 方法。此方法将类作为其字段的元组按顺序比较。比较中的两个实例必须是相同的类型。 </p>
<p>如果类已定义 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> ，则忽略此参数。 </p>
</li>
<li><p><code>order</code> ：如果为真值（默认为 <code>False</code> ），则 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__lt__" target="_blank" rel="noopener"><code>__lt__()</code></a> 、 <code>__ le__()</code> 、 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__gt__" target="_blank" rel="noopener"><code>__gt__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__ge__" target="_blank" rel="noopener"><code>__ge__()</code></a> 方法将生成。 这将类作为其字段的元组按顺序比较。比较中的两个实例必须是相同的类型。如果 <code>order</code> 为真值并且 <code>eq</code> 为假值 ，则引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 。</p>
<p>如果类已经定义了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__lt__" target="_blank" rel="noopener"><code>__lt__()</code></a> 、 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__le__" target="_blank" rel="noopener"><code>__le__()</code></a> 、 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__gt__" target="_blank" rel="noopener"><code>__gt__()</code></a> 或者 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__ge__" target="_blank" rel="noopener"><code>__ge__()</code></a> 中的任意一个，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 。 </p>
</li>
<li><p><code>unsafe_hash</code> ：如果为 <code>False</code> （默认值），则根据 <code>eq</code> 和 <code>frozen</code> 的设置方式生成 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法。 </p>
<p><a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 由内置的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#hash" target="_blank" rel="noopener"><code>hash()</code></a> 使用，当对象被添加到散列集合（如字典和集合）时。有一个 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 意味着类的实例是不可变的。可变性是一个复杂的属性，取决于程序员的意图， <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> 的存在性和行为，以及 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 装饰器中 <code>eq</code> 和 <code>frozen</code> 标志的值。</p>
<p>默认情况下， <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 不会隐式添加 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法，除非这样做是安全的。 它也不会添加或更改现有的明确定义的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法。 设置类属性 <code>__hash__ = None</code> 对 Python 具有特定含义，如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 文档中所述。</p>
<p>如果 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 没有显式定义，或者它被设置为 <code>None</code> ，那么 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> <em>可以</em> 添加一个隐式 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法。虽然不推荐，但你可以强制 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 用 <code>unsafe_hash=True</code> 创建一个 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法。 如果你的类在逻辑上是不可变的但实际仍然可变，则可能就是这种情况。这是一个特殊的用例，应该仔细考虑。</p>
<p>以下是隐式创建 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法的规则。请注意，你不能在数据类中都使用显式的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法并设置 <code>unsafe_hash=True</code> ；这将导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 。</p>
<p>如果 <code>eq</code> 和 <code>frozen</code> 都是 true，默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 将为你生成一个 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法。如果 <code>eq</code> 为 true 且 <code>frozen</code> 为 false ，则 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 将被设置为 <code>None</code> ，标记它不可用（因为它是可变的）。如果 <code>eq</code> 为 false ，则 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 将保持不变，这意味着将使用超类的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法（如果超类是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> ，这意味着它将回到基于id的hash）。</p>
</li>
<li><p><code>frozen</code>: 如为真值 (默认值为 <code>False</code>)，则对字段赋值将会产生异常。 这模拟了只读的冻结实例。 如果在类中定义了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__setattr__" target="_blank" rel="noopener"><code>__setattr__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__delattr__" target="_blank" rel="noopener"><code>__delattr__()</code></a> 则将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 参见下文的讨论。 </p>
</li>
</ul>
<p><code>field</code>s 可以选择使用普通的 Python 语法指定默认值: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    a: int       <span class="comment"># 'a' has no default value</span></span><br><span class="line">    b: int = <span class="number">0</span>   <span class="comment"># assign a default value for 'b'</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中， <code>a</code> 和 <code>b</code> 都将包含在添加的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法中，它们将被定义为: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a: int, b: int = <span class="number">0</span>)</span>:</span></span><br></pre></td></tr></table></figure>
<p>如果没有默认值的字段跟在具有默认值的字段后，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 。当这发生在单个类中时，或者作为类继承的结果时，都是如此。 </p>
</li>
<li><p><code>dataclasses.field</code>(<em>**, </em>default=MISSING<em>, </em>default_factory=MISSING<em>, </em>repr=True<em>, </em>hash=None<em>, </em>init=True<em>, </em>compare=True<em>, </em>metadata=None*) </p>
<p>对于常见和简单的用例，不需要其他功能。但是，有些数据类功能需要额外的每字段信息。为了满足这种对附加信息的需求，你可以通过调用提供的 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.field" target="_blank" rel="noopener"><code>field()</code></a> 函数来替换默认字段值。例如: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    mylist: List[int] = field(default_factory=list)</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.mylist += [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>如上所示， <code>MISSING</code> 值是一个 sentinel 对象，用于检测是否提供了 <code>default</code> 和 <code>default_factory</code> 参数。 使用此 sentinel 是因为 <code>None</code> 是 <code>default</code> 的有效值。没有代码应该直接使用 <code>MISSING</code> 值。 </p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.field" target="_blank" rel="noopener"><code>field()</code></a> 参数有： </p>
<ul>
<li><p><code>default</code> ：如果提供，这将是该字段的默认值。这是必需的，因为 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.field" target="_blank" rel="noopener"><code>field()</code></a> 调用本身会替换一般的默认值。 </p>
</li>
<li><p><code>default_factory</code> ：如果提供，它必须是一个零参数可调用对象，当该字段需要一个默认值时，它将被调用。除了其他目的之外，这可以用于指定具有可变默认值的字段，如下所述。 同时指定 <code>default</code> 和 <code>default_factory</code> 将产生错误。</p>
</li>
<li><p><code>init</code> ：如果为true（默认值），则该字段作为参数包含在生成的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法中。</p>
</li>
<li><p><code>repr</code> ：如果为true（默认值），则该字段包含在生成的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> 方法返回的字符串中。</p>
</li>
<li><p><code>compare</code> ：如果为true（默认值），则该字段包含在生成的相等性和比较方法中（ <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__gt__" target="_blank" rel="noopener"><code>__gt__()</code></a> 等等）。</p>
</li>
<li><p><code>hash</code> ：这可以是布尔值或 <code>None</code> 。如果为true，则此字段包含在生成的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法中。如果为 <code>None</code> （默认值），请使用 <code>compare</code> 的值，这通常是预期的行为。如果字段用于比较，则应在 hash 中考虑该字段。不鼓励将此值设置为 <code>None</code> 以外的任何值。</p>
<p>设置 <code>hash=False</code> 但 <code>compare=True</code> 的一个可能原因是，如果一个计算 hash 的代价很高的字段是检验等价性需要的，但还有其他字段可以计算类型的 hash 。 即使从 hash 中排除某个字段，它仍将用于比较。</p>
</li>
<li><p><code>metadata</code> ：这可以是映射或 None 。 None 被视为一个空的字典。这个值包含在 <code>MappingProxyType()</code> 中，使其成为只读，并暴露在 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.Field" target="_blank" rel="noopener"><code>Field</code></a> 对象上。数据类根本不使用它，它是作为第三方扩展机制提供的。多个第三方可以各自拥有自己的键值，以用作元数据中的命名空间。</p>
</li>
</ul>
<p>如果通过调用 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.field" target="_blank" rel="noopener"><code>field()</code></a> 指定字段的默认值，则该字段的类属性将替换为指定的 <code>default</code> 值。如果没有提供 <code>default</code> ，那么将删除类属性。目的是在 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 装饰器运行之后，类属性将包含字段的默认值，就像指定了默认值一样。例如，之后: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    x: int</span><br><span class="line">    y: int = field(repr=<span class="literal">False</span>)</span><br><span class="line">    z: int = field(repr=<span class="literal">False</span>, default=<span class="number">10</span>)</span><br><span class="line">    t: int = <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>类属性 <code>C.z</code> 将是 <code>10</code> ，类属性 <code>C.t</code> 将是 <code>20</code>，类属性 <code>C.x</code> 和 <code>C.y</code> 将不设置。 </p>
</li>
<li><p><em>class</em> <code>dataclasses.Field</code> </p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.Field" target="_blank" rel="noopener"><code>Field</code></a> 对象描述每个定义的字段。这些对象在内部创建，并由 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.fields" target="_blank" rel="noopener"><code>fields()</code></a> 模块级方法返回（见下文）。用户永远不应该直接实例化 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.Field" target="_blank" rel="noopener"><code>Field</code></a> 对象。 其有文档的属性是： </p>
<ul>
<li><code>name</code> ：字段的名字。</li>
<li><code>type</code> ：字段的类型。</li>
<li><code>default</code> 、 <code>default_factory</code> 、 <code>init</code> 、 <code>repr</code> 、 <code>hash</code> 、 <code>compare</code> 以及 <code>metadata</code> 与具有和 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.field" target="_blank" rel="noopener"><code>field()</code></a> 声明中相同的意义和值。</li>
</ul>
<p>可能存在其他属性，但它们是私有的，不能被审查或依赖。 </p>
</li>
<li><p><code>dataclasses.fields</code>(<em>class_or_instance</em>) </p>
<p>返回 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.Field" target="_blank" rel="noopener"><code>Field</code></a> 对象的元组，用于定义此数据类的字段。 接受数据类或数据类的实例。如果没有传递一个数据类或实例将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 。 不返回 <code>ClassVar</code> 或 <code>InitVar</code> 的伪字段。 </p>
</li>
<li><p><code>dataclasses.asdict</code>(<em>instance</em>, <em>**, </em>dict_factory=dict*) </p>
<p>将数据类 <code>instance</code> 转换为字典（使用工厂函数 <code>dict_factory</code> ）。每个数据类都转换为其字段的字典，如 <code>name: value</code> 对。数据类、字典、列表和元组被递归。例如: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">     x: int</span><br><span class="line">     y: int</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">     mylist: List[Point]</span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">assert</span> asdict(p) == &#123;<span class="string">'x'</span>: <span class="number">10</span>, <span class="string">'y'</span>: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">c = C([Point(<span class="number">0</span>, <span class="number">0</span>), Point(<span class="number">10</span>, <span class="number">4</span>)])</span><br><span class="line"><span class="keyword">assert</span> asdict(c) == &#123;<span class="string">'mylist'</span>: [&#123;<span class="string">'x'</span>: <span class="number">0</span>, <span class="string">'y'</span>: <span class="number">0</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">10</span>, <span class="string">'y'</span>: <span class="number">4</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>
<p>引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 如果 <code>instance</code> 不是数据类实例。 </p>
</li>
<li><p><code>dataclasses.astuple</code>(<em>instance</em>, <em>**, </em>tuple_factory=tuple*) </p>
<p>将数据类 <code>instance</code> 转换为元组（通过使用工厂函数 <code>tuple_factory</code> ）。每个数据类都转换为其字段值的元组。数据类、字典、列表和元组被递归。</p>
<p>继续前一个例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> astuple(p) == (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">assert</span> astuple(c) == ([(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">10</span>, <span class="number">4</span>)],)</span><br></pre></td></tr></table></figure>
<p>引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 如果 <code>instance</code> 不是数据类实例。 </p>
</li>
<li><p><code>dataclasses.make_dataclass</code>(<em>cls_name</em>, <em>fields</em>, <em>**, </em>bases=()<em>, </em>namespace=None<em>, </em>init=True<em>, </em>repr=True<em>, </em>eq=True<em>, </em>order=False<em>, </em>unsafe_hash=False<em>, </em>frozen=False*) </p>
<p>创建一个名为 <code>cls_name</code> 的新数据类，字段为 <code>fields</code> 中定义的字段，基类为 <code>bases</code> 中给出的基类，并使用 <code>namespace</code> 中给出的命名空间进行初始化。 <code>fields</code> 是一个可迭代的元素，每个元素都是 <code>name</code> 、 <code>(name, type)</code> 或 <code>(name, type, Field)</code> 。 如果只提供name ， <code>type</code> 为 <code>typing.Any</code> 。 <code>init</code> 、 <code>repr</code> 、 <code>eq</code> 、 <code>order</code> 、 <code>unsafe_hash</code> 和 <code>frozen</code> 的值与它们在 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 中的含义相同。</p>
<p>此函数不是严格要求的，因为用于任何创建带有 <code>__annotations__</code> 的新类的 Python 机制都可以应用 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 函数将该类转换为数据类。提供此功能是为了方便。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C = make_dataclass(<span class="string">'C'</span>,</span><br><span class="line">                   [(<span class="string">'x'</span>, int),</span><br><span class="line">                     <span class="string">'y'</span>,</span><br><span class="line">                    (<span class="string">'z'</span>, int, field(default=<span class="number">5</span>))],</span><br><span class="line">                   namespace=&#123;<span class="string">'add_one'</span>: <span class="keyword">lambda</span> self: self.x + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>等价于 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    x: int</span><br><span class="line">    y: <span class="string">'typing.Any'</span></span><br><span class="line">    z: int = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x + <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>dataclasses.replace</code>(<em>instance</em>, <em>**changes</em>) </p>
<p>创建一个 <code>instance</code> 相同类型的新对象，用 <code>changes</code> 中的值替换字段。如果 <code>instance</code> 不是数据类，则引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 。如果 <code>changes</code> 中的值没有指定字段，则引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 。</p>
<p>新返回的对象通过调用数据类的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法创建。这确保了如果存在 <code>__post_init__()</code> ，其也被调用。</p>
<p>如果存在没有默认值的仅初始化变量，必须在调用 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.replace" target="_blank" rel="noopener"><code>replace()</code></a> 时指定，以便它们可以传递给 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 和 <code>__post_init__()</code> 。</p>
<p><code>changes</code> 包含任何定义为 <code>init=False</code> 的字段是错误的。在这种情况下会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 。</p>
<p>提前提醒 <code>init=False</code> 字段在调用 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.replace" target="_blank" rel="noopener"><code>replace()</code></a> 时的工作方式。如果它们完全被初始化的话，它们不是从源对象复制的，而是在 <code>__post_init__()</code> 中初始化。估计 <code>init=False</code> 字段很少能被正确地使用。如果使用它们，那么使用备用类构造函数或者可能是处理实例复制的自定义 <code>replace()</code> （或类似命名的）方法可能是明智的。</p>
</li>
<li><p><code>dataclasses.is_dataclass</code>(<em>class_or_instance</em>) </p>
<p>如果其形参为 dataclass 或其实例则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>如果你需要知道一个类是否是一个数据类的实例（而不是一个数据类本身），那么再添加一个 <code>not isinstance(obj, type)</code> 检查:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_dataclass_instance</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> is_dataclass(obj) <span class="keyword">and</span> <span class="keyword">not</span> isinstance(obj, type)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="初始化后处理"><a href="#初始化后处理" class="headerlink" title="初始化后处理"></a>初始化后处理</h2><p>生成的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 代码将调用一个名为 <code>__post_init__()</code> 的方法，如果在类上已经定义了 <code>__post_init__()</code> 。它通常被称为 <code>self.__post_init__()</code> 。但是，如果定义了任何 <code>InitVar</code> 字段，它们也将按照它们在类中定义的顺序传递给 <code>__post_init__()</code> 。 如果没有 <code>__ init__()</code> 方法生成，那么 <code>__post_init__()</code> 将不会被自动调用。</p>
<p>在其他用途中，这允许初始化依赖于一个或多个其他字段的字段值。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    a: float</span><br><span class="line">    b: float</span><br><span class="line">    c: float = field(init=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__post_init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.c = self.a + self.b</span><br></pre></td></tr></table></figure>
<p> 有关将参数传递给 <code>__post_init__()</code> 的方法，请参阅下面有关仅初始化变量的段落。另请参阅关于 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.replace" target="_blank" rel="noopener"><code>replace()</code></a> 处理 <code>init=False</code> 字段的警告。 </p>
<h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><p> 两个地方 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 实际检查字段类型的之一是确定字段是否是如 <a href="https://www.python.org/dev/peps/pep-0526" target="_blank" rel="noopener"><strong>PEP 526</strong></a> 所定义的类变量。它通过检查字段的类型是否为 <code>typing.ClassVar</code> 来完成此操作。如果一个字段是一个 <code>ClassVar</code> ，它将被排除在考虑范围之外，并被数据类机制忽略。这样的 <code>ClassVar</code> 伪字段不会由模块级的 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.fields" target="_blank" rel="noopener"><code>fields()</code></a> 函数返回。 </p>
<h2 id="仅初始化变量"><a href="#仅初始化变量" class="headerlink" title="仅初始化变量"></a>仅初始化变量</h2><p>另一个 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 检查类型注解地方是为了确定一个字段是否是一个仅初始化变量。它通过查看字段的类型是否为 <code>dataclasses.InitVar</code> 类型来实现。如果一个字段是一个 <code>InitVar</code> ，它被认为是一个称为仅初始化字段的伪字段。因为它不是一个真正的字段，所以它不会被模块级的 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.fields" target="_blank" rel="noopener"><code>fields()</code></a> 函数返回。仅初始化字段作为参数添加到生成的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法中，并传递给可选的 <code>__post_init__()</code> 方法。数据类不会使用它们。</p>
<p>例如，假设一个字段将从数据库初始化，如果在创建类时未提供其值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    i: int</span><br><span class="line">    j: int = <span class="literal">None</span></span><br><span class="line">    database: InitVar[DatabaseType] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__post_init__</span><span class="params">(self, database)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.j <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> database <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.j = database.lookup(<span class="string">'j'</span>)</span><br><span class="line"></span><br><span class="line">c = C(<span class="number">10</span>, database=my_database)</span><br></pre></td></tr></table></figure>
<p> 在这种情况下， <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.fields" target="_blank" rel="noopener"><code>fields()</code></a> 将返回 <code>i</code> 和 <code>j</code> 的 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.Field" target="_blank" rel="noopener"><code>Field</code></a> 对象，但不包括 <code>database</code>  。</p>
<h2 id="冻结的实例"><a href="#冻结的实例" class="headerlink" title="冻结的实例"></a>冻结的实例</h2><p>无法创建真正不可变的 Python 对象。但是，通过将 <code>frozen=True</code> 传递给 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 装饰器，你可以模拟不变性。在这种情况下，数据类将向类添加 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__setattr__" target="_blank" rel="noopener"><code>__setattr__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__delattr__" target="_blank" rel="noopener"><code>__delattr__()</code></a> 方法。 些方法在调用时会引发 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.FrozenInstanceError" target="_blank" rel="noopener"><code>FrozenInstanceError</code></a> 。</p>
<p>使用 <code>frozen=True</code> 时会有很小的性能损失： <code>__ init__()</code> 不能使用简单的赋值来初始化字段，并必须使用 <code>object.__ setattr__()</code> 。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p> 当数组由 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 装饰器创建时，它会查看反向 MRO 中的所有类的基类（即从 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 开始 ），并且对于它找到的每个数据类， 将该基类中的字段添加到字段的有序映射中。添加完所有基类字段后，它会将自己的字段添加到有序映射中。所有生成的方法都将使用这种组合的，计算的有序字段映射。由于字段是按插入顺序排列的，因此派生类会重载基类。一个例子: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@dataclass</span><br><span class="line">class Base:</span><br><span class="line">    x: Any = 15.0</span><br><span class="line">    y: int = 0</span><br><span class="line"></span><br><span class="line">@dataclass</span><br><span class="line">class C(Base):</span><br><span class="line">    z: int = 10</span><br><span class="line">    x: int = 15</span><br></pre></td></tr></table></figure>
<p>最后的字段列表依次是 <code>x</code> 、 <code>y</code> 、 <code>z</code> 。 <code>x</code> 的最终类型是 <code>int</code> ，如类 <code>C</code> 中所指定的那样。</p>
<p>为 <code>C</code> 生成的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法看起来像:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x: int = <span class="number">15</span>, y: int = <span class="number">0</span>, z: int = <span class="number">10</span>)</span>:</span></span><br></pre></td></tr></table></figure>
<h2 id="默认工厂函数"><a href="#默认工厂函数" class="headerlink" title="默认工厂函数"></a>默认工厂函数</h2><p> 如果一个 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.field" target="_blank" rel="noopener"><code>field()</code></a> 指定了一个 <code>default_factory</code> ，当需要该字段的默认值时，将使用零参数调用它。例如，要创建列表的新实例，请使用: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mylist: list = field(default_factory=list)</span><br></pre></td></tr></table></figure>
<p> 如果一个字段被排除在 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 之外（使用 <code>init=False</code> ）并且字段也指定 <code>default_factory</code> ，则默认的工厂函数将始终从生成的 <code>__ init__()</code> 函数调用。发生这种情况是因为没有其他方法可以为字段提供初始值。 </p>
<h2 id="可变的默认值"><a href="#可变的默认值" class="headerlink" title="可变的默认值"></a>可变的默认值</h2><p> Python 在类属性中存储默认成员变量值。思考这个例子，不使用数据类: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    x = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, element)</span>:</span></span><br><span class="line">        self.x.append(element)</span><br><span class="line"></span><br><span class="line">o1 = C()</span><br><span class="line">o2 = C()</span><br><span class="line">o1.add(<span class="number">1</span>)</span><br><span class="line">o2.add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">assert</span> o1.x == [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">assert</span> o1.x <span class="keyword">is</span> o2.x</span><br></pre></td></tr></table></figure>
<p>请注意，类 <code>C</code> 的两个实例共享相同的类变量 <code>x</code> ，如预期的那样。</p>
<p>使用数据类， <em>如果</em> 此代码有效:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span></span><br><span class="line">    x: List = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, element)</span>:</span></span><br><span class="line">        self.x += element</span><br></pre></td></tr></table></figure>
<p> 它生成的代码类似于: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span></span><br><span class="line">    x = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=x)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, element)</span>:</span></span><br><span class="line">        self.x += element</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> D().x <span class="keyword">is</span> D().x</span><br></pre></td></tr></table></figure>
<p>这与使用类 <code>C</code> 的原始示例具有相同的问题。也就是说，在创建类实例时没有为 <code>x</code> 指定值的类 <code>D</code> 的两个实例将共享相同的 <code>x</code> 副本。由于数据类只使用普通的 Python 类创建，因此它们也会共享此行为。数据类没有通用的方法来检测这种情况。相反，如果数据类检测到类型为 <code>list</code> 、 <code>dict</code> 或 <code>set</code> 的默认参数，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 。这是一个部分解决方案，但它可以防止许多常见错误。</p>
<p>使用默认工厂函数是一种创建可变类型新实例的方法，并将其作为字段的默认值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span></span><br><span class="line">    x: list = field(default_factory=list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> D().x <span class="keyword">is</span> <span class="keyword">not</span> D().x</span><br></pre></td></tr></table></figure>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li><p><em>exception</em> <code>dataclasses.FrozenInstanceError</code> </p>
<p>在使用 <code>frozen=True</code> 定义的数据类上调用隐式定义的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__setattr__" target="_blank" rel="noopener"><code>__setattr__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__delattr__" target="_blank" rel="noopener"><code>__delattr__()</code></a> 时引发。 </p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们经常会遇到这样的情况:</p>
<p>比如我们设计一个商品类:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id=None, author_id=None, category_id=None, brand_id=None, spu_id=None, </span></span></span><br><span class="line"><span class="function"><span class="params">                 title=None, item_id=None, n_comments=None, creation_time=None, update_time=None, </span></span></span><br><span class="line"><span class="function"><span class="params">                 source=<span class="string">''</span>, parent_id=<span class="number">0</span>, ancestor_id=<span class="number">0</span>)</span>:</span> </span><br><span class="line">        self.id = id</span><br><span class="line">        self.author_id = author_id</span><br><span class="line">        self.category_id = category_id</span><br><span class="line">        self.brand_id = brand_id</span><br><span class="line">        self.spu_id = spu_id</span><br><span class="line">        self.title = title</span><br><span class="line">        self.item_id = item_id</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p><code>__init__</code>方法包含了众多参数,</p>
<h3 id="应用一"><a href="#应用一" class="headerlink" title="应用一"></a>应用一</h3><p><strong>我们在打印的时候不希望打印所有的参数</strong></p>
<p>通常的做法是,重写<code>__repr__</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(id=&#123;&#125;, author_id=&#123;&#125;, category_id=&#123;&#125;, brand_id=&#123;&#125;)'</span>.format(</span><br><span class="line">        self.__class__.__name__, self.id, self.author_id, self.category_id, </span><br><span class="line">        self.brand_id)</span><br><span class="line"><span class="comment">#对象打印</span></span><br><span class="line">p = Product()</span><br><span class="line">print(p)   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Product(id=<span class="number">1</span>, author_id=<span class="number">100001</span>, category_id=<span class="number">2003</span>, brand_id=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>问题来了,我需要在每个类里重写这个方法,那该怎么处理？</p>
<h3 id="应用二"><a href="#应用二" class="headerlink" title="应用二"></a>应用二</h3><p> <strong>对象比较</strong>，有时候需要判断2个对象是否相等甚至大小（例如用于展示顺序） </p>
<p>通常的做法是 重写对应的<code>__eq__</code>,<code>__lt__</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(other, self.__class__):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    <span class="keyword">return</span> (self.id, self.author_id, self.category_id, self.brand_id) == (</span><br><span class="line">        other.id, other.author_id, other.category_id, other.brand_id)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(other, self.__class__):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    <span class="keyword">return</span> (self.id, self.author_id, self.category_id, self.brand_id) &lt; (</span><br><span class="line">        other.id, other.author_id, other.category_id, other.brand_id)</span><br></pre></td></tr></table></figure>
<h3 id="应用三"><a href="#应用三" class="headerlink" title="应用三"></a>应用三</h3><p><strong>对象去重</strong>,重写<code>__hash__</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hash((self.id, self.author_id, self.category_id, self.brand_id))</span><br></pre></td></tr></table></figure>
<h3 id="应用四"><a href="#应用四" class="headerlink" title="应用四"></a>应用四</h3><p><strong>导出字典格式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'id'</span>: self.id,</span><br><span class="line">        <span class="string">'author_id'</span>: self.author_id,</span><br><span class="line">        <span class="string">'category_id'</span>: self.category_id,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>但是我并不想打印所有的属性,于是有下面的做法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> vars(self)</span><br></pre></td></tr></table></figure>
<p>等等,python难道没有解决方案。</p>
<p>答案是肯定的,当然有,那就是<code>dataclasses</code></p>
<h3 id="用dataclasses解决上面的问题"><a href="#用dataclasses解决上面的问题" class="headerlink" title="用dataclasses解决上面的问题"></a>用<code>dataclasses</code>解决上面的问题</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass(unsafe_hash=True, order=True)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(object)</span>:</span></span><br><span class="line">    id: int</span><br><span class="line">    author_id: int</span><br><span class="line">    brand_id: int</span><br><span class="line">    spu_id: int</span><br><span class="line">    title: str = field(hash=<span class="literal">False</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>)</span><br><span class="line">    item_id: int = field(hash=<span class="literal">False</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>)</span><br><span class="line">    n_comments: int = field(hash=<span class="literal">False</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>)</span><br><span class="line">    creation_time: datetime = field(default=<span class="literal">None</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>,hash=<span class="literal">False</span>)</span><br><span class="line">    update_time: datetime = field(default=<span class="literal">None</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>, hash=<span class="literal">False</span>)</span><br><span class="line">    source: str = field(default=<span class="string">''</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>, hash=<span class="literal">False</span>)</span><br><span class="line">    parent_id: int = field(default=<span class="number">0</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>, hash=<span class="literal">False</span>)</span><br><span class="line">    ancestor_id: int = field(default=<span class="number">0</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>, hash=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Product(<span class="number">1</span>, <span class="number">100001</span>, <span class="number">2003</span>, <span class="number">20</span>, <span class="number">1002393002</span>, <span class="string">'这是一个测试商品1'</span>, <span class="number">2000001</span>, <span class="number">100</span>, <span class="literal">None</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p2 = Product(<span class="number">1</span>, <span class="number">100001</span>, <span class="number">2003</span>, <span class="number">20</span>, <span class="number">1002393002</span>, <span class="string">'这是一个测试商品2'</span>, <span class="number">2000001</span>, <span class="number">100</span>, <span class="literal">None</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p3 = Product(<span class="number">3</span>, <span class="number">100001</span>, <span class="number">2003</span>, <span class="number">20</span>, <span class="number">1002393002</span>, <span class="string">'这是一个测试商品3'</span>, <span class="number">2000001</span>, <span class="number">100</span>, <span class="literal">None</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">print(p1)</span><br><span class="line"></span><br><span class="line">print(p1 == p2)</span><br><span class="line"></span><br><span class="line">print(p1 &gt; p2)</span><br><span class="line"></span><br><span class="line">print(&#123;p1, p2, p3&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> asdict</span><br><span class="line">asdict(p1)</span><br></pre></td></tr></table></figure>
<p>想了解更多的使用方法,强烈建议阅读源码。</p>
<p>最后,希望武汉的兄弟们能保护好自己,健康才是最重要的。加油!!!</p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>dataclasses</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library html.parser</title>
    <url>/2020/01/29/python-standard-library-html-parser/</url>
    <content><![CDATA[<h1 id="python-标准库-html-parser-简单HTML和XHTML解析器"><a href="#python-标准库-html-parser-简单HTML和XHTML解析器" class="headerlink" title="python 标准库  html.parser 简单HTML和XHTML解析器"></a>python 标准库  html.parser 简单HTML和XHTML解析器</h1><p><img src="https://cn.bing.com/th?id=OIP.cq-61gMRe77h_MW4ca_0egHaFj&amp;pid=Api&amp;rs=1" alt></p>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=595024&auto=0&height=66"></iframe>

<h2 id="源代码：-Lib-html-parser-py"><a href="#源代码：-Lib-html-parser-py" class="headerlink" title="源代码： Lib/html/parser.py"></a><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/html/parser.py" target="_blank" rel="noopener">Lib/html/parser.py</a></h2><p>这个模块定义了一个 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser" target="_blank" rel="noopener"><code>HTMLParser</code></a> 类，为 HTML（超文本标记语言）和 XHTML 文本文件解析提供基础。</p>
<ul>
<li><p><em>class</em> <code>html.parser.HTMLParser</code>(<em>**, </em>convert_charrefs=True*)</p>
<p>创建一个能解析无效标记的解析器实例。如果 <em>convert_charrefs</em> 为 <code>True</code> (默认值)，则所有字符引用( <code>script</code>/<code>style</code> 元素中的除外)都会自动转换为相应的 Unicode 字符。一个 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser" target="_blank" rel="noopener"><code>HTMLParser</code></a> 类的实例用来接受 HTML 数据，并在标记开始、标记结束、文本、注释和其他元素标记出现的时候调用对应的方法。要实现具体的行为，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser" target="_blank" rel="noopener"><code>HTMLParser</code></a> 的子类并重载其方法。这个解析器不检查结束标记是否与开始标记匹配，也不会因外层元素完毕而隐式关闭了的元素引发结束标记处理。</p>
</li>
</ul>
<h2 id="HTML-解析器的示例程序"><a href="#HTML-解析器的示例程序" class="headerlink" title="HTML 解析器的示例程序"></a>HTML 解析器的示例程序</h2><p>下面是简单的 HTML 解析器的一个基本示例，使用 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser" target="_blank" rel="noopener"><code>HTMLParser</code></a> 类，当遇到开始标记、结束标记以及数据的时候将内容打印出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> html.parser <span class="keyword">import</span> HTMLParser</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHTMLParser</span><span class="params">(HTMLParser)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_starttag</span><span class="params">(self, tag, attrs)</span>:</span></span><br><span class="line">        print(<span class="string">"Encountered a start tag:"</span>, tag)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_endtag</span><span class="params">(self, tag)</span>:</span></span><br><span class="line">        print(<span class="string">"Encountered an end tag :"</span>, tag)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        print(<span class="string">"Encountered some data  :"</span>, data)</span><br><span class="line"></span><br><span class="line">parser = MyHTMLParser()</span><br><span class="line">parser.feed(<span class="string">'&lt;html&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;'</span></span><br><span class="line">            <span class="string">'&lt;body&gt;&lt;h1&gt;Parse me!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'</span>)</span><br></pre></td></tr></table></figure>
<p> 输出是: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Encountered a start tag: html</span><br><span class="line">Encountered a start tag: head</span><br><span class="line">Encountered a start tag: title</span><br><span class="line">Encountered some data  : Test</span><br><span class="line">Encountered an end tag : title</span><br><span class="line">Encountered an end tag : head</span><br><span class="line">Encountered a start tag: body</span><br><span class="line">Encountered a start tag: h1</span><br><span class="line">Encountered some data  : Parse me!</span><br><span class="line">Encountered an end tag : h1</span><br><span class="line">Encountered an end tag : body</span><br><span class="line">Encountered an end tag : html</span><br></pre></td></tr></table></figure>
<h2 id="HTMLParser-方法"><a href="#HTMLParser-方法" class="headerlink" title="HTMLParser 方法"></a><code>HTMLParser</code> 方法</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser" target="_blank" rel="noopener"><code>HTMLParser</code></a> 实例有下列方法：</p>
<ul>
<li><p><code>HTMLParser.feed</code>(<em>data</em>)</p>
<p>填充一些文本到解析器中。如果包含完整的元素，则被处理；如果数据不完整，将被缓冲直到更多的数据被填充，或者 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.close" target="_blank" rel="noopener"><code>close()</code></a> 被调用。<em>data</em> 必须为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 类型。</p>
</li>
<li><p><code>HTMLParser.close</code>()</p>
<p>如同后面跟着一个文件结束标记一样，强制处理所有缓冲数据。这个方法能被派生类重新定义，用于在输入的末尾定义附加处理，但是重定义的版本应当始终调用基类 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser" target="_blank" rel="noopener"><code>HTMLParser</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.close" target="_blank" rel="noopener"><code>close()</code></a> 方法。</p>
</li>
<li><p><code>HTMLParser.reset</code>()</p>
<p>重置实例。丢失所有未处理的数据。在实例化阶段被隐式调用。</p>
</li>
<li><p><code>HTMLParser.getpos</code>()</p>
<p>返回当前行号和偏移值。</p>
</li>
<li><p><code>HTMLParser.get_starttag_text</code>()</p>
<p>返回最近打开的开始标记中的文本。 结构化处理时通常应该不需要这个，但在处理“已部署”的 HTML 或是在以最小改变来重新生成输入时可能会有用处（例如可以保留属性间的空格等）。</p>
</li>
</ul>
<p>下列方法将在遇到数据或者标记元素的时候被调用。他们需要在子类中重载。基类的实现中没有任何实际操作（除了 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.handle_startendtag" target="_blank" rel="noopener"><code>handle_startendtag()</code></a> ）：</p>
<ul>
<li><p><code>HTMLParser.handle_starttag</code>(<em>tag</em>, <em>attrs</em>)</p>
<p>这个方法在标签开始的时候被调用（例如：  ）。<em>tag</em> 参数是小写的标记名。<em>attrs</em> 参数是一个 <code>(name, value)</code> 形式的列表，包含了所有在标记的 <code>&lt;&gt;</code> 括号中找到的属性。<em>name</em> 转换为小写，<em>value</em> 的引号被去除，字符和实体引用都会被替换。实例中，对于标签 ，这个方法将以下列形式被调用 <code>handle_starttag(&#39;a&#39;, [(&#39;href&#39;, &#39;https://www.cwi.nl/&#39;)])</code> 。<a href="https://docs.python.org/zh-cn/3.8/library/html.entities.html#module-html.entities" target="_blank" rel="noopener"><code>html.entities</code></a> 中的所有实体引用，会被替换为属性值。</p>
</li>
<li><p><code>HTMLParser.handle_endtag</code>(<em>tag</em>)</p>
<p>此方法被用来处理元素的结束标记（例如：  ）。<em>tag</em> 参数是小写的标签名。</p>
</li>
<li><p><code>HTMLParser.handle_startendtag</code>(<em>tag</em>, <em>attrs</em>)</p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.handle_starttag" target="_blank" rel="noopener"><code>handle_starttag()</code></a>, 只是在解析器遇到 XHTML 样式的空标记时被调用（ ）。这个方法能被需要这种特殊词法信息的子类重载；默认实现仅简单调用 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.handle_starttag" target="_blank" rel="noopener"><code>handle_starttag()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.handle_endtag" target="_blank" rel="noopener"><code>handle_endtag()</code></a> 。</p>
</li>
<li><p><code>HTMLParser.handle_data</code>(<em>data</em>)</p>
<p>这个方法被用来处理任意数据（例如：文本节点和 <code>...</code> 以及 <code>...</code> 中的内容）。</p>
</li>
<li><p><code>HTMLParser.handle_entityref</code>(<em>name</em>)</p>
<p>这个方法被用于处理 <code>&amp;name;</code> 形式的命名字符引用（例如 <code>&gt;</code>），其中 <em>name</em> 是通用的实体引用（例如： <code>&#39;gt&#39;</code>）。如果 <em>convert_charrefs</em> 为 <code>True</code>，该方法永远不会被调用。</p>
</li>
<li><p><code>HTMLParser.handle_charref</code>(<em>name</em>)</p>
<p>这个方法被用来处理 <code>&amp;#NNN;</code> 和 <code>&amp;#xNNN;</code> 形式的十进制和十六进制字符引用。例如，<code>&gt;</code> 等效的十进制形式为 <code>&gt;</code> ，而十六进制形式为 <code>&gt;</code> ；在这种情况下，方法将收到 <code>&#39;62&#39;</code> 或 <code>&#39;x3E&#39;</code> 。如果 <em>convert_charrefs</em> 为 <code>True</code> ，则该方法永远不会被调用。</p>
</li>
<li><p><code>HTMLParser.handle_comment</code>(<em>data</em>)</p>
<p>这个方法在遇到注释的时候被调用（例如：  ）。例如，  这个注释会用 <code>&#39; comment &#39;</code> 作为参数调用此方法。Internet Explorer 条件注释（condcoms）的内容也被发送到这个方法，因此，对于  ，这个方法将接收到 `’[if IE 9]&gt;IE9-specific content 。</p>
</li>
<li><p><code>HTMLParser.handle_decl</code>(<em>decl</em>)</p>
<p>这个方法用来处理 HTML doctype 申明（例如  ）。<em>decl</em> 形参为  标记中的所有内容（例如： <code>&#39;DOCTYPE html&#39;</code> ）。</p>
</li>
<li><p><code>HTMLParser.handle_pi</code>(<em>data</em>)</p>
<p>此方法在遇到处理指令的时候被调用。<em>data</em> 形参将包含整个处理指令。例如，对于处理指令  ，这个方法将以 <code>handle_pi(&quot;proc color=&#39;red&#39;&quot;)</code> 形式被调用。它旨在被派生类重载；基类实现中无任何实际操作。注解 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser" target="_blank" rel="noopener"><code>HTMLParser</code></a> 类使用 SGML 语法规则处理指令。使用 <code>&#39;?&#39;</code> 结尾的 XHTML 处理指令将导致 <code>&#39;?&#39;</code> 包含在 <em>data</em> 中。</p>
</li>
<li><p><code>HTMLParser.unknown_decl</code>(<em>data</em>)</p>
<p>当解析器读到无法识别的声明时，此方法被调用。<em>data</em> 形参为  标记中的所有内容。某些时候对派生类的重载很有用。基类实现中无任何实际操作。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面的类实现了一个解析器，用于更多示例的演示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> html.parser <span class="keyword">import</span> HTMLParser</span><br><span class="line"><span class="keyword">from</span> html.entities <span class="keyword">import</span> name2codepoint</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHTMLParser</span><span class="params">(HTMLParser)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_starttag</span><span class="params">(self, tag, attrs)</span>:</span></span><br><span class="line">        print(<span class="string">"Start tag:"</span>, tag)</span><br><span class="line">        <span class="keyword">for</span> attr <span class="keyword">in</span> attrs:</span><br><span class="line">            print(<span class="string">"     attr:"</span>, attr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_endtag</span><span class="params">(self, tag)</span>:</span></span><br><span class="line">        print(<span class="string">"End tag  :"</span>, tag)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        print(<span class="string">"Data     :"</span>, data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_comment</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        print(<span class="string">"Comment  :"</span>, data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_entityref</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        c = chr(name2codepoint[name])</span><br><span class="line">        print(<span class="string">"Named ent:"</span>, c)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_charref</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'x'</span>):</span><br><span class="line">            c = chr(int(name[<span class="number">1</span>:], <span class="number">16</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c = chr(int(name))</span><br><span class="line">        print(<span class="string">"Num ent  :"</span>, c)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_decl</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        print(<span class="string">"Decl     :"</span>, data)</span><br><span class="line"></span><br><span class="line">parser = MyHTMLParser()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>解析一个文档类型声明:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" '</span></span><br><span class="line"><span class="meta">... </span>            <span class="string">'"http://www.w3.org/TR/html4/strict.dtd"&gt;'</span>)</span><br><span class="line">Decl     : DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01//EN"</span> <span class="string">"http://www.w3.org/TR/html4/strict.dtd"</span></span><br></pre></td></tr></table></figure>
<p>解析一个具有一些属性和标题的元素:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;img src="python-logo.png" alt="The Python logo"&gt;'</span>)</span><br><span class="line">Start tag: img</span><br><span class="line">     attr: (<span class="string">'src'</span>, <span class="string">'python-logo.png'</span>)</span><br><span class="line">     attr: (<span class="string">'alt'</span>, <span class="string">'The Python logo'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;h1&gt;Python&lt;/h1&gt;'</span>)</span><br><span class="line">Start tag: h1</span><br><span class="line">Data     : Python</span><br><span class="line">End tag  : h1</span><br></pre></td></tr></table></figure>
<p><code>script</code> 和 <code>style</code> 元素中的内容原样返回，无需进一步解析:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;style type="text/css"&gt;#python &#123; color: green &#125;&lt;/style&gt;'</span>)</span><br><span class="line">Start tag: style</span><br><span class="line">     attr: (<span class="string">'type'</span>, <span class="string">'text/css'</span>)</span><br><span class="line">Data     : <span class="comment">#python &#123; color: green &#125;</span></span><br><span class="line">End tag  : style</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;script type="text/javascript"&gt;'</span></span><br><span class="line"><span class="meta">... </span>            <span class="string">'alert("&lt;strong&gt;hello!&lt;/strong&gt;");&lt;/script&gt;'</span>)</span><br><span class="line">Start tag: script</span><br><span class="line">     attr: (<span class="string">'type'</span>, <span class="string">'text/javascript'</span>)</span><br><span class="line">Data     : alert(<span class="string">"&lt;strong&gt;hello!&lt;/strong&gt;"</span>);</span><br><span class="line">End tag  : script</span><br></pre></td></tr></table></figure>
<p>解析注释:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;!-- a comment --&gt;'</span></span><br><span class="line"><span class="meta">... </span>            <span class="string">'&lt;!--[if IE 9]&gt;IE-specific content&lt;![endif]--&gt;'</span>)</span><br><span class="line">Comment  :  a comment</span><br><span class="line">Comment  : [<span class="keyword">if</span> IE <span class="number">9</span>]&gt;IE-specific content&lt;![endif]</span><br></pre></td></tr></table></figure>
<p>解析命名或数字形式的字符引用，并把他们转换到正确的字符（注意：这 3 种转义都是 <code>&#39;&gt;&#39;</code> ）:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&amp;gt;&amp;#62;&amp;#x3E;'</span>)</span><br><span class="line">Named ent: &gt;</span><br><span class="line">Num ent  : &gt;</span><br><span class="line">Num ent  : &gt;</span><br></pre></td></tr></table></figure>
<p>填充不完整的块给 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.feed" target="_blank" rel="noopener"><code>feed()</code></a> 执行，<a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.handle_data" target="_blank" rel="noopener"><code>handle_data()</code></a> 可能会多次调用（除非 <em>convert_charrefs</em> 被设置为 <code>True</code> ）:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> chunk <span class="keyword">in</span> [<span class="string">'&lt;sp'</span>, <span class="string">'an&gt;buff'</span>, <span class="string">'ered '</span>, <span class="string">'text&lt;/s'</span>, <span class="string">'pan&gt;'</span>]:</span><br><span class="line"><span class="meta">... </span>    parser.feed(chunk)</span><br><span class="line">...</span><br><span class="line">Start tag: span</span><br><span class="line">Data     : buff</span><br><span class="line">Data     : ered</span><br><span class="line">Data     : text</span><br><span class="line">End tag  : span</span><br></pre></td></tr></table></figure>
<p>解析无效的 HTML (例如：未引用的属性）也能正常运行:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;p&gt;&lt;a class=link href=#main&gt;tag soup&lt;/p &gt;&lt;/a&gt;'</span>)</span><br><span class="line">Start tag: p</span><br><span class="line">Start tag: a</span><br><span class="line">     attr: (<span class="string">'class'</span>, <span class="string">'link'</span>)</span><br><span class="line">     attr: (<span class="string">'href'</span>, <span class="string">'#main'</span>)</span><br><span class="line">Data     : tag soup</span><br><span class="line">End tag  : p</span><br><span class="line">End tag  : a</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>html.parser</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library enum</title>
    <url>/2020/01/28/python-standard-library-enum/</url>
    <content><![CDATA[<h1 id="python-标准库-enum-枚举类型支持"><a href="#python-标准库-enum-枚举类型支持" class="headerlink" title="python 标准库 enum 枚举类型支持"></a>python 标准库 enum 枚举类型支持</h1><p><img src="https://cn.bing.com/th?id=OIP.MVQKeBgQJ2yG2rAwEJ5unQHaEK&amp;pid=Api&amp;rs=1" alt></p>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=643982&auto=0&height=66"></iframe>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/enum.py" target="_blank" rel="noopener">Lib/enum.py</a></p>
<hr>
<p>枚举是一组符号名称（枚举成员）的集合，枚举成员应该是唯一的、不可变的。在枚举中，可以对成员进行恒等比较，并且枚举本身是可迭代的。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>此模块定义了四个枚举类，它们可被用来定义名称和值的不重复集合: <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a>。 此外还定义了一个装饰器 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.unique" target="_blank" rel="noopener"><code>unique()</code></a> 和一个辅助类 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a>。</p>
<ul>
<li><p><em>class</em> <code>enum.Enum</code></p>
<p>此基类用于创建枚举常量。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#functional-api" target="_blank" rel="noopener">Functional API</a> 小节了解另一种替代性的构建语法。</p>
</li>
<li><p><em>class</em> <code>enum.IntEnum</code></p>
<p>此基类用于创建属于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的子类的枚举常量。</p>
</li>
<li><p><em>class</em> <code>enum.IntFlag</code></p>
<p>此基类用于创建可使用按位运算符进行组合而不会丢失其 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员资格的枚举常量。 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员同样也是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的子类。</p>
</li>
<li><p><em>class</em> <code>enum.Flag</code></p>
<p>此基类用于创建枚举常量 可使用按位运算符进行组合而不会丢失其 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 成员资格的枚举常量。</p>
</li>
<li><p><code>enum.unique</code>()</p>
<p>此 Enum 类装饰器可确保只将一个名称绑定到任意一个值。</p>
</li>
<li><p><em>class</em> <code>enum.auto</code></p>
<p>实例会被替换为一个可作为 Enum 成员的适当的值。 初始值从 1 开始。</p>
</li>
</ul>
<h2 id="创建一个-Enum"><a href="#创建一个-Enum" class="headerlink" title="创建一个 Enum"></a>创建一个 Enum</h2><p> 枚举是使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#class" target="_blank" rel="noopener"><code>class</code></a> 语法来创建的，这使得它们易于读写。 另一种替代创建方法的描述见 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#functional-api" target="_blank" rel="noopener">Functional API</a>。 要定义一个枚举，可以对 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 进行如下的子类化: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    GREEN = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    BLUE = <span class="number">3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 成员值可以为任意类型: <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 等等。 如果具体的值不重要，你可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a> 实例，将为你选择适当的值。 但如果你混用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a> 与其他值则需要小心谨慎。 </p>
<p> 虽然我们使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#class" target="_blank" rel="noopener"><code>class</code></a> 语法来创建 Enum，但 Enum 并不是普通的 Python 类。 更多细节请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#how-are-enums-different" target="_blank" rel="noopener">How are Enums different</a> </p>
</blockquote>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ul>
<li>类 <code>Color</code> 是一个 <em>枚举</em> (或称 <em>enum</em>)</li>
<li>属性 <code>Color.RED</code>, <code>Color.GREEN</code> 等等是 <em>枚举成员</em> (或称 <em>enum 成员</em>) 并且被用作常量。</li>
<li><p>枚举成员具有 <em>名称</em> 和 <em>值</em> (<code>Color.RED</code> 的名称为 <code>RED</code>，<code>Color.BLUE</code> 的值为 <code>3</code> 等等。)</p>
<p>枚举成员具有适合人类阅读的表示形式: </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Color.RED)</span><br><span class="line">Color.RED</span><br></pre></td></tr></table></figure>
<p> .而它们的 <code>repr</code> 包含更多信息: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(repr(Color.RED))</span><br><span class="line">&lt;Color.RED: <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure>
<p> 一个枚举成员的 <em>type</em> 就是它所从属的枚举: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(Color.RED)</span><br><span class="line">&lt;enum <span class="string">'Color'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Color.GREEN, Color)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p> Enum 的成员还有一个包含其条目名称的特征属性: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Color.RED.name)</span><br><span class="line">RED</span><br></pre></td></tr></table></figure>
<p>枚举支持按照定义顺序进行迭代:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Shake</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    VANILLA = <span class="number">7</span></span><br><span class="line"><span class="meta">... </span>    CHOCOLATE = <span class="number">4</span></span><br><span class="line"><span class="meta">... </span>    COOKIES = <span class="number">9</span></span><br><span class="line"><span class="meta">... </span>    MINT = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> shake <span class="keyword">in</span> Shake:</span><br><span class="line"><span class="meta">... </span>    print(shake)</span><br><span class="line">...</span><br><span class="line">Shake.VANILLA</span><br><span class="line">Shake.CHOCOLATE</span><br><span class="line">Shake.COOKIES</span><br><span class="line">Shake.MINT</span><br></pre></td></tr></table></figure>
<p> 枚举成员是可哈希的，因此它们可在字典和集合中可用: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>apples = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>apples[Color.RED] = <span class="string">'red delicious'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>apples[Color.GREEN] = <span class="string">'granny smith'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>apples == &#123;Color.RED: <span class="string">'red delicious'</span>, Color.GREEN: <span class="string">'granny smith'</span>&#125;</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="对枚举成员及其属性的程序化访问"><a href="#对枚举成员及其属性的程序化访问" class="headerlink" title="对枚举成员及其属性的程序化访问"></a>对枚举成员及其属性的程序化访问</h2><p> 有时对枚举中的成员进行程序化访问是很有用的（例如在某些场合不能使用 <code>Color.RED</code> 因为在编程时并不知道要指定的确切颜色）。 <code>Enum</code> 允许这样的访问: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color(<span class="number">1</span>)</span><br><span class="line">&lt;Color.RED: <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color(<span class="number">3</span>)</span><br><span class="line">&lt;Color.BLUE: <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure>
<p> 如果你希望通过 <em>name</em> 来访问枚举成员，可使用条目访问: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color[<span class="string">'RED'</span>]</span><br><span class="line">&lt;Color.RED: <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color[<span class="string">'GREEN'</span>]</span><br><span class="line">&lt;Color.GREEN: <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>
<p> 如果你有一个枚举成员并且需要它的 <code>name</code> 或 <code>value</code>: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>member = Color.RED</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.name</span><br><span class="line"><span class="string">'RED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.value</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="复制枚举成员和值"><a href="#复制枚举成员和值" class="headerlink" title="复制枚举成员和值"></a>复制枚举成员和值</h2><p> 不允许有同名的枚举成员: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Shape</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    SQUARE = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    SQUARE = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: Attempted to reuse key: <span class="string">'SQUARE'</span></span><br></pre></td></tr></table></figure>
<p> 但是，允许两个枚举成员有相同的值。 假定两个成员 A 和 B 有相同的值（且 A 先被定义），则 B 就是 A 的一个别名。 按值查找 A 和 B 的值将返回 A。 按名称查找 B 也将返回 A: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Shape</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    SQUARE = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    DIAMOND = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    CIRCLE = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    ALIAS_FOR_SQUARE = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Shape.SQUARE</span><br><span class="line">&lt;Shape.SQUARE: <span class="number">2</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Shape.ALIAS_FOR_SQUARE</span><br><span class="line">&lt;Shape.SQUARE: <span class="number">2</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Shape(<span class="number">2</span>)</span><br><span class="line">&lt;Shape.SQUARE: <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 试图创建具有与某个已定义的属性（另一个成员或方法等）相同名称的成员或者试图创建具有相同名称的属性也是不允许的 </p>
</blockquote>
<h2 id="确保唯一的枚举值"><a href="#确保唯一的枚举值" class="headerlink" title="确保唯一的枚举值"></a>确保唯一的枚举值</h2><p> 默认情况下，枚举允许有多个名称作为某个相同值的别名。 如果不想要这样的行为，可以使用以下装饰器来确保每个值在枚举中只被使用一次: </p>
<p> <a href="mailto:`@enum.unique" target="_blank" rel="noopener">`@enum.unique</a>` </p>
<p> 专用于枚举的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#class" target="_blank" rel="noopener"><code>class</code></a> 装饰器。 它会搜索一个枚举的 <code>__members__</code> 并收集所找到的任何别名；只要找到任何别名就会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 并附带相关细节信息: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@unique</span><br><span class="line"><span class="meta">... </span><span class="class"><span class="keyword">class</span> <span class="title">Mistake</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    ONE = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    TWO = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    THREE = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    FOUR = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">ValueError: duplicate values found in &lt;enum 'Mistake'&gt;: FOUR -&gt; THREE</span><br></pre></td></tr></table></figure>
<h2 id="使用自动设定的值"><a href="#使用自动设定的值" class="headerlink" title="使用自动设定的值"></a>使用自动设定的值</h2><p> 如果确切的值不重要，你可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a>: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, auto</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = auto()</span><br><span class="line"><span class="meta">... </span>    BLUE = auto()</span><br><span class="line"><span class="meta">... </span>    GREEN = auto()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(Color)</span><br><span class="line">[&lt;Color.RED: <span class="number">1</span>&gt;, &lt;Color.BLUE: <span class="number">2</span>&gt;, &lt;Color.GREEN: <span class="number">3</span>&gt;]</span><br></pre></td></tr></table></figure>
<p> 值将由 <code>_generate_next_value_()</code> 来选择，该函数可以被重载: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">AutoName</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">_generate_next_value_</span><span class="params">(name, start, count, last_values)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Ordinal</span><span class="params">(AutoName)</span>:</span></span><br><span class="line"><span class="meta">... </span>    NORTH = auto()</span><br><span class="line"><span class="meta">... </span>    SOUTH = auto()</span><br><span class="line"><span class="meta">... </span>    EAST = auto()</span><br><span class="line"><span class="meta">... </span>    WEST = auto()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(Ordinal)</span><br><span class="line">[&lt;Ordinal.NORTH: <span class="string">'NORTH'</span>&gt;, &lt;Ordinal.SOUTH: <span class="string">'SOUTH'</span>&gt;, &lt;Ordinal.EAST: <span class="string">'EAST'</span>&gt;, &lt;Ordinal.WEST: <span class="string">'WEST'</span>&gt;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 默认 <code>_generate_next_value_()</code> 方法的目标是提供所给出的最后一个 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 所在序列的下一个 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>，但这种行为方式属于实现细节并且可能发生改变。</p>
</blockquote>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p> 对枚举成员的迭代不会给出别名: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(Shape)</span><br><span class="line">[&lt;Shape.SQUARE: <span class="number">2</span>&gt;, &lt;Shape.DIAMOND: <span class="number">1</span>&gt;, &lt;Shape.CIRCLE: <span class="number">3</span>&gt;]</span><br></pre></td></tr></table></figure>
<p> 特殊属性 <code>__members__</code> 是一个从名称到成员的只读有序映射。 它包含枚举中定义的所有名称，包括别名: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, member <span class="keyword">in</span> Shape.__members__.items():</span><br><span class="line"><span class="meta">... </span>    name, member</span><br><span class="line">...</span><br><span class="line">(<span class="string">'SQUARE'</span>, &lt;Shape.SQUARE: <span class="number">2</span>&gt;)</span><br><span class="line">(<span class="string">'DIAMOND'</span>, &lt;Shape.DIAMOND: <span class="number">1</span>&gt;)</span><br><span class="line">(<span class="string">'CIRCLE'</span>, &lt;Shape.CIRCLE: <span class="number">3</span>&gt;)</span><br><span class="line">(<span class="string">'ALIAS_FOR_SQUARE'</span>, &lt;Shape.SQUARE: <span class="number">2</span>&gt;)</span><br></pre></td></tr></table></figure>
<p> <code>__members__</code> 属性可被用于对枚举成员进行详细的程序化访问。 例如，找出所有别名: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[name <span class="keyword">for</span> name, member <span class="keyword">in</span> Shape.__members__.items() <span class="keyword">if</span> member.name != name]</span><br><span class="line">[<span class="string">'ALIAS_FOR_SQUARE'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p> 枚举成员是按标识号进行比较的: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.RED <span class="keyword">is</span> Color.RED</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.RED <span class="keyword">is</span> Color.BLUE</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.RED <span class="keyword">is</span> <span class="keyword">not</span> Color.BLUE</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p> 枚举值之间的排序比较 <em>不被</em> 支持。 Enum 成员不属于整数 (另请参阅下文的 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#intenum" target="_blank" rel="noopener">IntEnum</a>): </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.RED &lt; Color.BLUE</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'&lt;'</span> <span class="keyword">not</span> supported between instances of <span class="string">'Color'</span> <span class="keyword">and</span> <span class="string">'Color'</span></span><br></pre></td></tr></table></figure>
<p> 相等比较的定义如下: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.BLUE == Color.RED</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.BLUE != Color.RED</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.BLUE == Color.BLUE</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p> 与非枚举值的比较将总是不相等（同样地，<a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a> 被显式设计成不同的行为，参见下文）: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.BLUE == <span class="number">2</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="允许的枚举成员和属性"><a href="#允许的枚举成员和属性" class="headerlink" title="允许的枚举成员和属性"></a>允许的枚举成员和属性</h2><p>以上示例使用整数作为枚举值。 使用整数相当简洁方便（并由 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#functional-api" target="_blank" rel="noopener">Functional API</a> 默认提供），但并不强制要求使用。 在大部分用例中，开发者都关心枚举的实际值是什么。 但如果值 <em>确实</em> 重要，则枚举可以使用任意的值。</p>
<p>枚举属于 Python 的类，并可具有普通方法和特殊方法。 如果我们有这样一个枚举:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Mood</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    FUNKY = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    HAPPY = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">describe</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="comment"># self is the member here</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.name, self.value</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'my custom str! &#123;0&#125;'</span>.format(self.value)</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    @classmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">favorite_mood</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="comment"># cls here is the enumeration</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> cls.HAPPY</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p> 那么: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Mood.favorite_mood()</span><br><span class="line">&lt;Mood.HAPPY: <span class="number">3</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Mood.HAPPY.describe()</span><br><span class="line">(<span class="string">'HAPPY'</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(Mood.FUNKY)</span><br><span class="line"><span class="string">'my custom str! 1'</span></span><br></pre></td></tr></table></figure>
<p>对于允许内容的规则如下：以单下划线开头和结尾的名称是由枚举保留而不可使用；在枚举中定义的所有其他属性将成为该枚举的成员，例外项则包括特殊方法成员 (<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__str__" target="_blank" rel="noopener"><code>__str__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 等)，描述符 (方法也属于描述符) 以及在 <code>_ignore_</code> 中列出的变量名。</p>
<p>注意：如果你的枚举定义了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 和/或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 那么指定给枚举成员的任何值都会被传入这些方法。 请参阅示例 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#planet" target="_blank" rel="noopener">Planet</a>。</p>
<h2 id="受限的-Enum-子类化"><a href="#受限的-Enum-子类化" class="headerlink" title="受限的 Enum 子类化"></a>受限的 Enum 子类化</h2><p> 一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类必须基于一个 Enum 类，至多一个实体数据类型以及出于实际需要的任意多个基于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 的 mixin 类。 这些基类的顺序为: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumName</span><span class="params">([mix-in, ...,] [data-type,] base-enum)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p> 另外，仅当一个枚举未定义任何成员时才允许子类化该枚举。 因此禁止这样的写法: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MoreColor</span><span class="params">(Color)</span>:</span></span><br><span class="line"><span class="meta">... </span>    PINK = <span class="number">17</span></span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: Cannot extend enumerations</span><br></pre></td></tr></table></figure>
<p> 但是允许这样的写法: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">some_behavior</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(Foo)</span>:</span></span><br><span class="line"><span class="meta">... </span>    HAPPY = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    SAD = <span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p> 允许子类化定义了成员的枚举将会导致违反类型与实例的某些重要的不可变规则。 在另一方面，允许在一组枚举之间共享某些通用行为也是有意义的。 （请参阅示例 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#orderedenum" target="_blank" rel="noopener">OrderedEnum</a> 。） </p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p> 枚举可以被封装与解封:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> test.test_enum <span class="keyword">import</span> Fruit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pickle <span class="keyword">import</span> dumps, loads</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fruit.TOMATO <span class="keyword">is</span> loads(dumps(Fruit.TOMATO))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p> 封装的常规限制同样适用：可封存枚举必须在模块的最高层级中定义，因为解封操作要求它们可以从该模块导入。 </p>
<blockquote>
<p> 使用 pickle 协议版本 4 可以方便地封存嵌套在其他类中的枚举。 </p>
</blockquote>
<p> 通过在枚举类中定义 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#object.__reduce_ex__" target="_blank" rel="noopener"><code>__reduce_ex__()</code></a> 可以对 Enum 成员的封存/解封方式进行修改。 </p>
<h2 id="功能性-API"><a href="#功能性-API" class="headerlink" title="功能性 API"></a>功能性 API</h2><p> <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类属于可调用对象，它提供了以下功能性 API: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Animal = Enum(<span class="string">'Animal'</span>, <span class="string">'ANT BEE CAT DOG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Animal</span><br><span class="line">&lt;enum <span class="string">'Animal'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Animal.ANT</span><br><span class="line">&lt;Animal.ANT: <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Animal.ANT.value</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(Animal)</span><br><span class="line">[&lt;Animal.ANT: <span class="number">1</span>&gt;, &lt;Animal.BEE: <span class="number">2</span>&gt;, &lt;Animal.CAT: <span class="number">3</span>&gt;, &lt;Animal.DOG: <span class="number">4</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>该 API 的主义类似于 <a href="https://docs.python.org/zh-cn/3.8/library/collections.html#collections.namedtuple" target="_blank" rel="noopener"><code>namedtuple</code></a>。 调用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 的第一个参数是枚举的名称。</p>
<p>第二个参数是枚举成员名称的 <em>来源</em>。 它可以是一个用空格分隔的名称字符串、名称序列、键/值对 2 元组的序列，或者名称到值的映射（例如字典）。 最后两种选项使得可以为枚举任意赋值；其他选项会自动以从 1 开始递增的整数赋值（使用 <code>start</code> 形参可指定不同的起始值）。 返回值是一个派生自 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 的新类。 换句话说，以上对 <code>Animal</code> 的赋值就等价于:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    ANT = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    BEE = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    CAT = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    DOG = <span class="number">4</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>默认以 <code>1</code> 而以 <code>0</code> 作为起始数值的原因在于 <code>0</code> 的布尔值为 <code>False</code>，但所有枚举成员都应被求值为 <code>True</code>。</p>
<p>对使用功能性 API 创建的枚举执行封存可能会很麻烦，因为要使用帧堆栈的实现细节来尝试并找出枚举是在哪个模块中创建的（例如当你使用了另一个模块中的工具函数就可能失败，在 IronPython 或 Jython 上也可能无效）。 解决办法是显式地指定模块名称，如下所示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Animal = Enum(<span class="string">'Animal'</span>, <span class="string">'ANT BEE CAT DOG'</span>, module=__name__)</span><br></pre></td></tr></table></figure>
<p> 新的 pickle 协议版本 4 在某些情况下同样依赖于 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#definition.__qualname__" target="_blank" rel="noopener"><code>__qualname__</code></a> 被设为特定位置以便 pickle 能够找到相应的类。 例如，类是否存在于全局作用域的 SomeData 类中: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Animal = Enum(<span class="string">'Animal'</span>, <span class="string">'ANT BEE CAT DOG'</span>, qualname=<span class="string">'SomeData.Animal'</span>)</span><br></pre></td></tr></table></figure>
<p> 完整的签名为: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Enum(value='NewEnumName', names=&lt;...&gt;, *, module='...', qualname='...', type=&lt;mixed-in class&gt;, start=1)</span><br></pre></td></tr></table></figure>
<h2 id="派生的枚举"><a href="#派生的枚举" class="headerlink" title="派生的枚举"></a>派生的枚举</h2><h3 id="IntEnum"><a href="#IntEnum" class="headerlink" title="IntEnum"></a>IntEnum</h3><p> 所提供的第一个变种 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 同时也是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的一个子类。 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a> 的成员可与整数进行比较；通过扩展，不同类型的整数枚举也可以相互进行比较: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> enum <span class="keyword">import</span> IntEnum</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Shape</span><span class="params">(IntEnum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    CIRCLE = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    SQUARE = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">(IntEnum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    POST = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    GET = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Shape == <span class="number">1</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Shape.CIRCLE == <span class="number">1</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Shape.CIRCLE == Request.POST</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p> 不过，它们仍然不可与标准 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 枚举进行比较: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Shape</span><span class="params">(IntEnum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    CIRCLE = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    SQUARE = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    GREEN = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Shape.CIRCLE == Color.RED</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a> 值在其他方面的行为都如你预期的一样类似于整数: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(Shape.CIRCLE)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>][Shape.CIRCLE]</span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i <span class="keyword">for</span> i <span class="keyword">in</span> range(Shape.SQUARE)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="IntFlag"><a href="#IntFlag" class="headerlink" title="IntFlag"></a>IntFlag</h3><p> 所提供的下一个 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 的变种 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 同样是基于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的，不同之处在于 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员可使用按位运算符 (&amp;, |, ^, ~) 进行组合且结果仍然为 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员。 如果，正如名称所表明的，<a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员同时也是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的子类，并能在任何使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的场合被使用。 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员进行除按位运算以外的其他运算都将导致失去 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员资格。 </p>
<p> 示例 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 类: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> enum <span class="keyword">import</span> IntFlag</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Perm</span><span class="params">(IntFlag)</span>:</span></span><br><span class="line"><span class="meta">... </span>    R = <span class="number">4</span></span><br><span class="line"><span class="meta">... </span>    W = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    X = <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Perm.R | Perm.W</span><br><span class="line">&lt;Perm.R|W: <span class="number">6</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Perm.R + Perm.W</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RW = Perm.R | Perm.W</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Perm.R <span class="keyword">in</span> RW</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p> 对于组合同样可以进行命名: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Perm</span><span class="params">(IntFlag)</span>:</span></span><br><span class="line"><span class="meta">... </span>    R = <span class="number">4</span></span><br><span class="line"><span class="meta">... </span>    W = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    X = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    RWX = <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Perm.RWX</span><br><span class="line">&lt;Perm.RWX: <span class="number">7</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>~Perm.RWX</span><br><span class="line">&lt;Perm.<span class="number">-8</span>: <span class="number">-8</span>&gt;</span><br></pre></td></tr></table></figure>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 的另一个重要区别在于如果没有设置任何旗标（值为 0），则其布尔值为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Perm.R &amp; Perm.X</span><br><span class="line">&lt;Perm<span class="number">.0</span>: <span class="number">0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(Perm.R &amp; Perm.X)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p> 由于 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员同时也是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的子类，因此它们可以相互组合: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Perm.X | <span class="number">8</span></span><br><span class="line">&lt;Perm<span class="number">.8</span>|X: <span class="number">9</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><p> 最后一个变种是 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a>。 与 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 类似，<a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 成员可使用按位运算符 (&amp;, |, ^, ~) 进行组合，与 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 不同的是它们不可与任何其它 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 枚举或 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 进行组合或比较。 虽然可以直接指定值，但推荐使用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a> 作为值以便让 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 选择适当的值。 </p>
<p> 与 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 类似，如果 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 成员的某种组合导致没有设置任何旗标，则其布尔值为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> enum <span class="keyword">import</span> Flag, auto</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Flag)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = auto()</span><br><span class="line"><span class="meta">... </span>    BLUE = auto()</span><br><span class="line"><span class="meta">... </span>    GREEN = auto()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.RED &amp; Color.GREEN</span><br><span class="line">&lt;Color<span class="number">.0</span>: <span class="number">0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(Color.RED &amp; Color.GREEN)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p> 单个旗标的值应当为二的乘方 (1, 2, 4, 8, …)，旗标的组合则无此限制: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Flag)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = auto()</span><br><span class="line"><span class="meta">... </span>    BLUE = auto()</span><br><span class="line"><span class="meta">... </span>    GREEN = auto()</span><br><span class="line"><span class="meta">... </span>    WHITE = RED | BLUE | GREEN</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.WHITE</span><br><span class="line">&lt;Color.WHITE: <span class="number">7</span>&gt;</span><br></pre></td></tr></table></figure>
<p> 对 “no flags set” 条件指定一个名称并不会改变其布尔值: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Flag)</span>:</span></span><br><span class="line"><span class="meta">... </span>    BLACK = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    RED = auto()</span><br><span class="line"><span class="meta">... </span>    BLUE = auto()</span><br><span class="line"><span class="meta">... </span>    GREEN = auto()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.BLACK</span><br><span class="line">&lt;Color.BLACK: <span class="number">0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(Color.BLACK)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p> 对于大多数新代码，强烈推荐使用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a>，因为 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 打破了枚举的某些语义约定（例如可以同整数进行比较，并因而导致此行为被传递给其他无关的枚举）。 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 的使用应当仅限于 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 无法使用的场合；例如，当使用枚举替代整数常量时，或是与其他系统进行交互操作时。 </p>
</blockquote>
<h3 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h3><p> 虽然 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a> 是 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#module-enum" target="_blank" rel="noopener"><code>enum</code></a> 模块的一部分，但要独立实现也应该相当容易: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntEnum</span><span class="params">(int, Enum)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这里演示了如何定义类似的派生枚举；例如一个混合了 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的 <code>StrEnum</code>。</p>
<p>几条规则：</p>
<ol>
<li>当子类化 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 时，在基类序列中的混合类型必须出现于 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 本身之前，如以上 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a> 的例子所示。</li>
<li>虽然 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 可以拥有任意类型的成员，不过一旦你混合了附加类型，则所有成员必须为相应类型的值，如在上面的例子中即为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>。 此限制不适用于仅添加方法而未指定另一数据类型如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 的混合类。</li>
<li>当混合了另一数据类型时，<code>value</code> 属性会 <em>不同于</em> 枚举成员自身，但它们仍保持等价且比较结果也相等。</li>
<li>%-style formatting: %s 和 %r 会分别调用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__str__" target="_blank" rel="noopener"><code>__str__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a>；其他代码 (例如表示 IntEnum 的 %i 或 %h) 会将枚举成员视为对应的混合类型。</li>
<li><a href="https://docs.python.org/zh-cn/3.8/reference/lexical_analysis.html#f-strings" target="_blank" rel="noopener">格式化字符串字面值</a>, <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str.format" target="_blank" rel="noopener"><code>str.format()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#format" target="_blank" rel="noopener"><code>format()</code></a> 将使用混合类型的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__format__" target="_blank" rel="noopener"><code>__format__()</code></a>。 如果需要 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a>，请使用 !s 或 !r 格式代码。</li>
</ol>
<h2 id="何时使用-init-与-new"><a href="#何时使用-init-与-new" class="headerlink" title="何时使用 __init__与__new__"></a>何时使用 <code>__init__</code>与<code>__new__</code></h2><p>当你想要定制 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 成员的实际值时必须使用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a>。 任何其他修改可以用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 也可以用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a>，应优先使用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a>。</p>
<p>举例来说，如果你要向构造器传入多个条目，但只希望将其中一个作为值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span><span class="params">(bytes, Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    Coordinate with binary codes that can be indexed by the int code.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    """</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, value, label, unit)</span>:</span></span><br><span class="line"><span class="meta">... </span>        obj = bytes.__new__(cls, [value])</span><br><span class="line"><span class="meta">... </span>        obj._value_ = value</span><br><span class="line"><span class="meta">... </span>        obj.label = label</span><br><span class="line"><span class="meta">... </span>        obj.unit = unit</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> obj</span><br><span class="line"><span class="meta">... </span>    PX = (<span class="number">0</span>, <span class="string">'P.X'</span>, <span class="string">'km'</span>)</span><br><span class="line"><span class="meta">... </span>    PY = (<span class="number">1</span>, <span class="string">'P.Y'</span>, <span class="string">'km'</span>)</span><br><span class="line"><span class="meta">... </span>    VX = (<span class="number">2</span>, <span class="string">'V.X'</span>, <span class="string">'km/s'</span>)</span><br><span class="line"><span class="meta">... </span>    VY = (<span class="number">3</span>, <span class="string">'V.Y'</span>, <span class="string">'km/s'</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Coordinate[<span class="string">'PY'</span>])</span><br><span class="line">Coordinate.PY</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Coordinate(<span class="number">3</span>))</span><br><span class="line">Coordinate.VY</span><br></pre></td></tr></table></figure>
<h2 id="有趣的示例"><a href="#有趣的示例" class="headerlink" title="有趣的示例"></a>有趣的示例</h2><p> 虽然 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 预期可覆盖大多数应用场景，但它们无法覆盖全部。 这里有一些不同类型枚举的方案，它们可以被直接使用，或是作为自行创建的参考示例。 </p>
<h3 id="省略值"><a href="#省略值" class="headerlink" title="省略值"></a>省略值</h3><p>在许多应用场景中人们都不关心枚举的实际值是什么。 有几个方式可以定义此种类型的简单枚举：</p>
<ul>
<li>使用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a> 的实例作为值</li>
<li>使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 的实例作为值</li>
<li>使用描述性的字符串作为值</li>
<li>使用元组作为值并用自定义的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 以一个 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 值来替代该元组</li>
</ul>
<p>使用以上任何一种方法均可向用户指明值并不重要，并且使人能够添加、移除或重排序成员而不必改变其余成员的数值。</p>
<p>无论你选择何种方法，你都应当提供一个 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 并且它也需要隐藏（不重要的）值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">NoValue</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'&lt;%s.%s&gt;'</span> % (self.__class__.__name__, self.name)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="使用auto"><a href="#使用auto" class="headerlink" title="使用auto"></a>使用<code>auto</code></h4><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a> 的形式如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(NoValue)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = auto()</span><br><span class="line"><span class="meta">... </span>    BLUE = auto()</span><br><span class="line"><span class="meta">... </span>    GREEN = auto()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.GREEN</span><br><span class="line">&lt;Color.GREEN&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用-object"><a href="#使用-object" class="headerlink" title="使用 object"></a>使用 <code>object</code></h4><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 的形式如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(NoValue)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = object()</span><br><span class="line"><span class="meta">... </span>    GREEN = object()</span><br><span class="line"><span class="meta">... </span>    BLUE = object()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.GREEN</span><br><span class="line">&lt;Color.GREEN&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用描述性字符串"><a href="#使用描述性字符串" class="headerlink" title="使用描述性字符串"></a>使用描述性字符串</h4><p>使用字符串作为值的形式如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(NoValue)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = <span class="string">'stop'</span></span><br><span class="line"><span class="meta">... </span>    GREEN = <span class="string">'go'</span></span><br><span class="line"><span class="meta">... </span>    BLUE = <span class="string">'too fast!'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.GREEN</span><br><span class="line">&lt;Color.GREEN&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.GREEN.value</span><br><span class="line"><span class="string">'go'</span></span><br></pre></td></tr></table></figure>
<h4 id="使用自定义的-new"><a href="#使用自定义的-new" class="headerlink" title="使用自定义的__new__"></a>使用自定义的<code>__new__</code></h4><p>使用自动编号 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 的形式如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">AutoNumber</span><span class="params">(NoValue)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="meta">... </span>        value = len(cls.__members__) + <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        obj = object.__new__(cls)</span><br><span class="line"><span class="meta">... </span>        obj._value_ = value</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> obj</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(AutoNumber)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = ()	</span><br><span class="line"><span class="meta">... </span>    GREEN = ()</span><br><span class="line"><span class="meta">... </span>    BLUE = ()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.GREEN</span><br><span class="line">&lt;Color.GREEN&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.GREEN.value</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p> 如果定义了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 则它会在创建 Enum 成员期间被使用；随后它将被 Enum 的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 所替换，该方法会在类创建后被用来查找现有成员</p>
</blockquote>
<h3 id="OrderedEnum"><a href="#OrderedEnum" class="headerlink" title="OrderedEnum"></a>OrderedEnum</h3><p> 一个有序枚举，它不是基于 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a>，因此保持了正常的 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 不变特性（例如不可与其他枚举进行比较）: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">OrderedEnum</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__ge__</span><span class="params">(self, other)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> self.__class__ <span class="keyword">is</span> other.__class__:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.value &gt;= other.value</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> self.__class__ <span class="keyword">is</span> other.__class__:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.value &gt; other.value</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__le__</span><span class="params">(self, other)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> self.__class__ <span class="keyword">is</span> other.__class__:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.value &lt;= other.value</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> self.__class__ <span class="keyword">is</span> other.__class__:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.value &lt; other.value</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Grade</span><span class="params">(OrderedEnum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    A = <span class="number">5</span></span><br><span class="line"><span class="meta">... </span>    B = <span class="number">4</span></span><br><span class="line"><span class="meta">... </span>    C = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    D = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    F = <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Grade.C &lt; Grade.A</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="DuplicateFreeEnum"><a href="#DuplicateFreeEnum" class="headerlink" title="DuplicateFreeEnum"></a>DuplicateFreeEnum</h3><p> 如果发现重复的成员名称则将引发错误而不是创建别名: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">DuplicateFreeEnum</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        cls = self.__class__</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> any(self.value == e.value <span class="keyword">for</span> e <span class="keyword">in</span> cls):</span><br><span class="line"><span class="meta">... </span>            a = self.name</span><br><span class="line"><span class="meta">... </span>            e = cls(self.value).name</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> ValueError(</span><br><span class="line"><span class="meta">... </span>                <span class="string">"aliases not allowed in DuplicateFreeEnum:  %r --&gt; %r"</span></span><br><span class="line"><span class="meta">... </span>                % (a, e))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(DuplicateFreeEnum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    GREEN = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    BLUE = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    GRENE = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">ValueError: aliases not allowed in DuplicateFreeEnum:  'GRENE' --&gt; 'GREEN'</span><br></pre></td></tr></table></figure>
<h3 id="Planet"><a href="#Planet" class="headerlink" title="Planet"></a>Planet</h3><p>如果定义了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 则枚举成员的值将被传给这些方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Planet</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    MERCURY = (<span class="number">3.303e+23</span>, <span class="number">2.4397e6</span>)</span><br><span class="line"><span class="meta">... </span>    VENUS   = (<span class="number">4.869e+24</span>, <span class="number">6.0518e6</span>)</span><br><span class="line"><span class="meta">... </span>    EARTH   = (<span class="number">5.976e+24</span>, <span class="number">6.37814e6</span>)</span><br><span class="line"><span class="meta">... </span>    MARS    = (<span class="number">6.421e+23</span>, <span class="number">3.3972e6</span>)</span><br><span class="line"><span class="meta">... </span>    JUPITER = (<span class="number">1.9e+27</span>,   <span class="number">7.1492e7</span>)</span><br><span class="line"><span class="meta">... </span>    SATURN  = (<span class="number">5.688e+26</span>, <span class="number">6.0268e7</span>)</span><br><span class="line"><span class="meta">... </span>    URANUS  = (<span class="number">8.686e+25</span>, <span class="number">2.5559e7</span>)</span><br><span class="line"><span class="meta">... </span>    NEPTUNE = (<span class="number">1.024e+26</span>, <span class="number">2.4746e7</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mass, radius)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.mass = mass       <span class="comment"># in kilograms</span></span><br><span class="line"><span class="meta">... </span>        self.radius = radius   <span class="comment"># in meters</span></span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">surface_gravity</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="comment"># universal gravitational constant  (m3 kg-1 s-2)</span></span><br><span class="line"><span class="meta">... </span>        G = <span class="number">6.67300E-11</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> G * self.mass / (self.radius * self.radius)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Planet.EARTH.value</span><br><span class="line">(<span class="number">5.976e+24</span>, <span class="number">6378140.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Planet.EARTH.surface_gravity</span><br><span class="line"><span class="number">9.802652743337129</span></span><br></pre></td></tr></table></figure>
<h3 id="TimePeriod"><a href="#TimePeriod" class="headerlink" title="TimePeriod"></a>TimePeriod</h3><p> 一个演示如何使用 <code>_ignore_</code> 属性的例子: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Period</span><span class="params">(timedelta, Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"different lengths of time"</span></span><br><span class="line"><span class="meta">... </span>    _ignore_ = <span class="string">'Period i'</span></span><br><span class="line"><span class="meta">... </span>    Period = vars()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">367</span>):</span><br><span class="line"><span class="meta">... </span>        Period[<span class="string">'day_%d'</span> % i] = i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(Period)[:<span class="number">2</span>]</span><br><span class="line">[&lt;Period.day_0: datetime.timedelta(<span class="number">0</span>)&gt;, &lt;Period.day_1: datetime.timedelta(days=<span class="number">1</span>)&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(Period)[<span class="number">-2</span>:]</span><br><span class="line">[&lt;Period.day_365: datetime.timedelta(days=<span class="number">365</span>)&gt;, &lt;Period.day_366: datetime.timedelta(days=<span class="number">366</span>)&gt;]</span><br></pre></td></tr></table></figure>
<h2 id="各种枚举有何区别？"><a href="#各种枚举有何区别？" class="headerlink" title="各种枚举有何区别？"></a>各种枚举有何区别？</h2><p> 枚举具有自定义的元类，它会影响所派生枚举类及其实例（成员）的各个方面。 </p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p> <code>EnumMeta</code> 元类负责提供 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__contains__" target="_blank" rel="noopener"><code>__contains__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__dir__" target="_blank" rel="noopener"><code>__dir__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 及其他方法以允许用户通过 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类来完成一般类做不到的事情，例如 list(Color) 或 some_enum_var in Color。 <code>EnumMeta</code> 会负责确保最终 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类中的各种其他方法是正确的 (例如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#object.__getnewargs__" target="_blank" rel="noopener"><code>__getnewargs__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__str__" target="_blank" rel="noopener"><code>__str__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a>)。 </p>
<h3 id="枚举成员（即实例）"><a href="#枚举成员（即实例）" class="headerlink" title="枚举成员（即实例）"></a>枚举成员（即实例）</h3><p> 有关枚举成员最有趣的特点是它们都是单例对象。 <code>EnumMeta</code> 会在创建 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类本身时将它们全部创建完成，然后准备好一个自定义的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a>，通过只返回现有的成员实例来确保不会再实例化新的对象。 </p>
<h3 id="细节要点"><a href="#细节要点" class="headerlink" title="细节要点"></a>细节要点</h3><h4 id="支持的-dunder-名称"><a href="#支持的-dunder-名称" class="headerlink" title="支持的 __dunder__ 名称"></a>支持的 <code>__dunder__</code> 名称</h4><p><code>__members__</code> 是一个 <code>member_name</code>:<code>member</code> 条目的只读有序映射。 它只在类上可用。</p>
<p>如果指定了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a>，它必须创建并返回枚举成员；相应地设定成员的 <code>_value_</code> 也是一个很好的主意。 一旦所有成员都创建完成它就不会再被使用。</p>
<h4 id="支持的-sunder-名称"><a href="#支持的-sunder-名称" class="headerlink" title="支持的 _sunder_ 名称"></a>支持的 <code>_sunder_</code> 名称</h4><ul>
<li><code>_name_</code> – 成员的名称</li>
<li><code>_value_</code> – 成员的值；可以在 <code>__new__</code> 中设置 / 修改</li>
<li><code>_missing_</code> – 当未发现某个值时所使用的查找函数；可被重载</li>
<li><code>_ignore_</code> – 一个名称列表，可以为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a>，它将不会被转化为成员，并会从最终类中被移除</li>
<li><code>_order_</code> – 用于 Python 2/3 代码以确保成员顺序一致（类属性，在类创建期间会被移除）</li>
<li><code>_generate_next_value_</code> – 用于 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#functional-api" target="_blank" rel="noopener">Functional API</a> 并通过 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a> 为枚举成员获取适当的值；可被重载</li>
</ul>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><p> 用来帮助 Python 2 / Python 3 代码保持同步提供 <code>_order_</code> 属性。 它将与枚举的实际顺序进行对照检查，如果两者不匹配则会引发错误: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    _order_ = <span class="string">'RED GREEN BLUE'</span></span><br><span class="line"><span class="meta">... </span>    RED = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    BLUE = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    GREEN = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: member order does <span class="keyword">not</span> match _order_</span><br></pre></td></tr></table></figure>
<h4 id="Enum-成员类型"><a href="#Enum-成员类型" class="headerlink" title="Enum 成员类型"></a><code>Enum</code> 成员类型</h4><p> <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 成员是其 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类的实例，一般通过 <code>EnumClass.member</code> 的形式来访问。 在特定情况下它们也可通过 <code>EnumClass.member.member</code> 的形式来访问，但你绝对不应这样做，因为查找可能失败，或者更糟糕地返回你所查找的 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 成员以外的对象（这也是成员应使用全大写名称的另一个好理由）: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">FieldTypes</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    name = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    value = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    size = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FieldTypes.value.size</span><br><span class="line">&lt;FieldTypes.size: <span class="number">2</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FieldTypes.size.value</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="Enum-类和成员的布尔值"><a href="#Enum-类和成员的布尔值" class="headerlink" title="Enum 类和成员的布尔值"></a><code>Enum</code> 类和成员的布尔值</h4><p>混合了非 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类型（例如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 等）的 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 成员会按所混合类型的规则被求值；在其他情况下，所有成员都将被求值为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>。 要使你的自定义 Enum 的布尔值取决于成员的值，请在你的类中添加以下代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bool(self.value)</span><br></pre></td></tr></table></figure>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类总是会被求值为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>。 </p>
<h4 id="带有方法的-Enum-类"><a href="#带有方法的-Enum-类" class="headerlink" title="带有方法的 Enum 类"></a>带有方法的 <code>Enum</code> 类</h4><p>如果你为你的 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 子类添加了额外的方法，如同上述的 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#planet" target="_blank" rel="noopener">Planet</a> 类一样，这些方法将在对成员执行 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#dir" target="_blank" rel="noopener"><code>dir()</code></a> 时显示出来，但对类执行时则不会显示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(Planet)</span><br><span class="line">[<span class="string">'EARTH'</span>, <span class="string">'JUPITER'</span>, <span class="string">'MARS'</span>, <span class="string">'MERCURY'</span>, <span class="string">'NEPTUNE'</span>, <span class="string">'SATURN'</span>, <span class="string">'URANUS'</span>, <span class="string">'VENUS'</span>, <span class="string">'__class__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__members__'</span>, <span class="string">'__module__'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(Planet.EARTH)</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__module__'</span>, <span class="string">'name'</span>, <span class="string">'surface_gravity'</span>, <span class="string">'value'</span>]</span><br></pre></td></tr></table></figure>
<h4 id="组合-Flag-的成员"><a href="#组合-Flag-的成员" class="headerlink" title="组合 Flag 的成员"></a>组合 <code>Flag</code> 的成员</h4><p> 如果 Flag 成员的某种组合未被命名，则 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 将包含所有已命名的旗标和值中所有已命名的旗标组合: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Flag)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = auto()</span><br><span class="line"><span class="meta">... </span>    GREEN = auto()</span><br><span class="line"><span class="meta">... </span>    BLUE = auto()</span><br><span class="line"><span class="meta">... </span>    MAGENTA = RED | BLUE</span><br><span class="line"><span class="meta">... </span>    YELLOW = RED | GREEN</span><br><span class="line"><span class="meta">... </span>    CYAN = GREEN | BLUE</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color(<span class="number">3</span>)  <span class="comment"># named combination</span></span><br><span class="line">&lt;Color.YELLOW: <span class="number">3</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color(<span class="number">7</span>)      <span class="comment"># not named combination</span></span><br><span class="line">&lt;Color.CYAN|MAGENTA|BLUE|YELLOW|GREEN|RED: <span class="number">7</span>&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>enum</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library queue</title>
    <url>/2020/01/31/python-standard-library-queue/</url>
    <content><![CDATA[<h1 id="python-标准库-queue"><a href="#python-标准库-queue" class="headerlink" title="python 标准库 queue"></a>python 标准库 queue</h1><p><img src="https://up.enterdesk.com/edpic/02/40/4a/02404af0eafff163c22ce10400cb5be9.jpg" alt></p>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=4973554&auto=0&height=66"></iframe>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/queue.py" target="_blank" rel="noopener">Lib/queue.py</a> </p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/queue.html#module-queue" target="_blank" rel="noopener"><code>queue</code></a> 模块实现了多生产者、多消费者队列。这特别适用于消息必须安全地在多线程间交换的线程编程。模块中的 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue" target="_blank" rel="noopener"><code>Queue</code></a> 类实现了所有所需的锁定语义。</p>
<p>模块实现了三种类型的队列，它们的区别仅仅是条目取回的顺序。在 FIFO 队列中，先添加的任务先取回。在 LIFO 队列中，最近被添加的条目先取回(操作类似一个堆栈)。优先级队列中，条目将保持排序( 使用 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#module-heapq" target="_blank" rel="noopener"><code>heapq</code></a> 模块 ) 并且最小值的条目第一个返回。</p>
<p>在内部，这三个类型的队列使用锁来临时阻塞竞争线程；然而，它们并未被设计用于线程的重入性处理。</p>
<p>此外，模块实现了一个 “简单的” FIFO 队列类型， <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.SimpleQueue" target="_blank" rel="noopener"><code>SimpleQueue</code></a> ，这个特殊实现为小功能在交换中提供额外的保障。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/queue.html#module-queue" target="_blank" rel="noopener"><code>queue</code></a> 模块定义了下列类和异常：</p>
<ul>
<li><p><em>class</em> <code>queue.Queue</code>(<em>maxsize=0</em>)</p>
<p>Constructor for a FIFO queue. <em>maxsize</em> is an integer that sets the upperbound limit on the number of items that can be placed in the queue. Insertion will block once this size has been reached, until queue items are consumed. If <em>maxsize</em> is less than or equal to zero, the queue size is infinite.</p>
</li>
<li><p><em>class</em> <code>queue.LifoQueue</code>(<em>maxsize=0</em>)</p>
<p>LIFO 队列构造函数。 <em>maxsize</em> 是个整数，用于设置可以放入队列中的项目数的上限。当达到这个大小的时候，插入操作将阻塞至队列中的项目被消费掉。如果 <em>maxsize</em> 小于等于零，队列尺寸为无限大。</p>
</li>
<li><p><em>class</em> <code>queue.PriorityQueue</code>(<em>maxsize=0</em>)</p>
<p>优先级队列构造函数。 <em>maxsize</em> 是个整数，用于设置可以放入队列中的项目数的上限。当达到这个大小的时候，插入操作将阻塞至队列中的项目被消费掉。如果 <em>maxsize</em> 小于等于零，队列尺寸为无限大。最小值先被取出( 最小值条目是由 <code>sorted(list(entries))[0]</code> 返回的条目)。条目的典型模式是一个以下形式的元组： <code>(priority_number, data)</code> 。如果 <em>data</em> 元素没有可比性，数据将被包装在一个类中，忽略数据值，仅仅比较优先级数字 ：<code>from dataclasses import dataclass, field from typing import Any @dataclass(order=True) class PrioritizedItem:    priority: int    item: Any=field(compare=False)</code></p>
</li>
<li><p><em>class</em> <code>queue.SimpleQueue</code></p>
<p>无界的 FIFO 队列构造函数。简单的队列，缺少任务跟踪等高级功能。<em>3.7 新版功能.</em></p>
</li>
<li><p><em>exception</em> <code>queue.Empty</code></p>
<p>对空的 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue" target="_blank" rel="noopener"><code>Queue</code></a> 对象，调用非阻塞的 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.get" target="_blank" rel="noopener"><code>get()</code></a> (or <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.get_nowait" target="_blank" rel="noopener"><code>get_nowait()</code></a>) 时，引发的异常。</p>
</li>
<li><p><em>exception</em> <code>queue.Full</code></p>
<p>对满的 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue" target="_blank" rel="noopener"><code>Queue</code></a> 对象，调用非阻塞的 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.put" target="_blank" rel="noopener"><code>put()</code></a> (or <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.put_nowait" target="_blank" rel="noopener"><code>put_nowait()</code></a>) 时，引发的异常。</p>
</li>
</ul>
<h2 id="Queue对象"><a href="#Queue对象" class="headerlink" title="Queue对象"></a>Queue对象</h2><p>队列对象 (<a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue" target="_blank" rel="noopener"><code>Queue</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.LifoQueue" target="_blank" rel="noopener"><code>LifoQueue</code></a>, 或者 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.PriorityQueue" target="_blank" rel="noopener"><code>PriorityQueue</code></a>) 提供下列描述的公共方法。</p>
<ul>
<li><p><code>Queue.qsize</code>()</p>
<p>返回队列的大致大小。注意，qsize() &gt; 0 不保证后续的 get() 不被阻塞，qsize() &lt; maxsize 也不保证 put() 不被阻塞。</p>
</li>
<li><p><code>Queue.empty</code>()</p>
<p>如果队列为空，返回 <code>True</code> ，否则返回 <code>False</code> 。如果 empty() 返回 <code>True</code> ，不保证后续调用的 put() 不被阻塞。类似的，如果 empty() 返回 <code>False</code> ，也不保证后续调用的 get() 不被阻塞。</p>
</li>
<li><p><code>Queue.full</code>()</p>
<p>如果队列是满的返回 <code>True</code> ，否则返回 <code>False</code> 。如果 full() 返回 <code>True</code> 不保证后续调用的 get() 不被阻塞。类似的，如果 full() 返回 <code>False</code> 也不保证后续调用的 put() 不被阻塞。</p>
</li>
<li><p><code>Queue.put</code>(<em>item</em>, <em>block=True</em>, <em>timeout=None</em>)</p>
<p>将 <em>item</em> 放入队列。如果可选参数 <em>block</em> 是 true 并且 <em>timeout</em> 是 <code>None</code> (默认)，则在必要时阻塞至有空闲插槽可用。如果 <em>timeout</em> 是个正数，将最多阻塞 <em>timeout</em> 秒，如果在这段时间没有可用的空闲插槽，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Full" target="_blank" rel="noopener"><code>Full</code></a> 异常。反之 (<em>block</em> 是 false)，如果空闲插槽立即可用，则把 <em>item</em> 放入队列，否则引发 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Full" target="_blank" rel="noopener"><code>Full</code></a> 异常 ( 在这种情况下，<em>timeout</em> 将被忽略)。</p>
</li>
<li><p><code>Queue.put_nowait</code>(<em>item</em>)</p>
<p>相当于 <code>put(item, False)</code> 。</p>
</li>
<li><p><code>Queue.get</code>(<em>block=True</em>, <em>timeout=None</em>)</p>
<p>从队列中移除并返回一个项目。如果可选参数 <em>block</em> 是 true 并且 <em>timeout</em> 是 <code>None</code> (默认值)，则在必要时阻塞至项目可得到。如果 <em>timeout</em> 是个正数，将最多阻塞 <em>timeout</em> 秒，如果在这段时间内项目不能得到，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Empty" target="_blank" rel="noopener"><code>Empty</code></a> 异常。反之 (<em>block</em> 是 false) , 如果一个项目立即可得到，则返回一个项目，否则引发 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Empty" target="_blank" rel="noopener"><code>Empty</code></a> 异常 (这种情况下，<em>timeout</em> 将被忽略)。POSIX系统3.0之前，以及所有版本的Windows系统中，如果 <em>block</em> 是 true 并且 <em>timeout</em> 是 <code>None</code> ， 这个操作将进入基础锁的不间断等待。这意味着，没有异常能发生，尤其是 SIGINT 将不会触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyboardInterrupt" target="_blank" rel="noopener"><code>KeyboardInterrupt</code></a> 异常。</p>
</li>
<li><p><code>Queue.get_nowait</code>()</p>
<p>相当于 <code>get(False)</code> 。</p>
</li>
</ul>
<p>提供了两个方法，用于支持跟踪 排队的任务 是否 被守护的消费者线程 完整的处理。</p>
<ul>
<li><p><code>Queue.task_done</code>()</p>
<p>表示前面排队的任务已经被完成。被队列的消费者线程使用。每个 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.get" target="_blank" rel="noopener"><code>get()</code></a> 被用于获取一个任务， 后续调用 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.task_done" target="_blank" rel="noopener"><code>task_done()</code></a> 告诉队列，该任务的处理已经完成。如果 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.join" target="_blank" rel="noopener"><code>join()</code></a> 当前正在阻塞，在所有条目都被处理后，将解除阻塞(意味着每个 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.put" target="_blank" rel="noopener"><code>put()</code></a> 进队列的条目的 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.task_done" target="_blank" rel="noopener"><code>task_done()</code></a> 都被收到)。如果被调用的次数多于放入队列中的项目数量，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常 。</p>
</li>
<li><p><code>Queue.join</code>()</p>
<p>阻塞至队列中所有的元素都被接收和处理完毕。当条目添加到队列的时候，未完成任务的计数就会增加。每当消费者线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.task_done" target="_blank" rel="noopener"><code>task_done()</code></a> 表示这个条目已经被回收，该条目所有工作已经完成，未完成计数就会减少。当未完成计数降到零的时候， <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.join" target="_blank" rel="noopener"><code>join()</code></a> 阻塞被解除。</p>
</li>
</ul>
<p>如何等待排队的任务被完成的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = q.get()</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        do_work(item)</span><br><span class="line">        q.task_done()</span><br><span class="line"></span><br><span class="line">q = queue.Queue()</span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num_worker_threads):</span><br><span class="line">    t = threading.Thread(target=worker)</span><br><span class="line">    t.start()</span><br><span class="line">    threads.append(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> source():</span><br><span class="line">    q.put(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># block until all tasks are done</span></span><br><span class="line">q.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># stop workers</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num_worker_threads):</span><br><span class="line">    q.put(<span class="literal">None</span>)</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure>
<h2 id="SimpleQueue-对象"><a href="#SimpleQueue-对象" class="headerlink" title="SimpleQueue 对象"></a>SimpleQueue 对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.SimpleQueue" target="_blank" rel="noopener"><code>SimpleQueue</code></a> 对象提供下列描述的公共方法。</p>
<ul>
<li><p><code>SimpleQueue.qsize</code>()</p>
<p>返回队列的大致大小。注意，qsize() &gt; 0 不保证后续的 get() 不被阻塞。</p>
</li>
<li><p><code>SimpleQueue.empty</code>()</p>
<p>如果队列为空，返回 <code>True</code> ，否则返回 <code>False</code> 。如果 empty() 返回 <code>False</code> ，不保证后续调用的 get() 不被阻塞。</p>
</li>
<li><p><code>SimpleQueue.put</code>(<em>item</em>, <em>block=True</em>, <em>timeout=None</em>)</p>
<p>将 <em>item</em> 放入队列。此方法永不阻塞，始终成功（除了潜在的低级错误，例如内存分配失败）。可选参数 <em>block</em> 和 <em>timeout</em> 仅仅是为了保持 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.put" target="_blank" rel="noopener"><code>Queue.put()</code></a> 的兼容性而提供，其值被忽略。<strong>CPython implementation detail:</strong> This method has a C implementation which is reentrant. That is, a <code>put()</code> or <code>get()</code> call can be interrupted by another <code>put()</code> call in the same thread without deadlocking or corrupting internal state inside the queue. This makes it appropriate for use in destructors such as <code>__del__</code> methods or <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> callbacks.</p>
</li>
<li><p><code>SimpleQueue.put_nowait</code>(<em>item</em>)</p>
<p>相当于 <code>put(item)</code> ，仅为保持 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.put_nowait" target="_blank" rel="noopener"><code>Queue.put_nowait()</code></a> 兼容性而提供。</p>
</li>
<li><p><code>SimpleQueue.get</code>(<em>block=True</em>, <em>timeout=None</em>)</p>
<p>从队列中移除并返回一个项目。如果可选参数 <em>block</em> 是 true 并且 <em>timeout</em> 是 <code>None</code> (默认值)，则在必要时阻塞至项目可得到。如果 <em>timeout</em> 是个正数，将最多阻塞 <em>timeout</em> 秒，如果在这段时间内项目不能得到，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Empty" target="_blank" rel="noopener"><code>Empty</code></a> 异常。反之 (<em>block</em> 是 false) , 如果一个项目立即可得到，则返回一个项目，否则引发 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Empty" target="_blank" rel="noopener"><code>Empty</code></a> 异常 (这种情况下，<em>timeout</em> 将被忽略)。</p>
</li>
<li><p><code>SimpleQueue.get_nowait</code>()</p>
<p>相当于 <code>get(False)</code> 。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="Queue的种类："><a href="#Queue的种类：" class="headerlink" title="Queue的种类："></a>Queue的种类：</h3><ul>
<li><p><strong>FIFO</strong>：</p>
<p><strong>Queue.Queue(maxsize=0)</strong></p>
</li>
</ul>
<p>FIFO即First in First Out,先进先出。Queue提供了一个基本的FIFO容器，使用方法很简单,maxsize是个整数，指明了队列中能存放的数据个数的上限。一旦达到上限，插入会导致阻塞，直到队列中的数据被消费掉。如果maxsize小于或者等于0，队列大小没有限制。</p>
<ul>
<li><strong>LIFO</strong></li>
</ul>
<p><strong>Queue.LifoQueue(maxsize=0)</strong></p>
<p>LIFO即Last in First Out,后进先出。与栈的类似，使用也很简单,maxsize用法同上</p>
<ul>
<li><strong>priority</strong></li>
</ul>
<p><strong>class Queue.PriorityQueue(maxsize=0)</strong></p>
<p>构造一个优先队列。maxsize用法同上。</p>
<h3 id="例子1：LifoQueue"><a href="#例子1：LifoQueue" class="headerlink" title="例子1：LifoQueue"></a>例子1：LifoQueue</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可以设置队列的长度 q=queue.LifoQueue(5)，意味着队列中最多存放5个元素,当队列满的时候自动进入阻塞状态</span></span><br><span class="line">q=queue.LifoQueue()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        q.put(i)</span><br><span class="line">        print(<span class="string">"数据%d被存入到队列中"</span> % i)</span><br><span class="line">    q.join()</span><br><span class="line">    print(<span class="string">'ok'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        value = q.get()</span><br><span class="line">        print(<span class="string">"数据%d从队列中取出"</span> % value)</span><br><span class="line">        q.task_done()</span><br><span class="line"> </span><br><span class="line">t1=threading.Thread(target=put,args=())</span><br><span class="line">t1.start()</span><br><span class="line">t2=threading.Thread(target=get,args=())</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">0</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">1</span>被存入到数据中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">2</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">3</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">4</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">5</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">6</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">7</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">8</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">9</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">9</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">8</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">7</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">6</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">5</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">4</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">3</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">2</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">1</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">0</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ok</span><br></pre></td></tr></table></figure>
<h3 id="例子2：Priortity-Queue-in-Python"><a href="#例子2：Priortity-Queue-in-Python" class="headerlink" title="例子2：Priortity Queue in Python"></a>例子2：Priortity Queue in Python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A simple implementation of Priority Queue </span></span><br><span class="line"><span class="comment"># using Queue. </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span><span class="params">(object)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        self.queue = [] </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join([str(i) <span class="keyword">for</span> i <span class="keyword">in</span> self.queue]) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># for checking if the queue is empty </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> len(self.queue) == [] </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># for inserting an element in the queue </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, data)</span>:</span> </span><br><span class="line">        self.queue.append(data) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># for popping an element based on Priority </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">try</span>: </span><br><span class="line">            max = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.queue)): </span><br><span class="line">                <span class="keyword">if</span> self.queue[i] &gt; self.queue[max]: </span><br><span class="line">                    max = i </span><br><span class="line">            item = self.queue[max] </span><br><span class="line">            <span class="keyword">del</span> self.queue[max] </span><br><span class="line">            <span class="keyword">return</span> item </span><br><span class="line">        <span class="keyword">except</span> IndexError: </span><br><span class="line">            print() </span><br><span class="line">            exit() </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: </span><br><span class="line">    myQueue = PriorityQueue() </span><br><span class="line">    myQueue.insert(<span class="number">12</span>) </span><br><span class="line">    myQueue.insert(<span class="number">1</span>) </span><br><span class="line">    myQueue.insert(<span class="number">14</span>) </span><br><span class="line">    myQueue.insert(<span class="number">7</span>) </span><br><span class="line">    print(myQueue)             </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> myQueue.isEmpty(): </span><br><span class="line">        print(myQueue.delete())  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">12</span> <span class="number">1</span> <span class="number">14</span> <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>()</span><br></pre></td></tr></table></figure>
<h2 id="扩展-第三方队列"><a href="#扩展-第三方队列" class="headerlink" title="扩展:第三方队列"></a>扩展:第三方队列</h2><p>下面介绍五个第三方队列框架,看来造轮子也是个好方法，:)</p>
<ol>
<li><p><a href="http://www.celeryproject.org/" target="_blank" rel="noopener">Celery</a>  </p>
<p><a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html" target="_blank" rel="noopener">官方栗子</a></p>
</li>
<li><p><a href="http://python-rq.org/" target="_blank" rel="noopener">RQ</a> </p>
</li>
</ol>
<p>   一个栗子</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_words_at_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> len(resp.text.split())</span><br></pre></td></tr></table></figure>
<p>   创建一个RQ queue</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">from</span> rq <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">q = Queue(connection=Redis())</span><br></pre></td></tr></table></figure>
<p>   方法调用</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> count_words_at_url</span><br><span class="line">result = q.enqueue(</span><br><span class="line">             count_words_at_url, <span class="string">'http://nvie.com'</span>)</span><br></pre></td></tr></table></figure>
<p>   Worker实例</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ rq worker</span><br><span class="line">*** Listening <span class="keyword">for</span> work on default</span><br><span class="line">Got count_words_at_url(<span class="string">'http://nvie.com'</span>) <span class="keyword">from</span> default</span><br><span class="line">Job result = <span class="number">818</span></span><br><span class="line">*** Listening <span class="keyword">for</span> work on default</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p><a href="https://huey.readthedocs.io/en/latest/" target="_blank" rel="noopener">huey</a> </p>
<blockquote>
<p>一个轻量级队列框架</p>
</blockquote>
<p>一个栗子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> huey <span class="keyword">import</span> RedisHuey, crontab</span><br><span class="line"></span><br><span class="line">huey = RedisHuey(<span class="string">'my-app'</span>, host=<span class="string">'redis.myapp.com'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@huey.task()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="meta">@huey.task(retries=2, retry_delay=60)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flaky_task</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment"># This task might fail, in which case it will be retried up to 2 times</span></span><br><span class="line">    <span class="comment"># with a delay of 60s between retries.</span></span><br><span class="line">    <span class="keyword">return</span> this_might_fail(url)</span><br><span class="line"></span><br><span class="line"><span class="meta">@huey.periodic_task(crontab(minute='0', hour='3'))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nightly_backup</span><span class="params">()</span>:</span></span><br><span class="line">    sync_all_data()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p><a href="https://kuyruk.readthedocs.io/en/latest/" target="_blank" rel="noopener">kuyruk</a></p>
<p>创建Task</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tasks.py</span></span><br><span class="line"><span class="keyword">from</span> kuyruk <span class="keyword">import</span> Kuyruk</span><br><span class="line"></span><br><span class="line">kuyruk = Kuyruk()</span><br><span class="line"></span><br><span class="line"><span class="meta">@kuyruk.task()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> message</span><br></pre></td></tr></table></figure>
<p>发送Task 去 RabbitMQ</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tasks</span><br><span class="line">tasks.echo(<span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></table></figure>
<p>运行Worker</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kuyruk --app tasks.kuyruk worker</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://dramatiq.io/" target="_blank" rel="noopener"><strong>Dramatiq</strong></a>  </p>
<p>一个栗子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dramatiq</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dramatiq.actor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_words</span><span class="params">(url)</span>:</span></span><br><span class="line">     response = requests.get(url)</span><br><span class="line">     count = len(response.text.split(<span class="string">" "</span>))</span><br><span class="line">     print(<span class="string">f"There are <span class="subst">&#123;count&#125;</span> words at <span class="subst">&#123;url!r&#125;</span>."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Synchronously count the words on example.com in the current process</span></span><br><span class="line">count_words(<span class="string">"http://example.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># or send the actor a message so that it may perform the count</span></span><br><span class="line"><span class="comment"># later, in a separate process.</span></span><br><span class="line">count_words.send(<span class="string">"http://example.com"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library concurrent</title>
    <url>/2020/01/30/python-standard-library-concurrent/</url>
    <content><![CDATA[<h1 id="python-标准库-concurrent"><a href="#python-标准库-concurrent" class="headerlink" title="python  标准库 concurrent"></a>python  标准库 concurrent</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/ezgif-2-131886a37345.png?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>what is love？ 也许一千个人有一千个人的说法。也许当你知道什么是爱的时候,我们已经忘记了曾经也爱过。一生都没弄明白什么是爱。学会爱别人,也学着如何去爱一个人,是一辈子的事。</p>
<p>​                                                                                                                                                     — 临风语录</p>
</blockquote>
<p>送给大家一首歌 How Long Will I Love You.在这个寒冷的季节里,唯有爱才是唯一可以温暖人们的东西吧。</p>
<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29596326&auto=1&height=66"></iframe></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/concurrent/futures/thread.py" target="_blank" rel="noopener">Lib/concurrent/futures/thread.py</a> 和 <a href="https://github.com/python/cpython/tree/3.8/Lib/concurrent/futures/process.py" target="_blank" rel="noopener">Lib/concurrent/futures/process.py</a></p>
<p>concurrent模块层次结构如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">concurrent</span><br><span class="line">    |-- futures/</span><br><span class="line">    |-----|--__init__.py</span><br><span class="line">    |-----|--_base.py</span><br><span class="line">    |-----|--process.py</span><br><span class="line">    |-----|--thread.py</span><br><span class="line">    |-- __init__.py</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#module-concurrent.futures" target="_blank" rel="noopener"><code>concurrent.futures</code></a> 模块提供异步执行回调高层接口。</p>
<p>异步执行可以由 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener"><code>ThreadPoolExecutor</code></a> 使用线程或由 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 使用单独的进程来实现。 两者都是实现抽像类 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 定义的接口。</p>
<h2 id="Executor对象"><a href="#Executor对象" class="headerlink" title="Executor对象"></a>Executor对象</h2><p><em>class</em> <code>concurrent.futures.Executor</code></p>
<p>抽象类提供异步执行调用方法。要通过它的子类调用，而不是直接调用。</p>
<ul>
<li><p><code>submit</code>(<em>fn</em>, <strong>args<em>, </em></strong>kwargs*)</p>
<p>调度可调用对象 <em>fn</em>，以 <code>fn(*args **kwargs)</code> 方式执行并返回 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 对像代表可调用对象的执行。:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">1</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    future = executor.submit(pow, <span class="number">323</span>, <span class="number">1235</span>)</span><br><span class="line">    print(future.result())</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>map</code>(<em>func</em>, *<em>iterables</em>, <em>timeout=None</em>, <em>chunksize=1</em>)</p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map(func, *iterables)</code></a> 除去：</p>
<ul>
<li>应立即收集 <em>iterables</em> 不要延迟再收集;</li>
<li><em>func</em> 是异步执行的且对 <em>func</em> 的调用可以并发执行。</li>
</ul>
<p>如果 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 已被调用且返回的结果在对 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor.map" target="_blank" rel="noopener"><code>Executor.map()</code></a> 的原始调用经过 <em>timeout</em> 秒后还不可用，则已返回的迭代器将引发 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.TimeoutError" target="_blank" rel="noopener"><code>concurrent.futures.TimeoutError</code></a>。 <em>timeout</em> 可以为 int 或 float 类型。 如果 <em>timeout</em> 未指定或为 <code>None</code>，则不限制等待时间。</p>
<p>如果 <em>func</em> 调用引发一个异常，当从迭代器中取回它的值时这个异常将被引发。</p>
<p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 时，这个方法会将 <em>iterables</em> 分割任务块并作为独立的任务并提交到执行池中。这些块的大概数量可以由 <em>chunksize</em> 指定正整数设置。 对很长的迭代器来说，使用大的 <em>chunksize</em> 值比默认值 1 能显著地提高性能。 <em>chunksize</em> 对 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener"><code>ThreadPoolExecutor</code></a> 没有效果。</p>
<p><em>在 3.5 版更改:</em> 加入 <em>chunksize</em> 参数。</p>
</li>
<li><p><code>shutdown</code>(<em>wait=True</em>)</p>
<p>当待执行的期程完成执行后向执行者发送信号，它就会释放正在使用的任何资源。调用 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor.submit" target="_blank" rel="noopener"><code>Executor.submit()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor.submit" target="_blank" rel="noopener"><code>Executor.submit()</code></a> 会在关闭后触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p>
<p>如果 <em>wait</em> 为 <code>True</code> 则此方法只有在所有待执行的期程完成执行且释放已分配的资源后才会返回。 如果 <em>wait</em> 为 <code>False</code>，方法立即返回，所有待执行的期程完成执行后会释放已分配的资源。 不管 <em>wait</em> 的值是什么，整个 Python 程序将等到所有待执行的期程完成执行后才退出。</p>
<p>如果使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句，你就可以避免显式调用这个方法，它将会停止 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> (就好像 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor.shutdown" target="_blank" rel="noopener"><code>Executor.shutdown()</code></a> 调用时 <em>wait</em> 设为 <code>True</code> 一样等待):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> e:</span><br><span class="line">    e.submit(shutil.copy, <span class="string">'src1.txt'</span>, <span class="string">'dest1.txt'</span>)</span><br><span class="line">    e.submit(shutil.copy, <span class="string">'src2.txt'</span>, <span class="string">'dest2.txt'</span>)</span><br><span class="line">    e.submit(shutil.copy, <span class="string">'src3.txt'</span>, <span class="string">'dest3.txt'</span>)</span><br><span class="line">    e.submit(shutil.copy, <span class="string">'src4.txt'</span>, <span class="string">'dest4.txt'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener"><code>ThreadPoolExecutor</code></a> 是 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 的子类，它使用线程池来异步执行调用。</p>
<p>当回调已关联了一个 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 然后再等待另一个 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 的结果时就会发生死锁情况。 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_on_b</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(b.result())  <span class="comment"># b will never complete because it is waiting on a.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_on_a</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(a.result())  <span class="comment"># a will never complete because it is waiting on b.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">a = executor.submit(wait_on_b)</span><br><span class="line">b = executor.submit(wait_on_a)</span><br></pre></td></tr></table></figure>
<p>和下面的情况:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_on_future</span><span class="params">()</span>:</span></span><br><span class="line">    f = executor.submit(pow, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># This will never complete because there is only one worker thread and</span></span><br><span class="line">    <span class="comment"># it is executing this function.</span></span><br><span class="line">    print(f.result())</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">1</span>)</span><br><span class="line">executor.submit(wait_on_future)</span><br></pre></td></tr></table></figure>
<p><em>class</em> <code>concurrent.futures.ThreadPoolExecutor</code>(<em>max_workers=None</em>, <em>thread_name_prefix=’’</em>, <em>initializer=None</em>, <em>initargs=()</em>)</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 的一个子类，使用最多 <em>max_workers</em> 个线程的线程池来异步执行调用。</p>
<p><em>initializer</em> 是在每个工作者线程开始处调用的一个可选可调用对象。 <em>initargs</em> 是传递给初始化器的元组参数。任何向池提交更多工作的尝试， <em>initializer</em> 都将引发一个异常，当前所有等待的工作都会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.thread.BrokenThreadPool" target="_blank" rel="noopener"><code>BrokenThreadPool</code></a>。</p>
<p><em>在 3.5 版更改:</em> 如果 <em>max_workers</em> 为 <code>None</code> 或没有指定，将默认为机器处理器的个数，假如 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener"><code>ThreadPoolExecutor</code></a> 则重于 I/O 操作而不是 CPU 运算，那么可以乘以 <code>5</code>，同时工作线程的数量可以比 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 的数量高。</p>
<p><em>3.6 新版功能:</em> 添加 <em>thread_name_prefix</em> 参数允许用户控制由线程池创建的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>threading.Thread</code></a> 工作线程名称以方便调试。</p>
<p><em>在 3.7 版更改:</em> 加入 <em>initializer</em> 和<em>initargs</em> 参数。</p>
<p><em>在 3.8 版更改:</em> <em>max_workers</em> 的默认值已改为 <code>min(32, os.cpu_count() + 4)</code>。 这个默认值会保留至少 5 个工作线程用于 I/O 密集型任务。 它会使用至多 32 个 CPU 核心用于 CPU 密集型任务并将释放 GIL。 它还会避免在多核机器上隐式地使用非常大量的资源。</p>
<p>现在 ThreadPoolExecutor 在启动 <em>max_workers</em> 个工作线程之前也会重用空闲的工作线程。</p>
<h3 id="ThreadPoolExecutor-例子"><a href="#ThreadPoolExecutor-例子" class="headerlink" title="ThreadPoolExecutor 例子"></a>ThreadPoolExecutor 例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">URLS = [<span class="string">'http://www.foxnews.com/'</span>,</span><br><span class="line">        <span class="string">'http://www.cnn.com/'</span>,</span><br><span class="line">        <span class="string">'http://europe.wsj.com/'</span>,</span><br><span class="line">        <span class="string">'http://www.bbc.co.uk/'</span>,</span><br><span class="line">        <span class="string">'http://some-made-up-domain.com/'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve a single page and report the URL and contents</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_url</span><span class="params">(url, timeout)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> urllib.request.urlopen(url, timeout=timeout) <span class="keyword">as</span> conn:</span><br><span class="line">        <span class="keyword">return</span> conn.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># We can use a with statement to ensure threads are cleaned up promptly</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># Start the load operations and mark each future with its URL</span></span><br><span class="line">    future_to_url = &#123;executor.submit(load_url, url, <span class="number">60</span>): url <span class="keyword">for</span> url <span class="keyword">in</span> URLS&#125;</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(future_to_url):</span><br><span class="line">        url = future_to_url[future]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = future.result()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            print(<span class="string">'%r generated an exception: %s'</span> % (url, exc))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'%r page is %d bytes'</span> % (url, len(data)))</span><br></pre></td></tr></table></figure>
<h2 id="ProcessPoolExecutor"><a href="#ProcessPoolExecutor" class="headerlink" title="ProcessPoolExecutor"></a>ProcessPoolExecutor</h2><p><a href="https://github.com/python/cpython/blob/3.8/Lib/concurrent/futures/process.py" target="_blank" rel="noopener">源码</a>中的图示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""Implements ProcessPoolExecutor.</span></span><br><span class="line"><span class="string">The following diagram and text describe the data-flow through the system:</span></span><br><span class="line"><span class="string">|======================= In-process =====================|== Out-of-process ==|</span></span><br><span class="line"><span class="string">+----------+     +----------+       +--------+     +-----------+    +---------+</span></span><br><span class="line"><span class="string">|          |  =&gt; | Work Ids |       |        |     | Call Q    |    | Process |</span></span><br><span class="line"><span class="string">|          |     +----------+       |        |     +-----------+    |  Pool   |</span></span><br><span class="line"><span class="string">|          |     | ...      |       |        |     | ...       |    +---------+</span></span><br><span class="line"><span class="string">|          |     | 6        |    =&gt; |        |  =&gt; | 5, call() | =&gt; |         |</span></span><br><span class="line"><span class="string">|          |     | 7        |       |        |     | ...       |    |         |</span></span><br><span class="line"><span class="string">| Process  |     | ...      |       | Local  |     +-----------+    | Process |</span></span><br><span class="line"><span class="string">|  Pool    |     +----------+       | Worker |                      |  #1..n  |</span></span><br><span class="line"><span class="string">| Executor |                        | Thread |                      |         |</span></span><br><span class="line"><span class="string">|          |     +----------- +     |        |     +-----------+    |         |</span></span><br><span class="line"><span class="string">|          | &lt;=&gt; | Work Items | &lt;=&gt; |        | &lt;=  | Result Q  | &lt;= |         |</span></span><br><span class="line"><span class="string">|          |     +------------+     |        |     +-----------+    |         |</span></span><br><span class="line"><span class="string">|          |     | 6: call()  |     |        |     | ...       |    |         |</span></span><br><span class="line"><span class="string">|          |     |    future  |     |        |     | 4, result |    |         |</span></span><br><span class="line"><span class="string">|          |     | ...        |     |        |     | 3, except |    |         |</span></span><br><span class="line"><span class="string">+----------+     +------------+     +--------+     +-----------+    +---------+</span></span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 是 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 的子类，它使用进程池来实现异步执行调用。 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 使用 <a href="https://docs.python.org/zh-cn/3.8/library/multiprocessing.html#module-multiprocessing" target="_blank" rel="noopener"><code>multiprocessing</code></a> 回避 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-global-interpreter-lock" target="_blank" rel="noopener">Global Interpreter Lock</a> 但也意味着只可以处理和返回可序列化的对象。</p>
<p><code>__main__</code> 模块必须可以被工作者子进程导入。这意味着 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 不可以工作在交互式解释器中。</p>
<p>从提交给 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 的回调中调用 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 方法会导致死锁。</p>
<ul>
<li><p><em>class</em> <code>concurrent.futures.ProcessPoolExecutor</code>(<em>max_workers=None</em>, <em>mp_context=None</em>, <em>initializer=None</em>, <em>initargs=()</em>)</p>
<p>异步执行调用的 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 子类使用一个最多有 <em>max_workers</em> 个进程的进程池。 如果 <em>max_workers</em> 为 <code>None</code> 或未给出，它将默认为机器的处理器个数。 如果 <em>max_workers</em> 小于等于 <code>0</code>，则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。 在 Windows 上，<em>max_workers</em> 必须小于等于 <code>61</code>，否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。 如果 <em>max_workers</em> 为 <code>None</code>，则所选择的默认最多为 <code>61</code>，即使存在更多处理器。 <em>mp_context</em> 可以是一个多进程上下文或是 None。 它将被用来启动工作者。 如果 <em>mp_context</em> 为 <code>None</code> 或未给出，将使用默认的多进程上下文。</p>
<p><em>initializer</em> 是在每个工作者进程开始处调用的一个可选可调用对象。 <em>initargs</em> 是传递给初始化器的元组参数。任何向池提交更多工作的尝试， <em>initializer</em> 都将引发一个异常，当前所有等待的工作都会引发一个 <code>BrokenProcessPool</code>。</p>
<p><em>在 3.3 版更改:</em> 如果其中一个工作进程被突然终止，<code>BrokenProcessPool</code> 就会马上触发。可预计的行为没有定义，但执行器上的操作或它的期程会被冻结或死锁。</p>
<p><em>在 3.7 版更改:</em> 添加 <em>mp_context</em> 参数允许用户控制由进程池创建给工作者进程的开始方法 。</p>
<p>加入 <em>initializer</em> 和<em>initargs</em> 参数。</p>
</li>
</ul>
<h3 id="ProcessPoolExecutor-例子"><a href="#ProcessPoolExecutor-例子" class="headerlink" title="ProcessPoolExecutor 例子"></a>ProcessPoolExecutor 例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">PRIMES = [</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">112582705942171</span>,</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">115280095190773</span>,</span><br><span class="line">    <span class="number">115797848077099</span>,</span><br><span class="line">    <span class="number">1099726899285419</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    sqrt_n = int(math.floor(math.sqrt(n)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, sqrt_n + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="keyword">for</span> number, prime <span class="keyword">in</span> zip(PRIMES, executor.map(is_prime, PRIMES)):</span><br><span class="line">            print(<span class="string">'%d is prime: %s'</span> % (number, prime))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="Future对象"><a href="#Future对象" class="headerlink" title="Future对象"></a>Future对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 类将可调用对象封装为异步执行。<a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 实例由 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor.submit" target="_blank" rel="noopener"><code>Executor.submit()</code></a> 创建。</p>
<p><em>class</em> <code>concurrent.futures.Future</code></p>
<p>将可调用对象封装为异步执行。<a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 实例由 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor.submit" target="_blank" rel="noopener"><code>Executor.submit()</code></a> 创建，除非测试，不应直接创建。</p>
<blockquote>
<ul>
<li><p><code>cancel</code>()</p>
<p>尝试取消调用。 如果调用正在执行或已结束运行不能被取消则该方法将返回 <code>False</code>，否则调用会被取消并且该方法将返回 <code>True</code>。</p>
</li>
<li><p><code>cancelled</code>()</p>
<p>如果调用成功取消返回 <code>True</code>。</p>
</li>
<li><p><code>running</code>()</p>
<p>如果调用正在执行而且不能被取消那么返回True。</p>
</li>
<li><p><code>done</code>()</p>
<p>如果调用已被取消或正常结束那么返回 <code>True</code>。</p>
</li>
<li><p><code>result</code>(<em>timeout=None</em>)</p>
<p>返回调用返回的值。如果调用还没完成那么这个方法将等待 <em>timeout</em> 秒。如果在 <em>timeout</em> 秒内没有执行完成，<a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.TimeoutError" target="_blank" rel="noopener"><code>concurrent.futures.TimeoutError</code></a> 将会被触发。<em>timeout</em> 可以是整数或浮点数。如果 <em>timeout</em> 没有指定或为 <code>None</code>，那么等待时间就没有限制。如果 futrue 在完成前被取消则 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 将被触发。如果调用引发了一个异常，这个方法也会引发同样的异常。</p>
</li>
<li><p><code>exception</code>(<em>timeout=None</em>)</p>
<p>返回由调用引发的异常。如果调用还没完成那么这个方法将等待 <em>timeout</em> 秒。如果在 <em>timeout</em> 秒内没有执行完成，<a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.TimeoutError" target="_blank" rel="noopener"><code>concurrent.futures.TimeoutError</code></a> 将会被触发。<em>timeout</em> 可以是整数或浮点数。如果 <em>timeout</em> 没有指定或为 <code>None</code>，那么等待时间就没有限制。如果 futrue 在完成前被取消则 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 将被触发。如果调用正常完成那么返回 <code>None</code>。</p>
</li>
<li><p><code>add_done_callback</code>(<em>fn</em>)</p>
<p>附加可调用 <em>fn</em> 到期程。当期程被取消或完成运行时，将会调用 <em>fn</em>，而这个期程将作为它唯一的参数。加入的可调用对象总被属于添加它们的进程中的线程按加入的顺序调用。如果可调用对象引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 子类，它会被记录下来并被忽略掉。如果可调用对象引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 子类，这个行为没有定义。如果期程已经完成或已取消，<em>fn</em> 会被立即调用。</p>
</li>
</ul>
</blockquote>
<p>下面这些 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 方法用于单元测试和 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 实现。</p>
<blockquote>
<ul>
<li><p><code>set_running_or_notify_cancel</code>()</p>
<p>这个方法只可以在执行关联 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 工作之前由 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 实现调用或由单测试调用。如果这个方法返回 <code>False</code> 那么 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 已被取消，即 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future.cancel" target="_blank" rel="noopener"><code>Future.cancel()</code></a> 已被调用并返回 <code>True</code> 。等待 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 完成 (即通过 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.as_completed" target="_blank" rel="noopener"><code>as_completed()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.wait" target="_blank" rel="noopener"><code>wait()</code></a>) 的线程将被唤醒。如果这个方法返回 <code>True</code> 那么 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 不会被取消并已将它变为正在运行状态，也就是说调用 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future.running" target="_blank" rel="noopener"><code>Future.running()</code></a> 时将返回 True。这个方法只可以被调用一次并且不能在调用 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future.set_result" target="_blank" rel="noopener"><code>Future.set_result()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future.set_exception" target="_blank" rel="noopener"><code>Future.set_exception()</code></a> 之后再调用。</p>
</li>
<li><p><code>set_result</code>(<em>result</em>)</p>
<p>设置将 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 关联工作的结果给 <em>result</em> 。这个方法只可以由 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 实现和单元测试使用。<em>在 3.8 版更改:</em> 如果 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 已经完成则此方法会引发 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.InvalidStateError" target="_blank" rel="noopener"><code>concurrent.futures.InvalidStateError</code></a>。</p>
</li>
<li><p><code>set_exception</code>(<em>exception</em>)</p>
<p>设置 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 关联工作的结果给 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> <em>exception</em> 。这个方法只可以由 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 实现和单元测试使用。<em>在 3.8 版更改:</em> 如果 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 已经完成则此方法会引发 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.InvalidStateError" target="_blank" rel="noopener"><code>concurrent.futures.InvalidStateError</code></a>。</p>
</li>
</ul>
</blockquote>
<h2 id="模块函数"><a href="#模块函数" class="headerlink" title="模块函数"></a>模块函数</h2><p><code>concurrent.futures.wait</code>(<em>fs</em>, <em>timeout=None</em>, <em>return_when=ALL_COMPLETED</em>)</p>
<p>等待 <em>fs</em> 指定的 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 实例（可能由不同的 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 实例创建）完成。 返回一个由集合构成的具名 2 元组。 第一个集合名称为 <code>done</code>，包含在等待完成之前已完成的期程（包括正常结束或被取消的期程）。 第二个集合名称为 <code>not_done</code>，包含未完成的期程（包括挂起的或正在运行的期程）。</p>
<p><em>timeout</em> 可以用来控制返回前最大的等待秒数。 <em>timeout</em> 可以为 int 或 float 类型。 如果 <em>timeout</em> 未指定或为 <code>None</code> ，则不限制等待时间。</p>
<p><em>return_when</em> 指定此函数应在何时返回。它必须为以下常数之一:</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FIRST_COMPLETED</code></td>
<td>函数将在任意可等待对象结束或取消时返回。</td>
</tr>
<tr>
<td><code>FIRST_EXCEPTION</code></td>
<td>函数将在任意可等待对象因引发异常而结束时返回。当没有引发任何异常时它就相当于 <code>ALL_COMPLETED</code>。</td>
</tr>
<tr>
<td><code>ALL_COMPLETED</code></td>
<td>函数将在所有可等待对象结束或取消时返回。</td>
</tr>
</tbody>
</table>
<p><code>concurrent.futures.as_completed</code>(<em>fs</em>, <em>timeout=None</em>)</p>
<p>返回一个包含 <em>fs</em> 所指定的 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 实例（可能由不同的 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 实例创建）的迭代器，这些实例会在完成时生成期程（包括正常结束或被取消的期程）。 任何由 <em>fs</em> 所指定的重复期程将只被返回一次。 任何在 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.as_completed" target="_blank" rel="noopener"><code>as_completed()</code></a> 被调用之前完成的期程将优先被生成。 如果 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 被调用并且在对 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.as_completed" target="_blank" rel="noopener"><code>as_completed()</code></a> 的原始调用 <em>timeout</em> 秒之后结果仍不可用，则返回的迭代器将引发 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.TimeoutError" target="_blank" rel="noopener"><code>concurrent.futures.TimeoutError</code></a>。 <em>timeout</em> 可以为整数或浮点数。 如果 <em>timeout</em> 未指定或为 <code>None</code>，则不限制等待时间。</p>
<blockquote>
<p><a href="https://www.python.org/dev/peps/pep-3148" target="_blank" rel="noopener"><strong>PEP 3148</strong></a> – futures - 异步执行指令。</p>
<p>该提案描述了Python标准库中包含的这个特性。</p>
</blockquote>
<h2 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h2><ul>
<li><p><em>exception</em> <code>concurrent.futures.CancelledError</code></p>
<p>future被取消时会触发。</p>
</li>
<li><p><em>exception</em> <code>concurrent.futures.TimeoutError</code></p>
<p>future运算超出给定的超时数值时触发。</p>
</li>
<li><p><em>exception</em> <code>concurrent.futures.BrokenExecutor</code></p>
<p>当执行器被某些原因中断而且不能用来提交或执行新任务时就会被引发派生于 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 的异常类。<em>3.7 新版功能.</em></p>
</li>
<li><p><em>exception</em> <code>concurrent.futures.InvalidStateError</code></p>
<p>当某个操作在一个当前状态所不允许的 future 上执行时将被引发。<em>3.8 新版功能.</em></p>
</li>
<li><p><em>exception</em> <code>concurrent.futures.thread.BrokenThreadPool</code></p>
<p>当 <code>ThreadPoolExecutor</code> 中的其中一个工作者初始化失败时会引发派生于 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.BrokenExecutor" target="_blank" rel="noopener"><code>BrokenExecutor</code></a> 的异常类。<em>3.7 新版功能.</em></p>
</li>
<li><p><em>exception</em> <code>concurrent.futures.process.BrokenProcessPool</code></p>
<p>当 <code>ThreadPoolExecutor</code> 中的其中一个工作者不完整终止时(比如，被外部杀死)会引发派生于 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.BrokenExecutor" target="_blank" rel="noopener"><code>BrokenExecutor</code></a> ( 原名 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> ) 的异常类。</p>
</li>
</ul>
<h2 id="补充例子"><a href="#补充例子" class="headerlink" title="补充例子"></a>补充例子</h2><h3 id="submit例子"><a href="#submit例子" class="headerlink" title="submit例子"></a><code>submit</code>例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#线程执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(n1,n2)</span>:</span></span><br><span class="line">    v = n1 + n2</span><br><span class="line">    print(<span class="string">'add :'</span>, v , <span class="string">', tid:'</span>,threading.currentThread().ident)</span><br><span class="line">    time.sleep(n1)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line"><span class="comment">#通过submit把需要执行的函数扔进线程池中.</span></span><br><span class="line"><span class="comment">#submit 直接返回一个future对象</span></span><br><span class="line">ex = ThreadPoolExecutor(max_workers=<span class="number">3</span>)      <span class="comment">#制定最多运行N个线程</span></span><br><span class="line">f1 = ex.submit(add,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">f2 = ex.submit(add,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">print(<span class="string">'main thread running'</span>)</span><br><span class="line">print(f1.done())                            <span class="comment">#done 看看任务结束了没</span></span><br><span class="line">print(f1.result())                          <span class="comment">#获取结果 ,阻塞方法</span></span><br></pre></td></tr></table></figure>
<h3 id="返回-map-例子"><a href="#返回-map-例子" class="headerlink" title="返回 map 例子"></a>返回 <code>map</code> 例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下面是map 方法的简单使用.  注意:map 返回是一个生成器 ,并且是*有序的*</span></span><br><span class="line">URLS = [<span class="string">'http://www.baidu.com'</span>, <span class="string">'http://www.qq.com'</span>, <span class="string">'http://www.sina.com.cn'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'thread id:'</span>,threading.currentThread().ident,<span class="string">' 访问了:'</span>,url)</span><br><span class="line">    <span class="keyword">return</span> requests.get(url)            <span class="comment">#这里使用了requests 模块</span></span><br><span class="line">ex = ThreadPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line">res_iter = ex.map(get_html,URLS)        <span class="comment">#内部迭代中, 每个url 开启一个线程</span></span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> res_iter:                    <span class="comment">#此时将阻塞 , 直到线程完成或异常</span></span><br><span class="line">    print(<span class="string">'url:%s ,len: %d'</span>%(res.url,len(res.text)))</span><br></pre></td></tr></table></figure>
<h3 id="as-complated-例子"><a href="#as-complated-例子" class="headerlink" title="as_complated 例子"></a><code>as_complated</code> 例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">URLS = [<span class="string">'http://www.baidu.com'</span>, <span class="string">'http://www.qq.com'</span>, <span class="string">'http://www.sina.com.cn'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'thread id:'</span>,threading.currentThread().ident,<span class="string">' 访问了:'</span>,url)</span><br><span class="line">    <span class="keyword">return</span> requests.get(url)            <span class="comment">#这里使用了requests 模块</span></span><br><span class="line">ex = ThreadPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line">f = ex.submit(get_html,URLS[<span class="number">0</span>])          <span class="comment">#提交一个任务,放入线程池中,准备执行</span></span><br><span class="line">print(<span class="string">'main thread running'</span>)</span><br><span class="line"><span class="keyword">for</span> future <span class="keyword">in</span> as_completed([f]):        <span class="comment">#as_completed()接受一个可迭代的Future序列,返回一个生成器,在完成或异常时返回这个Future对象</span></span><br><span class="line">    print(<span class="string">'一个任务完成.'</span>)</span><br><span class="line">    print(future.result())</span><br></pre></td></tr></table></figure>
<h3 id="as-complated-详细例子"><a href="#as-complated-详细例子" class="headerlink" title="as_complated 详细例子"></a><code>as_complated</code> 详细例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#as_completed 完整的例子</span></span><br><span class="line"><span class="comment">#as_completed 返回一个生成器，用于迭代， 一旦一个线程完成(或失败) 就返回</span></span><br><span class="line">URLS = [<span class="string">'http://www.baidu.com'</span>, <span class="string">'http://www.qq.com'</span>, <span class="string">'http://www.sina.com.cn'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread id:'</span>,threading.currentThread().ident,<span class="string">' 访问了:'</span>,url)</span><br><span class="line">    <span class="keyword">return</span> requests.get(url)            <span class="comment">#这里使用了requests 模块</span></span><br><span class="line">ex = ThreadPoolExecutor(max_workers=<span class="number">3</span>)   <span class="comment">#最多3个线程</span></span><br><span class="line">future_tasks = [ex.submit(get_html,url) <span class="keyword">for</span> url <span class="keyword">in</span> URLS]    <span class="comment">#创建3个future对象</span></span><br><span class="line"><span class="keyword">for</span> future <span class="keyword">in</span> as_completed(future_tasks):       <span class="comment">#迭代生成器</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = future.result()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'%s'</span>%e)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'%s has %d bytes!'</span>%(resp.url, len(resp.text)))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">thread id: 5160  访问了: http://www.baidu.com</span></span><br><span class="line"><span class="string">thread id: 7752  访问了: http://www.sina.com.cn</span></span><br><span class="line"><span class="string">thread id: 5928  访问了: http://www.qq.com</span></span><br><span class="line"><span class="string">http://www.qq.com/ has 240668 bytes!</span></span><br><span class="line"><span class="string">http://www.baidu.com/ has 2381 bytes!</span></span><br><span class="line"><span class="string">https://www.sina.com.cn/ has 577244 bytes!</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>as_complated</code> 返回的是迭代器,在迭代过程中会阻塞</li>
<li>直到线程完成或者异常时,返回一个被 <code>set_result</code>的<code>Future</code>对象</li>
<li>map方法返回的是有序的,<code>as_complated</code> 是哪个线程先完成/失败时就返回</li>
</ul>
<h3 id="wait例子（阻塞"><a href="#wait例子（阻塞" class="headerlink" title="wait例子（阻塞)"></a>wait例子（阻塞)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">wait 例子</span></span><br><span class="line"><span class="string">参数:</span></span><br><span class="line"><span class="string">    FIRST_COMPLETED    当任何未来完成或被取消时，该函数将返回。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    FIRST_EXCEPTION    当任何未来通过提出异常完成时，函数将返回。如果没有未来引发异常，那么它等同于 ALL_COMPLETED。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    ALL_COMPLETED(默认)      当所有future完成或被取消时，函数将返回。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">URLS = [<span class="string">'http://www.baidu.com'</span>, <span class="string">'http://www.qq.com'</span>, <span class="string">'http://www.sina.com.cn'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread id:'</span>,threading.currentThread().ident,<span class="string">' 访问了:'</span>,url)</span><br><span class="line">    <span class="keyword">return</span> requests.get(url)            <span class="comment">#这里使用了requests 模块</span></span><br><span class="line">ex = ThreadPoolExecutor(max_workers=<span class="number">3</span>)   <span class="comment">#最多3个线程</span></span><br><span class="line">future_tasks = [ex.submit(get_html,url) <span class="keyword">for</span> url <span class="keyword">in</span> URLS]    <span class="comment">#创建3个future对象</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = wait(future_tasks,return_when = fu.FIRST_COMPLETED)</span><br><span class="line">    done_set = result[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> done_set:</span><br><span class="line">        resp = future.result()</span><br><span class="line">        print(<span class="string">'第一个网页任务完成 url:%s , len:%d bytes! '</span> % (resp.url, len(resp.text)))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'exception :'</span> , e)</span><br></pre></td></tr></table></figure>
<h3 id="add-done-callback-fn-例子"><a href="#add-done-callback-fn-例子" class="headerlink" title="add_done__callback(fn)例子"></a><code>add_done__callback(fn)</code>例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os,sys,time,requests,threading</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">URLS = [</span><br><span class="line">        <span class="string">'http://baidu.com'</span>,</span><br><span class="line">        <span class="string">'http://www.qq.com'</span>,</span><br><span class="line">        <span class="string">'http://www.sina.com.cn'</span></span><br><span class="line">        ]</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'tid:'</span>,threading.currentThread().ident,<span class="string">',url:'</span>,url)</span><br><span class="line">    <span class="keyword">with</span> requests.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">return</span> resp.content</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_back</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid:'</span>,threading.currentThread().ident, <span class="string">',obj:'</span>,obj)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> ex:</span><br><span class="line">    <span class="comment"># mp = &#123;ex.submit(load_url,url) : url for url in URLS&#125;</span></span><br><span class="line">    mp = dict()</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> URLS:</span><br><span class="line">        f = ex.submit(load_url,url)</span><br><span class="line">        mp[f] = url</span><br><span class="line">        f.add_done_callback(call_back)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> futures.as_completed(mp):</span><br><span class="line">        url = mp[f]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = f.result()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            print(exc, <span class="string">',url:'</span>,url)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'url:'</span>, url, <span class="string">',len:'</span>,len(data),<span class="string">',data[:20]:'</span>,data[:<span class="number">20</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">tid: 7128 ,url: http://baidu.com</span></span><br><span class="line"><span class="string">tid: 7892 ,url: http://www.qq.com</span></span><br><span class="line"><span class="string">tid: 3712 ,url: http://www.sina.com.cn</span></span><br><span class="line"><span class="string">-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid: 7892 ,obj: &lt;Future at 0x2dd64b0 state=finished returned bytes&gt;</span></span><br><span class="line"><span class="string">url: http://www.qq.com ,len: 251215 ,data[:20]: b'&lt;!DOCTYPE html&gt;\n&lt;htm'</span></span><br><span class="line"><span class="string">-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid: 3712 ,obj: &lt;Future at 0x2de07b0 state=finished returned bytes&gt;</span></span><br><span class="line"><span class="string">url: http://www.sina.com.cn ,len: 577333 ,data[:20]: b'&lt;!DOCTYPE html&gt;\n&lt;!--'</span></span><br><span class="line"><span class="string">-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid: 7128 ,obj: &lt;Future at 0x2d533d0 state=finished returned bytes&gt;</span></span><br><span class="line"><span class="string">url: http://baidu.com ,len: 81 ,data[:20]: b'&lt;html&gt;\n&lt;meta http-eq'</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h3 id="futures例子"><a href="#futures例子" class="headerlink" title="futures例子"></a>futures例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os,sys,time,requests,threading</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">URLS = [</span><br><span class="line">        <span class="string">'http://baidu.com'</span>,</span><br><span class="line">        <span class="string">'http://www.qq.com'</span>,</span><br><span class="line">        <span class="string">'http://www.sina.com.cn'</span></span><br><span class="line">        ]</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'tid:'</span>,threading.currentThread().ident,<span class="string">',url:'</span>,url)</span><br><span class="line">    <span class="keyword">with</span> requests.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">return</span> resp.content</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_back</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid:'</span>,threading.currentThread().ident, <span class="string">',obj:'</span>,obj)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> ex:</span><br><span class="line">    <span class="comment"># mp = &#123;ex.submit(load_url,url) : url for url in URLS&#125;</span></span><br><span class="line">    mp = dict()</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> URLS:</span><br><span class="line">        f = ex.submit(load_url,url)</span><br><span class="line">        mp[f] = url</span><br><span class="line">        f.add_done_callback(call_back)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> futures.as_completed(mp):</span><br><span class="line">        url = mp[f]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = f.result()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            print(exc, <span class="string">',url:'</span>,url)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'url:'</span>, url, <span class="string">',len:'</span>,len(data),<span class="string">',data[:20]:'</span>,data[:<span class="number">20</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">tid: 7128 ,url: http://baidu.com</span></span><br><span class="line"><span class="string">tid: 7892 ,url: http://www.qq.com</span></span><br><span class="line"><span class="string">tid: 3712 ,url: http://www.sina.com.cn</span></span><br><span class="line"><span class="string">-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid: 7892 ,obj: &lt;Future at 0x2dd64b0 state=finished returned bytes&gt;</span></span><br><span class="line"><span class="string">url: http://www.qq.com ,len: 251215 ,data[:20]: b'&lt;!DOCTYPE html&gt;\n&lt;htm'</span></span><br><span class="line"><span class="string">-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid: 3712 ,obj: &lt;Future at 0x2de07b0 state=finished returned bytes&gt;</span></span><br><span class="line"><span class="string">url: http://www.sina.com.cn ,len: 577333 ,data[:20]: b'&lt;!DOCTYPE html&gt;\n&lt;!--'</span></span><br><span class="line"><span class="string">-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid: 7128 ,obj: &lt;Future at 0x2d533d0 state=finished returned bytes&gt;</span></span><br><span class="line"><span class="string">url: http://baidu.com ,len: 81 ,data[:20]: b'&lt;html&gt;\n&lt;meta http-eq'</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>切记一定要使用with，而不要使用for，如果你一定要用for，那么一定要手动进行executor.shutdown，而你使用了with方法的话，再with方法内部已经实现了wait(),在使用完毕之后可以自行关闭线程池，减少资源浪费。</li>
<li><code>ProcessPoolExecutor</code>类会利用multiprocessing模块所提供的底层机制，multiprocessing是基于进程的并行。</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library urllib robotparser</title>
    <url>/2020/02/04/python-standard-library-urllib-robotparser/</url>
    <content><![CDATA[<h1 id="python-标准库-urllib-robotparser"><a href="#python-标准库-urllib-robotparser" class="headerlink" title="python 标准库 urllib.robotparser"></a>python 标准库 urllib.robotparser</h1><p><img src="https://pic.superbed.cn/item/5c8e72043a213b0417a25657" alt></p>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1334059163&auto=0&height=66"></iframe>

<blockquote>
<p>一切终将过去,我们仍旧前行,如同黑暗中的舞者。 </p>
<p>​                                                              – 临风语录</p>
</blockquote>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/urllib/robotparser.py" target="_blank" rel="noopener">Lib/urllib/robotparser.py</a> </p>
<p> <code>robotparser</code> 实现了一个用于分析 <code>robots.txt</code> 文件格式的解析器， 它含有一个检查给定用户代理是否可以访问给定资源的函数。它的目的是给那些品行端正的爬虫用的，或用来指导需要节流，否则就会被限制访问的其他抓取器。</p>
<h2 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h2><p> <code>robots.txt</code> 文件是一个简单的基于文本的访问控制系统，用于控制那些自动访问网络资源的程序（如「爬虫」，「抓取器」，等等）。文件由特定的用户代理程序标识的记录以及代理不允许访问的 URLs （或 URL 前缀） 的一个列表组成。 </p>
<p>以我的博客为例</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo robots.txt</span></span><br><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: https://pinghailinfeng.gitee.io/sitemap.xml</span><br><span class="line">Sitemap: https://pinghailinfeng.gitee.io/baidusitemap.xml</span><br></pre></td></tr></table></figure>
<p><em>允许所有爬虫访问内容</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">User-Agent:  *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br></pre></td></tr></table></figure>
<p>不允许爬虫访问的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><em>class</em> <code>urllib.robotparser.RobotFileParser</code>(<em>url=’’</em>)</p>
<p>核心类通过下面方法读取、解析 通过url访问的<code>robots.txt</code>文件</p>
<ul>
<li><p><code>set_url</code>(<em>url</em>)</p>
<p>设定需要读取 <code>robots.txt</code>文件url路径</p>
</li>
<li><p><code>read</code>()</p>
<p>读取制定URL路径对应的 <code>robots.txt</code> 文件</p>
</li>
<li><p><code>parse</code>(<em>lines</em>)</p>
<p>解析参数指定的行</p>
</li>
<li><p><code>can_fetch</code>(<em>useragent</em>, <em>url</em>)</p>
<p>如果<code>useragent</code>被允许抓取<code>url</code>对应的<code>robots.txt</code>文件中包含了允许的规则,则返回<code>True</code></p>
</li>
<li><p><code>mtime</code>()</p>
<p>返回最后一次抓取<code>robots.txt</code>文件的时间。这是一个对长时间运行的网络爬虫用检查周期性<code>robots.txt</code>文件是否更新的很有用的方法。 </p>
</li>
<li><p><code>modified</code>()</p>
<p>设定最后一次抓取 <code>robots.txt</code> 文件的时间。</p>
</li>
<li><p><code>crawl_delay</code>(<em>useragent</em>)</p>
<p>返回  从<code>robots.txt</code> 中 <code>useragent</code>定义的 <code>Crawl-delay</code>  的值。如果没有这个参数或 在<code>useragent</code>中声明的参数格式不正确,返回<code>None</code>。</p>
<p><em>3.6 新版功能.</em></p>
</li>
<li><p><code>request_rate</code>(<em>useragent</em>)</p>
<p>返回作为<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-named-tuple" target="_blank" rel="noopener"><code>命名元组</code></a>类型的从  robots.txt 文件中 定义的 <code>Request-rate</code>参数内容。如果没有这个参数或在 robots.txt 文件中定义的<code>useragent</code>参数格式不正确,则返回<code>None</code>。</p>
<p><em>3.6 新版功能.</em></p>
</li>
<li><p><code>site_maps</code>()</p>
<p>返回 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list()</code></a> 类型的<code>Sitemap</code>参数内容。如果参数不存在或参数格式不正确,都返回<code>None</code>。</p>
</li>
</ul>
<h2 id="官方栗子"><a href="#官方栗子" class="headerlink" title="官方栗子"></a>官方栗子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> urllib.robotparser</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp = urllib.robotparser.RobotFileParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp.set_url(<span class="string">"http://www.musi-cal.com/robots.txt"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp.read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rrate = rp.request_rate(<span class="string">"*"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rrate.requests</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rrate.seconds</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp.crawl_delay(<span class="string">"*"</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp.can_fetch(<span class="string">"*"</span>, <span class="string">"http://www.musi-cal.com/cgi-bin/search?city=San+Francisco"</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp.can_fetch(<span class="string">"*"</span>, <span class="string">"http://www.musi-cal.com/"</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="分析知乎"><a href="#分析知乎" class="headerlink" title="分析知乎"></a>分析知乎</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">分析知乎 Robots 协议</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> urllib.robotparser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rp = urllib.robotparser.RobotFileParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 robots.txt 文件 URL</span></span><br><span class="line">rp.set_url(<span class="string">'https://www.zhihu.com/robots.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取操作必须有, 不然后面解析不到</span></span><br><span class="line">rp.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断网址是否运行爬取</span></span><br><span class="line">print(rp.can_fetch(<span class="string">'Googlebot'</span>, <span class="string">'https://www.zhihu.com/question/264161961/answer/278828570'</span>))</span><br><span class="line">print(rp.can_fetch(<span class="string">'*'</span>, <span class="string">'https://www.zhihu.com/question/264161961/answer/278828570'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回上次抓取分析 robots.txt 时间</span></span><br><span class="line">print(rp.mtime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前时间设置为上次抓取和分析 robots.txt 的时间</span></span><br><span class="line">rp.modified()</span><br><span class="line">print(rp.mtime())  <span class="comment"># 再次打印时间会有变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回 robots.txt 文件对请求速率限制的值</span></span><br><span class="line">print(rp.request_rate(<span class="string">'*'</span>))</span><br><span class="line">print(rp.request_rate(<span class="string">'MSNBot'</span>).requests)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回 robotx.txt 文件对抓取延迟限制的值</span></span><br><span class="line">print(rp.crawl_delay(<span class="string">'*'</span>))</span><br><span class="line">print(rp.crawl_delay(<span class="string">'MSNBot'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="分析我自己博客"><a href="#分析我自己博客" class="headerlink" title="分析我自己博客"></a>分析我自己博客</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.robotparser</span><br><span class="line"></span><br><span class="line">blog_url = <span class="string">'https://pinghailinfeng.gitee.io/robots.txt'</span></span><br><span class="line">rp = urllib.robotparser.RobotFileParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 robots.txt 文件 URL</span></span><br><span class="line">rp.set_url(blog_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取操作必须有, 不然后面解析不到</span></span><br><span class="line">rp.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断网址是否运行爬取</span></span><br><span class="line">print(rp.can_fetch(<span class="string">'*'</span>,<span class="string">'https://pinghailinfeng.gitee.io/archives/'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回上次抓取分析 robots.txt 时间</span></span><br><span class="line">print(rp.mtime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前时间设置为上次抓取和分析 robots.txt 的时间</span></span><br><span class="line">rp.modified()</span><br><span class="line">print(rp.mtime())  <span class="comment"># 再次打印时间会有变化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(rp.crawl_delay(<span class="string">'*'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(rp.site_maps())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1580804333.889091</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1580804333.889091</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'https://pinghailinfeng.gitee.io/sitemap.xml'</span>, <span class="string">'https://pinghailinfeng.gitee.io/baidusitemap.xml'</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>urllib.robotparser</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library copy</title>
    <url>/2020/02/02/python-standard-library-copy/</url>
    <content><![CDATA[<h1 id="python-标准库-copy"><a href="#python-标准库-copy" class="headerlink" title="python 标准库 copy"></a>python 标准库 copy</h1><p><img src="https://quotescover.com/wp-content/uploads/We-are-suffering-from-too__quotes-by-Marianne-Moore-22-1024x1024.png" alt></p>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=562888&auto=0&height=66"></iframe>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/copy.py" target="_blank" rel="noopener">Lib/copy.py</a> </p>
<p>类层次结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Interface summary:</span><br><span class="line">        <span class="keyword">import</span> copy</span><br><span class="line">        x = copy.copy(y)        <span class="comment"># make a shallow copy of y</span></span><br><span class="line">        x = copy.deepcopy(y)    <span class="comment"># make a deep copy of y</span></span><br></pre></td></tr></table></figure>
<p>Python 中赋值语句不复制对象，而是在目标和对象之间创建绑定 (bindings) 关系。对于自身可变或者包含可变项的集合对象，开发者有时会需要生成其副本用于改变操作，进而避免改变原对象。本模块提供了通用的浅层复制和深层复制操作（如下所述）。</p>
<p>接口摘要：</p>
<ul>
<li><p><code>copy.copy</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的浅层复制。</p>
</li>
<li><p><code>copy.deepcopy</code>(<em>x</em>[, <em>memo</em>])</p>
<p>返回 <em>x</em> 的深层复制。</p>
</li>
<li><p><em>exception</em> <code>copy.error</code></p>
<p>针对模块特定错误引发。</p>
</li>
</ul>
<p>浅层复制和深层复制之间的区别仅与复合对象 (即包含其他对象的对象，如列表或类的实例) 相关:</p>
<ul>
<li>一个 <em>浅层复制</em> 会构造一个新的复合对象，然后（在可能的范围内）将原对象中找到的 <em>引用</em> 插入其中。</li>
<li>一个 <em>深层复制</em> 会构造一个新的复合对象，然后递归地将原始对象中所找到的对象的 <em>副本</em> 插入。</li>
</ul>
<p>深度复制操作通常存在两个问题, 而浅层复制操作并不存在这些问题：</p>
<ul>
<li>递归对象 (直接或间接包含对自身引用的复合对象) 可能会导致递归循环。</li>
<li>由于深层复制会复制所有内容，因此可能会过多复制（例如本应该在副本之间共享的数据）。</li>
</ul>
<p>The <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#copy.deepcopy" target="_blank" rel="noopener"><code>deepcopy()</code></a> function avoids these problems by:</p>
<ul>
<li>保留在当前复制过程中已复制的对象的 “备忘录” （<code>memo</code>） 字典；以及</li>
<li>允许用户定义的类重载复制操作或复制的组件集合。</li>
</ul>
<p>该模块不复制模块、方法、栈追踪（stack trace）、栈帧（stack frame）、文件、套接字、窗口、数组以及任何类似的类型。它通过不改变地返回原始对象来（浅层或深层地）“复制”函数和类；这与 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块处理这类问题的方式是相似的。</p>
<p>制作字典的浅层复制可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.copy" target="_blank" rel="noopener"><code>dict.copy()</code></a> 方法，而制作列表的浅层复制可以通过赋值整个列表的切片完成，例如，<code>copied_list = original_list[:]</code>。</p>
<p>类可以使用与控制序列化（pickling）操作相同的接口来控制复制操作，关于这些方法的描述信息请参考 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块。实际上，<a href="https://docs.python.org/zh-cn/3.8/library/copy.html#module-copy" target="_blank" rel="noopener"><code>copy</code></a> 模块使用的正是从 <a href="https://docs.python.org/zh-cn/3.8/library/copyreg.html#module-copyreg" target="_blank" rel="noopener"><code>copyreg</code></a> 模块中注册的 pickle 函数。</p>
<p>想要给一个类定义它自己的拷贝操作实现，可以通过定义特殊方法 <code>__copy__()</code> 和 <code>__deepcopy__()</code>。 调用前者以实现浅层拷贝操作，该方法不用传入额外参数。 调用后者以实现深层拷贝操作；它应传入一个参数即 <code>memo</code> 字典。 如果 <code>__deepcopy__()</code> 实现需要创建一个组件的深层拷贝，它应当调用 <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#copy.deepcopy" target="_blank" rel="noopener"><code>deepcopy()</code></a> 函数并以该组件作为第一个参数，而将 memo 字典作为第二个参数。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="字典拷贝"><a href="#字典拷贝" class="headerlink" title="字典拷贝"></a>字典拷贝</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">displayList</span><span class="params">(text, dictOfElements)</span> :</span></span><br><span class="line">    print(<span class="string">"--------"</span>)</span><br><span class="line">    print(text)</span><br><span class="line">    <span class="keyword">for</span> key , value <span class="keyword">in</span> dictOfElements.items():</span><br><span class="line">        print(key, <span class="string">" :: "</span>, value)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Dictionary of strings and ints</span></span><br><span class="line">    wordsDict = &#123;</span><br><span class="line">        <span class="string">"Hello"</span>: <span class="number">56</span>,</span><br><span class="line">        <span class="string">"at"</span> : <span class="number">23</span> ,</span><br><span class="line">        <span class="string">"test"</span> : <span class="number">43</span>,</span><br><span class="line">        <span class="string">"this"</span> : <span class="number">43</span>,</span><br><span class="line">        <span class="string">"who"</span> : [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Shallow Copying dictionaries using dict.copy()</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    print(<span class="string">"***** Shallow Copy *********"</span>)</span><br><span class="line">    </span><br><span class="line">    displayList(<span class="string">"Original Dictionary : "</span> , wordsDict)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># create a Shallow copy  the original dictionary</span></span><br><span class="line">    newDict = wordsDict.copy()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Modify the value of key in new dictionary</span></span><br><span class="line">    newDict[<span class="string">"at"</span>] = <span class="number">200</span></span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"Contents of copied dictionary changed"</span>)</span><br><span class="line"> </span><br><span class="line">    displayList(<span class="string">"Modified copied dictionary : "</span> , newDict)</span><br><span class="line">    </span><br><span class="line">    displayList(<span class="string">"Original Dictionary : "</span> , wordsDict)</span><br><span class="line"> </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Modify the contents of list object in shallow copied dictionary will </span></span><br><span class="line"><span class="string">    modify the contents of original dictionary too because its a shallow copy. </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    newDict[<span class="string">"who"</span>].append(<span class="number">222</span>)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"Contents of list in copied dictionary changed"</span>)</span><br><span class="line"> </span><br><span class="line">    displayList(<span class="string">"Modified copied dictionary : "</span> , newDict)</span><br><span class="line">    </span><br><span class="line">    displayList(<span class="string">"Original Dictionary : "</span> , wordsDict)</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">"***** Deep Copy *******"</span>)</span><br><span class="line">    </span><br><span class="line">    displayList(<span class="string">"Original Dictionary : "</span> , wordsDict)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Create a deep copy of the dictionary</span></span><br><span class="line">    otherDict = copy.deepcopy(wordsDict)</span><br><span class="line">    </span><br><span class="line">    displayList(<span class="string">"Deep copy of  Dictionary : "</span> , otherDict)</span><br><span class="line">    </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Modify the contents of list object in deep copied dictionary will </span></span><br><span class="line"><span class="string">    have no impact on original dictionary because its a deep copy.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    newDict[<span class="string">"who"</span>].append(<span class="number">100</span>)</span><br><span class="line"> </span><br><span class="line">    displayList(<span class="string">"Modified Deep copy of Dictionary : "</span> , otherDict)</span><br><span class="line">    displayList(<span class="string">"Original Dictionary : "</span> , wordsDict)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">--------</span><br><span class="line">Original Dictionary : </span><br><span class="line">at  ::  <span class="number">23</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>]</span><br><span class="line">Contents of copied dictionary changed</span><br><span class="line">--------</span><br><span class="line">Modified copied dictionary : </span><br><span class="line">at  ::  <span class="number">200</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>]</span><br><span class="line">--------</span><br><span class="line">Original Dictionary : </span><br><span class="line">at  ::  <span class="number">23</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>]</span><br><span class="line">Contents of list <span class="keyword">in</span> copied dictionary changed</span><br><span class="line">--------</span><br><span class="line">Modified copied dictionary : </span><br><span class="line">at  ::  <span class="number">200</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">222</span>]</span><br><span class="line">--------</span><br><span class="line">Original Dictionary : </span><br><span class="line">at  ::  <span class="number">23</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">222</span>]</span><br><span class="line">***** Deep Copy *******</span><br><span class="line">--------</span><br><span class="line">Original Dictionary : </span><br><span class="line">at  ::  <span class="number">23</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">222</span>]</span><br><span class="line">--------</span><br><span class="line">Deep copy of  Dictionary : </span><br><span class="line">at  ::  <span class="number">23</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">222</span>]</span><br><span class="line">--------</span><br><span class="line">Modified Deep copy of Dictionary : </span><br><span class="line">at  ::  <span class="number">23</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">222</span>]</span><br><span class="line">--------</span><br><span class="line">Original Dictionary : </span><br><span class="line">at  ::  <span class="number">23</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">222</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<h3 id="列表拷贝"><a href="#列表拷贝" class="headerlink" title="列表拷贝"></a>列表拷贝</h3><p>浅拷贝</p>
<p>使用 <code>=</code>赋值运算符 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">old_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="string">'a'</span>]]</span><br><span class="line">new_list = old_list</span><br><span class="line"></span><br><span class="line">new_list[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Old List:'</span>, old_list)</span><br><span class="line">print(<span class="string">'ID of Old List:'</span>, id(old_list))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'New List:'</span>, new_list)</span><br><span class="line">print(<span class="string">'ID of New List:'</span>, id(new_list))</span><br></pre></td></tr></table></figure>
<p>使用<code>copy</code>浅拷贝</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">old_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">new_list = copy.copy(old_list)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Old list:"</span>, old_list)</span><br><span class="line">print(<span class="string">"New list:"</span>, new_list)</span><br></pre></td></tr></table></figure>
<p>使用<code>deepcopy</code> 深拷贝</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">old_list = [[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]]</span><br><span class="line">new_list = copy.deepcopy(old_list)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Old list:"</span>, old_list)</span><br><span class="line">print(<span class="string">"New list:"</span>, new_list)</span><br></pre></td></tr></table></figure>
<h3 id="类拷贝"><a href="#类拷贝" class="headerlink" title="类拷贝"></a>类拷贝</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Point(<span class="subst">&#123;self.x!r&#125;</span>, <span class="subst">&#123;self.y!r&#125;</span>)'</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Point(<span class="number">23</span>, <span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = copy.copy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">Point(<span class="number">23</span>, <span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">Point(<span class="number">23</span>, <span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用copy模块的copy方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, topleft, bottomright)</span>:</span></span><br><span class="line">        self.topleft = topleft</span><br><span class="line">        self.bottomright = bottomright</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">f'Rectangle(<span class="subst">&#123;self.topleft!r&#125;</span>, '</span></span><br><span class="line">                <span class="string">f'<span class="subst">&#123;self.bottomright!r&#125;</span>)'</span>)</span><br><span class="line">rect = Rectangle(Point(<span class="number">0</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">srect = copy.copy(rect)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect</span><br><span class="line">Rectangle(Point(<span class="number">0</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>srect</span><br><span class="line">Rectangle(Point(<span class="number">0</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect <span class="keyword">is</span> srect</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect.topleft.x = <span class="number">999</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect</span><br><span class="line">Rectangle(Point(<span class="number">999</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>srect</span><br><span class="line">Rectangle(Point(<span class="number">999</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>drect = copy.deepcopy(srect)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>drect.topleft.x = <span class="number">222</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>drect</span><br><span class="line">Rectangle(Point(<span class="number">222</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect</span><br><span class="line">Rectangle(Point(<span class="number">999</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>srect</span><br><span class="line">Rectangle(Point(<span class="number">999</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment">## 使用copy方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, topleft, bottomright)</span>:</span></span><br><span class="line">        self.topleft = topleft</span><br><span class="line">        self.bottomright = bottomright</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">f'Rectangle(<span class="subst">&#123;self.topleft!r&#125;</span>, '</span></span><br><span class="line">                <span class="string">f'<span class="subst">&#123;self.bottomright!r&#125;</span>)'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Rectangle(self.topleft, self.bottomright)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r1  = Rectangle(<span class="number">20</span>,<span class="number">30</span>)</span><br><span class="line">r2  =r1.copy()</span><br><span class="line">print(<span class="string">"r1:"</span>,r1)</span><br><span class="line">print(<span class="string">"r2:"</span>,r2)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r1: Rectangle(<span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r2: Rectangle(<span class="number">20</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<h3 id="一个深入的例子"><a href="#一个深入的例子" class="headerlink" title="一个深入的例子"></a>一个深入的例子</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></span><br><span class="line">    x = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">CopyOfB = type(<span class="string">'CopyOfB'</span>, B.__bases__, dict(B.__dict__))</span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line">cob = CopyOfB()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> b.x   <span class="comment"># Prints '3'</span></span><br><span class="line"><span class="keyword">print</span> cob.x <span class="comment"># Prints '3'</span></span><br><span class="line"></span><br><span class="line">b.x = <span class="number">2</span></span><br><span class="line">cob.x = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> b.x   <span class="comment"># Prints '2'</span></span><br><span class="line"><span class="keyword">print</span> cob.x <span class="comment"># Prints '4'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line">    x = []</span><br><span class="line"></span><br><span class="line">CopyOfC = type(<span class="string">'CopyOfC'</span>, C.__bases__, dict(C.__dict__))</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">coc = CopyOfC()</span><br><span class="line"></span><br><span class="line">c.x.append(<span class="number">1</span>)</span><br><span class="line">coc.x.append(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> c.x   <span class="comment"># Prints '[1, 2]' (!)</span></span><br><span class="line"><span class="keyword">print</span> coc.x <span class="comment"># Prints '[1, 2]' (!)</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://stackoverflow.com/questions/17873384/how-to-deep-copy-a-list" target="_blank" rel="noopener">how to deep copy a list</a></p>
<p><a href="https://www.programiz.com/python-programming/shallow-deep-copy" target="_blank" rel="noopener">shallow-deep-copy</a></p>
<p><a href="https://stackoverflow.com/questions/9541025/how-to-copy-a-python-class" target="_blank" rel="noopener">how-to-copy-a-python-class</a></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最近学到一个新词:<code>共克时艰</code> 翻译成 英文 <code>We are suffering</code>,希望和朋友们共勉。</p>
<blockquote>
<p>我们都是蝴蝶翅膀上的那粒灰尘，被裹挟在龙卷风里，谁都晕头转向</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>copy</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library functools</title>
    <url>/2020/02/01/python-standard-library-functools/</url>
    <content><![CDATA[<h1 id="python-标准库-functools-高阶函数工具"><a href="#python-标准库-functools-高阶函数工具" class="headerlink" title="python 标准库 functools 高阶函数工具"></a>python 标准库 functools 高阶函数工具</h1><p><img src="http://s3-eu-west-1.amazonaws.com/sup46/wp-content/uploads/2016/06/15100010/Attach-sup46.png" alt></p>
<a id="more"></a>
<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=539420&auto=0&height=66"></iframe><br>每日一词:</p>
<p>这里我们换种记忆方法 ,词根 <code>tach</code>代表 固定</p>
<blockquote>
<p>attach </p>
<p>英 [əˈtætʃ]  美 [əˈtætʃ]  </p>
<p>vt.&amp; vi. 贴上，系； 附上；</p>
<p>vt.（有时不受欢迎或未受邀请而）参加； 把…固定； 把…归因于； （使）与…有联系</p>
<p>vi. 从属； 附着； 伴随而来； 联在一起(to, upon)</p>
<p>attachment  n 邮件的附件</p>
<p>de 是反义前缀</p>
<p>detach v 分离</p>
<p>detached  adj  冷漠的,离群的</p>
<p>detachment  n 公平 </p>
</blockquote>
<p><a href="https://docs.python.org/zh-cn/3.8/library/functools.html#module-functools" target="_blank" rel="noopener"><code>functools</code></a> 模块应用于高阶函数，即参数或（和）返回值为其他函数的函数。 通常来说，此模块的功能适用于所有可调用对象。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/functools.html#module-functools" target="_blank" rel="noopener"><code>functools</code></a> 模块定义了以下函数:</p>
<ul>
<li><p><a href="mailto:`@functools.cache" target="_blank" rel="noopener">`@functools.cache</a>d_property`(<em>func</em>)</p>
<p>将一个类方法转换为特征属性，一次性计算该特征属性的值，然后将其缓存为实例生命周期内的普通属性。 类似于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#property" target="_blank" rel="noopener"><code>property()</code></a> 但增加了缓存功能。 对于在其他情况下实际不可变的高计算资源消耗的实例特征属性来说该函数非常有用。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSet</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sequence_of_numbers)</span>:</span></span><br><span class="line">        self._data = sequence_of_numbers</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cached_property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stdev</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> statistics.stdev(self._data)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cached_property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">variance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> statistics.variance(self._data)</span><br></pre></td></tr></table></figure>
<p><em>3.8 新版功能.</em></p>
<blockquote>
<p>此装饰器要求每个实例上的 <code>__dict__</code> 属性是可变的映射。 这意味着它将不适用于某些类型，例如元类（因为类型实例上的 <code>__dict__</code> 属性是类命名空间的只读代理），以及那些指定了 <code>__slots__</code> 但未包含 <code>__dict__</code> 作为所定义的空位之一的类（因为这样的类根本没有提供 <code>__dict__</code> 属性）。</p>
</blockquote>
</li>
<li><p><code>functools.cmp_to_key</code>(<em>func</em>)</p>
<p>将(旧式的)比较函数转换为新式的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-key-function" target="_blank" rel="noopener">key function</a> . 在类似于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#min" target="_blank" rel="noopener"><code>min()</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#max" target="_blank" rel="noopener"><code>max()</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.nlargest" target="_blank" rel="noopener"><code>heapq.nlargest()</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.nsmallest" target="_blank" rel="noopener"><code>heapq.nsmallest()</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.groupby" target="_blank" rel="noopener"><code>itertools.groupby()</code></a> 等函数的 key 参数中使用。此函数主要用作将 Python 2 程序转换至新版的转换工具，以保持对比较函数的兼容。比较函数意为一个可调用对象，该对象接受两个参数并比较它们，结果为小于则返回一个负数，相等则返回零，大于则返回一个正数。key function则是一个接受一个参数，并返回另一个用以排序的值的可调用对象。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sorted(iterable, key=cmp_to_key(locale.strcoll))  <span class="comment"># locale-aware sort order</span></span><br></pre></td></tr></table></figure>
<p>有关排序示例和简要排序教程，请参阅 <a href="https://docs.python.org/zh-cn/3.8/howto/sorting.html#sortinghowto" target="_blank" rel="noopener">排序指南</a> 。<em>3.2 新版功能.</em></p>
</li>
<li><p><a href="mailto:`@functools.lr" target="_blank" rel="noopener">`@functools.lr</a>u_cache`(<em>user_function</em>)</p>
</li>
<li><p><a href="mailto:`@functools.lr" target="_blank" rel="noopener">`@functools.lr</a>u_cache`(<em>maxsize=128</em>, <em>typed=False</em>)</p>
<p>一个为函数提供缓存功能的装饰器，缓存 <em>maxsize</em> 组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或I/O函数的调用时间。</p>
<p>由于使用了字典存储缓存，所以该函数的固定参数和关键字参数必须是可哈希的。</p>
<p>不同模式的参数可能被视为不同从而产生多个缓存项，例如, f(a=1, b=2) 和 f(b=2, a=1) 因其参数顺序不同，可能会被缓存两次。</p>
<p>如果指定了 <em>user_function</em>，它必须是一个可调用对象。 这允许 <em>lru_cache</em> 装饰器被直接应用于一个用户自定义函数，让 <em>maxsize</em> 保持其默认值 128:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@lru_cache</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_vowels</span><span class="params">(sentence)</span>:</span></span><br><span class="line">    sentence = sentence.casefold()</span><br><span class="line">    <span class="keyword">return</span> sum(sentence.count(vowel) <span class="keyword">for</span> vowel <span class="keyword">in</span> <span class="string">'aeiou'</span>)</span><br></pre></td></tr></table></figure>
<p>如果 <em>maxsize</em> 设置为 <code>None</code> ，LRU功能将被禁用且缓存数量无上限。 <em>maxsize</em> 设置为2的幂时可获得最佳性能。</p>
<p>如果 <em>typed</em> 设置为true，不同类型的函数参数将被分别缓存。例如， <code>f(3)</code> 和 <code>f(3.0)</code> 将被视为不同而分别缓存。</p>
<p>为了衡量缓存的有效性以便调整 <em>maxsize</em> 形参，被装饰的函数带有一个 <code>cache_info()</code> 函数。当调用 <code>cache_info()</code> 函数时，返回一个具名元组，包含命中次数 <em>hits</em>，未命中次数 <em>misses</em> ，最大缓存数量 <em>maxsize</em> 和 当前缓存大小 <em>currsize</em>。在多线程环境中，命中数与未命中数是不完全准确的。</p>
<p>该装饰器也提供了一个用于清理/使缓存失效的函数 <code>cache_clear()</code> 。</p>
<p>原始的未经装饰的函数可以通过 <code>__wrapped__</code> 属性访问。它可以用于检查、绕过缓存，或使用不同的缓存再次装饰原始函数。</p>
<p><a href="https://en.wikipedia.org/wiki/Cache_algorithms#Examples" target="_blank" rel="noopener">“最久未使用算法”（LRU）缓存</a> 在“最近的调用是即将到来的调用的最佳预测因子”时性能最好（比如，新闻服务器上最受欢迎的文章倾向于每天更改）。 “缓存大小限制”参数保证缓存不会在长时间运行的进程比如说网站服务器上无限制的增加自身的大小。</p>
<p>一般来说，LRU缓存只在当你想要重用之前计算的结果时使用。因此，用它缓存具有副作用的函数、需要在每次调用时创建不同、易变的对象的函数或者诸如time（）或random（）之类的不纯函数是没有意义的。</p>
<p>静态 Web 内容的 LRU 缓存示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@lru_cache(maxsize=32)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pep</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="string">'Retrieve text of a Python Enhancement Proposal'</span></span><br><span class="line">    resource = <span class="string">'http://www.python.org/dev/peps/pep-%04d/'</span> % num</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> urllib.request.urlopen(resource) <span class="keyword">as</span> s:</span><br><span class="line">            <span class="keyword">return</span> s.read()</span><br><span class="line">    <span class="keyword">except</span> urllib.error.HTTPError:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Not Found'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">8</span>, <span class="number">290</span>, <span class="number">308</span>, <span class="number">320</span>, <span class="number">8</span>, <span class="number">218</span>, <span class="number">320</span>, <span class="number">279</span>, <span class="number">289</span>, <span class="number">320</span>, <span class="number">9991</span>:</span><br><span class="line"><span class="meta">... </span>    pep = get_pep(n)</span><br><span class="line"><span class="meta">... </span>    print(n, len(pep))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_pep.cache_info()</span><br><span class="line">CacheInfo(hits=<span class="number">3</span>, misses=<span class="number">8</span>, maxsize=<span class="number">32</span>, currsize=<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>以下是使用缓存通过 <a href="https://zh.wikipedia.org/wiki/动态规划" target="_blank" rel="noopener">动态规划</a> 计算 <a href="https://zh.wikipedia.org/wiki/斐波那契数列" target="_blank" rel="noopener">斐波那契数列</a> 的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@lru_cache(maxsize=None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[fib(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">16</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">144</span>, <span class="number">233</span>, <span class="number">377</span>, <span class="number">610</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib.cache_info()</span><br><span class="line">CacheInfo(hits=<span class="number">28</span>, misses=<span class="number">16</span>, maxsize=<span class="literal">None</span>, currsize=<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p><em>在 3.3 版更改:</em> 添加 <em>typed</em> 选项。</p>
<p><em>在 3.8 版更改:</em> 添加了 <em>user_function</em> 选项。</p>
</li>
<li><p><a href="mailto:`@functools.tota" target="_blank" rel="noopener">`@functools.tota</a>l_ordering`</p>
<p>给定一个声明一个或多个全比较排序方法的类，这个类装饰器实现剩余的方法。这减轻了指定所有可能的全比较操作的工作。</p>
<p>此类必须包含以下方法之一：<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__lt__" target="_blank" rel="noopener"><code>__lt__()</code></a> 、<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__le__" target="_blank" rel="noopener"><code>__le__()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__gt__" target="_blank" rel="noopener"><code>__gt__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__ge__" target="_blank" rel="noopener"><code>__ge__()</code></a>。另外，此类必须支持 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> 方法。</p>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@total_ordering</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_is_valid_operand</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (hasattr(other, <span class="string">"lastname"</span>) <span class="keyword">and</span></span><br><span class="line">                hasattr(other, <span class="string">"firstname"</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._is_valid_operand(other):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">        <span class="keyword">return</span> ((self.lastname.lower(), self.firstname.lower()) ==</span><br><span class="line">                (other.lastname.lower(), other.firstname.lower()))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._is_valid_operand(other):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">        <span class="keyword">return</span> ((self.lastname.lower(), self.firstname.lower()) &lt;</span><br><span class="line">                (other.lastname.lower(), other.firstname.lower()))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然此装饰器使得创建具有良好行为的完全有序类型变得非常容易，但它 <em>确实</em> 是以执行速度更缓慢和派生比较方法的堆栈回溯更复杂为代价的。 如果性能基准测试表明这是特定应用的瓶颈所在，则改为实现全部六个富比较方法应该会轻松提升速度。 </p>
</blockquote>
<p> <em>在 3.4 版更改:</em> 现在已支持从未识别类型的下层比较函数返回 NotImplemented 异常。 </p>
</li>
<li><p><code>functools.partial</code>(<em>func</em>, <em>/</em>, <strong>args<em>, </em></strong>keywords*)</p>
<p> 返回一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#partial-objects" target="_blank" rel="noopener">部分对象</a>，当被调用时其行为类似于 <em>func</em> 附带位置参数 <em>args</em> 和关键字参数 <em>keywords</em> 被调用。 如果为调用提供了更多的参数，它们会被附加到 <em>args</em>。 如果提供了额外的关键字参数，它们会扩展并重载 <em>keywords</em>。 大致等价于: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial</span><span class="params">(func, /, *args, **keywords)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newfunc</span><span class="params">(*fargs, **fkeywords)</span>:</span></span><br><span class="line">        newkeywords = &#123;**keywords, **fkeywords&#125;</span><br><span class="line">        <span class="keyword">return</span> func(*args, *fargs, **newkeywords)</span><br><span class="line">    newfunc.func = func</span><br><span class="line">    newfunc.args = args</span><br><span class="line">    newfunc.keywords = keywords</span><br><span class="line">    <span class="keyword">return</span> newfunc</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial()</code></a> 会被“冻结了”一部分函数参数和/或关键字的部分函数应用所使用，从而得到一个具有简化签名的新对象。 例如，<a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial()</code></a> 可用来创建一个行为类似于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int()</code></a> 函数的可调用对象，其中 <em>base</em> 参数默认为二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basetwo = partial(int, base=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basetwo.__doc__ = <span class="string">'Convert base 2 string to an int.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basetwo(<span class="string">'10010'</span>)</span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><em>class</em> <code>functools.partialmethod</code>(<em>func</em>, <em>/</em>, <strong>args<em>, </em></strong>keywords*)</p>
<p>返回一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partialmethod" target="_blank" rel="noopener"><code>partialmethod</code></a> 描述器，其行为类似 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 但它被设计用作方法定义而非直接用作可调用对象。</p>
<p><em>func</em> 必须是一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-descriptor" target="_blank" rel="noopener">descriptor</a> 或可调用对象（同属两者的对象例如普通函数会被当作描述器来处理）。</p>
<p>当 <em>func</em> 是一个描述器（例如普通 Python 函数, <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#classmethod" target="_blank" rel="noopener"><code>classmethod()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#staticmethod" target="_blank" rel="noopener"><code>staticmethod()</code></a>, <code>abstractmethod()</code> 或其他 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partialmethod" target="_blank" rel="noopener"><code>partialmethod</code></a> 的实例）时, 对 <code>__get__</code> 的调用会被委托给底层的描述器，并会返回一个适当的 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#partial-objects" target="_blank" rel="noopener">部分对象</a> 作为结果。</p>
<p>当 <em>func</em> 是一个非描述器类可调用对象时，则会动态创建一个适当的绑定方法。 当用作方法时其行为类似普通 Python 函数：将会插入 <em>self</em> 参数作为第一个位置参数，其位置甚至会处于提供给 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partialmethod" target="_blank" rel="noopener"><code>partialmethod</code></a> 构造器的 <em>args</em> 和 <em>keywords</em> 之前。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Cell</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._alive = <span class="literal">False</span></span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">alive</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self._alive</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">set_state</span><span class="params">(self, state)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._alive = bool(state)</span><br><span class="line"><span class="meta">... </span>    set_alive = partialmethod(set_state, <span class="literal">True</span>)</span><br><span class="line"><span class="meta">... </span>    set_dead = partialmethod(set_state, <span class="literal">False</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Cell()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.alive</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.set_alive()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.alive</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>functools.reduce</code>(<em>function</em>, <em>iterable</em>[, <em>initializer</em>])</p>
<p>将两个参数的 <em>function</em> 从左至右积累地应用到 <em>iterable</em> 的条目，以便将该可迭代对象缩减为单一的值。 例如，<code>reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])</code> 是计算 <code>((((1+2)+3)+4)+5)</code> 的值。 左边的参数 <em>x</em> 是积累值而右边的参数 <em>y</em> 则是来自 <em>iterable</em> 的更新值。 如果存在可选项 <em>initializer</em>，它会被放在参与计算的可迭代对象的条目之前，并在可迭代对象为空时作为默认值。 如果没有给出 <em>initializer</em> 并且 <em>iterable</em> 仅包含一个条目，则将返回第一项。</p>
<p>大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span><span class="params">(function, iterable, initializer=None)</span>:</span></span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    <span class="keyword">if</span> initializer <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        value = next(it)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = initializer</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">        value = function(value, element)</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>
<p>请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.accumulate" target="_blank" rel="noopener"><code>itertools.accumulate()</code></a> 了解有关可产生所有中间值的迭代器。</p>
</li>
<li><p><a href="mailto:`@functools.singledispatch" target="_blank" rel="noopener">`@functools.singledispatch</a>`</p>
<p>将一个函数转换为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-single-dispatch" target="_blank" rel="noopener">单分派</a> <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generic-function" target="_blank" rel="noopener">generic function</a>。</p>
<p>要定义一个泛型函数，应使用 <code>@singledispatch</code> 装饰器进行装饰。 请注意分派是作用于第一个参数的类型，要相应地创建你的函数:</p>
<p>>&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@singledispatch</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(arg, verbose=False)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> verbose:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Let me just say,"</span>, end=<span class="string">" "</span>)</span><br><span class="line"><span class="meta">... </span>    print(arg)</span><br></pre></td></tr></table></figure>
<p>要将重载的实现添加到函数中，请使用泛型函数的 <code>register()</code> 属性。 它是一个装饰器。 对于带有类型标注的函数，该装饰器将自动推断第一个参数的类型:</p>
<p>>&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@fun.register</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(arg: int, verbose=False)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> verbose:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Strength in numbers, eh?"</span>, end=<span class="string">" "</span>)</span><br><span class="line"><span class="meta">... </span>    print(arg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@fun.register</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(arg: list, verbose=False)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> verbose:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Enumerate this:"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i, elem <span class="keyword">in</span> enumerate(arg):</span><br><span class="line"><span class="meta">... </span>        print(i, elem)</span><br></pre></td></tr></table></figure>
<p>对于不使用类型标注的代码，可以将适当的类型参数显式地传给装饰器本身:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@fun.register(complex)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(arg, verbose=False)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> verbose:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Better than complicated."</span>, end=<span class="string">" "</span>)</span><br><span class="line"><span class="meta">... </span>    print(arg.real, arg.imag)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>要启用注册 lambda 和现有函数，可以使用函数形式的 <code>register()</code> 属性:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">nothing</span><span class="params">(arg, verbose=False)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Nothing."</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun.register(type(<span class="literal">None</span>), nothing)</span><br></pre></td></tr></table></figure>
<p><code>register()</code> 属性将返回启用了装饰器堆栈、封存的未装饰函数，并会为每个变量单独创建单元测试:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@fun.register(float)</span><br><span class="line"><span class="meta">... </span>@fun.register(Decimal)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">fun_num</span><span class="params">(arg, verbose=False)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> verbose:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Half of your number:"</span>, end=<span class="string">" "</span>)</span><br><span class="line"><span class="meta">... </span>    print(arg / <span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun_num <span class="keyword">is</span> fun</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>在调用时，泛型函数会根据第一个参数的类型进行分派:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(<span class="string">"Hello, world."</span>)</span><br><span class="line">Hello, world.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(<span class="string">"test."</span>, verbose=<span class="literal">True</span>)</span><br><span class="line">Let me just say, test.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(<span class="number">42</span>, verbose=<span class="literal">True</span>)</span><br><span class="line">Strength in numbers, eh? 42</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun([<span class="string">'spam'</span>, <span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'spam'</span>], verbose=<span class="literal">True</span>)</span><br><span class="line">Enumerate this:</span><br><span class="line"><span class="number">0</span> spam</span><br><span class="line"><span class="number">1</span> spam</span><br><span class="line"><span class="number">2</span> eggs</span><br><span class="line"><span class="number">3</span> spam</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(<span class="literal">None</span>)</span><br><span class="line">Nothing.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(<span class="number">1.23</span>)</span><br><span class="line"><span class="number">0.615</span></span><br></pre></td></tr></table></figure>
<p>在没有用于特定类型的已注册实现的情况下，则会使用其方法解析顺序来查找更通用的实现。 以 <code>@singledispatch</code> 装饰的原始函数将为最基本的 <code>object</code> 类型进行注册，这意味着它将在找不到更好的实现时被使用。</p>
<p>要检查泛型函数将为给定类型选择哪个实现，请使用 <code>dispatch()</code> 属性:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun.dispatch(float)</span><br><span class="line">&lt;function fun_num at <span class="number">0x1035a2840</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun.dispatch(dict)    <span class="comment"># note: default implementation</span></span><br><span class="line">&lt;function fun at <span class="number">0x103fe0000</span>&gt;</span><br></pre></td></tr></table></figure>
<p>要访问所有忆注册实现，请使用只读的 <code>registry</code> 属性:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun.registry.keys()</span><br><span class="line">dict_keys([&lt;class 'NoneType'&gt;, &lt;class 'int'&gt;, &lt;class 'object'&gt;,</span><br><span class="line">          &lt;class 'decimal.Decimal'&gt;, &lt;class 'list'&gt;,</span><br><span class="line">          &lt;<span class="class"><span class="keyword">class</span> '<span class="title">float</span>'&gt;])</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">fun</span>.<span class="title">registry</span>[<span class="title">float</span>]</span></span><br><span class="line"><span class="class">&lt;<span class="title">function</span> <span class="title">fun_num</span> <span class="title">at</span> 0<span class="title">x1035a2840</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">fun</span>.<span class="title">registry</span>[<span class="title">object</span>]</span></span><br><span class="line"><span class="class">&lt;<span class="title">function</span> <span class="title">fun</span> <span class="title">at</span> 0<span class="title">x103fe0000</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <em>在 3.7 版更改:</em> <code>register()</code> 属性支持使用类型标注。 </p>
</li>
<li><p><em>class</em> <code>functools.singledispatchmethod</code>(<em>func</em>)</p>
<p>将一个方法转换为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-single-dispatch" target="_blank" rel="noopener">单分派</a> <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generic-function" target="_blank" rel="noopener">generic function</a>。</p>
<p>要定义一个泛型方法，应使用 <code>@singledispatchmethod</code> 装饰器进行装饰。 请注意分派是作用于第一个非 self 或非 cls 参数的类型，要相应地创建你的函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Negator</span>:</span></span><br><span class="line"><span class="meta">    @singledispatchmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">neg</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"Cannot negate a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @neg.register</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(self, arg: int)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -arg</span><br><span class="line"></span><br><span class="line"><span class="meta">    @neg.register</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(self, arg: bool)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> arg</span><br></pre></td></tr></table></figure>
<p><code>@singledispatchmethod</code> 支持与其他装饰器如 <code>@classmethod</code> 相嵌套。 请注意如果要允许 <code>dispatcher.register</code>，则 <code>singledispatchmethod</code> 必须是 <em>最外层</em> 的装饰器。 下面的示例定义了 <code>Negator</code> 类，其中包含绑定到类的 <code>neg</code> 方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Negator</span>:</span></span><br><span class="line"><span class="meta">    @singledispatchmethod</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">neg</span><span class="params">(cls, arg)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"Cannot negate a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @neg.register</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(cls, arg: int)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -arg</span><br><span class="line"></span><br><span class="line"><span class="meta">    @neg.register</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(cls, arg: bool)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> arg</span><br></pre></td></tr></table></figure>
<p>同样的模式也被用于其他类似的装饰器: <code>staticmethod</code>, <code>abstractmethod</code> 等等。</p>
<p> <em>3.8 新版功能.</em> </p>
</li>
<li><p><code>functools.update_wrapper</code>(<em>wrapper</em>, <em>wrapped</em>, <em>assigned=WRAPPER_ASSIGNMENTS</em>, <em>updated=WRAPPER_UPDATES</em>)</p>
<p>更新一个 <em>wrapper</em> 函数以使其类似于 <em>wrapped</em> 函数。 可选参数为指明原函数的哪些属性要直接被赋值给 wrapper 函数的匹配属性的元组，并且这些 wrapper 函数的属性将使用原函数的对应属性来更新。 这些参数的默认值是模块级常量 <code>WRAPPER_ASSIGNMENTS</code> (它将被赋值给 wrapper 函数的 <code>__module__</code>, <code>__name__</code>, <code>__qualname__</code>, <code>__annotations__</code> 和 <code>__doc__</code> 即文档字符串) 以及 <code>WRAPPER_UPDATES</code> (它将更新 wrapper 函数的 <code>__dict__</code> 即实例字典)。</p>
<p>为了允许出于内省和其他目的访问原始函数（例如绕过 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.lru_cache" target="_blank" rel="noopener"><code>lru_cache()</code></a> 之类的缓存装饰器），此函数会自动为 wrapper 添加一个指向被包装函数的 <code>__wrapped__</code> 属性。</p>
<p>此函数的主要目的是在 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-decorator" target="_blank" rel="noopener">decorator</a> 函数中用来包装被装饰的函数并返回包装器。 如果包装器函数未被更新，则被返回函数的元数据将反映包装器定义而不是原始函数定义，这通常没有什么用处。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.update_wrapper" target="_blank" rel="noopener"><code>update_wrapper()</code></a> 可以与函数之外的可调用对象一同使用。 在 <em>assigned</em> 或 <em>updated</em> 中命名的任何属性如果不存在于被包装对象则会被忽略（即该函数将不会尝试在包装器函数上设置它们）。 如果包装器函数自身缺少在 <em>updated</em> 中命名的任何属性则仍将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>。</p>
<p><em>3.2 新版功能:</em> 自动添加 <code>__wrapped__</code> 属性。</p>
<p><em>3.2 新版功能:</em> 默认拷贝 <code>__annotations__</code> 属性。</p>
<p><em>在 3.2 版更改:</em> 不存在的属性将不再触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>。</p>
<p><em>在 3.4 版更改:</em> <code>__wrapped__</code> 属性现在总是指向被包装的函数，即使该函数定义了 <code>__wrapped__</code> 属性。 (参见 <a href="https://bugs.python.org/issue17482" target="_blank" rel="noopener">bpo-17482</a>)</p>
<blockquote>
<p><strong>wrapped是被装饰的原函数</strong></p>
<p><strong>wrapper是被装饰器装饰后的新函数。</strong></p>
</blockquote>
<h3 id="补充例子："><a href="#补充例子：" class="headerlink" title="补充例子："></a>补充例子：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">f"before..."</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"after..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    求和运算</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(a + b)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1、原函数为add。</p>
<p>2、@outer会去执行outer装饰器，传入add函数，返回一个inner函数。</p>
<p>3、执行outer函数时，加载inner函数，此时会直接执行functools.wraps(func)返回一个可调用对象，即partial对象。</p>
<p>4、此时inner的装饰器实际上是@partial，partial会被调用，传入inner函数，执行partial内部的update_wrapper函数，将func的相应属性拷贝给inner函数，最后返回inner函数。这一步并没有生成新的函数，仅仅是改变了inner函数的属性。</p>
<p>5、把add指向inner函数。</p>
<p>6、调用add实际调用的是inner函数，inner函数内部持有原add函数的引用即func。</p>
<p><strong>update_wrapper函数参数对应：</strong></p>
<p><strong>wrapper指的是inner函数</strong></p>
<p><strong>wrapped指的是func即原始的add函数</strong></p>
</blockquote>
</li>
<li><p><a href="mailto:`@functools.wraps" target="_blank" rel="noopener">`@functools.wraps</a>`(<em>wrapped</em>, <em>assigned=WRAPPER_ASSIGNMENTS</em>, <em>updated=WRAPPER_UPDATES</em>)</p>
<p>这是一个便捷函数，用于在定义包装器函数时发起调用 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.update_wrapper" target="_blank" rel="noopener"><code>update_wrapper()</code></a> 作为函数装饰器。 它等价于 <code>partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated)</code>。 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">... </span>    @wraps(f)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwds)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'Calling decorated function'</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> f(*args, **kwds)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> wrapper</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@my_decorator</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""Docstring"""</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Called example function'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example()</span><br><span class="line">Calling decorated function</span><br><span class="line">Called example function</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.__name__</span><br><span class="line"><span class="string">'example'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.__doc__</span><br><span class="line"><span class="string">'Docstring'</span></span><br></pre></td></tr></table></figure>
<p>如果不使用这个装饰器工厂函数，则 example 函数的名称将变为 <code>&#39;wrapper&#39;</code>，并且 <code>example()</code> 原本的文档字符串将会丢失。 </p>
</li>
</ul>
<h2 id="partial-对象"><a href="#partial-对象" class="headerlink" title="partial 对象"></a><a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 对象是由 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial()</code></a> 创建的可调用对象。 它们具有三个只读属性：</p>
<ul>
<li><p><code>partial.func</code></p>
<p>一个可调用对象或函数。 对 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 对象的调用将被转发给 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial.func" target="_blank" rel="noopener"><code>func</code></a> 并附带新的参数和关键字。</p>
</li>
<li><p><code>partial.args</code></p>
<p>最左边的位置参数将放置在提供给 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 对象调用的位置参数之前。</p>
</li>
<li><p><code>partial.keywords</code></p>
<p>当调用 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 对象时将要提供的关键字参数。</p>
</li>
</ul>
<p><a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 对象与 <code>function</code> 对象的类似之处在于它们都是可调用、可弱引用的对象并可拥有属性。 但两者也存在一些重要的区别。 例如前者不会自动创建 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#definition.__name__" target="_blank" rel="noopener"><code>__name__</code></a> 和 <code>__doc__</code> 属性。 而且，在类中定义的 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 对象的行为类似于静态方法，并且不会在实例属性查找期间转换为绑定方法。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><code>functools.wraps</code>目的消除装饰器对原函数造成的影响,    通过对原函数相关属性拷贝,已达到装饰器不修改原函数的目的。</li>
<li><p><strong>wraps内部通过partial对象和update_wrapper函数实现</strong> </p>
</li>
<li><p><strong>partial是一个类，通过实现了双下方法new，自定义实例化对象过程，使得对象内部保留原函数和固定参数，通过实现双下方法call，使得对象可以像函数一样被调用，再通过内部保留的原函数和固定参数以及传入的其它参数进行原函数调用。</strong> </p>
</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>functools</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library uuid</title>
    <url>/2020/02/05/python-standard-library-uuid/</url>
    <content><![CDATA[<h1 id="python-标准库-之-uuid"><a href="#python-标准库-之-uuid" class="headerlink" title="python 标准库 之 uuid"></a>python 标准库 之 uuid</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200205update.jpg?raw=true" alt></p>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=413961275&auto=0&height=66"></iframe>


<h2 id="何谓UUID"><a href="#何谓UUID" class="headerlink" title="何谓UUID"></a>何谓UUID</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UUID是<span class="number">128</span>位的全局唯一标识符，通常由<span class="number">32</span>字节的字符串表示。</span><br><span class="line">   它可以保证时间和空间的唯一性，也称为GUID，全称为：</span><br><span class="line">           UUID —— Universally Unique IDentifier      Python 中叫 UUID</span><br><span class="line">           UUID -- java.util.UUID                     Java 中也叫 UUID</span><br><span class="line">           GUID —— Globally Unique IDentifier         C<span class="comment">#  中叫 GUID</span></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">   它通过MAC地址、时间戳、命名空间、随机数、伪随机数来保证生成ID的唯一性。</span><br><span class="line">   UUID主要有五个算法，也就是五种方法来实现：</span><br><span class="line"></span><br><span class="line">      <span class="number">1</span>、uuid1()——基于时间戳</span><br><span class="line"></span><br><span class="line">              由MAC地址、当前时间戳、随机数生成。可以保证全球范围内的唯一性，</span><br><span class="line">              但MAC的使用同时带来安全性问题，局域网中可以使用IP来代替MAC。</span><br><span class="line"></span><br><span class="line">      <span class="number">2</span>、uuid2()——基于分布式计算环境DCE（Python中没有这个函数）</span><br><span class="line"></span><br><span class="line">               算法与uuid1相同，不同的是把时间戳的前<span class="number">4</span>位置换为POSIX的UID。</span><br><span class="line">               实际中很少用到该方法。</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span>、uuid3()——基于名字的MD5散列值</span><br><span class="line"></span><br><span class="line">               通过计算名字和命名空间的MD5散列值得到，保证了同一命名空间中不同名字的唯一性，</span><br><span class="line">               和不同命名空间的唯一性，但同一命名空间的同一名字生成相同的uuid。    </span><br><span class="line"></span><br><span class="line">      <span class="number">4</span>、uuid4()——基于随机数</span><br><span class="line"></span><br><span class="line">               由伪随机数得到，有一定的重复概率，该概率可以计算出来。</span><br><span class="line"></span><br><span class="line">      <span class="number">5</span>、uuid5()——基于名字的SHA<span class="number">-1</span>散列值</span><br><span class="line"></span><br><span class="line">               算法与uuid3相同，不同的是使用 Secure Hash Algorithm <span class="number">1</span> 算法</span><br></pre></td></tr></table></figure>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>Source code:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/uuid.py" target="_blank" rel="noopener">Lib/uuid.py</a> </p>
<p>  uuid模块包括：不可变对象UUID（UUID类）和函数uuid1()、uuid3()、uuid4()和uuid5()，后面的四个函数用于生成 <a href="http://tools.ietf.org/html/rfc4122.html" target="_blank" rel="noopener">RFC 4122</a> 规范中指定的第1、3、4、5版UUID。使用uuid1()或uuid4()可以获得一个唯一的ID，uuid1()包含了主机的网络名称，uuid4()不涉及网络主机名，仅生成一个随机UUID，因此从隐私保护角度uuid4()更加安全。 </p>
<h2 id="枚举类型的SafeUUID-类"><a href="#枚举类型的SafeUUID-类" class="headerlink" title="枚举类型的SafeUUID 类"></a>枚举类型的SafeUUID 类</h2><p> <em>class</em> <code>uuid.SafeUUID</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">safe = <span class="number">0</span></span><br><span class="line">unsafe = <span class="number">-1</span></span><br><span class="line">unknown = <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h2 id="UUID-类-接口"><a href="#UUID-类-接口" class="headerlink" title="UUID 类(接口)"></a>UUID 类(接口)</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法:"></a>基本语法:</h3><p><em>class</em> <code>uuid.UUID</code>(<em>hex=None</em>, <em>bytes=None</em>, <em>bytes_le=None</em>, <em>fields=None</em>, <em>int=None</em>, <em>version=None</em>, <em>**, </em>is_safe=SafeUUID.unknown*) </p>
<p>下面的各种方法创建相同的UUID对象，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UUID(<span class="string">'&#123;12345678-1234-5678-1234-567812345678&#125;'</span>)</span><br><span class="line">UUID(<span class="string">'12345678123456781234567812345678'</span>)</span><br><span class="line">UUID(<span class="string">'urn:uuid:12345678-1234-5678-1234-567812345678'</span>)</span><br><span class="line">UUID(bytes=<span class="string">b'\x12\x34\x56\x78'</span>*<span class="number">4</span>)</span><br><span class="line">UUID(bytes_le=<span class="string">b'\x78\x56\x34\x12\x34\x12\x78\x56'</span> +</span><br><span class="line">              <span class="string">b'\x12\x34\x56\x78\x12\x34\x56\x78'</span>)</span><br><span class="line">UUID(fields=(<span class="number">0x12345678</span>, <span class="number">0x1234</span>, <span class="number">0x5678</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x567812345678</span>))</span><br><span class="line">UUID(int=<span class="number">0x12345678123456781234567812345678</span>)</span><br></pre></td></tr></table></figure>
<p>其中:</p>
<blockquote>
<p>如果尝试比较一个非UUID对象会引发<code>TypeError</code><br>使用str()函数强制转换一个uuid对象,将会生成一个从<code>12345678-1234-5678-1234-567812345678.</code>中创建的字符串</p>
</blockquote>
<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><ul>
<li><p><code>UUID.bytes</code></p>
<p>指定一个大端字节序的总长16字节的字节串来创建UUID对象；    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = uuid.UUID(<span class="string">'&#123;12345678-1234-5678-1234-567812345678&#125;'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.bytes</span><br><span class="line"><span class="string">b'\x124Vx\x124Vx\x124Vx\x124Vx'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>UUID.bytes_le</code></p>
<p>指定一个小端字节序的总长16字节的字节串来创建UUID对象；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.bytes_le</span><br><span class="line"><span class="string">b'xV4\x124\x12xV\x124Vx\x124Vx'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>UUID.fields</code></p>
<p>以元组形式存放的UUID的6个整数域，有六个单独的属性和两个派生属性：</p>
<p>| 域                                                           | 意义                   |<br>| :———————————————————– | :——————— |<br>| <code>time_low</code>                                                   | UUID的前32位           |<br>| <code>time_mid</code>                                                   | 接前一域的16位         |<br>| <code>time_hi_version</code>                                            | 接前一域的16位         |<br>| <code>clock_seq_hi_variant</code>                                       | 接前一域的8位          |<br>| <code>clock_seq_low</code>                                              | 接前一域的8位          |<br>| <code>node</code>                                                       | UUID的最后48位         |<br>| <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> | UUID的总长60位的时间戳 |<br>| <code>clock_seq</code>                                                  | 14位的序列号           |</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.fields</span><br><span class="line">(<span class="number">305419896</span>, <span class="number">4660</span>, <span class="number">22136</span>, <span class="number">18</span>, <span class="number">52</span>, <span class="number">95073701484152</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>UUID.hex</code></p>
<p> 以32个字符表示的UUID</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.hex</span><br><span class="line"><span class="string">'12345678123456781234567812345678'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>UUID.int</code></p>
<p> 以一个长度为128个二进制位的整数表示的UUID；</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.int</span><br><span class="line"><span class="number">24197857161011715162171839636988778104</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>UUID.urn</code></p>
<p> 以 RFC 4122 中指定的URN形式表示的UUID；</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.urn</span><br><span class="line"><span class="string">'urn:uuid:12345678-1234-5678-1234-567812345678'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>UUID.variant</code></p>
<p>　UUID变体（variant），决定UUID内部的布局，已有的值为 RESERVED_NCS、RFC_4122、RESERVED_MICROSOFT 或 RESERVED_FUTURE；</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.variant</span><br><span class="line"><span class="string">'reserved for NCS compatibility'</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>UUID.version</code></p>
<p>返回UUID的版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.version</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>　这里由于u.variant == ‘reserved for NCS compatibility’，所以此处u.version为空。 </p>
</li>
<li><p><code>UUID.is_safe</code></p>
<p>枚举类型的<code>SafeUUID</code>对象,为了标识创建的UUID是否是线程安全的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.is_safe</span><br><span class="line">&lt;SafeUUID.unknown: <span class="literal">None</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3></li>
</ul>
<p><strong>关于属性variant，uuid模块定义了如下的常量</strong></p>
<p> uuid.RESERVED_NCS<br>　　该常量为兼容NCS而保留；<br>　　<br> uuid.RFC_4122<br>　　按照 RFC 4122 的规定来确定UUID的布局；<br>　　<br> uuid.RESERVED_MICROSOFT<br>　　该常量位兼容微软而保留<br> 　　<br> uuid.RESERVED_FUTURE<br>　　该常量为未来可能的定义保留 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">可以在Python中查看这些常量：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.RESERVED_NCS</span><br><span class="line"><span class="string">'reserved for NCS compatibility'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.RFC_4122</span><br><span class="line"><span class="string">'specified in RFC 4122'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.RESERVED_MICROSOFT</span><br><span class="line"><span class="string">'reserved for Microsoft compatibility'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.RESERVED_FUTURE</span><br><span class="line"><span class="string">'reserved for future definition'</span></span><br></pre></td></tr></table></figure>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p><code>uuid.getnode</code>() </p>
<p>  　获取硬件的地址并以48位二进制长度的正整数形式返回，这里所说的硬件地址是指网络接口的MAC地址，如果一个机器有多个网络接口，可能返回其中的任一个。如果获取失败，将按照RFC 4122的规定将随机返回的48位二进制整数的第8位设置成1。 </p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.getnode()</span><br><span class="line"><span class="number">202960192043486</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>uuid.uuid1</code>(<em>node=None</em>, <em>clock_seq=None</em>) </p>
<p>  　利用主机ID、序列号和当前时间生成一个UUID，如果参数 <em>node</em> 没有给定，会调用 getnode() 来获取硬件地址。如果参数中指定了 <em>clock_seq</em> ，使用参数中给定的时钟序列作为序列号，否则使用一个随机的14位长的序列号。 </p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid1()</span><br><span class="line">UUID(<span class="string">'97344912-4827-11ea-9c91-b8975a2679de'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>uuid.uuid3</code>(<em>namespace</em>, <em>name</em>) </p>
<p> 基于命名空间标识符（实质上是一个UUID）和一个名称（实质上是一个字符串）的MD5哈希值生成UUID。 </p>
</li>
<li><p><code>uuid.uuid4</code>() </p>
<p>生成一个随机的UUID。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid4()</span><br><span class="line">UUID(<span class="string">'ff3c991e-df64-4cfc-900e-ef83c991b513'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>uuid.uuid5</code>(<em>namespace</em>, <em>name</em>) </p>
<p>基于命名空间标识符（实质上是一个UUID）和一个名称（实质上是一个字符串）的SHA-1哈希值生成UUID </p>
</li>
</ul>
<p>下面的几个标准uuid在使用<code>uuid3()</code> 或<code>uuid5()</code>的时候使用</p>
<ul>
<li><p><code>uuid.NAMESPACE_DNS</code></p>
<p> 　当指定该命名空间时，参数 <em>name</em> 是一个完全限定的（fully-qualified）域名 </p>
</li>
<li><p><code>uuid.NAMESPACE_URL</code> </p>
<p> 当指定该命名空间时，参数 <em>name</em> 是一个URL </p>
</li>
<li><p><code>uuid.NAMESPACE_OID</code> </p>
<p> 当指定该命名空间时，参数 <em>name</em> 是一个ISO OID </p>
</li>
<li><p><code>uuid.NAMESPACE_X500</code> </p>
<p> 当指定该命名空间时，参数 <em>name</em> 是一个DER格式或文本格式的X.500 DN。 </p>
</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID based on the host ID and current time</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid1()</span><br><span class="line">UUID(<span class="string">'a8098c1a-f86e-11da-bd1a-00112444be1e'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID using an MD5 hash of a namespace UUID and a name</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid3(uuid.NAMESPACE_DNS, <span class="string">'python.org'</span>)</span><br><span class="line">UUID(<span class="string">'6fa459ea-ee8a-3ca4-894e-db77e160355e'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a random UUID</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid4()</span><br><span class="line">UUID(<span class="string">'16fd2706-8baf-433b-82eb-8c7fada847da'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID using a SHA-1 hash of a namespace UUID and a name</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid5(uuid.NAMESPACE_DNS, <span class="string">'python.org'</span>)</span><br><span class="line">UUID(<span class="string">'886313e1-3b8a-5372-9b90-0c9aee199e5d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID from a string of hex digits (braces and hyphens ignored)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = uuid.UUID(<span class="string">'&#123;00010203-0405-0607-0809-0a0b0c0d0e0f&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># convert a UUID to a string of hex digits in standard form</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(x)</span><br><span class="line"><span class="string">'00010203-0405-0607-0809-0a0b0c0d0e0f'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># get the raw 16 bytes of the UUID</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.bytes</span><br><span class="line"><span class="string">b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID from a 16-byte string</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.UUID(bytes=x.bytes)</span><br><span class="line">UUID(<span class="string">'00010203-0405-0607-0809-0a0b0c0d0e0f'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="如何去除UUID字符串中的横杠"><a href="#如何去除UUID字符串中的横杠" class="headerlink" title="如何去除UUID字符串中的横杠"></a>如何去除UUID字符串中的横杠</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">uid = str(uuid.uuid4())</span><br><span class="line">suid = <span class="string">''</span>.join(uid.split(<span class="string">'-'</span>))</span><br><span class="line"><span class="comment">## 等价于</span></span><br><span class="line">print(uuid.uuid1().hex)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>uuid</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library types</title>
    <url>/2020/02/07/python-standard-library-types/</url>
    <content><![CDATA[<h1 id="python-标准库-types"><a href="#python-标准库-types" class="headerlink" title="python 标准库 types"></a>python 标准库 types</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200207_RIP.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>今天心情很沉重,李文亮医生一路走好！R.I.P</p>
</blockquote>
<p><a href="https://v.youku.com/v_show/id_XNDQ1MTYyMDI4OA==.html" target="_blank" rel="noopener">https://v.youku.com/v_show/id_XNDQ1MTYyMDI4OA==.html</a></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/types.py" target="_blank" rel="noopener">Lib/types.py</a></p>
<hr>
<p>此模块定义了一些工具函数，用于协助动态创建新的类型。</p>
<p>它还为某些对象类型定义了名称，这些名称由标准 Python 解释器所使用，但并不像内置的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 那样对外公开。</p>
<p>最后，它还额外提供了一些类型相关但重要程度不足以作为内置对象的工具类和函数。</p>
<h2 id="动态类型创建"><a href="#动态类型创建" class="headerlink" title="动态类型创建"></a>动态类型创建</h2><ul>
<li><p><code>types.new_class</code>(<em>name</em>, <em>bases=()</em>, <em>kwds=None</em>, <em>exec_body=None</em>) </p>
<p>使用适当的元类动态地创建一个类对象。</p>
<p>前三个参数是组成类定义头的部件：类名称，基类 (有序排列)，关键字参数 (例如 <code>metaclass</code>)。</p>
<p><em>exec_body</em> 参数是一个回调函数，用于填充新创建类的命名空间。 它应当接受类命名空间作为其唯一的参数并使用类内容直接更新命名空间。 如果未提供回调函数，则它就等效于传入 <code>lambda ns: ns</code>。</p>
<p><em>3.3 新版功能.</em></p>
</li>
<li><p><code>types.prepare_class</code>(<em>name</em>, <em>bases=()</em>, <em>kwds=None</em>) </p>
<p>计算适当的元类并创建类命名空间。</p>
<p>参数是组成类定义头的部件：类名称，基类 (有序排列) 以及关键字参数 (例如 <code>metaclass</code>)。</p>
<p>返回值是一个 3 元组: <code>metaclass, namespace, kwds</code></p>
<p><em>metaclass</em> 是适当的元类，<em>namespace</em> 是预备好的类命名空间而 <em>kwds</em> 是所传入 <em>kwds</em> 参数移除每个 <code>&#39;metaclass&#39;</code> 条目后的已更新副本。 如果未传入 <em>kwds</em> 参数，这将为一个空字典。</p>
<p><em>3.3 新版功能.</em></p>
<p><em>在 3.6 版更改:</em> 所返回元组中 <code>namespace</code> 元素的默认值已被改变。 现在当元类没有 <code>__prepare__</code> 方法时将会使用一个保留插入顺序的映射。</p>
</li>
<li><p><code>types.resolve_bases</code>(<em>bases</em>) </p>
<p>动态地解析 MRO 条目，具体描述见 <a href="https://www.python.org/dev/peps/pep-0560" target="_blank" rel="noopener"><strong>PEP 560</strong></a>。</p>
<p>此函数会在 <em>bases</em> 中查找不是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#type" target="_blank" rel="noopener"><code>type</code></a> 的实例的项，并返回一个元组，其中每个具有 <code>__mro_entries__</code> 方法的此种对象对象将被替换为调用该方法解包后的结果。 如果一个 <em>bases</em> 项是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#type" target="_blank" rel="noopener"><code>type</code></a> 的实例，或它不具有 <code>__mro_entries__</code> 方法，则它将不加改变地被包含在返回的元组中。</p>
</li>
</ul>
<h2 id="标准解释器类型"><a href="#标准解释器类型" class="headerlink" title="标准解释器类型"></a>标准解释器类型</h2><p>此模块为许多类型提供了实现 Python 解释器所要求的名称。 它刻意地避免了包含某些仅在处理过程中偶然出现的类型，例如 <code>listiterator</code> 类型。</p>
<p>此种名称的典型应用如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#issubclass" target="_blank" rel="noopener"><code>issubclass()</code></a> 检测。</p>
<p>如果你要实例化这些类型中的任何一种，请注意其签名在不同 Python 版本之间可能出现变化。</p>
<p>以下类型有相应的标准名称定义：</p>
<ul>
<li><p><code>types.FunctionType</code></p>
</li>
<li><p><code>types.LambdaType</code> </p>
<p>用户自定义函数以及由 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#lambda" target="_blank" rel="noopener"><code>lambda</code></a> 表达式所创建函数的类型。 </p>
</li>
<li><p><code>types.GeneratorType</code> </p>
<p><a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 迭代器对象的类型，由生成器函数创建。 </p>
</li>
<li><p><code>types.CoroutineType</code> </p>
<p><a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 对象的类型，由 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 函数创建。 </p>
</li>
<li><p><code>types.AsyncGeneratorType</code>  </p>
<p><a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-generator" target="_blank" rel="noopener">asynchronous generator</a> 迭代器对象的类型，由异步生成器函数创建。 </p>
</li>
<li><p><em>class</em> <code>types.CodeType</code>(<strong><em>kwargs</em>) </strong></p>
<p>代码对象的类型，例如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#compile" target="_blank" rel="noopener"><code>compile()</code></a> 的返回值。</p>
<p>引发 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>code.__new__</code> 附带参数 <code>code</code>, <code>filename</code>, <code>name</code>, <code>argcount</code>, <code>posonlyargcount</code>, <code>kwonlyargcount</code>, <code>nlocals</code>, <code>stacksize</code>, <code>flags</code>。</p>
<p>请注意被审核参数可能不匹配初始化器所要求的名称或位置。</p>
<ul>
<li><p><strong><code>replace</code>(*</strong>kwargs*)</p>
<p>返回代码对象的一个副本，使用指定的新字段值。</p>
</li>
</ul>
</li>
<li><p><code>types.CellType</code> </p>
<p>单元对象的类型：这种对象被用作函数中自由变量的容器。 </p>
</li>
<li><p><code>types.MethodType</code> </p>
<p>用户自定义类实例方法的类型。 </p>
</li>
<li><p><code>types.BuiltinFunctionType</code> </p>
</li>
<li><p><code>types.BuiltinMethodType</code> </p>
<p>内置函数例如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 以及内置类方法的类型。 （这里所说的“内置”是指“以 C 语言编写”。） </p>
</li>
<li><p><code>types.WrapperDescriptorType</code> </p>
<p>某些内置数据类型和基类的方法的类型，例如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>object.__init__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__lt__" target="_blank" rel="noopener"><code>object.__lt__()</code></a>。 </p>
</li>
<li><p><code>types.MethodWrapperType</code> </p>
<p>某些内置数据类型和基类的 <em>绑定</em> 方法的类型。 例如 <code>object().__str__</code> 所属的类型。 </p>
</li>
<li><p><code>types.MethodDescriptorType</code> </p>
<p>某些内置数据类型方法例如 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str.join" target="_blank" rel="noopener"><code>str.join()</code></a> 的类型。 </p>
</li>
<li><p><code>types.MethodDescriptorType</code> </p>
<p>某些内置数据类型 <em>非绑定</em> 类方法例如 <code>dict.__dict__[&#39;fromkeys&#39;]</code> 的类型 </p>
</li>
<li><p><code>types.ClassMethodDescriptorType</code> </p>
<p>某些内置数据类型 <em>非绑定</em> 类方法例如 <code>dict.__dict__[&#39;fromkeys&#39;]</code> 的类型。 </p>
<p><em>class</em> <code>types.ModuleType</code>(<em>name</em>, <em>doc=None</em>) </p>
</li>
</ul>
<p><a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-module" target="_blank" rel="noopener">模块</a> 的类型。 构造器接受待创建模块的名称及其作为可选项 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-docstring" target="_blank" rel="noopener">docstring</a>。</p>
<p>如果你希望设置各种由导入控制的属性，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/importlib.html#importlib.util.module_from_spec" target="_blank" rel="noopener"><code>importlib.util.module_from_spec()</code></a> 来创建一个新模块。</p>
<ul>
<li><p><code>__doc__</code></p>
<p>模块的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-docstring" target="_blank" rel="noopener">docstring</a>。 默认为 <code>None</code>。</p>
</li>
<li><p><code>__loader__</code></p>
<p>用于加载模块的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-loader" target="_blank" rel="noopener">loader</a>。 默认为 <code>None</code>。<em>在 3.4 版更改:</em> 默认为 <code>None</code>。 之前该属性为可选项。</p>
</li>
<li><p><code>__name__</code></p>
<p>模块的名字</p>
</li>
<li><p><code>__package__</code></p>
<p>一个模块所属的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-package" target="_blank" rel="noopener">package</a>。 如果模块为最高层级的（即不是任何特定包的组成部分）则该属性应设为 <code>&#39;&#39;</code>，否则它应设为特定包的名称 (如果模块本身也是一个包则名称可以为 <a href="https://docs.python.org/zh-cn/3.8/reference/import.html#__name__" target="_blank" rel="noopener"><code>__name__</code></a>)。 默认为 <code>None</code>。</p>
<p><em>class</em> <code>types.TracebackType</code>(<em>tb_next</em>, <em>tb_frame</em>, <em>tb_lasti</em>, <em>tb_lineno</em>) </p>
</li>
</ul>
<p>回溯对象的类型，例如 <code>sys.exc_info()[2]</code> 中的对象。</p>
<p>请查看 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#traceback-objects" target="_blank" rel="noopener">语言参考</a> 了解可用属性和操作的细节，以及动态地创建回溯对象的指南。</p>
<ul>
<li><p><code>types.FrameType</code></p>
<p>帧对象的类型，例如 <code>tb.tb_frame</code> 中的对象，其中 <code>tb</code> 是一个回溯对象。请查看 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#frame-objects" target="_blank" rel="noopener">语言参考</a> 了解可用属性和操作的细节。</p>
</li>
<li><p><code>types.GetSetDescriptorType</code></p>
<p> 使用 <code>PyGetSetDef</code> 在扩展模块中定义的对象的类型，例如 <code>FrameType.f_locals</code> 或 <code>array.array.typecode</code>。 此类型被用作对象属性的描述器；它的目的与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#property" target="_blank" rel="noopener"><code>property</code></a> 类型相同，但专门针对在扩展模块中定义的类。 </p>
</li>
<li><p><code>types.MemberDescriptorType</code></p>
<p>使用 <code>PyMemberDef</code> 在扩展模块中定义的对象的类型，例如 <code>datetime.timedelta.days</code>。 此类型被用作使用标准转换函数的简单 C 数据成员的描述器；它的目的与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#property" target="_blank" rel="noopener"><code>property</code></a> 类型相同，但专门针对在扩展模块中定义的类。</p>
<p><strong>CPython implementation detail:</strong> 在 Python 的其它实现中，此类型可能与 <code>GetSetDescriptorType</code> 完全相同。</p>
</li>
<li><p><em>class</em> <code>types.MappingProxyType</code>(<em>mapping</em>)</p>
<p>一个映射的只读代理。 它提供了对映射条目的动态视图，这意味着当映射发生改变时，视图会反映这些改变。</p>
<p><em>3.3 新版功能.</em></p>
<ul>
<li><p><code>key in proxy</code></p>
<p>如果下层的映射中存在键 <em>key</em> 则返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><code>proxy[key]</code></p>
<p>返回下层的映射中以 <em>key</em> 为键的项。 如果下层的映射中不存在键 <em>key</em> 则引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。</p>
</li>
<li><p><code>iter(proxy)</code></p>
<p>返回由下层映射的键为元素的迭代器。 这是 <code>iter(proxy.keys())</code> 的快捷方式。</p>
</li>
<li><p><code>len(proxy)</code></p>
<p>返回下层映射中的项数。</p>
</li>
<li><p><code>copy</code>()</p>
<p>返回下层映射的浅拷贝。</p>
</li>
<li><p><code>get</code>(<em>key</em>[, <em>default</em>])</p>
<p>如果 <em>key</em> 存在于下层映射中则返回 <em>key</em> 的值，否则返回 <em>default</em>。 如果 <em>default</em> 未给出则默认为 <code>None</code>，因而此方法绝不会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。</p>
</li>
<li><p><code>items</code>()</p>
<p>返回由下层映射的项 (<code>(键, 值)</code> 对) 组成的一个新视图。</p>
</li>
<li><p><code>keys</code>()</p>
<p>返回由下层映射的键组成的一个新视图。</p>
</li>
<li><p><code>values</code>()</p>
<p>返回由下层映射的值组成的一个新视图。</p>
</li>
</ul>
</li>
</ul>
<h2 id="附加工具类和函数"><a href="#附加工具类和函数" class="headerlink" title="附加工具类和函数"></a>附加工具类和函数</h2><ul>
<li><p>class* <code>types.SimpleNamespace</code> </p>
<p>一个简单的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 子类，提供了访问其命名空间的属性，以及一个有意义的 repr。</p>
<p>不同于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a>，对于 <code>SimpleNamespace</code> 你可以添加和移除属性。 如果一个 <code>SimpleNamespace</code> 对象使用关键字参数进行初始化，这些参数会被直接加入下层命名空间。</p>
<p>此类型大致等价于以下代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleNamespace</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, /, **kwargs)</span>:</span></span><br><span class="line">        self.__dict__.update(kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        keys = sorted(self.__dict__)</span><br><span class="line">        items = (<span class="string">"&#123;&#125;=&#123;!r&#125;"</span>.format(k, self.__dict__[k]) <span class="keyword">for</span> k <span class="keyword">in</span> keys)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;&#125;(&#123;&#125;)"</span>.format(type(self).__name__, <span class="string">", "</span>.join(items))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__dict__ == other.__dict__</span><br></pre></td></tr></table></figure>
<p> <code>SimpleNamespace</code> 可被用于替代 <code>class NS: pass</code>。 但是，对于结构化记录类型则应改用 <a href="https://docs.python.org/zh-cn/3.8/library/collections.html#collections.namedtuple" target="_blank" rel="noopener"><code>namedtuple()</code></a>。 </p>
</li>
<li><p><code>types.DynamicClassAttribute</code>(<em>fget=None</em>, <em>fset=None</em>, <em>fdel=None</em>, <em>doc=None</em>) </p>
</li>
</ul>
<p>在类上访问 <strong>getattr</strong> 的路由属性。</p>
<p>这是一个描述器，用于定义通过实例与通过类访问时具有不同行为的属性。 当实例访问时保持正常行为，但当类访问属性时将被路由至类的 <strong>getattr</strong> 方法；这是通过引发 AttributeError 来完成的。</p>
<p>这样就允许有在实例上激活的特征属性，同时又有在类上的同名虚拟属性（一个这样的例子是 Enum）。</p>
<h2 id="协程工具函数"><a href="#协程工具函数" class="headerlink" title="协程工具函数"></a>协程工具函数</h2><p> <code>types.coroutine</code>(<em>gen_func</em>) </p>
<p>此函数可将 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 函数转换为返回基于生成器的协程的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine-function" target="_blank" rel="noopener">coroutine function</a>。 基于生成器的协程仍然属于 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator-iterator" target="_blank" rel="noopener">generator iterator</a>，但同时又可被视为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 对象兼 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a>。 不过，它没有必要实现 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 方法。</p>
<p>如果 <em>gen_func</em> 是一个生成器函数，它将被原地修改。</p>
<p>如果 <em>gen_func</em> 不是一个生成器函数，则它会被包装。 如果它返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Generator" target="_blank" rel="noopener"><code>collections.abc.Generator</code></a> 的实例，该实例将被包装在一个 <em>awaitable</em> 代理对象中。 所有其他对象类型将被原样返回。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>types</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library itertools</title>
    <url>/2020/02/03/python-standard-library-itertools/</url>
    <content><![CDATA[<h1 id="python-标准库-itertools"><a href="#python-标准库-itertools" class="headerlink" title="python 标准库 itertools"></a>python 标准库 itertools</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200203_Alita-Battle-Angel-2019.png?raw=true" alt></p>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1348507017&auto=0&height=66"></iframe>


<h1 id="为高效循环而创建迭代器的函数"><a href="#为高效循环而创建迭代器的函数" class="headerlink" title="为高效循环而创建迭代器的函数"></a>为高效循环而创建迭代器的函数</h1><p>本模块实现一系列 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a> ，这些迭代器受到APL，Haskell和SML的启发。为了适用于Python，它们都被重新写过。</p>
<p>本模块标准化了一个快速、高效利用内存的核心工具集，这些工具本身或组合都很有用。它们一起形成了“迭代器代数”，这使得在纯Python中有可能创建简洁又高效的专用工具。</p>
<p>例如，SML有一个制表工具： <code>tabulate(f)</code>，它可产生一个序列 <code>f(0), f(1), ...</code>。在Python中可以组合 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.count" target="_blank" rel="noopener"><code>count()</code></a> 实现： <code>map(f, count())</code>。</p>
<p>这些内置工具同时也能很好地与 <a href="https://docs.python.org/zh-cn/3.8/library/operator.html#module-operator" target="_blank" rel="noopener"><code>operator</code></a> 模块中的高效函数配合使用。例如，我们可以将两个向量的点积映射到乘法运算符： <code>sum(map(operator.mul, vector1, vector2))</code> 。</p>
<p><strong>无穷迭代器：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">迭代器</th>
<th style="text-align:left">实参</th>
<th style="text-align:left">结果</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.count" target="_blank" rel="noopener"><code>count()</code></a></td>
<td style="text-align:left">start, [step]</td>
<td style="text-align:left">start, start+step, start+2*step, …</td>
<td style="text-align:left"><code>count(10) --&gt; 10 11 12 13 14 ...</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.cycle" target="_blank" rel="noopener"><code>cycle()</code></a></td>
<td style="text-align:left">p</td>
<td style="text-align:left">p0, p1, … plast, p0, p1, …</td>
<td style="text-align:left"><code>cycle(&#39;ABCD&#39;) --&gt; A B C D A B C D ...</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.repeat" target="_blank" rel="noopener"><code>repeat()</code></a></td>
<td style="text-align:left">elem [,n]</td>
<td style="text-align:left">elem, elem, elem, … 重复无限次或n次</td>
<td style="text-align:left"><code>repeat(10, 3) --&gt; 10 10 10</code></td>
</tr>
</tbody>
</table>
<p><strong>根据最短输入序列长度停止的迭代器：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">迭代器</th>
<th style="text-align:left">实参</th>
<th style="text-align:left">结果</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.accumulate" target="_blank" rel="noopener"><code>accumulate()</code></a></td>
<td style="text-align:left">p [,func]</td>
<td style="text-align:left">p0, p0+p1, p0+p1+p2, …</td>
<td style="text-align:left"><code>accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.chain" target="_blank" rel="noopener"><code>chain()</code></a></td>
<td style="text-align:left">p, q, …</td>
<td style="text-align:left">p0, p1, … plast, q0, q1, …</td>
<td style="text-align:left"><code>chain(&#39;ABC&#39;, &#39;DEF&#39;) --&gt; A B C D E F</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.chain.from_iterable" target="_blank" rel="noopener"><code>chain.from_iterable()</code></a></td>
<td style="text-align:left">iterable</td>
<td style="text-align:left">p0, p1, … plast, q0, q1, …</td>
<td style="text-align:left"><code>chain.from_iterable([&#39;ABC&#39;, &#39;DEF&#39;]) --&gt; A B C D E F</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.compress" target="_blank" rel="noopener"><code>compress()</code></a></td>
<td style="text-align:left">data, selectors</td>
<td style="text-align:left">(d[0] if s[0]), (d[1] if s[1]), …</td>
<td style="text-align:left"><code>compress(&#39;ABCDEF&#39;, [1,0,1,0,1,1]) --&gt; A C E F</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.dropwhile" target="_blank" rel="noopener"><code>dropwhile()</code></a></td>
<td style="text-align:left">pred, seq</td>
<td style="text-align:left">seq[n], seq[n+1], … 从pred首次真值测试失败开始</td>
<td style="text-align:left"><code>dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.filterfalse" target="_blank" rel="noopener"><code>filterfalse()</code></a></td>
<td style="text-align:left">pred, seq</td>
<td style="text-align:left">seq中pred(x)为假值的元素，x是seq中的元素。</td>
<td style="text-align:left"><code>filterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.groupby" target="_blank" rel="noopener"><code>groupby()</code></a></td>
<td style="text-align:left">iterable[, key]</td>
<td style="text-align:left">根据key(v)值分组的迭代器</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.islice" target="_blank" rel="noopener"><code>islice()</code></a></td>
<td style="text-align:left">seq, [start,] stop [, step]</td>
<td style="text-align:left">seq[start:stop:step]中的元素</td>
<td style="text-align:left"><code>islice(&#39;ABCDEFG&#39;, 2, None) --&gt; C D E F G</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.starmap" target="_blank" rel="noopener"><code>starmap()</code></a></td>
<td style="text-align:left">func, seq</td>
<td style="text-align:left">func(<em>seq[0]), func(</em>seq[1]), …</td>
<td style="text-align:left"><code>starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.takewhile" target="_blank" rel="noopener"><code>takewhile()</code></a></td>
<td style="text-align:left">pred, seq</td>
<td style="text-align:left">seq[0], seq[1], …, 直到pred真值测试失败</td>
<td style="text-align:left"><code>takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4</code></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.tee" target="_blank" rel="noopener"><code>tee()</code></a></td>
<td style="text-align:left">it, n</td>
<td style="text-align:left">it1, it2, … itn 将一个迭代器拆分为n个迭代器</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.zip_longest" target="_blank" rel="noopener"><code>zip_longest()</code></a></td>
<td style="text-align:left">p, q, …</td>
<td style="text-align:left">(p[0], q[0]), (p[1], q[1]), …</td>
<td style="text-align:left"><code>zip_longest(&#39;ABCD&#39;, &#39;xy&#39;, fillvalue=&#39;-&#39;) --&gt; Ax By C- D-</code></td>
</tr>
</tbody>
</table>
<p><strong>排列组合迭代器：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">迭代器</th>
<th style="text-align:left">实参</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.product" target="_blank" rel="noopener"><code>product()</code></a></td>
<td style="text-align:left">p, q, … [repeat=1]</td>
<td style="text-align:left">笛卡尔积，相当于嵌套的for循环</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.permutations" target="_blank" rel="noopener"><code>permutations()</code></a></td>
<td style="text-align:left">p[, r]</td>
<td style="text-align:left">长度r元组，所有可能的排列，无重复元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.combinations" target="_blank" rel="noopener"><code>combinations()</code></a></td>
<td style="text-align:left">p, r</td>
<td style="text-align:left">长度r元组，有序，无重复元素</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.combinations_with_replacement" target="_blank" rel="noopener"><code>combinations_with_replacement()</code></a></td>
<td style="text-align:left">p, r</td>
<td style="text-align:left">长度r元组，有序，元素可重复</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">例子</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>product(&#39;ABCD&#39;, repeat=2)</code></td>
<td style="text-align:left"><code>AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD</code></td>
</tr>
<tr>
<td style="text-align:left"><code>permutations(&#39;ABCD&#39;, 2)</code></td>
<td style="text-align:left"><code>AB AC AD BA BC BD CA CB CD DA DB DC</code></td>
</tr>
<tr>
<td style="text-align:left"><code>combinations(&#39;ABCD&#39;, 2)</code></td>
<td style="text-align:left"><code>AB AC AD BC BD CD</code></td>
</tr>
<tr>
<td style="text-align:left"><code>combinations_with_replacement(&#39;ABCD&#39;, 2)</code></td>
<td style="text-align:left"><code>AA AB AC AD BB BC BD CC CD DD</code></td>
</tr>
</tbody>
</table>
<h2 id="Itertools数"><a href="#Itertools数" class="headerlink" title="Itertools数"></a>Itertools数</h2><p>下列模块函数均创建并返回迭代器。有些迭代器不限制输出流长度，所以它们只应在能截断输出流的函数或循环中使用。</p>
<ul>
<li><p><code>itertools.accumulate</code>(<em>iterable</em>[, <em>func</em>, <em>**, </em>initial=None*])</p>
<p>创建一个迭代器，返回累积汇总值或其他双目运算函数的累积结果值（通过可选的 <em>func</em> 参数指定）。如果提供了 <em>func</em>，它应当为带有两个参数的函数。 输入 <em>iterable</em> 的元素可以是能被 <em>func</em> 接受为参数的任意类型。 （例如，对于默认的加法运算，元素可以是任何可相加的类型包括 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>Decimal</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a>。）通常，输出的元素数量与输入的可迭代对象是一致的。 但是，如果提供了关键字参数 <em>initial</em>，则累加会以 <em>initial</em> 值开始，这样输出就比输入的可迭代对象多一个元素。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accumulate</span><span class="params">(iterable, func=operator.add, *, initial=None)</span>:</span></span><br><span class="line">    <span class="string">'Return running totals'</span></span><br><span class="line">    <span class="comment"># accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15</span></span><br><span class="line">    <span class="comment"># accumulate([1,2,3,4,5], initial=100) --&gt; 100 101 103 106 110 115</span></span><br><span class="line">    <span class="comment"># accumulate([1,2,3,4,5], operator.mul) --&gt; 1 2 6 24 120</span></span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    total = initial</span><br><span class="line">    <span class="keyword">if</span> initial <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            total = next(it)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">yield</span> total</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">        total = func(total, element)</span><br><span class="line">        <span class="keyword">yield</span> total</span><br></pre></td></tr></table></figure>
<p><em>func</em> 参数有几种用法。它可以被设为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#min" target="_blank" rel="noopener"><code>min()</code></a> 最终得到一个最小值，或者设为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#max" target="_blank" rel="noopener"><code>max()</code></a> 最终得到一个最大值，或设为 <a href="https://docs.python.org/zh-cn/3.8/library/operator.html#operator.mul" target="_blank" rel="noopener"><code>operator.mul()</code></a> 最终得到一个乘积。摊销表可通过累加利息和支付款项得到。给iterable设置初始值并只将参数 <em>func</em> 参数有几种用法。它可以被设为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#min" target="_blank" rel="noopener"><code>min()</code></a> 最终得到一个最小值，或者设为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#max" target="_blank" rel="noopener"><code>max()</code></a> 最终得到一个最大值，或设为 <a href="https://docs.python.org/zh-cn/3.8/library/operator.html#operator.mul" target="_blank" rel="noopener"><code>operator.mul()</code></a> 最终得到一个乘积。摊销表可通过累加利息和支付款项得到。给iterable设置初始值并只将参数 <em>func</em> 设为累加总数可以对一阶 <a href="https://en.wikipedia.org/wiki/Recurrence_relation" target="_blank" rel="noopener">递归关系</a> 建模。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(accumulate(data, operator.mul))     <span class="comment"># running product</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">12</span>, <span class="number">72</span>, <span class="number">144</span>, <span class="number">144</span>, <span class="number">1296</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(accumulate(data, max))              <span class="comment"># running maximum</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Amortize a 5% loan of 1000 with 4 annual payments of 90</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cashflows = [<span class="number">1000</span>, <span class="number">-90</span>, <span class="number">-90</span>, <span class="number">-90</span>, <span class="number">-90</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(accumulate(cashflows, <span class="keyword">lambda</span> bal, pmt: bal*<span class="number">1.05</span> + pmt))</span><br><span class="line">[<span class="number">1000</span>, <span class="number">960.0</span>, <span class="number">918.0</span>, <span class="number">873.9000000000001</span>, <span class="number">827.5950000000001</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>logistic_map = <span class="keyword">lambda</span> x, _:  r * x * (<span class="number">1</span> - x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="number">3.8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x0 = <span class="number">0.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inputs = repeat(x0, <span class="number">36</span>)     <span class="comment"># only the initial value is used</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[format(x, <span class="string">'.2f'</span>) <span class="keyword">for</span> x <span class="keyword">in</span> accumulate(inputs, logistic_map)]</span><br><span class="line">[<span class="string">'0.40'</span>, <span class="string">'0.91'</span>, <span class="string">'0.30'</span>, <span class="string">'0.81'</span>, <span class="string">'0.60'</span>, <span class="string">'0.92'</span>, <span class="string">'0.29'</span>, <span class="string">'0.79'</span>, <span class="string">'0.63'</span>,</span><br><span class="line"> <span class="string">'0.88'</span>, <span class="string">'0.39'</span>, <span class="string">'0.90'</span>, <span class="string">'0.33'</span>, <span class="string">'0.84'</span>, <span class="string">'0.52'</span>, <span class="string">'0.95'</span>, <span class="string">'0.18'</span>, <span class="string">'0.57'</span>,</span><br><span class="line"> <span class="string">'0.93'</span>, <span class="string">'0.25'</span>, <span class="string">'0.71'</span>, <span class="string">'0.79'</span>, <span class="string">'0.63'</span>, <span class="string">'0.88'</span>, <span class="string">'0.39'</span>, <span class="string">'0.91'</span>, <span class="string">'0.32'</span>,</span><br><span class="line"> <span class="string">'0.83'</span>, <span class="string">'0.54'</span>, <span class="string">'0.95'</span>, <span class="string">'0.20'</span>, <span class="string">'0.60'</span>, <span class="string">'0.91'</span>, <span class="string">'0.30'</span>, <span class="string">'0.80'</span>, <span class="string">'0.60'</span>]</span><br></pre></td></tr></table></figure>
<p>参考一个类似函数 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.reduce" target="_blank" rel="noopener"><code>functools.reduce()</code></a> ，它只返回一个最终累积值。</p>
<p><em>3.2 新版功能.</em></p>
<p><em>在 3.3 版更改:</em> 增加可选参数 <em>func</em> 。</p>
<p><em>在 3.8 版更改:</em> 添加了可选的 <em>initial</em> 形参。</p>
</li>
<li><p><code>itertools.chain</code>(<em>iterables</em>)</p>
<p>创建一个迭代器，它首先返回第一个可迭代对象中所有元素，接着返回下一个可迭代对象中所有元素，直到耗尽所有可迭代对象中的元素。可将多个序列处理为单个序列。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="comment"># chain('ABC', 'DEF') --&gt; A B C D E F</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">            <span class="keyword">yield</span> element</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>classmethod</em> <code>chain.from_iterable</code>(<em>iterable</em>)</p>
<p>构建类似 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.chain" target="_blank" rel="noopener"><code>chain()</code></a> 迭代器的另一个选择。从一个单独的可迭代参数中得到链式输入，该参数是延迟计算的。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">from_iterable</span><span class="params">(iterables)</span>:</span></span><br><span class="line">    <span class="comment"># chain.from_iterable(['ABC', 'DEF']) --&gt; A B C D E F</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">            <span class="keyword">yield</span> element</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>itertools.combinations</code>(<em>iterable</em>, <em>r</em>)</p>
<p>返回由输入 <em>iterable</em> 中元素组成长度为 <em>r</em> 的子序列。组合按照字典序返回。所以如果输入 <em>iterable</em> 是有序的，生成的组合元组也是有序的。即使元素的值相同，不同位置的元素也被认为是不同的。如果元素各自不同，那么每个组合中没有重复元素。大致相当于:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinations</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    <span class="comment"># combinations('ABCD', 2) --&gt; AB AC AD BC BD CD</span></span><br><span class="line">    <span class="comment"># combinations(range(4), 3) --&gt; 012 013 023 123</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    <span class="keyword">if</span> r &gt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">  indices = list(range(r))</span><br><span class="line">    <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(r)):</span><br><span class="line">            <span class="keyword">if</span> indices[i] != i + n - r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        indices[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, r):</span><br><span class="line">            indices[j] = indices[j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure>
<p><code>combinations()</code> 的代码可被改写为 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.permutations" target="_blank" rel="noopener"><code>permutations()</code></a> 过滤后的子序列，（相对于元素在输入中的位置）元素不是有序的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinations</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    <span class="keyword">for</span> indices <span class="keyword">in</span> permutations(range(n), r):</span><br><span class="line">        <span class="keyword">if</span> sorted(indices) == list(indices):</span><br><span class="line">            <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当 <code>0 &lt;= r &lt;= n</code> 时，返回项的个数是 <code>n! / r! / (n-r)!</code>；当 <code>r &gt; n</code> 时，返回项个数为0。</p>
<ul>
<li><p><code>itertools.combinations_with_replacement</code>(<em>iterable</em>, <em>r</em>)</p>
<p>返回由输入 <em>iterable</em> 中元素组成的长度为 <em>r</em> 的子序列，允许每个元素可重复出现。组合按照字典序返回。所以如果输入 <em>iterable</em> 是有序的，生成的组合元组也是有序的。不同位置的元素是不同的，即使它们的值相同。因此如果输入中的元素都是不同的话，返回的组合中元素也都会不同。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinations_with_replacement</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    <span class="comment"># combinations_with_replacement('ABC', 2) --&gt; AA AB AC BB BC CC</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">and</span> r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    indices = [<span class="number">0</span>] * r</span><br><span class="line">    <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(r)):</span><br><span class="line">            <span class="keyword">if</span> indices[i] != n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        indices[i:] = [indices[i] + <span class="number">1</span>] * (r - i)</span><br><span class="line">        <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure>
<p> <code>combinations_with_replacement() 的代码可被改写为</code>production()` 过滤后的子序列，（相对于元素在输入中的位置）元素不是有序的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinations_with_replacement</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    <span class="keyword">for</span> indices <span class="keyword">in</span> product(range(n), repeat=r):</span><br><span class="line">        <span class="keyword">if</span> sorted(indices) == list(indices):</span><br><span class="line">            <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>itertools.compress</code>(<em>data</em>, <em>selectors</em>)</p>
<p>创建一个迭代器，它返回 <em>data</em> 中经 <em>selectors</em> 真值测试为 <code>True</code> 的元素。迭代器在两者较短的长度处停止。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress</span><span class="params">(data, selectors)</span>:</span></span><br><span class="line">    <span class="comment"># compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F</span></span><br><span class="line">    <span class="keyword">return</span> (d <span class="keyword">for</span> d, s <span class="keyword">in</span> zip(data, selectors) <span class="keyword">if</span> s)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>itertools.count</code>(<em>start=0</em>, <em>step=1</em>)</p>
<p>创建一个迭代器，它从 <em>start</em> 值开始，返回均匀间隔的值。常用于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 中的实参来生成连续的数据点。此外，还用于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#zip" target="_blank" rel="noopener"><code>zip()</code></a> 来添加序列号。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(start=<span class="number">0</span>, step=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment"># count(10) --&gt; 10 11 12 13 14 ...</span></span><br><span class="line">    <span class="comment"># count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += step</span><br><span class="line">~</span><br></pre></td></tr></table></figure>
<p>当对浮点数计数时，替换为乘法代码有时精度会更好，例如： <code>(start + step * i for i in count())</code> 。<em>在 3.1 版更改:</em> 增加参数 <em>step</em> ，允许非整型。</p>
</li>
<li><p><code>itertools.cycle</code>(<em>iterable</em>)</p>
<p>创建一个迭代器，返回 <em>iterable</em> 中所有元素并保存一个副本。当取完 <em>iterable</em> 中所有元素，返回副本中的所有元素。无限重复。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cycle</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="comment"># cycle('ABCD') --&gt; A B C D A B C D A B C D ...</span></span><br><span class="line">    saved = []</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">yield</span> element</span><br><span class="line">        saved.append(element)</span><br><span class="line">    <span class="keyword">while</span> saved:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> saved:</span><br><span class="line">              <span class="keyword">yield</span> element</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>   `注意，该函数可能需要相当大的辅助空间（取决于 <em>iterable</em> 的长度）。</p>
<ul>
<li><p><code>itertools.dropwhile</code>(<em>predicate</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，如果 <em>predicate</em> 为true，迭代器丢弃这些元素，然后返回其他元素。注意，迭代器在 <em>predicate</em> 首次为false之前不会产生任何输出，所以可能需要一定长度的启动时间。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropwhile</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1</span></span><br><span class="line">    iterable = iter(iterable)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">yield</span> x</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>itertools.filterfalse</code>(<em>predicate</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，只返回 <em>iterable</em> 中 <em>predicate</em> 为 <code>False</code> 的元素。如果 <em>predicate</em> 是 <code>None</code>，返回真值测试为false的元素。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filterfalse</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># filterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8</span></span><br><span class="line">    <span class="keyword">if</span> predicate <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        predicate = bool</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>itertools.groupby</code>(<em>iterable</em>, <em>key=None</em>)</p>
<p>创建一个迭代器，返回 <em>iterable</em> 中连续的键和组。<em>key</em> 是一个计算元素键值函数。如果未指定或为 <code>None</code>，<em>key</em> 缺省为恒等函数（identity function），返回元素不变。一般来说，<em>iterable</em> 需用同一个键值函数预先排序。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.groupby" target="_blank" rel="noopener"><code>groupby()</code></a> 操作类似于Unix中的 <code>uniq</code>。当每次 <em>key</em> 函数产生的键值改变时，迭代器会分组或生成一个新组（这就是为什么通常需要使用同一个键值函数先对数据进行排序）。这种行为与SQL的GROUP BY操作不同，SQL的操作会忽略输入的顺序将相同键值的元素分在同组中。</p>
<p>返回的组本身也是一个迭代器，它与 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.groupby" target="_blank" rel="noopener"><code>groupby()</code></a> 共享底层的可迭代对象。因为源是共享的，当 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.groupby" target="_blank" rel="noopener"><code>groupby()</code></a> 对象向后迭代时，前一个组将消失。因此如果稍后还需要返回结果，可保存为列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">groups = []</span><br><span class="line">uniquekeys = []</span><br><span class="line">data = sorted(data, key=keyfunc)</span><br><span class="line"><span class="keyword">for</span> k, g <span class="keyword">in</span> groupby(data, keyfunc):</span><br><span class="line">    groups.append(list(g))      <span class="comment"># Store group iterator as a list</span></span><br><span class="line">    uniquekeys.append(k)</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.groupby" target="_blank" rel="noopener"><code>groupby()</code></a> 大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">groupby</span>:</span></span><br><span class="line">    <span class="comment"># [k for k, g in groupby('AAAABBBCCDAABBB')] --&gt; A B C D A B</span></span><br><span class="line">    <span class="comment"># [list(g) for k, g in groupby('AAAABBBCCD')] --&gt; AAAA BBB CC D</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable, key=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            key = <span class="keyword">lambda</span> x: x</span><br><span class="line">        self.keyfunc = key</span><br><span class="line">        self.it = iter(iterable)</span><br><span class="line">        self.tgtkey = self.currkey = self.currvalue = object()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.id = object()</span><br><span class="line">        <span class="keyword">while</span> self.currkey == self.tgtkey:</span><br><span class="line">            self.currvalue = next(self.it)    <span class="comment"># Exit on StopIteration</span></span><br><span class="line">            self.currkey = self.keyfunc(self.currvalue)</span><br><span class="line">        self.tgtkey = self.currkey</span><br><span class="line">        <span class="keyword">return</span> (self.currkey, self._grouper(self.tgtkey, self.id))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_grouper</span><span class="params">(self, tgtkey, id)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.id <span class="keyword">is</span> id <span class="keyword">and</span> self.currkey == tgtkey:</span><br><span class="line">            <span class="keyword">yield</span> self.currvalue</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.currvalue = next(self.it)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.currkey = self.keyfunc(self.currvalue)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>itertools.islice</code>(<em>iterable</em>, <em>stop</em>)</p>
</li>
<li><p><code>itertools.islice</code>(<em>iterable</em>, <em>start</em>, <em>stop</em>[, <em>step</em>])</p>
<p>创建一个迭代器，返回从 <em>iterable</em> 里选中的元素。如果 <em>start</em> 不是0，跳过 <em>iterable</em> 中的元素，直到到达 <em>start</em> 这个位置。之后迭代器连续返回元素，除非 <em>step</em> 设置的值很高导致被跳过。如果 <em>stop</em> 为 <code>None</code>，迭代器耗光为止；否则，在指定的位置停止。与普通的切片不同，<a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.islice" target="_blank" rel="noopener"><code>islice()</code></a> 不支持将 <em>start</em> ， <em>stop</em> ，或 <em>step</em> 设为负值。可用来从内部数据结构被压平的数据中提取相关字段（例如一个多行报告，它的名称字段出现在每三行上）。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">islice</span><span class="params">(iterable, *args)</span>:</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2) --&gt; A B</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2, 4) --&gt; C D</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2, None) --&gt; C D E F G</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 0, None, 2) --&gt; A C E G</span></span><br><span class="line">    s = slice(*args)</span><br><span class="line">    start, stop, step = s.start <span class="keyword">or</span> <span class="number">0</span>, s.stop <span class="keyword">or</span> sys.maxsize, s.step <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">    it = iter(range(start, stop, step))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        nexti = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># Consume *iterable* up to the *start* position.</span></span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> zip(range(start), iterable):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(iterable):</span><br><span class="line">            <span class="keyword">if</span> i == nexti:</span><br><span class="line">                <span class="keyword">yield</span> element</span><br><span class="line">                nexti = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># Consume to *stop*.</span></span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> zip(range(i + <span class="number">1</span>, stop), iterable):</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>如果 <em>start</em> 为 <code>None</code>，迭代从0开始。如果 <em>step</em> 为 <code>None</code> ，步长缺省为1。</p>
</li>
<li><p><code>itertools.permutations</code>(<em>iterable</em>, <em>r=None</em>)</p>
<p>连续返回由 <em>iterable</em> 元素生成长度为 <em>r</em> 的排列。如果 <em>r</em> 未指定或为 <code>None</code> ，<em>r</em> 默认设置为 <em>iterable</em> 的长度，这种情况下，生成所有全长排列。排列依字典序发出。因此，如果 <em>iterable</em> 是已排序的，排列元组将有序地产出。即使元素的值相同，不同位置的元素也被认为是不同的。如果元素值都不同，每个排列中的元素值不会重复。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(iterable, r=None)</span>:</span></span><br><span class="line">    <span class="comment"># permutations('ABCD', 2) --&gt; AB AC AD BA BC BD CA CB CD DA DB DC</span></span><br><span class="line">    <span class="comment"># permutations(range(3)) --&gt; 012 021 102 120 201 210</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    r = n <span class="keyword">if</span> r <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> r</span><br><span class="line">    <span class="keyword">if</span> r &gt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    indices = list(range(n))</span><br><span class="line">    cycles = list(range(n, n-r, <span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices[:r])</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(r)):</span><br><span class="line">            cycles[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cycles[i] == <span class="number">0</span>:</span><br><span class="line">                indices[i:] = indices[i+<span class="number">1</span>:] + indices[i:i+<span class="number">1</span>]</span><br><span class="line">                cycles[i] = n - i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = cycles[i]</span><br><span class="line">                indices[i], indices[-j] = indices[-j], indices[i]</span><br><span class="line">                <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices[:r])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.permutations" target="_blank" rel="noopener"><code>permutations()</code></a> 的代码也可被改写为 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.product" target="_blank" rel="noopener"><code>product()</code></a> 的子序列，只要将含有重复元素（来自输入中同一位置的）的项排除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(iterable, r=None)</span>:</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    r = n <span class="keyword">if</span> r <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> r</span><br><span class="line">    <span class="keyword">for</span> indices <span class="keyword">in</span> product(range(n), repeat=r):</span><br><span class="line">        <span class="keyword">if</span> len(set(indices)) == r:</span><br><span class="line">            <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure>
<p>当 <code>0 &lt;= r &lt;= n</code> ，返回项个数为 <code>n! / (n-r)!</code> ；当 <code>r &gt; n</code> ，返回项个数为0。</p>
</li>
<li><p><code>itertools.product</code>(*<em>iterables</em>, <em>repeat=1</em>)</p>
<p>可迭代对象输入的笛卡儿积。大致相当于生成器表达式中的嵌套循环。例如， <code>product(A, B)</code> 和 <code>((x,y) for x in A for y in B)</code> 返回结果一样。</p>
<p>嵌套循环像里程表那样循环变动，每次迭代时将最右侧的元素向后迭代。这种模式形成了一种字典序，因此如果输入的可迭代对象是已排序的，笛卡尔积元组依次序发出。</p>
<p>要计算可迭代对象自身的笛卡尔积，将可选参数 <em>repeat</em> 设定为要重复的次数。例如，<code>product(A, repeat=4)</code> 和 <code>product(A, A, A, A)</code> 是一样的。</p>
<p>该函数大致相当于下面的代码，只不过实际实现方案不会在内存中创建中间结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(*args, repeat=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment"># product('ABCD', 'xy') --&gt; Ax Ay Bx By Cx Cy Dx Dy</span></span><br><span class="line">    <span class="comment"># product(range(2), repeat=3) --&gt; 000 001 010 011 100 101 110 111</span></span><br><span class="line">    pools = [tuple(pool) <span class="keyword">for</span> pool <span class="keyword">in</span> args] * repeat</span><br><span class="line">    result = [[]]</span><br><span class="line">    <span class="keyword">for</span> pool <span class="keyword">in</span> pools:</span><br><span class="line">        result = [x+[y] <span class="keyword">for</span> x <span class="keyword">in</span> result <span class="keyword">for</span> y <span class="keyword">in</span> pool]</span><br><span class="line">    <span class="keyword">for</span> prod <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">yield</span> tuple(prod)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>itertools.repeat</code>(<em>object</em>[, <em>times</em>])</p>
<p>创建一个迭代器，不断重复 <em>object</em> 。除非设定参数 <em>times</em> ，否则将无限重复。可用于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 函数中的参数，被调用函数可得到一个不变参数。也可用于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#zip" target="_blank" rel="noopener"><code>zip()</code></a> 的参数以在元组记录中创建一个不变的部分。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeat</span><span class="params">(object, times=None)</span>:</span></span><br><span class="line">    <span class="comment"># repeat(10, 3) --&gt; 10 10 10</span></span><br><span class="line">    <span class="keyword">if</span> times <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">yield</span> object</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">            <span class="keyword">yield</span> object</span><br></pre></td></tr></table></figure>
<p><em>repeat</em> 最常见的用途就是在 <em>map</em> 或 <em>zip</em> 提供一个常量流：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(pow, range(<span class="number">10</span>), repeat(<span class="number">2</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>itertools.starmap</code>(<em>function</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，使用从可迭代对象中获取的参数来计算该函数。当参数对应的形参已从一个单独可迭代对象组合为元组时（数据已被“预组对”）可用此函数代替 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 与 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.starmap" target="_blank" rel="noopener"><code>starmap()</code></a> 之间的区别可以类比 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">starmap</span><span class="params">(function, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000</span></span><br><span class="line">    <span class="keyword">for</span> args <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">yield</span> function(*args)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>itertools.takewhile</code>(<em>predicate</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，只要 predicate 为真就从可迭代对象中返回元素。大致相当于:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takewhile</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>itertools.tee</code>(<em>iterable</em>, <em>n=2</em>)</p>
<p>从一个可迭代对象中返回 <em>n</em> 个独立的迭代器。下面的Python代码能帮助解释 <em>tee</em> 做了什么（尽管实际的实现更复杂，而且仅使用了一个底层的 FIFO 队列）。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tee</span><span class="params">(iterable, n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    deques = [collections.deque() <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(mydeque)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> mydeque:             <span class="comment"># when the local deque is empty</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    newval = next(it)   <span class="comment"># fetch a new value and</span></span><br><span class="line">                <span class="keyword">except</span> StopIteration:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> deques:        <span class="comment"># load it to all the deques</span></span><br><span class="line">                    d.append(newval)</span><br><span class="line">            <span class="keyword">yield</span> mydeque.popleft()</span><br><span class="line">    <span class="keyword">return</span> tuple(gen(d) <span class="keyword">for</span> d <span class="keyword">in</span> deques)</span><br></pre></td></tr></table></figure>
<p>一旦 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.tee" target="_blank" rel="noopener"><code>tee()</code></a> 实施了一次分裂，原有的 <em>iterable</em> 不应再被使用；否则tee对象无法得知 <em>iterable</em> 可能已向后迭代。</p>
<p><code>tee</code> 迭代器不是线程安全的。当同时使用由同一个 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.tee" target="_blank" rel="noopener"><code>tee()</code></a> 调用所返回的迭代器时可能引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>，即使原本的 <em>iterable</em> 是线程安全的。</p>
<p>该迭代工具可能需要相当大的辅助存储空间（这取决于要保存多少临时数据）。通常，如果一个迭代器在另一个迭代器开始之前就要使用大部份或全部数据，使用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list()</code></a> 会比 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.tee" target="_blank" rel="noopener"><code>tee()</code></a> 更快。</p>
</li>
<li><p><code>itertools.zip_longest</code>(*<em>iterables</em>, <em>fillvalue=None</em>)</p>
<p>创建一个迭代器，从每个可迭代对象中收集元素。如果可迭代对象的长度未对齐，将根据 <em>fillvalue</em> 填充缺失值。迭代持续到耗光最长的可迭代对象。大致相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip_longest</span><span class="params">(*args, fillvalue=None)</span>:</span></span><br><span class="line">    <span class="comment"># zip_longest('ABCD', 'xy', fillvalue='-') --&gt; Ax By C- D-</span></span><br><span class="line">    iterators = [iter(it) <span class="keyword">for</span> it <span class="keyword">in</span> args]</span><br><span class="line">    num_active = len(iterators)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> num_active:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        values = []</span><br><span class="line">        <span class="keyword">for</span> i, it <span class="keyword">in</span> enumerate(iterators):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                value = next(it)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                num_active -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> num_active:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                iterators[i] = repeat(fillvalue)</span><br><span class="line">                value = fillvalue</span><br><span class="line">            values.append(value)</span><br><span class="line">        <span class="keyword">yield</span> tuple(values)</span><br></pre></td></tr></table></figure>
<p>如果其中一个可迭代对象有无限长度，<a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.zip_longest" target="_blank" rel="noopener"><code>zip_longest()</code></a> 函数应封装在限制调用次数的场景中（例如 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.islice" target="_blank" rel="noopener"><code>islice()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.takewhile" target="_blank" rel="noopener"><code>takewhile()</code></a>）。除非指定， <em>fillvalue</em> 默认为 <code>None</code> 。</p>
</li>
</ul>
<h2 id="itertools-扩展"><a href="#itertools-扩展" class="headerlink" title="itertools 扩展"></a>itertools 扩展</h2><p>本节将展示如何使用现有的 itertools 作为基础构件来创建扩展的工具集。</p>
<p>基本上所有这些西方和许许多多其他的配方都可以通过 Python Package Index 上的 <a href="https://pypi.org/project/more-itertools/" target="_blank" rel="noopener">more-itertools 项目</a> 来安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install more-itertools</span><br></pre></td></tr></table></figure>
<p>扩展的工具提供了与底层工具集相同的高性能。保持了超棒的内存利用率，因为一次只处理一个元素，而不是将整个可迭代对象加载到内存。代码量保持得很小，以函数式风格将这些工具连接在一起，有助于消除临时变量。速度依然很快，因为倾向于使用“矢量化”构件来取代解释器开销大的 for 循环和 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span><span class="params">(n, iterable)</span>:</span></span><br><span class="line">    <span class="string">"Return first n items of the iterable as a list"</span></span><br><span class="line">    <span class="keyword">return</span> list(islice(iterable, n))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepend</span><span class="params">(value, iterator)</span>:</span></span><br><span class="line">    <span class="string">"Prepend a single value in front of an iterator"</span></span><br><span class="line">    <span class="comment"># prepend(1, [2, 3, 4]) -&gt; 1 2 3 4</span></span><br><span class="line">    <span class="keyword">return</span> chain([value], iterator)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tabulate</span><span class="params">(function, start=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"Return function(0), function(1), ..."</span></span><br><span class="line">    <span class="keyword">return</span> map(function, count(start))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tail</span><span class="params">(n, iterable)</span>:</span></span><br><span class="line">    <span class="string">"Return an iterator over the last n items"</span></span><br><span class="line">    <span class="comment"># tail(3, 'ABCDEFG') --&gt; E F G</span></span><br><span class="line">    <span class="keyword">return</span> iter(collections.deque(iterable, maxlen=n))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">(iterator, n=None)</span>:</span></span><br><span class="line">    <span class="string">"Advance the iterator n-steps ahead. If n is None, consume entirely."</span></span><br><span class="line">    <span class="comment"># Use functions that consume iterators at C speed.</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># feed the entire iterator into a zero-length deque</span></span><br><span class="line">        collections.deque(iterator, maxlen=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># advance to the empty slice starting at position n</span></span><br><span class="line">        next(islice(iterator, n, n), <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nth</span><span class="params">(iterable, n, default=None)</span>:</span></span><br><span class="line">    <span class="string">"Returns the nth item or a default value"</span></span><br><span class="line">    <span class="keyword">return</span> next(islice(iterable, n, <span class="literal">None</span>), default)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_equal</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="string">"Returns True if all the elements are equal to each other"</span></span><br><span class="line">    g = groupby(iterable)</span><br><span class="line">    <span class="keyword">return</span> next(g, <span class="literal">True</span>) <span class="keyword">and</span> <span class="keyword">not</span> next(g, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantify</span><span class="params">(iterable, pred=bool)</span>:</span></span><br><span class="line">    <span class="string">"Count how many times the predicate is true"</span></span><br><span class="line">    <span class="keyword">return</span> sum(map(pred, iterable))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padnone</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="string">"""Returns the sequence elements and then returns None indefinitely.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Useful for emulating the behavior of the built-in map() function.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> chain(iterable, repeat(<span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ncycles</span><span class="params">(iterable, n)</span>:</span></span><br><span class="line">    <span class="string">"Returns the sequence elements n times"</span></span><br><span class="line">    <span class="keyword">return</span> chain.from_iterable(repeat(tuple(iterable), n))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dotproduct</span><span class="params">(vec1, vec2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(map(operator.mul, vec1, vec2))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(list_of_lists)</span>:</span></span><br><span class="line">    <span class="string">"Flatten one level of nesting"</span></span><br><span class="line">    <span class="keyword">return</span> chain.from_iterable(list_of_lists)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeatfunc</span><span class="params">(func, times=None, *args)</span>:</span></span><br><span class="line">    <span class="string">"""Repeat calls to func with specified arguments.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Example:  repeatfunc(random.random)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> times <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> starmap(func, repeat(args))</span><br><span class="line">    <span class="keyword">return</span> starmap(func, repeat(args, times))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pairwise</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="string">"s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."</span></span><br><span class="line">    a, b = tee(iterable)</span><br><span class="line">    next(b, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">return</span> zip(a, b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(iterable, n, fillvalue=None)</span>:</span></span><br><span class="line">    <span class="string">"Collect data into fixed-length chunks or blocks"</span></span><br><span class="line">    <span class="comment"># grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"</span></span><br><span class="line">    args = [iter(iterable)] * n</span><br><span class="line">    <span class="keyword">return</span> zip_longest(*args, fillvalue=fillvalue)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">roundrobin</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="string">"roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"</span></span><br><span class="line">    <span class="comment"># Recipe credited to George Sakkis</span></span><br><span class="line">    num_active = len(iterables)</span><br><span class="line">    nexts = cycle(iter(it).__next__ <span class="keyword">for</span> it <span class="keyword">in</span> iterables)</span><br><span class="line">    <span class="keyword">while</span> num_active:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> next <span class="keyword">in</span> nexts:</span><br><span class="line">                <span class="keyword">yield</span> next()</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="comment"># Remove the iterator we just exhausted from the cycle.</span></span><br><span class="line">            num_active -= <span class="number">1</span></span><br><span class="line">            nexts = cycle(islice(nexts, num_active))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(pred, iterable)</span>:</span></span><br><span class="line">    <span class="string">'Use a predicate to partition entries into false entries and true entries'</span></span><br><span class="line">    <span class="comment"># partition(is_odd, range(10)) --&gt; 0 2 4 6 8   and  1 3 5 7 9</span></span><br><span class="line">    t1, t2 = tee(iterable)</span><br><span class="line">    <span class="keyword">return</span> filterfalse(pred, t1), filter(pred, t2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">powerset</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="string">"powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"</span></span><br><span class="line">    s = list(iterable)</span><br><span class="line">    <span class="keyword">return</span> chain.from_iterable(combinations(s, r) <span class="keyword">for</span> r <span class="keyword">in</span> range(len(s)+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unique_everseen</span><span class="params">(iterable, key=None)</span>:</span></span><br><span class="line">    <span class="string">"List unique elements, preserving order. Remember all elements ever seen."</span></span><br><span class="line">    <span class="comment"># unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D</span></span><br><span class="line">    <span class="comment"># unique_everseen('ABBCcAD', str.lower) --&gt; A B C D</span></span><br><span class="line">    seen = set()</span><br><span class="line">    seen_add = seen.add</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> filterfalse(seen.__contains__, iterable):</span><br><span class="line">            seen_add(element)</span><br><span class="line">            <span class="keyword">yield</span> element</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">            k = key(element)</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen_add(k)</span><br><span class="line">                <span class="keyword">yield</span> element</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unique_justseen</span><span class="params">(iterable, key=None)</span>:</span></span><br><span class="line">    <span class="string">"List unique elements, preserving order. Remember only the element just seen."</span></span><br><span class="line">    <span class="comment"># unique_justseen('AAAABBBCCDAABBB') --&gt; A B C D A B</span></span><br><span class="line">    <span class="comment"># unique_justseen('ABBCcAD', str.lower) --&gt; A B C A D</span></span><br><span class="line">    <span class="keyword">return</span> map(next, map(operator.itemgetter(<span class="number">1</span>), groupby(iterable, key)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter_except</span><span class="params">(func, exception, first=None)</span>:</span></span><br><span class="line">    <span class="string">""" Call a function repeatedly until an exception is raised.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Converts a call-until-exception interface to an iterator interface.</span></span><br><span class="line"><span class="string">    Like builtins.iter(func, sentinel) but uses an exception instead</span></span><br><span class="line"><span class="string">    of a sentinel to end the loop.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Examples:</span></span><br><span class="line"><span class="string">        iter_except(functools.partial(heappop, h), IndexError)   # priority queue iterator</span></span><br><span class="line"><span class="string">        iter_except(d.popitem, KeyError)                         # non-blocking dict iterator</span></span><br><span class="line"><span class="string">        iter_except(d.popleft, IndexError)                       # non-blocking deque iterator</span></span><br><span class="line"><span class="string">        iter_except(q.get_nowait, Queue.Empty)                   # loop over a producer Queue</span></span><br><span class="line"><span class="string">        iter_except(s.pop, KeyError)                             # non-blocking set iterator</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> first <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> first()            <span class="comment"># For database APIs needing an initial cast to db.first()</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">yield</span> func()</span><br><span class="line">    <span class="keyword">except</span> exception:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_true</span><span class="params">(iterable, default=False, pred=None)</span>:</span></span><br><span class="line">    <span class="string">"""Returns the first true value in the iterable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If no true value is found, returns *default*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If *pred* is not None, returns the first item</span></span><br><span class="line"><span class="string">    for which pred(item) is true.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># first_true([a,b,c], x) --&gt; a or b or c or x</span></span><br><span class="line">    <span class="comment"># first_true([a,b], x, f) --&gt; a if f(a) else b if f(b) else x</span></span><br><span class="line">    <span class="keyword">return</span> next(filter(pred, iterable), default)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_product</span><span class="params">(*args, repeat=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">"Random selection from itertools.product(*args, **kwds)"</span></span><br><span class="line">    pools = [tuple(pool) <span class="keyword">for</span> pool <span class="keyword">in</span> args] * repeat</span><br><span class="line">    <span class="keyword">return</span> tuple(random.choice(pool) <span class="keyword">for</span> pool <span class="keyword">in</span> pools)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_permutation</span><span class="params">(iterable, r=None)</span>:</span></span><br><span class="line">    <span class="string">"Random selection from itertools.permutations(iterable, r)"</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    r = len(pool) <span class="keyword">if</span> r <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> r</span><br><span class="line">    <span class="keyword">return</span> tuple(random.sample(pool, r))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_combination</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    <span class="string">"Random selection from itertools.combinations(iterable, r)"</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    indices = sorted(random.sample(range(n), r))</span><br><span class="line">    <span class="keyword">return</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_combination_with_replacement</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    <span class="string">"Random selection from itertools.combinations_with_replacement(iterable, r)"</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    indices = sorted(random.randrange(n) <span class="keyword">for</span> i <span class="keyword">in</span> range(r))</span><br><span class="line">    <span class="keyword">return</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nth_combination</span><span class="params">(iterable, r, index)</span>:</span></span><br><span class="line">    <span class="string">'Equivalent to list(combinations(iterable, r))[index]'</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    <span class="keyword">if</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> r &gt; n:</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br><span class="line">    c = <span class="number">1</span></span><br><span class="line">    k = min(r, n-r)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">        c = c * (n - k + i) // i</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">        index += c</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= c:</span><br><span class="line">        <span class="keyword">raise</span> IndexError</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> r:</span><br><span class="line">        c, n, r = c*r//n, n<span class="number">-1</span>, r<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> index &gt;= c:</span><br><span class="line">            index -= c</span><br><span class="line">            c, n = c*(n-r)//n, n<span class="number">-1</span></span><br><span class="line">        result.append(pool[<span class="number">-1</span>-n])</span><br><span class="line">    <span class="keyword">return</span> tuple(result)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>itertools</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library statistics</title>
    <url>/2020/02/06/python-standard-library-statistics/</url>
    <content><![CDATA[<h1 id="python-标准库-statistics-数学统计函数"><a href="#python-标准库-statistics-数学统计函数" class="headerlink" title="python 标准库 statistics 数学统计函数"></a>python 标准库 statistics 数学统计函数</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200206update.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p> I have self-doubt. I have insecurity. I have fear of failure. I have nights when I show up at the arena and I’m like, ‘My back hurts, my feet hurt, my knees hurt. I don’t have it. I just want to chill.’ We all have self-doubt. You don’t deny it, but you also don’t capitulate to it. You embrace it.<br>我有自我怀疑。我有不安全感。我害怕失败。当我出现在竞技场的时候，我会说，‘我的背疼，我的脚疼，我的膝盖疼。我没有打赢的信心。我只是想冷静一下。’我们都有自我怀疑。你不要否认，但你也不屈服于它。你要拥抱它。 </p>
<p>​                                                                                                                                                  by   Kobe Bryant </p>
</blockquote>
<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27867449&auto=0&height=66"></iframe></p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/statistics.py" target="_blank" rel="noopener">Lib/statistics.py</a></p>
<p><em>主要方法</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">==================  ==================================================</span><br><span class="line">Function            Description</span><br><span class="line">==================  ==================================================</span><br><span class="line">mean                Arithmetic mean (average) of data.</span><br><span class="line">fmean               Fast, floating point arithmetic mean.</span><br><span class="line">geometric_mean      Geometric mean of data.</span><br><span class="line">harmonic_mean       Harmonic mean of data.</span><br><span class="line">median              Median (middle value) of data.</span><br><span class="line">median_low          Low median of data.</span><br><span class="line">median_high         High median of data.</span><br><span class="line">median_grouped      Median, <span class="keyword">or</span> <span class="number">50</span>th percentile, of grouped data.</span><br><span class="line">mode                Mode (most common value) of data.</span><br><span class="line">multimode           List of modes (most common values of data).</span><br><span class="line">quantiles           Divide data into intervals <span class="keyword">with</span> equal probability.</span><br><span class="line">==================  ==================================================</span><br></pre></td></tr></table></figure>
<hr>
<p>该模块提供了用于计算数字 (<a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Real" target="_blank" rel="noopener"><code>Real</code></a>-valued) 数据的数理统计量的函数。</p>
<p>此模块并不是诸如 <a href="https://numpy.org/" target="_blank" rel="noopener">NumPy</a> ， <a href="https://www.scipy.org/" target="_blank" rel="noopener">SciPy</a> 等第三方库或者诸如 Minitab ， SAS ， Matlab 等针对专业统计学家的专有全功能统计软件包的竟品。此模块针对图形和科学计算器的水平。</p>
<p>除非明确注释，这些函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>Decimal</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 。当前不支持同其他类型（是否在数字塔中）的行为。混合类型的集合也是未定义的，并且依赖于实现。如果你输入的数据由混合类型组成，你应该能够使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 来确保一个一致的结果，比如： <code>map(float, input_data)</code> 。</p>
<h2 id="中心位置的平均值和度量"><a href="#中心位置的平均值和度量" class="headerlink" title="中心位置的平均值和度量"></a>中心位置的平均值和度量</h2><p> 这些函数计算一个整体或样本的平均值或者特定值 </p>
<table>
<thead>
<tr>
<th><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.mean" target="_blank" rel="noopener"><code>mean()</code></a></th>
<th>数据的算术平均数（“平均数”）。</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.fmean" target="_blank" rel="noopener"><code>fmean()</code></a></td>
<td>快速的，浮点算数平均数。</td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.geometric_mean" target="_blank" rel="noopener"><code>geometric_mean()</code></a></td>
<td>数据的几何平均数</td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.harmonic_mean" target="_blank" rel="noopener"><code>harmonic_mean()</code></a></td>
<td>数据的调和均值</td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median" target="_blank" rel="noopener"><code>median()</code></a></td>
<td>数据的中位数（中间值）</td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_low" target="_blank" rel="noopener"><code>median_low()</code></a></td>
<td>数据的低中位数</td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_high" target="_blank" rel="noopener"><code>median_high()</code></a></td>
<td>数据的高中位数</td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_grouped" target="_blank" rel="noopener"><code>median_grouped()</code></a></td>
<td>分组数据的中位数，即第50个百分点。</td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.mode" target="_blank" rel="noopener"><code>mode()</code></a></td>
<td>离散的或标称的数据的单模（最常见的值）。</td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.multimode" target="_blank" rel="noopener"><code>multimode()</code></a></td>
<td>离散的或标称的数据的模式列表（最常见的值）。</td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.quantiles" target="_blank" rel="noopener"><code>quantiles()</code></a></td>
<td>将数据以相等的概率分为多个间隔。</td>
</tr>
</tbody>
</table>
<h2 id="传播措施"><a href="#传播措施" class="headerlink" title="传播措施"></a>传播措施</h2><p>这些函数计算多少总体或者样本偏离典型值或平均值的度量。</p>
<table>
<thead>
<tr>
<th><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.pstdev" target="_blank" rel="noopener"><code>pstdev()</code></a></th>
<th>数据的总体标准差</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.pvariance" target="_blank" rel="noopener"><code>pvariance()</code></a></td>
<td>数据的总体方差</td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.stdev" target="_blank" rel="noopener"><code>stdev()</code></a></td>
<td>数据的样本标准差</td>
</tr>
<tr>
<td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.variance" target="_blank" rel="noopener"><code>variance()</code></a></td>
<td>数据的样本方差</td>
</tr>
</tbody>
</table>
<h2 id="函数细节"><a href="#函数细节" class="headerlink" title="函数细节"></a>函数细节</h2><p>这些函数不需要对提供给它们的数据进行排序。但是，为了方便阅读，大多数例子展示的是已排序的序列。</p>
<ul>
<li><p><code>statistics.mean</code>(<em>data</em>)</p>
<p>返回 <em>data</em> 的样本算术平均数，形式为序列或迭代器。算术平均数是数据之和与数据点个数的商。通常称作“平均数”，尽管它指示诸多数学平均数之一。它是数据的中心位置的度量。若 <em>data</em> 为空，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。一些用法示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">2.8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean([<span class="number">-1.0</span>, <span class="number">2.5</span>, <span class="number">3.25</span>, <span class="number">5.75</span>])</span><br><span class="line"><span class="number">2.625</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction <span class="keyword">as</span> F</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean([F(<span class="number">3</span>, <span class="number">7</span>), F(<span class="number">1</span>, <span class="number">21</span>), F(<span class="number">5</span>, <span class="number">3</span>), F(<span class="number">1</span>, <span class="number">3</span>)])</span><br><span class="line">Fraction(<span class="number">13</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal <span class="keyword">as</span> D</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean([D(<span class="string">"0.5"</span>), D(<span class="string">"0.75"</span>), D(<span class="string">"0.625"</span>), D(<span class="string">"0.375"</span>)])</span><br><span class="line">Decimal(<span class="string">'0.5625'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>statistics.fmean</code>(<em>data</em>) </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">将浮点数转换成 data 并且计算算术平均数。</span><br><span class="line"></span><br><span class="line">此函数的运行速度比 mean() 函数快并且它总是返回一个 float。 data 可以为序列或迭代器。 如果输入数据集为空，则会引发 StatisticsError。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>statistics.geometric_mean</code>(<em>data</em>) </p>
<p>返回 <em>data</em> 调和均值，该参数可以是序列或包含实数值的可迭代对象。</p>
<p>调和均值,也叫次相反均值，所有数据的倒数的算术平均数 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.mean" target="_blank" rel="noopener"><code>mean()</code></a> 的倒数。比如说，数据 <em>a</em> ， <em>b</em> ， <em>c</em> 的调和均值等于 <code>3/(1/a + 1/b + 1/c)</code> 。如果其中一个值为零，结果为零。</p>
<p>调和均值是一种均值类型，是数据中心位置的度量。它通常适合于求比率和比例的平均值，比如速率。</p>
<p>假设一辆车在 40 km/hr 的速度下行驶了 10 km ，然后又以 60 km/hr 的速度行驶了 10 km 。车辆的平均速率是多少？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>harmonic_mean([<span class="number">40</span>, <span class="number">60</span>])</span><br><span class="line"><span class="number">48.0</span></span><br></pre></td></tr></table></figure>
<p>假设一名投资者在三家公司各购买了等价值的股票，以 2.5， 3 ， 10 的 P/E (价格/收益) 率。投资者投资组合的平均市盈率是多少？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>harmonic_mean([<span class="number">2.5</span>, <span class="number">3</span>, <span class="number">10</span>])  <span class="comment"># For an equal investment portfolio.</span></span><br><span class="line"><span class="number">3.6</span></span><br></pre></td></tr></table></figure>
<p>如果 <em>data</em> 为空或者 任何一个元素的值小于零，会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a> 。</p>
<p>当前算法在输入中遇到零时会提前退出。这意味着不会测试后续输入的有效性。（此行为将来可能会更改。）</p>
</li>
<li><p><code>statistics.median</code>(<em>data</em>) </p>
<p>使用普通的“取中间两数平均值”方法返回数值数据的中位数（中间值）。 如果 <em>data</em> 为空，则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。 <em>data</em> 可以是序列或可迭代对象。</p>
<p>中位数是衡量中间位置的可靠方式，并且较少受到极端值的影响。 当数据点的总数为奇数时，将返回中间数据点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>当数据点的总数为偶数时，中位数将通过对两个中间值求平均进行插值得出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>])</span><br><span class="line"><span class="number">4.0</span></span><br></pre></td></tr></table></figure>
<p>这适用于当你的数据是离散的，并且你不介意中位数不是实际数据点的情况。</p>
<p>如果数据是有序的（支持排序操作）但不是数字（不支持加法），请考虑改用 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_low" target="_blank" rel="noopener"><code>median_low()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_high" target="_blank" rel="noopener"><code>median_high()</code></a>。</p>
</li>
<li><p><code>statistics.median_low</code>(<em>data</em>) </p>
<p>返回数值数据的低中位数。 如果 <em>data</em> 为空则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。 <em>data</em> 可以是序列或可迭代对象。</p>
<p>低中位数一定是数据集的成员。 当数据点总数为奇数时，将返回中间值。 当其为偶数时，将返回两个中间值中较小的那个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_low([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_low([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>])</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>当你的数据是离散的，并且你希望中位数是一个实际数据点而非插值结果时可以使用低中位数。</p>
</li>
<li><p><code>statistics.median_high</code>(<em>data</em>) </p>
<p>​    返回数据的高中位数。 如果 <em>data</em> 为空则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。 <em>data</em> 可以是序列或可迭代对象。</p>
<p>高中位数一定是数据集的成员。 当数据点总数为奇数时，将返回中间值。 当其为偶数时，将返回两个中间值中较大的那个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_high([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_high([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>])</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>当你的数据是离散的，并且你希望中位数是一个实际数据点而非插值结果时可以使用高中位数。</p>
</li>
<li><p><code>statistics.median_grouped</code>(<em>data</em>, <em>interval=1</em>) </p>
<p>返回分组的连续数据的中位数，根据第 50 个百分点的位置使用插值来计算。 如果 <em>data</em> 为空则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。 <em>data</em> 可以是序列或可迭代对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_grouped([<span class="number">52</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>])</span><br><span class="line"><span class="number">52.5</span></span><br></pre></td></tr></table></figure>
<p>在下面的示例中，数据已经过舍入，这样每个值都代表数据分类的中间点，例如 1 是 0.5–1.5 分类的中间点，2 是 1.5–2.5 分类的中间点，3 是 2.5–3.5 的中间点等待。 根据给定的数据，中间值应落在 3.5–4.5 分类之内，并可使用插值法来进行估算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_grouped([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">3.7</span></span><br></pre></td></tr></table></figure>
<p>可选参数 <em>interval</em> 表示分类间隔，默认值为 1。 改变分类间隔自然会改变插件结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_grouped([<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], interval=<span class="number">1</span>)</span><br><span class="line"><span class="number">3.25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_grouped([<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], interval=<span class="number">2</span>)</span><br><span class="line"><span class="number">3.5</span></span><br></pre></td></tr></table></figure>
<p>此函数不会检查数据点之间是否至少相隔 <em>interval</em> 的距离。</p>
</li>
<li><p><code>statistics.mode</code>(<em>data</em>) </p>
<p>根据离散或标称的 <em>data</em> 返回单个最觉的数据点。 此模式（如果存在）是最典型的值，并可用来度量中心的位置。</p>
<p>如果存在具有相同频率的多个模式，则返回在 <em>data</em> 中遇到的第一个。 如果想要其中最小或最大的一个，请使用 <code>min(multimode(data))</code> 或 <code>max(multimode(data))</code>。 如果输入的 <em>data</em> 为空，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p>
<p><code>mode</code> 将假定是离散数据并返回一个单一的值。 这是通常的学校教学中标准的处理方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; mode([1, 1, 2, 3, 3, 3, 3, 4])</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>此模式的独特之处在于它是这个包中唯一还可应用于标称（非数字）数据的统计信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; mode([&quot;red&quot;, &quot;blue&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;red&quot;, &quot;red&quot;])</span><br><span class="line">&apos;red&apos;</span><br></pre></td></tr></table></figure>
<p><em>在 3.8 版更改:</em> 现在会通过返回所遇到的第一个模式来处理多模数据集。 之前它会在遇到超过一个的模式时引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p>
</li>
<li><p><code>statistics.multimode</code>(<em>data</em>) </p>
<p>返回最频繁出现的值的列表，并按它们在 <em>data</em> 中首次出现的位置排序。 如果存在多种模式则将返回一个以上的模式，或者如果 <em>data</em> 为空则将返回空列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>multimode(<span class="string">'aabbbbccddddeeffffgg'</span>)</span><br><span class="line">[<span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'f'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>multimode(<span class="string">''</span>)</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p><em>3.8 新版功能.</em> </p>
</li>
<li><p><code>statistics.pstdev</code>(<em>data</em>, <em>mu=None</em>) </p>
<p>返回总体标准差（总体方差的平方根）。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.pvariance" target="_blank" rel="noopener"><code>pvariance()</code></a> 了解参数和其他细节。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pstdev([<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">2.5</span>, <span class="number">2.75</span>, <span class="number">3.25</span>, <span class="number">4.75</span>])</span><br><span class="line"><span class="number">0.986893273527251</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>statistics.pvariance</code>(<em>data</em>, <em>mu=None</em>) </p>
<p>返回非空序列或包含实数值的可迭代对象 <em>data</em> 的总体方差。 方差或称相对于均值的二阶距，是对数据变化幅度（延展度或分散度）的度量。 方差值较大表明数据的散布范围较大；方差值较小表明它紧密聚集于均值附近。</p>
<p>如果给出了可选的第二个参数 <em>mu</em>，它通常是 <em>data</em> 的均值。 它也可以被用来计算相对于一个非均值点的二阶距。 如果该参数省略或为 <code>None</code> (默认值)，则会自动进行算术均值的计算。</p>
<p>使用此函数可根据所有数值来计算方差。 要根据一个样本来估算方差，通常 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.variance" target="_blank" rel="noopener"><code>variance()</code></a> 函数是更好的选择。</p>
<p>如果 <em>data</em> 为空则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]</span><br><span class="line">&gt;&gt;&gt; pvariance(data)</span><br><span class="line">1.25</span><br></pre></td></tr></table></figure>
<p>如果你已经计算过数据的平均值，你可以将其作为可选的第二个参数 <em>mu</em> 传入以避免重复计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mu = mean(data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pvariance(data, mu)</span><br><span class="line"><span class="number">1.25</span></span><br></pre></td></tr></table></figure>
<p>同样也支持使用 Decimal 和 Fraction 值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal <span class="keyword">as</span> D</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pvariance([D(<span class="string">"27.5"</span>), D(<span class="string">"30.25"</span>), D(<span class="string">"30.25"</span>), D(<span class="string">"34.5"</span>), D(<span class="string">"41.75"</span>)])</span><br><span class="line">Decimal(<span class="string">'24.815'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction <span class="keyword">as</span> F</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pvariance([F(<span class="number">1</span>, <span class="number">4</span>), F(<span class="number">5</span>, <span class="number">4</span>), F(<span class="number">1</span>, <span class="number">2</span>)])</span><br><span class="line">Fraction(<span class="number">13</span>, <span class="number">72</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>statistics.stdev</code>(<em>data</em>, <em>xbar=None</em>) </p>
<p>返回样本标准差（样本方差的平方根）。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.variance" target="_blank" rel="noopener"><code>variance()</code></a> 了解参数和其他细节。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>stdev([<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">2.5</span>, <span class="number">2.75</span>, <span class="number">3.25</span>, <span class="number">4.75</span>])</span><br><span class="line"><span class="number">1.0810874155219827</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>statistics.variance</code>(<em>data</em>, <em>xbar=None</em>) </p>
<p>返回包含至少两个实数值的可迭代对象 <em>data</em> 的样本方差。 方差或称相对于均值的二阶矩，是对数据变化幅度（延展度或分散度）的度量。 方差值较大表明数据的散布范围较大；方差值较小表明它紧密聚集于均值附近。</p>
<p>如果给出了可选的第二个参数 <em>xbar</em>，它应当是 <em>data</em> 的均值。 如果该参数省略或为 <code>None</code> (默认值)，则会自动进行均值的计算。</p>
<p>当你的数据是总体数据的样本时请使用此函数。 要根据整个总体数据来计算方差，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.pvariance" target="_blank" rel="noopener"><code>pvariance()</code></a>。</p>
<p>如果 <em>data</em> 包含的值少于两个则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]</span><br><span class="line">&gt;&gt;&gt; variance(data)</span><br><span class="line">1.3720238095238095</span><br></pre></td></tr></table></figure>
<p>如果你已经计算过数据的平均值，你可以将其作为可选的第二个参数 <em>xbar</em> 传入以避免重复计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; m = mean(data)</span><br><span class="line">&gt;&gt;&gt; variance(data, m)</span><br><span class="line">1.3720238095238095</span><br></pre></td></tr></table></figure>
<p>此函数不会试图检查你所传入的 <em>xbar</em> 是否为真实的平均值。 使用任意值作为 <em>xbar</em> 可能导致无效或不可能的结果。</p>
<p>同样也支持使用 Decimal 和 Fraction 值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal <span class="keyword">as</span> D</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>variance([D(<span class="string">"27.5"</span>), D(<span class="string">"30.25"</span>), D(<span class="string">"30.25"</span>), D(<span class="string">"34.5"</span>), D(<span class="string">"41.75"</span>)])</span><br><span class="line">Decimal(<span class="string">'31.01875'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction <span class="keyword">as</span> F</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>variance([F(<span class="number">1</span>, <span class="number">6</span>), F(<span class="number">1</span>, <span class="number">2</span>), F(<span class="number">5</span>, <span class="number">3</span>)])</span><br><span class="line">Fraction(<span class="number">67</span>, <span class="number">108</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>statistics.quantiles</code>(<em>data</em>, <em>**, </em>n=4<em>, </em>method=’exclusive’*) </p>
<p>将 <em>data</em> 分隔为具有相等概率的 <em>n</em> 个连续区间。 返回分隔这些区间的 <code>n - 1</code> 个分隔点的列表。</p>
<p>将 <em>n</em> 设为 4 以使用四分位（默认值）。 将 <em>n</em> 设为 10 以使用十分位。 将 <em>n</em> 设为 100 以使用百分位，即给出 99 个分隔点来将 <em>data</em> 分隔为 100 个大小相等的组。 如果 <em>n</em> 小于 1 则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p>
<p><em>data</em> 可以是包含样本数据的任意可迭代对象。 为了获得有意义的结果，<em>data</em> 中数据点的数量应当大于 <em>n</em>。 如果数据点的数量小于两个则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p>
<p>分隔点是通过对两个最接近的数据点进行线性插值得到的。 例如，如果一个分隔点落在两个样本值 <code>100</code> 和 <code>112</code> 之间距离三分之一的位置，则分隔点的取值将为 <code>104</code>。</p>
<p><em>method</em> 用于计算分位值，它会由于 <em>data</em> 是包含还是排除总体的最低和最高可能值而有所不同。</p>
<p>默认 <em>method</em> 是 “唯一的” 并且被用于在总体中数据采样这样可以有比样本中找到的更多的极端值。落在 <em>m</em> 个排序数据点的第 <em>i-th</em> 个以下的总体部分被计算为 <code>i / (m + 1)</code> 。给定九个样本值，方法排序它们并且分配一下的百分位： 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90% 。</p>
<p>将 <em>method</em> 设为 “inclusive” 可用于描述总体数据或已明确知道包含有总体数据中最极端值的样本。 <em>data</em> 中的最小值会被作为第 0 个百分位而最大值会被作为第 100 个百分位。 总体数据里处于 <em>m</em> 个已排序数据点中 <em>第 i 个</em> 以下的部分会以 <code>(i - 1) / (m - 1)</code> 来计算。 给定 11 个样本值，该方法会对它们进行排序并赋予以下百分位: 0%, 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90%, 100%。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Decile cut points for empirically sampled data</span><br><span class="line">&gt;&gt;&gt; data = [105, 129, 87, 86, 111, 111, 89, 81, 108, 92, 110,</span><br><span class="line">...         100, 75, 105, 103, 109, 76, 119, 99, 91, 103, 129,</span><br><span class="line">...         106, 101, 84, 111, 74, 87, 86, 103, 103, 106, 86,</span><br><span class="line">...         111, 75, 87, 102, 121, 111, 88, 89, 101, 106, 95,</span><br><span class="line">...         103, 107, 101, 81, 109, 104]</span><br><span class="line">&gt;&gt;&gt; [round(q, 1) for q in quantiles(data, n=10)]</span><br><span class="line">[81.0, 86.2, 89.0, 99.4, 102.5, 103.6, 106.0, 109.8, 111.0]</span><br></pre></td></tr></table></figure>
<p><em>3.8 新版功能.</em></p>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>只定义了一个异常：</p>
<ul>
<li><p><em>exception</em> <code>statistics.StatisticsError</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 的子类，表示统计相关的异常。</p>
</li>
</ul>
<h2 id="NormalDist对象"><a href="#NormalDist对象" class="headerlink" title="NormalDist对象"></a><code>NormalDist</code>对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 工具可用于创建和操纵 <a href="http://www.stat.yale.edu/Courses/1997-98/101/ranvar.htm" target="_blank" rel="noopener">随机变量</a> 的正态分布。 这个类将数据度量值的平均值和标准差作为单一实体来处理。</p>
<p>正态分布的概念来自于 <a href="https://en.wikipedia.org/wiki/Central_limit_theorem" target="_blank" rel="noopener">中央极限定理</a> 并且在统计学中有广泛的应用。</p>
<ul>
<li><p><em>class</em> <code>statistics.NormalDist</code>(<em>mu=0.0</em>, <em>sigma=1.0</em></p>
<p>返回一个新的 <em>NormalDist</em> 对象，其中 <em>mu</em> 代表 <a href="https://en.wikipedia.org/wiki/Arithmetic_mean" target="_blank" rel="noopener">算术平均值</a> 而 <em>sigma</em> 代表 <a href="https://en.wikipedia.org/wiki/Standard_deviation" target="_blank" rel="noopener">标准差</a>。</p>
<p>若 <em>sigma</em> 为负数，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p>
<ul>
<li><p><code>mean</code></p>
<p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Arithmetic_mean" target="_blank" rel="noopener">算术平均值</a>。</p>
</li>
<li><p><code>median</code></p>
<p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Median" target="_blank" rel="noopener">中位数</a>。</p>
</li>
<li><p><code>mode</code></p>
<p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Mode_(statistics" target="_blank" rel="noopener">模式</a>)。</p>
</li>
<li><p><code>stdev</code></p>
<p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Standard_deviation" target="_blank" rel="noopener">标准差</a>。</p>
</li>
<li><p><code>variance</code><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist.variance" target="_blank" rel="noopener">¶</a></p>
<p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Variance" target="_blank" rel="noopener">方差</a>。 等于标准差的平方</p>
</li>
</ul>
</li>
<li><p><em>classmethod</em> <code>from_samples</code>(<em>data</em>)</p>
<p>传入使用 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.fmean" target="_blank" rel="noopener"><code>fmean()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.stdev" target="_blank" rel="noopener"><code>stdev()</code></a> 基于 <em>data</em> 估算出的 <em>mu</em> 和 <em>sigma</em> 形参创建一个正态分布实例。<em>data</em> 可以是任何 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterable" target="_blank" rel="noopener">iterable</a> 并且应当包含能被转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 类型的值。 如果 <em>data</em> 不包含至少两个元素，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>，因为估算中心值至少需要一个点而估算分散度至少需要两个点。</p>
</li>
<li><p><code>samples</code>(<em>n</em>, <em>**, </em>seed=None*)</p>
<p>对于给定的平均值和标准差生成 <em>n</em> 个随机样本。 返回一个由 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 值组成的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a>。当给定 <em>seed</em> 时，创建一个新的底层随机数生成器实例。 这适用于创建可重现的结果，即使对于多线程上下文也有效。</p>
</li>
<li><p><code>pdf</code>(<em>x</em>)</p>
<p>使用 <a href="https://en.wikipedia.org/wiki/Probability_density_function" target="_blank" rel="noopener">概率密度函数 (pdf)</a>，计算一个随机变量 <em>X</em> 趋向于给定值 <em>x</em> 的相对可能性。 在数学意义上，它是当 <em>dx</em> 趋向于零时比率 <code>P(x &lt;= X &lt; x+dx) / dx</code> 的极限。相对可能性的计算方法是用一个狭窄区间内某个样本出现的概率除以区间的宽度（因此使用“密度”一词）。 由于可能性是相对于其他点的，它的值可以大于 1.0。</p>
</li>
<li><p><code>cdf</code>(<em>x</em>)</p>
<p>使用 <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function" target="_blank" rel="noopener">累积分布函数 (cdf)</a>，计算一个随机变量 <em>X</em> 小于等于 <em>x</em> 的概率。 在数学上，它表示为 <code>P(X &lt;= x)</code>。</p>
</li>
<li><p><code>inv_cdf</code>(<em>p</em>)</p>
<p>计算反向累积分布函数，也称为 <a href="https://en.wikipedia.org/wiki/Quantile_function" target="_blank" rel="noopener">分位数函数</a> 或 <a href="https://www.statisticshowto.datasciencecentral.com/inverse-distribution-function/" target="_blank" rel="noopener">百分点</a> 函数。 在数学上，它表示为 <code>x : P(X &lt;= x) = p</code>。找出随机变量 <em>X</em> 的值 <em>x</em> 使得该变量小于等于该值的概率等于给定的概率 <em>p</em>。</p>
</li>
<li><p><code>overlap</code>(<em>other</em>)</p>
<p>测量两个正态概率分布之间的一致性。 返回介于 0.0 和 1.0 之间的值，给出 <a href="https://www.rasch.org/rmt/rmt101r.htm" target="_blank" rel="noopener">两个概率密度函数的重叠区域</a>。</p>
</li>
<li><p><code>quantiles</code>(<em>n=4</em>)</p>
<p>将指定正态分布划分为 <em>n</em> 个相等概率的连续分隔区。 返回这些分隔区对应的 (n - 1) 个分隔点的列表。将 <em>n</em> 设为 4 以使用四分位（默认值）。 将 <em>n</em> 设为 10 以使用十分位。将 <em>n</em> 设为 100 以使用百分位，即给出 99 个分隔点来将正态分布分隔为 100 个大小相等的组。</p>
</li>
</ul>
<p><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 的实例支持加上、减去、乘以或除以一个常量。 这些运算被用于转换和缩放。 例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; temperature_february = NormalDist(5, 2.5)             # Celsius</span><br><span class="line">&gt;&gt;&gt; temperature_february * (9/5) + 32                     # Fahrenheit</span><br><span class="line">NormalDist(mu=41.0, sigma=4.5)</span><br></pre></td></tr></table></figure>
<p>不允许一个常量除以 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 的实例，因为结果将不是正态分布。</p>
<p>由于正态分布是由独立变量的累加效应产生的，因此允许表示为 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 实例的 <a href="https://en.wikipedia.org/wiki/Sum_of_normally_distributed_random_variables" target="_blank" rel="noopener">两组独立正态分布的随机变量相加和相减</a>。 例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>birth_weights = NormalDist.from_samples([<span class="number">2.5</span>, <span class="number">3.1</span>, <span class="number">2.1</span>, <span class="number">2.4</span>, <span class="number">2.7</span>, <span class="number">3.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>drug_effects = NormalDist(<span class="number">0.4</span>, <span class="number">0.15</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined = birth_weights + drug_effects</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(combined.mean, <span class="number">1</span>)</span><br><span class="line"><span class="number">3.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(combined.stdev, <span class="number">1</span>)</span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure>
<h3 id="NormalDist-示例和用法"><a href="#NormalDist-示例和用法" class="headerlink" title="NormalDist 示例和用法"></a><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 示例和用法</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 适合用来解决经典概率问题。</p>
<p>举例来说，如果 <a href="https://nces.ed.gov/programs/digest/d17/tables/dt17_226.40.asp" target="_blank" rel="noopener">SAT 考试的历史数据</a> 显示分数呈平均值为 1060 且标准差为 195 的正态分布，则可以确定考试分数处于 1100 和 1200 之间的学生的百分比舍入到最接近的整数应为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sat = NormalDist(<span class="number">1060</span>, <span class="number">195</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fraction = sat.cdf(<span class="number">1200</span> + <span class="number">0.5</span>) - sat.cdf(<span class="number">1100</span> - <span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(fraction * <span class="number">100.0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">18.4</span></span><br></pre></td></tr></table></figure>
<p>求 SAT 分数的 <a href="https://en.wikipedia.org/wiki/Quartile" target="_blank" rel="noopener">四分位</a> 和 <a href="https://en.wikipedia.org/wiki/Decile" target="_blank" rel="noopener">十分位</a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(round, sat.quantiles()))</span><br><span class="line">[<span class="number">928</span>, <span class="number">1060</span>, <span class="number">1192</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(round, sat.quantiles(n=<span class="number">10</span>)))</span><br><span class="line">[<span class="number">810</span>, <span class="number">896</span>, <span class="number">958</span>, <span class="number">1011</span>, <span class="number">1060</span>, <span class="number">1109</span>, <span class="number">1162</span>, <span class="number">1224</span>, <span class="number">1310</span>]</span><br></pre></td></tr></table></figure>
<p>为了估算一个不易解析的模型分布，<a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 可以生成用于 <a href="https://en.wikipedia.org/wiki/Monte_Carlo_method" target="_blank" rel="noopener">蒙特卡洛模拟</a> 的输入样本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(x, y, z)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> (<span class="number">3</span>*x + <span class="number">7</span>*x*y - <span class="number">5</span>*y) / (<span class="number">11</span> * z)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">100</span>_000</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = NormalDist(<span class="number">10</span>, <span class="number">2.5</span>).samples(n, seed=<span class="number">3652260728</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Y = NormalDist(<span class="number">15</span>, <span class="number">1.75</span>).samples(n, seed=<span class="number">4582495471</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = NormalDist(<span class="number">50</span>, <span class="number">1.25</span>).samples(n, seed=<span class="number">6582483453</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quantiles(map(model, X, Y, Z))       </span><br><span class="line">[<span class="number">1.4591308524824727</span>, <span class="number">1.8035946855390597</span>, <span class="number">2.175091447274739</span>]</span><br></pre></td></tr></table></figure>
<p>当样本量较大并且成功试验的可能性接近 50% 时，正态分布可以被用来模拟 <a href="http://mathworld.wolfram.com/BinomialDistribution.html" target="_blank" rel="noopener">二项分布</a>。</p>
<p>例如，一次开源会议有 750 名与会者和两个可分别容纳 500 人的会议厅。 会上有一场关于 Python 的演讲和一场关于 Ruby 的演讲。 在往届会议中，65% 的与会者更愿意去听关于 Python 的演讲。 假定人群的偏好没有发生改变，那么 Python 演讲的会议厅不超出其容量上限的可能性是多少？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">750</span>             <span class="comment"># Sample size</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = <span class="number">0.65</span>            <span class="comment"># Preference for Python</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = <span class="number">1.0</span> - p         <span class="comment"># Preference for Ruby</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k = <span class="number">500</span>             <span class="comment"># Room capacity</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Approximation using the cumulative normal distribution</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(NormalDist(mu=n*p, sigma=sqrt(n*p*q)).cdf(k + <span class="number">0.5</span>), <span class="number">4</span>)</span><br><span class="line"><span class="number">0.8402</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Solution using the cumulative binomial distribution</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> comb, fsum</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(fsum(comb(n, r) * p**r * q**(n-r) <span class="keyword">for</span> r <span class="keyword">in</span> range(k+<span class="number">1</span>)), <span class="number">4</span>)</span><br><span class="line"><span class="number">0.8402</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Approximation using a simulation</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> seed, choices</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seed(<span class="number">8675309</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">trial</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> choices((<span class="string">'Python'</span>, <span class="string">'Ruby'</span>), (p, q), k=n).count(<span class="string">'Python'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean(trial() &lt;= k <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>_000))</span><br><span class="line"><span class="number">0.8398</span></span><br></pre></td></tr></table></figure>
<p>在机器学习问题中也经常会出现正态分布。</p>
<p>Wikipedia 上有一个 <a href="https://en.wikipedia.org/wiki/Naive_Bayes_classifier#Sex_classification" target="_blank" rel="noopener">朴素贝叶斯分类器的好例子</a>。 挑战的问题是根据对多个正态分布的特征测量值包括身高、体重和足部尺码来预测一个人的性别。</p>
<p>我们得到了由八个人的测量值组成的训练数据集。 假定这些测量值是正态分布的，因此我们用 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 来总结数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>height_male = NormalDist.from_samples([<span class="number">6</span>, <span class="number">5.92</span>, <span class="number">5.58</span>, <span class="number">5.92</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>height_female = NormalDist.from_samples([<span class="number">5</span>, <span class="number">5.5</span>, <span class="number">5.42</span>, <span class="number">5.75</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weight_male = NormalDist.from_samples([<span class="number">180</span>, <span class="number">190</span>, <span class="number">170</span>, <span class="number">165</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weight_female = NormalDist.from_samples([<span class="number">100</span>, <span class="number">150</span>, <span class="number">130</span>, <span class="number">150</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foot_size_male = NormalDist.from_samples([<span class="number">12</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">10</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foot_size_female = NormalDist.from_samples([<span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>
<p>接下来，我们遇到一个特征测量值已知但性别未知的新人：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ht = <span class="number">6.0</span>        <span class="comment"># height</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wt = <span class="number">130</span>        <span class="comment"># weight</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fs = <span class="number">8</span>          <span class="comment"># foot size</span></span><br></pre></td></tr></table></figure>
<p>从是男是女各 50% 的 <a href="https://en.wikipedia.org/wiki/Prior_probability" target="_blank" rel="noopener">先验概率</a> 出发，我们通过将该先验概率乘以给定性别的特征度量值的可能性累积值来计算后验概率：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; prior_male = 0.5</span><br><span class="line">&gt;&gt;&gt; prior_female = 0.5</span><br><span class="line">&gt;&gt;&gt; posterior_male = (prior_male * height_male.pdf(ht) *</span><br><span class="line">...                   weight_male.pdf(wt) * foot_size_male.pdf(fs))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; posterior_female = (prior_female * height_female.pdf(ht) *</span><br><span class="line">...                     weight_female.pdf(wt) * foot_size_female.pdf(fs))</span><br></pre></td></tr></table></figure>
<p>最终预测值应为最大后验概率值。 这种算法被称为 <a href="https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation" target="_blank" rel="noopener">maximum a posteriori</a> 或 MAP：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'male'</span> <span class="keyword">if</span> posterior_male &gt; posterior_female <span class="keyword">else</span> <span class="string">'female'</span></span><br><span class="line"><span class="string">'female'</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>statistics</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library json</title>
    <url>/2020/02/08/python-standard-library-json/</url>
    <content><![CDATA[<h1 id="python-标准库-json"><a href="#python-标准库-json" class="headerlink" title="python 标准库 json"></a>python 标准库 json</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20191223_blog_6.jpg?raw=true" alt></p>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=25706282&auto=0&height=66"></iframe>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/json/__init__.py" target="_blank" rel="noopener">Lib/json/<strong>init</strong>.py</a></p>
<p> <a href="http://json.org/" target="_blank" rel="noopener">JSON (JavaScript Object Notation)</a>，由 <a href="https://tools.ietf.org/html/rfc7159.html" target="_blank" rel="noopener"><strong>RFC 7159</strong></a> (which obsoletes <a href="https://tools.ietf.org/html/rfc4627.html" target="_blank" rel="noopener"><strong>RFC 4627</strong></a>) 和 <a href="http://www.ecma-international.org/publications/standards/Ecma-404.htm" target="_blank" rel="noopener">ECMA-404</a> 指定，是一个受 <a href="https://en.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a> 的对象字面量语法启发的轻量级数据交换格式，尽管它不仅仅是一个严格意义上的 JavaScript 的字集。</p>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 提供了与标准库 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#module-marshal" target="_blank" rel="noopener"><code>marshal</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 相似的API接口。 </p>
<p> 对基本的 Python 对象层次结构进行编码： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps([<span class="string">'foo'</span>, &#123;<span class="string">'bar'</span>: (<span class="string">'baz'</span>, <span class="literal">None</span>, <span class="number">1.0</span>, <span class="number">2</span>)&#125;])</span><br><span class="line"><span class="string">'["foo", &#123;"bar": ["baz", null, 1.0, 2]&#125;]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(<span class="string">"\"foo\bar"</span>))</span><br><span class="line"><span class="string">"\"foo\bar"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(<span class="string">'\u1234'</span>))</span><br><span class="line"><span class="string">"\u1234"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(<span class="string">'\\'</span>))</span><br><span class="line"><span class="string">"\\"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(&#123;<span class="string">"c"</span>: <span class="number">0</span>, <span class="string">"b"</span>: <span class="number">0</span>, <span class="string">"a"</span>: <span class="number">0</span>&#125;, sort_keys=<span class="literal">True</span>))</span><br><span class="line">&#123;<span class="string">"a"</span>: <span class="number">0</span>, <span class="string">"b"</span>: <span class="number">0</span>, <span class="string">"c"</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io = StringIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dump([<span class="string">'streaming API'</span>], io)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io.getvalue()</span><br><span class="line"><span class="string">'["streaming API"]'</span></span><br></pre></td></tr></table></figure>
<p> 紧凑编码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="string">'4'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">7</span>&#125;], separators=(<span class="string">','</span>, <span class="string">':'</span>))</span><br><span class="line"><span class="string">'[1,2,3,&#123;"4":5,"6":7&#125;]'</span></span><br></pre></td></tr></table></figure>
<p>美化输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(&#123;<span class="string">'4'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">7</span>&#125;, sort_keys=<span class="literal">True</span>, indent=<span class="number">4</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"4"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">"6"</span>: <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSON解码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'["foo", &#123;"bar":["baz", null, 1.0, 2]&#125;]'</span>)</span><br><span class="line">[<span class="string">'foo'</span>, &#123;<span class="string">'bar'</span>: [<span class="string">'baz'</span>, <span class="literal">None</span>, <span class="number">1.0</span>, <span class="number">2</span>]&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'"\\"foo\\bar"'</span>)</span><br><span class="line"><span class="string">'"foo\x08ar'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io = StringIO(<span class="string">'["streaming API"]'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.load(io)</span><br><span class="line">[<span class="string">'streaming API'</span>]</span><br></pre></td></tr></table></figure>
<p> 特殊JSON对象解码: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">as_complex</span><span class="params">(dct)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="string">'__complex__'</span> <span class="keyword">in</span> dct:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> complex(dct[<span class="string">'real'</span>], dct[<span class="string">'imag'</span>])</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> dct</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'&#123;"__complex__": true, "real": 1, "imag": 2&#125;'</span>,</span><br><span class="line"><span class="meta">... </span>    object_hook=as_complex)</span><br><span class="line">(<span class="number">1</span>+<span class="number">2j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'1.1'</span>, parse_float=decimal.Decimal)</span><br><span class="line">Decimal(<span class="string">'1.1'</span>)</span><br></pre></td></tr></table></figure>
<p>扩展 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder" target="_blank" rel="noopener"><code>JSONEncoder</code></a>: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ComplexEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, obj)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> isinstance(obj, complex):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> [obj.real, obj.imag]</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># Let the base class default method raise the TypeError</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> json.JSONEncoder.default(self, obj)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(<span class="number">2</span> + <span class="number">1j</span>, cls=ComplexEncoder)</span><br><span class="line"><span class="string">'[2.0, 1.0]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ComplexEncoder().encode(<span class="number">2</span> + <span class="number">1j</span>)</span><br><span class="line"><span class="string">'[2.0, 1.0]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ComplexEncoder().iterencode(<span class="number">2</span> + <span class="number">1j</span>))</span><br><span class="line">[<span class="string">'[2.0'</span>, <span class="string">', 1.0'</span>, <span class="string">']'</span>]</span><br></pre></td></tr></table></figure>
<p> 从命令行使用 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#module-json.tool" target="_blank" rel="noopener"><code>json.tool</code></a> 来验证并美化输出： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ echo <span class="string">'&#123;"json":"obj"&#125;'</span> | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"json"</span>: <span class="string">"obj"</span></span><br><span class="line">&#125;</span><br><span class="line">$ echo <span class="string">'&#123;1.2:3.4&#125;'</span> | python -m json.tool</span><br><span class="line">Expecting property name enclosed <span class="keyword">in</span> double quotes: line <span class="number">1</span> column <span class="number">2</span> (char <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p> 详细文档请参见 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json-commandline" target="_blank" rel="noopener">命令行界面</a>。 </p>
<blockquote>
<p> JSON 是 <a href="http://yaml.org/" target="_blank" rel="noopener">YAML</a> 1.2 的一个子集。由该模块的默认设置生成的 JSON （尤其是默认的 “分隔符” 设置值）也是 YAML 1.0 and 1.1 的一个子集。因此该模块也能够用于序列化为 YAML。 </p>
</blockquote>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul>
<li><p><code>json.dump</code>(<em>obj</em>, <em>fp</em>, <strong><em>, </em>skipkeys=False<em>, </em>ensure_ascii=True<em>, </em>check_circular=True<em>, </em>allow_nan=True<em>, </em>cls=None<em>, </em>indent=None<em>, </em>separators=None<em>, </em>default=None<em>, </em>sort_keys=False<em>, </em></strong>kw*) </p>
<p> 使用这个 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#py-to-json-table" target="_blank" rel="noopener">转换表</a> 将 <em>obj</em> 序列化为 JSON 格式化流形式的 <em>fp</em> (支持 <code>.write()</code> 的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-like-object" target="_blank" rel="noopener">file-like object</a>)。 </p>
<p>如果 <em>skipkeys</em> 是 true （默认为 <code>False</code>），那么那些不是基本对象（包括 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#bool" target="_blank" rel="noopener"><code>bool</code></a>、<code>None</code>）的字典的键会被跳过；否则引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 模块始终产生 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 对象而非 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 对象。因此，<code>fp.write()</code> 必须支持 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 输入。</p>
<p>如果 <em>ensure_ascii</em> 是 true （即默认值），输出保证将所有输入的非 ASCII 字符转义。如果 <em>ensure_ascii</em> 是 false，这些字符会原样输出。</p>
<p>如果 <em>check_circular</em> 是为假值 (默认为 <code>True</code>)，那么容器类型的循环引用检验会被跳过并且循环引用会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a> (或者更糟的情况)。</p>
<p>如果 <em>allow_nan</em> 是 false（默认为 <code>True</code>），那么在对严格 JSON 规格范围外的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 类型值（<code>nan</code>、<code>inf</code> 和 <code>-inf</code>）进行序列化时会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。如果 <em>allow_nan</em> 是 true，则使用它们的 JavaScript 等价形式（<code>NaN</code>、<code>Infinity</code> 和 <code>-Infinity</code>）。</p>
<p>如果 <em>indent</em> 是一个非负整数或者字符串，那么 JSON 数组元素和对象成员会被美化输出为该值指定的缩进等级。如果缩进等级为零、负数或者 <code>&quot;&quot;</code>，则只会添加换行符。<code>None（默认值）选择最紧凑的表达。使用一个正整数会让每一层缩进同样数量的空格。如果 *indent* 是一个字符串（比如 &quot;\t&quot;</code>），那个字符串会被用于缩进每一层。</p>
<p><em>在 3.2 版更改:</em> 允许使用字符串作为 <em>indent</em> 而不再仅仅是整数。</p>
<p>当指定时，<em>separators</em> 应当是一个 <code>(item_separator, key_separator)</code> 元组。当 <em>indent</em> 为 <code>None</code> 时，默认值取 <code>(&#39;, &#39;, &#39;: &#39;)</code>，否则取 <code>(&#39;,&#39;, &#39;: &#39;)</code>。为了得到最紧凑的 JSON 表达式，你应该指定其为 <code>(&#39;,&#39;, &#39;:&#39;)</code> 以消除空白字符。</p>
<p><em>在 3.4 版更改:</em> 现当 <em>indent</em> 不是 <code>None</code> 时，采用 <code>(&#39;,&#39;, &#39;: &#39;)</code> 作为默认值。</p>
<p>当 <em>default</em> 被指定时，其应该是一个函数，每当某个对象无法被序列化时它会被调用。它应该返回该对象的一个可以被 JSON 编码的版本或者引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。如果没有被指定，则会直接引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p>
<p>如果 <em>sort_keys</em> 是 true（默认为 <code>False</code>），那么字典的输出会以键的顺序排序。</p>
<p>为了使用一个自定义的 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder" target="_blank" rel="noopener"><code>JSONEncoder</code></a> 子类（比如：覆盖了 <code>default()</code> 方法来序列化额外的类型）， 通过 <em>cls</em> 关键字参数来指定；否则将使用 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder" target="_blank" rel="noopener"><code>JSONEncoder</code></a>。</p>
</li>
<li><p>json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)</p>
<p> 使用这个 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#py-to-json-table" target="_blank" rel="noopener">转换表</a> 将 <em>obj</em> 序列化为 JSON 格式的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>。 其参数的含义与 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.dump" target="_blank" rel="noopener"><code>dump()</code></a> 中的相同。 </p>
</li>
<li><p><code>json.load</code>(<em>fp</em>, <strong><em>, </em>cls=None<em>, </em>object_hook=None<em>, </em>parse_float=None<em>, </em>parse_int=None<em>, </em>parse_constant=None<em>, </em>object_pairs_hook=None<em>, </em></strong>kw*) </p>
<p>使用这个 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json-to-py-table" target="_blank" rel="noopener">转换表</a> 将 <em>fp</em> (一个支持 <code>.read()</code> 并包含一个 JSON 文档的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-text-file" target="_blank" rel="noopener">text file</a> 或者 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a>) 反序列化为一个 Python 对象。</p>
<p><em>object_hook</em> 是一个可选的函数，它会被调用于每一个解码出的对象字面量（即一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>）。<em>object_hook</em> 的返回值会取代原本的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>。这一特性能够被用于实现自定义解码器（如 <a href="http://www.jsonrpc.org/" target="_blank" rel="noopener">JSON-RPC</a> 的类型提示)。</p>
<p><em>object_pairs_hook</em> 是一个可选的函数，它会被调用于每一个有序列表对解码出的对象字面量。 <em>object_pairs_hook</em> 的返回值将会取代原本的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 。这一特性能够被用于实现自定义解码器。如果 <em>object_hook</em> 也被定义， <em>object_pairs_hook</em> 优先。</p>
<p><em>在 3.1 版更改:</em> 添加了对 <em>object_pairs_hook</em> 的支持。</p>
<p><em>parse_float</em> ，如果指定，将与每个要解码 JSON 浮点数的字符串一同调用。默认状态下，相当于 <code>float(num_str)</code> 。可以用于对 JSON 浮点数使用其它数据类型和语法分析程序 （比如 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>decimal.Decimal</code></a> ）。</p>
<p><em>parse_int</em> ，如果指定，将与每个要解码 JSON 整数的字符串一同调用。默认状态下，相当于 <code>int(num_str)</code> 。可以用于对 JSON 整数使用其它数据类型和语法分析程序 （比如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> ）。</p>
<p><em>parse_constant</em> ，如果指定，将要与以下字符串中的一个一同调用： <code>&#39;-Infinity&#39;</code> ， <code>&#39;Infinity&#39;</code> ， <code>&#39;NaN&#39;</code> 。如果遇到无效的 JSON 数字则可以使用它引发异常。</p>
<p><em>在 3.1 版更改:</em> <em>parse_constant</em> 不再调用 ‘null’ ， ‘true’ ， ‘false’ 。</p>
<p>要使用自定义的 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecoder" target="_blank" rel="noopener"><code>JSONDecoder</code></a> 子类，用 <code>cls</code> 指定他；否则使用 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecoder" target="_blank" rel="noopener"><code>JSONDecoder</code></a> 。额外的关键词参数会通过类的构造函数传递。</p>
<p>如果反序列化的数据不是有效 JSON 文档，引发 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecodeError" target="_blank" rel="noopener"><code>JSONDecodeError</code></a> 错误。</p>
<p><em>在 3.6 版更改:</em> 所有的可选参数现在是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#keyword-only-parameter" target="_blank" rel="noopener">keyword-only</a> 的了。</p>
<p><em>在 3.6 版更改:</em> <em>fp</em> 现在可以是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a> 。输入编码应当是 UTF-8 ， UTF-16 或者 UTF-32 。</p>
</li>
<li><p><code>json.loads</code>(<em>s</em>, <strong><em>, </em>cls=None<em>, </em>object_hook=None<em>, </em>parse_float=None<em>, </em>parse_int=None<em>, </em>parse_constant=None<em>, </em>object_pairs_hook=None<em>, </em></strong>kw*) </p>
<p>使用这个 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json-to-py-table" target="_blank" rel="noopener">转换表</a> 将 <em>s</em> (一个包含 JSON 文档的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 实例) 反序列化为 Python 对象。</p>
<p>除了<em>encoding</em>被忽略和弃用自 Python 3.1 以来，其他参数的含义与 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.load" target="_blank" rel="noopener"><code>load()</code></a> 中相同。</p>
<p>如果反序列化的数据不是有效 JSON 文档，引发 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecodeError" target="_blank" rel="noopener"><code>JSONDecodeError</code></a> 错误。</p>
<p><em>Deprecated since version 3.1, will be removed in version 3.9:</em> <em>encoding</em> 关键字参数。</p>
<p><em>在 3.6 版更改:</em> <em>s</em> 现在可以为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 类型。 输入编码应为 UTF-8, UTF-16 或 UTF-32。</p>
</li>
</ul>
<h2 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h2><ul>
<li><p><em>class</em> <code>json.JSONDecoder</code>(<em>**, </em>object_hook=None<em>, </em>parse_float=None<em>, </em>parse_int=None<em>, </em>parse_constant=None<em>, </em>strict=True<em>, </em>object_pairs_hook=None*) </p>
<p>简单的JSON解码器。</p>
<p>默认情况下，解码执行以下翻译:</p>
<p>| JSON          | Python |<br>| :———— | :—– |<br>| object        | dict   |<br>| array         | list   |<br>| string        | str    |<br>| number (int)  | int    |<br>| number (real) | float  |<br>| true          | True   |<br>| false         | False  |<br>| null          | None   |</p>
</li>
</ul>
<p>​      它还将“NaN”、“Infinity”和“-Infinity”理解为它们对应的“float”值，这超出了JSON规范。</p>
<p>​    <em>object_hook</em> ，如果指定，会被每个解码的 JSON 对象的结果调用，并且返回值会替代给定 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 。它可被用于提供自定义反序列化（比如去支持 JSON-RPC 类的暗示）。</p>
<p>如果指定了 <em>object_pairs_hook</em> 则它将被调用并传入以对照值有序列表进行解码的每个 JSON 对象的结果。 <em>object_pairs_hook</em> 的结果值将被用来替代 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>。 这一特性可被用于实现自定义解码器。 如果还定义了 <em>object_hook</em>，则 <em>object_pairs_hook</em> 的优先级更高。</p>
<p><em>在 3.1 版更改:</em> 添加了对 <em>object_pairs_hook</em> 的支持。</p>
<p><em>parse_float</em> ，如果指定，将与每个要解码 JSON 浮点数的字符串一同调用。默认状态下，相当于 <code>float(num_str)</code> 。可以用于对 JSON 浮点数使用其它数据类型和语法分析程序 （比如 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>decimal.Decimal</code></a> ）。</p>
<p><em>parse_int</em> ，如果指定，将与每个要解码 JSON 整数的字符串一同调用。默认状态下，相当于 <code>int(num_str)</code> 。可以用于对 JSON 整数使用其它数据类型和语法分析程序 （比如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> ）。</p>
<p><em>parse_constant</em> ，如果指定，将要与以下字符串中的一个一同调用： <code>&#39;-Infinity&#39;</code> ， <code>&#39;Infinity&#39;</code> ， <code>&#39;NaN&#39;</code> 。如果遇到无效的 JSON 数字则可以使用它引发异常。</p>
<p>如果 <em>strict</em> 为 false （默认为 <code>True</code> ），那么控制字符将被允许在字符串内。在此上下文中的控制字符编码在范围 0–31 内的字符，包括 <code>&#39;\t&#39;</code> (制表符）， <code>&#39;\n&#39;</code> ， <code>&#39;\r&#39;</code> 和 <code>&#39;\0&#39;</code> 。</p>
<p>如果反序列化的数据不是有效 JSON 文档，引发 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecodeError" target="_blank" rel="noopener"><code>JSONDecodeError</code></a> 错误。</p>
<p><em>在 3.6 版更改:</em> 所有形参现在都是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#keyword-only-parameter" target="_blank" rel="noopener">仅限关键字参数</a>。</p>
<ul>
<li><p><code>decode</code>(<em>s</em>) </p>
<p>返回 <em>s</em> 的 Python 表示形式（包含一个 JSON 文档的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 实例）。</p>
<p>如果给定的 JSON 文档无效则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecodeError" target="_blank" rel="noopener"><code>JSONDecodeError</code></a>。</p>
</li>
<li><p><code>raw_decode</code>(<em>s</em>) </p>
<p>从 <em>s</em> 中解码出 JSON 文档（以 JSON 文档开头的一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 对象）并返回一个 Python 表示形式为 2 元组以及指明该文档在 <em>s</em> 中结束位置的序号。</p>
<p>这可以用于从一个字符串解码JSON文档，该字符串的末尾可能有无关的数据。</p>
</li>
</ul>
<ul>
<li><p><em>lass</em> <code>json.JSONEncoder</code>(<em>**, </em>skipkeys=False<em>, </em>ensure_ascii=True<em>, </em>check_circular=True<em>, </em>allow_nan=True<em>, </em>sort_keys=False<em>, </em>indent=None<em>, </em>separators=None<em>, </em>default=None*) </p>
<p>用于Python数据结构的可扩展JSON编码器。</p>
<p>默认支持以下对象和类型：</p>
<p>| Python                              | JSON   |<br>| :———————————- | :—– |<br>| dict                                | object |<br>| list, tuple                         | array  |<br>| str                                 | string |<br>| int, float, int 和 float 派生的枚举 | number |<br>| True                                | true   |<br>| False                               | false  |<br>| None                                | null   |</p>
<p><em>在 3.4 版更改:</em> 添加了对 int 和 float 派生的枚举类的支持</p>
<p>为了将其拓展至识别其他对象，需要子类化并实现 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder.default" target="_blank" rel="noopener"><code>default()</code></a> 方法于另一种返回 <code>o</code> 的可序列化对象的方法如果可行，否则它应该调用超类实现（来引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> ）。</p>
<p>如果 <em>skipkeys</em> 为假值（默认），则尝试对不是 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 或 <code>None</code> 的键进行编码将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 如果 <em>skipkeys</em> 为真值，这些条目将被直接跳过。</p>
<p>如果 <em>ensure_ascii</em> 是 true （即默认值），输出保证将所有输入的非 ASCII 字符转义。如果 <em>ensure_ascii</em> 是 false，这些字符会原样输出。</p>
<p>如果 <em>check_circular</em> 为 true （默认），那么列表，字典，和自定义编码的对象在编码期间会被检查重复循环引用防止无限递归（无限递归将导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a> ）。否则，这样进行检查。</p>
<p>如果 <em>allow_nan</em> 为 true （默认），那么 <code>NaN</code> ， <code>Infinity</code> ，和 <code>-Infinity</code> 进行编码。此行为不符合 JSON 规范，但与大多数的基于 Javascript 的编码器和解码器一致。否则，它将是一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 来编码这些浮点数。</p>
<p>如果 <em>sort_keys</em> 为 true （默认为： <code>False</code> ），那么字典的输出是按照键排序；这对回归测试很有用，以确保可以每天比较 JSON 序列化。</p>
<p>如果 <em>indent</em> 是一个非负整数或者字符串，那么 JSON 数组元素和对象成员会被美化输出为该值指定的缩进等级。如果缩进等级为零、负数或者 <code>&quot;&quot;</code>，则只会添加换行符。<code>None（默认值）选择最紧凑的表达。使用一个正整数会让每一层缩进同样数量的空格。如果 *indent* 是一个字符串（比如 &quot;\t&quot;</code>），那个字符串会被用于缩进每一层。</p>
<p><em>在 3.2 版更改:</em> 允许使用字符串作为 <em>indent</em> 而不再仅仅是整数。</p>
<p>当指定时，<em>separators</em> 应当是一个 <code>(item_separator, key_separator)</code> 元组。当 <em>indent</em> 为 <code>None</code> 时，默认值取 <code>(&#39;, &#39;, &#39;: &#39;)</code>，否则取 <code>(&#39;,&#39;, &#39;: &#39;)</code>。为了得到最紧凑的 JSON 表达式，你应该指定其为 <code>(&#39;,&#39;, &#39;:&#39;)</code> 以消除空白字符。</p>
<p><em>在 3.4 版更改:</em> 现当 <em>indent</em> 不是 <code>None</code> 时，采用 <code>(&#39;,&#39;, &#39;: &#39;)</code> 作为默认值。</p>
<p>当 <em>default</em> 被指定时，其应该是一个函数，每当某个对象无法被序列化时它会被调用。它应该返回该对象的一个可以被 JSON 编码的版本或者引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。如果没有被指定，则会直接引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p>
<p><em>在 3.6 版更改:</em> 所有形参现在都是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#keyword-only-parameter" target="_blank" rel="noopener">仅限关键字参数</a>。</p>
<ul>
<li><p><code>default</code>(<em>o</em>) </p>
<p>在子类中实现这种方法使其返回 <em>o</em> 的可序列化对象，或者调用基础实现（引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> ）。</p>
<p>比如说，为了支持任意迭代器，你可以像这样实现默认设置:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, o)</span>:</span></span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       iterable = iter(o)</span><br><span class="line">   <span class="keyword">except</span> TypeError:</span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       <span class="keyword">return</span> list(iterable)</span><br><span class="line">   <span class="comment"># Let the base class default method raise the TypeError</span></span><br><span class="line">   <span class="keyword">return</span> json.JSONEncoder.default(self, o)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>encode</code>(<em>o</em>) </p>
<p>返回 Python <em>o</em> 数据结构的 JSON 字符串表达方式。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.JSONEncoder().encode(&#123;<span class="string">"foo"</span>: [<span class="string">"bar"</span>, <span class="string">"baz"</span>]&#125;)</span><br><span class="line"><span class="string">'&#123;"foo": ["bar", "baz"]&#125;'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>iterencode</code>(<em>o</em>) </p>
<p>编码给定对象 <em>o</em> ，并且让每个可用的字符串表达方式。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> json.JSONEncoder().iterencode(bigobject):</span><br><span class="line">    mysocket.write(chunk)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><em>exception</em> <code>json.JSONDecodeError</code>(<em>msg</em>, <em>doc</em>, <em>pos</em>)</p>
<p>拥有以下附加属性的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 的子类：</p>
<ul>
<li><p><code>msg</code></p>
<p>未格式化的错误消息。</p>
</li>
<li><p><code>doc</code></p>
<p>正在解析的 JSON 文档。</p>
</li>
<li><p><code>pos</code></p>
<p>从文档开始解析失败的索引</p>
</li>
<li><p><code>lineno</code></p>
<p>定位的行号</p>
</li>
<li><p><code>colno</code></p>
<p>定位的列号</p>
</li>
</ul>
<h2 id="标准符合性和互操作性"><a href="#标准符合性和互操作性" class="headerlink" title="标准符合性和互操作性"></a>标准符合性和互操作性</h2><p>JSON 格式由 <a href="https://tools.ietf.org/html/rfc7159.html" target="_blank" rel="noopener"><strong>RFC 7159</strong></a> 和 <a href="http://www.ecma-international.org/publications/standards/Ecma-404.htm" target="_blank" rel="noopener">ECMA-404</a> 指定。此段落详细讲了这个模块符合 RFC 的级别。简单来说， <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder" target="_blank" rel="noopener"><code>JSONEncoder</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecoder" target="_blank" rel="noopener"><code>JSONDecoder</code></a> 子类，和明确提到的参数以外的参数，不作考虑。</p>
<p>此模块不严格遵循于 RFC ，它实现了一些扩展是有效的 Javascript 但不是有效的 JSON。尤其是：</p>
<ul>
<li>无限和 NaN 数值是被接受并输出；</li>
<li>对象内的重复名称是接受的，并且仅使用最后一对属性-值对的值。</li>
</ul>
<p>自从 RFC 允许符合 RFC 的语法分析程序接收 不符合 RFC 的输入文本以来，这个模块的解串器在默认状态下默认符合 RFC 。</p>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>RFC 要求使用 UTF-8 ， UTF-16 ，或 UTF-32 之一来表示 JSON ，为了最大互通性推荐使用 UTF-8 。</p>
<p>RFC允许，尽管不是必须的，这个模块的序列化默认设置为 <em>ensure_ascii=True</em> ，这样消除输出以便结果字符串至容纳 ASCII 字符。</p>
<p><em>ensure_ascii</em> 参数以外，此模块是严格的按照在 Python 对象和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>Unicode strings</code></a> 间的转换定义的，并且因此不能直接解决字符编码的问题。</p>
<p>RFC 禁止添加字符顺序标记（ BOM ）在 JSON 文本的开头，这个模块的序列化器不添加 BOM 标记在它的输出上。 RFC，准许 JSON 反序列化器忽略它们输入中的初始 BOM 标记，但不要求。此模块的反序列化器引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 当存在初始 BOM 标记。</p>
<p>RFC 不会明确禁止包含字节序列的 JSON 字符串这不对应有效的 Unicode 字符（比如 不成对的 UTF-16 的替代物），但是它确实指出它们可能会导致互操作性问题。默认下，模块对这样的序列接受和输出（当在原始 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 存在时）代码点。</p>
<h3 id="Infinite-和-NaN-数值"><a href="#Infinite-和-NaN-数值" class="headerlink" title="Infinite 和 NaN 数值"></a>Infinite 和 NaN 数值</h3><p>RFC 不允许 infinite 或者 NaN 数值的表达方式。尽管这样，默认情况下，此模块接受并且输出 <code>Infinity</code> ， <code>-Infinity</code>，和 <code>NaN</code> 好像它们是有效的JSON数字字面值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Neither of these calls raises an exception, but the results are not valid JSON</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(float(<span class="string">'-inf'</span>))</span><br><span class="line"><span class="string">'-Infinity'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(float(<span class="string">'nan'</span>))</span><br><span class="line"><span class="string">'NaN'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Same when deserializing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'-Infinity'</span>)</span><br><span class="line">-inf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'NaN'</span>)</span><br><span class="line">nan</span><br></pre></td></tr></table></figure>
<p>序列化器中， <em>allow_nan</em> 参数可用于替代这个行为。反序列化器中， <em>parse_constant</em> 参数，可用于替代这个行为。</p>
<h3 id="对象中的重复名称"><a href="#对象中的重复名称" class="headerlink" title="对象中的重复名称"></a>对象中的重复名称</h3><p>RFC 具体说明了 在 JSON对象里的名字应该是唯一的，但没有规定如何处理JSON对象中的重复名称。默认下，此模块不引发异常；作为替代，对于给定名它将忽略除姓-值对之外的所有对:</p>
<p>>&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; weird_json = &apos;&#123;&quot;x&quot;: 1, &quot;x&quot;: 2, &quot;x&quot;: 3&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; json.loads(weird_json)</span><br><span class="line">&#123;&apos;x&apos;: 3&#125;</span><br></pre></td></tr></table></figure>
<p>参数 <code>*object_pairs_hook*</code> 可以改变这个行为</p>
<h3 id="顶级非对象，非数组值"><a href="#顶级非对象，非数组值" class="headerlink" title="顶级非对象，非数组值"></a>顶级非对象，非数组值</h3><p>老版本的JSON声明遵循<a href="https://tools.ietf.org/html/rfc4627.html" target="_blank" rel="noopener"><strong>RFC 4627</strong></a> ,需要顶级的JSON 文本必须是JSON对象或数组(Python中的字典或列表),并且不能是null,boolean,number或字符串。<a href="https://tools.ietf.org/html/rfc7159.html" target="_blank" rel="noopener"><strong>RFC 7159</strong></a> 移除了这个限制,意味着无需在序列化和反序列化时实现该规范。</p>
<p>除此以外,为了获得最大限度的操作灵活性,你可以根据自己的实际情况选择是否遵循该规范。</p>
<h3 id="实现限制"><a href="#实现限制" class="headerlink" title="实现限制"></a>实现限制</h3><p>一些json 实现可能有下面的限制:</p>
<ul>
<li>可以接受的 JSON 文本大小 </li>
<li>对象和数组的最大层数</li>
<li>JSON numbers的范围以及小数位数。</li>
<li>JSON字符串的内容和最大长度</li>
</ul>
<p>json模块并不会强制这些限制,这取决于自定义Python数据类型自身的实现。</p>
<h2 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h2><p> <a href="https://docs.python.org/zh-cn/3.8/library/json.html#module-json.tool" target="_blank" rel="noopener"><code>json.tool</code></a> 模块实现了一个简易的命令行接口,用来验证和打印格式良好的JSON 对象。</p>
<p>如果没有设定可选参数<code>infile</code> and <code>outfile</code>,将会使用<a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a> and <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdout" target="_blank" rel="noopener"><code>sys.stdout</code></a> 标准输入输出代替。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ echo <span class="string">'&#123;"json": "obj"&#125;'</span> | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"json"</span>: <span class="string">"obj"</span></span><br><span class="line">&#125;</span><br><span class="line">$ echo <span class="string">'&#123;1.2:3.4&#125;'</span> | python -m json.tool</span><br><span class="line">Expecting property name enclosed <span class="keyword">in</span> double quotes: line <span class="number">1</span> column <span class="number">2</span> (char <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><p> <strong>infile</strong> </p>
<p>JSON 文件校验或美化打印。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -m json.tool mp_films.json</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"And Now for Something Completely Different"</span>,</span><br><span class="line">        <span class="string">"year"</span>: <span class="number">1971</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"Monty Python and the Holy Grail"</span>,</span><br><span class="line">        <span class="string">"year"</span>: <span class="number">1975</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>If <em>infile</em> is not specified, read from <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a>.</p>
<p> <strong>outfile</strong> </p>
<p> Write the output of the <em>infile</em> to the given <em>outfile</em>. Otherwise, write it to </p>
<p>输出到文件,如果没有设置则使用<a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdout" target="_blank" rel="noopener"><code>sys.stdout</code></a>(标准输出)</p>
<p> <strong>–sort-keys</strong> </p>
<p>根据输出的字典的键根据字母顺序排序</p>
<p> <strong>–json-lines</strong> </p>
<p>解析每一行作为单独的JSON对象</p>
<p> <code>-h, --help</code> </p>
<p>显示帮助信息</p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library fractions</title>
    <url>/2020/02/09/python-standard-library-fractions/</url>
    <content><![CDATA[<h1 id="python-标准库-fractions-分数"><a href="#python-标准库-fractions-分数" class="headerlink" title="python 标准库 fractions 分数"></a>python 标准库 fractions 分数</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200210_hope.jpg?raw=true" alt></p>
<a id="more"></a>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/fractions.py" target="_blank" rel="noopener">Lib/fractions.py</a></p>
<h2 id="模块概述"><a href="#模块概述" class="headerlink" title="模块概述"></a>模块概述</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#module-fractions" target="_blank" rel="noopener"><code>fractions</code></a> 模块支持分数运算。</p>
<p>分数实例可以由一对整数，一个分数，或者一个字符串构建而成。</p>
<ul>
<li><p><em>class</em> <code>fractions.Fraction</code>(<em>numerator=0</em>, <em>denominator=1</em>)</p>
</li>
<li><p><em>class</em> <code>fractions.Fraction</code>(<em>other_fraction</em>)</p>
</li>
<li><p><em>class</em> <code>fractions.Fraction</code>(<em>float</em>)</p>
</li>
<li><p><em>class</em> <code>fractions.Fraction</code>(<em>decimal</em>)</p>
</li>
<li><p><em>class</em> <code>fractions.Fraction</code>(<em>string</em>)</p>
<p>第一个版本要求 <em>numerator</em> 和 <em>denominator</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational" target="_blank" rel="noopener"><code>numbers.Rational</code></a> 的实例，并返回一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 实例，其值为 <code>numerator/denominator</code>。 如果 <em>denominator</em> 为 <code>0</code> 将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ZeroDivisionError" target="_blank" rel="noopener"><code>ZeroDivisionError</code></a>。 第二个版本要求 <em>other_fraction</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational" target="_blank" rel="noopener"><code>numbers.Rational</code></a> 的实例，并返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 实例且与传入值相等。 下两个版本接受 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>decimal.Decimal</code></a> 的实例，并返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 实例且与传入值完全相等。 请注意由于二进制浮点数通常存在的问题 (参见 <a href="https://docs.python.org/zh-cn/3.8/tutorial/floatingpoint.html#tut-fp-issues" target="_blank" rel="noopener">浮点算术：争议和限制</a>)，<code>Fraction(1.1)</code> 的参数并不会精确等于 11/10，因此 <code>Fraction(1.1)</code> 也 <em>不会</em> 返回用户所期望的 <code>Fraction(11, 10)</code>。 （请参阅下文中 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction.limit_denominator" target="_blank" rel="noopener"><code>limit_denominator()</code></a> 方法的文档。） 构造器的最后一个版本接受一个字符串或 unicode 实例。 此实例的通常形式为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[sign] numerator [<span class="string">'/'</span> denominator]</span><br></pre></td></tr></table></figure>
<p>其中的可选项 <code>sign</code> 可以为 ‘+’ 或 ‘-‘ 并且 <code>numerator</code> 和 <code>denominator</code> (如果存在) 是十进制数码的字符串。 此外，<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 构造器所接受的任何表示一个有限值的字符串也都为 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 构造器所接受。 不论哪种形式的输入字符串也都可以带有前缀和/或后缀的空格符。 这里是一些示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">16</span>, <span class="number">-10</span>)</span><br><span class="line">Fraction(<span class="number">-8</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">123</span>)</span><br><span class="line">Fraction(<span class="number">123</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction()</span><br><span class="line">Fraction(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'3/7'</span>)</span><br><span class="line">Fraction(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">' -3/7 '</span>)</span><br><span class="line">Fraction(<span class="number">-3</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'1.414213 \t\n'</span>)</span><br><span class="line">Fraction(<span class="number">1414213</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'-.125'</span>)</span><br><span class="line">Fraction(<span class="number">-1</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'7e-6'</span>)</span><br><span class="line">Fraction(<span class="number">7</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">2.25</span>)</span><br><span class="line">Fraction(<span class="number">9</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">1.1</span>)</span><br><span class="line">Fraction(<span class="number">2476979795053773</span>, <span class="number">2251799813685248</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(Decimal(<span class="string">'1.1'</span>))</span><br><span class="line">Fraction(<span class="number">11</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 类继承自抽象基类 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational" target="_blank" rel="noopener"><code>numbers.Rational</code></a>，并实现了该类的所有方法和操作。 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 实例是可哈希的，并应当被视为不可变对象。 此外，<a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 还具有以下属性和方法：</p>
<ul>
<li><p><code>numerator</code></p>
<p>最简分数形式的分子。</p>
</li>
<li><p><code>denominator</code></p>
<p>最简分数形式的分母。</p>
</li>
<li><p><code>as_integer_ratio</code>()</p>
<p>返回由两个整数组成的元组，两数之比等于该分数的值且其分母为正数。<em>3.8 新版功能.</em></p>
</li>
<li><p><code>from_float</code>(<em>flt</em>) : classmethod</p>
<p>此类方法可构造一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 来表示 <em>flt</em> 的精确值，该参数必须是一个 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>。 请注意 <code>Fraction.from_float(0.3)</code> 的值并不等于 <code>Fraction(3, 10)</code>。</p>
</li>
<li><p><code>from_decimal</code>(<em>dec</em>) : classmethod</p>
<p>此类方法可构造一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 来表示 <em>dec</em> 的精确值，该参数必须是一个 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>decimal.Decimal</code></a> 实例。</p>
</li>
<li><p><code>limit_denominator</code>(<em>max_denominator=1000000</em>)</p>
<p>找到并返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 使得其值最接近 <code>self</code> 并且分母不大于 max_denominator。 此方法适用于找出给定浮点数的有理数近似值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'3.1415926535897932'</span>).limit_denominator(<span class="number">1000</span>)</span><br><span class="line">Fraction(<span class="number">355</span>, <span class="number">113</span>)</span><br></pre></td></tr></table></figure>
<p>或是用来恢复被表示为一个浮点数的有理数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi, cos</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(cos(pi/<span class="number">3</span>))</span><br><span class="line">Fraction(<span class="number">4503599627370497</span>, <span class="number">9007199254740992</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(cos(pi/<span class="number">3</span>)).limit_denominator()</span><br><span class="line">Fraction(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">1.1</span>).limit_denominator()</span><br><span class="line">Fraction(<span class="number">11</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__floor__</code>()</p>
<p>返回最大的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> <code>&lt;= self</code>。 此方法也可通过 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.floor" target="_blank" rel="noopener"><code>math.floor()</code></a> 函数来使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> floor</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floor(Fraction(<span class="number">355</span>, <span class="number">113</span>))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__ceil__</code>()</p>
<p>返回最小的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> <code>&gt;= self</code>。 此方法也可通过 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.ceil" target="_blank" rel="noopener"><code>math.ceil()</code></a> 函数来使用。</p>
</li>
<li><p><code>__round__</code>()</p>
</li>
<li><p><code>__round__</code>(<em>ndigits</em>)</p>
<p>第一个版本返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 使得其值最接近 <code>self</code>，位值为二分之一时只对偶数舍入。第二个版本会将 <code>self</code> 舍入到最接近 <code>Fraction(1, 10**ndigits)</code> 的倍数（如果 <code>ndigits</code> 为负值则为逻辑运算），位值为二分之一时同样只对偶数舍入。 此方法也可通过 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#round" target="_blank" rel="noopener"><code>round()</code></a> 函数来使用</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>fractions.gcd</code>(<em>a</em>, <em>b</em>)</p>
<p>返回整数 <em>a</em> 和 <em>b</em> 的最大公约数。如果 <em>a</em> 或 <em>b</em> 之一非零，则 <code>gcd(a, b)</code> 的绝对值是能同时整除 <em>a</em> 和 <em>b</em> 的最大整数。若 <em>b</em> 非零，则 <code>gcd(a,b)</code> 与 <em>b</em> 同号；否则返回值与 <em>a</em> 同号。<code>gcd(0, 0)</code> 返回 <code>0</code>。</p>
<p><em>3.5 版后已移除:</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.gcd" target="_blank" rel="noopener"><code>math.gcd()</code></a> 取代.</p>
</li>
</ul>
<p>​    </p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>fractions</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library cmath</title>
    <url>/2020/02/10/python-standard-library-cmath/</url>
    <content><![CDATA[<h1 id="python-标准库-cmath"><a href="#python-标准库-cmath" class="headerlink" title="python 标准库 cmath"></a>python 标准库 cmath</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200210_butterfly.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>患难可以试验一个人的品格；非常的境遇方才可以显出非常的气节；风平浪静的海面，所有船只都可以并驱竞胜；命运的铁拳击中要害的时候，只有大勇大智的人才能够处之泰然。</p>
<p>​                                                                                                                                             –    莎士比亚</p>
</blockquote>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>这一模块提供了一些关于复数的数学函数。 该模块的函数的参数为整数、浮点数或复数。 这些函数的参数也可为一个拥有 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__complex__" target="_blank" rel="noopener"><code>__complex__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__float__" target="_blank" rel="noopener"><code>__float__()</code></a> 方法的 Python 对象，这些方法分别用于将对象转换为复数和浮点数，这些函数作用于转换后的结果。</p>
<h2 id="到极坐标和从极坐标的转换"><a href="#到极坐标和从极坐标的转换" class="headerlink" title="到极坐标和从极坐标的转换"></a>到极坐标和从极坐标的转换</h2><p>使用 <em>矩形坐标</em> 或 <em>笛卡尔坐标</em> 在内部存储 Python 复数 <code>z</code>。 这完全取决于它的 <em>实部</em> <code>z.real</code> 和 <em>虚部</em> <code>z.imag</code>。 换句话说:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z == z.real + z.imag*<span class="number">1j</span></span><br></pre></td></tr></table></figure>
<p><em>极坐标</em> 提供了另一种复数的表示方法。在极坐标中，一个复数 <em>z</em> 由模量 <em>r</em> 和相位角 <em>phi</em> 来定义。模量 <em>r</em> 是从 <em>z</em> 到坐标原点的距离，而相位角 <em>phi</em> 是以弧度为单位的，逆时针的，从正X轴到连接原点和 <em>z</em> 的线段间夹角的角度。</p>
<p>下面的函数可用于原生直角坐标与极坐标的相互转换。</p>
<ul>
<li><p><code>cmath.phase</code>(<em>x</em>)</p>
<p>将 <em>x</em> 的相位 (也称为 <em>x</em> 的 <em>参数</em>) 返回为一个浮点数。<code>phase(x)</code> 相当于 <code>math.atan2(x.imag, x.real)</code>。 结果处于 [-<em>π</em>, <em>π</em>] 之间，以及这个操作的分支切断处于负实轴上，从上方连续。 在支持有符号零的系统上（这包涵大多数当前的常用系统），这意味着结果的符号与 <code>x.imag</code> 的符号相同，即使 <code>x.imag</code> 的值是 0:</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>phase(complex(<span class="number">-1.0</span>, <span class="number">0.0</span>))</span><br><span class="line"><span class="number">3.141592653589793</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phase(complex(<span class="number">-1.0</span>, <span class="number">-0.0</span>))</span><br><span class="line"><span class="number">-3.141592653589793</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>cmath.polar</code>(<em>x</em>)</p>
<p>在极坐标中返回 <em>x</em> 的表达方式。返回一个数对 <code>(r, phi)</code>，<em>r</em> 是 <em>x</em> 的模数，<em>phi</em> 是 <em>x</em> 的相位角。 <code>polar(x)</code> 相当于 <code>(abs(x), phase(x))</code>。</p>
</li>
<li><p><code>cmath.rect</code>(<em>r</em>, <em>phi</em>)</p>
<p>通过极坐标的 <em>r</em> 和 <em>phi</em> 返回复数 <em>x</em>。相当于 <code>r * (math.cos(phi) + math.sin(phi)*1j)</code>。</p>
</li>
</ul>
<h2 id="幂函数与对数函数"><a href="#幂函数与对数函数" class="headerlink" title="幂函数与对数函数"></a>幂函数与对数函数</h2><ul>
<li><p><code>cmath.exp</code>(<em>x</em>)</p>
<p>返回 <em>e</em> 的 <em>x</em> 次方，<em>e</em> 是自然对数的底数。</p>
</li>
<li><p><code>cmath.log</code>(<em>x</em>[, <em>base</em>])</p>
<p>返回给定 <em>base</em> 的 <em>x</em> 的对数。如果没有给定 <em>base</em>，返回 <em>x</em> 的自然对数。 从 0 到 -∞ 存在一个分歧点，沿负实轴之上连续。</p>
</li>
<li><p><code>cmath.log10</code>(<em>x</em>)</p>
<p>返回底数为 10 的 <em>x</em> 的对数。它具有与 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#cmath.log" target="_blank" rel="noopener"><code>log()</code></a> 相同的分歧点。</p>
</li>
<li><p><code>cmath.sqrt</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的平方根。 它具有与 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#cmath.log" target="_blank" rel="noopener"><code>log()</code></a> 相同的分歧点。</p>
</li>
</ul>
<h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><ul>
<li><p><code>cmath.acos</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反余弦。这里有两个分歧点：一个沿着实轴从 1 向右延伸到 ∞，从下面连续延伸。另外一个沿着实轴从 -1 向左延伸到 -∞，从上面连续延伸。</p>
</li>
<li><p><code>cmath.asin</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反正弦。它与 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#cmath.acos" target="_blank" rel="noopener"><code>acos()</code></a> 有相同的分歧点。</p>
</li>
<li><p><code>cmath.atan</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反正切。它具有两个分歧点：一个沿着虚轴从 <code>1j</code> 延伸到 <code>∞j</code>，向右持续延伸。另一个是沿着虚轴从 <code>-1j</code> 延伸到 <code>-∞j</code> ，向左持续延伸。</p>
</li>
<li><p><code>cmath.cos</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的余弦。</p>
</li>
<li><p><code>cmath.sin</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的正弦。</p>
</li>
<li><p><code>cmath.tan</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的正切。</p>
</li>
</ul>
<h2 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h2><ul>
<li><p><code>cmath.acosh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反双曲余弦。它有一个分歧点沿着实轴从 1 到 -∞ 向左延伸，从上方持续延伸。</p>
</li>
<li><p><code>cmath.asinh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反双曲正弦。它有两个分歧点：一个沿着虚轴从 <code>1j</code> 向右持续延伸到 <code>∞j</code>。另一个是沿着虚轴从 <code>-1j</code> 向左持续延伸到 <code>-∞j</code>。</p>
</li>
<li><p><code>cmath.atanh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反双曲正切。它有两个分歧点：一个是沿着实轴从 <code>1</code> 延展到 <code>∞</code>，从下面持续延展。另一个是沿着实轴从 <code>-1</code> 延展到 <code>-∞</code>，从上面持续延展。</p>
</li>
<li><p><code>cmath.cosh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的双曲余弦值。</p>
</li>
<li><p><code>cmath.sinh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的双曲正弦值。</p>
</li>
<li><p><code>cmath.tanh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的双曲正切值。</p>
</li>
</ul>
<h2 id="分类函数"><a href="#分类函数" class="headerlink" title="分类函数"></a>分类函数</h2><ul>
<li><p><code>cmath.isfinite</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 的实部和虚部都是有限的，则返回 <code>True</code>，否则返回 <code>False</code>。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>cmath.isinf</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 的实部或者虚部是无穷大的，则返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><code>cmath.isnan</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 的实部或者虚部是 NaN，则返回 <code>True</code> ，否则返回 <code>False</code>。</p>
</li>
<li><p><code>cmath.isclose</code>(<em>a</em>, <em>b</em>, <em>**, </em>rel_tol=1e-09<em>, </em>abs_tol=0.0*)</p>
<p>若 <em>a</em> 和 <em>b</em> 的值比较接近则返回 <code>True</code>，否则返回 <code>False</code>。根据给定的绝对和相对容差确定两个值是否被认为是接近的。<em>rel_tol</em> 是相对容差 —— 它是 <em>a</em> 和 <em>b</em> 之间允许的最大差值，相对于 <em>a</em> 或 <em>b</em> 的较大绝对值。例如，要设置5％的容差，请传递 <code>rel_tol=0.05</code> 。默认容差为 <code>1e-09</code>，确保两个值在大约9位十进制数字内相同。 <em>rel_tol</em> 必须大于零。<em>abs_tol</em> 是最小绝对容差 —— 对于接近零的比较很有用。 <em>abs_tol</em> 必须至少为零。如果没有错误发生，结果将是： <code>abs(a-b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)</code> 。IEEE 754特殊值 <code>NaN</code> ， <code>inf</code> 和<code>-inf</code> 将根据IEEE规则处理。具体来说， <code>NaN</code> 不被认为接近任何其他值，包括 <code>NaN</code> 。 <code>inf</code> 和 <code>-inf</code> 只被认为接近自己。</p>
<blockquote>
<p><a href="https://www.python.org/dev/peps/pep-0485" target="_blank" rel="noopener"><strong>PEP 485</strong></a> —— 用于测试近似相等的函数</p>
</blockquote>
</li>
</ul>
<h2 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h2><ul>
<li><p><code>cmath.pi</code></p>
<p>数学常数 <em>π</em> ，作为一个浮点数。</p>
</li>
<li><p><code>cmath.e</code></p>
<p>数学常数 <em>e</em> ，作为一个浮点数。</p>
</li>
<li><p><code>cmath.tau</code></p>
<p>数学常数 <em>τ</em> ，作为一个浮点数。<em>3.6 新版功能.</em></p>
</li>
<li><p><code>cmath.inf</code></p>
<p>浮点正无穷大。相当于 <code>float(&#39;inf&#39;)</code>。<em>3.6 新版功能.</em></p>
</li>
<li><p><code>cmath.infj</code></p>
<p>具有零实部和正无穷虚部的复数。相当于 <code>complex(0.0, float(&#39;inf&#39;))</code>。<em>3.6 新版功能.</em></p>
</li>
<li><p><code>cmath.nan</code></p>
<p>浮点“非数字”（NaN）值。相当于 <code>float(&#39;nan&#39;)</code>。<em>3.6 新版功能.</em></p>
</li>
<li><p><code>cmath.nanj</code></p>
<p>具有零实部和 NaN 虚部的复数。相当于 <code>complex(0.0, float(&#39;nan&#39;))</code>。</p>
</li>
</ul>
<p>请注意，函数的选择与模块 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#module-math" target="_blank" rel="noopener"><code>math</code></a> 中的函数选择相似，但不完全相同。 拥有两个模块的原因是因为有些用户对复数不感兴趣，甚至根本不知道它们是什么。它们宁愿 <code>math.sqrt(-1)</code> 引发异常，也不想返回一个复数。 另请注意，被 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#module-cmath" target="_blank" rel="noopener"><code>cmath</code></a> 定义的函数始终会返回一个复数，尽管答案可以表示为一个实数（在这种情况下，复数的虚数部分为零）。</p>
<p>关于分歧点的注释：它们是沿着给定函数无法连续的曲线。它们是许多复杂函数的必要特征。假设您需要使用复杂函数进行计算，您将了解分歧点。请参阅几乎所有关于复杂变量的（不太基本）的书来进行启发。关于分歧点数值目的的正确选择信息，应提供以下良好参考.</p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>cmath</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library weakref</title>
    <url>/2020/02/11/python-standard-library-weakref/</url>
    <content><![CDATA[<h1 id="python-标准库-weakref-弱引用"><a href="#python-标准库-weakref-弱引用" class="headerlink" title="python 标准库 weakref 弱引用"></a>python 标准库 weakref 弱引用</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/compress.jpg?raw=true" alt></p>
<a id="more"></a>
<p>通过<code>google Insights</code> 优化,我把图片进行了压缩,明显速度提升了15%，接下来压缩css和js.</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/weakref.py" target="_blank" rel="noopener">Lib/weakref.py</a> </p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块允许Python程序员创建对象的 <em>weak references</em> 。</p>
<p>在下文中，术语 <em>referent</em> 表示由弱引用引用的对象。</p>
<p>对对象的弱引用不能保证对象存活：当对像的引用只剩弱引用时， <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-garbage-collection" target="_blank" rel="noopener">garbage collection</a> 可以销毁引用并将其内存重用于其他内容。但是，在实际销毁对象之前，即使没有强引用，弱引用也一直能返回该对象。</p>
<p>弱引用的主要用途是实现保存大对象的高速缓存或映射，但又并希望大对象仅仅因为它出现在高速缓存或映射中而保持存活。</p>
<p>例如，如果您有许多大型二进制图像对象，则可能希望将名称与每个对象关联起来。如果您使用Python字典将名称映射到图像，或将图像映射到名称，则图像对象将保持活动状态，因为它们在字典中显示为值或键。 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块提供的 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 类可以替代Python字典，使用弱引用来构造映射，这些映射不会仅仅因为它们出现在映射对象中而使对象保持存活。例如，如果一个图像对象是 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 中的值，那么当对该图像对象的剩余引用是弱映射对象所持有的弱引用时，垃圾回收可以回收该对象并将其在弱映射对象中相应的条目删除。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 在它们的实现中使用弱引用，在弱引用上设置回调函数，当键或值被垃圾回收回收时通知弱字典。 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakSet" target="_blank" rel="noopener"><code>WeakSet</code></a> 实现了 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 接口，但像 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 一样，只持有其元素的弱引用。`</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize" target="_blank" rel="noopener"><code>finalize</code></a> 提供了注册一个对象被垃圾收集时要调用的清理函数的方式。这比在原始弱引用上设置回调函数更简单，因为模块会自动确保对象被回收前终结器一直保持存活。</p>
<p>这些弱容器类型之一或者 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize" target="_blank" rel="noopener"><code>finalize</code></a> 就是大多数程序所需要的 - 通常不需要直接创建自己的弱引用。<a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块暴露了低级机制，以便于高级用途。</p>
<p>并非所有对象都可以被弱引用；可以被弱引用的对象包括类实例，用 Python（而不是用 C）编写的函数，实例方法、集合、冻结集合，某些 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">文件对象</a>，<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">生成器</a>，类型对象，套接字，数组，双端队列，正则表达式模式对象以及代码对象等。</p>
<p><em>在 3.2 版更改:</em> 添加了对thread.lock，threading.Lock和代码对象的支持。</p>
<p>几个内建类型如 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 不直接支持弱引用，但可以通过子类化添加支持:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">obj = Dict(red=<span class="number">1</span>, green=<span class="number">2</span>, blue=<span class="number">3</span>)   <span class="comment"># this object is weak referenceable</span></span><br></pre></td></tr></table></figure>
<p><strong>CPython implementation detail:</strong> 其他内置类型例如 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#tuple" target="_blank" rel="noopener"><code>tuple</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 不支持弱引用，即使通过子类化也不支持。</p>
<p>Extension types can easily be made to support weak references; see <a href="https://docs.python.org/zh-cn/3.8/extending/newtypes.html#weakref-support" target="_blank" rel="noopener">Weak Reference Support</a>.</p>
<ul>
<li><p><em>class</em> <code>weakref.`</code>ref`(<em>object</em>[, <em>callback</em>])</p>
<p>返回对 <em>对象</em> 的弱引用。如果原始对象仍然存活，则可以通过调用引用对象来检索原始对象；如果引用的原始对象不再存在，则调用引用对象将得到 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 。如果提供了 <em>回调</em> 而且值不是 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> ，并且返回的弱引用对象仍然存活，则在对象即将终结时将调用回调;弱引用对象将作为回调的唯一参数传递；指示物将不再可用。</p>
<p>许多弱引用也允许针对相同对象来构建。 为每个弱引用注册的回调将按从最近注册的回调到最早注册的回调的顺序被调用。</p>
<p>回调所引发的异常将记录于标准错误输出，但无法被传播；它们会按与对象的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法所引发的异常相同的方式被处理。</p>
<p>如果 <em>object</em> 可哈希，则弱引用也为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a>。 即使在 <em>object</em> 被删除之后它们仍将保持其哈希值。 如果 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#hash" target="_blank" rel="noopener"><code>hash()</code></a> 在 <em>object</em> 被删除之后才首次被调用，则该调用将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p>
<p>弱引用支持相等检测，但不支持排序比较。 如果被引用对象仍然存在，两个引用具有与它们的被引用对象一致的相等关系（无论 <em>callback</em> 是否相同）。 如果删除了任一被引用对象，则仅在两个引用对象为同一对象时两者才相等。</p>
<p>这是一个可子类化的类型而非一个工厂函数。</p>
<ul>
<li><p><strong><strong>callback</strong></strong> </p>
<p>这个只读属性会返回当前关联到弱引用的回调。 如果回调不存在或弱引用的被引用对象已不存在，则此属性的值为 <code>None</code>。 </p>
</li>
</ul>
</li>
<li><p><code>weakref.`</code>proxy`(<em>object</em>[, <em>callback</em>]) </p>
<p>返回 <em>object</em> 的一个使用弱引用的代理。 此函数支持在大多数上下文中使用代理，而不要求显式地对所使用的弱引用对象解除引用。 返回的对象类型将为 <code>ProxyType</code> 或 <code>CallableProxyType</code>，具体取决于 <em>object</em> 是否可调用。 Proxy 对象不是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a> 对象，无论被引用对象是否可哈希；这可避免与它们的基本可变性质相关的多种问题，并可防止它们被用作字典键。 <em>callback</em> 与 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref()</code></a> 函数的同名形参含义相同。</p>
<p><em>在 3.8 版更改:</em> 扩展代理对象所支持的运算符，包括矩阵乘法运算符 <code>@</code> 和 <code>@=</code>。</p>
</li>
<li><p><code>weakref.`</code>getweakrefcount`(<em>object</em>) </p>
<p>返回指向 <em>object</em> 的弱引用和代理的数量。 </p>
</li>
<li><p><code>weakref.`</code>getweakrefs`(<em>object</em>) </p>
<p>返回由指向 <em>object</em> 的所有弱引用和代理构成的列表。 </p>
</li>
<li><p><em>class</em> <code>weakref.`</code>WeakKeyDictionary`([<em>dict</em>]) </p>
<p>弱引用键的映射类。 当不再有对键的强引用时字典中的条目将被丢弃。 这可被用来将额外数据关联到一个应用中其他部分所拥有的对象而无需在那些对象中添加属性。 这对于重载了属性访问的对象来说特别有用。 </p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 对象具有一个额外方法可以直接公开内部引用。 这些引用不保证在它们被使用时仍然保持“存活”，因此这些引用的调用结果需要在使用前进行检测。 此方法可用于避免创建会导致垃圾回收器将保留键超出实际需要时长的引用。 </p>
</li>
<li><p><code>WeakKeyDictionary.`</code>keyrefs`() </p>
<p>返回包含对键的弱引用的可迭代对象。 </p>
</li>
<li><p><em>class</em> <code>weakref.`</code>WeakValueDictionary`([<em>dict</em>]) </p>
<p>弱引用值的映射类。 当不再有对键的强引用时字典中的条目将被丢弃。 </p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 对象具有一个额外方法，此方法存在与 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 对象的 <code>keyrefs()</code> 方法相同的问题。 </p>
</li>
<li><p><code>WeakValueDictionary.`</code>valuerefs`() </p>
<p> 返回包含对值的弱引用的可迭代对象。 </p>
</li>
<li><p><em>class</em> <code>weakref.`</code>WeakSet`([<em>elements</em>]) </p>
<p>保持对其元素弱引用的集合类。 当不再有对某个元素的强引用时元素将被丢弃。 </p>
</li>
<li><p><em>class</em> <code>weakref.`</code>WeakMethod`(<em>method</em>) </p>
<p>一个模拟对绑定方法（即在类中定义并在实例中查找的方法）进行弱引用的自定义 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref</code></a> 子类。 由于绑定方法是临时性的，标准弱引用无法保持它。 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakMethod" target="_blank" rel="noopener"><code>WeakMethod</code></a> 包含特别代码用来重新创建绑定方法，直到对象或初始函数被销毁: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"method called!"</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = weakref.ref(c.method)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = weakref.WeakMethod(c.method)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()</span><br><span class="line">&lt;bound method C.method of &lt;__main__.C object at <span class="number">0x7fc859830220</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()()</span><br><span class="line">method called!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> c</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.collect()</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>class</em> <code>weakref.`</code>finalize`(<em>obj</em>, <em>func</em>, <strong>args<em>, </em></strong>kwargs*) </p>
<p>返回一个可调用的终结器对象，该对象将在 <em>obj</em> 作为垃圾回收时被调用。 与普通的弱引用不同，终结器将总是存活，直到引用对象被回收，这极大地简化了生存期管理。</p>
<p>终结器总是被视为 <em>存活</em> 直到它被调用（显式调用或在垃圾回收时隐式调用），调用之后它将 <em>死亡</em>。 调用存活的终结器将返回 <code>func(*arg, **kwargs)</code> 的求值结果，而调用死亡的终结器将返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p>
<p>在垃圾收集期间由终结器回调所引发异常将显示于标准错误输出，但无法被传播。 它们会按与对象的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法或弱引用的回调所引发异常相同的方式被处理。</p>
<p>当程序退出时，剩余的存活终结器会被调用，除非它们的 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 属性已被设为假值。 它们会按与创建时相反的顺序被调用。</p>
<p>终结器在 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-interpreter-shutdown" target="_blank" rel="noopener">interpreter shutdown</a> 的后期绝不会发起调用其回调函数，此时模块全局变量很可能已被替换为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p>
<ul>
<li><p><code>__call__</code>()</p>
<p>如果 <em>self</em> 为存活状态则将其标记为已死亡，并返回调用 <code>func(*args, **kwargs)</code> 的结果。 如果 <em>self</em> 已死亡则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p>
</li>
<li><p><code>detach</code>()</p>
<p>如果 <em>self</em> 为存活状态则将其标记为已死亡，并返回元组 <code>(obj, func, args, kwargs)</code>。 如果 <em>self</em> 已死亡则返 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p>
</li>
<li><p><code>peek</code>()</p>
<p>如果 <em>self</em> 为存活状态则返回元组 <code>(obj, func, args, kwargs)</code>。 如果 <em>self</em> 已死亡则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p>
</li>
<li><p><code>alive</code></p>
<p>如果终结器为存活状态则该特征属性为真值，否则为假值。</p>
</li>
<li><p><code>atexit</code></p>
<p>一个可写的布尔型特征属性，默认为真值。 当程序退出时，它会调用所有 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize.atexit" target="_blank" rel="noopener"><code>atexit</code></a> 为真值的剩余存活终结器。 它们会按与创建时相反的顺序被调用。</p>
</li>
</ul>
</li>
<li><p><code>weakref.`</code>ReferenceType`</p>
<p>弱引用对象的类型对象。</p>
</li>
<li><p><code>weakref.`</code>ProxyType`</p>
<p>不可调用对象的代理的类型对象。</p>
</li>
<li><p><code>weakref.`</code>CallableProxyType`</p>
<p>可调用对象的代理的类型对象。</p>
</li>
<li><p><code>weakref.`</code>ProxyTypes`</p>
<p>包含所有代理的类型对象的序列。 这可以用于更方便地检测一个对象是否是代理，而不必依赖于两种代理对象的名称。</p>
</li>
<li><p><em>exception</em> <code>weakref.`</code>ReferenceError`</p>
<p>当一个代理对象被使用但其下层的对象已被收集时所引发的异常。 这等价于标准的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ReferenceError" target="_blank" rel="noopener"><code>ReferenceError</code></a> 异常。</p>
</li>
</ul>
<blockquote>
<p><a href="https://www.python.org/dev/peps/pep-0205" target="_blank" rel="noopener"><strong>PEP 205</strong></a> - 弱引用</p>
<p>此特性的提议和理由，包括早期实现的链接和其他语言中类似特性的相关信息。</p>
</blockquote>
<h2 id="弱引用对象"><a href="#弱引用对象" class="headerlink" title="弱引用对象"></a>弱引用对象</h2><p>弱引用对象没有 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref.__callback__" target="_blank" rel="noopener"><code>ref.__callback__</code></a> 以外的方法和属性。 一个弱引用对象如果存在，就允许通过调用它来获取引用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Object</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = weakref.ref(o)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o2 = r()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o <span class="keyword">is</span> o2</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>如果引用已不存在，则调用引用对象将返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> o, o2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(r())</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>检测一个弱引用对象是否仍然存在应该使用表达式 <code>ref() is not None</code>。 通常，需要使用引用对象的应用代码应当遵循这样的模式:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># r is a weak reference object</span></span><br><span class="line">o = r()</span><br><span class="line"><span class="keyword">if</span> o <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># referent has been garbage collected</span></span><br><span class="line">    print(<span class="string">"Object has been deallocated; can't frobnicate."</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Object is still live!"</span>)</span><br><span class="line">    o.do_something_useful()</span><br></pre></td></tr></table></figure>
<p>使用单独的“存活”测试会在多线程应用中制造竞争条件；其他线程可能导致某个弱引用在该弱引用被调用前就失效；上述的写法在多线程应用和单线程应用中都是安全的。</p>
<p>特别版本的 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref</code></a> 对象可以通过子类化来创建。 在 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 的实现中就使用了这种方式来减少映射中每个条目的内存开销。 这对于将附加信息关联到引用的情况最为适用，但也可以被用于在调用中插入额外处理来提取引用。</p>
<p>这个例子演示了如何将 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref</code></a> 的一个子类用于存储有关对象的附加信息并在引用被访问时影响其所返回的值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedRef</span><span class="params">(weakref.ref)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ob, callback=None, /, **annotations)</span>:</span></span><br><span class="line">        super(ExtendedRef, self).__init__(ob, callback)</span><br><span class="line">        self.__counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> annotations.items():</span><br><span class="line">            setattr(self, k, v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a pair containing the referent and the number of</span></span><br><span class="line"><span class="string">        times the reference has been called.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ob = super(ExtendedRef, self).__call__()</span><br><span class="line">        <span class="keyword">if</span> ob <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.__counter += <span class="number">1</span></span><br><span class="line">            ob = (ob, self.__counter)</span><br><span class="line">        <span class="keyword">return</span> ob</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这个简单的例子演示了一个应用如何使用对象 ID 来提取之前出现过的对象。 然后对象的 ID 可以在其它数据结构中使用，而无须强制对象保持存活，但处于存活状态的对象也仍然可以通过 ID 来提取。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line">_id2obj_dict = weakref.WeakValueDictionary()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remember</span><span class="params">(obj)</span>:</span></span><br><span class="line">    oid = id(obj)</span><br><span class="line">    _id2obj_dict[oid] = obj</span><br><span class="line">    <span class="keyword">return</span> oid</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">id2obj</span><span class="params">(oid)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _id2obj_dict[oid]</span><br></pre></td></tr></table></figure>
<h2 id="终结器对象"><a href="#终结器对象" class="headerlink" title="终结器对象"></a>终结器对象</h2><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize" target="_blank" rel="noopener"><code>finalize</code></a> 的主要好处在于它能更简便地注册回调函数，而无须保留所返回的终结器对象。 例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Object</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kenny = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weakref.finalize(kenny, <span class="keyword">print</span>, <span class="string">"You killed Kenny!"</span>)  </span><br><span class="line">&lt;finalize object at ...; <span class="keyword">for</span> <span class="string">'Object'</span> at ...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> kenny</span><br><span class="line">You killed Kenny!</span><br></pre></td></tr></table></figure>
<p>终结器也可以被直接调用。 但是终结器最多只能对回调函数发起一次调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(x, y, z)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"CALLBACK"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y + z</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = weakref.finalize(obj, callback, <span class="number">1</span>, <span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> f.alive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> f() == <span class="number">6</span></span><br><span class="line">CALLBACK</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="keyword">not</span> f.alive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()                     <span class="comment"># callback not called because finalizer dead</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> obj                 <span class="comment"># callback not called because finalizer dead</span></span><br></pre></td></tr></table></figure>
<p>你可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize.detach" target="_blank" rel="noopener"><code>detach()</code></a> 方法来注销一个终结器。 该方法将销毁终结器并返回其被创建时传给构造器的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = weakref.finalize(obj, callback, <span class="number">1</span>, <span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.detach()                                           </span><br><span class="line">(&lt;...Object object ...&gt;, &lt;function callback ...&gt;, (<span class="number">1</span>, <span class="number">2</span>), &#123;<span class="string">'z'</span>: <span class="number">3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newobj, func, args, kwargs = _</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="keyword">not</span> f.alive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> newobj <span class="keyword">is</span> obj</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> func(*args, **kwargs) == <span class="number">6</span></span><br><span class="line">CALLBACK</span><br></pre></td></tr></table></figure>
<p>除非你将 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize.atexit" target="_blank" rel="noopener"><code>atexit</code></a> 属性设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>，否则终结器在程序退出时如果仍然存活就将被调用。 例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weakref.finalize(obj, <span class="keyword">print</span>, <span class="string">"obj dead or exiting"</span>)</span><br><span class="line">&lt;finalize object at ...; <span class="keyword">for</span> <span class="string">'Object'</span> at ...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exit()</span><br><span class="line">obj dead <span class="keyword">or</span> exiting</span><br></pre></td></tr></table></figure>
<h2 id="比较终结器与-del-方法"><a href="#比较终结器与-del-方法" class="headerlink" title="比较终结器与 __del__() 方法"></a>比较终结器与 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法</h2><p>假设我们想创建一个类，用它的实例来代表临时目录。 当以下事件中的某一个发生时，这个目录应当与其内容一起被删除：</p>
<ul>
<li>对象被作为垃圾回收，</li>
<li>对象的 <code>remove()</code> 方法被调用，或</li>
<li>程序退出。</li>
</ul>
<p>我们可以尝试使用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法来实现这个类，如下所示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TempDir</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = tempfile.mkdtemp()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            shutil.rmtree(self.name)</span><br><span class="line">            self.name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removed</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.remove()</span><br></pre></td></tr></table></figure>
<p>从 Python 3.4 开始，<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法不会再阻止循环引用被作为垃圾回收，并且模块全局变量在 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-interpreter-shutdown" target="_blank" rel="noopener">interpreter shutdown</a> 期间不会被强制设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。 因此这段代码在 CPython 上应该会正常运行而不会出现任何问题。</p>
<p>然而，<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法的处理会严重地受到具体实现的影响，因为它依赖于解释器垃圾回收实现方式的内部细节。</p>
<p>更健壮的替代方式可以是定义一个终结器，只引用它所需要的特定函数和对象，而不是获取对整个对象状态的访问权:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TempDir</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = tempfile.mkdtemp()</span><br><span class="line">        self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._finalizer()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removed</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._finalizer.alive</span><br></pre></td></tr></table></figure>
<p>像这样定义后，我们的终结器将只接受一个对其完成正确清理目录任务所需细节的引用。 如果对象一直未被作为垃圾回收，终结器仍会在退出时被调用。</p>
<p>基于弱引用的终结器还具有另一项优势，就是它们可被用来为定义由第三方控制的类注册终结器，例如当一个模块被卸载时运行特定代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref, sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unloading_module</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># implicit reference to the module globals from the function body</span></span><br><span class="line">weakref.finalize(sys.modules[__name__], unloading_module)</span><br></pre></td></tr></table></figure>
<p><strong>备注</strong>:</p>
<p> 如果当程序退出时你恰好在守护线程中创建终结器对象，则有可能该终结器不会在退出时被调用。 但是，在一个守护线程中 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#atexit.register" target="_blank" rel="noopener"><code>atexit.register()</code></a>, <code>try: ... finally: ...</code> 和 <code>with: ...</code> 同样不能保证执行清理。 </p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>weakref</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library tempfile</title>
    <url>/2020/02/13/python-standard-library-tempfile/</url>
    <content><![CDATA[<h1 id="python-标准库-tempfile"><a href="#python-标准库-tempfile" class="headerlink" title="python 标准库 tempfile"></a>python 标准库 tempfile</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200213_car.jpeg?raw=true" alt></p>
<a id="more"></a>
<p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/tempfile.py" target="_blank" rel="noopener">Lib/tempfile.py</a></p>
<hr>
<p>该模块用于创建临时文件和目录，它可以跨平台使用。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.NamedTemporaryFile" target="_blank" rel="noopener"><code>NamedTemporaryFile</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryDirectory" target="_blank" rel="noopener"><code>TemporaryDirectory</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.SpooledTemporaryFile" target="_blank" rel="noopener"><code>SpooledTemporaryFile</code></a> 是带有自动清理功能的高级接口，可用作上下文管理器。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 是低级函数，使用完毕需手动清理。</p>
<p>所有由用户调用的函数和构造函数都带有参数，这些参数可以设置临时文件和临时目录的路径和名称。该模块生成的文件名包括一串随机字符，在公共的临时目录中，这些字符可以让创建文件更加安全。为了保持向后兼容性，参数的顺序有些奇怪。所以为了代码清晰，建议使用关键字参数。</p>
<p>这个模块定义了以下内容供用户调用：</p>
<ul>
<li><p><code>tempfile.TemporaryFile</code>(<em>mode=’w+b’</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>**, </em>errors=None*)</p>
<p>返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-like-object" target="_blank" rel="noopener">file-like object</a> （文件类对象）作为临时存储区域。创建该文件使用了与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 相同的安全规则。它将在关闭后立即销毁（包括垃圾回收机制关闭该对象时）。在 Unix 下，该文件在目录中的条目根本不创建，或者创建文件后立即就被删除了，其他平台不支持此功能。您的代码不应依赖使用此功能创建的临时文件名称，因为它在文件系统中的名称可能是可见的，也可能是不可见的。</p>
<p>生成的对象可以用作上下文管理器（参见 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile-examples" target="_blank" rel="noopener">示例</a>）。完成上下文或销毁临时文件对象后，临时文件将从文件系统中删除。</p>
<p><em>mode</em> 参数默认值为 <code>&#39;w+b&#39;</code>，所以创建的文件不用关闭，就可以读取或写入。因为用的是二进制模式，所以无论存的是什么数据，它在所有平台上都表现一致。<em>buffering</em>、<em>encoding</em>、<em>errors</em> 和 <em>newline</em> 的含义与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 中的相同。</p>
<p>参数 <em>dir</em>、<em>prefix</em> 和 <em>suffix</em> 的含义和默认值都与它们在 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 中的相同。</p>
<p>在 POSIX 平台上，它返回的对象是真实的文件对象。在其他平台上，它是一个文件类对象 (file-like object)，它的 <code>file</code> 属性是底层的真实文件对象。</p>
<p>如果可用，则使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_TMPFILE" target="_blank" rel="noopener"><code>os.O_TMPFILE</code></a> 标志（仅限于 Linux，需要 3.11 及更高版本的内核）。</p>
<p>引发一个 <code>tempfile.mkstemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p>
<p><em>在 3.5 版更改:</em> 如果可用，现在用的是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_TMPFILE" target="_blank" rel="noopener"><code>os.O_TMPFILE</code></a> 标志。</p>
<p><em>在 3.8 版更改:</em> 添加了 <em>errors</em> 参数。</p>
</li>
<li><p><code>tempfile.NamedTemporaryFile</code>(<em>mode=’w+b’</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>delete=True</em>, <em>**, </em>errors=None*) </p>
<p>此函数执行的操作与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 完全相同，但确保了该临时文件在文件系统中具有可见的名称（在 Unix 上表现为目录条目不取消链接）。从返回的文件类对象的 <code>name</code> 属性中可以检索到文件名。在临时文件仍打开时，是否允许用文件名第二次打开文件，在各个平台上是不同的（在 Unix 上可以，但在 Windows NT 或更高版本上不行）。如果 <em>delete</em> 为 true（默认值），则文件会在关闭后立即被删除。该函数返回的对象始终是文件类对象 (file-like object)，它的 <code>file</code> 属性是底层的真实文件对象。文件类对象可以像普通文件一样在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中使用。</p>
<p>引发一个 <code>tempfile.mkstemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p>
<p><em>在 3.8 版更改:</em> 添加了 <em>errors</em> 参数。</p>
</li>
<li><p><code>tempfile.SpooledTemporaryFile</code>(<em>max_size=0</em>, <em>mode=’w+b’</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>**, </em>errors=None*) </p>
<p>此函数执行的操作与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 完全相同，但会将数据缓存在内存中，直到文件大小超过 <em>max_size</em>，或调用文件的 <code>fileno()</code> 方法为止，此时数据会被写入磁盘，并且写入操作与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 相同。</p>
<p>此函数生成的文件对象有一个额外的方法——<code>rollover()</code>，可以忽略文件大小，让文件立即写入磁盘。</p>
<p>返回的对象是文件类对象 (file-like object)，它的 <code>_file</code> 属性是 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.BytesIO" target="_blank" rel="noopener"><code>io.BytesIO</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.TextIOWrapper" target="_blank" rel="noopener"><code>io.TextIOWrapper</code></a> 对象（取决于指定的是二进制模式还是文本模式）或真实的文件对象（取决于是否已调用 <code>rollover()</code>）。文件类对象可以像普通文件一样在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中使用。</p>
<p><em>在 3.3 版更改:</em> 现在，文件的 truncate 方法可接受一个 <code>size</code> 参数。</p>
<p><em>在 3.8 版更改:</em> 添加了 <em>errors</em> 参数。</p>
</li>
<li><p><code>tempfile.TemporaryDirectory</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>) </p>
<p>此函数会安全地创建一个临时目录，且使用与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 相同的规则。此函数返回的对象可用作上下文管理器（参见 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile-examples" target="_blank" rel="noopener">示例</a>）。完成上下文或销毁临时目录对象后，新创建的临时目录及其所有内容将从文件系统中删除。</p>
<p>可以从返回对象的 <code>name</code> 属性中找到临时目录的名称。当返回的对象用作上下文管理器时，这个 <code>name</code> 会作为 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中 <code>as</code> 子句的目标（如果有 as 的话）。</p>
<p>可以调用 <code>cleanup()</code> 方法来手动清理目录。</p>
<p>引发一个 <code>tempfile.mkdtemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p>
<p><em>3.2 新版功能.</em></p>
</li>
<li><p><code>tempfile.mkstemp</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>text=False</em>) </p>
<p>以最安全的方式创建一个临时文件。假设所在平台正确实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_EXCL" target="_blank" rel="noopener"><code>os.O_EXCL</code></a> 标志，则创建文件时不会有竞争的情况。该文件只能由创建者读写，如果所在平台用权限位来标记文件是否可执行，那么没有人有执行权。文件描述符不会过继给子进程。</p>
<p>与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 不同，<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 用户用完临时文件后需要自行将其删除。</p>
<p>如果 <em>suffix</em> 不是 <code>None</code> 则文件名将以该后缀结尾，是 <code>None</code> 则没有后缀。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 不会在文件名和后缀之间加点，如果需要加一个点号，请将其放在 <em>suffix</em> 的开头。</p>
<p>如果 <em>prefix</em> 不是 <code>None</code>，则文件名将以该前缀开头，是 <code>None</code> 则使用默认前缀。默认前缀是 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefix" target="_blank" rel="noopener"><code>gettempprefix()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefixb" target="_blank" rel="noopener"><code>gettempprefixb()</code></a> 函数的返回值（自动调用合适的函数）。</p>
<p>如果 <em>dir</em> 不为 <code>None</code>，则在指定的目录创建文件，是 <code>None</code> 则使用默认目录。默认目录是从一个列表中选择出来的，这个列表不同平台不一样，但是用户可以设置 <em>TMPDIR</em>、<em>TEMP</em> 或 <em>TMP</em> 环境变量来设置目录的位置。因此，不能保证生成的临时文件路径很规范，比如，通过 <code>os.popen()</code> 将路径传递给外部命令时仍需要加引号。</p>
<p>如果 <em>suffix</em>、<em>prefix</em> 和 <em>dir</em> 中的任何一个不是 <code>None</code>，就要保证它们是同一数据类型。如果它们是 bytes，则返回的名称的类型就是 bytes 而不是 str。如果确实要用默认参数，但又想要返回值是 bytes 类型，请传入 <code>suffix=b&#39;&#39;</code>。</p>
<p>如果指定了 <em>text</em> 参数，它表示的是以二进制模式（默认）还是文本模式打开文件。在某些平台上，两种模式没有区别。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 返回一个元组，元组中第一个元素是句柄，它是一个系统级句柄，指向一个打开的文件（等同于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 的返回值），第二元素是该文件的绝对路径。</p>
<p>引发一个 <code>tempfile.mkstemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p>
<p><em>在 3.5 版更改:</em> 现在，<em>suffix</em>、<em>prefix</em> 和 <em>dir</em> 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 str。<em>suffix</em> 和 <em>prefix</em> 现在可以接受 <code>None</code>，并且默认为 <code>None</code> 以使用合适的默认值。</p>
<p><em>在 3.6 版更改:</em> <em>dir</em> 参数现在可接受一个路径类对象 (<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a>)。</p>
</li>
<li><p><code>tempfile.mkdtemp</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>) </p>
<p>以最安全的方式创建一个临时目录，创建该目录时不会有竞争的情况。该目录只能由创建者读取、写入和搜索。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 用户用完临时目录后需要自行将其删除。</p>
<p><em>prefix</em>、<em>suffix</em> 和 <em>dir</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 中的相同。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 返回新目录的绝对路径。</p>
<p>引发一个 <code>tempfile.mkdtemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p>
<p><em>在 3.5 版更改:</em> 现在，<em>suffix</em>、<em>prefix</em> 和 <em>dir</em> 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 str。<em>suffix</em> 和 <em>prefix</em> 现在可以接受 <code>None</code>，并且默认为 <code>None</code> 以使用合适的默认值。</p>
<p><em>在 3.6 版更改:</em> <em>dir</em> 参数现在可接受一个路径类对象 (<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a>)。</p>
</li>
<li><p><code>tempfile.gettempdir</code>() </p>
<p>返回放置临时文件的目录的名称。这个方法的返回值就是本模块所有函数的 <em>dir</em> 参数的默认值。</p>
<p>Python 搜索标准目录列表，以找到调用者可以在其中创建文件的目录。这个列表是：</p>
<ol>
<li><code>TMPDIR</code> 环境变量指向的目录。</li>
<li><code>TEMP</code> 环境变量指向的目录。</li>
<li><code>TMP</code> 环境变量指向的目录。</li>
<li>与平台相关的位置：<ul>
<li>在 Windows 上，依次为 <code>C:\TEMP</code>、<code>C:\TMP</code>、<code>\TEMP</code> 和 <code>\TMP</code>。</li>
<li>在所有其他平台上，依次为 <code>/tmp</code>、<code>/var/tmp</code> 和 <code>/usr/tmp</code>。</li>
</ul>
</li>
<li>不得已时，使用当前工作目录。</li>
</ol>
<p>搜索的结果会缓存起来，参见下面 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.tempdir" target="_blank" rel="noopener"><code>tempdir</code></a> 的描述。</p>
</li>
<li><p><code>tempfile.gettempdirb</code>()</p>
<p>与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempdir" target="_blank" rel="noopener"><code>gettempdir()</code></a> 相同，但返回值为字节类型。<em>3.5 新版功能.</em></p>
</li>
<li><p><code>tempfile.gettempprefix</code>()</p>
<p>返回用于创建临时文件的文件名前缀，它不包含目录部分。</p>
</li>
<li><p><code>tempfile.gettempprefixb</code>()</p>
<p>与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefix" target="_blank" rel="noopener"><code>gettempprefix()</code></a> 相同，但返回值为字节类型。<em>3.5 新版功能.</em></p>
</li>
</ul>
<p>本模块使用一个全局变量来存储由 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempdir" target="_blank" rel="noopener"><code>gettempdir()</code></a> 返回的临时文件目录路径。可以直接给它赋值，这样可以覆盖自动选择的路径，但是不建议这样做。本模块中的所有函数都带有一个 <em>dir</em> 参数，该参数可用于指定目录，这是推荐的方法。</p>
<ul>
<li><p><code>tempfile.tempdir</code></p>
<p>当设置为 <code>None</code> 以外的其他值时，此变量将决定本模块所有函数的 <em>dir</em> 参数的默认值。如果在调用除 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefix" target="_blank" rel="noopener"><code>gettempprefix()</code></a> 外的上述任何函数时 <code>tempdir</code> 为 <code>None</code> (默认值) 则它会按照 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempdir" target="_blank" rel="noopener"><code>gettempdir()</code></a> 中所描述的算法来初始化。</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下是 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#module-tempfile" target="_blank" rel="noopener"><code>tempfile</code></a> 模块典型用法的一些示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> tempfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a temporary file and write some data to it</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp = tempfile.TemporaryFile()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.write(<span class="string">b'Hello world!'</span>)</span><br><span class="line"><span class="comment"># read data from file</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.seek(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.read()</span><br><span class="line"><span class="string">b'Hello world!'</span></span><br><span class="line"><span class="comment"># close the file, it will be removed</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a temporary file using a context manager</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> tempfile.TemporaryFile() <span class="keyword">as</span> fp:</span><br><span class="line"><span class="meta">... </span>    fp.write(<span class="string">b'Hello world!'</span>)</span><br><span class="line"><span class="meta">... </span>    fp.seek(<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span>    fp.read()</span><br><span class="line"><span class="string">b'Hello world!'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment"># file is now closed and removed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create a temporary directory using the context manager</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> tempfile.TemporaryDirectory() <span class="keyword">as</span> tmpdirname:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'created temporary directory'</span>, tmpdirname)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment"># directory and contents have been removed</span></span><br></pre></td></tr></table></figure>
<h2 id="已弃用的函数和变量"><a href="#已弃用的函数和变量" class="headerlink" title="已弃用的函数和变量"></a>已弃用的函数和变量</h2><p>创建临时文件有一种历史方法，首先使用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mktemp" target="_blank" rel="noopener"><code>mktemp()</code></a> 函数生成一个文件名，然后使用该文件名创建文件。不幸的是，这是不安全的，因为在调用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mktemp" target="_blank" rel="noopener"><code>mktemp()</code></a> 与随后尝试创建文件的进程之间的时间里，其他进程可能会使用该名称创建文件。解决方案是将两个步骤结合起来，立即创建文件。这个方案目前被 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 和上述其他函数所采用。</p>
<ul>
<li><p><code>tempfile.mktemp</code>(<em>suffix=’’</em>, <em>prefix=’tmp’</em>, <em>dir=None</em>)</p>
<p><em>2.3 版后已移除:</em> 使用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 来代替。返回一个绝对路径，这个路径指向的文件在调用本方法时不存在。<em>prefix</em>、<em>suffix</em> 和 <em>dir</em> 参数与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 中的同名参数类似，不同之处在于不支持字节类型的文件名，不支持 <code>suffix=None</code> 和 <code>prefix=None</code>。</p>
</li>
</ul>
<p>使用此功能可能会在程序中引入安全漏洞。当你开始使用本方法返回的文件执行任何操作时，可能有人已经捷足先登了。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mktemp" target="_blank" rel="noopener"><code>mktemp()</code></a> 的功能可以很轻松地用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.NamedTemporaryFile" target="_blank" rel="noopener"><code>NamedTemporaryFile()</code></a> 代替，当然需要传递 <code>delete=False</code> 参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = NamedTemporaryFile(delete=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.name</span><br><span class="line"><span class="string">'/tmp/tmptjujjt'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">b"Hello World!\n"</span>)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.unlink(f.name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exists(f.name)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>tempfile</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library linecache</title>
    <url>/2020/02/14/python-standard-library-linecache/</url>
    <content><![CDATA[<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200214_valentines.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>情人节快乐，愿有情人终成眷属!</p>
</blockquote>
<p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/linecache.py" target="_blank" rel="noopener">Lib/linecache.py</a></p>
<hr>
<p><a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#module-linecache" target="_blank" rel="noopener"><code>linecache</code></a> 模块允许从一个 Python 源文件中获取任意的行，并会尝试使用缓存进行内部优化，常应用于从单个文件读取多行的场合。 此模块被 <a href="https://docs.python.org/zh-cn/3.8/library/traceback.html#module-traceback" target="_blank" rel="noopener"><code>traceback</code></a> 模块用来提取源码行以便包含在格式化的回溯中。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/tokenize.html#tokenize.open" target="_blank" rel="noopener"><code>tokenize.open()</code></a> 函数被用于打开文件。 此函数使用 <a href="https://docs.python.org/zh-cn/3.8/library/tokenize.html#tokenize.detect_encoding" target="_blank" rel="noopener"><code>tokenize.detect_encoding()</code></a> 来获取文件的编码格式；如果未指明编码格式，则默认编码为 UTF-8。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#module-linecache" target="_blank" rel="noopener"><code>linecache</code></a> 模块定义了下列函数：</p>
<ul>
<li><p><code>linecache.getline</code>(<em>filename</em>, <em>lineno</em>, <em>module_globals=None</em>)</p>
<p>从名为 <em>filename</em> 的文件中获取 <em>lineno</em> 行，此函数绝不会引发异常 — 出现错误时它将返回 <code>&#39;&#39;</code> (所有找到的行都将包含换行符作为结束)。如果找不到名为 <em>filename</em> 的文件，此函数会先在 <em>module_globals</em> 中检查 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a> <code>__loader__</code>。 如果存在这样的加载器并且它定义了 <code>get_source</code> 方法，则由该方法来确定源行 (如果 <code>get_source()</code> 返回 <code>None</code>，则该函数返回 <code>&#39;&#39;</code>)。 最后，如果 <em>filename</em> 是一个相对路径文件名，则它会在模块搜索路径 <code>sys.path</code> 中按条目的相对位置进行查找。</p>
</li>
<li><p><code>linecache.clearcache</code>()</p>
<p>清空缓存。 如果你不再需要之前使用 <a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#linecache.getline" target="_blank" rel="noopener"><code>getline()</code></a> 从文件读取的行即可使用此函数。</p>
</li>
<li><p><code>linecache.checkcache</code>(<em>filename=None</em>)</p>
<p>检查缓存有效性。 如果缓存中的文件在磁盘上发生了改变，而你需要更新后的版本即可使用此函数。 如果省略了 <em>filename</em>，它会检查缓存中的所有条目。</p>
</li>
<li><p><code>linecache.lazycache</code>(<em>filename</em>, <em>module_globals</em>)</p>
<p>捕获有关某个非基于文件的模块的足够细节信息，以允许稍后再通过 <a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#linecache.getline" target="_blank" rel="noopener"><code>getline()</code></a> 来获取其中的行，即使当稍后调用时 <em>module_globals</em> 为 <code>None</code>。 这可以避免在实际需要读取行之前执行 I/O，也不必始终保持模块全局变量。<em>3.5 新版功能.</em></p>
</li>
</ul>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> linecache</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>linecache.getline(linecache.__file__, <span class="number">8</span>)</span><br><span class="line"><span class="string">'import sys\n'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> linecache</span><br><span class="line"><span class="comment">## 获取指定前四条数据</span></span><br><span class="line">a = linecache.getlines(<span class="string">'aa.txt'</span>)[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">## 获取第四条数据</span></span><br><span class="line">a = linecache.getline(<span class="string">'aa.txt'</span>,<span class="number">4</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>linecache</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library coroutines</title>
    <url>/2020/02/12/python-standard-library-coroutines/</url>
    <content><![CDATA[<h1 id="python-标准库-coroutines-协程"><a href="#python-标准库-coroutines-协程" class="headerlink" title="python 标准库 coroutines 协程"></a>python 标准库 coroutines 协程</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200213_coroutine.jpg?raw=true" alt></p>
<a id="more"></a>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200213_writing.jpg?raw=true" alt></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id2" target="_blank" rel="noopener">协程</a></h2><p> <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">Coroutines</a> declared with the async/await syntax is the preferred way of writing asyncio applications. For example, the following snippet of code (requires Python 3.7+) prints “hello”, waits 1 second, and then prints “world”: </p>
<p> <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">Coroutines</a> 通过 async/await 语法声明是编写异步应用程序的首选方式。例如下面的语法片段(需要Python 3.7+),我们实现了等待一秒,打印’’world“的功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'hello'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>asyncio.run(main())</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<p> 注意：简单地调用一个协程并不会将其加入执行日程: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>main()</span><br><span class="line">&lt;coroutine object main at <span class="number">0x1053bb7c8</span>&gt;</span><br></pre></td></tr></table></figure>
<p>要真正运行一个协程，asyncio 提供了三种主要机制:</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.run" target="_blank" rel="noopener"><code>asyncio.run()</code></a> 函数用来运行最高层级的入口点 “main()” 函数 (参见上面的示例。)</p>
</li>
<li><p>等待一个协程。以下代码段会在等待 1 秒后打印 “hello”，然后 <em>再次</em> 等待 2 秒后打印 “world”:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_after</span><span class="params">(delay, what)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    print(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>预期的输出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">started at <span class="number">17</span>:<span class="number">13</span>:<span class="number">52</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finished at <span class="number">17</span>:<span class="number">13</span>:<span class="number">55</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>asyncio.create_task()</code></a> 函数用来并发运行作为 asyncio <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>任务</code></a> 的多个协程。 </p>
<p>让我们修改以上示例，<em>并发</em> 运行两个 <code>say_after</code> 协程:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task1 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">1</span>, <span class="string">'hello'</span>))</span><br><span class="line"></span><br><span class="line">    task2 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">2</span>, <span class="string">'world'</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait until both tasks are completed (should take</span></span><br><span class="line">    <span class="comment"># around 2 seconds.)</span></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>注意，预期的输出显示代码段的运行时间比之前快了 1 秒:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">started at <span class="number">17</span>:<span class="number">14</span>:<span class="number">32</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finished at <span class="number">17</span>:<span class="number">14</span>:<span class="number">34</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="可等待对象"><a href="#可等待对象" class="headerlink" title="可等待对象"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id3" target="_blank" rel="noopener">可等待对象</a></h2><p>如果一个对象可以在 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#await" target="_blank" rel="noopener"><code>await</code></a> 语句中使用，那么它就是 <strong>可等待</strong> 对象。许多 asyncio API 都被设计为接受可等待对象。</p>
<p><em>可等待</em> 对象有三种主要类型: <strong>协程</strong>, <strong>任务</strong> 和 <strong>Future</strong>.</p>
<p>协程</p>
<p>Python 协程属于 <em>可等待</em> 对象，因此可以在其他协程中被等待:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Nothing happens if we just call "nested()".</span></span><br><span class="line">    <span class="comment"># A coroutine object is created but not awaited,</span></span><br><span class="line">    <span class="comment"># so it *won't run at all*.</span></span><br><span class="line">    nested()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let's do it differently now and await it:</span></span><br><span class="line">    print(<span class="keyword">await</span> nested())  <span class="comment"># will print "42".</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>重要</p>
<p>在本文档中 “协程” 可用来表示两个紧密关联的概念:</p>
<ul>
<li><em>协程函数</em>: 定义形式为 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 的函数;</li>
<li><p><em>协程对象</em>: 调用 <em>协程函数</em> 所返回的对象。</p>
<p>asyncio 也支持旧式的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-generator-based-coro" target="_blank" rel="noopener">基于生成器的</a> 协程。 </p>
</li>
</ul>
<p>任务</p>
<p><em>任务</em> 被用来设置日程以便 <em>并发</em> 执行协程。</p>
<p>当一个协程通过 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>asyncio.create_task()</code></a> 等函数被打包为一个 <em>任务</em>，该协程将自动排入日程准备立即运行:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Schedule nested() to run soon concurrently</span></span><br><span class="line">    <span class="comment"># with "main()".</span></span><br><span class="line">    task = asyncio.create_task(nested())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># "task" can now be used to cancel "nested()", or</span></span><br><span class="line">    <span class="comment"># can simply be awaited to wait until it is complete:</span></span><br><span class="line">    <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>Future 对象</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future</code></a> 是一种特殊的 <strong>低层级</strong> 可等待对象，表示一个异步操作的 <strong>最终结果</strong>。</p>
<p>当一个 Future 对象 <em>被等待</em>，这意味着协程将保持等待直到该 Future 对象在其他地方操作完毕。</p>
<p>在 asyncio 中需要 Future 对象以便允许通过 async/await 使用基于回调的代码。</p>
<p>通常情况下 <strong>没有必要</strong> 在应用层级的代码中创建 Future 对象。</p>
<p>Future 对象有时会由库和某些 asyncio API 暴露给用户，用作可等待对象:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> function_that_returns_a_future_object()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># this is also valid:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        function_that_returns_a_future_object(),</span><br><span class="line">        some_python_coroutine()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>一个很好的返回对象的低层级函数的示例是 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.loop.run_in_executor" target="_blank" rel="noopener"><code>loop.run_in_executor()</code></a>。</p>
<h2 id="运行-asyncio-程序"><a href="#运行-asyncio-程序" class="headerlink" title="运行 asyncio 程序"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id4" target="_blank" rel="noopener">运行 asyncio 程序</a></h2><p> <code>asyncio.run</code>(<em>coro</em>, <em>**, </em>debug=False*) </p>
<p>执行 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> <em>coro</em> 并返回结果。</p>
<p>此函数运行传入的协程，负责管理 asyncio 事件循环并 <em>完结异步生成器</em>。</p>
<p>当有其他 asyncio 事件循环在同一线程中运行时，此函数不能被调用。</p>
<p>如果 <em>debug</em> 为 <code>True</code>，事件循环将以调试模式运行。</p>
<p>此函数总是会创建一个新的事件循环并在结束时关闭之。它应当被用作 asyncio 程序的主入口点，理想情况下应当只被调用一次。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p> <em>3.7 新版功能.</em> </p>
<blockquote>
<p>  <code>asyncio.run()</code>源代码请移步至 <a href="https://github.com/python/cpython/tree/3.8/Lib/asyncio/runners.py" target="_blank" rel="noopener">Lib/asyncio/runners.py</a>.</p>
</blockquote>
<h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id5" target="_blank" rel="noopener">创建任务</a></h2><ul>
<li><p><code>asyncio.create_task</code>(<em>coro</em>, <em>**, </em>name=None*)</p>
<p>将 <em>coro</em> <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程</a> 打包为一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 排入日程准备执行。返回 Task 对象。</p>
<p>If <em>name</em> is not <code>None</code>, it is set as the name of the task using <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.set_name" target="_blank" rel="noopener"><code>Task.set_name()</code></a>.</p>
<p>该任务会在 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener"><code>get_running_loop()</code></a> 返回的循环中执行，如果当前线程没有在运行的循环则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p>
<p>此函数 <strong>在 Python 3.7 中被加入</strong>。在 Python 3.7 之前，可以改用低层级的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.ensure_future" target="_blank" rel="noopener"><code>asyncio.ensure_future()</code></a> 函数。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># In Python 3.7+</span></span><br><span class="line">task = asyncio.create_task(coro())</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># This works in all Python versions but is less readable</span></span><br><span class="line">task = asyncio.ensure_future(coro())</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><em>3.7 新版功能.</em></p>
<p><em>在 3.8 版更改:</em> Added the <code>name</code> parameter.</p>
<h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id6" target="_blank" rel="noopener">休眠</a></h2><ul>
<li><p><em>coroutine</em> <code>asyncio.sleep</code>(<em>delay</em>, <em>result=None</em>, <em>**, </em>loop=None*)</p>
<p>阻塞 <em>delay</em> 指定的秒数。</p>
<p>如果指定了 <em>result</em>，则当协程完成时将其返回给调用者。</p>
<p><code>sleep()</code> 总是会挂起当前任务，以允许其他任务运行。</p>
<p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p>
<p>以下协程示例运行 5 秒，每秒显示一次当前日期:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">display_date</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    end_time = loop.time() + <span class="number">5.0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(datetime.datetime.now())</span><br><span class="line">        <span class="keyword">if</span> (loop.time() + <span class="number">1.0</span>) &gt;= end_time:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(display_date())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="并发运行任务"><a href="#并发运行任务" class="headerlink" title="并发运行任务"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id7" target="_blank" rel="noopener">并发运行任务</a></h2><ul>
<li><p><em>awaitable</em> <code>asyncio.gather</code>(*<em>aws</em>, <em>loop=None</em>, <em>return_exceptions=False</em>) </p>
<p><em>并发</em> 运行 <em>aws</em> 序列中的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a>。</p>
<p>如果 <em>aws</em> 中的某个可等待对象为协程，它将自动作为一个任务加入日程。</p>
<p>如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而成的列表。结果值的顺序与 <em>aws</em> 中可等待对象的顺序一致。</p>
<p>如果 <em>return_exceptions</em> 为 <code>False</code> (默认)，所引发的首个异常会立即传播给等待 <code>gather()</code> 的任务。<em>aws</em> 序列中的其他可等待对象 <strong>不会被取消</strong> 并将继续运行。</p>
<p>如果 <em>return_exceptions</em> 为 <code>True</code>，异常会和成功的结果一样处理，并聚合至结果列表。</p>
<p>如果 <code>gather()</code> <em>被取消</em>，所有被提交 (尚未完成) 的可等待对象也会 <em>被取消</em>。</p>
<p>如果 <em>aws</em> 序列中的任一 Task 或 Future 对象 <em>被取消</em>，它将被当作引发了 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 一样处理 – 在此情况下 <code>gather()</code> 调用 <strong>不会</strong> 被取消。这是为了防止一个已提交的 Task/Future 被取消导致其他 Tasks/Future 也被取消。</p>
<p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(name, number)</span>:</span></span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: Compute factorial(<span class="subst">&#123;i&#125;</span>)..."</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        f *= i</span><br><span class="line">    print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: factorial(<span class="subst">&#123;number&#125;</span>) = <span class="subst">&#123;f&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        factorial(<span class="string">"A"</span>, <span class="number">2</span>),</span><br><span class="line">        factorial(<span class="string">"B"</span>, <span class="number">3</span>),</span><br><span class="line">        factorial(<span class="string">"C"</span>, <span class="number">4</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     Task A: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task A: factorial(2) = 2</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(3)...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(3)...</span></span><br><span class="line"><span class="comment">#     Task B: factorial(3) = 6</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(4)...</span></span><br><span class="line"><span class="comment">#     Task C: factorial(4) = 24</span></span><br></pre></td></tr></table></figure>
<p><em>在 3.7 版更改:</em> 如果 <em>gather</em> 本身被取消，则无论 <em>return_exceptions</em> 取值为何，消息都会被传播。</p>
</li>
</ul>
<h2 id="屏蔽取消操作"><a href="#屏蔽取消操作" class="headerlink" title="屏蔽取消操作"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id8" target="_blank" rel="noopener">屏蔽取消操作</a></h2><ul>
<li><p><em>awaitable</em> <code>asyncio.shield</code>(<em>aw</em>, <em>**, </em>loop=None*) </p>
<p>保护一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a> 防止其被 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>取消</code></a>。</p>
<p>如果 <em>aw</em> 是一个协程，它将自动作为任务加入日程。</p>
<p>以下语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res = await shield(something())</span><br></pre></td></tr></table></figure>
<p>相当于:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res = await something()</span><br></pre></td></tr></table></figure>
<p><em>不同之处</em> 在于如果包含它的协程被取消，在 <code>something()</code> 中运行的任务不会被取消。从 <code>something()</code> 的角度看来，取消操作并没有发生。然而其调用者已被取消，因此 “await” 表达式仍然会引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a>。</p>
<p>如果通过其他方式取消 <code>something()</code> (例如在其内部操作) 则 <code>shield()</code> 也会取消。</p>
<p>如果希望完全忽略取消操作 (不推荐) 则 <code>shield()</code> 函数需要配合一个 try/except 代码段，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    res = await shield(something())</span><br><span class="line">except CancelledError:</span><br><span class="line">    res = None</span><br></pre></td></tr></table></figure>
<p>从 3.8版本加入，将于 3.10版本移除<em>loop</em> 形参。</p>
</li>
</ul>
<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id9" target="_blank" rel="noopener">超时</a></h2><ul>
<li><p><em>coroutine</em> <code>asyncio.wait_for</code>(<em>aw</em>, <em>timeout</em>, <em>**, </em>loop=None*) </p>
<p>等待 <em>aw</em> <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a> 完成，指定 timeout 秒数后超时。</p>
<p>如果 <em>aw</em> 是一个协程，它将自动作为任务加入日程。</p>
<p><em>timeout</em> 可以为 <code>None</code>，也可以为 float 或 int 型数值表示的等待秒数。如果 <em>timeout</em> 为 <code>None</code>，则等待直到完成。</p>
<p>如果发生超时，任务将取消并引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>.</p>
<p>要避免任务 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>取消</code></a>，可以加上 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.shield" target="_blank" rel="noopener"><code>shield()</code></a>。</p>
<p>函数将等待直到目标对象确实被取消，所以总等待时间可能超过 <em>timeout</em> 指定的秒数。</p>
<p>如果等待被取消，则 <em>aw</em> 指定的对象也会被取消。</p>
<p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">eternity</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Sleep for one hour</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    print(<span class="string">'yay!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Wait for at most 1 second</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait_for(eternity(), timeout=<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">        print(<span class="string">'timeout!'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     timeout!</span></span><br></pre></td></tr></table></figure>
<p><em>在 3.7 版更改:</em> 当 <em>aw</em> 因超时被取消，<code>wait_for</code> 会等待 <em>aw</em> 被取消。之前版本则将立即引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>。</p>
</li>
</ul>
<h2 id="简单等待"><a href="#简单等待" class="headerlink" title="简单等待"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id10" target="_blank" rel="noopener">简单等待</a></h2><ul>
<li><p><em>coroutine</em> <code>asyncio.wait</code>(<em>aws</em>, <em>**, </em>loop=None<em>, </em>timeout=None<em>, </em>return_when=ALL_COMPLETED*) </p>
<p>并发运行 <em>aws</em> 指定的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a> 并阻塞线程直到满足 <em>return_when</em> 指定的条件。</p>
<p>返回两个 Task/Future 集合: <code>(done, pending)</code>。</p>
<p>用法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">done, pending = await asyncio.wait(aws)</span><br></pre></td></tr></table></figure>
<p>如指定 <em>timeout</em> (float 或 int 类型) 则它将被用于控制返回之前等待的最长秒数。</p>
<p>请注意此函数不会引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>。当超时发生时，未完成的 Future 或 Task 将在指定秒数后被返回。</p>
<p><em>return_when</em> 指定此函数应在何时返回。它必须为以下常数之一:</p>
<p>| 常数              | 描述                                                         |<br>| :—————- | :———————————————————– |<br>| <code>FIRST_COMPLETED</code> | 函数将在任意可等待对象结束或取消时返回。                     |<br>| <code>FIRST_EXCEPTION</code> | 函数将在任意可等待对象因引发异常而结束时返回。当没有引发任何异常时它就相当于 <code>ALL_COMPLETED</code>。 |<br>| <code>ALL_COMPLETED</code>   | 函数将在所有可等待对象结束或取消时返回。                     |</p>
<p>与 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.wait_for" target="_blank" rel="noopener"><code>wait_for()</code></a> 不同，<code>wait()</code> 在超时发生时不会取消可等待对象。</p>
<p><em>3.8 版后已移除:</em> 如果 <em>aws</em> 中的某个可等待对象为协程，它将自动作为任务加入日程。直接向 <code>wait()</code> 传入协程对象已弃用，因为这会导致 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-example-wait-coroutine" target="_blank" rel="noopener">令人迷惑的行为</a>。</p>
<p>从 3.8版本加入，将于 3.10版本移除<em>loop</em> 形参。</p>
<blockquote>
<p>注解</p>
<p><code>wait()</code> 会自动将协程作为任务加入日程，以后将以 <code>(done, pending)</code> 集合形式返回显式创建的任务对象。因此以下代码并不会有预期的行为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; coro = foo()</span><br><span class="line">&gt; done, pending = <span class="keyword">await</span> asyncio.wait(&#123;coro&#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">if</span> coro <span class="keyword">in</span> done:</span><br><span class="line">&gt;     <span class="comment"># This branch will never be run!</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>以上代码段的修正方法如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; task = asyncio.create_task(foo())</span><br><span class="line">&gt; done, pending = <span class="keyword">await</span> asyncio.wait(&#123;task&#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">if</span> task <span class="keyword">in</span> done:</span><br><span class="line">&gt;     <span class="comment"># Everything will work as expected now.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>​     <em>3.8 版后已移除:</em> 直接向 <code>wait()</code> 传入协程对象的方式已弃用。 </p>
<ul>
<li><p><code>asyncio.as_completed</code>(<em>aws</em>, <em>**, </em>loop=None<em>, </em>timeout=None*) </p>
<p>并发地运行 <em>aws</em> 集合中的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a>。返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future</code></a> 对象的迭代器。返回的每个 Future 对象代表来自剩余可等待对象集合的最早结果。</p>
<p>如果在所有 Future 对象完成前发生超时则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>。</p>
<p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> as_completed(aws):</span><br><span class="line">    earliest_result = <span class="keyword">await</span> f</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="来自其他线程的日程安排"><a href="#来自其他线程的日程安排" class="headerlink" title="来自其他线程的日程安排"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id11" target="_blank" rel="noopener">来自其他线程的日程安排</a></h2><ul>
<li><p><code>asyncio.run_coroutine_threadsafe</code>(<em>coro</em>, <em>loop</em>)</p>
<p>向指定事件循环提交一个协程。线程安全。</p>
<p>返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>concurrent.futures.Future</code></a> 以等待来自其他 OS 线程的结果。</p>
<p>此函数应该从另一个 OS 线程中调用，而非事件循环运行所在线程。示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Create a coroutine</span><br><span class="line">coro = asyncio.sleep(1, result=3)</span><br><span class="line"></span><br><span class="line"># Submit the coroutine to a given loop</span><br><span class="line">future = asyncio.run_coroutine_threadsafe(coro, loop)</span><br><span class="line"></span><br><span class="line"># Wait for the result with an optional timeout argument</span><br><span class="line">assert future.result(timeout) == 3</span><br></pre></td></tr></table></figure>
<p>如果在协程内产生了异常，将会通知返回的 Future 对象。它也可被用来取消事件循环中的任务:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    result = future.result(timeout)</span><br><span class="line">except asyncio.TimeoutError:</span><br><span class="line">    print(&apos;The coroutine took too long, cancelling the task...&apos;)</span><br><span class="line">    future.cancel()</span><br><span class="line">except Exception as exc:</span><br><span class="line">    print(f&apos;The coroutine raised an exception: &#123;exc!r&#125;&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(f&apos;The coroutine returned: &#123;result!r&#125;&apos;)</span><br></pre></td></tr></table></figure>
<p>查看 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-dev.html#asyncio-multithreading" target="_blank" rel="noopener">并发和多线程</a> 章节的文档。</p>
<p>不同与其他 asyncio 函数，此函数要求显式地传入 <em>loop</em> 参数。</p>
<p><em>3.5.1 新版功能.</em></p>
</li>
</ul>
<h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id12" target="_blank" rel="noopener">内省</a></h2><ul>
<li><p><code>asyncio.current_task</code>(<em>loop=None</em>)</p>
<p>返回当前运行的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 实例，如果没有正在运行的任务则返回 <code>None</code>。如果 <em>loop</em> 为 <code>None</code> 则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener"><code>get_running_loop()</code></a> 获取当前事件循环。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>asyncio.all_tasks</code>(<em>loop=None</em>)</p>
<p>返回事件循环所运行的未完成的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 对象的集合。如果 <em>loop</em> 为 <code>None</code>，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener"><code>get_running_loop()</code></a> 获取当前事件循环。<em>3.7 新版功能.</em></p>
</li>
</ul>
<h2 id="Task-对象"><a href="#Task-对象" class="headerlink" title="Task 对象"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id13" target="_blank" rel="noopener">Task 对象</a></h2><ul>
<li><p><em>class</em> <code>asyncio.Task</code>(<em>coro</em>, <em>**, </em>loop=None<em>, </em>name=None*)</p>
<p>一个与 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future 类似</code></a> 的对象，可运行 Python <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程</a>。非线程安全。</p>
<p>Task 对象被用来在事件循环中运行协程。如果一个协程在等待一个 Future 对象，Task 对象会挂起该协程的执行并等待该 Future 对象完成。当该 Future 对象 <em>完成</em>，被打包的协程将恢复执行。</p>
<p>事件循环使用协同日程调度: 一个事件循环每次运行一个 Task 对象。而一个 Task 对象会等待一个 Future 对象完成，该事件循环会运行其他 Task、回调或执行 IO 操作。</p>
<p>使用高层级的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>asyncio.create_task()</code></a> 函数来创建 Task 对象，也可用低层级的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.loop.create_task" target="_blank" rel="noopener"><code>loop.create_task()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.ensure_future" target="_blank" rel="noopener"><code>ensure_future()</code></a> 函数。不建议手动实例化 Task 对象。</p>
<p>要取消一个正在运行的 Task 对象可使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>cancel()</code></a> 方法。调用此方法将使该 Task 对象抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常给打包的协程。如果取消期间一个协程正在等待一个 Future 对象，该 Future 对象也将被取消。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancelled" target="_blank" rel="noopener"><code>cancelled()</code></a> 可被用来检测 Task 对象是否被取消。如果打包的协程没有抑制 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常并且确实被取消，该方法将返回 <code>True</code>。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>asyncio.Task</code></a> 从 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future</code></a> 继承了其除 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_result" target="_blank" rel="noopener"><code>Future.set_result()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_exception" target="_blank" rel="noopener"><code>Future.set_exception()</code></a> 以外的所有 API。</p>
<p>Task 对象支持 <a href="https://docs.python.org/zh-cn/3.8/library/contextvars.html#module-contextvars" target="_blank" rel="noopener"><code>contextvars</code></a> 模块。当一个 Task 对象被创建，它将复制当前上下文，然后在复制的上下文中运行其协程。</p>
<p><em>在 3.7 版更改:</em> 加入对 <a href="https://docs.python.org/zh-cn/3.8/library/contextvars.html#module-contextvars" target="_blank" rel="noopener"><code>contextvars</code></a> 模块的支持。</p>
<p><em>在 3.8 版更改:</em> Added the <code>name</code> parameter.</p>
<p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p>
<ul>
<li><p><code>cancel</code>()</p>
<p>请求取消 Task 对象。这将安排在下一轮事件循环中抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常给被封包的协程。协程在之后有机会进行清理甚至使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> … … <code>except CancelledError</code> … <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 代码块抑制异常来拒绝请求。不同于 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.cancel" target="_blank" rel="noopener"><code>Future.cancel()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>Task.cancel()</code></a> 不保证 Task 会被取消，虽然抑制完全取消并不常见，也很不鼓励这样做。以下示例演示了协程是如何侦听取消请求的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel_me</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'cancel_me(): before sleep'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Wait for 1 hour</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        print(<span class="string">'cancel_me(): cancel sleep'</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'cancel_me(): after sleep'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Create a "cancel_me" Task</span></span><br><span class="line">    task = asyncio.create_task(cancel_me())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait for 1 second</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    task.cancel()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        print(<span class="string">"main(): cancel_me is cancelled now"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     cancel_me(): before sleep</span></span><br><span class="line"><span class="comment">#     cancel_me(): cancel sleep</span></span><br><span class="line"><span class="comment">#     cancel_me(): after sleep</span></span><br><span class="line"><span class="comment">#     main(): cancel_me is cancelled now</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>cancelled</code>()</p>
<p>如果 Task 对象 <em>被取消</em> 则返回 <code>True</code>。当使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>cancel()</code></a> 发出取消请求时 Task 会被 <em>取消</em>，其封包的协程将传播被抛入的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。</p>
</li>
<li><p><code>done</code>()</p>
<p>如果 Task 对象 <em>已完成</em> 则返回 <code>True</code>。当 Task 所封包的协程返回一个值、引发一个异常或 Task 本身被取消时，则会被认为 <em>已完成</em>。</p>
</li>
<li><p><code>result</code>()</p>
<p>返回 Task 的结果。如果 Task 对象 <em>已完成</em>，其封包的协程的结果会被返回 (或者当协程引发异常时，该异常会被重新引发。)如果 Task 对象 <em>被取消</em>，此方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。如果 Task 对象的结果还不可用，此方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 异常。</p>
</li>
<li><p><code>exception</code>()</p>
<p>返回 Task 对象的异常。如果所封包的协程引发了一个异常，该异常将被返回。如果所封包的协程正常返回则该方法将返回 <code>None</code>。如果 Task 对象 <em>被取消</em>，此方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。如果 Task 对象尚未 <em>完成</em>，此方法将引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 异常。</p>
</li>
<li><p><code>add_done_callback</code>(<em>callback</em>, <em>**, </em>context=None*)</p>
<p>添加一个回调，将在 Task 对象 <em>完成</em> 时被运行。此方法应该仅在低层级的基于回调的代码中使用。要了解更多细节请查看 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.add_done_callback" target="_blank" rel="noopener"><code>Future.add_done_callback()</code></a> 的文档。</p>
</li>
<li><p><code>remove_done_callback</code>(<em>callback</em>)</p>
<p>从回调列表中移除 <em>callback</em> 指定的回调。此方法应该仅在低层级的基于回调的代码中使用。要了解更多细节请查看 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.remove_done_callback" target="_blank" rel="noopener"><code>Future.remove_done_callback()</code></a> 的文档。</p>
</li>
<li><p><code>get_stack</code>(<em>**, </em>limit=None*)</p>
<p>返回此 Task 对象的栈框架列表。如果所封包的协程未完成，这将返回其挂起所在的栈。如果协程已成功完成或被取消，这将返回一个空列表。如果协程被一个异常终止，这将返回回溯框架列表。框架总是从按从旧到新排序。每个被挂起的协程只返回一个栈框架。可选的 <em>limit</em> 参数指定返回框架的数量上限；默认返回所有框架。返回列表的顺序要看是返回一个栈还是一个回溯：栈返回最新的框架，回溯返回最旧的框架。(这与 traceback 模块的行为保持一致。)</p>
</li>
<li><p><code>print_stack</code>(<em>**, </em>limit=None<em>, </em>file=None*)</p>
<p>打印此 Task 对象的栈或回溯。此方法产生的输出类似于 traceback 模块通过 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.get_stack" target="_blank" rel="noopener"><code>get_stack()</code></a> 所获取的框架。<em>limit</em> 参数会直接传递给 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.get_stack" target="_blank" rel="noopener"><code>get_stack()</code></a>。<em>file</em> 参数是输出所写入的 I/O 流；默认情况下输出会写入 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stderr" target="_blank" rel="noopener"><code>sys.stderr</code></a>。</p>
</li>
<li><p><code>get_coro</code>()</p>
<p>返回绑定到 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a>.的协程对象。<em>3.8 新版功能.</em></p>
</li>
<li><p><code>get_name</code>()</p>
<p>返回Task 名字。如果没有显式分配给Task一个名字,则默认的异步Task将分配给默认的生成的名字。<em>3.8 新版功能.</em></p>
</li>
<li><p><code>set_name</code>(<em>value</em>)</p>
<p>设置Task名字。参数值可以是任意数据类型,都将被转换成字符串。默认的Task实现，可以通过在task对象中实现 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a>函数显式输出。<em>3.8 新版功能.</em></p>
</li>
<li><p><em>classmethod</em> <code>all_tasks</code>(<em>loop=None</em>)</p>
<p>返回一个事件循环中所有任务的集合。默认情况下将返回当前事件循环中所有任务。如果 <em>loop</em> 为 <code>None</code>，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_event_loop" target="_blank" rel="noopener"><code>get_event_loop()</code></a> 函数来获取当前事件循环。从3.7版本就被废弃,3.9版本将会被移除。尽量不要作为一个task方法来使用,建议使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.all_tasks" target="_blank" rel="noopener"><code>asyncio.all_tasks()</code></a> 代替。</p>
</li>
<li><p><em>classmethod</em> <code>current_task</code>(<em>loop=None</em>)</p>
<p>返回当前运行任务或 <code>None</code>。如果 <em>loop</em> 为 <code>None</code>，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_event_loop" target="_blank" rel="noopener"><code>get_event_loop()</code></a> 函数来获取当前事件循环。</p>
<p>从3.7版本就被废弃,3.9版本将会被移除。尽量不要作为一个task方法来使用,建议使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.current_task" target="_blank" rel="noopener"><code>asyncio.current_task()</code></a> 代替。</p>
</li>
</ul>
<h2 id="基于生成器的协程"><a href="#基于生成器的协程" class="headerlink" title="基于生成器的协程"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id14" target="_blank" rel="noopener">基于生成器的协程</a></h2><blockquote>
<p>对基于生成器的协程的支持 <strong>已弃用</strong> 并计划在 Python 3.10 中移除。</p>
</blockquote>
<p>基于生成器的协程是 async/await 语法的前身。它们是使用 <code>yield from</code> 语句创建的 Python 生成器，可以等待 Future 和其他协程。</p>
<p>基于生成器的协程应该使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.coroutine" target="_blank" rel="noopener"><code>@asyncio.coroutine</code></a> 装饰，虽然这并非强制。</p>
<ul>
<li><p><a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a>`</p>
<p>用来标记基于生成器的协程的装饰器。此装饰器使得旧式的基于生成器的协程能与 async/await 代码相兼容:</p>
<p>此装饰器使得旧式的基于生成器的协程能与 async/await 代码相兼容:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">old_style_coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> old_style_coroutine()</span><br></pre></td></tr></table></figure>
<p>此装饰器不应该被用于 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 协程。</p>
<p> 从3.8版本被废弃, 将于3.10版本移除:* 使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 代替。</p>
</li>
<li><p><code>asyncio.iscoroutine</code>(<em>obj</em>)</p>
<p>如果 <em>obj</em> 是一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程对象</a> 则返回 <code>True</code>。此方法不同于 <a href="https://docs.python.org/zh-cn/3.8/library/inspect.html#inspect.iscoroutine" target="_blank" rel="noopener"><code>inspect.iscoroutine()</code></a> 因为它对基于生成器的协程返回 <code>True</code>。</p>
</li>
<li><p><code>asyncio.iscoroutinefunction</code>(<em>func</em>)</p>
<p>如果 <em>func</em> 是一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程函数</a> 则返回 <code>True</code>。此方法不同于 <a href="https://docs.python.org/zh-cn/3.8/library/inspect.html#inspect.iscoroutinefunction" target="_blank" rel="noopener"><code>inspect.iscoroutinefunction()</code></a> 因为它对以 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.coroutine" target="_blank" rel="noopener"><code>@coroutine</code></a> 装饰的基于生成器的协程函数返回 <code>True</code>。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>转自 <a href="https://www.zhihu.com/question/35139020" target="_blank" rel="noopener">python协程</a></p>
<p>作者：侠三十六</p>
<p><strong>协程</strong></p>
<p>首先要明确，线程和进程都是系统帮咱们开辟的，不管是thread还是process他内部都是调用的系统的API,而对于协程来说它和系统毫无关系;</p>
<p>协程不同于线程的是，线程是抢占式的调度，而协程是协同式的调度，也就是说，协程需要自己做调度。</p>
<p>他就和程序员有关系，对于线程和进程来说，调度是由CPU来决定调度的;</p>
<p>对于协程来说，程序员就是上帝，你想让谁执行到哪里他就执行到哪里;</p>
<p>协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。</p>
<p><strong>适用场景：</strong>其实在其他语言中，协程的其实是意义不大的多线程即可已解决I/O的问题，但是在python因为他有GIL（Global Interpreter Lock 全局解释器锁 ）在同一时间只有一个线程在工作，所以：如果一个线程里面I/O操作特别多，协程就比较适用;</p>
<p>协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程。</p>
<p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：</p>
<p>协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</p>
<p><strong>协程的好处：</strong></p>
<p>无需线程上下文切换的开销</p>
<p>无需原子操作锁定及同步的开销</p>
<p>方便切换控制流，简化编程模型</p>
<p>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</p>
<p><strong>缺点：</strong></p>
<p>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</p>
<p>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>coroutines</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library os.path</title>
    <url>/2020/02/15/python-standard-library-os-path/</url>
    <content><![CDATA[<h1 id="python-标准库-os-path"><a href="#python-标准库-os-path" class="headerlink" title="python 标准库 os.path"></a>python 标准库 os.path</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200215_nixingzhe.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>每日一词</p>
<p> retrograde  [ˈrɛtrəɡreɪd] </p>
<p>v   directed or moving backwards. </p>
<p>n retrograder 逆行者</p>
<ol>
<li><p>倒行；不按正常方向行进。《孟子·滕文公下》：“当 尧 之时，水<a href="https://cidian.911cha.com/MjA1MXc=.html" target="_blank" rel="noopener">逆行</a>，氾滥於中国。”《史记·孝景本纪》：“彗星出东北。秋， 衡山 雨雹，大者五寸，深者二尺。荧惑<a href="https://cidian.911cha.com/MjA1MXc=.html" target="_blank" rel="noopener">逆行</a>，守北辰。”《后汉书·杨震传》：“ 丰 等闻，惶怖，会太史言星变<a href="https://cidian.911cha.com/MjA1MXc=.html" target="_blank" rel="noopener">逆行</a>，遂共譖 震 。”</p>
</li>
<li><p>指逆流而行。 </p>
</li>
</ol>
</blockquote>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/posixpath.py" target="_blank" rel="noopener">Lib/posixpath.py</a> （用于 POSIX）和 <a href="https://github.com/python/cpython/tree/3.8/Lib/ntpath.py" target="_blank" rel="noopener">Lib/ntpath.py</a> （用于 Windows NT）</p>
<hr>
<p>该模块在路径名上实现了一些有用的功能：如需读取或写入文件，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> ；有关访问文件系统的信息，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块。路径参数可以字符串或字节形式传递。我们鼓励应用程序将文件名表示为（Unicode）字符串。不幸的是，某些文件名在Unix上可能无法用字符串表示，因此在Unix上平台上需要支持任意文件名的应用程序，应使用字节对象来表示路径名。反之亦然，在Windows平台上仅使用字节对象，不能表示的所有文件名（以标准 <code>mbcs</code> 编码），因此Windows应用程序应使用字符串对象来访问所有文件。</p>
<p>与unix shell不同，Python不执行任何 <em>自动</em> 路径扩展。当应用程序需要类似shell的路径扩展时，可以显式调用诸如 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.expanduser" target="_blank" rel="noopener"><code>expanduser()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.expandvars" target="_blank" rel="noopener"><code>expandvars()</code></a> 之类的函数。 （另请参见 <a href="https://docs.python.org/zh-cn/3.8/library/glob.html#module-glob" target="_blank" rel="noopener"><code>glob</code></a> 模块。）</p>
<blockquote>
<p>参见 <a href="https://docs.python.org/zh-cn/3.8/library/pathlib.html#module-pathlib" target="_blank" rel="noopener"><code>pathlib</code></a> 模块提供高级路径对象。</p>
</blockquote>
<blockquote>
<p>所有这些函数都仅接受字节或字符串对象作为其参数。如果返回路径或文件名，则结果是相同类型的对象。</p>
</blockquote>
<blockquote>
<p>由于不同的操作系统具有不同的路径名称约定，因此标准库中有此模块的几个版本。<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 模块始终是适合 Python 运行的操作系统的路径模块，因此可用于本地路径。但是，如果操作的路径 <em>总是</em> 以一种不同的格式显示，那么也可以分别导入和使用各个模块。它们都具有相同的接口：</p>
<ul>
<li><code>posixpath</code> 用于Unix 样式的路径</li>
<li><code>ntpath</code> 用于 Windows 路径</li>
</ul>
</blockquote>
<p><em>在 3.8 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>exists()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.lexists" target="_blank" rel="noopener"><code>lexists()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isdir" target="_blank" rel="noopener"><code>isdir()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isfile" target="_blank" rel="noopener"><code>isfile()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>islink()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.ismount" target="_blank" rel="noopener"><code>ismount()</code></a> 现在遇到系统层面上不可表示的字符或字节的路径时，会返回 <code>False</code>，而不是抛出异常。</p>
<ul>
<li><p><code>os.path.abspath</code>(<em>path</em>)</p>
<p>返回路径 <em>path</em> 的绝对路径（标准化的）。在大多数平台上，这等同于用 <code>normpath(join(os.getcwd(), path))</code> 的方式调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.normpath" target="_blank" rel="noopener"><code>normpath()</code></a> 函数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.basename</code>(<em>path</em>)</p>
<p>返回路径 <em>path</em> 的基本名称。这是将 <em>path</em> 传入函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.split" target="_blank" rel="noopener"><code>split()</code></a> 之后，返回的一对值中的第二个元素。请注意，此函数的结果与Unix <strong>basename</strong> 程序不同。<strong>basename</strong> 在 <code>&#39;/foo/bar/&#39;</code> 上返回 <code>&#39;bar&#39;</code>，而 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.basename" target="_blank" rel="noopener"><code>basename()</code></a> 函数返回一个空字符串 (<code>&#39;&#39;</code>)。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.commonpath</code>(<em>paths</em>)</p>
<p>接受包含多个路径的序列 <em>paths</em>，返回 <em>paths</em> 的最长公共子路径。如果 <em>paths</em> 同时包含绝对路径和相对路径，或 <em>paths</em> 在不同的驱动器上，或 <em>paths</em> 为空，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。与 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.commonprefix" target="_blank" rel="noopener"><code>commonprefix()</code></a> 不同，本方法返回有效路径。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>3.5 新版功能.**在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 序列。</p>
</li>
<li><p><code>os.path.commonprefix</code>(<em>list</em>)</p>
<p>接受包含多个路径的 <em>列表</em>，返回所有路径的最长公共前缀（逐字符比较）。如果 <em>列表</em> 为空，则返回空字符串 (<code>&#39;&#39;</code>)。</p>
<p>此函数是逐字符比较，因此可能返回无效路径。要获取有效路径，参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.commonpath" target="_blank" rel="noopener"><code>commonpath()</code></a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.commonprefix([<span class="string">'/usr/lib'</span>, <span class="string">'/usr/local/lib'</span>])</span><br><span class="line"><span class="string">'/usr/l'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.commonpath([<span class="string">'/usr/lib'</span>, <span class="string">'/usr/local/lib'</span>])</span><br><span class="line"><span class="string">'/usr'</span></span><br></pre></td></tr></table></figure>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.dirname</code>(<em>path</em>)</p>
<p>返回路径 <em>path</em> 的目录名称。这是将 <em>path</em> 传入函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.split" target="_blank" rel="noopener"><code>split()</code></a> 之后，返回的一对值中的第一个元素。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.exists</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 指向一个已存在的路径或已打开的文件描述符，返回 <code>True</code>。对于失效的符号链接，返回 <code>False</code>。在某些平台上，如果使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 查询到目标文件没有执行权限，即使 <em>path</em> 确实存在，本函数也可能返回 <code>False</code>。<em>在 3.3 版更改:</em> <em>path</em> 现在可以是一个整数：如果该整数是一个已打开的文件描述符，返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.lexists</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 指向一个已存在的路径，返回 <code>True</code>。对于失效的符号链接，也返回 <code>True</code>。在缺失 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>os.lstat()</code></a> 的平台上等同于 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>exists()</code></a>。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.expanduser</code>(<em>path</em>)</p>
<p>在 Unix 和 Windows 上，将参数中开头部分的 <code>~</code> 或 <code>~user</code> 替换为当前 <em>用户</em> 的家目录并返回。在 Unix 上，开头的 <code>~</code> 会被环境变量 <code>HOME</code> 代替，如果变量未设置，则通过内置模块 <a href="https://docs.python.org/zh-cn/3.8/library/pwd.html#module-pwd" target="_blank" rel="noopener"><code>pwd</code></a> 在 password 目录中查找当前用户的主目录。以 <code>~user</code> 开头则直接在 password 目录中查找。在 Windows 上，如果设置了 <code>USERPROFILE</code>，就使用这个变量，否则会将 <code>HOMEPATH</code> 和 <code>HOMEDRIVE</code> 结合在一起使用。以 <code>~user</code> 开头则将上述方法生成路径的最后一截目录替换成 user。如果展开路径失败，或者路径不是以波浪号开头，则路径将保持不变。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
<p><em>在 3.8 版更改:</em> Windows 不再使用 <code>HOME</code>。</p>
</li>
<li><p><code>os.path.expandvars</code>(<em>path</em>)</p>
<p>输入带有环境变量的路径作为参数，返回展开变量以后的路径。<code>$name</code> 或 <code>${name}</code> 形式的子字符串被环境变量 <em>name</em> 的值替换。格式错误的变量名称和对不存在变量的引用保持不变。在 Windows 上，除了 <code>$name</code> 和 <code>${name}</code> 外，还可以展开 <code>%name%</code>。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.getatime</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 的最后访问时间。返回值是一个浮点数，为纪元秒数（参见 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块）。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p>
</li>
<li><p><code>os.path.getmtime</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 的最后修改时间。返回值是一个浮点数，为纪元秒数（参见 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块）。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.getctime</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 在系统中的 ctime，在有些系统（比如 Unix）上，它是元数据的最后修改时间，其他系统（比如 Windows）上，它是 <em>path</em> 的创建时间。返回值是一个数，为纪元秒数（参见 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块）。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.getsize</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 的大小，以字节为单位。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.isabs</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 是一个绝对路径，则返回 <code>True</code>。在 Unix 上，它就是以斜杠开头，而在 Windows 上，它可以是去掉驱动器号后以斜杠（或反斜杠）开头。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.isfile</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>现有的</code></a> 常规文件，则返回 <code>True</code>。本方法会跟踪符号链接，因此，对于同一路径，<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>islink()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isfile" target="_blank" rel="noopener"><code>isfile()</code></a> 都可能为 <code>True</code>。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.isdir</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>现有的</code></a> 目录，则返回 <code>True</code>。本方法会跟踪符号链接，因此，对于同一路径，<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>islink()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isdir" target="_blank" rel="noopener"><code>isdir()</code></a> 都可能为 <code>True</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.islink</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 指向的 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>现有</code></a> 目录条目是一个符号链接，则返回 <code>True</code>。如果 Python 运行时不支持符号链接，则总是返回 <code>False</code>。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.ismount</code>(<em>path</em>)</p>
<p>如果路径 <em>path</em> 是 <em>挂载点</em> （文件系统中挂载其他文件系统的点），则返回 <code>True</code>。在 POSIX 上，该函数检查 <em>path</em> 的父目录 <code>*path*/..</code> 是否在与 <em>path</em> 不同的设备上，或者 <code>*path*/..</code> 和 <em>path</em> 是否指向同一设备上的同一 inode（这一检测挂载点的方法适用于所有 Unix 和 POSIX 变体）。本方法不能可靠地检测同一文件系统上的绑定挂载 (bind mount)。在 Windows 上，盘符和共享 UNC 始终是挂载点，对于任何其他路径，将调用 <code>GetVolumePathName</code> 来查看它是否与输入的路径不同。<em>3.4 新版功能:</em> 支持在 Windows 上检测非根挂载点。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.join</code>(<em>path</em>, *<em>paths</em>)</p>
<p>合理地拼接一个或多个路径部分。返回值是 <em>path</em> 和 *<em>paths</em> 所有值的连接，每个非空部分后面都紧跟一个目录分隔符 (<code>os.sep</code>)，除了最后一部分。这意味着如果最后一部分为空，则结果将以分隔符结尾。如果参数中某个部分是绝对路径，则绝对路径前的路径都将被丢弃，并从绝对路径部分开始连接。在 Windows 上，遇到绝对路径部分（例如 <code>r&#39;\foo&#39;</code>）时，不会重置盘符。如果某部分路径包含盘符，则会丢弃所有先前的部分，并重置盘符。请注意，由于每个驱动器都有一个“当前目录”，所以 <code>os.path.join(&quot;c:&quot;, &quot;foo&quot;)</code> 表示驱动器 <code>C:</code> 上当前目录的相对路径 (<code>c:foo</code>)，而不是 <code>c:\foo</code>。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 用于 <em>path</em> 和 <em>paths</em> 。</p>
</li>
<li><p><code>os.path.normcase</code>(<em>path</em>)</p>
<p>规范路径的大小写。在 Windows 上，将路径中的所有字符都转换为小写，并将正斜杠转换为反斜杠。在其他操作系统上返回原路径。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.normpath</code>(<em>path</em>)</p>
<p>通过折叠多余的分隔符和对上级目录的引用来标准化路径名，所以 <code>A//B</code>、<code>A/B/</code>、<code>A/./B</code> 和 <code>A/foo/../B</code> 都会转换成 <code>A/B</code>。这个字符串操作可能会改变带有符号链接的路径的含义。在 Windows 上，本方法将正斜杠转换为反斜杠。要规范大小写，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.normcase" target="_blank" rel="noopener"><code>normcase()</code></a>。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.realpath</code>(<em>path</em>)</p>
<p>返回指定文件的规范路径，消除路径中存在的任何符号链接（如果操作系统支持）。注解 当发生符号链接循环时，返回的路径将是该循环的某个组成部分，但不能保证是哪个部分。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
<p><em>在 3.8 版更改:</em> 在 Windows 上现在可以正确解析符号链接和交接点 (junction point)。</p>
</li>
<li><p><code>os.path.relpath</code>(<em>path</em>, <em>start=os.curdir</em>)</p>
<p>返回从当前目录或 <em>start</em> 目录（可选）到达 <em>path</em> 之间要经过的相对路径。这仅仅是对路径的计算，不会访问文件系统来确认 <em>path</em> 或 <em>start</em> 的存在性或属性。<em>start</em> 默认为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.samefile</code>(<em>path1</em>, <em>path2</em>)</p>
<p>如果两个路径都指向相同的文件或目录，则返回 <code>True</code>。这由设备号和 inode 号确定，在任一路径上调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 失败则抛出异常。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加了 Windows 支持。<em>在 3.4 版更改:</em> Windows现在使用与其他所有平台相同的实现。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.sameopenfile</code>(<em>fp1</em>, <em>fp2</em>)</p>
<p>如果文件描述符 <em>fp1</em> 和 <em>fp2</em> 指向相同文件，则返回 <code>True</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加了 Windows 支持。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.samestat</code>(<em>stat1</em>, <em>stat2</em>)</p>
<p>如果 stat 元组 <em>stat1</em> 和 <em>stat2</em> 指向相同文件，则返回 <code>True</code>。这些 stat 元组可能是由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fstat" target="_blank" rel="noopener"><code>os.fstat()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>os.lstat()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 返回的。本函数实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.samefile" target="_blank" rel="noopener"><code>samefile()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.sameopenfile" target="_blank" rel="noopener"><code>sameopenfile()</code></a> 底层所使用的比较过程。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.4 版更改:</em> 添加了 Windows 支持。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.split</code>(<em>path</em>)</p>
<p>将路径 <em>path</em> 拆分为一对，即 <code>(head, tail)</code>，其中，<em>tail</em> 是路径的最后一部分，而 <em>head</em> 里是除最后部分外的所有内容。<em>tail</em> 部分不会包含斜杠，如果 <em>path</em> 以斜杠结尾，则 <em>tail</em> 将为空。如果 <em>path</em> 中没有斜杠，<em>head</em> 将为空。如果 <em>path</em> 为空，则 <em>head</em> 和 <em>tail</em> 均为空。<em>head</em> 末尾的斜杠会被去掉，除非它是根目录（即它仅包含一个或多个斜杠）。在所有情况下，<code>join(head, tail)</code> 指向的位置都与 <em>path</em> 相同（但字符串可能不同）。另请参见函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.dirname" target="_blank" rel="noopener"><code>dirname()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.basename" target="_blank" rel="noopener"><code>basename()</code></a>。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.splitdrive</code>(<em>path</em>)</p>
<p>将路径 <em>path</em> 拆分为一对，即 <code>(drive, tail)</code>，其中 <em>drive</em> 是挂载点或空字符串。在没有驱动器概念的系统上，<em>drive</em> 将始终为空字符串。在所有情况下，<code>drive + tail</code> 都与 <em>path</em> 相同。在 Windows 上，本方法将路径拆分为驱动器/UNC 根节点和相对路径。如果路径 path 包含盘符，则 drive 将包含冒号及冒号前面的所有内容。例如 <code>splitdrive(&quot;c:/dir&quot;)</code> 返回 <code>(&quot;c:&quot;, &quot;/dir&quot;)</code>。如果 path 是一个 UNC 路径，则 drive 将包含主机名和共享点，但不包括第四个分隔符。例如 <code>splitdrive(&quot;//host/computer/dir&quot;)</code> 返回 <code>(&quot;//host/computer&quot;, &quot;/dir&quot;)</code>。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.splitext</code>(<em>path</em>)</p>
<p>将路径 <em>path</em> 拆分为一对，即 <code>(root, ext)</code>，使 <code>root + ext == path</code>，其中 <em>ext</em> 为空或以英文句点开头，且最多包含一个句点。路径前的句点将被忽略，例如 <code>splitext(&#39;.cshrc&#39;)</code> 返回 <code>(&#39;.cshrc&#39;, &#39;&#39;)</code>。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.path.supports_unicode_filenames</code></p>
<p>如果（在文件系统限制下）允许将任意 Unicode 字符串用作文件名，则为 <code>True</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>os.path</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library marshal</title>
    <url>/2020/02/16/python-standard-library-marshal/</url>
    <content><![CDATA[<h1 id="marshal-—-内部-Python-对象序列化"><a href="#marshal-—-内部-Python-对象序列化" class="headerlink" title="marshal — 内部 Python 对象序列化"></a><code>marshal</code> — 内部 Python 对象序列化</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200216_pijitailai.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>每日一词：</p>
<p>否极泰来( pi ji tai lai):</p>
<p> 否，读如痞(pǐ)又作“否极终泰”、“否去泰来”。天地相交，因而安泰。天与地不相交，叫做否。在这种情况下，君子应该收敛自己的才华，以避免小人陷害；不可追求荣誉富贵，以避免小人嫉妒。闭塞到了极点，则转向通泰。人们将这些观点概括为否极泰来或否极终泰。原指事物发展到一定程度，就要转化到它的对立面。后常以此形容情况从坏变好。</p>
<p>【出典】：</p>
<p>  《易·泰》：“天地交，泰。”《易·否》：“天地不交，否；君子以俭德辟难，不可荣以禄。”《易·杂卦》：“否泰反其类也。”</p>
<p>【例句】：</p>
<p>  《吴越春秋·句践入臣外传》：“时过于期，否终则泰。” 唐·白居易《遣怀诗》：“乐往必悲生，泰来犹否极。” 唐·韦庄《湘中作》：“否去泰来终可待。”</p>
<p>【英文】</p>
<p> after a storm comes a calm </p>
<p>【反义词】</p>
<p>乐极生悲  after joy comes sadness </p>
</blockquote>
<p>此模块包含一此能以二进制格式来读写 Python 值的函数。 这种格式是 Python 专属的，但是独立于特定的机器架构（即你可以在一台 PC 上写入某个 Python 值，将文件传到一台 Sun 上并在那里读取它）。 这种格式的细节有意不带文档说明；它可能在不同 Python 版本中发生改变（但这种情况极少发生）。 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#id2" target="_blank" rel="noopener">1</a></p>
<p>这不是一个通用的“持久化”模块。 对于通用的持久化以及通过 RPC 调用传递 Python 对象，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/shelve.html#module-shelve" target="_blank" rel="noopener"><code>shelve</code></a> 等模块。 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#module-marshal" target="_blank" rel="noopener"><code>marshal</code></a> 模块主要是为了支持读写 <code>.pyc</code> 文件形式“伪编译”代码的 Python 模块。 因此，Python 维护者保留在必要时以不向下兼容的方式修改 marshal 格式的权利。 如果你要序列化和反序列化 Python 对象，请改用 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块 – 其执行效率相当，版本独立性有保证，并且 pickle 还支持比 marshal 更多样的对象类型。</p>
<p>警告<br><a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#module-marshal" target="_blank" rel="noopener"><code>marshal</code></a> 模块对于错误或恶意构建的数据来说是不安全的。 永远不要 unmarshal 来自不受信任的或未经验证的来源的数据。</p>
<p>不是所有 Python 对象类型都受支持；一般来说，此模块只能写入和读取不依赖于特定 Python 调用的对象。 下列类型是受支持的：布尔值、整数、浮点数、复数、字符串、字节串、字节数组、元组、列表、集合、冻结集合、字典和代码对象，需要了解的一点是元组、列表、集合、冻结集合和字典只在其所包含的值也是这些值时才受支持。 单例对象 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#Ellipsis" target="_blank" rel="noopener"><code>Ellipsis</code></a> and <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 也可以被 marshal 和 unmarshal。 对于 <em>version</em> 低于 3 的格式，递归列表、集合和字典无法被写入（见下文）。</p>
<p>有些函数可以读/写文件，还有些函数可以操作字节类对象。</p>
<p>这个模块定义了以下函数：</p>
<ul>
<li><p><code>marshal.dump</code>(<em>value</em>, <em>file</em>[, <em>version</em>])</p>
<p>向打开的文件写入值。 值必须为受支持的类型。 文件必须为可写的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a>。如果值具有（或所包含的对象具有）不受支持的类型，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> — 但是将向文件写入垃圾数据。 对象也将不能正确地通过 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#marshal.load" target="_blank" rel="noopener"><code>load()</code></a> 重新读取。<em>version</em> 参数指明 <code>dump</code> 应当使用的数据格式（见下文）。</p>
</li>
<li><p><code>marshal.load</code>(<em>file</em>)</p>
<p>从打开的文件读取一个值并返回。 如果读不到有效的值（例如由于数据为不同 Python 版本的不兼容 marshal 格式），则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EOFError" target="_blank" rel="noopener"><code>EOFError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 文件必须为可读的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a>。注解 如果通过 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#marshal.dump" target="_blank" rel="noopener"><code>dump()</code></a> marshal 了一个包含不受支持类型的对象，<a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#marshal.load" target="_blank" rel="noopener"><code>load()</code></a> 将为不可 marshal 的类型替换 <code>None</code>。</p>
</li>
<li><p><code>marshal.dumps</code>(<em>value</em>[, <em>version</em>])</p>
<p>返回将通过 <code>dump(value, file)</code> 被写入一个文件的字节串对象。 值必须属于受支持的类型。 如果值属于（或包含的对象属于）不受支持的类型则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。<em>version</em> 参数指明 <code>dumps</code> 应当使用的数据类型（见下文）。</p>
</li>
<li><p><code>marshal.loads</code>(<em>bytes</em>)</p>
<p>将 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 转换为一个值。 如果找不到有效的值，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EOFError" target="_blank" rel="noopener"><code>EOFError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 输入的额外字节串会被忽略。</p>
</li>
</ul>
<p>此外，还定义了以下常量：</p>
<ul>
<li><p><code>marshal.version</code></p>
<p>指明模块所使用的格式。 第 0 版为历史格式，第 1 版为共享固化的字符串，第 2 版对浮点数使用二进制格式。 第 3 版添加了对于对象实例化和递归的支持。 目前使用的为第 4 版。</p>
</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> marshal</span><br><span class="line">data1 = [<span class="string">'abc'</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="string">'jb51'</span>]  <span class="comment">#几个测试数据</span></span><br><span class="line">data2 = &#123;<span class="number">1</span>:<span class="string">'aaa'</span>,<span class="string">"b"</span>:<span class="string">'dad'</span>&#125;</span><br><span class="line">data3 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">output_file = open(<span class="string">"a.txt"</span>,<span class="string">'wb'</span>)<span class="comment">#把这些数据序列化到文件中，注：文件必须以二进制模式打开</span></span><br><span class="line">marshal.dump(data1,output_file)</span><br><span class="line">marshal.dump(data2,output_file)</span><br><span class="line">marshal.dump(data3,output_file)</span><br><span class="line">output_file.close()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">input_file = open(<span class="string">'a.txt'</span>,<span class="string">'rb'</span>)<span class="comment">#从文件中读取序列化的数据</span></span><br><span class="line"><span class="comment">#data1 = []</span></span><br><span class="line">data1 = marshal.load(input_file)</span><br><span class="line">data2 = marshal.load(input_file)</span><br><span class="line">data3 = marshal.load(input_file)</span><br><span class="line"><span class="keyword">print</span> data1<span class="comment">#给同志们打印出结果看看</span></span><br><span class="line"><span class="keyword">print</span> data2</span><br><span class="line"><span class="keyword">print</span> data3</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">outstring = marshal.dumps(data1)<span class="comment">#marshal.dumps()返回是一个字节串，该字节串用于写入文件</span></span><br><span class="line">open(<span class="string">'out.txt'</span>,<span class="string">'wb'</span>).write(outstring)</span><br><span class="line"> </span><br><span class="line">file_data = open(<span class="string">'out.txt'</span>,<span class="string">'rb'</span>).read()</span><br><span class="line">real_data = marshal.loads(file_data)</span><br><span class="line">print(real_data)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>python standard library dbm</title>
    <url>/2020/02/17/python-standard-library-dbm/</url>
    <content><![CDATA[<h1 id="python-标准库-dbm"><a href="#python-标准库-dbm" class="headerlink" title="python 标准库 dbm"></a>python 标准库 dbm</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200217_haiwang.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>要使整个人生都过得舒适、愉快，这是不可能的，因为人类必须具备一种能应付逆境的态度。</p>
<p>​                                                                                                                                  ——卢梭</p>
</blockquote>
<p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/__init__.py" target="_blank" rel="noopener">Lib/dbm/<strong>init</strong>.py</a></p>
<hr>
<p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm" target="_blank" rel="noopener"><code>dbm</code></a> 是一种泛用接口，针对各种 DBM 数据库 — 包括 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a>。 如果未安装这些模块中的任何一种，则将使用 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 模块中慢速但简单的实现。 还有一个适用于 Oracle Berkeley DB 的 <a href="https://www.jcea.es/programacion/pybsddb.htm" target="_blank" rel="noopener">第三方接口</a>。</p>
<ul>
<li><p><em>exception</em> <code>dbm.error</code></p>
<p>一个元组，其中包含每个受支持的模块可引发的异常，另外还有一个名为 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.error" target="_blank" rel="noopener"><code>dbm.error</code></a> 的特殊异常作为第一项 — 后者最在引发 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.error" target="_blank" rel="noopener"><code>dbm.error</code></a> 时被使用。</p>
</li>
<li><p><code>dbm.whichdb</code>(<em>filename</em>)</p>
<p>此函数会猜测各种简单数据库模块中的哪一个是可用的 — <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 还是 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> — 应该被用来打开给定的文件。返回下列值中的一个：如果文件由于不可读或不存在而无法打开则返回 <code>None</code>；如果文件的格式无法猜测则返回空字符串 (<code>&#39;&#39;</code>)；或是包含所需模块名称的字符串，例如 <code>&#39;dbm.ndbm&#39;</code> 或 <code>&#39;dbm.gnu&#39;</code>。</p>
</li>
<li><p><code>dbm.open</code>(<em>file</em>, <em>flag=’r’</em>, <em>mode=0o666</em>)</p>
<p>打开数据库文件 <em>file</em> 并返回一个相应的对象。如果数据库文件已存在，则使用 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.whichdb" target="_blank" rel="noopener"><code>whichdb()</code></a> 函数来确定其类型和要使用的适当模块；如果文件不存在，则会使用上述可导入模块中的第一个。可选的 <em>flag</em> 参数可以是：’’</p>
<p>| 值    | 意义                                     |<br>| —– | —————————————- |<br>| <code>&#39;r&#39;</code> | 以只读方式打开现有数据库（默认）         |<br>| <code>&#39;w&#39;</code> | 以读写方式打开现有数据库                 |<br>| <code>&#39;c&#39;</code> | 以读写方式打开数据库，如果不存在则创建它 |<br>| <code>&#39;n&#39;</code> | 始终创建一个新的空数据库，以读写方式打开 |</p>
<p>  <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.open" target="_blank" rel="noopener"><code>open()</code></a> 所返回的对象支持与字典相同的基本功能；可以存储、获取和删除键及其对应的值，并可使用 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a> 运算符和 <code>keys()</code> 方法，以及 <code>get()</code> 和 <code>setdefault()</code>。</p>
</li>
</ul>
<p><em>在 3.2 版更改:</em> 现在 <code>get()</code> 和 <code>setdefault()</code> 在所有数据库模块中均可用。</p>
<p><em>在 3.8 版更改:</em> 从只读数据库中删除键将引发数据库模块专属的错误而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。</p>
<p>键和值总是被存储为字节串。 这意味着当使用字符串时它们会在被存储之前隐式地转换至默认编码格式。</p>
<p>这些对象也支持在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中使用，当语句结束时将自动关闭它们。</p>
<p><em>在 3.4 版更改:</em> 向 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.open" target="_blank" rel="noopener"><code>open()</code></a> 所返回的对象添加了上下文管理协议的原生支持。</p>
<p>以下示例记录了一些主机名和对应的标题，随后将数据库的内容打印出来。:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> dbm</span><br><span class="line"></span><br><span class="line"><span class="comment"># Open database, creating it if necessary.</span></span><br><span class="line"><span class="keyword">with</span> dbm.open(<span class="string">'cache'</span>, <span class="string">'c'</span>) <span class="keyword">as</span> db:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Record some values</span></span><br><span class="line">    db[<span class="string">b'hello'</span>] = <span class="string">b'there'</span></span><br><span class="line">    db[<span class="string">'www.python.org'</span>] = <span class="string">'Python Website'</span></span><br><span class="line">    db[<span class="string">'www.cnn.com'</span>] = <span class="string">'Cable News Network'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Note that the keys are considered bytes now.</span></span><br><span class="line">    <span class="keyword">assert</span> db[<span class="string">b'www.python.org'</span>] == <span class="string">b'Python Website'</span></span><br><span class="line">    <span class="comment"># Notice how the value is now in bytes.</span></span><br><span class="line">    <span class="keyword">assert</span> db[<span class="string">'www.cnn.com'</span>] == <span class="string">b'Cable News Network'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Often-used methods of the dict interface work too.</span></span><br><span class="line">    print(db.get(<span class="string">'python.org'</span>, <span class="string">b'not present'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Storing a non-string key or value will raise an exception (most</span></span><br><span class="line">    <span class="comment"># likely a TypeError).</span></span><br><span class="line">    db[<span class="string">'www.yahoo.com'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># db is automatically closed when leaving the with statement.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参见:模块 <a href="https://docs.python.org/zh-cn/3.8/library/shelve.html#module-shelve" target="_blank" rel="noopener"><code>shelve</code></a></p>
<p>存储非字符串数据的持久化模块。</p>
</blockquote>
<p>以下部分描述了各个单独的子模块。</p>
<h2 id="dbm-gnu-—-GNU-对-dbm-的重解析"><a href="#dbm-gnu-—-GNU-对-dbm-的重解析" class="headerlink" title="dbm.gnu — GNU 对 dbm 的重解析"></a><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> — GNU 对 dbm 的重解析</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/gnu.py" target="_blank" rel="noopener">Lib/dbm/gnu.py</a></p>
<hr>
<p>此模块与 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm" target="_blank" rel="noopener"><code>dbm</code></a> 模块很相似，但是改用 GNU 库 <code>gdbm</code> 来提供某些附加功能。 请注意由 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 与 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 所创建的文件格式是不兼容的。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 模块提供了对 GNU DBM 库的接口。 <code>dbm.gnu.gdbm</code> 对象的行为类似于映射（字典），区别在于其键和值总是会在存储之前被转换为字节串。 打印 <code>gdbm</code> 对象不会打印出键和值，并且 <code>items()</code> 和 <code>values()</code> 等方法也不受支持。</p>
<ul>
<li><p><em>exception</em> <code>dbm.gnu.error</code></p>
<p>针对 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 专属错误例如 I/O 错误引发。 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 的引发则针对一般映射错误例如指定了不正确的键。</p>
</li>
<li><p><code>dbm.gnu.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p>
<p>打开一个 <code>gdbm</code> 数据库并返回 <code>gdbm</code> 对象。 <em>filename</em> 参数为数据库文件名称。</p>
<p>可选的 <em>flag</em> 参数可以是：</p>
<p>| 值    | 意义                                     |<br>| —– | —————————————- |<br>| <code>&#39;r&#39;</code> | 以只读方式打开现有数据库（默认）         |<br>| <code>&#39;w&#39;</code> | 以读写方式打开现有数据库                 |<br>| <code>&#39;c&#39;</code> | 以读写方式打开数据库，如果不存在则创建它 |<br>| <code>&#39;n&#39;</code> | 始终创建一个新的空数据库，以读写方式打开 |</p>
<p>下列附加字符可被添加至旗标以控制数据库的打开方式：</p>
<p>| 值    | 意义                                         |<br>| —– | ——————————————– |<br>| <code>&#39;f&#39;</code> | 以快速模式打开数据库。写入数据库将不会同步。 |<br>| <code>&#39;s&#39;</code> | 同步模式。这将导致数据库的更改立即写入文件。 |<br>| <code>&#39;u&#39;</code> | 不要锁定数据库。                             |</p>
<p>不是所有旗标都可用于所有版本的 <code>gdbm</code>。 模块常量 <code>open_flags</code> 为包含受支持旗标字符的字符串。 如果指定了无效的旗标则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.gnu.error" target="_blank" rel="noopener"><code>error</code></a>。</p>
<p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code>。</p>
<p>除了与字典类似的方法，<code>gdbm</code> 对象还有以下方法：</p>
</li>
<li><p><code>gdbm.firstkey</code>()</p>
<p>  使用此方法和 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.gnu.gdbm.nextkey" target="_blank" rel="noopener"><code>nextkey()</code></a> 方法可以循环遍历数据库中的每个键。 遍历的顺序是按照 <code>gdbm</code> 的内部哈希值，而不会根据键的值排序。 此方法将返回起始键。</p>
</li>
<li><p><code>gdbm.nextkey</code>(<em>key</em>)</p>
<p>  在遍历中返回 <em>key</em> 之后的的下一个键。 以下代码将打印数据库 <code>db</code> 中的每个键，而不会在内存中创建一个包含所有键的列表:<code>k = db.firstkey() while k != None:     print(k)     k = db.nextkey(k)</code></p>
</li>
<li><p><code>gdbm.reorganize</code>()</p>
<p>  如果你进行了大量删除操作并且想要缩减 <code>gdbm</code> 文件所使用的空间，此例程将可重新组织数据库。 除非使用此重组功能否则 <code>gdbm</code> 对象不会缩减数据库文件大小；在其他情况下，被删除的文件空间将会保留并在添加新的 (键, 值) 对时被重用。</p>
</li>
<li><p><code>gdbm.sync</code>()</p>
<p>  当以快速模式打开数据库时，此方法会将任何未写入数据强制写入磁盘。</p>
</li>
<li><p><code>gdbm.close</code>()<a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.gnu.gdbm.close" target="_blank" rel="noopener">¶</a></p>
<p>  关闭 <code>gdbm</code> 数据库。</p>
</li>
</ul>
<h2 id="dbm-ndbm-—-基于-ndbm-的接口"><a href="#dbm-ndbm-—-基于-ndbm-的接口" class="headerlink" title="dbm.ndbm — 基于 ndbm 的接口"></a><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> — 基于 ndbm 的接口</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/ndbm.py" target="_blank" rel="noopener">Lib/dbm/ndbm.py</a></p>
<hr>
<p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 模块提供了对 Unix “(n)dbm” 库的接口。 Dbm 对象的行为类似于映射（字典），区别在于其键和值总是被存储为字节串。 打印 <code>dbm</code> 对象不会打印出键和值，并且 <code>items()</code> 和 <code>values()</code> 等方法也不受支持。</p>
<p>此模块可与 “经典classic” ndbm 接口或 GNU GDBM 兼容接口一同使用。 在 Unix 上，<strong>configure</strong> 脚本将尝试定位适当的头文件来简化此模块的构建。</p>
<ul>
<li><p><em>exception</em> <code>dbm.ndbm.error</code></p>
<p>针对 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 专属错误例如 I/O 错误引发。 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 的引发则针对一般映射错误例如指定了不正确的键。</p>
</li>
<li><p><code>dbm.ndbm.library</code></p>
<p>所使用的 <code>ndbm</code> 实现库的名称。</p>
</li>
<li><p><code>dbm.ndbm.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p>
<p>打开一个 dbm 数据库并返回 <code>ndbm</code> 对象。 <em>filename</em> 参数为数据库文件名称（不带 <code>.dir</code> 或 <code>.pag</code> 扩展名）。可选的 <em>flag</em> 参数必须是下列值之一：值意义<code>&#39;r&#39;</code>以只读方式打开现有数据库（默认）<code>&#39;w&#39;</code>以读写方式打开现有数据库<code>&#39;c&#39;</code>以读写方式打开数据库，如果不存在则创建它<code>&#39;n&#39;</code>始终创建一个新的空数据库，以读写方式打开可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code> (并将被当前的 umask 所修改)。除了与字典类似的方法，<code>ndbm</code> 对象还有以下方法：<code>ndbm.close</code>()关闭 <code>ndbm</code> 数据库。</p>
</li>
</ul>
<h2 id="dbm-dumb-—-便携式-DBM-实现"><a href="#dbm-dumb-—-便携式-DBM-实现" class="headerlink" title="dbm.dumb — 便携式 DBM 实现"></a><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> — 便携式 DBM 实现</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/dumb.py" target="_blank" rel="noopener">Lib/dbm/dumb.py</a></p>
<blockquote>
<p>注解:<a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 模块的目的是在更健壮的模块不可用时作为 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm" target="_blank" rel="noopener"><code>dbm</code></a> 模块的最终回退项。 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 不是为高速运行而编写的，也不像其他数据库模块一样被经常使用。</p>
</blockquote>
<hr>
<p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 模块提供了一个完全以 Python 编写的持久化字典类接口。 不同于 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 等其他模块，它不需要外部库。 与其他持久化映射一样，它的键和值也总是被存储为字节串。</p>
<p>该模块定义以下内容：</p>
<ul>
<li><p><em>exception</em> <code>dbm.dumb.error</code></p>
<p>针对 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 专属错误例如 I/O 错误引发。 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 的引发则针对一般映射例如指定了不正确的键。</p>
</li>
<li><p><code>dbm.dumb.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p>
<p>打开一个 <code>dumbdbm</code> 数据库并返回 dumbdbm 对象。 <em>filename</em> 参数为数据库文件的主名称（不带任何特定扩展名）。 创建一个 dumbdbm 数据库时将创建多个带有 <code>.dat</code> 和 <code>.dir</code> 扩展名的文件。可选的 <em>flag</em> 参数可以是：</p>
<p>| 值    | 意义                                     |<br>| —– | —————————————- |<br>| <code>&#39;r&#39;</code> | 以只读方式打开现有数据库（默认）         |<br>| <code>&#39;w&#39;</code> | 以读写方式打开现有数据库                 |<br>| <code>&#39;c&#39;</code> | 以读写方式打开数据库，如果不存在则创建它 |<br>| <code>&#39;n&#39;</code> | 始终创建一个新的空数据库，以读写方式打开 |</p>
<p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code> (并将  被当前的 umask 所修改)。</p>
<p><em>在 3.5 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.dumb.open" target="_blank" rel="noopener"><code>open()</code></a> 在 flag 值为 <code>&#39;n&#39;</code> 时将总是创建一个新的数据库。</p>
<p><em>在 3.8 版更改:</em> 附带 <code>&#39;r&#39;</code> 旗标打开的数据库现在将是只读的。 附带 <code>&#39;r&#39;</code> 和 <code>&#39;w&#39;</code> 旗标的打开操作不会再创建数据库。</p>
<p>除了 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableMapping" target="_blank" rel="noopener"><code>collections.abc.MutableMapping</code></a> 类所提供的方法，<code>dumbdbm</code> 对象还提供了以下方法：</p>
</li>
<li><p><code>dumbdbm.sync</code>()</p>
<p>  同步磁盘上的目录和数据文件。 此方法会由 <code>Shelve.sync()</code> 方法来调用。</p>
</li>
<li><p><code>dumbdbm.close</code>()</p>
<p>  关闭 <code>dumbdbm</code> 数据库。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>dbm</tag>
      </tags>
  </entry>
  <entry>
    <title>using ffmpeg download yizhibo m3u8 type playback video</title>
    <url>/2020/02/18/using-ffmpeg-download-yizhibo-m3u8-type-playback-video/</url>
    <content><![CDATA[<h1 id="使用-ffmpe-下载一直播-回放视频"><a href="#使用-ffmpe-下载一直播-回放视频" class="headerlink" title="使用 ffmpe 下载一直播 回放视频"></a>使用 ffmpe 下载一直播 回放视频</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200218_JohnWill.jpeg?raw=true" alt></p>
<a id="more"></a>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>想下载一直播上的直播视频到本地,但是发现没有直接下载的途径,只能回放。</p>
<h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>下播后,通过分享链接到qq,得到了在线观看回放的视频地址。F12 发现m3u8格式的链接地址。</p>
<p>复制该链接地址。</p>
<p>本地已经搭建了ffmpeg的环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PS &gt; ffmpeg</span><br><span class="line">ffmpeg version git-2019-11-20-d73f062 Copyright (c) 2000-2019 the FFmpeg developers</span><br><span class="line">  built with gcc 9.2.1 (GCC) 20191010</span><br><span class="line">  configuration: --enable-gpl --enable-version3 --enable-sdl2 --enable-fontconfig --enable-gnutls --enable-iconv --enable-libass --enable-libdav1d --enable-libbluray --enable-libfreetype --enable-libmp3lame --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-libopus --enable-libshine --enable-libsnappy</span><br><span class="line">--enable-libsoxr --enable-libtheora --enable-libtwolame --enable-libvpx --enable-libwavpack --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxml2 --enable-libzimg --enable-lzma --enable-zlib --enable-gmp --enable-libvidstab --enable-libvorbis --enable-libvo-amrwbenc --enable-libmysofa --enable-libspeex --enable-libxvid --enable-libaom --enable-libmfx --enable-ffnvcodec --enable-cuvid --enable-d3d11va --enable-nvenc --enable-nvdec --enable-dxva2 --enable-avisynth --enable-libopenmpt --enable-amf</span><br><span class="line">  libavutil      56. 36.100 / 56. 36.100</span><br><span class="line">  libavcodec     58. 62.100 / 58. 62.100</span><br><span class="line">  libavformat    58. 35.100 / 58. 35.100</span><br><span class="line">  libavdevice    58.  9.101 / 58.  9.101</span><br><span class="line">  libavfilter     7. 66.100 /  7. 66.100</span><br><span class="line">  libswscale      5.  6.100 /  5.  6.100</span><br><span class="line">  libswresample   3.  6.100 /  3.  6.100</span><br><span class="line">  libpostproc    55.  6.100 / 55.  6.100</span><br><span class="line">Hyper fast Audio and Video encoder</span><br><span class="line">usage: ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...</span><br><span class="line"></span><br><span class="line">Use -h to get full help or, even better, run 'man ffmpeg'</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>接下来使用 ffmpeg 解析上面网址中含有 m3u8的链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i "https://test.test/test.m3u8" -vcodec copy -acodec copy -absf aac_adtstoasc test.mp4</span><br></pre></td></tr></table></figure>
<p>经过漫长的等待,终于解析成功。视频可以直接播放。</p>
]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>m3u8</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library cmd</title>
    <url>/2020/02/21/python-standard-library-cmd/</url>
    <content><![CDATA[<h1 id="python-标准库-cmd模块"><a href="#python-标准库-cmd模块" class="headerlink" title="python 标准库 cmd模块"></a>python 标准库 cmd模块</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200221_zhuakuang.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>每日一词:</p>
<p> collapse </p>
<p>近义词:</p>
<p>crash<br>breakdown<br>crumble<br>fall apart </p>
<p>例句:</p>
<p> 我曾经神经崩溃过。那是一次痛苦的经历。<br>I suffered a nervous breakdown. It was a traumatic experience </p>
<p> 他能明显地看出我快要精神崩溃了。<br>It was plain to him that I was having a nervous breakdown </p>
</blockquote>
<p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/cmd.py" target="_blank" rel="noopener">Lib/cmd.py</a></p>
<hr>
<p><a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 类提供简单框架用于编写面向行的命令解释器。 这些通常对测试工具，管理工具和原型有用，这些工具随后将被包含在更复杂的接口中。</p>
<ul>
<li><p><em>class</em> <code>cmd.Cmd</code>(<em>completekey=’tab’</em>, <em>stdin=None</em>, <em>stdout=None</em>)</p>
<p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 实例或子类实例是面向行的解释器框架结构。 实例化 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 本身是没有充分理由的， 它作为自定义解释器类的超类是非常有用的为了继承 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 的方法并且封装动作方法。可选参数 <em>completekey</em> 是完成键的 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 名称；默认是 Tab 。如果 <em>completekey</em> 不是 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 并且 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 是可用的， 命令完成会自动完成。可选参数 <em>stdin</em> 和 <em>stdout</em> 指定了Cmd实例或子类实例将用于输入和输出的输入和输出文件对象。如果没有指定，他们将默认为 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdout" target="_blank" rel="noopener"><code>sys.stdout</code></a> 。如果你想要使用一个给定的 <em>stdin</em> ，确保将实例的 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.use_rawinput" target="_blank" rel="noopener"><code>use_rawinput</code></a> 属性设置为 <code>False</code> ，否则 <em>stdin</em> 将被忽略</p>
</li>
</ul>
<h2 id="Cmd-对象"><a href="#Cmd-对象" class="headerlink" title="Cmd 对象"></a>Cmd 对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 实例有下列方法：</p>
<ul>
<li><p><code>Cmd.cmdloop</code>(<em>intro=None</em>)</p>
<p>反复发出提示，接受输入，从收到的输入中解析出一个初始前缀，并分派给操作方法，将其余的行作为参数传递给它们。可选参数是在第一个提示之前发布的横幅或介绍字符串（这将覆盖 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.intro" target="_blank" rel="noopener"><code>intro</code></a> 类属性）。如果 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 继承模块被加载，输入将自动继承类似 <strong>bash</strong>的历史列表编辑（例如， Control-P 滚动回到最后一个命令， Control-N 转到下一个命令，以 Control-F 非破坏性的方式向右 Control-B 移动光标，破坏性地等）。输入的文件结束符被作为字符串传回 <code>&#39;EOF&#39;</code> 。解释器实例将会识别命令名称 <code>foo</code> 当且仅当它有方法 <code>do_foo()</code> 。有一个特殊情况，分派始于字符 <code>&#39;?&#39;</code> 的行到方法 <code>do_help()</code> 。另一种特殊情况，分派始于字符 <code>&#39;!&#39;</code> 的行到方法 <code>do_shell()</code> （如果定义了这个方法）这个方法将返回当 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.postcmd" target="_blank" rel="noopener"><code>postcmd()</code></a> 方法返回一个真值 。参数 <em>stop</em> 到 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.postcmd" target="_blank" rel="noopener"><code>postcmd()</code></a> 是命令对应的返回值 <code>do_*()</code> 的方法。如果激活了完成，全部命令将会自动完成，并且通过调用 <code>complete_foo()</code> 参数 <em>text</em> , <em>line</em>, <em>begidx</em> ,和 <em>endidx</em> 完成全部命令参数。 <em>text</em> 是我们试图匹配的字符串前缀，所有返回的匹配项必须以它为开头。 <em>line</em> 是删除了前导空格的当前的输入行， <em>begidx</em> 和 <em>endidx</em> 是前缀文本的开始和结束索引。，可以用于根据参数位置提供不同的完成。所有 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 的子类继承一个预定义 <code>do_help()</code> 。 这个方法使用参数 <code>&#39;bar&#39;</code> 调用， 调用对应的方法 <code>help_bar()</code> ，如果不存在，打印 <code>do_bar()</code> 的文档字符串，如果可用。没有参数的情况下， <code>do_help()</code> 方法会列出所有可用的帮助主题 （即所有具有相应的 <code>help_*()</code> 方法或命令的 文档字符串），也会列举所有未被记录的命令。</p>
</li>
<li><p><code>Cmd.onecmd</code>(<em>str</em>)</p>
<p>解释该参数，就好像它是为响应提示而键入的一样。 这可能会被覆盖，但通常不应该被覆盖; 请参阅： <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.precmd" target="_blank" rel="noopener"><code>precmd()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.postcmd" target="_blank" rel="noopener"><code>postcmd()</code></a> 方法，用于执行有用的挂钩。 返回值是一个标志，指示解释器对命令的解释是否应该停止。 如果命令 <em>str</em> 有一个 <code>do_*()</code> 方法，则返回该方法的返回值，否则返回 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.default" target="_blank" rel="noopener"><code>default()</code></a> 方法的返回值。</p>
</li>
<li><p><code>Cmd.emptyline</code>()</p>
<p>在响应提示输入空行时调用的方法。如果此方法未被覆盖，则重复输入的最后一个非空命令。</p>
</li>
<li><p><code>Cmd.default</code>(<em>line</em>)</p>
<p>当命令前缀不能被识别的时候在输入行调用的方法。如果此方法未被覆盖，它将输出一个错误信息并返回。</p>
</li>
<li><p><code>Cmd.completedefault</code>(<em>text</em>, <em>line</em>, <em>begidx</em>, <em>endidx</em>)</p>
<p>当没有特定于命令的 <code>complete_*()</code> 方法可用时，调用此方法完成输入行。默认情况下，它返回一个空列表。</p>
</li>
<li><p><code>Cmd.precmd</code>(<em>line</em>)</p>
<p>钩方法在命令行 <em>line</em> 被解释之前执行，但是在输入提示被生成和发出后。这个方法是一个在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 中的存根；它的存在是为了被子类覆盖。返回值被用作 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.onecmd" target="_blank" rel="noopener"><code>onecmd()</code></a> 方法执行的命令； <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.precmd" target="_blank" rel="noopener"><code>precmd()</code></a> 的实现或许会重写命令或者简单的返回 <em>line</em> 不变。</p>
</li>
<li><p><code>Cmd.postcmd</code>(<em>stop</em>, <em>line</em>)</p>
<p>钩方法只在命令调度完成后执行。这个方法是一个在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 中的存根；它的存在是为了子类被覆盖。 <em>line</em> 是被执行的命令行， <em>stop</em> 是一个表示在调用 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.postcmd" target="_blank" rel="noopener"><code>postcmd()</code></a> 之后是否终止执行的标志；这将作为 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.onecmd" target="_blank" rel="noopener"><code>onecmd()</code></a> 方法的返回值。这个方法的返回值被用作与 <em>stop</em> 相关联的内部标志的新值；返回 false 将导致解释继续。</p>
</li>
<li><p><code>Cmd.preloop</code>()</p>
<p>钩方法当 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 被调用时执行一次。方法是一个在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 中的存根；它的存在是为了被子类覆盖。</p>
</li>
<li><p><code>Cmd.postloop</code>()</p>
<p>钩方法在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 即将返回时执行一次。这个方法是一个在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 中的存根；塔顶存在是为了被子类覆盖。</p>
</li>
</ul>
<p>Instances of <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> subclasses have some public instance variables:</p>
<ul>
<li><p><code>Cmd.prompt</code></p>
<p>发出提示以请求输入。</p>
</li>
<li><p><code>Cmd.identchars</code></p>
<p>接受命令前缀的字符串。</p>
</li>
<li><p><code>Cmd.lastcmd</code></p>
<p>看到最后一个非空命令前缀。</p>
</li>
<li><p><code>Cmd.cmdqueue</code></p>
<p>排队的输入行列表。当需要新的输入时，在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 中检查 cmdqueue 列表；如果它不是空的，它的元素将被按顺序处理，就像在提示符处输入一样。</p>
</li>
<li><p><code>Cmd.intro</code></p>
<p>要作为简介或横幅发出的字符串。 可以通过给 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 方法一个参数来覆盖它。</p>
</li>
<li><p><code>Cmd.doc_header</code></p>
<p>如果帮助输出具有记录命令的段落，则发出头文件。</p>
</li>
<li><p><code>Cmd.misc_header</code></p>
<p>如果帮助输出其他帮助主题的部分（即与 <code>do_*()</code> 方法没有关联的 <code>help_*()</code> 方法），则发出头文件。</p>
</li>
<li><p><code>Cmd.undoc_header</code></p>
<p>如果帮助输出未被记录命令的部分（即与 <code>help_*()</code> 方法没有关联的 <code>do_*()</code> 方法），则发出头文件。</p>
</li>
<li><p><code>Cmd.ruler</code></p>
<p>用于在帮助信息标题的下方绘制分隔符的字符，如果为空，则不绘制标尺线。 这个字符默认是 <code>&#39;=&#39;</code> 。</p>
</li>
<li><p><code>Cmd.use_rawinput</code></p>
<p>这是一个标志，默认为 true 。如果为 true ，, <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#input" target="_blank" rel="noopener"><code>input()</code></a> 先是提示并且阅读下一个命令；如果为 false ， <code>sys.stdout.write()</code> 和 <code>sys.stdin.readline()</code> 被使用。（这意味着解释器将会自动支持类似于 <strong>Emacs</strong>的行编辑和命令历史记录按键操作，通过导入 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 在支持它的系统上。）</p>
</li>
</ul>
<h2 id="Cmd-例子"><a href="#Cmd-例子" class="headerlink" title="Cmd 例子"></a>Cmd 例子</h2><p>这部分提供了一个简单的例子来介绍如何使用一部分在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 模块中的命令构建一个 shell 。</p>
<p>基础的 turtle 命令比如 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.forward" target="_blank" rel="noopener"><code>forward()</code></a> 被添加进一个 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 子类，方法名为 <code>do_forward()</code> 。参数被转换成数字并且分发至 turtle 模组中。 docstring 是 shell 提供的帮助实用程序。</p>
<p>例子也包含使用 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.precmd" target="_blank" rel="noopener"><code>precmd()</code></a> 方法实现基础的记录和回放的功能，这个方法负责将输入转换为小写并且将命令写入文件。 <code>do_playback()</code> 方法读取文件并添加记录命令至 <code>cmdqueue</code> 用于即时回放:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cmd, sys</span><br><span class="line"><span class="keyword">from</span> turtle <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TurtleShell</span><span class="params">(cmd.Cmd)</span>:</span></span><br><span class="line">    intro = <span class="string">'Welcome to the turtle shell.   Type help or ? to list commands.\n'</span></span><br><span class="line">    prompt = <span class="string">'(turtle) '</span></span><br><span class="line">    file = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ----- basic turtle commands -----</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_forward</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Move the turtle forward by the specified distance:  FORWARD 10'</span></span><br><span class="line">        forward(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_right</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Turn turtle right by given number of degrees:  RIGHT 20'</span></span><br><span class="line">        right(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_left</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Turn turtle left by given number of degrees:  LEFT 90'</span></span><br><span class="line">        left(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_goto</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Move turtle to an absolute position with changing orientation.  GOTO 100 200'</span></span><br><span class="line">        goto(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_home</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Return turtle to the home position:  HOME'</span></span><br><span class="line">        home()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_circle</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Draw circle with given radius an options extent and steps:  CIRCLE 50'</span></span><br><span class="line">        circle(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_position</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Print the current turtle position:  POSITION'</span></span><br><span class="line">        print(<span class="string">'Current position is %d %d\n'</span> % position())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_heading</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Print the current turtle heading in degrees:  HEADING'</span></span><br><span class="line">        print(<span class="string">'Current heading is %d\n'</span> % (heading(),))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_color</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Set the color:  COLOR BLUE'</span></span><br><span class="line">        color(arg.lower())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_undo</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Undo (repeatedly) the last turtle action(s):  UNDO'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_reset</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Clear the screen and return turtle to center:  RESET'</span></span><br><span class="line">        reset()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_bye</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Stop recording, close the turtle window, and exit:  BYE'</span></span><br><span class="line">        print(<span class="string">'Thank you for using Turtle'</span>)</span><br><span class="line">        self.close()</span><br><span class="line">        bye()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ----- record and playback -----</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_record</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Save future commands to filename:  RECORD rose.cmd'</span></span><br><span class="line">        self.file = open(arg, <span class="string">'w'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_playback</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Playback commands from a file:  PLAYBACK rose.cmd'</span></span><br><span class="line">        self.close()</span><br><span class="line">        <span class="keyword">with</span> open(arg) <span class="keyword">as</span> f:</span><br><span class="line">            self.cmdqueue.extend(f.read().splitlines())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">precmd</span><span class="params">(self, line)</span>:</span></span><br><span class="line">        line = line.lower()</span><br><span class="line">        <span class="keyword">if</span> self.file <span class="keyword">and</span> <span class="string">'playback'</span> <span class="keyword">not</span> <span class="keyword">in</span> line:</span><br><span class="line">            print(line, file=self.file)</span><br><span class="line">        <span class="keyword">return</span> line</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.file:</span><br><span class="line">            self.file.close()</span><br><span class="line">            self.file = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="string">'Convert a series of zero or more numbers to an argument tuple'</span></span><br><span class="line">    <span class="keyword">return</span> tuple(map(int, arg.split()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    TurtleShell().cmdloop()</span><br></pre></td></tr></table></figure>
<p>这是一个示例会话，其中 turtle shell 显示帮助功能，使用空行重复命令，以及简单的记录和回放功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Welcome to the turtle shell.   Type help or ? to list commands.</span><br><span class="line"></span><br><span class="line">(turtle) ?</span><br><span class="line"></span><br><span class="line">Documented commands (type help &lt;topic&gt;):</span><br><span class="line">========================================</span><br><span class="line">bye     color    goto     home  playback  record  right</span><br><span class="line">circle  forward  heading  left  position  reset   undo</span><br><span class="line"></span><br><span class="line">(turtle) help forward</span><br><span class="line">Move the turtle forward by the specified distance:  FORWARD <span class="number">10</span></span><br><span class="line">(turtle) record spiral.cmd</span><br><span class="line">(turtle) position</span><br><span class="line">Current position <span class="keyword">is</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">(turtle) heading</span><br><span class="line">Current heading <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">(turtle) reset</span><br><span class="line">(turtle) circle <span class="number">20</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">40</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">60</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">80</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">100</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">120</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">120</span></span><br><span class="line">(turtle) heading</span><br><span class="line">Current heading <span class="keyword">is</span> <span class="number">180</span></span><br><span class="line"></span><br><span class="line">(turtle) forward <span class="number">100</span></span><br><span class="line">(turtle)</span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">100</span></span><br><span class="line">(turtle)</span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">400</span></span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">500</span></span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">400</span></span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">300</span></span><br><span class="line">(turtle) playback spiral.cmd</span><br><span class="line">Current position <span class="keyword">is</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Current heading <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Current heading <span class="keyword">is</span> <span class="number">180</span></span><br><span class="line"></span><br><span class="line">(turtle) bye</span><br><span class="line">Thank you <span class="keyword">for</span> using Turtle</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library gc</title>
    <url>/2020/02/23/python_standard_library_gc/</url>
    <content><![CDATA[<h1 id="python-标准库-gc"><a href="#python-标准库-gc" class="headerlink" title="python 标准库 gc"></a>python 标准库 gc</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200224_father.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>离开的时候,才会记得你。</p>
</blockquote>
<p>此模块提供可选的垃圾回收器的接口，提供的功能包括：关闭收集器、调整收集频率、设置调试选项。它同时提供对回收器找到但是无法释放的不可达对象的访问。由于 Python 使用了带有引用计数的回收器，如果你确定你的程序不会产生循环引用，你可以关闭回收器。可以通过调用 <code>gc.disable()</code> 关闭自动垃圾回收。若要调试一个存在内存泄漏的程序，调用 <code>gc.set_debug(gc.DEBUG_LEAK)</code> ；需要注意的是，它包含 <code>gc.DEBUG_SAVEALL</code> ，使得被垃圾回收的对象会被存放在 gc.garbage 中以待检查。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/gc.html#module-gc" target="_blank" rel="noopener"><code>gc</code></a> 模块提供下列函数：</p>
<ul>
<li><p><code>gc.enable</code>()</p>
<p>启用自动垃圾回收</p>
</li>
<li><p><code>gc.disable</code>()</p>
<p>停用自动垃圾回收</p>
</li>
<li><p><code>gc.isenabled</code>()</p>
<p>如果启用了自动回收则返回 <code>True</code>。</p>
</li>
<li><p><code>gc.collect</code>(<em>generation=2</em>)</p>
<p>若被调用时不包含参数，则启动完全的垃圾回收。可选的参数 <em>generation</em> 可以是一个整数，指明需要回收哪一代（从 0 到 2 ）的垃圾。当参数 <em>generation</em> 无效时，会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。返回发现的不可达对象的数目。每当运行完整收集或最高代 (2) 收集时，为多个内置类型所维护的空闲列表会被清空。 由于特定类型特别是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 的实现，在某些空闲列表中并非所有项都会被释放。</p>
</li>
<li><p><code>gc.set_debug</code>(<em>flags</em>)</p>
<p>设置垃圾回收器的调试标识位。调试信息会被写入 <code>sys.stderr</code> 。此文档末尾列出了各个标志位及其含义；可以使用位操作对多个标志位进行设置以控制调试器。</p>
</li>
<li><p><code>gc.get_debug</code>()</p>
<p>返回当前调试标识位。</p>
</li>
<li><p><code>gc.get_objects</code>(<em>generation=None</em>)</p>
<p>返回一个收集器所跟踪的所有对象的列表，所返回的列表除外。 如果 <em>generation</em> 不为 None，则只返回收集器所跟踪的属于该生成的对象。<em>在 3.8 版更改:</em> 新的 <em>generation</em> 形参。</p>
</li>
<li><p><code>gc.get_stats</code>()</p>
<p>返回一个包含三个字典对象的列表，每个字典分别包含对应代的从解释器开始运行的垃圾回收统计数据。字典的键的数目在将来可能发生改变，目前每个字典包含以下内容：<code>collections</code> 是该代被回收的次数；<code>collected</code> 是该代中被回收的对象总数；<code>uncollectable</code> 是在这一代中被发现无法收集的对象总数 （因此被移动到 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>garbage</code></a> 列表中）。<em>3.4 新版功能.</em></p>
</li>
<li><p><code>gc.set_threshold</code>(<em>threshold0</em>[, <em>threshold1</em>[, <em>threshold2</em>]])</p>
<p>设置垃圾回收阈值（收集频率）。 将 <em>threshold0</em> 设为零会禁用回收。垃圾回收器把所有对象分类为三代，取决于对象幸存于多少次垃圾回收。新创建的对象会被放在最年轻代（第 <code>0</code> 代）。如果一个对象幸存于一次垃圾回收，则该对象会被放入下一代。第 <code>2</code> 代是最老的一代，因此这一代的对象幸存于垃圾回收后，仍会留在第 <code>2</code> 代。为了判定何时需要进行垃圾回收，垃圾回收器会跟踪上一次回收后，分配和释放的对象的数目。当分配对象的数量减去释放对象的数量大于阈值 <em>threshold0</em> 时，回收器开始进行垃圾回收。起初只有第 <code>0</code> 代会被检查。当上一次第 <code>1</code> 代被检查后，第 <code>0</code> 代被检查的次数多于阈值 <em>threshold1</em> 时，第 <code>1</code> 代也会被检查。相似的， <em>threshold2</em> 设置了触发第 <code>2</code> 代被垃圾回收的第 <code>1</code> 代被垃圾回收的次数。</p>
</li>
<li><p><code>gc.get_count</code>()</p>
<p>将当前回收计数以形为 <code>(count0, count1, count2)</code> 的元组返回。</p>
</li>
<li><p><code>gc.get_threshold</code>()</p>
<p>将当前回收阈值以形为 <code>(threshold0, threshold1, threshold2)</code> 的元组返回。</p>
</li>
<li><p><code>gc.get_referrers</code>(*<em>objs</em>)</p>
<p>返回直接引用任意一个 <em>ojbs</em> 的对象列表。这个函数只定位支持垃圾回收的容器；引用了其它对象但不支持垃圾回收的扩展类型不会被找到。需要注意的是，已经解除对 <em>objs</em> 引用的对象，但仍存在于循环引用中未被回收时，仍然会被作为引用者出现在返回的列表当中。若要获取当前正在引用 <em>objs</em> 的对象，需要调用 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.collect" target="_blank" rel="noopener"><code>collect()</code></a> 然后再调用 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.get_referrers" target="_blank" rel="noopener"><code>get_referrers()</code></a> 。在使用 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.get_referrers" target="_blank" rel="noopener"><code>get_referrers()</code></a> 返回的对象时必须要小心，因为其中一些对象可能仍在构造中因此处于暂时的无效状态。不要把 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.get_referrers" target="_blank" rel="noopener"><code>get_referrers()</code></a> 用于调试以外的其它目的。</p>
</li>
<li><p><code>gc.get_referents</code>(*<em>objs</em>)</p>
<p>返回被任意一个参数中的对象直接引用的对象的列表。返回的被引用对象是被参数中的对象的C语言级别方法（若存在） <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_traverse" target="_blank" rel="noopener"><code>tp_traverse</code></a> 访问到的对象，可能不是所有的实际直接可达对象。只有支持垃圾回收的对象支持 <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_traverse" target="_blank" rel="noopener"><code>tp_traverse</code></a>  方法，并且此方法只会在需要访问涉及循环引用的对象时使用。因此，可以有以下例子：一个整数对其中一个参数是直接可达的，这个整数有可能出现或不出现在返回的结果列表当中。</p>
</li>
<li><p><code>gc.is_tracked</code>(<em>obj</em>)</p>
<p>当对象正在被垃圾回收器监控时返回 <code>True</code> ，否则返回 <code>False</code> 。一般来说，原子类的实例不会被监控，而非原子类（如容器、用户自定义的对象）会被监控。然而，会有一些特定类型的优化以便减少垃圾回收器在简单实例（如只含有原子性的键和值的字典）上的消耗。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(<span class="number">0</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(<span class="string">"a"</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked([])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(&#123;&#125;)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(&#123;<span class="string">"a"</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(&#123;<span class="string">"a"</span>: []&#125;)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>gc.freeze</code>()</p>
<p>冻结 gc 所跟踪的所有对象 —— 将它们移至永久代并忽略所有未来的集合。 这可以在 POSIX fork() 调用之前使用以便令对写入复制保持友好或加速收集。 并且在 POSIX fork() 调用之前的收集也可以释放页面以供未来分配，这也可能导致写入时复制，因此建议在主进程中禁用 gc 并在 fork 之前冻结，而在子进程中启用 gc。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>gc.unfreeze</code>()</p>
<p>解冻永久代中的对象，并将它们放回到年老代中。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>gc.get_freeze_count</code>()</p>
<p>返回永久代中的对象数量。<em>3.7 新版功能.</em></p>
</li>
</ul>
<p>提供以下变量仅供只读访问（你可以修改但不应该重绑定它们）：</p>
<ul>
<li><p><code>gc.garbage</code></p>
<p>一个回收器发现不可达而又无法被释放的对象（不可回收对象）列表。 从 Python 3.4 开始，该列表在大多数时候都应该是空的，除非使用了含有非 <code>NULL</code> <code>tp_del</code> 空位的 C 扩展类型的实例。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.DEBUG_SAVEALL" target="_blank" rel="noopener"><code>DEBUG_SAVEALL</code></a> ，则所有不可访问对象将被添加至该列表而不会被释放。<em>在 3.2 版更改:</em> 当 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-interpreter-shutdown" target="_blank" rel="noopener">interpreter shutdown</a> 即解释器关闭时，若此列表非空，会产生 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ResourceWarning" target="_blank" rel="noopener"><code>ResourceWarning</code></a> ，即资源警告，在默认情况下此警告不会被提醒。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.DEBUG_UNCOLLECTABLE" target="_blank" rel="noopener"><code>DEBUG_UNCOLLECTABLE</code></a> ，所有无法被回收的对象会被打印。<em>在 3.4 版更改:</em> 根据 <a href="https://www.python.org/dev/peps/pep-0442" target="_blank" rel="noopener"><strong>PEP 442</strong></a> ，带有 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法的对象最终不再会进入 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>gc.garbage</code></a> 。</p>
</li>
<li><p><code>gc.callbacks</code></p>
<p>在垃圾回收器开始前和完成后会被调用的一系列回调函数。这些回调函数在被调用时使用两个参数： <em>phase</em> 和 <em>info</em> 。<em>phase</em> 可为以下两值之一：”start”: 垃圾回收即将开始。”stop”: 垃圾回收已结束。<em>info</em> is a dict providing more information for the callback. The following keys are currently defined:”generation”（代） ：正在被回收的最久远的一代。”collected”（已回收的 ）: 当<em>phase</em> 为 “stop” 时，被成功回收的对象的数目。”uncollectable”（不可回收的）: 当 <em>phase</em> 为 “stop” 时，不能被回收并被放入 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>garbage</code></a> 的对象的数目。应用程序可以把他们自己的回调函数加入此列表。主要的使用场景有：统计垃圾回收的数据，如：不同代的回收频率、回收所花费的时间。使应用程序可以识别和清理他们自己的在 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>garbage</code></a> 中的不可回收类型的对象。<em>3.3 新版功能.</em></p>
</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>以下常量被用于 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.set_debug" target="_blank" rel="noopener"><code>set_debug()</code></a> ：</p>
<ul>
<li><p><code>gc.DEBUG_STATS</code></p>
<p>在回收完成后打印统计信息。当回收频率设置较高时，这些信息会比较有用。</p>
</li>
<li><p><code>gc.DEBUG_COLLECTABLE</code></p>
<p>当发现可回收对象时打印信息。</p>
</li>
<li><p><code>gc.DEBUG_UNCOLLECTABLE</code></p>
<p>打印找到的不可回收对象的信息（指不能被回收器回收的不可达对象）。这些对象会被添加到 <code>garbage</code> 列表中。<em>在 3.2 版更改:</em> 当 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-interpreter-shutdown" target="_blank" rel="noopener">interpreter shutdown</a> 时，即解释器关闭时，若 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>garbage</code></a> 列表中存在对象，这些对象也会被打印输出。</p>
</li>
<li><p><code>gc.DEBUG_SAVEALL</code></p>
<p>设置后，所有回收器找到的不可达对象会被添加进 <em>garbage</em> 而不是直接被释放。这在调试一个内存泄漏的程序时会很有用。</p>
</li>
<li><p><code>gc.DEBUG_LEAK</code></p>
<p>调试内存泄漏的程序时，使回收器打印信息的调试标识位。（等价于 <code>DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_SAVEALL</code> ）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>gc</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library binascii</title>
    <url>/2020/02/24/python-standard-library-binascii/</url>
    <content><![CDATA[<h1 id="python-标准库-binascii"><a href="#python-标准库-binascii" class="headerlink" title="python 标准库 binascii"></a>python 标准库 binascii</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200224_Happy-Hero-Day.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>the love of father is like a mountain  父爱如山</p>
</blockquote>
<p><a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#module-binascii" target="_blank" rel="noopener"><code>binascii</code></a> 模块包含很多在二进制和二进制表示的各种ASCII码之间转换的方法。 通常情况不会直接使用这些函数，而是使用像 <a href="https://docs.python.org/zh-cn/3.8/library/uu.html#module-uu" target="_blank" rel="noopener"><code>uu</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/base64.html#module-base64" target="_blank" rel="noopener"><code>base64</code></a> ，或 <a href="https://docs.python.org/zh-cn/3.8/library/binhex.html#module-binhex" target="_blank" rel="noopener"><code>binhex</code></a> 这样的封装模块。 为了执行效率高，<a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#module-binascii" target="_blank" rel="noopener"><code>binascii</code></a> 模块含有许多用 C 写的低级函数，这些底层函数被一些高级模块所使用。</p>
<blockquote>
<p> <code>a2b_*</code> 函数接受只含有 ASCII 码的Unicode 字符串。其他函数只接受 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> （例如 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 和其他支持缓冲区协议的对象）。</p>
</blockquote>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p><code>binascii.a2b_uu</code>(<em>string</em>)</p>
<p>将单行 uu 编码数据转换成二进制数据并返回。uu 编码每行的数据通常包含45 个（二进制）字节，最后一行除外。每行数据后面可能跟有空格。</p>
</li>
<li><p><code>binascii.b2a_uu</code>(<em>data</em>, <em>**, </em>backtick=False*)</p>
<p>将二进制数据转换为 ASCII 编码字符，返回值是转换后的行数据，包括换行符。 <em>data</em> 的长度最多为45。如果 <em>backtick</em> 为ture，则零由 <code>&#39;</code>‘` 而不是空格表示。<em>在 3.7 版更改:</em> 增加 <em>backtick</em> 形参。</p>
</li>
<li><p><code>binascii.a2b_base64</code>(<em>string</em>)</p>
<p>将 base64 数据块转换成二进制并以二进制数据形式返回。一次可以传递多行数据。</p>
</li>
<li><p><code>binascii.b2a_base64</code>(<em>data</em>, <em>**, </em>newline=True*)</p>
<p>将二进制数据转换为一行用 base64 编码的ASCII字符串。返回值是转换后的行数据，如果 <em>newline</em> 为true，则返回值包括换行符。该函数的输出符合：rfc：3548。<em>在 3.6 版更改:</em> 增加 <em>newline</em> 形参。</p>
</li>
<li><p><code>binascii.a2b_qp</code>(<em>data</em>, <em>header=False</em>)</p>
<p>将一个引号可打印的数据块转换成二进制数据并返回。一次可以转换多行。如果可选参数 <em>header</em> 存在且为true，则数据中的下划线将被解码成空格。</p>
</li>
<li><p><code>binascii.b2a_qp</code>(<em>data</em>, <em>quotetabs=False</em>, <em>istext=True</em>, <em>header=False</em>)</p>
<p>将二进制数据转换为一行或多行带引号可打印编码的ASCII字符串。返回值是转换后的行数据。如果可选参数 <em>quotetabs</em> 存在且为真值，则对所有制表符和空格进行编码。如果可选参数 <em>istext</em> 存在且为真值，则不对新行进行编码，但将对尾随空格进行编码。如果可选参数 <em>header</em> 存在且为true，则空格将被编码为下划线 <a href="https://tools.ietf.org/html/rfc1522.html" target="_blank" rel="noopener"><strong>RFC 1522</strong></a>。如果可选参数 <em>header</em> 存在且为假值，则也会对换行符进行编码;不进行换行转换编码可能会破坏二进制数据流。</p>
</li>
<li><p><code>binascii.a2b_hqx</code>(<em>string</em>)</p>
<p>将 binhex4 格式的 ASCII 数据不进行 RLE 解压缩直接转换为二进制数据。该字符串应包含完整数量的二进制字节，或者（在binhex4 数据最后部分）剩余位为零。</p>
</li>
<li><p><code>binascii.rledecode_hqx</code>(<em>data</em>)</p>
<p>根据 binhex4 标准对数据执行 RLE 解压缩。该算法在一个字节的数据后使用 <code>0x90</code> 作为重复指示符，然后计数。计数 <code>0</code> 指定字节值 <code>0x90</code> 。该例程返回解压缩的数据，输入数据以孤立的重复指示符结束的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#binascii.Incomplete" target="_blank" rel="noopener"><code>Incomplete</code></a> 异常。<em>在 3.2 版更改:</em> 仅接受 bytestring 或 bytearray 对象作为输入。</p>
</li>
<li><p><code>binascii.rlecode_hqx</code>(<em>data</em>)</p>
<p>在 <em>data</em> 上执行 binhex4 游程编码压缩并返回结果。</p>
</li>
<li><p><code>binascii.b2a_hqx</code>(<em>data</em>)</p>
<p>执行 hexbin4 类型二进制到 ASCII 码的转换并返回结果字符串。输入数据应经过 RLE 编码，且数据长度可被3整除（除了最后一个片段）。</p>
</li>
<li><p><code>binascii.crc_hqx</code>(<em>data</em>, <em>value</em>)</p>
<p>以 <em>value</em> 作为初始 CRC 计算 <em>data</em> 的16位 CRC 值，返回其结果。这里使用 CRC-CCITT 生成多项式 <em>x</em>16 + <em>x</em>12 + <em>x</em>5 + 1 ，通常表示为0x1021。该 CRC 被用于 binhex4 格式。</p>
</li>
<li><p><code>binascii.crc32</code>(<em>data</em>[, <em>value</em>])</p>
<p>计算 CRC-32 ，从 <em>value</em> 的初始 CRC 开始计算 <em>data</em> 的32位校验和。默认初始 CRC 为零。该算法与 ZIP 文件校验和一致。由于该算法被设计用作校验和算法，因此不适合用作通用散列算法。使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(binascii.crc32(<span class="string">b"hello world"</span>))</span><br><span class="line"><span class="comment"># Or, in two pieces:</span></span><br><span class="line">crc = binascii.crc32(<span class="string">b"hello"</span>)</span><br><span class="line">crc = binascii.crc32(<span class="string">b" world"</span>, crc)</span><br><span class="line">print(<span class="string">'crc32 = &#123;:#010x&#125;'</span>.format(crc))</span><br></pre></td></tr></table></figure>
<p><em>在 3.0 版更改:</em> 校验结果始终是无符号类型的。要在所有Python版本和平台上生成相同的数值，请使用 <code>crc32(data) &amp; 0xffffffff</code> 。</p>
</li>
<li><p><code>binascii.b2a_hex</code>(<em>data</em>[, <em>sep</em>[, <em>bytes_per_sep=1</em>]])</p>
</li>
<li><p><code>binascii.hexlify</code>(<em>data</em>[, <em>sep</em>[, <em>bytes_per_sep=1</em>]])</p>
<p>返回二进制数据 <em>data</em> 的十六进制表示形式。 <em>data</em> 的每个字节都被转换为相应的2位十六进制表示形式。因此返回的字节对象的长度是 <em>data</em> 的两倍。</p>
<p>使用：<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes.hex" target="_blank" rel="noopener"><code>bytes.hex()</code></a> 方法也可以方便地实现相似的功能（但仅返回文本字符串）。</p>
<p>如果指定了 <em>sep</em>，它必须为单字符 str 或 bytes 对象。 它将被插入每个 <em>bytes_per_sep</em> 输入字节之后。 分隔符位置默认从输出的右端开始计数，如果你希望从左端开始计数，请提供一个负的 <em>bytes_per_sep</em> 值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> binascii</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.b2a_hex(<span class="string">b'\xb9\x01\xef'</span>)</span><br><span class="line"><span class="string">b'b901ef'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.hexlify(<span class="string">b'\xb9\x01\xef'</span>, <span class="string">'-'</span>)</span><br><span class="line"><span class="string">b'b9-01-ef'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.b2a_hex(<span class="string">b'\xb9\x01\xef'</span>, <span class="string">b'_'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">b'b9_01ef'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.b2a_hex(<span class="string">b'\xb9\x01\xef'</span>, <span class="string">b' '</span>, <span class="number">-2</span>)</span><br><span class="line"><span class="string">b'b901 ef'</span></span><br></pre></td></tr></table></figure>
<p><em>在 3.8 版更改:</em> 添加了 <em>sep</em> 和 <em>bytes_per_sep</em> 形参。</p>
</li>
<li><p><code>binascii.a2b_hex</code>(<em>hexstr</em>)</p>
</li>
<li><p><code>binascii.unhexlify</code>(<em>hexstr</em>)</p>
<p>返回由十六进制字符串 <em>hexstr</em> 表示的二进制数据。此函数功能与 <a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#binascii.b2a_hex" target="_blank" rel="noopener"><code>b2a_hex()</code></a> 相反。 <em>hexstr</em> 必须包含偶数个十六进制数字（可以是大写或小写），否则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#binascii.Error" target="_blank" rel="noopener"><code>Error</code></a> 异常。</p>
<p>使用：<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes.fromhex" target="_blank" rel="noopener"><code>bytes.fromhex()</code></a> 类方法也实现相似的功能（仅接受文本字符串参数，不限制其中的空白字符）。</p>
</li>
<li><p><em>exception</em> <code>binascii.Error</code></p>
<p>通常是因为编程错误引发的异常。</p>
</li>
<li><p><em>exception</em> <code>binascii.Incomplete</code></p>
<p>数据不完整引发的异常。通常不是编程错误导致的，可以通过读取更多的数据并再次尝试来处理该异常。</p>
</li>
</ul>
<blockquote>
<p>参见:</p>
<p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/base64.html#module-base64" target="_blank" rel="noopener"><code>base64</code></a></p>
<p>支持在16，32，64，85进制中进行符合 RFC 协议的 base64 样式编码。</p>
<p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/binhex.html#module-binhex" target="_blank" rel="noopener"><code>binhex</code></a></p>
<p>支持在 Macintosh 上使用的 binhex 格式。</p>
<p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/uu.html#module-uu" target="_blank" rel="noopener"><code>uu</code></a></p>
<p>支持在 Unix 上使用的 UU 编码。</p>
<p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/quopri.html#module-quopri" target="_blank" rel="noopener"><code>quopri</code></a></p>
<p>支持在 MIME 版本电子邮件中使用引号可打印编码。</p>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment"># 导入binascii模块</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"> </span><br><span class="line">a = <span class="string">b'BE27E8FFFF010203'</span></span><br><span class="line"><span class="comment"># 先把b'BE27E8FFFF010203'转换成二进制数据然后在用十六进制表示</span></span><br><span class="line">b = binascii.b2a_hex(a)</span><br><span class="line"><span class="comment"># 打印出：b'42453237453846464646303130323033'，例如B对应ascii码42，E对应ascii码45</span></span><br><span class="line">print(b)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 与b2a_hex相反，打印出：b'BE27E8FFFF010203'</span></span><br><span class="line">print(binascii.a2b_hex(b))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个功能和b2a_hex()一样</span></span><br><span class="line"><span class="comment"># 打印出：b'42453237453846464646303130323033'，例如B对应ascii码42，E对应ascii码45</span></span><br><span class="line">c = binascii.hexlify(a)</span><br><span class="line">print(c)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个功能和a2b_hex()一样，打印出：b'BE27E8FFFF010203'</span></span><br><span class="line">print(binascii.unhexlify(c))</span><br></pre></td></tr></table></figure>
<h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">a = <span class="string">'hello world'</span></span><br><span class="line"><span class="comment">#先把a转换成二进制数据然后在用十六进制表示</span></span><br><span class="line">b = binascii.b2a_hex(a)</span><br><span class="line">c = binascii.hexlify(a)<span class="comment">#和a2b_hex()功能是一样的,但是推荐用这个函数,具体不清楚= =</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;0:10s&#125;'</span>.format(<span class="string">'b2a_hex'</span>),</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(b),<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">print</span> b[i:i+<span class="number">2</span>],</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#到这是不是发现了,利用b2a_hex()返回的字符串长度为原串的两倍,因为转换为十六进制,一个字节用两个字节表示了</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;0:10s&#125;'</span>.format(<span class="string">'hexlify'</span>),</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(c),<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">print</span> c[i:i+<span class="number">2</span>],   </span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;0:10s&#125;'</span>.format(<span class="string">'ord'</span>),</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">print</span> hex(ord(i))[<span class="number">2</span>:],<span class="comment">#手动转换为二进制十六进制</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#与b2a_hex相反</span></span><br><span class="line"><span class="keyword">print</span> binascii.a2b_hex(b)</span><br><span class="line"><span class="keyword">print</span> binascii.unhexlify(c)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">result:</span></span><br><span class="line"><span class="string">b2a_hex    68 65 6c 6c 6f 20 77 6f 72 6c 64</span></span><br><span class="line"><span class="string">hexlify    68 65 6c 6c 6f 20 77 6f 72 6c 64</span></span><br><span class="line"><span class="string">ord        68 65 6c 6c 6f 20 77 6f 72 6c 64</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">d1 = datetime.datetime(<span class="number">2019</span>,<span class="number">4</span>,<span class="number">7</span>)</span><br><span class="line">d2 = datetime.datetime(<span class="number">2020</span>,<span class="number">2</span>,<span class="number">24</span>)</span><br><span class="line">print(d2-d1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>父亲离开我已经过去了323天。</p>
<p>今天整理云盘,发现了父亲的照片。</p>
<p>心里很难受。</p>
<p>父亲平时少言寡语。不太喜欢和我们交流。</p>
<p>最后一次和父亲聊天,是19年3月底,医院住院的时候。</p>
<p>他说:鑫儿,昨天大夫查房和说我了,我是个定时炸弹,随时都会爆发。栓塞已经不是主要问题了。指了指心。这里是大问题。这个3到5分钟就过去了。父亲顿了顿,继续说：存着都在你妈那里，我要是万一哪天过去了,就找你妈要,你和你姐都有份,你姐身体不好,孩子还上大学,你就多让点你姐,你还年轻,以后还有机会赚钱。</p>
<p>我调侃道：您这是要交代后事啊?</p>
<p>父亲说,对啊，现在说了,我就了心思了。能活一天算一天。</p>
<p>我不知道该说些什么。只能扶着父亲在医院走廊里继续走啊，走啊。</p>
<p>想起我小时候拉着父亲的手过马路的情形。和这时候差不多。父亲的腿因为栓塞，没有劲,需要拄着拐杖才能慢慢挪动脚步。</p>
<p>谁能想到这次谈话,竟是永别。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>python standard library shutil</title>
    <url>/2020/02/19/python-standard-library-shutil/</url>
    <content><![CDATA[<h1 id="python-标准库-shutil-高阶文件操作"><a href="#python-标准库-shutil-高阶文件操作" class="headerlink" title="python 标准库 shutil 高阶文件操作"></a>python 标准库 shutil 高阶文件操作</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200219python3_sheet.png?raw=true" alt></p>
<a id="more"></a>
<p>收集了一些网上找到的学习python的资源,分享给大家。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/shutil.py" target="_blank" rel="noopener">Lib/shutil.py</a></p>
<hr>
<p><a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 模块提供了一系列对文件和文件集合的高阶操作。 特别是提供了一些支持文件拷贝和删除的函数。 对于单个文件的操作，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块。</p>
<blockquote>
<p>警告：即便是高阶文件拷贝函数 (<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>shutil.copy()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>shutil.copy2()</code></a>) 也无法拷贝所有的文件元数据。</p>
<p>在 POSIX 平台上，这意味着将丢失文件所有者和组以及 ACL 数据。 在 Mac OS 上，资源钩子和其他元数据不被使用。 这意味着将丢失这些资源并且文件类型和创建者代码将不正确。 在 Windows 上，将不会拷贝文件所有者、ACL 和替代数据流。</p>
</blockquote>
<h2 id="目录和文件操作"><a href="#目录和文件操作" class="headerlink" title="目录和文件操作"></a>目录和文件操作</h2><ul>
<li><p><code>shutil.copyfileobj</code>(<em>fsrc</em>, <em>fdst</em>[, <em>length</em>])</p>
<p>将文件类对象 <em>fsrc</em> 的内容拷贝到文件类对象 <em>fdst</em>。 整数值 <em>length</em> 如果给出则为缓冲区大小。 特别地， <em>length</em> 为负值表示拷贝数据时不对源数据进行分块循环处理；默认情况下会分块读取数据以避免不受控制的内存消耗。 请注意如果 <em>fsrc</em> 对象的当前文件位置不为 0，则只有从当前文件位置到文件末尾的内容会被拷贝。</p>
</li>
<li><p><code>shutil.copyfile</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p>
<p>将名为 <em>src</em> 的文件的内容（不包括元数据）拷贝到名为 <em>dst</em> 的文件并以尽可能高效的方式返回 <em>dst</em>。 <em>src</em> 和 <em>dst</em> 均为路径类对象或以字符串形式给出的路径名。<em>dst</em> 必须是完整的目标文件名；对于接受目标目录路径的拷贝请参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a>。 如果 <em>src</em> 和 <em>dst</em> 指定了同一个文件，则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.SameFileError" target="_blank" rel="noopener"><code>SameFileError</code></a>。目标位置必须是可写的；否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。 如果 <em>dst</em> 已经存在，它将被替换。 特殊文件如字符或块设备以及管道无法用此函数来拷贝。如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则将创建一个新的符号链接而不是拷贝 <em>src</em> 所指向的文件。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 曾经是引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IOError" target="_blank" rel="noopener"><code>IOError</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>。 增加了 <em>follow_symlinks</em> 参数。 现在是返回 <em>dst</em>。<em>在 3.4 版更改:</em> 引发 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.SameFileError" target="_blank" rel="noopener"><code>SameFileError</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.Error" target="_blank" rel="noopener"><code>Error</code></a>。 由于前者是后者的子类，此改变是向后兼容的。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p>
</li>
<li><p><em>exception</em> <code>shutil.SameFileError</code></p>
<p>此异常会在 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfile" target="_blank" rel="noopener"><code>copyfile()</code></a> 中的源和目标为同一文件时被引发。<em>3.4 新版功能.</em></p>
</li>
<li><p><code>shutil.copymode</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p>
<p>从 <em>src</em> 拷贝权限位到 <em>dst</em>。 文件的内容、所有者和分组将不受影响。 <em>src</em> 和 <em>dst</em> 均为路径类对象或字符串形式的路径名。 如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均为符号链接，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copymode" target="_blank" rel="noopener"><code>copymode()</code></a> 将尝试修改 <em>dst</em> 本身的模式（而非它所指向的文件）。 此功能并不是在所有平台上均可用；请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 了解详情。 如果 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copymode" target="_blank" rel="noopener"><code>copymode()</code></a> 无法修改本机平台上的符号链接，而它被要求这样做，它将不做任何操作即返回。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copymode</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 加入 <em>follow_symlinks</em> 参数。</p>
</li>
<li><p><code>shutil.copystat</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p>
<p>从 <em>src</em> 拷贝权限位、最近访问时间、最近修改时间以及旗标到 <em>dst</em>。 在 Linux上，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 还会在可能的情况下拷贝“扩展属性”。 文件的内容、所有者和分组将不受影响。 <em>src</em> 和 <em>dst</em> 均为路径类对象或字符串形式的路径名。如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均指向符号链接，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 将作用于符号链接本身而非该符号链接所指向的文件 — 从 <em>src</em> 符号链接读取信息，并将信息写入 <em>dst</em> 符号链接。</p>
<blockquote>
<p>注解:</p>
<p>并非所有平台者提供检查和修改符号链接的功能。 Python 本身可以告诉你哪些功能是在本机上可用的。</p>
<ul>
<li>如果 <code>os.chmod in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 可以修改符号链接的权限位。</li>
<li>如果 <code>os.utime in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 可以修改符号链接的最近访问和修改时间。</li>
<li>如果 <code>os.chflags in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 可以修改符号链接的旗标。 (<code>os.chflags</code> 不是在所有平台上均可用。)</li>
</ul>
<p>在此功能部分或全部不可用的平台上，当被要求修改一个符号链接时，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 将尽量拷贝所有内容。 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 一定不会返回失败信息。</p>
<p>更多信息请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_follow_symlinks" target="_blank" rel="noopener"><code>os.supports_follow_symlinks</code></a>。</p>
</blockquote>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copystat</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p><em>在 3.3 版更改:</em> 添加了 <em>follow_symlinks</em> 参数并且支持 Linux 扩展属性。</p>
</li>
<li><p><code>shutil.copy</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p>
<p>将文件 <em>src</em> 拷贝到文件或目录 <em>dst</em>。 <em>src</em> 和 <em>dst</em> 应为字符串。 如果 <em>dst</em> 指定了一个目录，文件将使用 <em>src</em> 中的基准文件名拷贝到 <em>dst</em>。 返回新创建文件的路径。如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则 <em>dst</em> 也将被创建为符号链接。 如果 <em>follow_symlinks</em> 为真值且 <em>src</em> 为符号链接，<em>dst</em> 将成为 <em>src</em> 所指向的文件的一个副本。<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a> 会拷贝文件数据和文件的权限模式 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>os.chmod()</code></a>)。 其他元数据，例如文件的创建和修改时间不会被保留。 要保留所有原有的元数据，请改用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copymode</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 添加了 <em>follow_symlinks</em> 参数。 现在会返回新创建文件的路径。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p>
</li>
<li><p><code>shutil.copy2</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a>，区别在于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 还会尝试保留文件的元数据。当 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接时，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 会尝试将来自 <em>src</em> 符号链接的所有元数据拷贝到新创建的 <em>dst</em> 符号链接。 但是，此功能不是在所有平台上均可用。 在此功能部分或全部不可用的平台上，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 将尽量保留所有元数据；<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 一定不会由于无法保留文件元数据而引发异常。<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 会使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 来拷贝文件元数据。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 了解有关修改符号链接元数据的平台支持的更多信息。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copystat</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 添加了 <em>follow_symlinks</em> 参数，还会尝试拷贝扩展文件系统属性（目前仅限 Linux）。 现在会返回新创建文件的路径。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p>
</li>
<li><p><code>shutil.ignore_patterns</code>(*<em>patterns</em>)</p>
<p>这个工厂函数会创建一个函数，它可被用作 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 的 <em>ignore</em> 可调用对象参数，以忽略那些匹配所提供的 glob 风格的 <em>patterns</em> 之一的文件和目录。 参见以下示例。</p>
</li>
<li><p><code>shutil.copytree</code>(<em>src</em>, <em>dst</em>, <em>symlinks=False</em>, <em>ignore=None</em>, <em>copy_function=copy2</em>, <em>ignore_dangling_symlinks=False</em>, <em>dirs_exist_ok=False</em>)</p>
<p>将以 <em>src</em> 为根起点的整个目录树拷贝到名为 <em>dst</em> 的目录并返回目标目录。 <em>dirs_exist_ok</em> 指明是否要在 <em>dst</em> 或任何丢失的父目录已存在的情况下引发异常。目录的权限和时间会通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 来拷贝，单个文件则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 来拷贝。如果 <em>symlinks</em> 为真值，源目录树中的符号链接会在新目录树中表示为符号链接，并且原链接的元数据在平台允许的情况下也会被拷贝；如果为假值或省略，则会将被链接文件的内容和元数据拷贝到新目录树。当 <em>symlinks</em> 为假值时，如果符号链接所指向的文件不存在，则会在拷贝进程的末尾将一个异常添加到 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.Error" target="_blank" rel="noopener"><code>Error</code></a> 异常中的错误列表。 如果你希望屏蔽此异常那就将可选的 <em>ignore_dangling_symlinks</em> 旗标设为真值。 请注意此选项在不支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.symlink" target="_blank" rel="noopener"><code>os.symlink()</code></a> 的平台上将不起作用。如果给出了 <em>ignore</em>，它必须是一个可调用对象，该对象将接受 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 所访问的目录以及 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>os.listdir()</code></a> 所返回的目录内容列表作为其参数。 由于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 是递归地被调用的，<em>ignore</em> 可调用对象对于每个被拷贝目录都将被调用一次。 该可调用对象必须返回一个相对于当前目录的目录和文件名序列（即其第二个参数的子集）；随后这些名称将在拷贝进程中被忽略。 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.ignore_patterns" target="_blank" rel="noopener"><code>ignore_patterns()</code></a> 可被用于创建这种基于 glob 风格模式来忽略特定名称的可调用对象。如果发生了（一个或多个）异常，将引发一个附带原因列表的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.Error" target="_blank" rel="noopener"><code>Error</code></a>。如果给出了 <em>copy_function</em>，它必须是一个将被用来拷贝每个文件的可调用对象。 它在被调用时会将源路径和目标路径作为参数传入。 默认情况下，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 将被使用，但任何支持同样签名（与 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a> 一致）都可以使用。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copytree</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 当 <em>symlinks</em> 为假值时拷贝元数据。 现在会返回 <em>dst</em>。<em>在 3.2 版更改:</em> 添加了 <em>copy_function</em> 参数以允许提供定制的拷贝函数。 添加了 <em>ignore_dangling_symlinks</em> 参数以便在 <em>symlinks</em> 为假值时屏蔽符号链接错误。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。<em>3.8 新版功能:</em> <em>dirs_exist_ok</em> 形参。</p>
</li>
<li><p><code>shutil.rmtree</code>(<em>path</em>, <em>ignore_errors=False</em>, <em>onerror=None</em>)</p>
<p>删除一个完整的目录树；<em>path</em> 必须指向一个目录（但不能是一个目录的符号链接）。 如果 <em>ignore_errors</em> 为真值，删除失败导致的错误将被忽略；如果为假值或是省略，此类错误将通过调用由 <em>onerror</em> 所指定的处理程序来处理，或者如果此参数被省略则将引发一个异常。</p>
<blockquote>
<p>注解:</p>
<p>在支持必要的基于 fd 的函数的平台上，默认会使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree" target="_blank" rel="noopener"><code>rmtree()</code></a> 的可防御符号链接攻击的版本。 在其他平台上，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree" target="_blank" rel="noopener"><code>rmtree()</code></a> 较易遭受符号链接攻击：给定适当的时间和环境，攻击者可以操纵文件系统中的符号链接来删除他们在其他情况下无法访问的文件。 应用程序可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree.avoids_symlink_attacks" target="_blank" rel="noopener"><code>rmtree.avoids_symlink_attacks</code></a> 函数属性来确定此类情况具体是哪一些。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>shutil.move</code>(<em>src</em>, <em>dst</em>, <em>copy_function=copy2</em>)</p>
<p>递归地将一个文件或目录 (<em>src</em>) 移至另一位置 (<em>dst</em>) 并返回目标位置。如果目标是已存在的目录，则 <em>src</em> 会被移至该目录下。 如果目标已存在但不是目录，它可能会被覆盖，具体取决于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a> 的语义。如果目标是在当前文件系统中，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a>。 在其他情况下，<em>src</em> 将被拷贝至 <em>dst</em>，使用的函数为 <em>copy_function</em>，然后目标会被移除。 对于符号链接，则将在 <em>dst</em> 之下或以其本身为名称创建一个指向 <em>src</em> 目标的新符号链接，并且 <em>src</em> 将被移除。如果给出了 <em>copy_function</em>，则它必须为接受两个参数 <em>src</em> 和 <em>dst</em> 的可调用对象，并会在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a> 无法使用时被用来将 <em>src</em> 拷贝到 <em>dest</em>。 如果源位置是一个目录，则会调用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a>，并向它传入 <code>copy_function()</code>。 默认的 <em>copy_function</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a>。 使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a> 作为 <em>copy_function</em> 允许在无法附带拷贝元数据时让移动操作成功执行，但其代价是不拷贝任何元数据。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.move</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 为异类文件系统添加了显式的符号链接处理，以便使它适应 GNU 的 <strong>mv</strong> 的行为。 现在会返回 <em>dst</em>。<em>在 3.5 版更改:</em> 增加了 <em>copy_function</em> 关键字参数。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p>
</li>
<li><p><code>shutil.disk_usage</code>(<em>path</em>)</p>
<p>返回给定路径的磁盘使用统计数据，形式为一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-named-tuple" target="_blank" rel="noopener">named tuple</a>，其中包含 <em>total</em>, <em>used</em> 和 <em>free</em> 属性，分别表示总计、已使用和未使用空间的字节数。 <em>path</em> 可以是一个文件或是一个目录。<em>3.3 新版功能.**在 3.8 版更改:</em> 在 Windows 上，<em>path</em> 现在可以是一个文件或目录。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p>
</li>
<li><p><code>shutil.chown</code>(<em>path</em>, <em>user=None</em>, <em>group=None</em>)</p>
<p>修改给定 <em>path</em> 的所有者 <em>user</em> 和/或 <em>group</em>。<em>user</em> 可以是一个系统用户名或 uid；<em>group</em> 同样如此。 要求至少有一个参数。另请参阅下层的函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chown" target="_blank" rel="noopener"><code>os.chown()</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.chown</code> 附带参数 <code>path</code>, <code>user</code>, <code>group</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">Availability</a>: Unix.<em>3.3 新版功能.</em></p>
</li>
<li><p><code>shutil.which</code>(<em>cmd</em>, <em>mode=os.F_OK | os.X_OK</em>, <em>path=None</em>)</p>
<p>返回当给定的 <em>cmd</em> 被调用时将要运行的可执行文件的路径。 如果没有 <em>cmd</em> 会被调用则返回 <code>None</code>。<em>mode</em> 是一个传递给 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>os.access()</code></a> 的权限掩码，在默认情况下将确定文件是否存在并且为可执行文件。当未指定 <em>path</em> 时，将会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>os.environ()</code></a> 的结果，返回 “PATH” 的值或回退为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.defpath" target="_blank" rel="noopener"><code>os.defpath</code></a>。在 Windows 上当前目录总是会被添加为 <em>path</em> 的第一项，无论你是否使用默认值或提供你自己的路径，这是命令行终端在查找可执行文件时所采用的行为方式。 此外，当在 <em>path</em> 中查找 <em>cmd</em> 时，还会检查 <code>PATHEXT</code> 环境变量。 例如，如果你调用 <code>shutil.which(&quot;python&quot;)</code>，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.which" target="_blank" rel="noopener"><code>which()</code></a> 将搜索 <code>PATHEXT</code> 来确定它要在 <em>path</em> 目录中查找 <code>python.exe</code>。 例如，在 Windows 上:&gt;&gt;&gt;<code>&gt;&gt;&gt; shutil.which(&quot;python&quot;) &#39;C:\\Python33\\python.EXE&#39;</code><em>3.3 新版功能.**在 3.8 版更改:</em> 现在可以接受 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型。 如果 <em>cmd</em> 的类型为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>，结果的类型也将为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>。</p>
</li>
<li><p><em>exception</em> <code>shutil.Error</code></p>
<p>此异常会收集在多文件操作期间所引发的异常。 对于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a>，此异常参数将是一个由三元组 (<em>srcname</em>, <em>dstname</em>, <em>exception</em>) 构成的列表。</p>
</li>
</ul>
<h2 id="依赖于具体平台的高效拷贝操作"><a href="#依赖于具体平台的高效拷贝操作" class="headerlink" title="依赖于具体平台的高效拷贝操作"></a>依赖于具体平台的高效拷贝操作</h2><p>从 Python 3.8 开始，所有涉及文件拷贝的函数 (<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfile" target="_blank" rel="noopener"><code>copyfile()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#module-copy" target="_blank" rel="noopener"><code>copy()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a>, 以及 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.move" target="_blank" rel="noopener"><code>move()</code></a>) 将会使用平台专属的 “fast-copy” 系统调用以便更高效地拷贝文件 (参见 <a href="https://bugs.python.org/issue33671" target="_blank" rel="noopener">bpo-33671</a>)。 “fast-copy” 意味着拷贝操作将发生于内核之中，避免像在 “<code>outfd.write(infd.read())</code>“ 中那样使用用户空间的缓冲区。</p>
<p>在 macOS 上将会使用 <a href="http://www.manpagez.com/man/3/copyfile/" target="_blank" rel="noopener">fcopyfile</a> 来拷贝文件内容（不含元数据）。</p>
<p>在 Linux 上将会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sendfile" target="_blank" rel="noopener"><code>os.sendfile()</code></a>。</p>
<p>在 Windows 上 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfile" target="_blank" rel="noopener"><code>shutil.copyfile()</code></a> 将会使用更大的默认缓冲区（1 MiB 而非 64 KiB）并且会使用基于 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview()</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfileobj" target="_blank" rel="noopener"><code>shutil.copyfileobj()</code></a> 变种形式。</p>
<p>如果快速拷贝操作失败并且没有数据被写入目标文件，则 shutil 将在内部静默地回退到使用效率较低的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfileobj" target="_blank" rel="noopener"><code>copyfileobj()</code></a> 函数。</p>
<p><em>在 3.8 版更改.</em></p>
<h3 id="copytree-示例"><a href="#copytree-示例" class="headerlink" title="copytree 示例"></a>copytree 示例</h3><p>这个示例就是上面所描述的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 函数的实现，其中省略了文档字符串。 它还展示了此模块所提供的许多其他函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copytree</span><span class="params">(src, dst, symlinks=False)</span>:</span></span><br><span class="line">    names = os.listdir(src)</span><br><span class="line">    os.makedirs(dst)</span><br><span class="line">    errors = []</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        srcname = os.path.join(src, name)</span><br><span class="line">        dstname = os.path.join(dst, name)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> symlinks <span class="keyword">and</span> os.path.islink(srcname):</span><br><span class="line">                linkto = os.readlink(srcname)</span><br><span class="line">                os.symlink(linkto, dstname)</span><br><span class="line">            <span class="keyword">elif</span> os.path.isdir(srcname):</span><br><span class="line">                copytree(srcname, dstname, symlinks)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                copy2(srcname, dstname)</span><br><span class="line">            <span class="comment"># XXX What about devices, sockets etc.?</span></span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> why:</span><br><span class="line">            errors.append((srcname, dstname, str(why)))</span><br><span class="line">        <span class="comment"># catch the Error from the recursive copytree so that we can</span></span><br><span class="line">        <span class="comment"># continue with other files</span></span><br><span class="line">        <span class="keyword">except</span> Error <span class="keyword">as</span> err:</span><br><span class="line">            errors.extend(err.args[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        copystat(src, dst)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> why:</span><br><span class="line">        <span class="comment"># can't copy file access times on Windows</span></span><br><span class="line">        <span class="keyword">if</span> why.winerror <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            errors.extend((src, dst, str(why)))</span><br><span class="line">    <span class="keyword">if</span> errors:</span><br><span class="line">        <span class="keyword">raise</span> Error(errors)</span><br></pre></td></tr></table></figure>
<p>另一个使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.ignore_patterns" target="_blank" rel="noopener"><code>ignore_patterns()</code></a> 辅助函数的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree, ignore_patterns</span><br><span class="line"></span><br><span class="line">copytree(source, destination, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br></pre></td></tr></table></figure>
<p>这将会拷贝除 <code>.pyc</code> 文件和以 <code>tmp</code> 打头的文件或目录以外的所有条目.</p>
<p>另一个使用 <em>ignore</em> 参数来添加记录调用的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_logpath</span><span class="params">(path, names)</span>:</span></span><br><span class="line">    logging.info(<span class="string">'Working in %s'</span>, path)</span><br><span class="line">    <span class="keyword">return</span> []   <span class="comment"># nothing will be ignored</span></span><br><span class="line"></span><br><span class="line">copytree(source, destination, ignore=_logpath)</span><br></pre></td></tr></table></figure>
<h3 id="rmtree-示例"><a href="#rmtree-示例" class="headerlink" title="rmtree 示例"></a>rmtree 示例</h3><p>这个例子演示了如何在 Windows 上删除一个目录树，其中部分文件设置了只读属性位。 它会使用 onerror 回调函数来清除只读属性位并再次尝试删除。 任何后续的失败都将被传播。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os, stat</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_readonly</span><span class="params">(func, path, _)</span>:</span></span><br><span class="line">    <span class="string">"Clear the readonly bit and reattempt the removal"</span></span><br><span class="line">    os.chmod(path, stat.S_IWRITE)</span><br><span class="line">    func(path)</span><br><span class="line"></span><br><span class="line">shutil.rmtree(directory, onerror=remove_readonly)</span><br></pre></td></tr></table></figure>
<h2 id="归档操作"><a href="#归档操作" class="headerlink" title="归档操作"></a>归档操作</h2><p><em>3.2 新版功能.</em></p>
<p><em>在 3.5 版更改:</em> 添加了对 <em>xztar</em> 格式的支持。</p>
<p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <a href="https://docs.python.org/zh-cn/3.8/library/zipfile.html#module-zipfile" target="_blank" rel="noopener"><code>zipfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tarfile.html#module-tarfile" target="_blank" rel="noopener"><code>tarfile</code></a> 模块。</p>
<ul>
<li><p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p>
<p>创建一个归档文件（例如 zip 或 tar）并返回其名称。<em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “tar”, “gztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “bztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用) 或 “xztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用) 中的一个。<em>root_dir</em> 是一个目录，它将作为归档文件的根目录；例如，我们通常会在创建归档文件之前用 chdir 命令切换到 <em>root_dir</em>。<em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档文件中所有文件和目录共有的路径前缀。<em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。<em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。<em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logging.Logger" target="_blank" rel="noopener"><code>logging.Logger</code></a> 的实例。<em>verbose</em> 参数已不再使用并进入弃用状态。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。<em>在 3.8 版更改:</em> 现在对于通过 <code>format=&quot;tar&quot;</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p>
</li>
<li><p><code>shutil.get_archive_formats</code>()</p>
<p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_archive_format" target="_blank" rel="noopener"><code>register_archive_format()</code></a> 注册新的格式或为任何现有格式提供你自己的归档器。</p>
</li>
<li><p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p>
<p>为 <em>name</em> 格式注册一个归档器。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name</em>，再加上要归档内容的 <em>base_dir</em> (其默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.make_archive" target="_blank" rel="noopener"><code>make_archive()</code></a> 传入的参数一致)。如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。<em>description</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_archive_formats" target="_blank" rel="noopener"><code>get_archive_formats()</code></a> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p>
</li>
<li><p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p>
<p>从支持的格式中移除归档格式 <em>name</em>。</p>
</li>
<li><p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p>
<p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。<em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。<em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册的其他格式。 如果未提供，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.unpack_archive" target="_blank" rel="noopener"><code>unpack_archive()</code></a> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。<em>在 3.7 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a> 作为 <em>filename</em> 和 <em>extract_dir</em>。</p>
</li>
<li><p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p>
<p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。可以提供 <em>description</em> 来描述该格式，它将被 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_unpack_formats" target="_blank" rel="noopener"><code>get_unpack_formats()</code></a> 返回。</p>
</li>
<li><p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p>
<p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p>
</li>
<li><p><code>shutil.get_unpack_formats</code>()</p>
<p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。<em>tar</em>: 未压缩的 tar 文件。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册新的格式或为任何现有格式提供你自己的解包器。</p>
</li>
</ul>
<p><em>3.2 新版功能.</em></p>
<p><em>在 3.5 版更改:</em> 添加了对 <em>xztar</em> 格式的支持。</p>
<p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <a href="https://docs.python.org/zh-cn/3.8/library/zipfile.html#module-zipfile" target="_blank" rel="noopener"><code>zipfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tarfile.html#module-tarfile" target="_blank" rel="noopener"><code>tarfile</code></a> 模块。</p>
<ul>
<li><p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p>
<p>创建一个归档文件（例如 zip 或 tar）并返回其名称。<em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “tar”, “gztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “bztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用) 或 “xztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用) 中的一个。<em>root_dir</em> 是一个目录，它将作为归档文件的根目录；例如，我们通常会在创建归档文件之前用 chdir 命令切换到 <em>root_dir</em>。<em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档文件中所有文件和目录共有的路径前缀。<em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。<em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。<em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logging.Logger" target="_blank" rel="noopener"><code>logging.Logger</code></a> 的实例。<em>verbose</em> 参数已不再使用并进入弃用状态。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。<em>在 3.8 版更改:</em> 现在对于通过 <code>format=&quot;tar&quot;</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p>
</li>
<li><p><code>shutil.get_archive_formats</code>()</p>
<p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_archive_format" target="_blank" rel="noopener"><code>register_archive_format()</code></a> 注册新的格式或为任何现有格式提供你自己的归档器。</p>
</li>
<li><p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p>
<p>为 <em>name</em> 格式注册一个归档器。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name</em>，再加上要归档内容的 <em>base_dir</em> (其默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.make_archive" target="_blank" rel="noopener"><code>make_archive()</code></a> 传入的参数一致)。如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。<em>description</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_archive_formats" target="_blank" rel="noopener"><code>get_archive_formats()</code></a> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p>
</li>
<li><p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p>
<p>从支持的格式中移除归档格式 <em>name</em>。</p>
</li>
<li><p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p>
<p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。<em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。<em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册的其他格式。 如果未提供，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.unpack_archive" target="_blank" rel="noopener"><code>unpack_archive()</code></a> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。<em>在 3.7 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a> 作为 <em>filename</em> 和 <em>extract_dir</em>。</p>
</li>
<li><p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p>
<p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。可以提供 <em>description</em> 来描述该格式，它将被 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_unpack_formats" target="_blank" rel="noopener"><code>get_unpack_formats()</code></a> 返回。</p>
</li>
<li><p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p>
<p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p>
</li>
<li><p><code>shutil.get_unpack_formats</code>()</p>
<p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。<em>tar</em>: 未压缩的 tar 文件。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册新的格式或为任何现有格式提供你自己的解包器。</p>
</li>
</ul>
<p><em>3.2 新版功能.</em></p>
<p><em>在 3.5 版更改:</em> 添加了对 <em>xztar</em> 格式的支持。</p>
<p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <a href="https://docs.python.org/zh-cn/3.8/library/zipfile.html#module-zipfile" target="_blank" rel="noopener"><code>zipfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tarfile.html#module-tarfile" target="_blank" rel="noopener"><code>tarfile</code></a> 模块。</p>
<ul>
<li><p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p>
<p>创建一个归档文件（例如 zip 或 tar）并返回其名称。<em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “tar”, “gztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “bztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用) 或 “xztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用) 中的一个。<em>root_dir</em> 是一个目录，它将作为归档文件的根目录；例如，我们通常会在创建归档文件之前用 chdir 命令切换到 <em>root_dir</em>。<em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档文件中所有文件和目录共有的路径前缀。<em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。<em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。<em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logging.Logger" target="_blank" rel="noopener"><code>logging.Logger</code></a> 的实例。<em>verbose</em> 参数已不再使用并进入弃用状态。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。<em>在 3.8 版更改:</em> 现在对于通过 <code>format=&quot;tar&quot;</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p>
</li>
<li><p><code>shutil.get_archive_formats</code>()</p>
<p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_archive_format" target="_blank" rel="noopener"><code>register_archive_format()</code></a> 注册新的格式或为任何现有格式提供你自己的归档器。</p>
</li>
<li><p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p>
<p>为 <em>name</em> 格式注册一个归档器。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name</em>，再加上要归档内容的 <em>base_dir</em> (其默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.make_archive" target="_blank" rel="noopener"><code>make_archive()</code></a> 传入的参数一致)。如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。<em>description</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_archive_formats" target="_blank" rel="noopener"><code>get_archive_formats()</code></a> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p>
</li>
<li><p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p>
<p>从支持的格式中移除归档格式 <em>name</em>。</p>
</li>
<li><p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p>
<p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。<em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。<em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册的其他格式。 如果未提供，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.unpack_archive" target="_blank" rel="noopener"><code>unpack_archive()</code></a> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。<em>在 3.7 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a> 作为 <em>filename</em> 和 <em>extract_dir</em>。</p>
</li>
<li><p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p>
<p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。可以提供 <em>description</em> 来描述该格式，它将被 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_unpack_formats" target="_blank" rel="noopener"><code>get_unpack_formats()</code></a> 返回。</p>
</li>
<li><p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p>
<p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p>
</li>
<li><p><code>shutil.get_unpack_formats</code>()</p>
<p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。<em>tar</em>: 未压缩的 tar 文件。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册新的格式或为任何现有格式提供你自己的解包器。</p>
</li>
</ul>
<h3 id="归档程序示例"><a href="#归档程序示例" class="headerlink" title="归档程序示例"></a>归档程序示例</h3><p>在这个示例中，我们创建了一个 gzip 压缩的 tar 归档文件，其中包含用户的 <code>.ssh</code> 目录下的所有文件:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> shutil <span class="keyword">import</span> make_archive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>archive_name = os.path.expanduser(os.path.join(<span class="string">'~'</span>, <span class="string">'myarchive'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root_dir = os.path.expanduser(os.path.join(<span class="string">'~'</span>, <span class="string">'.ssh'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>make_archive(archive_name, <span class="string">'gztar'</span>, root_dir)</span><br><span class="line"><span class="string">'/Users/tarek/myarchive.tar.gz'</span></span><br></pre></td></tr></table></figure>
<p>结果归档文件中包含有:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ tar -tzvf /Users/tarek/myarchive.tar.gz</span><br><span class="line">drwx------ tarek/staff       <span class="number">0</span> <span class="number">2010</span><span class="number">-02</span><span class="number">-01</span> <span class="number">16</span>:<span class="number">23</span>:<span class="number">40</span> ./</span><br><span class="line">-rw-r--r-- tarek/staff     <span class="number">609</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./authorized_keys</span><br><span class="line">-rwxr-xr-x tarek/staff      <span class="number">65</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./config</span><br><span class="line">-rwx------ tarek/staff     <span class="number">668</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_dsa</span><br><span class="line">-rwxr-xr-x tarek/staff     <span class="number">609</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_dsa.pub</span><br><span class="line">-rw------- tarek/staff    <span class="number">1675</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_rsa</span><br><span class="line">-rw-r--r-- tarek/staff     <span class="number">397</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_rsa.pub</span><br><span class="line">-rw-r--r-- tarek/staff   <span class="number">37192</span> <span class="number">2010</span><span class="number">-02</span><span class="number">-06</span> <span class="number">18</span>:<span class="number">23</span>:<span class="number">10</span> ./known_hosts</span><br></pre></td></tr></table></figure>
<h2 id="查询输出终端的尺寸"><a href="#查询输出终端的尺寸" class="headerlink" title="查询输出终端的尺寸"></a>查询输出终端的尺寸</h2><ul>
<li><p><code>shutil.get_terminal_size</code>(<em>fallback=(columns</em>, <em>lines)</em>)</p>
<p>获取终端窗口的尺寸。</p>
<p>对于两个维度中的每一个，会分别检查环境变量 <code>COLUMNS</code> 和 <code>LINES</code>。 如果定义了这些变量并且其值为正整数，则将使用这些值。</p>
<p>如果未定义 <code>COLUMNS</code> 或 <code>LINES</code>，这是通常的情况，则连接到 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.__stdout__" target="_blank" rel="noopener"><code>sys.__stdout__</code></a> 的终端将通过发起调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.get_terminal_size" target="_blank" rel="noopener"><code>os.get_terminal_size()</code></a> 被查询。</p>
<p>如果由于系统不支持查询，或是由于我们未连接到某个终端而导致查询终端尺寸不成功，则会使用在 <code>fallback</code> 形参中给出的值。 <code>fallback</code> 默认为 <code>(80, 24)</code>，这是许多终端模拟器所使用的默认尺寸。</p>
<p>返回的值是一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.terminal_size" target="_blank" rel="noopener"><code>os.terminal_size</code></a> 类型的具名元组。</p>
<p>另请参阅: The Single UNIX Specification, Version 2, <a href="http://pubs.opengroup.org/onlinepubs/7908799/xbd/envvar.html#tag_002_003" target="_blank" rel="noopener">Other Environment Variables</a>.</p>
<p><em>3.3 新版功能.</em></p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil主要API:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  shutil.copyfileobj(fsrc, fdst[, length=<span class="number">16</span>*<span class="number">1024</span>])    <span class="comment">#copy文件内容到另一个文件，可以copy指定大小的内容</span></span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>  shutil.copyfile(src,dst)   <span class="comment">#copy文件内容，是不是感觉上面的文件复制很麻烦？还需要自己手动用open函数打开文件，在这里就不需要了，事实上，copyfile调用了copyfileobj</span></span><br><span class="line"> </span><br><span class="line"><span class="number">3</span>  shutil.copymode(src,dst)   <span class="comment">#仅copy权限，不更改文件内容，组和用户。</span></span><br><span class="line"> </span><br><span class="line"><span class="number">4</span>  shutil.copystat(src,dst)    <span class="comment">#复制所有的状态信息，包括权限，组，用户，时间等</span></span><br><span class="line"> </span><br><span class="line"><span class="number">5</span>  shutil.copy(src,dst)   <span class="comment">#复制文件的内容以及权限，先copyfile后copymode</span></span><br><span class="line"> </span><br><span class="line"><span class="number">6</span>  shutil.copy2(src,dst)    <span class="comment">#复制文件的内容以及文件的所有状态信息。先copyfile后copystat</span></span><br><span class="line"> </span><br><span class="line"><span class="number">7</span>  shutil.copytree(src, dst, symlinks=<span class="literal">False</span>, ignore=<span class="literal">None</span>, copy_function=copy2,ignore_dangling_symlinks=<span class="literal">False</span>)   <span class="comment">#递归的复制文件内容及状态信息</span></span><br><span class="line"> </span><br><span class="line"><span class="number">8</span>  shutil.rmtree(path, ignore_errors=<span class="literal">False</span>, onerror=<span class="literal">None</span>)   <span class="comment">#递归地删除文件</span></span><br><span class="line"> </span><br><span class="line"><span class="number">9</span>  shutil.move(src, dst)    <span class="comment">#递归的移动文件</span></span><br><span class="line"> </span><br><span class="line"><span class="number">10</span>  make_archive(base_name, format, root_dir=<span class="literal">None</span>, base_dir=<span class="literal">None</span>, verbose=<span class="number">0</span>,dry_run=<span class="number">0</span>, owner=<span class="literal">None</span>, group=<span class="literal">None</span>, logger=<span class="literal">None</span>)  <span class="comment">#压缩打包</span></span><br><span class="line"> </span><br><span class="line">base_name：    压缩打包后的文件名或者路径名</span><br><span class="line"></span><br><span class="line">format：          压缩或者打包格式    <span class="string">"zip"</span>, <span class="string">"tar"</span>, <span class="string">"bztar"</span><span class="keyword">or</span> <span class="string">"gztar"</span></span><br><span class="line"></span><br><span class="line">root_dir :         将哪个目录或者文件打包（也就是源文件）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>shutil</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library Built-in Exception</title>
    <url>/2020/02/22/python-standard-library-Built-in-Exception/</url>
    <content><![CDATA[<h1 id="python-标准库-内置异常"><a href="#python-标准库-内置异常" class="headerlink" title="python 标准库 内置异常"></a>python 标准库 内置异常</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200221-happy-birthday.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>每日一词:</p>
<h1 id="worth"><a href="#worth" class="headerlink" title="worth"></a><strong>worth</strong></h1><p>n <strong>价值；意义；价值（十元、40 英镑等）的东西</strong></p>
<p>adj <strong>有…价值；值…钱；（指行动）值得；值得（费周折）</strong></p>
<p>web <strong>值得的；有……的价值；值…的</strong></p>
<p>短语:</p>
<p><strong>for all sb/it is worth</strong> 竭尽全力；拼命</p>
<p>for what its worth  非正式   （所说的只是个人意见）无论管不管用，不论好坏</p>
<p><strong>(the game is) not worth the candle</strong>  得不偿失<br>  <strong>not worth the paper its written/printed on</strong>  尤指 (法律上 )毫无价值</p>
<p>worth your/its salt   称职；胜任</p>
<p>worth sbs while    对…有好处（或用处）</p>
</blockquote>
<p>在 Python 中，所有异常必须为一个派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 的类的实例。 在带有提及一个特定类的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 子句的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句中，该子句也会处理任何派生自该类的异常类（但不处理 <em>它</em> 所派生出的异常类）。 通过子类化创建的两个不相关异常类永远是不等效的，既使它们具有相同的名称。</p>
<p>下面列出的内置异常可通过解释器或内置函数来生成。除非另有说明，它们都会具有一个提示导致错误详细原因的“关联值”。 这可以是一个字符串或由多个信息项（例如一个错误码和一个解释错误的字符串）组成的元组。 关联值通常会作为参数被传递给异常类的构造器。</p>
<p>用户代码可以引发内置异常。 这可被用于测试异常处理程序或报告错误条件，“就像” 在解释器引发了相同异常的情况时一样；但是请注意，没有任何机制能防止用户代码引发不适当的错误。</p>
<p>内置异常类可以被子类化以定义新的异常；鼓励程序员从 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 类或它的某个子类而不是从 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 来派生新的异常。 关于定义异常的更多信息可以在 Python 教程的 <a href="https://docs.python.org/zh-cn/3.8/tutorial/errors.html#tut-userexceptions" target="_blank" rel="noopener">用户自定义异常</a> 部分查看。</p>
<p>当在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句中引发（或重新引发）异常时，<code>__context__</code> 会被自动设为所捕获的最后一个异常；如果新的异常未被处理，则最终显示的回溯信息将包括原始的异常和最后的异常。</p>
<p>当引发一个新的异常（而不是简单地使用 <code>raise</code> 来重新引发当前在处理的异常）时，隐式的异常上下文可以通过使用带有 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#raise" target="_blank" rel="noopener"><code>raise</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 来补充一个显式的原因:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> new_exc <span class="keyword">from</span> original_exc</span><br></pre></td></tr></table></figure>
<p>跟在 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 之后的表达式必须为一个异常或 <code>None</code>。 它将在所引发的异常上被设置为 <code>__cause__</code>。 设置 <code>__cause__</code> 还会隐式地将 <code>__suppress_context__</code> 属性设为 <code>True</code>，这样使用 <code>raise new_exc from None</code> 可以有效地将旧异常替换为新异常来显示其目的 (例如将 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>)，同时让旧异常在 <code>__context__</code> 中保持可用状态以便在调试时进行内省。</p>
<p>除了异常本身的回溯以外，默认的回溯还会显示这些串连的异常。 <code>__cause__</code> 中的显式串连异常如果存在将总是显示。 <code>__context__</code> 中的隐式串连异常仅在 <code>__cause__</code> 为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 并且 <code>__suppress_context__</code> 为假值时显示。</p>
<p>不论在哪种情况下，异常本身总会在任何串连异常之后显示，以便回溯的最后一行总是显示所引发的最后一个异常。</p>
<h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><p>下列异常主要被用作其他异常的基类。</p>
<ul>
<li><p><em>exception</em> <code>BaseException</code></p>
<p>所有内置异常的基类。 它不应该被用户自定义类直接继承 (这种情况请使用 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a>)。 如果在此类的实例上调用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a>，则会返回实例的参数表示，或者当没有参数时返回空字符串。</p>
<ul>
<li><p><code>args</code></p>
<p>传给异常构造器的参数元组。 某些内置异常 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>) 接受特定数量的参数并赋予此元组中的元素特殊的含义，而其他异常通常只接受一个给出错误信息的单独字符串。</p>
</li>
<li><p><code>with_traceback</code>(<em>tb</em>)</p>
<p>此方法将 <em>tb</em> 设为异常的新回溯信息并返回该异常对象。 它通常以如下的形式在异常处理程序中使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">except</span> SomeException:</span><br><span class="line">    tb = sys.exc_info()[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">raise</span> OtherException(...).with_traceback(tb)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><em>exception</em> <code>Exception</code></p>
<p>所有内置的非系统退出类异常都派生自此类。 所有用户自定义异常也应当派生自此类。</p>
</li>
<li><p><em>exception</em> <code>ArithmeticError</code></p>
<p>此基类用于派生针对各种算术类错误而引发的内置异常: <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ZeroDivisionError" target="_blank" rel="noopener"><code>ZeroDivisionError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FloatingPointError" target="_blank" rel="noopener"><code>FloatingPointError</code></a>。</p>
</li>
<li><p><em>exception</em> <code>BufferError</code></p>
<p>当与 <a href="https://docs.python.org/zh-cn/3.8/c-api/buffer.html#bufferobjects" target="_blank" rel="noopener">缓冲区</a> 相关的操作无法执行时将被引发。</p>
</li>
<li><p><em>exception</em> <code>LookupError</code></p>
<p>此基类用于派生当映射或序列所使用的键或索引无效时引发的异常: <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。 这可以通过 <a href="https://docs.python.org/zh-cn/3.8/library/codecs.html#codecs.lookup" target="_blank" rel="noopener"><code>codecs.lookup()</code></a> 来直接引发。</p>
</li>
</ul>
<h2 id="具体异常"><a href="#具体异常" class="headerlink" title="具体异常"></a>具体异常</h2><p>以下异常属于经常被引发的异常。</p>
<ul>
<li><p><em>exception</em> <code>AssertionError</code></p>
<p>当 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#assert" target="_blank" rel="noopener"><code>assert</code></a> 语句失败时将被引发。</p>
</li>
<li><p><em>exception</em> <code>AttributeError</code></p>
<p>当属性引用 (参见 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#attribute-references" target="_blank" rel="noopener">属性引用</a>) 或赋值失败时将被引发。 （当一个对象根本不支持属性引用或属性赋值时则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。）</p>
</li>
<li><p><em>exception</em> <code>EOFError</code></p>
<p>当 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#input" target="_blank" rel="noopener"><code>input()</code></a> 函数未读取任何数据即达到文件结束条件 (EOF) 时将被引发。 （另外，<code>io.IOBase.read()</code> 和 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.readline" target="_blank" rel="noopener"><code>io.IOBase.readline()</code></a> 方法在遇到 EOF 则将返回一个空字符串。）</p>
</li>
<li><p><em>exception</em> <code>FloatingPointError</code></p>
<p>目前未被使用。</p>
</li>
<li><p><em>exception</em> <code>GeneratorExit</code></p>
<p>当一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 或 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 被关闭时将被引发；参见 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.close" target="_blank" rel="noopener"><code>generator.close()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine.close" target="_blank" rel="noopener"><code>coroutine.close()</code></a>。 它直接继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a>，因为从技术上来说它并不是一个错误。</p>
</li>
<li><p><em>exception</em> <code>ImportError</code></p>
<p>当 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句尝试加载模块遇到麻烦时将被引发。 并且当 <code>from ... import</code> 中的 “from list” 存在无法找到的名称时也会被引发。<code>name</code> 与 <code>path</code> 属性可通过对构造器使用仅关键字参数来设定。 设定后它们将分别表示被尝试导入的模块名称与触发异常的任意文件所在路径。<em>在 3.3 版更改:</em> 添加了 <code>name</code> 与 <code>path</code> 属性。</p>
</li>
<li><p><em>exception</em> <code>ModuleNotFoundError</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a> 的子类，当一个模块无法被定位时将由 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 引发。 当在 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中找到 <code>None</code> 时也会被引发。</p>
<p><em>3.6 新版功能.</em></p>
</li>
<li><p><em>exception</em> <code>IndexError</code></p>
<p>当序列抽取超出范围时将被引发。 （切片索引会被静默截短到允许的范围；如果指定索引不是整数则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 会被引发。）</p>
</li>
<li><p><em>exception</em> <code>KeyError</code></p>
<p>当在现有键集合中找不到指定的映射（字典）键时将被引发。</p>
</li>
<li><p><em>exception</em> <code>KeyboardInterrupt</code></p>
<p>当用户按下中断键 (通常为 Control-C 或 Delete) 时将被引发。 在执行期间，会定期检测中断信号。 该异常继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 以确保不会被处理 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的代码意外捕获，这样可以避免退出解释器。</p>
</li>
<li><p><em>exception</em> <code>MemoryError</code></p>
<p>当一个操作耗尽内存但情况仍可（通过删除一些对象）进行挽救时将被引发。 关联的值是一个字符串，指明是哪种（内部）操作耗尽了内存。 请注意由于底层的内存管理架构（C 的 <code>malloc()</code> 函数），解释器也许并不总是能够从这种情况下完全恢复；但它毕竟可以引发一个异常，这样就能打印出栈回溯信息，以便找出导致问题的失控程序。</p>
</li>
<li><p><em>exception</em> <code>NameError</code></p>
<p>当某个局部或全局名称未找到时将被引发。 此异常仅用于非限定名称。 关联的值是一条错误信息，其中包含未找到的名称。</p>
</li>
<li><p><em>exception</em> <code>NotImplementedError</code></p>
<p>此异常派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 在用户自定义的基类中，抽象方法应当在其要求所派生类重载该方法，或是在其要求所开发的类提示具体实现尚待添加时引发此异常。</p>
<blockquote>
<p>它不应当用来表示一个运算符或方法根本不能被支持 – 在此情况下应当让特定运算符 / 方法保持未定义，或者在子类中将其设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p>
<p><code>NotImplementedError</code> 和 <code>NotImplemented</code> 不可互换，即使它们有相似的名称和用途。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#NotImplemented" target="_blank" rel="noopener"><code>NotImplemented</code></a> 了解有关何时使用它们的详细说明。</p>
</blockquote>
</li>
<li><p><em>exception</em> <code>OSError</code>([<em>arg</em>])</p>
<p><em>exception</em> <code>OSError</code>(<em>errno</em>, <em>strerror</em>[, <em>filename</em>[, <em>winerror</em>[, <em>filename2</em>]]])</p>
<p>此异常在一个系统函数返回系统相关的错误时将被引发，此类错误包括 I/O 操作失败例如 “文件未找到” 或 “磁盘已满” 等（不包括非法参数类型或其他偶然性错误）。</p>
<p>构造器的第二种形式可设置如下所述的相应属性。 如果未指定这些属性则默认为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。 为了能向下兼容，如果传入了三个参数，则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException.args" target="_blank" rel="noopener"><code>args</code></a> 属性将仅包含由前两个构造器参数组成的 2 元组。</p>
<p>构造器实际返回的往往是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的某个子类，如下文 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#os-exceptions" target="_blank" rel="noopener">OS exceptions</a> 中所描述的。 具体的子类取决于最终的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 值。 此行为仅在直接或通过别名来构造 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 时发生，并且在子类化时不会被继承。</p>
<ul>
<li><p><code>errno</code></p>
<p>来自于 C 变量 <code>errno</code> 的数字错误码。</p>
</li>
<li><p><code>winerror</code></p>
<p>在 Windows 下，此参数将给出原生的 Windows 错误码。 而 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 属性将是该原生错误码在 POSIX 平台下的近似转换形式。在 Windows 下，如果 <em>winerror</em> 构造器参数是一个整数，则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 属性会根据 Windows 错误码来确定，而 <em>errno</em> 参数会被忽略。 在其他平台上，<em>winerror</em> 参数会被忽略，并且 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.winerror" target="_blank" rel="noopener"><code>winerror</code></a> 属性将不存在。</p>
</li>
<li><p><code>strerror</code></p>
<p>操作系统所提供的相应错误信息。 它在 POSIX 平台中由 C 函数 <code>perror()</code> 来格式化，在 Windows 中则是由 <code>FormatMessage()</code>。</p>
</li>
<li><p><code>filename</code></p>
</li>
<li><p><code>filename2</code></p>
<p>对于与文件系统路径有关 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unlink" target="_blank" rel="noopener"><code>os.unlink()</code></a>) 的异常，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename" target="_blank" rel="noopener"><code>filename</code></a> 是传给函数的文件名。 对于涉及两个文件系统路径的函数 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a>)，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename2" target="_blank" rel="noopener"><code>filename2</code></a> 将是传给函数的第二个文件名。</p>
</li>
</ul>
<p><em>在 3.3 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EnvironmentError" target="_blank" rel="noopener"><code>EnvironmentError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IOError" target="_blank" rel="noopener"><code>IOError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#WindowsError" target="_blank" rel="noopener"><code>WindowsError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.error" target="_blank" rel="noopener"><code>socket.error</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.error" target="_blank" rel="noopener"><code>select.error</code></a> 与 <code>mmap.error</code> 已被合并到 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>，构造器可能返回其中一个子类。</p>
<p><em>在 3.4 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename" target="_blank" rel="noopener"><code>filename</code></a> 属性现在将是传给函数的原始文件名，而不是经过编码或基于文件系统编码进行解码之后的名称。 此外还添加了 <em>filename2</em> 构造器参数和属性。</p>
</li>
<li><p><em>exception</em> <code>OverflowError</code></p>
<p>当算术运算的结果大到无法表示时将被引发。 这对整数来说不可能发生（宁可引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#MemoryError" target="_blank" rel="noopener"><code>MemoryError</code></a> 也不会放弃尝试）。 但是出于历史原因，有时也会在整数超出要求范围的情况下引发 OverflowError。 因为在 C 中缺少对浮点异常处理的标准化，大多数浮点运算都不会做检查。</p>
</li>
<li><p><em>exception</em> <code>RecursionError</code></p>
<p>此异常派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 它会在解释器检测发现超过最大递归深度 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getrecursionlimit" target="_blank" rel="noopener"><code>sys.getrecursionlimit()</code></a>) 时被引发。<em>3.5 新版功能:</em> 在此之前将只引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p>
</li>
<li><p><em>exception</em> <code>ReferenceError</code></p>
<p>此异常将在使用 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.proxy" target="_blank" rel="noopener"><code>weakref.proxy()</code></a> 函数所创建的弱引用来访问该引用的某个已被作为垃圾回收的属性时被引发。 有关弱引用的更多信息请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块。</p>
</li>
<li><p><em>exception</em> <code>RuntimeError</code></p>
<p>当检测到一个不归属于任何其他类别的错误时将被引发。 关联的值是一个指明究竟发生了什么问题的字符串。</p>
</li>
<li><p><em>exception</em> <code>StopIteration</code></p>
<p>由内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法所引发，用来表示该迭代器不能产生下一项。该异常对象只有一个属性 <code>value</code>，它在构造该异常时作为参数给出，默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。当一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 或 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 函数返回时，将引发一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 实例，函数返回的值将被用作异常构造器的 <code>value</code> 形参。如果某个生成器代码直接或间接地引发了 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a>，它会被转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> (并将 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 保留为导致新异常的原因)。<em>在 3.3 版更改:</em> 添加了 <code>value</code> 属性及其被生成器函数用作返回值的功能。<em>在 3.5 版更改:</em> 引入了通过 <code>from __future__ import generator_stop</code> 来实现 RuntimeError 转换，参见 <a href="https://www.python.org/dev/peps/pep-0479" target="_blank" rel="noopener"><strong>PEP 479</strong></a>。<em>在 3.7 版更改:</em> 默认对所有代码启用 <a href="https://www.python.org/dev/peps/pep-0479" target="_blank" rel="noopener"><strong>PEP 479</strong></a>: 在生成器中引发的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 错误将被转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p>
</li>
<li><p><em>exception</em> <code>StopAsyncIteration</code></p>
<p>必须由一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterator" target="_blank" rel="noopener">asynchronous iterator</a> 对象的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__" target="_blank" rel="noopener"><code>__anext__()</code></a> 方法来引发以停止迭代操作。<em>3.5 新版功能.</em></p>
</li>
<li><p><em>exception</em> <code>SyntaxError</code></p>
<p>当解析器遇到语法错误时将被引发。 这可以发生在 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句，对内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 的调用，或者读取原始脚本或标准输入（也包括交互模式）的时候。该类的实例包含有属性 <code>filename</code>, <code>lineno</code>, <code>offset</code> 和 <code>text</code> 用于方便地访问相应的详细信息。 异常实例的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a> 仅返回消息文本。</p>
</li>
<li><p><em>exception</em> <code>IndentationError</code></p>
<p>与不正确的缩进相关的语法错误的基类。 这是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>TabError</code></p>
<p>当缩进包含对制表符和空格符不一致的使用时将被引发。 这是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndentationError" target="_blank" rel="noopener"><code>IndentationError</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>SystemError</code></p>
<p>当解释器发现内部错误，但情况看起来尚未严重到要放弃所有希望时将被引发。 关联的值是一个指明发生了什么问题的字符串（表示为低层级的符号）。你应当将此问题报告给你所用 Python 解释器的作者或维护人员。 请确认报告 Python 解释器的版本号 (<code>sys.version</code>; 它也会在交互式 Python 会话开始时被打印出来)，具体的错误消息（异常所关联的值）以及可能触发该错误的程序源码。</p>
</li>
<li><p><em>exception</em> <code>SystemExit</code></p>
<p>此异常由 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 函数引发。 它继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 以确保不会被处理 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的代码意外捕获。 这允许此异常正确地向上传播并导致解释器退出。 如果它未被处理，则 Python 解释器就将退出；不会打印任何栈回溯信息。 构造器接受的可选参数与传递给 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 的相同。 如果该值为一个整数，则它指明系统退出状态码（会传递给 C 的 <code>exit()</code> 函数）；如果该值为 <code>None</code>，则退出状态码为零；如果该值为其他类型（例如字符串），则会打印对象的值并将退出状态码设为一。对 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 的调用会被转换为一个异常以便能执行清理处理程序 (<a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句)，并且使得调试器可以执行一段脚本而不必冒失去控制的风险。 如果绝对确实地需要立即退出（例如在调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>os.fork()</code></a> 之后的子进程中）则可使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os._exit" target="_blank" rel="noopener"><code>os._exit()</code></a>.<code>code</code>传给构造器的退出状态码或错误信息（默认为 <code>None</code>。）</p>
</li>
<li><p><em>exception</em> <code>TypeError</code></p>
<p>当一个操作或函数被应用于类型不适当的对象时将被引发。 关联的值是一个字符串，给出有关类型不匹配的详情。此异常可以由用户代码引发，以表明尝试对某个对象进行的操作不受支持也不应当受支持。 如果某个对象应当支持给定的操作但尚未提供相应的实现，所要引发的适当异常应为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a>。传入参数的类型错误 (例如在要求 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 时却传入了 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a>) 应当导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>，但传入参数的值错误 (例如传入要求范围之外的数值) 则应当导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。</p>
</li>
<li><p><em>exception</em> <code>UnboundLocalError</code></p>
<p>当在函数或方法中对某个局部变量进行引用，但该变量并未绑定任何值时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NameError" target="_blank" rel="noopener"><code>NameError</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>UnicodeError</code></p>
<p>当发生与 Unicode 相关的编码或解码错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 的一个子类。<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 具有一些描述编码或解码错误的属性。 例如 <code>err.object[err.start:err.end]</code> 会给出导致编解码器失败的特定无效输入。<code>encoding</code>引发错误的编码名称。<code>reason</code>描述特定编解码器错误的字符串。<code>object</code>编解码器试图要编码或解码的对象。<code>start</code><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 中无效数据的开始位置索引。<code>end</code><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 中无效数据的末尾位置索引（不含）。</p>
</li>
<li><p><em>exception</em> <code>UnicodeEncodeError</code></p>
<p>当在编码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>UnicodeDecodeError</code></p>
<p>当在解码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>UnicodeTranslateError</code></p>
<p>在转写过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>ValueError</code></p>
<p>当操作或函数接收到具有正确类型但值不适合的参数，并且情况不能用更精确的异常例如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 来描述时将被引发。</p>
</li>
<li><p><em>exception</em> <code>ZeroDivisionError</code></p>
<p>当除法或取余运算的第二个参数为零时将被引发。 关联的值是一个字符串，指明操作数和运算的类型。</p>
</li>
</ul>
<p>下列异常被保留以与之前的版本相兼容；从 Python 3.3 开始，它们都是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的别名。</p>
<ul>
<li><em>exception</em> <code>EnvironmentError</code></li>
</ul>
<ul>
<li><em>exception</em> <code>IOError</code></li>
</ul>
<ul>
<li><p><em>exception</em> <code>WindowsError</code></p>
<p>限在 Windows 中可用。</p>
</li>
</ul>
<h3 id="OS-异常"><a href="#OS-异常" class="headerlink" title="OS 异常"></a>OS 异常</h3><p>下列异常均为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的子类，它们将根据系统错误代码被引发。</p>
<ul>
<li><p><em>exception</em> <code>BlockingIOError</code></p>
<p>当一个操作会被某个设置为非阻塞操作的对象（例如套接字）所阻塞时将被引发。 对应于 <code>errno</code> <code>EAGAIN</code>, <code>EALREADY</code>, <code>EWOULDBLOCK</code> 和 <code>EINPROGRESS</code>。除了 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 已有的属性，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BlockingIOError" target="_blank" rel="noopener"><code>BlockingIOError</code></a> 还有一个额外属性：<code>characters_written</code>一个整数，表示在被阻塞前已写入到流的字符数。 当使用来自 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#module-io" target="_blank" rel="noopener"><code>io</code></a> 模块的带缓冲 I/O 类时此属性可用。</p>
</li>
<li><p><em>exception</em> <code>ChildProcessError</code></p>
<p>当一个子进程上的操作失败时将被引发。 对应于 <code>errno</code> <code>ECHILD</code>。</p>
</li>
<li><p><em>exception</em> <code>ConnectionError</code></p>
<p>与连接相关问题的基类。其子类有 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BrokenPipeError" target="_blank" rel="noopener"><code>BrokenPipeError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionAbortedError" target="_blank" rel="noopener"><code>ConnectionAbortedError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionRefusedError" target="_blank" rel="noopener"><code>ConnectionRefusedError</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionResetError" target="_blank" rel="noopener"><code>ConnectionResetError</code></a>。</p>
</li>
<li><p><em>exception</em> <code>BrokenPipeError</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当试图写入另一端已被关闭的管道，或是试图写入已关闭写入的套接字时将被引发。 对应于 <code>errno</code> <code>EPIPE</code> 和 <code>ESHUTDOWN</code>。</p>
</li>
<li><p><em>exception</em> <code>ConnectionAbortedError</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接尝试被对端中止时将被引发。 对应于 <code>errno</code> <code>ECONNABORTED</code>。</p>
</li>
<li><p><em>exception</em> <code>ConnectionRefusedError</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接尝试被对端拒绝时将被引发。 对应于 <code>errno</code> <code>ECONNREFUSED</code>。</p>
</li>
<li><p><em>exception</em> <code>ConnectionResetError</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接被对端重置时将被引发。 对应于 <code>errno</code> <code>ECONNRESET</code>。</p>
</li>
<li><p><em>exception</em> <code>FileExistsError</code></p>
<p>当试图创建一个已存在的文件或目录时将被引发。 对应于 <code>errno</code> <code>EEXIST</code>。</p>
</li>
<li><p><em>exception</em> <code>FileNotFoundError</code></p>
<p>当所请求的文件或目录不存在时将被引发。 对应于 <code>errno</code> <code>ENOENT</code>。</p>
</li>
<li><p><em>exception</em> <code>InterruptedError</code></p>
<p>当系统调用被输入信号中断时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EINTR" target="_blank" rel="noopener"><code>EINTR</code></a>。<em>在 3.5 版更改:</em> 当系统调用被某个信号中断时，Python 现在会重试系统调用，除非该信号的处理程序引发了其它异常 (原理参见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>) 而不是引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a>。</p>
</li>
<li><p><em>exception</em> <code>IsADirectoryError</code></p>
<p>当请求对一个目录执行文件操作 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.remove" target="_blank" rel="noopener"><code>os.remove()</code></a>) 将被引发。 对应于 <code>errno</code> <code>EISDIR</code>。</p>
</li>
<li><p><em>exception</em> <code>NotADirectoryError</code></p>
<p>当请求对一个非目录对象执行目录操作 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>os.listdir()</code></a>) 时将被引发。 对应于 <code>errno</code> <code>ENOTDIR</code>。</p>
</li>
<li><p><em>exception</em> <code>PermissionError</code></p>
<p>当在没有足够操作权限的情况下试图执行某个操作时将被引发 —— 例如缺少文件系统权限。 对应于 <code>errno</code> <code>EACCES</code> 和 <code>EPERM</code>。</p>
</li>
<li><p><em>exception</em> <code>ProcessLookupError</code></p>
<p>当给定的进程不存在时将被引发。 对应于 <code>errno</code> <code>ESRCH</code>。</p>
</li>
<li><p><em>exception</em> <code>TimeoutError</code></p>
<p>当一个系统函数发生系统级超时的情况下将被引发。 对应于 <code>errno</code> <code>ETIMEDOUT</code>。</p>
</li>
</ul>
<p><em>3.3 新版功能:</em> 添加了以上所有 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的子类。</p>
<blockquote>
<p>参见：<a href="https://www.python.org/dev/peps/pep-3151" target="_blank" rel="noopener"><strong>PEP 3151</strong></a> - 重写 OS 和 IO 异常的层次结构</p>
</blockquote>
<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>下列异常被用作警告类别；请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/warnings.html#warning-categories" target="_blank" rel="noopener">警告类别</a> 文档了解详情。</p>
<ul>
<li><p><em>exception</em> <code>Warning</code></p>
<p>警告类别的基类。</p>
</li>
<li><p><em>exception</em> <code>UserWarning</code></p>
<p>用户代码所产生警告的基类。</p>
</li>
<li><p><em>exception</em> <code>DeprecationWarning</code></p>
<p>如果所发出的警告是针对其他 Python 开发者的，则以此作为与已弃用特性相关警告的基类。</p>
</li>
<li><p><em>exception</em> <code>PendingDeprecationWarning</code></p>
<p>对于已过时并预计在未来弃用，但目前尚未弃用的特性相关警告的基类。这个类很少被使用，因为针对未来可能的弃用发出警告的做法并不常见，而针对当前已有的弃用则推荐使用 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#DeprecationWarning" target="_blank" rel="noopener"><code>DeprecationWarning</code></a>。</p>
</li>
<li><p><em>exception</em> <code>SyntaxWarning</code></p>
<p>与模糊的语法相关的警告的基类。</p>
</li>
<li><p><em>exception</em> <code>RuntimeWarning</code></p>
<p>与模糊的运行时行为相关的警告的基类。</p>
</li>
<li><p><em>exception</em> <code>FutureWarning</code></p>
<p>如果所发出的警告是针对以 Python 所编写应用的最终用户的，则以此作为与已弃用特性相关警告的基类。</p>
</li>
<li><p><em>exception</em> <code>ImportWarning</code></p>
<p>与在模块导入中可能的错误相关的警告的基类。</p>
</li>
<li><p><em>exception</em> <code>UnicodeWarning</code></p>
<p>与 Unicode 相关的警告的基类。</p>
</li>
<li><p><em>exception</em> <code>BytesWarning</code></p>
<p>与 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 相关的警告的基类。</p>
</li>
<li><p><em>exception</em> <code>ResourceWarning</code></p>
<p>与资源使用相关的警告的基类。 会被默认的警告过滤器忽略。<em>3.2 新版功能.</em></p>
</li>
</ul>
<h2 id="异常层次结构"><a href="#异常层次结构" class="headerlink" title="异常层次结构"></a>异常层次结构</h2><p>内置异常的类层级结构如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- StopAsyncIteration</span><br><span class="line">      +-- ArithmeticError</span><br><span class="line">      |    +-- FloatingPointError</span><br><span class="line">      |    +-- OverflowError</span><br><span class="line">      |    +-- ZeroDivisionError</span><br><span class="line">      +-- AssertionError</span><br><span class="line">      +-- AttributeError</span><br><span class="line">      +-- BufferError</span><br><span class="line">      +-- EOFError</span><br><span class="line">      +-- ImportError</span><br><span class="line">      |    +-- ModuleNotFoundError</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br><span class="line">      +-- MemoryError</span><br><span class="line">      +-- NameError</span><br><span class="line">      |    +-- UnboundLocalError</span><br><span class="line">      +-- OSError</span><br><span class="line">      |    +-- BlockingIOError</span><br><span class="line">      |    +-- ChildProcessError</span><br><span class="line">      |    +-- ConnectionError</span><br><span class="line">      |    |    +-- BrokenPipeError</span><br><span class="line">      |    |    +-- ConnectionAbortedError</span><br><span class="line">      |    |    +-- ConnectionRefusedError</span><br><span class="line">      |    |    +-- ConnectionResetError</span><br><span class="line">      |    +-- FileExistsError</span><br><span class="line">      |    +-- FileNotFoundError</span><br><span class="line">      |    +-- InterruptedError</span><br><span class="line">      |    +-- IsADirectoryError</span><br><span class="line">      |    +-- NotADirectoryError</span><br><span class="line">      |    +-- PermissionError</span><br><span class="line">      |    +-- ProcessLookupError</span><br><span class="line">      |    +-- TimeoutError</span><br><span class="line">      +-- ReferenceError</span><br><span class="line">      +-- RuntimeError</span><br><span class="line">      |    +-- NotImplementedError</span><br><span class="line">      |    +-- RecursionError</span><br><span class="line">      +-- SyntaxError</span><br><span class="line">      |    +-- IndentationError</span><br><span class="line">      |         +-- TabError</span><br><span class="line">      +-- SystemError</span><br><span class="line">      +-- TypeError</span><br><span class="line">      +-- ValueError</span><br><span class="line">      |    +-- UnicodeError</span><br><span class="line">      |         +-- UnicodeDecodeError</span><br><span class="line">      |         +-- UnicodeEncodeError</span><br><span class="line">      |         +-- UnicodeTranslateError</span><br><span class="line">      +-- Warning</span><br><span class="line">           +-- DeprecationWarning</span><br><span class="line">           +-- PendingDeprecationWarning</span><br><span class="line">           +-- RuntimeWarning</span><br><span class="line">           +-- SyntaxWarning</span><br><span class="line">           +-- UserWarning</span><br><span class="line">           +-- FutureWarning</span><br><span class="line">           +-- ImportWarning</span><br><span class="line">           +-- UnicodeWarning</span><br><span class="line">           +-- BytesWarning</span><br><span class="line">           +-- ResourceWarning</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library 2to3</title>
    <url>/2020/02/26/python-standard-library-2to3/</url>
    <content><![CDATA[<h1 id="python-标准库-2to3-自动转换python2到3"><a href="#python-标准库-2to3-自动转换python2到3" class="headerlink" title="python 标准库 2to3 自动转换python2到3"></a>python 标准库 2to3 自动转换python2到3</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200226Memorize-Words-Quickly-Step-8-Version-3.jpg?raw=true" alt></p>
<a id="more"></a>
<p>2to3 是一个 Python 程序，它可以用来读取 Python 2.x 版本的代码，并使用一系列的 <em>修复器</em> 来将其转换为合法的 Python 3.x 代码。标准库中已经包含了丰富的修复器，这足以处理绝大多数代码。不过 2to3 的支持库 <a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#module-lib2to3" target="_blank" rel="noopener"><code>lib2to3</code></a> 是一个很灵活通用的库，所以你也可以为 2to3 编写你自己的修复器。<a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#module-lib2to3" target="_blank" rel="noopener"><code>lib2to3</code></a> 也可以用在那些需要自动处理 Python 代码的应用中。</p>
<h2 id="使用-2to3"><a href="#使用-2to3" class="headerlink" title="使用 2to3"></a>使用 2to3</h2><p>2to3 通常会作为脚本和 Python 解释器一起安装，你可以在 Python 根目录的 <code>Tools/scripts</code> 文件夹下找到它。</p>
<p>2to3 的基本调用参数是一个需要转换的文件或目录列表。对于目录，会递归地寻找其中的 Python 源码。</p>
<p>这里有一个 Python 2.x 的源码文件，<code>example.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Hello, &#123;0&#125;!"</span>.format(name)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"What's your name?"</span></span><br><span class="line">name = raw_input()</span><br><span class="line">greet(name)</span><br></pre></td></tr></table></figure>
<p>它可以在命令行中使用 2to3 转换成 Python 3.x 版本的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 example.py</span><br></pre></td></tr></table></figure>
<p>这个命令会打印出和源文件的区别。通过传入 <code>-w</code> 参数，2to3 也可以把需要的修改写回到原文件中（除非传入了 <code>-n</code> 参数，否则会为原始文件创建一个副本）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -w example.py</span><br></pre></td></tr></table></figure>
<p>在转换完成后，<code>example.py</code> 看起来像是这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"Hello, &#123;0&#125;!"</span>.format(name))</span><br><span class="line">print(<span class="string">"What's your name?"</span>)</span><br><span class="line">name = input()</span><br><span class="line">greet(name)</span><br></pre></td></tr></table></figure>
<p>注释和缩进都会在转换过程中保持不变。</p>
<p>默认情况下，2to3 会执行 <a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#to3-fixers" target="_blank" rel="noopener">预定义修复器</a> 的集合。使用 <code>-l</code> 参数可以列出所有可用的修复器。使用 <code>-f</code> 参数可以明确指定需要使用的修复器集合。而使用 <code>-x</code> 参数则可以明确指定不使用的修复器。下面的例子会只使用 <code>imports</code> 和 <code>has_key</code> 修复器运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -f imports -f has_key example.py</span><br></pre></td></tr></table></figure>
<p>这个命令会执行除了 <code>apply</code> 之外的所有修复器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -x apply example.py</span><br></pre></td></tr></table></figure>
<p>有一些修复器是需要 <em>显式指定</em> 的，它们默认不会执行，必须在命令行中列出才会执行。比如下面的例子，除了默认的修复器以外，还会执行 <code>idioms</code> 修复器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -f all -f idioms example.py</span><br></pre></td></tr></table></figure>
<p>注意这里使用 <code>all</code> 来启用所有默认的修复器。</p>
<p>有些情况下 2to3 会找到源码中有一些需要修改，但是无法自动处理的代码。在这种情况下，2to3 会在差异处下面打印一个警告信息。你应该定位到相应的代码并对其进行修改，以使其兼容 Python 3.x。</p>
<p>2to3 也可以重构 doctests。使用 <code>-d</code> 开启这个模式。需要注意<em>只有</em> doctests 会被重构。这种模式下不需要文件是合法的 Python 代码。举例来说，reST 文档中类似 doctests 的示例也可以使用这个选项进行重构。</p>
<p><code>-v</code> 选项可以输出更多转换程序的详细信息。</p>
<p>由于某些 print 语句可被解读为函数调用或是语句，2to3 并不是总能读取包含 print 函数的文件。当 2to3 检测到存在 <code>from __future__ import print_function</code> 编译器指令时，会修改其内部语法将 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 解读为函数。这一变动也可以使用 <code>-p</code> 选项手动开启。使用 <code>-p</code> 来为已经转换过 print 语句的代码运行修复器。</p>
<p><code>-o</code> 或 <code>--output-dir</code> 选项可以指定将转换后的文件写入其他目录中。由于这种情况下不会覆写原始文件，所以创建副本文件毫无意义，因此也需要使用 <code>-n</code> 选项来禁用创建副本。</p>
<p><em>3.2.3 新版功能:</em> 增加了 <code>-o</code> 选项。</p>
<p><code>-W</code> 或 <code>--write-unchanged-files</code> 选项用来告诉 2to3 始终需要输出文件，即使没有任何改动。这在使用 <code>-o</code> 参数时十分有用，这样就可以将整个 Python 源码包完整地转换到另一个目录。这个选项隐含了 <code>-w</code> 选项，否则等于没有作用。</p>
<p><em>3.2.3 新版功能:</em> 增加了 <code>-W</code> 选项。</p>
<p><code>--add-suffix</code> 选项接受一个字符串，用来作为后缀附加在输出文件名后面的后面。由于写入的文件名与原始文件不同，所以没有必要创建副本，因此 <code>-n</code> 选项也是必要的。举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -n -W --add-suffix=<span class="number">3</span> example.py</span><br></pre></td></tr></table></figure>
<p>这样会把转换后的文件写入 <code>example.py3</code> 文件。</p>
<p><em>3.2.3 新版功能:</em> 增加了 <code>--add-suffix</code> 选项。</p>
<p>将整个项目从一个目录转换到另一个目录可以用这样的命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 --output-dir=python3-version/mycode -W -n python2-version/mycode</span><br></pre></td></tr></table></figure>
<h2 id="修复器"><a href="#修复器" class="headerlink" title="修复器"></a>修复器</h2><p>转换代码的每一个步骤都封装在修复器中。可以使用 <code>2to3 -l</code> 来列出可用的修复器。<a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#to3-using" target="_blank" rel="noopener">之前已经提到</a>，每个修复器都可以独立地打开或是关闭。下面会对各个修复器做更详细的描述。</p>
<ul>
<li><p><code>apply</code></p>
<p>移除对 <code>apply()</code> 的使用，举例来说，<code>apply(function, *args, **kwargs)</code> 会被转换成 <code>function(*args, **kwargs)</code>。</p>
</li>
<li><p><code>asserts</code></p>
<p>将已弃用的 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 方法替换为正确的。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">Python 2.x</th>
<th style="text-align:left">Python 3.x</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>failUnlessEqual(a, b)</code></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertEqual" target="_blank" rel="noopener"><code>assertEqual(a, b)</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>assertEquals(a, b)</code></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertEqual" target="_blank" rel="noopener"><code>assertEqual(a, b)</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>failIfEqual(a, b)</code></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertNotEqual" target="_blank" rel="noopener"><code>assertNotEqual(a, b)</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>assertNotEquals(a, b)</code></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertNotEqual" target="_blank" rel="noopener"><code>assertNotEqual(a, b)</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>failUnless(a)</code></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertTrue" target="_blank" rel="noopener"><code>assertTrue(a)</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>assert_(a)</code></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertTrue" target="_blank" rel="noopener"><code>assertTrue(a)</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>failIf(a)</code></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertFalse" target="_blank" rel="noopener"><code>assertFalse(a)</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>failUnlessRaises(exc, cal)</code></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertRaises" target="_blank" rel="noopener"><code>assertRaises(exc, cal)</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>failUnlessAlmostEqual(a, b)</code></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertAlmostEqual" target="_blank" rel="noopener"><code>assertAlmostEqual(a, b)</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>assertAlmostEquals(a, b)</code></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertAlmostEqual" target="_blank" rel="noopener"><code>assertAlmostEqual(a, b)</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>failIfAlmostEqual(a, b)</code></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertNotAlmostEqual" target="_blank" rel="noopener"><code>assertNotAlmostEqual(a, b)</code></a></td>
</tr>
<tr>
<td style="text-align:left"><code>assertNotAlmostEquals(a, b)</code></td>
<td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertNotAlmostEqual" target="_blank" rel="noopener"><code>assertNotAlmostEqual(a, b)</code></a></td>
</tr>
</tbody>
</table>
<ul>
<li><code>basestring</code></li>
</ul>
<ul>
<li><p><code>buffer</code></p>
<p>将 <code>buffer</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview</code></a>。这个修复器是可选的，因为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview</code></a> API 和 <code>buffer</code> 很相似，但不完全一样。</p>
</li>
<li><p><code>dict</code></p>
<p>修复字典迭代方法。<code>dict.iteritems()</code> 会转换成 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.items" target="_blank" rel="noopener"><code>dict.items()</code></a>，<code>dict.iterkeys()</code> 会转换成 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.keys" target="_blank" rel="noopener"><code>dict.keys()</code></a>，<code>dict.itervalues()</code> 会转换成 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.values" target="_blank" rel="noopener"><code>dict.values()</code></a>。类似的，<code>dict.viewitems()</code>，<code>dict.viewkeys()</code> 和 <code>dict.viewvalues()</code> 会分别转换成 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.items" target="_blank" rel="noopener"><code>dict.items()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.keys" target="_blank" rel="noopener"><code>dict.keys()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.values" target="_blank" rel="noopener"><code>dict.values()</code></a>。另外也会将原有的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.items" target="_blank" rel="noopener"><code>dict.items()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.keys" target="_blank" rel="noopener"><code>dict.keys()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.values" target="_blank" rel="noopener"><code>dict.values()</code></a> 方法调用用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装一层。</p>
</li>
<li><p><code>except</code></p>
<p>将 <code>except X, T</code> 转换为 <code>except X as T</code>。</p>
</li>
<li><p><code>exec</code></p>
<p>将 <code>exec</code> 语句转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 函数调用。</p>
</li>
<li><p><code>execfile</code></p>
<p>移除 <code>execfile()</code> 的使用。<code>execfile()</code> 的实参会使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#compile" target="_blank" rel="noopener"><code>compile()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 包装。</p>
</li>
<li><p><code>exitfunc</code></p>
<p>将对 <code>sys.exitfunc</code> 的赋值改为使用 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 模块代替。</p>
</li>
<li><p><code>filter</code></p>
<p>将 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#filter" target="_blank" rel="noopener"><code>filter()</code></a> 函数用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装一层。</p>
</li>
<li><p><code>funcattrs</code></p>
<p>修复已经重命名的函数属性。比如 <code>my_function.func_closure</code> 会被转换为 <code>my_function.__closure__</code>。</p>
</li>
<li><p><code>future</code></p>
<p>移除 <code>from __future__ import new_feature</code> 语句。</p>
</li>
<li><p><code>getcwdu</code></p>
<p>将 <code>os.getcwdu()</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getcwd" target="_blank" rel="noopener"><code>os.getcwd()</code></a>。</p>
</li>
<li><p><code>has_key</code></p>
<p>将 <code>dict.has_key(key)</code> 转换为 <code>key in dict</code>。</p>
</li>
<li><p><code>idioms</code></p>
<p>这是一个可选的修复器，会进行多种转换，将 Python 代码变成更加常见的写法。类似 <code>type(x) is SomeClass</code> 和 <code>type(x) == SomeClass</code> 的类型对比会被转换成 <code>isinstance(x, SomeClass)</code>。<code>while 1</code> 转换成 <code>while True</code>。这个修复器还会在合适的地方使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> 函数。举个例子，这样的代码块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = list(some_iterable)</span><br><span class="line">L.sort()</span><br></pre></td></tr></table></figure>
<p>会被转换为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = sorted(some_iterable)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>import</code></p>
<p>检测 sibling imports，并将其转换成相对 import。</p>
</li>
<li><p><code>imports</code></p>
<p>处理标准库模块的重命名。</p>
</li>
<li><p><code>imports2</code></p>
<p>处理标准库中其他模块的重命名。这个修复器由于一些技术上的限制，因此和 <a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#2to3fixer-imports" target="_blank" rel="noopener"><code>imports</code></a> 拆分开了。</p>
</li>
<li><p><code>input</code></p>
<p>将 <code>input(prompt)</code> 转换为 <code>eval(input(prompt))</code>。</p>
</li>
<li><p><code>intern</code></p>
<p>将 <code>intern()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.intern" target="_blank" rel="noopener"><code>sys.intern()</code></a>。</p>
</li>
<li><p><code>isinstance</code></p>
<p>修复 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a> 函数第二个实参中重复的类型。举例来说，<code>isinstance(x, (int, int))</code> 会转换为 <code>isinstance(x, int)</code>, <code>isinstance(x, (int, float, int))</code> 会转换为 <code>isinstance(x, (int, float))</code>。</p>
</li>
<li><p><code>itertools_imports</code></p>
<p>移除 <code>itertools.ifilter()</code>，<code>itertools.izip()</code> 以及 <code>itertools.imap()</code> 的 import。对 <code>itertools.ifilterfalse()</code> 的 import 也会替换成 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.filterfalse" target="_blank" rel="noopener"><code>itertools.filterfalse()</code></a>。</p>
</li>
<li><p><code>itertools</code></p>
<p>修改 <code>itertools.ifilter()</code>，<code>itertools.izip()</code> 和 <code>itertools.imap()</code> 的调用为对应的内建实现。<code>itertools.ifilterfalse()</code> 会替换成 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.filterfalse" target="_blank" rel="noopener"><code>itertools.filterfalse()</code></a>。</p>
</li>
<li><p><code>long</code></p>
<p>将 <code>long</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>。</p>
</li>
<li><p><code>map</code></p>
<p>用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a>。同时也会将 <code>map(None, x)</code> 替换为 <code>list(x)</code>。使用 <code>from future_builtins import map</code> 禁用这个修复器。</p>
</li>
<li><p><code>metaclass</code></p>
<p>将老的元类语法（类体中的 <code>__metaclass__ = Meta</code>）替换为新的（<code>class X(metaclass=Meta)</code>）。</p>
</li>
<li><p><code>methodattrs</code></p>
<p>修复老的方法属性名。例如 <code>meth.im_func</code> 会被转换为 <code>meth.__func__</code>。</p>
</li>
<li><p><code>ne</code></p>
<p>转换老的不等语法，将 <code>&lt;&gt;</code> 转为 <code>!=</code>。</p>
</li>
<li><p><code>next</code></p>
<p>将迭代器的 <code>next()</code> 方法调用转为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 函数。也会将 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 方法重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a>。</p>
</li>
<li><p><code>nonzero</code></p>
<p>将 <code>__nonzero__()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__bool__" target="_blank" rel="noopener"><code>__bool__()</code></a>。</p>
</li>
<li><p><code>numliterals</code></p>
<p>将八进制字面量转为新的语法。</p>
</li>
<li><p><code>operator</code></p>
<p>将 <a href="https://docs.python.org/zh-cn/3.8/library/operator.html#module-operator" target="_blank" rel="noopener"><code>operator</code></a> 模块中的许多方法调用转为其他的等效函数调用。如果有需要，会添加适当的 <code>import</code> 语句，比如 <code>import collections.abc</code>。有以下转换映射：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">Python 2.x</th>
<th style="text-align:left">Python 3.x</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>operator.isCallable(obj)</code></td>
<td style="text-align:left"><code>callable(obj)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>operator.sequenceIncludes(obj)</code></td>
<td style="text-align:left"><code>operator.contains(obj)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>operator.isSequenceType(obj)</code></td>
<td style="text-align:left"><code>isinstance(obj, collections.abc.Sequence)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>operator.isMappingType(obj)</code></td>
<td style="text-align:left"><code>isinstance(obj, collections.abc.Mapping)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>operator.isNumberType(obj)</code></td>
<td style="text-align:left"><code>isinstance(obj, numbers.Number)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>operator.repeat(obj, n)</code></td>
<td style="text-align:left"><code>operator.mul(obj, n)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>operator.irepeat(obj, n)</code></td>
<td style="text-align:left"><code>operator.imul(obj, n)</code></td>
</tr>
</tbody>
</table>
<ul>
<li><p><code>paren</code></p>
<p>在列表生成式中增加必须的括号。例如将 <code>[x for x in 1, 2]</code> 转换为 <code>[x for x in (1, 2)]</code>。</p>
</li>
<li><p><code>print</code></p>
<p>将 <code>print</code> 语句转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 函数。</p>
</li>
<li><p><code>raise</code></p>
<p>将 <code>raise E, V</code> 转换为 <code>raise E(V)</code>，将 <code>raise E, V, T</code> 转换为 <code>raise E(V).with_traceback(T)</code>。如果 <code>E</code> 是元组，这样的转换是不正确的，因为用元组代替异常的做法在 3.0 中已经移除了。</p>
</li>
<li><p><code>raw_input</code></p>
<p>将 <code>raw_input()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#input" target="_blank" rel="noopener"><code>input()</code></a>。</p>
</li>
<li><p><code>reduce</code></p>
<p>将 <code>reduce()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.reduce" target="_blank" rel="noopener"><code>functools.reduce()</code></a>。</p>
</li>
<li><p><code>reload</code></p>
<p>将 <code>reload()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/importlib.html#importlib.reload" target="_blank" rel="noopener"><code>importlib.reload()</code></a>。</p>
</li>
<li><p><code>renames</code></p>
<p>将 <code>sys.maxint</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.maxsize" target="_blank" rel="noopener"><code>sys.maxsize</code></a>。</p>
</li>
<li><p><code>repr</code></p>
<p>将反引号 repr 表达式替换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 函数。</p>
</li>
<li><p><code>set_literal</code></p>
<p>将 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 构造函数替换为 set literals 写法。这个修复器是可选的。</p>
</li>
<li><p><code>standarderror</code></p>
<p>将 <code>StandardError</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a>。</p>
</li>
<li><p><code>sys_exc</code></p>
<p>将弃用的 <code>sys.exc_value</code>，<code>sys.exc_type</code>，<code>sys.exc_traceback</code> 替换为 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exc_info" target="_blank" rel="noopener"><code>sys.exc_info()</code></a> 的用法。</p>
</li>
<li><p><code>throw</code></p>
<p>修复生成器的 <code>throw()</code> 方法的 API 变更。</p>
</li>
<li><p><code>tuple_params</code></p>
<p>移除隐式的元组参数解包。这个修复器会插入临时变量。</p>
</li>
<li><p><code>types</code></p>
<p>修复 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#type" target="_blank" rel="noopener"><code>type</code></a> 模块中一些成员的移除引起的代码问题。</p>
</li>
<li><p><code>unicode</code></p>
<p>将 <code>unicode</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>。</p>
</li>
<li><p><code>urllib</code></p>
<p>将 <a href="https://docs.python.org/zh-cn/3.8/library/urllib.html#module-urllib" target="_blank" rel="noopener"><code>urllib</code></a> 和 <code>urllib2</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/urllib.html#module-urllib" target="_blank" rel="noopener"><code>urllib</code></a> 包。</p>
</li>
<li><p><code>ws_comma</code></p>
<p>移除逗号分隔的元素之间多余的空白。这个修复器是可选的。</p>
</li>
<li><p><code>xrange</code></p>
<p>将 <code>xrange()</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#range" target="_blank" rel="noopener"><code>range()</code></a>，并用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装原有的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#range" target="_blank" rel="noopener"><code>range()</code></a>。</p>
</li>
<li><p><code>xreadlines</code></p>
<p>将 <code>for x in file.xreadlines()</code> 转换为 <code>for x in file</code>。</p>
</li>
<li><p><code>zip</code></p>
<p>用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#zip" target="_blank" rel="noopener"><code>zip()</code></a>。如果使用了 <code>from future_builtins import zip</code> 的话会禁用。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>2to3</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library unittest</title>
    <url>/2020/02/25/python-standard-library-unittest/</url>
    <content><![CDATA[<h1 id="python-标准库-unittest"><a href="#python-标准库-unittest" class="headerlink" title="python 标准库 unittest"></a>python 标准库 unittest</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200225unit-test.png?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>今天又学到一种单词记忆方法</p>
<p><a href="https://www.wikihow.com/Memorize-Words-Quickly" target="_blank" rel="noopener">https://www.wikihow.com/Memorize-Words-Quickly</a> </p>
<p>基本原则我梳理了一下:</p>
<ol>
<li><p>Using Word Association and Mnemonic Devices</p>
</li>
<li><p>Visualizing Words </p>
</li>
<li><p>Using Sound and Music</p>
</li>
</ol>
</blockquote>
<p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/unittest/__init__.py" target="_blank" rel="noopener">Lib/unittest/<strong>init</strong>.py</a></p>
<hr>
<p>（如果你已经对测试的概念比较熟悉了，你可能想直接跳转到这一部分 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#assert-methods" target="_blank" rel="noopener">断言方法</a>。）</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 单元测试框架是受到 JUnit 的启发，与其他语言中的主流单元测试框架有着相似的风格。其支持测试自动化，配置共享和关机代码测试。支持将测试样例聚合到测试集中，并将测试与报告框架独立。</p>
<p>为了实现这些，<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 通过面向对象的方式支持了一些重要的概念。</p>
<ul>
<li><p>测试脚手架</p>
<p><em>test fixture</em> 表示为了开展一项或多项测试所需要进行的准备工作，以及所有相关的清理操作。举个例子，这可能包含创建临时或代理的数据库、目录，再或者启动一个服务器进程。</p>
</li>
<li><p>测试用例</p>
<p>一个测试用例是一个独立的测试单元。它检查输入特定的数据时的响应。 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 提供一个基类： <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a> ，用于新建测试用例。</p>
</li>
<li><p>测试套件</p>
<p><em>test suite</em> 是一系列的测试用例，或测试套件，或两者皆有。它用于归档需要一起执行的测试。</p>
</li>
<li><p>测试运行器（test runner）</p>
<p><em>test runner</em> 是一个用于执行和输出测试结果的组件。这个运行器可能使用图形接口、文本接口，或返回一个特定的值表示运行测试的结果。</p>
</li>
</ul>
<p>参见</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/doctest.html#module-doctest" target="_blank" rel="noopener"><code>doctest</code></a> — 文档测试模块</p>
<p>另一个风格完全不同的测试模块。</p>
</li>
<li><p><a href="https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm" target="_blank" rel="noopener">Simple Smalltalk Testing: With Patterns</a></p>
<p>Kent Beck 的原始论文阐述了关于使用共享模式的单元测试框架。</p>
</li>
<li><p><a href="https://docs.pytest.org/" target="_blank" rel="noopener">pytest</a></p>
<p>第三方单元测试框架拥有轻量级易编写用例的语法.例如 <code>assert func(10) == 42</code>.</p>
</li>
<li><p><a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy" target="_blank" rel="noopener">The Python Testing Tools Taxonomy</a></p>
<p>这是一个关于测试工具的清单,包括功能测试和模拟mock对象库。</p>
</li>
<li><p><a href="http://lists.idyll.org/listinfo/testing-in-python" target="_blank" rel="noopener">Testing in Python Mailing List</a></p>
<p>用于讨论Python中测试和测试工具的讨论组</p>
</li>
</ul>
<p><code>Tools/unittestgui/unittestgui.py</code>脚本是用来做探索测试和执行的GUI工具。这主要是为了更加方便那些新的单元测试用例。对于生产环境而言,建议还是使用例如 <a href="https://buildbot.net/" target="_blank" rel="noopener">Buildbot</a>, <a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins</a> or <a href="http://hudson-ci.org/" target="_blank" rel="noopener">Hudson</a> 这样的持续集成工具来执行测试。</p>
<h2 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 模块提供了一系列创建和运行测试的工具。这一段落演示了这些工具的一小部分，但也足以满足大部分用户的需求。</p>
<p>这是一段简短的代码，来测试三种字符串方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStringMethods</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_upper</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(<span class="string">'foo'</span>.upper(), <span class="string">'FOO'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_isupper</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertTrue(<span class="string">'FOO'</span>.isupper())</span><br><span class="line">        self.assertFalse(<span class="string">'Foo'</span>.isupper())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_split</span><span class="params">(self)</span>:</span></span><br><span class="line">        s = <span class="string">'hello world'</span></span><br><span class="line">        self.assertEqual(s.split(), [<span class="string">'hello'</span>, <span class="string">'world'</span>])</span><br><span class="line">        <span class="comment"># check that s.split fails when the separator is not a string</span></span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(TypeError):</span><br><span class="line">            s.split(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>
<p>继承 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>unittest.TestCase</code></a> 就创建了一个测试样例。上述三个独立的测试是三个类的方法，这些方法的命名都以 <code>test</code> 开头。 这个命名约定告诉测试运行者类的哪些方法表示测试。</p>
<p>每个测试的关键是：调用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertEqual" target="_blank" rel="noopener"><code>assertEqual()</code></a> 来检查预期的输出； 调用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertTrue" target="_blank" rel="noopener"><code>assertTrue()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertFalse" target="_blank" rel="noopener"><code>assertFalse()</code></a> 来验证一个条件；调用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertRaises" target="_blank" rel="noopener"><code>assertRaises()</code></a> 来验证抛出了一个特定的异常。使用这些方法而不是 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#assert" target="_blank" rel="noopener"><code>assert</code></a> 语句是为了让测试运行者能聚合所有的测试结果并产生结果报告。</p>
<p>通过 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener"><code>setUp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.tearDown" target="_blank" rel="noopener"><code>tearDown()</code></a> 方法，可以设置测试开始前与完成后需要执行的指令。 在 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#organizing-tests" target="_blank" rel="noopener">组织你的测试代码</a> 中，对此有更为详细的描述。</p>
<p>最后的代码块中，演示了运行测试的一个简单的方法。 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.main" target="_blank" rel="noopener"><code>unittest.main()</code></a> 提供了一个测试脚本的命令行接口。当在命令行运行该测试脚本，上文的脚本生成如以下格式的输出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">3</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>在调用测试脚本时添加 <code>-v</code> 参数使 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.main" target="_blank" rel="noopener"><code>unittest.main()</code></a> 显示更为详细的信息，生成如以下形式的输出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_isupper (__main__.TestStringMethods) ... ok</span><br><span class="line">test_split (__main__.TestStringMethods) ... ok</span><br><span class="line">test_upper (__main__.TestStringMethods) ... ok</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">3</span> tests <span class="keyword">in</span> <span class="number">0.001</span>s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p> 以上例子演示了 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 中最常用的、足够满足许多日常测试需求的特性。文档的剩余部分详述该框架的完整特性。 </p>
<h2 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h2><p>unittest 模块可以通过命令行运行模块、类和独立测试方法的测试:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m unittest test_module1 test_module2</span><br><span class="line">python -m unittest test_module.TestClass</span><br><span class="line">python -m unittest test_module.TestClass.test_method</span><br></pre></td></tr></table></figure>
<p>你可以传入模块名、类或方法名或他们的任意组合。</p>
<p>同样的，测试模块可以通过文件路径指定:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m unittest tests/test_something.py</span><br></pre></td></tr></table></figure>
<p>这样就可以使用 shell 的文件名补全指定测试模块。所指定的文件仍需要可以被作为模块导入。路径通过去除 ‘.py’ 、把分隔符转换为 ‘.’ 转换为模块名。若你需要执行不能被作为模块导入的测试文件，你需要直接执行该测试文件。</p>
<p>在运行测试时，你可以通过添加 -v 参数获取更详细（更多的冗余）的信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m unittest -v test_module</span><br></pre></td></tr></table></figure>
<p>当运行时不包含参数，开始 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest-test-discovery" target="_blank" rel="noopener">探索性测试</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m unittest</span><br></pre></td></tr></table></figure>
<p>用于获取命令行选项列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m unittest -h</span><br></pre></td></tr></table></figure>
<p> <em>在 3.2 版更改:</em> 在早期版本中，只支持运行独立的测试方法，而不支持模块和类。 </p>
<h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><p><strong>unittest</strong> 支持下面的命令行选项:</p>
<ul>
<li><p><code>-b, --buffer</code></p>
<p>在测试运行时，标准输出流与标准错误流会被放入缓冲区。成功的测试的运行时输出会被丢弃；测试不通过时，测试运行中的输出会正常显示，错误会被加入到测试失败信息。</p>
</li>
<li><p><code>-c, --catch</code></p>
<p>当测试正在运行时， Control-C 会等待当前测试完成，并在完成后报告已执行的测试的结果。当再次按下 Control-C 时，引发平常的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyboardInterrupt" target="_blank" rel="noopener"><code>KeyboardInterrupt</code></a> 异常。See <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#signal-handling" target="_blank" rel="noopener">Signal Handling</a> for the functions that provide this functionality.</p>
</li>
<li><p><code>-f, --failfast</code></p>
<p>当出现第一个错误或者失败时，停止运行测试。</p>
</li>
<li><p><code>-k</code></p>
<p>只运行匹配模式或子串的测试方法和类。可以多次使用这个选项，以便包含匹配子串的所有测试用例。包含通配符（*）的模式使用 <a href="https://docs.python.org/zh-cn/3.8/library/fnmatch.html#fnmatch.fnmatchcase" target="_blank" rel="noopener"><code>fnmatch.fnmatchcase()</code></a> 对测试名称进行匹配。另外，该匹配是大小写敏感的。模式对测试加载器导入的测试方法全名进行匹配。例如，<code>-k foo</code> 可以匹配到 <code>foo_tests.SomeTest.test_something</code> 和 <code>bar_tests.SomeTest.test_foo</code> ，但是不能匹配到 <code>bar_tests.FooTest.test_something</code> 。</p>
</li>
<li><p><code>--locals</code></p>
<p>在回溯中显示局部变量。</p>
</li>
</ul>
<p><em>3.2 新版功能:</em> 添加命令行选项 <code>-b</code>, <code>-c</code> 和 <code>-f</code> 。</p>
<p><em>3.5 新版功能:</em> 命令行选项 <code>--locals</code> 。</p>
<p><em>3.7 新版功能:</em> 命令行选项 <code>-k</code> 。</p>
<p>命令行亦可用于探索性测试，以运行一个项目的所有测试或其子集。</p>
<h2 id="探索性测试"><a href="#探索性测试" class="headerlink" title="探索性测试"></a>探索性测试</h2><p><em>3.2 新版功能.</em></p>
<p>Unittest支持简单的测试搜索。若需要使用探索性测试，所有的测试文件必须是 <a href="https://docs.python.org/zh-cn/3.8/tutorial/modules.html#tut-modules" target="_blank" rel="noopener">modules</a> 或 <a href="https://docs.python.org/zh-cn/3.8/tutorial/modules.html#tut-packages" target="_blank" rel="noopener">packages</a> （包括 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-namespace-package" target="_blank" rel="noopener">namespace packages</a> )并可从项目根目录导入（即它们的文件名必须是有效的 <a href="https://docs.python.org/zh-cn/3.8/reference/lexical_analysis.html#identifiers" target="_blank" rel="noopener">identifiers</a> ）。</p>
<p>探索性测试在 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestLoader.discover" target="_blank" rel="noopener"><code>TestLoader.discover()</code></a> 中实现，但也可以通过命令行使用。它在命令行中的基本用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd project_directory</span><br><span class="line">python -m unittest discover</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方便起见， <code>python -m unittest</code> 与 <code>python -m unittest discover</code> 等价。如果你需要向探索性测试传入参数，必须显式地使用 <code>discover</code> 子命令。</p>
</blockquote>
<p><code>discover</code> 有以下选项：</p>
<ul>
<li><p><code>-v, --verbose</code></p>
<p>更详细地输出结果。</p>
</li>
<li><p><code>-s, --start-directory directory</code></p>
<p>开始进行搜索的目录(默认值为当前目录 <code>.</code> )。</p>
</li>
<li><p><code>-p, --pattern pattern</code></p>
<p>用于匹配测试文件的模式（默认为 <code>test*.py</code> ）。</p>
</li>
<li><p><code>-t, --top-level-directory directory</code></p>
<p>指定项目的最上层目录（通常为开始时所在目录）。</p>
</li>
</ul>
<p><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#cmdoption-unittest-discover-s" target="_blank" rel="noopener"><code>-s</code></a> ，<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#cmdoption-unittest-discover-p" target="_blank" rel="noopener"><code>-p</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#cmdoption-unittest-discover-t" target="_blank" rel="noopener"><code>-t</code></a> 选项可以按顺序作为位置参数传入。以下两条命令是等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m unittest discover -s project_directory -p <span class="string">"*_test.py"</span></span><br><span class="line">python -m unittest discover project_directory <span class="string">"*_test.py"</span></span><br></pre></td></tr></table></figure>
<p>正如可以传入路径那样，传入一个包名作为起始目录也是可行的，如 <code>myproject.subpackage.test</code> 。你提供的包名会被导入，它在文件系统中的位置会被作为起始目录。</p>
<blockquote>
<p>探索性测试通过导入测试对测试进行加载。在找到所有你指定的开始目录下的所有测试文件后，它把路径转换为包名并进行导入。如 <code>foo/bar/baz.py</code> 会被导入为 <code>foo.bar.baz</code> 。</p>
</blockquote>
<p>如果你有一个全局安装的包，并尝试对这个包的副本进行探索性测试，可能会从错误的地方开始导入。如果出现这种情况，测试会输出警告并退出。</p>
<p>如果你使用包名而不是路径作为开始目录，搜索时会假定它导入的是你想要的目录，所以你不会收到警告。</p>
<p>测试模块和包可以通过 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#load-tests-protocol" target="_blank" rel="noopener">load_tests protocol</a> 自定义测试的加载和搜索。</p>
<p><em>在 3.4 版更改:</em> 探索性测试支持命名空间包（ <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-namespace-package" target="_blank" rel="noopener">namespace packages</a> ）。</p>
<h2 id="组织你的测试代码"><a href="#组织你的测试代码" class="headerlink" title="组织你的测试代码"></a>组织你的测试代码</h2><p>单元测试的构建单位是 <em>test cases</em> ：独立的、包含执行条件与正确性检查的方案。在 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 中，测试用例表示为 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>unittest.TestCase</code></a> 的实例。通过编写 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a> 的子类或使用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.FunctionTestCase" target="_blank" rel="noopener"><code>FunctionTestCase</code></a> 编写你自己的测试用例。</p>
<p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a> 实例的测试代码必须是完全自含的，因此它可以独立运行，或与其它任意组合任意数量的测试用例一起运行。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a> 的最简单的子类需要实现一个测试方法（例如一个命名以 <code>test</code> 开头的方法）以执行特定的测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultWidgetSizeTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_default_widget_size</span><span class="params">(self)</span>:</span></span><br><span class="line">        widget = Widget(<span class="string">'The widget'</span>)</span><br><span class="line">        self.assertEqual(widget.size(), (<span class="number">50</span>, <span class="number">50</span>))</span><br></pre></td></tr></table></figure>
<p>可以看到，为了进行测试，我们使用了基类 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a> 提供的其中一个 <code>assert*()</code> 方法。若测试不通过，将会引发一个带有说明信息的异常，并且 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 会将这个测试用例标记为测试不通过。任何其它类型的异常将会被当做错误处理。</p>
<p>可能同时存在多个前置操作相同的测试，我们可以把测试的前置操作从测试代码中拆解出来，并实现测试前置方法 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener"><code>setUp()</code></a> 。在运行测试时，测试框架会自动地为每个单独测试调用前置方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.widget = Widget(<span class="string">'The widget'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_default_widget_size</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(self.widget.size(), (<span class="number">50</span>,<span class="number">50</span>),</span><br><span class="line">                         <span class="string">'incorrect default size'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_widget_resize</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.widget.resize(<span class="number">100</span>,<span class="number">150</span>)</span><br><span class="line">        self.assertEqual(self.widget.size(), (<span class="number">100</span>,<span class="number">150</span>),</span><br><span class="line">                         <span class="string">'wrong size after resize'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 多个测试运行的顺序由内置字符串排序方法对测试名进行排序的结果决定。 </p>
</blockquote>
<p>在测试运行时，若 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener"><code>setUp()</code></a> 方法引发异常，测试框架会认为测试发生了错误，因此测试方法不会被运行。</p>
<p>相似的，我们提供了一个 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.tearDown" target="_blank" rel="noopener"><code>tearDown()</code></a> 方法在测试方法运行后进行清理工作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.widget = Widget(<span class="string">'The widget'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.widget.dispose()</span><br></pre></td></tr></table></figure>
<p>若 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener"><code>setUp()</code></a> 成功运行，无论测试方法是否成功，都会运行 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.tearDown" target="_blank" rel="noopener"><code>tearDown()</code></a> 。</p>
<p>这样的一个测试代码运行的环境被称为 <em>test fixture</em> 。一个新的 TestCase 实例作为一个测试脚手架，用于运行各个独立的测试方法。在运行每个测试时，<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener"><code>setUp()</code></a> 、<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.tearDown" target="_blank" rel="noopener"><code>tearDown()</code></a> 和 <code>__init__()</code> 会被调用一次。</p>
<p>建议使用TestCase来实现根据测试实现的功能将测试组合在一起。·单元测试通机制,在一个测试集中的测试套件中组织的方式。</p>
<p>通常情况,调用<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.main" target="_blank" rel="noopener"><code>unittest.main()</code></a>来执行测试。</p>
<p>然而，如果你需要自定义你的测试套件的话，你可以参考以下方法组织你的测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">suite</span><span class="params">()</span>:</span></span><br><span class="line">    suite = unittest.TestSuite()</span><br><span class="line">    suite.addTest(WidgetTestCase(<span class="string">'test_default_widget_size'</span>))</span><br><span class="line">    suite.addTest(WidgetTestCase(<span class="string">'test_widget_resize'</span>))</span><br><span class="line">    <span class="keyword">return</span> suite</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    runner = unittest.TextTestRunner()</span><br><span class="line">    runner.run(suite())</span><br></pre></td></tr></table></figure>
<p>您可以将测试用例和测试套件的定义与它们要测试的代码放在相同的模块中（例如“ widget.py”），但是将测试代码放置在独立的模块中有很多优点，例如“ test_widget.py`：</p>
<p>你可以遵循以下原则：</p>
<ul>
<li>测试模块可以通过命令行方式单独运行</li>
<li>测试脚本可以很容易被隔离</li>
<li>在没有充分理由的情况下,尽量不要为了适配代码而修改测试代码。</li>
<li>测试代码的修改频率应低于其测试的代码。</li>
<li>测试的代码可以更容易地重构。</li>
<li>无论如何用c编写的模块都必须在一个模块中隔离,为什么必须要一致呢？</li>
<li>如果测试策略更改了,没必要去修改测试代码</li>
</ul>
<h2 id="复用已有的测试代码"><a href="#复用已有的测试代码" class="headerlink" title="复用已有的测试代码"></a>复用已有的测试代码</h2><p>一些用户希望直接使用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 运行已有的测试代码，而不需要把已有的每个测试函数转化为一个 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a> 的子类。</p>
<p>因此， <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 提供 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.FunctionTestCase" target="_blank" rel="noopener"><code>FunctionTestCase</code></a> 类。这个 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a> 的子类可用于打包已有的测试函数，并支持设置前置与后置函数。</p>
<p>假定有一个测试函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSomething</span><span class="params">()</span>:</span></span><br><span class="line">    something = makeSomething()</span><br><span class="line">    <span class="keyword">assert</span> something.name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>可以创建等价的测试用例如下，其中前置和后置方法是可选的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">testcase = unittest.FunctionTestCase(testSomething,</span><br><span class="line">                                     setUp=makeSomethingDB,</span><br><span class="line">                                     tearDown=deleteSomethingDB)</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 尽管 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.FunctionTestCase" target="_blank" rel="noopener"><code>FunctionTestCase</code></a> 可以快速将一个已经存在的测试转换为基于<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a>的系统,但是不推荐这么做。好好设计<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a>子类将会在未来重构代码变得更容易。</p>
</blockquote>
<p>在特定情况下,现有的测试可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/doctest.html#module-doctest" target="_blank" rel="noopener"><code>doctest</code></a>  模块。如果是那样,  会绑定<code>DocTestSuite</code> 类从已经存在的  <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestSuite" target="_blank" rel="noopener"><code>unittest.TestSuite</code></a> 自动构建 基于<a href="https://docs.python.org/zh-cn/3.8/library/doctest.html#module-doctest" target="_blank" rel="noopener"><code>doctest</code></a>  实例。</p>
<h2 id="忽略测试与预计的失败"><a href="#忽略测试与预计的失败" class="headerlink" title="忽略测试与预计的失败"></a>忽略测试与预计的失败</h2><p><em>3.1 新版功能.</em></p>
<p><code>Unittest</code> 支持忽略测试方法或者忽略整个测试。除此以外,还支持标注某个测试”强制失败”,但是在<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestResult" target="_blank" rel="noopener"><code>TestResult</code></a> 中不会体现这类测试为失败。</p>
<p>忽略测试可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.skip" target="_blank" rel="noopener"><code>skip()</code></a> <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-decorator" target="_blank" rel="noopener">decorator</a> 装饰器,或者其中一些条件变量,直接添加<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.SkipTest" target="_blank" rel="noopener"><code>SkipTest</code></a> 注解</p>
<p>忽略测试的基本用法如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @unittest.skip("demonstrating skipping")</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_nothing</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fail(<span class="string">"shouldn't happen"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @unittest.skipIf(mylib.__version__ &lt; (1, 3),</span></span><br><span class="line">                     <span class="string">"not supported in this library version"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_format</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Tests that work for only a certain version of the library.</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @unittest.skipUnless(sys.platform.startswith("win"), "requires Windows")</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_windows_support</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># windows specific testing code</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_maybe_skipped</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> external_resource_available():</span><br><span class="line">            self.skipTest(<span class="string">"external resource not available"</span>)</span><br><span class="line">        <span class="comment"># test code that depends on the external resource</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>在详细测试模式下运行以上测试例子时，程序输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_format (__main__.MyTestCase) ... skipped <span class="string">'not supported in this library version'</span></span><br><span class="line">test_nothing (__main__.MyTestCase) ... skipped <span class="string">'demonstrating skipping'</span></span><br><span class="line">test_maybe_skipped (__main__.MyTestCase) ... skipped <span class="string">'external resource not available'</span></span><br><span class="line">test_windows_support (__main__.MyTestCase) ... skipped <span class="string">'requires Windows'</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">4</span> tests <span class="keyword">in</span> <span class="number">0.005</span>s</span><br><span class="line"></span><br><span class="line">OK (skipped=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>忽略测试类的写法跟忽略测试方法的写法相似:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@unittest.skip("showing class skipping")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySkippedTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_not_run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener"><code>TestCase.setUp()</code></a> 也可以忽略测试。可以用于所需资源不可用的情况下忽略接下来的测试。</p>
<p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.expectedFailure" target="_blank" rel="noopener"><code>expectedFailure()</code></a> 装饰器表明这个测试预计失败。:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpectedFailureTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"><span class="meta">    @unittest.expectedFailure</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_fail</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"broken"</span>)</span><br></pre></td></tr></table></figure>
<p>通过测试方法中调用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.skip" target="_blank" rel="noopener"><code>skip()</code></a>装饰器，可以轻松忽略那些希望被忽略的测试。除非传递的对象具有某个属性，否则此装饰器将起作用,如下面的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skipUnlessHasattr</span><span class="params">(obj, attr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(obj, attr):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> func: func</span><br><span class="line">    <span class="keyword">return</span> unittest.skip(<span class="string">"&#123;!r&#125; doesn't have &#123;!r&#125;"</span>.format(obj, attr))</span><br></pre></td></tr></table></figure>
<p>下面的装饰器和异常处理可以直接忽略期望失败的测试:</p>
<ul>
<li><p><a href="mailto:`@unittest.skip" target="_blank" rel="noopener">`@unittest.skip</a>`(<em>reason</em>)</p>
<p>忽略被此装饰器装饰的测试。 <em>reason</em> 为测试被忽略的原因。</p>
</li>
<li><p><a href="mailto:`@unittest.skipIf" target="_blank" rel="noopener">`@unittest.skipIf</a>`(<em>condition</em>, <em>reason</em>)</p>
<p>当 <em>condition</em> 为真时，忽略被装饰的测试。</p>
</li>
<li><p><a href="mailto:`@unittest.skipUnless" target="_blank" rel="noopener">`@unittest.skipUnless</a>`(<em>condition</em>, <em>reason</em>)</p>
<p>忽略被装饰的测试，除非 <em>condition</em> 为真。</p>
</li>
<li><p><a href="mailto:`@unittest.expectedFailure" target="_blank" rel="noopener">`@unittest.expectedFailure</a>`</p>
<p>把测试标记为预计失败。如果测试不通过，会被认为测试成功；如果测试通过了，则被认为是测试失败。</p>
</li>
<li><p><em>exception</em> <code>unittest.SkipTest</code>(<em>reason</em>)</p>
<p>引发此异常以忽略一个测试。通常来说，你可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.skipTest" target="_blank" rel="noopener"><code>TestCase.skipTest()</code></a> 或其中一个忽略测试的装饰器实现忽略测试的功能，而不是直接引发此异常。</p>
</li>
</ul>
<p>被忽略的测试的 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener"><code>setUp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.tearDown" target="_blank" rel="noopener"><code>tearDown()</code></a> 不会被运行。被忽略的类的 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUpClass" target="_blank" rel="noopener"><code>setUpClass()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.tearDownClass" target="_blank" rel="noopener"><code>tearDownClass()</code></a> 不会被运行。被忽略的模组的 <code>setUpModule()</code> 和 <code>tearDownModule()</code> 不会被运行。</p>
<h2 id="使用-subtest-执行Distinguishing-test迭代"><a href="#使用-subtest-执行Distinguishing-test迭代" class="headerlink" title="使用 subtest 执行Distinguishing test迭代"></a>使用 subtest 执行Distinguishing test迭代</h2><p><em>3.4 新版功能.</em></p>
<p>如果测试之间的差异很小，例如某些参数，则unittest允许您使用<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.subTest" target="_blank" rel="noopener"><code>subTest()</code></a> 的上下文装饰器</p>
<p>例如，以下测试:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumbersTest</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_even</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Test that numbers between 0 and 5 are all even.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">6</span>):</span><br><span class="line">            <span class="keyword">with</span> self.subTest(i=i):</span><br><span class="line">                self.assertEqual(i % <span class="number">2</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>可以得到以下输出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">======================================================================</span><br><span class="line">FAIL: test_even (__main__.NumbersTest) (i=<span class="number">1</span>)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"subtests.py"</span>, line <span class="number">32</span>, <span class="keyword">in</span> test_even</span><br><span class="line">    self.assertEqual(i % <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">AssertionError: <span class="number">1</span> != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_even (__main__.NumbersTest) (i=<span class="number">3</span>)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"subtests.py"</span>, line <span class="number">32</span>, <span class="keyword">in</span> test_even</span><br><span class="line">    self.assertEqual(i % <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">AssertionError: <span class="number">1</span> != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_even (__main__.NumbersTest) (i=<span class="number">5</span>)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"subtests.py"</span>, line <span class="number">32</span>, <span class="keyword">in</span> test_even</span><br><span class="line">    self.assertEqual(i % <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">AssertionError: <span class="number">1</span> != <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果不使用子测试，则在第一次失败后执行将停止，并且错误将不那么容易诊断，因为不会显示<code>i</code>的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">======================================================================</span><br><span class="line">FAIL: test_even (__main__.NumbersTest)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"subtests.py"</span>, line <span class="number">32</span>, <span class="keyword">in</span> test_even</span><br><span class="line">    self.assertEqual(i % <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">AssertionError: <span class="number">1</span> != <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>unittest</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library turtle</title>
    <url>/2020/02/27/python-standard-library-turtle/</url>
    <content><![CDATA[<h1 id="python-标准库-turtle-海龟制图"><a href="#python-标准库-turtle-海龟制图" class="headerlink" title="python 标准库 turtle 海龟制图"></a>python 标准库 turtle 海龟制图</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200227turtle.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>turtle n  海龟</p>
<p>vi. 捕海龟，捕鳖； （船等）翻没，倾覆；</p>
</blockquote>
<p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/turtle.py" target="_blank" rel="noopener">Lib/turtle.py</a></p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>海龟绘图很适合用来引导孩子学习编程。 最初来自于 Wally Feurzeig, Seymour Papert 和 Cynthia Solomon 于 1967 年所创造的 Logo 编程语言。</p>
<p>请想象绘图区有一只机器海龟，起始位置在 x-y 平面的 (0, 0) 点。先执行 <code>import turtle</code>，再执行 <code>turtle.forward(15)</code>，它将(在屏幕上)朝所面对的 x 轴正方向前进 15 像素，随着它的移动画出一条线段。再执行 <code>turtle.right(25)</code>，它将原地右转 25 度。</p>
<p>通过组合使用此类命令，可以轻松地绘制出精美的形状和图案。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 模块是基于 Python 标准发行版 2.5 以来的同名模块重新编写并进行了功能扩展。</p>
<p>新模块尽量保持了原模块的特点，并且(几乎)100%与其兼容。这就意味着初学编程者能够以交互方式使用模块的所有命令、类和方法——运行 IDLE 时注意加 <code>-n</code> 参数。</p>
<p>turtle 模块提供面向对象和面向过程两种形式的海龟绘图基本组件。由于它使用 <a href="https://docs.python.org/zh-cn/3.8/library/tkinter.html#module-tkinter" target="_blank" rel="noopener"><code>tkinter</code></a> 实现基本图形界面，因此需要安装了 Tk 支持的 Python 版本。</p>
<p>面向对象的接口主要使用“2+2”个类：</p>
<ol>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 类定义图形窗口作为绘图海龟的运动场。它的构造器需要一个 <code>tkinter.Canvas</code> 或 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ScrolledCanvas" target="_blank" rel="noopener"><code>ScrolledCanvas</code></a> 作为参数。应在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 作为某个程序的一部分的时候使用。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Screen" target="_blank" rel="noopener"><code>Screen()</code></a> 函数返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 子类的单例对象。此函数应在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 作为独立绘图工具时使用。作为一个单例对象，其所属的类是不可被继承的。</p>
<p>TurtleScreen/Screen 的所有方法还存在对应的函数，即作为面向过程的接口组成部分。</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.RawTurtle" target="_blank" rel="noopener"><code>RawTurtle</code></a> (别名: <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.RawPen" target="_blank" rel="noopener"><code>RawPen</code></a>) 类定义海龟对象在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 上绘图。它的构造器需要一个 Canvas, ScrolledCanvas 或 TurtleScreen 作为参数，以指定 RawTurtle 对象在哪里绘图。</p>
<p>从 RawTurtle 派生出子类 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Turtle" target="_blank" rel="noopener"><code>Turtle</code></a> (别名: <code>Pen</code>)，该类对象在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Screen" target="_blank" rel="noopener"><code>Screen</code></a> 实例上绘图，如果实例不存在则会自动创建。</p>
<p>RawTurtle/Turtle 的所有方法也存在对应的函数，即作为面向过程的接口组成部分。</p>
</li>
</ol>
<p>过程式接口提供与 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Screen" target="_blank" rel="noopener"><code>Screen</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Turtle" target="_blank" rel="noopener"><code>Turtle</code></a> 类的方法相对应的函数。函数名与对应的方法名相同。当 Screen 类的方法对应函数被调用时会自动创建一个 Screen 对象。当 Turtle 类的方法对应函数被调用时会自动创建一个 (匿名的) Turtle 对象。</p>
<p>如果屏幕上需要有多个海龟，就必须使用面向对象的接口。</p>
<h2 id="可用的-Turtle-和-Screen-方法概览"><a href="#可用的-Turtle-和-Screen-方法概览" class="headerlink" title="可用的 Turtle 和 Screen 方法概览"></a>可用的 Turtle 和 Screen 方法概览</h2><h3 id="Turtle-方法"><a href="#Turtle-方法" class="headerlink" title="Turtle 方法"></a>Turtle 方法</h3><p>海龟动作</p>
<ul>
<li><p>移动和绘制</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.forward" target="_blank" rel="noopener"><code>forward()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.fd" target="_blank" rel="noopener"><code>fd()</code></a> 前进</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.backward" target="_blank" rel="noopener"><code>backward()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.bk" target="_blank" rel="noopener"><code>bk()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.back" target="_blank" rel="noopener"><code>back()</code></a> 后退</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.right" target="_blank" rel="noopener"><code>right()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.rt" target="_blank" rel="noopener"><code>rt()</code></a> 右转</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.left" target="_blank" rel="noopener"><code>left()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.lt" target="_blank" rel="noopener"><code>lt()</code></a> 左转</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.goto" target="_blank" rel="noopener"><code>goto()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setpos" target="_blank" rel="noopener"><code>setpos()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setposition" target="_blank" rel="noopener"><code>setposition()</code></a> 前往/定位</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setx" target="_blank" rel="noopener"><code>setx()</code></a> 设置x坐标</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.sety" target="_blank" rel="noopener"><code>sety()</code></a> 设置y坐标</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setheading" target="_blank" rel="noopener"><code>setheading()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.seth" target="_blank" rel="noopener"><code>seth()</code></a> 设置朝向</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.home" target="_blank" rel="noopener"><code>home()</code></a> 返回原点</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.circle" target="_blank" rel="noopener"><code>circle()</code></a> 画圆</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.dot" target="_blank" rel="noopener"><code>dot()</code></a> 画点</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.stamp" target="_blank" rel="noopener"><code>stamp()</code></a> 印章</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clearstamp" target="_blank" rel="noopener"><code>clearstamp()</code></a> 清除印章</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clearstamps" target="_blank" rel="noopener"><code>clearstamps()</code></a> 清除多个印章</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.undo" target="_blank" rel="noopener"><code>undo()</code></a> 撤消</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.speed" target="_blank" rel="noopener"><code>speed()</code></a> 速度</p>
</li>
<li><p>获取海龟的状态</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.position" target="_blank" rel="noopener"><code>position()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pos" target="_blank" rel="noopener"><code>pos()</code></a> 位置</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.towards" target="_blank" rel="noopener"><code>towards()</code></a> 目标方向</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.xcor" target="_blank" rel="noopener"><code>xcor()</code></a> x坐标</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ycor" target="_blank" rel="noopener"><code>ycor()</code></a> y坐标</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.heading" target="_blank" rel="noopener"><code>heading()</code></a> 朝向</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.distance" target="_blank" rel="noopener"><code>distance()</code></a> 距离</p>
</li>
<li><p>设置与度量单位</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.degrees" target="_blank" rel="noopener"><code>degrees()</code></a> 角度</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.radians" target="_blank" rel="noopener"><code>radians()</code></a> 弧度</p>
</li>
</ul>
<p>画笔控制</p>
<ul>
<li><p>绘图状态</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pendown" target="_blank" rel="noopener"><code>pendown()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pd" target="_blank" rel="noopener"><code>pd()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.down" target="_blank" rel="noopener"><code>down()</code></a> 画笔落下</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.penup" target="_blank" rel="noopener"><code>penup()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pu" target="_blank" rel="noopener"><code>pu()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.up" target="_blank" rel="noopener"><code>up()</code></a> 画笔抬起</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pensize" target="_blank" rel="noopener"><code>pensize()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.width" target="_blank" rel="noopener"><code>width()</code></a> 画笔粗细</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pen" target="_blank" rel="noopener"><code>pen()</code></a> 画笔</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.isdown" target="_blank" rel="noopener"><code>isdown()</code></a> 画笔是否落下</p>
</li>
<li><p>颜色控制</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.color" target="_blank" rel="noopener"><code>color()</code></a> 颜色</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pencolor" target="_blank" rel="noopener"><code>pencolor()</code></a> 画笔颜色</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.fillcolor" target="_blank" rel="noopener"><code>fillcolor()</code></a> 填充颜色</p>
</li>
<li><p>填充</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.filling" target="_blank" rel="noopener"><code>filling()</code></a> 是否填充</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.begin_fill" target="_blank" rel="noopener"><code>begin_fill()</code></a> 开始填充</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.end_fill" target="_blank" rel="noopener"><code>end_fill()</code></a> 结束填充</p>
</li>
<li><p>更多绘图控制</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.reset" target="_blank" rel="noopener"><code>reset()</code></a> 重置</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clear" target="_blank" rel="noopener"><code>clear()</code></a> 清空</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.write" target="_blank" rel="noopener"><code>write()</code></a> 书写</p>
</li>
</ul>
<p>海龟状态</p>
<ul>
<li><p>可见性</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.showturtle" target="_blank" rel="noopener"><code>showturtle()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.st" target="_blank" rel="noopener"><code>st()</code></a> 显示海龟</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.hideturtle" target="_blank" rel="noopener"><code>hideturtle()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ht" target="_blank" rel="noopener"><code>ht()</code></a> 隐藏海龟</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.isvisible" target="_blank" rel="noopener"><code>isvisible()</code></a> 是否可见</p>
</li>
<li><p>外观</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shape" target="_blank" rel="noopener"><code>shape()</code></a> 形状</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.resizemode" target="_blank" rel="noopener"><code>resizemode()</code></a> 大小调整模式</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shapesize" target="_blank" rel="noopener"><code>shapesize()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.turtlesize" target="_blank" rel="noopener"><code>turtlesize()</code></a> 形状大小</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shearfactor" target="_blank" rel="noopener"><code>shearfactor()</code></a> 剪切因子</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.settiltangle" target="_blank" rel="noopener"><code>settiltangle()</code></a> 设置倾角</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.tiltangle" target="_blank" rel="noopener"><code>tiltangle()</code></a> 倾角</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.tilt" target="_blank" rel="noopener"><code>tilt()</code></a> 倾斜</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shapetransform" target="_blank" rel="noopener"><code>shapetransform()</code></a> 变形</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.get_shapepoly" target="_blank" rel="noopener"><code>get_shapepoly()</code></a> 获取形状多边形</p>
</li>
</ul>
<p>使用事件</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onclick" target="_blank" rel="noopener"><code>onclick()</code></a> 当鼠标点击</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onrelease" target="_blank" rel="noopener"><code>onrelease()</code></a> 当鼠标释放</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ondrag" target="_blank" rel="noopener"><code>ondrag()</code></a> 当鼠标拖动</p>
<p>特殊海龟方法</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.begin_poly" target="_blank" rel="noopener"><code>begin_poly()</code></a> 开始记录多边形</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.end_poly" target="_blank" rel="noopener"><code>end_poly()</code></a> 结束记录多边形</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.get_poly" target="_blank" rel="noopener"><code>get_poly()</code></a> 获取多边形</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clone" target="_blank" rel="noopener"><code>clone()</code></a> 克隆</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getturtle" target="_blank" rel="noopener"><code>getturtle()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getpen" target="_blank" rel="noopener"><code>getpen()</code></a> 获取海龟画笔</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getscreen" target="_blank" rel="noopener"><code>getscreen()</code></a> 获取屏幕</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setundobuffer" target="_blank" rel="noopener"><code>setundobuffer()</code></a> 设置撤消缓冲区</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.undobufferentries" target="_blank" rel="noopener"><code>undobufferentries()</code></a> 撤消缓冲区条目数</p>
<h3 id="TurtleScreen-Screen-方法"><a href="#TurtleScreen-Screen-方法" class="headerlink" title="TurtleScreen/Screen 方法"></a>TurtleScreen/Screen 方法</h3><ul>
<li><p>窗口控制</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.bgcolor" target="_blank" rel="noopener"><code>bgcolor()</code></a> 背景颜色</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.bgpic" target="_blank" rel="noopener"><code>bgpic()</code></a> 背景图片</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clear" target="_blank" rel="noopener"><code>clear()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clearscreen" target="_blank" rel="noopener"><code>clearscreen()</code></a> 清屏</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.reset" target="_blank" rel="noopener"><code>reset()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.resetscreen" target="_blank" rel="noopener"><code>resetscreen()</code></a> 重置</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.screensize" target="_blank" rel="noopener"><code>screensize()</code></a> 屏幕大小</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setworldcoordinates" target="_blank" rel="noopener"><code>setworldcoordinates()</code></a> 设置世界坐标系</p>
</li>
<li><p>动画控制</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.delay" target="_blank" rel="noopener"><code>delay()</code></a> 延迟</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.tracer" target="_blank" rel="noopener"><code>tracer()</code></a> 追踪</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.update" target="_blank" rel="noopener"><code>update()</code></a> 更新</p>
<p>使用屏幕事件</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.listen" target="_blank" rel="noopener"><code>listen()</code></a> 监听</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onkey" target="_blank" rel="noopener"><code>onkey()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onkeyrelease" target="_blank" rel="noopener"><code>onkeyrelease()</code></a> 当键盘按下并释放</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onkeypress" target="_blank" rel="noopener"><code>onkeypress()</code></a> 当键盘按下</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onclick" target="_blank" rel="noopener"><code>onclick()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onscreenclick" target="_blank" rel="noopener"><code>onscreenclick()</code></a> 当点击屏幕</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ontimer" target="_blank" rel="noopener"><code>ontimer()</code></a> 当达到定时</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mainloop" target="_blank" rel="noopener"><code>mainloop()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.done" target="_blank" rel="noopener"><code>done()</code></a> 主循环</p>
</li>
<li><p>设置与特殊方法</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a> 模式</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.colormode" target="_blank" rel="noopener"><code>colormode()</code></a> 颜色模式</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getcanvas" target="_blank" rel="noopener"><code>getcanvas()</code></a> 获取画布</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getshapes" target="_blank" rel="noopener"><code>getshapes()</code></a> 获取形状</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.register_shape" target="_blank" rel="noopener"><code>register_shape()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.addshape" target="_blank" rel="noopener"><code>addshape()</code></a> 添加形状</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.turtles" target="_blank" rel="noopener"><code>turtles()</code></a> 所有海龟</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.window_height" target="_blank" rel="noopener"><code>window_height()</code></a> 窗口高度</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.window_width" target="_blank" rel="noopener"><code>window_width()</code></a> 窗口宽度</p>
</li>
<li><p>输入方法</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.textinput" target="_blank" rel="noopener"><code>textinput()</code></a> 文本输入</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.numinput" target="_blank" rel="noopener"><code>numinput()</code></a> 数字输入</p>
</li>
<li><p>Screen 专有方法</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.bye" target="_blank" rel="noopener"><code>bye()</code></a> 退出</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.exitonclick" target="_blank" rel="noopener"><code>exitonclick()</code></a> 当点击时退出</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setup" target="_blank" rel="noopener"><code>setup()</code></a> 设置</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.title" target="_blank" rel="noopener"><code>title()</code></a> 标题</p>
</li>
</ul>
<h2 id="RawTurtle-Turtle-方法和对应函数"><a href="#RawTurtle-Turtle-方法和对应函数" class="headerlink" title="RawTurtle/Turtle 方法和对应函数"></a>RawTurtle/Turtle 方法和对应函数</h2><p>本节中的大部分示例都使用 Turtle 类的一个实例，命名为 <code>turtle</code>。</p>
<h3 id="海龟动作"><a href="#海龟动作" class="headerlink" title="海龟动作"></a>海龟动作</h3><ul>
<li><p><code>turtle.forward</code>(<em>distance</em>)</p>
</li>
<li><p><code>turtle.fd</code>(<em>distance</em>)</p>
<p>参数<strong>distance</strong> – 一个数值 (整型或浮点型)海龟前进 <em>distance</em> 指定的距离，方向为海龟的朝向。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.forward(<span class="number">25</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">25.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.forward(<span class="number">-75</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">-50.00</span>,<span class="number">0.00</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>turtle.back</code>(<em>distance</em>)</p>
<p><code>turtle.bk</code>(<em>distance</em>)</p>
<p><code>turtle.backward</code>(<em>distance</em>)</p>
<ul>
<li>参数  :<strong>distance</strong> – 一个数值</li>
</ul>
<p>海龟后退 <em>distance</em> 指定的距离，方向与海龟的朝向相反。不改变海龟的朝向。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.backward(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">-30.00</span>,<span class="number">0.00</span>)</span><br></pre></td></tr></table></figure>
<p><code>turtle.right</code>(<em>angle</em>)</p>
<p><code>turtle.rt</code>(<em>angle</em>)</p>
<ul>
<li>参数：<strong>angle</strong> – 一个数值 (整型或浮点型)</li>
</ul>
<p>海龟右转 <em>angle</em> 个单位。(单位默认为角度，但可通过 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.degrees" target="_blank" rel="noopener"><code>degrees()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.radians" target="_blank" rel="noopener"><code>radians()</code></a> 函数改变设置。) 角度的正负由海龟模式确定，参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">22.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.right(<span class="number">45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">337.0</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.left</code>(<em>angle</em>)</p>
<p><code>turtle.lt</code>(<em>angle</em>)</p>
<ul>
<li>参数:<strong>angle</strong> – 一个数值 (整型或浮点型)</li>
</ul>
<p>海龟左转 <em>angle</em> 个单位。(单位默认为角度，但可通过 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.degrees" target="_blank" rel="noopener"><code>degrees()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.radians" target="_blank" rel="noopener"><code>radians()</code></a> 函数改变设置。) 角度的正负由海龟模式确定，参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">22.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">67.0</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.goto</code>(<em>x</em>, <em>y=None</em>)</p>
<p><code>turtle.setpos</code>(<em>x</em>, <em>y=None</em>)</p>
<p><code>turtle.setposition</code>(<em>x</em>, <em>y=None</em>)</p>
<ul>
<li>参数：<strong>x</strong> – 一个数值或数值对/向量<strong>y</strong> – 一个数值或 <code>None</code></li>
</ul>
<p>如果 <em>y</em> 为 <code>None</code>，<em>x</em> 应为一个表示坐标的数值对或 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Vec2D" target="_blank" rel="noopener"><code>Vec2D</code></a> 类对象 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pos" target="_blank" rel="noopener"><code>pos()</code></a> 返回的对象).</p>
<p>海龟移动到一个绝对坐标。如果画笔已落下将会画线。不改变海龟的朝向。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tp = turtle.pos()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tp</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setpos(<span class="number">60</span>,<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">60.00</span>,<span class="number">30.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setpos((<span class="number">20</span>,<span class="number">80</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">20.00</span>,<span class="number">80.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setpos(tp)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br></pre></td></tr></table></figure>
<p><code>turtle.setx</code>(<em>x</em>)</p>
<ul>
<li>参数:<strong>x</strong> – 一个数值 (整型或浮点型)</li>
</ul>
<p>设置海龟的横坐标为 <em>x</em>，纵坐标保持不变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">240.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setx(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">10.00</span>,<span class="number">240.00</span>)</span><br></pre></td></tr></table></figure>
<p><code>turtle.sety</code>(<em>y</em>)</p>
<ul>
<li>参数:<strong>y</strong> – 一个数值 (整型或浮点型)</li>
</ul>
<p>设置海龟的纵坐标为 <em>y</em>，横坐标保持不变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">40.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.sety(<span class="number">-10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">-10.00</span>)</span><br></pre></td></tr></table></figure>
<p><code>turtle.setheading</code>(<em>to_angle</em>)</p>
<p><code>turtle.seth</code>(<em>to_angle</em>)</p>
<ul>
<li>参数:<strong>to_angle</strong> – 一个数值 (整型或浮点型)</li>
</ul>
<p>设置海龟的朝向为 <em>to_angle</em>。以下是以角度表示的几个常用方向：</p>
<table>
<thead>
<tr>
<th>标准模式</th>
<th>logo 模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 - 东</td>
<td>0 - 北</td>
</tr>
<tr>
<td>90 - 北</td>
<td>90 - 东</td>
</tr>
<tr>
<td>180 - 西</td>
<td>180 - 南</td>
</tr>
<tr>
<td>270 - 南</td>
<td>270 - 西</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setheading(<span class="number">90</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.home</code>()</p>
<p>海龟移至初始坐标 (0,0)，并设置朝向为初始方向 (由海龟模式确定，参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">-10.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.circle</code>(<em>radius</em>, <em>extent=None</em>, <em>steps=None</em>)</p>
<p>三个参数:</p>
<ul>
<li><strong>radius</strong> – 一个数值</li>
<li><strong>extent</strong> – 一个数值 (或 <code>None</code>)</li>
<li><strong>steps</strong> – 一个整型数 (或 <code>None</code>)</li>
</ul>
<p>绘制一个 <em>radius</em> 指定半径的圆。圆心在海龟左边 <em>radius</em> 个单位；<em>extent</em> 为一个夹角，用来决定绘制圆的一部分。如未指定 <em>extent\</em>则绘制整个圆。如果 *extent<em> 不是完整圆周，则以当前画笔位置为一个端点绘制圆弧。如果 </em>radius<em> 为正值则朝逆时针方向绘制圆弧，否则朝顺时针方向。最终海龟的朝向会依据 </em>extent* 的值而改变。</p>
<p>圆实际是以其内切正多边形来近似表示的，其边的数量由 <em>steps</em> 指定。如果未指定边数则会自动确定。此方法也可用来绘制正多边形。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.circle(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">-0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.circle(<span class="number">120</span>, <span class="number">180</span>)  <span class="comment"># draw a semicircle</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">240.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">180.0</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.dot</code>(<em>size=None</em>, *<em>color</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>size</strong> – 一个整型数 &gt;= 1 (如果指定)<strong>color</strong> – 一个颜色字符串或颜色数值元组</p>
</li>
</ul>
<p>绘制一个直径为 <em>size</em>，颜色为 <em>color</em> 的圆点。如果 <em>size</em> 未指定，则直径取 pensize+4 和 2*pensize 中的较大值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.dot()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>); turtle.dot(<span class="number">20</span>, <span class="string">"blue"</span>); turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">100.00</span>,<span class="number">-0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.stamp</code>()</p>
<p>在海龟当前位置印制一个海龟形状。返回该印章的 stamp_id，印章可以通过调用 <code>clearstamp(stamp_id)</code> 来删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"blue"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.stamp()</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<p><code>turtle.clearstamp</code>(<em>stampid</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>stampid</strong> – 一个整型数，必须是之前 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.stamp" target="_blank" rel="noopener"><code>stamp()</code></a> 调用的返回值</p>
</li>
</ul>
<p>删除 <em>stampid</em> 指定的印章。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">150.00</span>,<span class="number">-0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"blue"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>astamp = turtle.stamp()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">200.00</span>,<span class="number">-0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.clearstamp(astamp)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">200.00</span>,<span class="number">-0.00</span>)</span><br></pre></td></tr></table></figure>
<p><code>turtle.clearstamps</code>(<em>n=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>n</strong> – 一个整型数 (或 <code>None</code>)</p>
</li>
</ul>
<p>删除全部或前/后 <em>n</em> 个海龟印章。如果 <em>n</em> 为 <code>None</code> 则删除全部印章，如果 <em>n</em> &gt; 0 则删除前 <em>n</em> 个印章，否则如果 <em>n</em> &lt; 0 则删除后 <em>n</em> 个印章。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line"><span class="meta">... </span>    turtle.stamp(); turtle.fd(<span class="number">30</span>)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.clearstamps(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.clearstamps(<span class="number">-2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.clearstamps()</span><br></pre></td></tr></table></figure>
<p><code>turtle.undo</code>()</p>
<p>撤消 (或连续撤消) 最近的一个 (或多个) 海龟动作。可撤消的次数由撤消缓冲区的大小决定。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    turtle.fd(<span class="number">50</span>); turtle.lt(<span class="number">80</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line"><span class="meta">... </span>    turtle.undo()</span><br></pre></td></tr></table></figure>
<p><code>turtle.speed</code>(<em>speed=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>speed</strong> – 一个 0..10 范围内的整型数或速度字符串 (见下)</p>
</li>
</ul>
<p>设置海龟移动的速度为 0..10 表示的整型数值。如未指定参数则返回当前速度。</p>
<p>如果输入数值大于 10 或小于 0.5 则速度设为 0。速度字符串与速度值的对应关系如下:</p>
<ul>
<li>“fastest”: 0 最快</li>
<li>“fast”: 10 快</li>
<li>“normal”: 6 正常</li>
<li>“slow”: 3 慢</li>
<li>“slowest”: 1 最慢</li>
</ul>
<p>速度值从 1 到 10，画线和海龟转向的动画效果逐级加快。</p>
<p>注意: <em>speed</em> = 0 表示 <em>没有</em> 动画效果。forward/back 将使海龟向前/向后跳跃，同样的 left/right 将使海龟立即改变朝向。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed(<span class="string">'normal'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed()</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed(<span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<h3 id="获取海龟的状态"><a href="#获取海龟的状态" class="headerlink" title="获取海龟的状态"></a>获取海龟的状态</h3><p><code>turtle.position</code>()</p>
<p><code>turtle.pos</code>()</p>
<p>返回海龟当前的坐标 (x,y) (为 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Vec2D" target="_blank" rel="noopener"><code>Vec2D</code></a> 矢量类对象)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">440.00</span>,<span class="number">-0.00</span>)</span><br></pre></td></tr></table></figure>
<p><code>urtle.towards</code>(<em>x</em>, <em>y=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>x</strong> – 一个数值或数值对/矢量，或一个海龟实例<strong>y</strong> – 一个数值——如果 <em>x</em> 是一个数值，否则为 <code>None</code></p>
</li>
</ul>
<p>从海龟位置到由 (x,y)，矢量或另一海龟对应位置的连线的夹角。此数值依赖于海龟初始朝向 - 由 “standard”/“world” 或 “logo” 模式设置所决定)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.goto(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.towards(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="number">225.0</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.xcor</code>()</p>
<p>返回海龟的 x 坐标。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.forward(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">64.28</span>,<span class="number">76.60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(round(turtle.xcor(), <span class="number">5</span>))</span><br><span class="line"><span class="number">64.27876</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.ycor</code>()</p>
<p>返回海龟的 y 坐标。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.forward(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(turtle.pos())</span><br><span class="line">(<span class="number">50.00</span>,<span class="number">86.60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(round(turtle.ycor(), <span class="number">5</span>))</span><br><span class="line"><span class="number">86.60254</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.heading</code>()</p>
<p>返回海龟当前的朝向 (数值依赖于海龟模式参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">67</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">67.0</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.distance</code>(<em>x</em>, <em>y=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>x</strong> – 一个数值或数值对/矢量，或一个海龟实例<strong>y</strong> – 一个数值——如果 <em>x</em> 是一个数值，否则为 <code>None</code></p>
</li>
</ul>
<p>返回从海龟位置到由 (x,y)，适量或另一海龟对应位置的单位距离。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.distance(<span class="number">30</span>,<span class="number">40</span>)</span><br><span class="line"><span class="number">50.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.distance((<span class="number">30</span>,<span class="number">40</span>))</span><br><span class="line"><span class="number">50.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe = Turtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe.forward(<span class="number">77</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.distance(joe)</span><br><span class="line"><span class="number">77.0</span></span><br></pre></td></tr></table></figure>
<h3 id="度量单位设置"><a href="#度量单位设置" class="headerlink" title="度量单位设置"></a>度量单位设置</h3><p><code>turtle.degrees</code>(<em>fullcircle=360.0</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>fullcircle</strong> – 一个数值</p>
</li>
</ul>
<p>设置角度的度量单位，即设置一个圆周为多少 “度”。默认值为 360 度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">90</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br><span class="line"></span><br><span class="line">Change angle measurement unit to grad (also known <span class="keyword">as</span> gon,</span><br><span class="line">grade, <span class="keyword">or</span> gradian <span class="keyword">and</span> equals <span class="number">1</span>/<span class="number">100</span>-th of the right angle.)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.degrees(<span class="number">400.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.degrees(<span class="number">360</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.radians</code>()</p>
<p>设置角度的度量单位为弧度。其值等于 <code>degrees(2*math.pi)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">90</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.radians()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">1.5707963267948966</span></span><br></pre></td></tr></table></figure>
<h3 id="画笔控制"><a href="#画笔控制" class="headerlink" title="画笔控制"></a>画笔控制</h3><h4 id="绘图状态"><a href="#绘图状态" class="headerlink" title="绘图状态"></a>绘图状态</h4><ul>
<li><p><code>turtle.pendown</code>()</p>
</li>
<li><p><code>turtle.pd</code>()</p>
</li>
<li><p><code>turtle.down</code>()</p>
<p>画笔落下 – 移动时将画线。</p>
</li>
<li><p><code>turtle.penup</code>()</p>
</li>
<li><p><code>turtle.pu</code>()</p>
</li>
<li><p><code>turtle.up</code>()</p>
<p>画笔抬起 – 移动时不画线。</p>
</li>
<li><p><code>turtle.pensize</code>(<em>width=None</em>)</p>
</li>
<li><p><code>turtle.width</code>(<em>width=None</em>)<a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.width" target="_blank" rel="noopener">¶</a></p>
</li>
<li><p>参数</p>
<p><strong>width</strong> – 一个正数值</p>
</li>
</ul>
<p>设置线条的粗细为 <em>width</em> 或返回该值。如果 resizemode 设为 “auto” 并且 turtleshape 为多边形，该多边形也以同样组细的线条绘制。如未指定参数，则返回当前的 pensize。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pensize()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pensize(<span class="number">10</span>)   <span class="comment"># from here on lines of width 10 are drawn</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>turtle.pen</code>(<em>pen=None</em>, <em>**pendict</em>)</p>
<p><strong>pen</strong> – 一个包含部分或全部下列键的字典</p>
<p><strong>pendict</strong> – 一个或多个以下列键为关键字的关键字参数</p>
<p>返回或设置画笔的属性，以一个包含以下键值对的 “画笔字典” 表示:</p>
<ul>
<li>“shown”: True/False</li>
<li>“pendown”: True/False</li>
<li>“pencolor”: 颜色字符串或颜色元组</li>
<li>“fillcolor”: 颜色字符串或颜色元组</li>
<li>“pensize”: 正数值</li>
<li>“speed”: 0..10 范围内的数值</li>
<li>“resizemode”: “auto” 或 “user” 或 “noresize”</li>
<li>“stretchfactor”: (正数值, 正数值)</li>
<li>“outline”: 正数值</li>
<li>“tilt”: 数值</li>
</ul>
</li>
</ul>
<p>此字典可作为后续调用 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pen" target="_blank" rel="noopener"><code>pen()</code></a> 时的参数，以恢复之前的画笔状态。另外还可将这些属性作为关键词参数提交。使用此方式可以用一条语句设置画笔的多个属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pen(fillcolor=<span class="string">"black"</span>, pencolor=<span class="string">"red"</span>, pensize=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(turtle.pen().items())</span><br><span class="line">[(<span class="string">'fillcolor'</span>, <span class="string">'black'</span>), (<span class="string">'outline'</span>, <span class="number">1</span>), (<span class="string">'pencolor'</span>, <span class="string">'red'</span>),</span><br><span class="line"> (<span class="string">'pendown'</span>, <span class="literal">True</span>), (<span class="string">'pensize'</span>, <span class="number">10</span>), (<span class="string">'resizemode'</span>, <span class="string">'noresize'</span>),</span><br><span class="line"> (<span class="string">'shearfactor'</span>, <span class="number">0.0</span>), (<span class="string">'shown'</span>, <span class="literal">True</span>), (<span class="string">'speed'</span>, <span class="number">9</span>),</span><br><span class="line"> (<span class="string">'stretchfactor'</span>, (<span class="number">1.0</span>, <span class="number">1.0</span>)), (<span class="string">'tilt'</span>, <span class="number">0.0</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>penstate=turtle.pen()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"yellow"</span>, <span class="string">""</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.penup()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(turtle.pen().items())[:<span class="number">3</span>]</span><br><span class="line">[(<span class="string">'fillcolor'</span>, <span class="string">''</span>), (<span class="string">'outline'</span>, <span class="number">1</span>), (<span class="string">'pencolor'</span>, <span class="string">'yellow'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pen(penstate, fillcolor=<span class="string">"green"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(turtle.pen().items())[:<span class="number">3</span>]</span><br><span class="line">[(<span class="string">'fillcolor'</span>, <span class="string">'green'</span>), (<span class="string">'outline'</span>, <span class="number">1</span>), (<span class="string">'pencolor'</span>, <span class="string">'red'</span>)]</span><br></pre></td></tr></table></figure>
<p><code>turtle.isdown</code>()</p>
<p>如果画笔落下返回 <code>True</code>，如果画笔抬起返回 <code>False</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.penup()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.isdown()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pendown()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.isdown()</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="颜色控制"><a href="#颜色控制" class="headerlink" title="颜色控制"></a>颜色控制</h4><p><code>turtle.pencolor</code>(*<em>args</em>)</p>
<p>返回或设置画笔颜色。</p>
<p>允许以下四种输入格式:</p>
<ul>
<li><p><code>pencolor()</code></p>
<p>返回以颜色描述字符串或元组 (见示例) 表示的当前画笔颜色。可用作其他 color/pencolor/fillcolor 调用的输入。</p>
</li>
<li><p><code>pencolor(colorstring)</code></p>
<p>设置画笔颜色为 <em>colorstring</em> 指定的 Tk 颜色描述字符串，例如 <code>&quot;red&quot;</code>、<code>&quot;yellow&quot;</code> 或 <code>&quot;#33cc8c&quot;</code>。</p>
</li>
<li><p><code>pencolor((r, g, b))</code></p>
<p>设置画笔颜色为以 <em>r</em>, <em>g</em>, <em>b</em> 元组表示的 RGB 颜色。<em>r</em>, <em>g</em>, <em>b</em> 的取值范围应为 0..colormode，colormode 的值为 1.0 或 255 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.colormode" target="_blank" rel="noopener"><code>colormode()</code></a>)。</p>
</li>
<li><p><code>pencolor(r, g, b)</code></p>
<p>设置画笔颜色为以 <em>r</em>, <em>g</em>, <em>b</em> 表示的 RGB 颜色。<em>r</em>, <em>g</em>, <em>b</em> 的取值范围应为 0..colormode。如果 turtleshape 为多边形，该多边形轮廓也以新设置的画笔颜色绘制。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colormode()</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line"><span class="string">'red'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(<span class="string">"brown"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line"><span class="string">'brown'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup = (<span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.55</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(tup)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line">(<span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.5490196078431373</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colormode(<span class="number">255</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line">(<span class="number">51.0</span>, <span class="number">204.0</span>, <span class="number">140.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(<span class="string">'#32c18f'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line">(<span class="number">50.0</span>, <span class="number">193.0</span>, <span class="number">143.0</span>)</span><br></pre></td></tr></table></figure>
<p><code>turtle.fillcolor</code>(*<em>args</em>)</p>
<p>返回或设置填充颜色。</p>
<p>允许以下四种输入格式:</p>
<ul>
<li><p><code>fillcolor()</code></p>
<p>返回以颜色描述字符串或元组 (见示例) 表示的当前填充颜色。可用作其他 color/pencolor/fillcolor 调用的输入。</p>
</li>
<li><p><code>fillcolor(colorstring)</code></p>
<p>设置填充颜色为 <em>colorstring</em> 指定的 Tk 颜色描述字符串，例如 <code>&quot;red&quot;</code>、<code>&quot;yellow&quot;</code> 或 <code>&quot;#33cc8c&quot;</code>。</p>
</li>
<li><p><code>fillcolor((r, g, b))</code></p>
<p>设置填充颜色为以 <em>r</em>, <em>g</em>, <em>b</em> 元组表示的 RGB 颜色。<em>r</em>, <em>g</em>, <em>b</em> 的取值范围应为 0..colormode，colormode 的值为 1.0 或 255 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.colormode" target="_blank" rel="noopener"><code>colormode()</code></a>)。</p>
</li>
<li><p><code>fillcolor(r, g, b)</code></p>
<p>设置填充颜色为 <em>r</em>, <em>g</em>, <em>b</em> 表示的 RGB 颜色。<em>r</em>, <em>g</em>, <em>b</em> 的取值范围应为 0..colormode。如果 turtleshape 为多边形，该多边形内部也以新设置的填充颜色填充。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor(<span class="string">"violet"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor()</span><br><span class="line"><span class="string">'violet'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line">(<span class="number">50.0</span>, <span class="number">193.0</span>, <span class="number">143.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor((<span class="number">50</span>, <span class="number">193</span>, <span class="number">143</span>))  <span class="comment"># Integers, not floats</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor()</span><br><span class="line">(<span class="number">50.0</span>, <span class="number">193.0</span>, <span class="number">143.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor(<span class="string">'#ffffff'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor()</span><br><span class="line">(<span class="number">255.0</span>, <span class="number">255.0</span>, <span class="number">255.0</span>)</span><br></pre></td></tr></table></figure>
<p><code>turtle.color</code>(*<em>args</em>)</p>
<p>返回或设置画笔颜色和填充颜色。</p>
<p>允许多种输入格式。使用如下 0 至 3 个参数:</p>
<ul>
<li><p><code>color()</code></p>
<p>返回以一对颜色描述字符串或元组表示的当前画笔颜色和填充颜色，两者可分别由 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pencolor" target="_blank" rel="noopener"><code>pencolor()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.fillcolor" target="_blank" rel="noopener"><code>fillcolor()</code></a> 返回。</p>
</li>
<li><p><code>color(colorstring)</code>, <code>color((r,g,b))</code>, <code>color(r,g,b)</code></p>
<p>输入格式与 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pencolor" target="_blank" rel="noopener"><code>pencolor()</code></a> 相同，同时设置填充颜色和画笔颜色为指定的值。</p>
</li>
<li><p><code>color(colorstring1, colorstring2)</code>, <code>color((r1,g1,b1), (r2,g2,b2))</code></p>
<p>相当于 <code>pencolor(colorstring1)</code> 加 <code>fillcolor(colorstring2)</code>，使用其他输入格式的方法也与之类似。如果 turtleshape 为多边形，该多边形轮廓与填充也使用新设置的颜色。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"red"</span>, <span class="string">"green"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color()</span><br><span class="line">(<span class="string">'red'</span>, <span class="string">'green'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color(<span class="string">"#285078"</span>, <span class="string">"#a0c8f0"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color()</span><br><span class="line">((<span class="number">40.0</span>, <span class="number">80.0</span>, <span class="number">120.0</span>), (<span class="number">160.0</span>, <span class="number">200.0</span>, <span class="number">240.0</span>))</span><br></pre></td></tr></table></figure>
<p>另参见: Screen 方法 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.colormode" target="_blank" rel="noopener"><code>colormode()</code></a>。</p>
<h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p><code>turtle.filling</code>()</p>
<p>返回填充状态 (填充为 <code>True</code>，否则为 <code>False</code>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.begin_fill()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> turtle.filling():</span><br><span class="line"><span class="meta">... </span>   turtle.pensize(<span class="number">5</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>   turtle.pensize(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>turtle.begin_fill</code>()<a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.begin_fill" target="_blank" rel="noopener">¶</a></p>
<p>在绘制要填充的形状之前调用。</p>
</li>
<li><p><code>turtle.end_fill</code>()</p>
<p>填充上次调用 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.begin_fill" target="_blank" rel="noopener"><code>begin_fill()</code></a> 之后绘制的形状。自相交多边形或多个形状间的重叠区域是否填充取决于操作系统的图形引擎、重叠的类型以及重叠的层数。 例如上面的 Turtle 多芒星可能会全部填充为黄色，也可能会有一些白色区域。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"black"</span>, <span class="string">"red"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.begin_fill()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.circle(<span class="number">80</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.end_fill()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="更多绘图控制"><a href="#更多绘图控制" class="headerlink" title="更多绘图控制"></a>更多绘图控制</h4><ul>
<li><p><code>turtle.reset</code>()</p>
<p>从屏幕中删除海龟的绘图，海龟回到原点并设置所有变量为默认值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.goto(<span class="number">0</span>,<span class="number">-22</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">-22.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>turtle.clear</code>()</p>
<p>从屏幕中删除指定海龟的绘图。不移动海龟。海龟的状态和位置以及其他海龟的绘图不受影响。</p>
</li>
<li><p><code>turtle.clear</code>()</p>
<p>从屏幕中删除指定海龟的绘图。不移动海龟。海龟的状态和位置以及其他海龟的绘图不受影响。</p>
</li>
<li><p><code>turtle.write</code>(<em>arg</em>, <em>move=False</em>, <em>align=”left”</em>, <em>font=(“Arial”</em>, <em>8</em>, <em>“normal”)</em>)</p>
<p>参数<strong>arg</strong> – 要书写到 TurtleScreen 的对象<strong>move</strong> – True/False<strong>align</strong> – 字符串 “left”, “center” 或 “right”<strong>font</strong> – 一个三元组 (fontname, fontsize, fonttype)书写文本 - <em>arg</em> 指定的字符串 - 到当前海龟位置，<em>align</em> 指定对齐方式 (“left”, “center” 或 right”)，font 指定字体。如果 <em>move</em> 为 True，画笔会移动到文本的右下角。默认 <em>move</em> 为 <code>False</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">turtle.write(<span class="string">"Home = "</span>, <span class="literal">True</span>, align=<span class="string">"center"</span>)</span><br><span class="line">turtle.write((<span class="number">0</span>,<span class="number">0</span>), <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="海龟状态"><a href="#海龟状态" class="headerlink" title="海龟状态"></a>海龟状态</h3><p>  可见性</p>
<ul>
<li><p><code>turtle.hideturtle</code>()</p>
</li>
<li><p><code>turtle.ht</code>()</p>
<p>使海龟不可见。当你绘制复杂图形时这是个好主意，因为隐藏海龟可显著加快绘制速度。<code>&gt;&gt;&gt; turtle.hideturtle()</code></p>
</li>
<li><p><code>turtle.showturtle</code>()</p>
<p><code>turtle.st</code>()</p>
<p>使海龟可见。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.showturtle()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>turtle.isvisible</code>()</p>
<p>如果海龟显示返回 <code>True</code>，如果海龟隐藏返回 <code>False</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.hideturtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.isvisible()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.showturtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.isvisible()</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h4><ul>
<li><p><code>turtle.shape</code>(<em>name=None</em>)</p>
<ul>
<li><strong>name</strong> – 一个有效的形状名字符串</li>
</ul>
<p>设置海龟形状为 <em>name</em> 指定的形状名，如未指定形状名则返回当前的形状名。<em>name</em> 指定的形状名应存在于 TurtleScreen 的 shape 字典中。多边形的形状初始时有以下几种: “arrow”, “turtle”, “circle”, “square”, “triangle”, “classic”。要了解如何处理形状请参看 Screen 方法 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.register_shape" target="_blank" rel="noopener"><code>register_shape()</code></a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape()</span><br><span class="line"><span class="string">'classic'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"turtle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape()</span><br><span class="line"><span class="string">'turtle'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>turtle.resizemode</code>(<em>rmode=None</em>)<a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.resizemode" target="_blank" rel="noopener">¶</a></p>
<ul>
<li><p>参数</p>
<p><strong>rmode</strong> – 字符串 “auto”, “user”, “noresize” 其中之一</p>
</li>
</ul>
<p>设置大小调整模式为以下值之一: “auto”, “user”, “noresize”。如未指定 <em>rmode</em> 则返回当前的大小调整模式。不同的大小调整模式的效果如下:</p>
<ul>
<li>“auto”: 根据画笔粗细值调整海龟的外观。</li>
<li>“user”: 根据拉伸因子和轮廓宽度 (outline) 值调整海龟的外观，两者是由 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shapesize" target="_blank" rel="noopener"><code>shapesize()</code></a> 设置的。</li>
<li>“noresize”: 不调整海龟的外观大小。</li>
</ul>
<p>大小调整模式 (“user”) 会在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shapesize" target="_blank" rel="noopener"><code>shapesize()</code></a> 带参数调用时生效。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.resizemode()</span><br><span class="line"><span class="string">'noresize'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.resizemode(<span class="string">"auto"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.resizemode()</span><br><span class="line"><span class="string">'auto'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>turtle.shapesize</code>(<em>stretch_wid=None</em>, <em>stretch_len=None</em>, <em>outline=None</em>)</p>
<p><code>turtle.turtlesize</code>(<em>stretch_wid=None</em>, <em>stretch_len=None</em>, <em>outline=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>stretch_wid</strong> – 正数值<strong>stretch_len</strong> – 正数值<strong>outline</strong> – 正数值</p>
</li>
</ul>
<p>返回或设置画笔的属性 x/y-拉伸因子和/或轮廓。设置大小调整模式为 “user”。当且仅当大小调整模式设为 “user” 时海龟会基于其拉伸因子调整外观: <em>stretch_wid</em> 为垂直于其朝向的宽度拉伸因子，<em>stretch_len</em> 为平等于其朝向的长度拉伸因子，决定形状轮廓线的粗细。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize()</span><br><span class="line">(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.resizemode(<span class="string">"user"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize()</span><br><span class="line">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(outline=<span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize()</span><br><span class="line">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p><code>turtle.shearfactor</code>(<em>shear=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>shear</strong> – 数值 (可选)</p>
</li>
</ul>
<p>设置或返回当前的剪切因子。根据 share 指定的剪切因子即剪切角度的切线来剪切海龟形状。<em>不</em> 改变海龟的朝向 (移动方向)。如未指定 shear 参数: 返回当前的剪切因子即剪切角度的切线，与海龟朝向平行的线条将被剪切。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"circle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shearfactor(<span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shearfactor()</span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.tilt</code>(<em>angle</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>angle</strong> – 一个数值</p>
</li>
</ul>
<p>海龟形状自其当前的倾角转动 <em>angle</em> 指定的角度，但 <em>不</em> 改变海龟的朝向 (移动方向)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"circle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.tilt(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.tilt(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<p><code>turtle.settiltangle</code>(<em>angle</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>angle</strong> – 一个数值</p>
</li>
</ul>
<p>旋转海龟形状使其指向 <em>angle</em> 指定的方向，忽略其当前的倾角，<em>不</em> 改变海龟的朝向 (移动方向)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"circle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.settiltangle(<span class="number">45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.settiltangle(<span class="number">-45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<p><em>3.1 版后已移除.</em></p>
<p><code>turtle.tiltangle</code>(<em>angle=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>angle</strong> – 一个数值 (可选)</p>
</li>
</ul>
<p>设置或返回当前的倾角。如果指定 angle 则旋转海龟形状使其指向 angle 指定的方向，忽略其当前的倾角。<em>不</em> 改变海龟的朝向 (移动方向)。如果未指定 angle: 返回当前的倾角，即海龟形状的方向和海龟朝向 (移动方向) 之间的夹角。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"circle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.tilt(<span class="number">45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.tiltangle()</span><br><span class="line"><span class="number">45.0</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.shapetransform</code>(<em>t11=None</em>, <em>t12=None</em>, <em>t21=None</em>, <em>t22=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>t11</strong> – 一个数值 (可选)<strong>t12</strong> – 一个数值 (可选)<strong>t21</strong> – 一个数值 (可选)<strong>t12</strong> – 一个数值 (可选)</p>
</li>
</ul>
<p>设置或返回海龟形状的当前变形矩阵。</p>
<p>如不指定任何矩阵元素，则返回以4元素元组表示的变形矩阵。否则使用指定元素设置变形矩阵改变海龟形状，矩阵第一排的值为 t11, t12，第二排的值为 t21, t22。行列式 t11 <em> t22 - t12 </em> t21 的值不能为零，否则会出错。根据指定的矩阵修改拉伸因子，剪切因子和倾角。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle = Turtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"square"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shearfactor(<span class="number">-0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapetransform()</span><br><span class="line">(<span class="number">4.0</span>, <span class="number">-1.0</span>, <span class="number">-0.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>
<p><code>turtle.get_shapepoly</code>()</p>
<p>返回以坐标值对元组表示的当前形状多边形。这可以用于定义一个新形状或一个复合形状的多个组成部分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"square"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapetransform(<span class="number">4</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.get_shapepoly()</span><br><span class="line">((<span class="number">50</span>, <span class="number">-20</span>), (<span class="number">30</span>, <span class="number">20</span>), (<span class="number">-50</span>, <span class="number">20</span>), (<span class="number">-30</span>, <span class="number">-20</span>))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>turtle</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library selectors</title>
    <url>/2020/02/29/python-standard-library-selectors/</url>
    <content><![CDATA[<h1 id="python-标准库-selectors-高级-I-O-复用库"><a href="#python-标准库-selectors-高级-I-O-复用库" class="headerlink" title="python 标准库 selectors  高级 I/O 复用库"></a>python 标准库 selectors  高级 I/O 复用库</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200229selectors.jpg?raw=true" alt></p>
<a id="more"></a>
<p><strong>源码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/selectors.py" target="_blank" rel="noopener">Lib/selectors.py</a></p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>它的功能与linux的epoll，还是select模块,poll等类似；实现高效的I/O multiplexing,  常用于非阻塞的socket的编程中</p>
<p>模块定义了一个 BaseSelector的抽象基类， 以及它的子类，包括：EpollSelector, KqueueSelector等模块,</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Classes hierarchy:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BaseSelector</span><br><span class="line">+-- SelectSelector</span><br><span class="line">+-- PollSelector</span><br><span class="line">+-- EpollSelector</span><br><span class="line">+-- DevpollSelector</span><br><span class="line">+-- KqueueSelector</span><br></pre></td></tr></table></figure>
<p>模块定义了两个常量，用于描述 event Mask</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EVENT_READ</code></td>
<td>可读</td>
</tr>
<tr>
<td><code>EVENT_WRITE</code></td>
<td>可写</td>
</tr>
</tbody>
</table>
<p>模块定义了一个 SelectorKey类,是一个 <a href="https://docs.python.org/zh-cn/3.8/library/collections.html#collections.namedtuple" target="_blank" rel="noopener"><code>namedtuple</code></a> 类型, 一般用这个类的实例来描述一个已经注册的文件对象的状态，</p>
<p>常用属性:</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fileobj</td>
<td style="text-align:left">表示已经注册的文件对象</td>
</tr>
<tr>
<td style="text-align:center">fd</td>
<td style="text-align:left">表示文件对象的描述符，是一个整数，它是文件对象的 fileno()方法的返回值</td>
</tr>
<tr>
<td style="text-align:center">events</td>
<td style="text-align:left">表示注册一个文件对象时，我们等待的events, 即上面的event Mask, 是可读呢还是可写</td>
</tr>
<tr>
<td style="text-align:center">data</td>
<td style="text-align:left">表示注册一个文件对象是邦定的data</td>
</tr>
</tbody>
</table>
<p><em>class</em> <code>selectors.BaseSelector</code></p>
<p>定义了一个抽象基类,能够注册和取消注册,通过一个可选的timeout,等待流中的I/O事件。抽象基类无法实例化,所以通常使用<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.DefaultSelector" target="_blank" rel="noopener"><code>DefaultSelector</code></a> 代替，或者<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectSelector" target="_blank" rel="noopener">SelectSelector`</a>, <a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.KqueueSelector" target="_blank" rel="noopener"><code>KqueueSelector</code></a> 来实现。如果你想声明一个操作系统平台支持的实现, <a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.BaseSelector" target="_blank" rel="noopener"><code>BaseSelector</code></a> 和他的子类支持 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-context-manager" target="_blank" rel="noopener">上下文管理</a> 实现。</p>
<ul>
<li><p><em>abstractmethod</em> <code>register</code>(<em>fileobj</em>, <em>events</em>, <em>data=None</em>)</p>
<p>用于注册一个文件对象或监控I/O事件的抽象方法。<strong>fileobj</strong> 参数是一个用于监控的对象。它可能是一个整形文件描述符或者是一个拥有 <code>fileno()</code>方法的对象。返回一个新创建的<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectorKey" target="_blank" rel="noopener">SelectorKey`</a> 类实例,或因为不存在的<code>event mask</code> 或文件描述符,或者该文件对象已经被注册过而引发<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。</p>
</li>
<li><p><em>abstractmethod</em> <code>unregister</code>(<em>fileobj</em>)</p>
<p>用于注销注册文件对象或移除监控I/O事件的抽象方法。该文件对象必须是之前已经注册的对象。返回值关联了<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectorKey" target="_blank" rel="noopener"><code>SelectorKey</code></a> 实例,或因为不存在的<code>event mask</code> 或文件描述符,或者该文件对象已经被注册过而引发<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。</p>
</li>
<li><p><code>modify</code>(<em>fileobj</em>, <em>events</em>, <em>data=None</em>)</p>
<p>用于修改一个注册过的文件对象，比如从监听可读变为监听可写；它其实就是register() 后再跟unregister(),       但是使用modify( ) 更高效；返回一个新创建的<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectorKey" target="_blank" rel="noopener">SelectorKey`</a> 类实例,或因为不存在的<code>event mask</code> 或文件描述符,或者该文件对象已经被注册过而引发<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。</p>
</li>
<li><p><em>abstractmethod</em> <code>select</code>(<em>timeout=None</em>)</p>
<p>用于选择满足我们监听的event的文件对象的抽象方法。</p>
</li>
<li><p><code>close</code>()</p>
<p>关闭 selector,为了 要确保所有的资源被释放,最后一定要调用该方法。</p>
</li>
<li><p><code>get_key</code>(<em>fileobj</em>)</p>
<p>返回注册文件对象的 <a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectorKey" target="_blank" rel="noopener"><code>SelectorKey</code></a> 实例。该实例关联文件对象,若文件对象未注册,将抛出<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 异常。</p>
</li>
<li><p><em>abstractmethod</em> <code>get_map</code>()</p>
<p>返回selectors key 的文件对象的映射。</p>
</li>
<li><p><em>class</em> <code>selectors.DefaultSelector</code></p>
<p>默认的selector类,其中一个子类的别名，它自动选择为当前环境中最有效的Selector。</p>
<p><em>selectors模块默认会用epoll，如果你的系统中没有epoll(比如windows)则会自动使用select</em></p>
</li>
<li><p><em>class</em> <code>selectors.SelectSelector</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.select" target="_blank" rel="noopener"><code>select.select()</code></a>-based selector.</p>
</li>
<li><p><em>class</em> <code>selectors.PollSelector</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.poll" target="_blank" rel="noopener"><code>select.poll()</code></a>-based selector.</p>
</li>
<li><p><em>class</em> <code>selectors.EpollSelector</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.epoll" target="_blank" rel="noopener"><code>select.epoll()</code></a>-based selector.<code>fileno</code>()This returns the file descriptor used by the underlying <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.epoll" target="_blank" rel="noopener"><code>select.epoll()</code></a> object.</p>
</li>
<li><p><em>class</em> <code>selectors.DevpollSelector</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.devpoll" target="_blank" rel="noopener"><code>select.devpoll()</code></a>-based selector.<code>fileno</code>()This returns the file descriptor used by the underlying <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.devpoll" target="_blank" rel="noopener"><code>select.devpoll()</code></a> object.<em>3.5 新版功能.</em></p>
</li>
<li><p><em>class</em> <code>selectors.KqueueSelector</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.kqueue" target="_blank" rel="noopener"><code>select.kqueue()</code></a>-based selector.<code>fileno</code>()This returns the file descriptor used by the underlying <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.kqueue" target="_blank" rel="noopener"><code>select.kqueue()</code></a> object.</p>
</li>
</ul>
<h2 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h2><p>Here is a simple echo server implementation:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sel = selectors.DefaultSelector()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span><span class="params">(sock, mask)</span>:</span></span><br><span class="line">    conn, addr = sock.accept()  <span class="comment"># Should be ready</span></span><br><span class="line">    print(<span class="string">'accepted'</span>, conn, <span class="string">'from'</span>, addr)</span><br><span class="line">    conn.setblocking(<span class="literal">False</span>)</span><br><span class="line">    sel.register(conn, selectors.EVENT_READ, read)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(conn, mask)</span>:</span></span><br><span class="line">    data = conn.recv(<span class="number">1000</span>)  <span class="comment"># Should be ready</span></span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        print(<span class="string">'echoing'</span>, repr(data), <span class="string">'to'</span>, conn)</span><br><span class="line">        conn.send(data)  <span class="comment"># Hope it won't block</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'closing'</span>, conn)</span><br><span class="line">        sel.unregister(conn)</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">sock = socket.socket()</span><br><span class="line">sock.bind((<span class="string">'localhost'</span>, <span class="number">1234</span>))</span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line">sock.setblocking(<span class="literal">False</span>)</span><br><span class="line">sel.register(sock, selectors.EVENT_READ, accept)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    events = sel.select()</span><br><span class="line">    <span class="keyword">for</span> key, mask <span class="keyword">in</span> events:</span><br><span class="line">        callback = key.data</span><br><span class="line">        callback(key.fileobj, mask)</span><br></pre></td></tr></table></figure>
<h2 id="一个基于socket的客户端与服务器端实例"><a href="#一个基于socket的客户端与服务器端实例" class="headerlink" title="一个基于socket的客户端与服务器端实例"></a>一个基于socket的客户端与服务器端实例</h2><h3 id="基于socket的服务器端实例"><a href="#基于socket的服务器端实例" class="headerlink" title="基于socket的服务器端实例"></a>基于socket的服务器端实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">selectors_echo_server.py</span><br><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">mysel = selectors.DefaultSelector()</span><br><span class="line">keep_running = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(connection, mask)</span>:</span></span><br><span class="line">    <span class="string">"Callback for read events"</span></span><br><span class="line">    <span class="keyword">global</span> keep_running</span><br><span class="line"></span><br><span class="line">    client_address = connection.getpeername()</span><br><span class="line">    print(<span class="string">'read(&#123;&#125;)'</span>.format(client_address))</span><br><span class="line">    data = connection.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        <span class="comment"># A readable client socket has data</span></span><br><span class="line">        print(<span class="string">'  received &#123;!r&#125;'</span>.format(data))</span><br><span class="line">        connection.sendall(data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Interpret empty result as closed connection</span></span><br><span class="line">        print(<span class="string">'  closing'</span>)</span><br><span class="line">        mysel.unregister(connection)</span><br><span class="line">        connection.close()</span><br><span class="line">        <span class="comment"># Tell the main loop to stop</span></span><br><span class="line">        keep_running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span><span class="params">(sock, mask)</span>:</span></span><br><span class="line">    <span class="string">"Callback for new connections"</span></span><br><span class="line">    new_connection, addr = sock.accept()</span><br><span class="line">    print(<span class="string">'accept(&#123;&#125;)'</span>.format(addr))</span><br><span class="line">    new_connection.setblocking(<span class="literal">False</span>)</span><br><span class="line">    mysel.register(new_connection, selectors.EVENT_READ, read)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server_address = (<span class="string">'localhost'</span>, <span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'starting up on &#123;&#125; port &#123;&#125;'</span>.format(*server_address))</span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.setblocking(<span class="literal">False</span>)</span><br><span class="line">server.bind(server_address)</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">mysel.register(server, selectors.EVENT_READ, accept)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> keep_running:</span><br><span class="line">    print(<span class="string">'waiting for I/O'</span>)</span><br><span class="line">    <span class="keyword">for</span> key, mask <span class="keyword">in</span> mysel.select(timeout=<span class="number">1</span>):</span><br><span class="line">        callback = key.data</span><br><span class="line">        callback(key.fileobj, mask)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'shutting down'</span>)</span><br><span class="line">mysel.close()</span><br></pre></td></tr></table></figure>
<h3 id="基于socket的客户端实例"><a href="#基于socket的客户端实例" class="headerlink" title="基于socket的客户端实例"></a>基于socket的客户端实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">selectors_echo_client.py</span><br><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">mysel = selectors.DefaultSelector()</span><br><span class="line">keep_running = <span class="literal">True</span></span><br><span class="line">outgoing = [</span><br><span class="line">    <span class="string">b'It will be repeated.'</span>,</span><br><span class="line">    <span class="string">b'This is the message.  '</span>,</span><br><span class="line">]</span><br><span class="line">bytes_sent = <span class="number">0</span></span><br><span class="line">bytes_received = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Connecting is a blocking operation, so call setblocking()</span></span><br><span class="line"><span class="comment"># after it returns.</span></span><br><span class="line">server_address = (<span class="string">'localhost'</span>, <span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'connecting to &#123;&#125; port &#123;&#125;'</span>.format(*server_address))</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.connect(server_address)</span><br><span class="line">sock.setblocking(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up the selector to watch for when the socket is ready</span></span><br><span class="line"><span class="comment"># to send data as well as when there is data to read.</span></span><br><span class="line">mysel.register(</span><br><span class="line">    sock,</span><br><span class="line">    selectors.EVENT_READ | selectors.EVENT_WRITE,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> keep_running:</span><br><span class="line">    print(<span class="string">'waiting for I/O'</span>)</span><br><span class="line">    <span class="keyword">for</span> key, mask <span class="keyword">in</span> mysel.select(timeout=<span class="number">1</span>):</span><br><span class="line">        connection = key.fileobj</span><br><span class="line">        client_address = connection.getpeername()</span><br><span class="line">        print(<span class="string">'client(&#123;&#125;)'</span>.format(client_address))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mask &amp; selectors.EVENT_READ:</span><br><span class="line">            print(<span class="string">'  ready to read'</span>)</span><br><span class="line">            data = connection.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                <span class="comment"># A readable client socket has data</span></span><br><span class="line">                print(<span class="string">'  received &#123;!r&#125;'</span>.format(data))</span><br><span class="line">                bytes_received += len(data)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Interpret empty result as closed connection,</span></span><br><span class="line">            <span class="comment"># and also close when we have received a copy</span></span><br><span class="line">            <span class="comment"># of all of the data sent.</span></span><br><span class="line">            keep_running = <span class="keyword">not</span> (</span><br><span class="line">                data <span class="keyword">or</span></span><br><span class="line">                (bytes_received <span class="keyword">and</span></span><br><span class="line">                 (bytes_received == bytes_sent))</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mask &amp; selectors.EVENT_WRITE:</span><br><span class="line">            print(<span class="string">'  ready to write'</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> outgoing:</span><br><span class="line">                <span class="comment"># We are out of messages, so we no longer need to</span></span><br><span class="line">                <span class="comment"># write anything. Change our registration to let</span></span><br><span class="line">                <span class="comment"># us keep reading responses from the server.</span></span><br><span class="line">                print(<span class="string">'  switching to read-only'</span>)</span><br><span class="line">                mysel.modify(sock, selectors.EVENT_READ)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Send the next message.</span></span><br><span class="line">                next_msg = outgoing.pop()</span><br><span class="line">                print(<span class="string">'  sending &#123;!r&#125;'</span>.format(next_msg))</span><br><span class="line">                sock.sendall(next_msg)</span><br><span class="line">                bytes_sent += len(next_msg)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'shutting down'</span>)</span><br><span class="line">mysel.unregister(connection)</span><br><span class="line">connection.close()</span><br><span class="line">mysel.close()</span><br></pre></td></tr></table></figure>
<h3 id="Server和client交互"><a href="#Server和client交互" class="headerlink" title="Server和client交互"></a>Server和client交互</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python3 source/selectors/selectors_echo_server.py</span><br><span class="line">starting up on localhost port <span class="number">10000</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">accept((<span class="string">'127.0.0.1'</span>, <span class="number">59850</span>))</span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">read((<span class="string">'127.0.0.1'</span>, <span class="number">59850</span>))</span><br><span class="line">  received <span class="string">b'This is the message.  It will be repeated.'</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">read((<span class="string">'127.0.0.1'</span>, <span class="number">59850</span>))</span><br><span class="line">  closing</span><br><span class="line">shutting down</span><br></pre></td></tr></table></figure>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python3 source/selectors/selectors_echo_client.py</span><br><span class="line">connecting to localhost port <span class="number">10000</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">client((<span class="string">'127.0.0.1'</span>, <span class="number">10000</span>))</span><br><span class="line">  ready to write</span><br><span class="line">  sending <span class="string">b'This is the message.  '</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">client((<span class="string">'127.0.0.1'</span>, <span class="number">10000</span>))</span><br><span class="line">  ready to write</span><br><span class="line">  sending <span class="string">b'It will be repeated.'</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">client((<span class="string">'127.0.0.1'</span>, <span class="number">10000</span>))</span><br><span class="line">  ready to write</span><br><span class="line">  switching to read-only</span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">client((<span class="string">'127.0.0.1'</span>, <span class="number">10000</span>))</span><br><span class="line">  ready to read</span><br><span class="line">  received <span class="string">b'This is the message.  It will be repeated.'</span></span><br><span class="line">shutting down</span><br></pre></td></tr></table></figure>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://pymotw.com/3/selectors/" target="_blank" rel="noopener">python标准库之selectors</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>selectors</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library turtle-2</title>
    <url>/2020/02/28/python-standard-library-turtle-2/</url>
    <content><![CDATA[<h1 id="python-标准库-turtle-海龟制图-续"><a href="#python-标准库-turtle-海龟制图-续" class="headerlink" title="python 标准库 turtle 海龟制图(续)"></a>python 标准库 turtle 海龟制图(续)</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/2020200228english.png?raw=true" alt></p>
<a id="more"></a>
<h3 id="使用事件"><a href="#使用事件" class="headerlink" title="使用事件"></a>使用事件</h3><ul>
<li><p><code>turtle.onclick</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p>
<p>参数<strong>fun</strong> – 一个函数，调用时将传入两个参数表示在画布上点击的坐标。<strong>btn</strong> – 鼠标按钮编号，默认值为 1 (鼠标左键)<strong>add</strong> – <code>True</code> 或 <code>False</code> – 如为 <code>True</code> 则将添加一个新绑定，否则将取代先前的绑定将 <em>fun</em> 指定的函数绑定到鼠标点击此海龟事件。如果 <em>fun</em> 值为 <code>None</code>，则移除现有的绑定。以下为使用匿名海龟即过程式的示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">turn</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    left(<span class="number">180</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>onclick(turn)  <span class="comment"># Now clicking into the turtle will turn it.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>onclick(<span class="literal">None</span>)  <span class="comment"># event-binding will be removed</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>turtle.onrelease</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p>
<ul>
<li>参数</li>
</ul>
<p><strong>fun</strong> – 一个函数，调用时将传入两个参数表示在画布上点击的坐标。<strong>btn</strong> – 鼠标按钮编号，默认值为 1 (鼠标左键)<strong>add</strong> – <code>True</code> 或 <code>False</code> – 如为 <code>True</code> 则将添加一个新绑定，否则将取代先前的绑定</p>
<p>将 <em>fun</em> 指定的函数绑定到在此海龟上释放鼠标按键事件。如果 <em>fun</em> 值为 <code>None</code>，则移除现有的绑定。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyTurtle</span><span class="params">(Turtle)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">glow</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.fillcolor(<span class="string">"red"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">unglow</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.fillcolor(<span class="string">""</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle = MyTurtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.onclick(turtle.glow)     <span class="comment"># clicking on turtle turns fillcolor red,</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.onrelease(turtle.unglow) <span class="comment"># releasing turns it to transparent.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>turtle.ondrag</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>fun</strong> – 一个函数，调用时将传入两个参数表示在画布上点击的坐标。<strong>btn</strong> – 鼠标按钮编号，默认值为 1 (鼠标左键)<strong>add</strong> – <code>True</code> 或 <code>False</code> – 如为 <code>True</code> 则将添加一个新绑定，否则将取代先前的绑定</p>
</li>
</ul>
<p>将 <em>fun</em> 指定的函数绑定到在此海龟上移动鼠标事件。如果 <em>fun</em> 值为 <code>None</code>，则移除现有的绑定。</p>
<p>注: 在海龟上移动鼠标事件之前应先发生在此海龟上点击鼠标事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; turtle.ondrag(turtle.goto)</span><br></pre></td></tr></table></figure>
<p>在此之后点击并拖动海龟可在屏幕上手绘线条 (如果画笔为落下)。</p>
</li>
</ul>
<h3 id="特殊海龟方法"><a href="#特殊海龟方法" class="headerlink" title="特殊海龟方法"></a>特殊海龟方法</h3><ul>
<li><p><code>turtle.begin_poly</code>()</p>
<p>开始记录多边形的顶点。当前海龟位置为多边形的第一个顶点。</p>
</li>
<li><p><code>turtle.end_poly</code>()</p>
<p>停止记录多边形的顶点。当前海龟位置为多边形的最后一个顶点。它将连线到第一个顶点。</p>
</li>
<li><p><code>turtle.get_poly</code>()</p>
<p>返回最新记录的多边形。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.begin_poly()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.end_poly()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = turtle.get_poly()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>register_shape(<span class="string">"myFavouriteShape"</span>, p)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>turtle.clone</code>()</li>
</ul>
<p>创建并返回海龟的克隆体，具有相同的位置、朝向和海龟属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mick = Turtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe = mick.clone()</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>turtle.getturtle</code>()</p>
</li>
<li><p><code>turtle.getpen</code>()</p>
</li>
</ul>
<p>返回海龟对象自身。唯一合理的用法: 作为一个函数来返回 “匿名海龟”:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pet = getturtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pet.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pet</span><br><span class="line">&lt;turtle.Turtle object at <span class="number">0</span>x...&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>turtle.getscreen</code>()</li>
</ul>
<p>返回作为海龟绘图场所的 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 类对象。该对象将可调用 TurtleScreen 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ts = turtle.getscreen()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ts</span><br><span class="line">&lt;turtle._Screen object at <span class="number">0</span>x...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ts.bgcolor(<span class="string">"pink"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>turtle.setundobuffer</code>(<em>size</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>size</strong> – 一个整型数值或 <code>None</code></p>
</li>
</ul>
</li>
</ul>
<p>设置或禁用撤消缓冲区。如果 <em>size</em> 为一个整型数则将开辟一个指定大小的空缓冲区。<em>size</em> 表示可使用 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.undo" target="_blank" rel="noopener"><code>undo()</code></a> 方法/函数撤消的海龟命令的次数上限。如果 <em>size</em> 为 <code>None</code> 则禁用撤消缓冲区。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setundobuffer(<span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>turtle.undobufferentries</code>()</li>
</ul>
<p>返回撤销缓冲区里的条目数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> undobufferentries():</span><br><span class="line"><span class="meta">... </span>    undo()</span><br></pre></td></tr></table></figure>
<h3 id="复合形状"><a href="#复合形状" class="headerlink" title="复合形状"></a>复合形状</h3><p>要使用由多个不同颜色多边形构成的复合海龟形状，你必须明确地使用辅助类 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Shape" target="_blank" rel="noopener"><code>Shape</code></a>，具体步骤如下:</p>
<ol>
<li><p>创建一个空 Shape 对象，类型为 “compound”。</p>
</li>
<li><p>按照需要使用 <code>addcomponent()</code> 方法向此对象添加多个部件。</p>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Shape(<span class="string">"compound"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>poly1 = ((<span class="number">0</span>,<span class="number">0</span>),(<span class="number">10</span>,<span class="number">-5</span>),(<span class="number">0</span>,<span class="number">10</span>),(<span class="number">-10</span>,<span class="number">-5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.addcomponent(poly1, <span class="string">"red"</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>poly2 = ((<span class="number">0</span>,<span class="number">0</span>),(<span class="number">10</span>,<span class="number">-5</span>),(<span class="number">-10</span>,<span class="number">-5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.addcomponent(poly2, <span class="string">"blue"</span>, <span class="string">"red"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来将 Shape 对象添加到 Screen 对象的形状列表并使用它:</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>register_shape(<span class="string">"myshape"</span>, s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shape(<span class="string">"myshape"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Shape" target="_blank" rel="noopener"><code>Shape</code></a> 类在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.register_shape" target="_blank" rel="noopener"><code>register_shape()</code></a> 方法的内部以多种方式使用。应用程序编写者 <em>只有</em> 在使用上述的复合形状时才需要处理 Shape 类。</p>
</blockquote>
<h2 id="TurtleScreen-Screen-方法及对应函数"><a href="#TurtleScreen-Screen-方法及对应函数" class="headerlink" title="TurtleScreen/Screen 方法及对应函数"></a>TurtleScreen/Screen 方法及对应函数</h2><p>本节中的大部分示例都使用 TurtleScreen 类的一个实例，命名为 <code>screen</code>。</p>
<h3 id="窗口控制"><a href="#窗口控制" class="headerlink" title="窗口控制"></a>窗口控制</h3><ul>
<li><p><code>turtle.bgcolor</code>(*<em>args</em>)</p>
<p>参数<strong>args</strong> – 一个颜色字符串或三个取值范围 0..colormode 内的数值或一个取值范围相同的数值3元组设置或返回 TurtleScreen 的背景颜色。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgcolor()</span><br><span class="line"><span class="string">'orange'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgcolor(<span class="string">"#800080"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgcolor()</span><br><span class="line">(<span class="number">128.0</span>, <span class="number">0.0</span>, <span class="number">128.0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>urtle.bgpic</code>(<em>picname=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>picname</strong> – 一个字符串, gif-文件名, <code>&quot;nopic&quot;</code>, 或 <code>None</code></p>
</li>
</ul>
<p>设置背景图片或返回当前背景图片名称。如果 <em>picname</em> 为一个文件名，则将相应图片设为背景。如果 <em>picname</em> 为 <code>&quot;nopic&quot;</code>，则删除当前背景图片。如果 <em>picname</em> 为 <code>None</code>，则返回当前背景图片文件名。:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgpic()</span><br><span class="line"><span class="string">'nopic'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgpic(<span class="string">"landscape.gif"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgpic()</span><br><span class="line"><span class="string">"landscape.gif"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>turtle.clear</code>()</p>
<p><code>turtle.clearscreen</code>()</p>
<p>从中删除所有海龟的全部绘图。将已清空的 TurtleScreen 重置为初始状态: 白色背景，无背景片，无事件绑定并启用追踪。</p>
<blockquote>
<p>此 TurtleScreen 方法作为全局函数时只有一个名字 <code>clearscreen</code>。全局函数 <code>clear</code> 所对应的是 Turtle 方法 <code>clear</code>。</p>
</blockquote>
</li>
<li><p><code>turtle.reset</code>()</p>
</li>
<li><p><code>turtle.resetscreen</code>()</p>
<p>重置屏幕上的所有海龟为其初始状态。</p>
</li>
<li><p><code>turtle.reset</code>()</p>
<p><code>turtle.resetscreen</code>()</p>
<p>重置屏幕上的所有海龟为其初始状态。</p>
<blockquote>
<p>此 TurtleScreen 方法作为全局函数时只有一个名字 <code>resetscreen</code>。全局函数 <code>reset</code> 所对应的是 Turtle 方法 <code>reset</code>。</p>
</blockquote>
</li>
<li><p><code>turtle.screensize</code>(<em>canvwidth=None</em>, <em>canvheight=None</em>, <em>bg=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>canvwidth</strong> – 正整型数，以像素表示画布的新宽度值<strong>canvheight</strong> – 正整型数，以像素表示画面的新高度值<strong>bg</strong> – 颜色字符串或颜色元组，新的背景颜色</p>
</li>
</ul>
<p>如未指定任何参数，则返回当前的 (canvaswidth, canvasheight)。否则改变作为海龟绘图场所的画布大小。不改变绘图窗口。要观察画布的隐藏区域，可以使用滚动条。通过此方法可以令之前绘制于画布之外的图形变为可见。</p>
<p>可见。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.screensize()</span><br><span class="line">(<span class="number">400</span>, <span class="number">300</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.screensize(<span class="number">2000</span>,<span class="number">1500</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.screensize()</span><br><span class="line">(<span class="number">2000</span>, <span class="number">1500</span>)</span><br></pre></td></tr></table></figure>
<p>也可以用来寻找意外逃走的海龟 ;-)</p>
</li>
<li><p><code>turtle.setworldcoordinates</code>(<em>llx</em>, <em>lly</em>, <em>urx</em>, <em>ury</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>llx</strong> – 一个数值, 画布左下角的 x-坐标</p>
<p><strong>lly</strong> – 一个数值, 画布左下角的 y-坐标</p>
<p><strong>urx</strong> – 一个数值, 画面右上角的 x-坐标</p>
<p><strong>ury</strong> – 一个数值, 画布右上角的 y-坐标</p>
</li>
</ul>
<p>设置用户自定义坐标系并在必要时切换模式为 “world”。这会执行一次 <code>screen.reset()</code>。如果 “world” 模式已激活，则所有图形将根据新的坐标系重绘。</p>
<p><strong>注意</strong>: 在用户自定义坐标系中，角度可能显得扭曲。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.setworldcoordinates(<span class="number">-50</span>,<span class="number">-7.5</span>,<span class="number">50</span>,<span class="number">7.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">72</span>):</span><br><span class="line"><span class="meta">... </span>    left(<span class="number">10</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line"><span class="meta">... </span>    left(<span class="number">45</span>); fd(<span class="number">2</span>)   <span class="comment"># a regular octagon</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="动画控制"><a href="#动画控制" class="headerlink" title="动画控制"></a>动画控制</h3><ul>
<li><p><code>turtle.delay</code>(<em>delay=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>delay</strong> – 正整型数</p>
</li>
</ul>
<p>设置或返回以毫秒数表示的延迟值 <em>delay</em>。(这约等于连续两次画布刷新的间隔时间。) 绘图延迟越长，动画速度越慢。</p>
<p>可选参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.delay()</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.delay(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.delay()</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>turtle.tracer</code>(<em>n=None</em>, <em>delay=None</em>)</p>
<p>参数<strong>n</strong> – 非负整型数<strong>delay</strong> – 非负整型数启用/禁用海龟动画并设置刷新图形的延迟时间。如果指定 <em>n</em> 值，则只有每第 n 次屏幕刷新会实际执行。(可被用来加速复杂图形的绘制。) 如果调用时不带参数，则返回当前保存的 n 值。第二个参数设置延迟值 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.delay" target="_blank" rel="noopener"><code>delay()</code></a>)。<code>&gt;&gt;&gt; screen.tracer(8, 25) &gt;&gt;&gt; dist = 2 &gt;&gt;&gt; for i in range(200): ...     fd(dist) ...     rt(90) ...     dist += 2</code></p>
</li>
<li><p><code>turtle.update</code>()</p>
<p>执行一次 TurtleScreen 刷新。在禁用追踪时使用。</p>
</li>
</ul>
<p>另参见 RawTurtle/Turtle 方法 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.speed" target="_blank" rel="noopener"><code>speed()</code></a>。</p>
<h3 id="使用屏幕事件"><a href="#使用屏幕事件" class="headerlink" title="使用屏幕事件"></a>使用屏幕事件</h3><ul>
<li><p><code>turtle.listen</code>(<em>xdummy=None</em>, <em>ydummy=None</em>)</p>
<p>设置焦点到 TurtleScreen (以便接收按键事件)。使用两个 Dummy 参数以便能够传递 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.listen" target="_blank" rel="noopener"><code>listen()</code></a> 给 onclick 方法。</p>
</li>
<li><p><code>turtle.onkey</code>(<em>fun</em>, <em>key</em>)</p>
</li>
<li><p><code>turtle.onkeyrelease</code>(<em>fun</em>, <em>key</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>fun</strong> – 一个无参数的函数或 <code>None</code><strong>key</strong> – 一个字符串: 键 (例如 “a”) 或键标 (例如 “space”)</p>
</li>
</ul>
<p>绑定 <em>fun</em> 指定的函数到按键释放事件。如果 <em>fun</em> 值为 <code>None</code>，则移除事件绑定。注: 为了能够注册按键事件，TurtleScreen 必须得到焦点。(参见 method <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.listen" target="_blank" rel="noopener"><code>listen()</code></a> 方法。)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">... </span>    lt(<span class="number">60</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.onkey(f, <span class="string">"Up"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.listen()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>turtle.onkeypress</code>(<em>fun</em>, <em>key=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>fun</strong> – 一个无参数的函数或 <code>None</code><strong>key</strong> – 一个字符串: 键 (例如 “a”) 或键标 (例如 “space”)</p>
</li>
</ul>
<p>绑定 <em>fun</em> 指定的函数到指定键的按下事件。如未指定键则绑定到任意键的按下事件。注: 为了能够注册按键事件，必须得到焦点。(参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.listen" target="_blank" rel="noopener"><code>listen()</code></a> 方法。)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    fd(<span class="number">50</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.onkey(f, <span class="string">"Up"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.listen()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>turtle.onclick</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p>
<p><code>turtle.onscreenclick</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>fun</strong> – 一个函数，调用时将传入两个参数表示在画布上点击的坐标。<strong>btn</strong> – 鼠标按钮编号，默认值为 1 (鼠标左键)<strong>add</strong> – <code>True</code> 或 <code>False</code> – 如为 <code>True</code> 则将添加一个新绑定，否则将取代先前的绑定</p>
</li>
</ul>
<p>绑定 <em>fun</em> 指定的函数到鼠标点击屏幕事件。如果 <em>fun</em> 值为 <code>None</code>，则移除现有的绑定。</p>
<p>以下示例使用一个 TurtleScreen 实例 <code>screen</code> 和一个 Turtle 实例 turtle:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.onclick(turtle.goto) <span class="comment"># Subsequently clicking into the TurtleScreen will</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>                            <span class="comment"># make the turtle move to the clicked point.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.onclick(<span class="literal">None</span>)        <span class="comment"># remove event binding again</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p> 此 TurtleScreen 方法作为全局函数时只有一个名字 <code>onscreenclick</code>。全局函数 <code>onclick</code> 所对应的是 Turtle 方法 <code>onclick</code>。</p>
</blockquote>
</li>
<li><p><code>turtle.ontimer</code>(<em>fun</em>, <em>t=0</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>fun</strong> – 一个无参数的函数<strong>t</strong> – 一个数值 &gt;= 0</p>
</li>
</ul>
<p>安装一个计时器，在 <em>t</em> 毫秒后调用 <em>fun</em> 函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>running = <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> running:</span><br><span class="line"><span class="meta">... </span>        fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">... </span>        lt(<span class="number">60</span>)</span><br><span class="line"><span class="meta">... </span>        screen.ontimer(f, <span class="number">250</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()   <span class="comment">### makes the turtle march around</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>running = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>turtle.mainloop</code>()</p>
<p><code>turtle.done</code>()</p>
<p>开始事件循环 - 调用 Tkinter 的 mainloop 函数。必须作为一个海龟绘图程序的结束语句。如果一个脚本是在以 -n 模式 (无子进程) 启动的 IDLE 中运行时 <em>不可</em> 使用 - 用于实现海龟绘图的交互功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.mainloop()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="输入方法"><a href="#输入方法" class="headerlink" title="输入方法"></a>输入方法</h3><ul>
<li><p><code>turtle.textinput</code>(<em>title</em>, <em>prompt</em>)</p>
<p>参数<strong>title</strong> – 字符串<strong>prompt</strong> – 字符串弹出一个对话框窗口用来输入一个字符串。形参 title 为对话框窗口的标题，prompt 为一条文本，通常用来提示要输入什么信息。返回输入的字符串。如果对话框被取消则返回 <code>None</code>。:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.textinput(<span class="string">"NIM"</span>, <span class="string">"Name of first player:"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>turtle.numinput</code>(<em>title</em>, <em>prompt</em>, <em>default=None</em>, <em>minval=None</em>, <em>maxval=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>title</strong> – 字符串<strong>prompt</strong> – 字符串<strong>default</strong> – 数值 (可选)<strong>minval</strong> – 数值 (可选)<strong>maxval</strong> – 数值 (可选)</p>
</li>
</ul>
<p>弹出一个对话框窗口用来输入一个数值。title 为对话框窗口的标题，prompt 为一条文本，通常用来描述要输入的数值信息。default: 默认值, minval: 可输入的最小值, maxval: 可输入的最大值。输入数值的必须在指定的 minval .. maxval 范围之内，否则将给出一条提示，对话框保持打开等待修改。返回输入的数值。如果对话框被取消则返回 <code>None</code>。:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.numinput(<span class="string">"Poker"</span>, <span class="string">"Your stakes:"</span>, <span class="number">1000</span>, minval=<span class="number">10</span>, maxval=<span class="number">10000</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="设置与特殊方法"><a href="#设置与特殊方法" class="headerlink" title="设置与特殊方法"></a>设置与特殊方法</h3><p><code>turtle.mode</code>(<em>mode=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>mode</strong> – 字符串 “standard”, “logo” 或 “world” 其中之一</p>
</li>
</ul>
<p>设置海龟模式 (“standard”, “logo” 或 “world”) 并执行重置。如未指定模式则返回当前的模式。</p>
<p>“standard” 模式与旧的 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 兼容。”logo” 模式与大部分 Logo 海龟绘图兼容。”world” 模式使用用户自定义的 “世界坐标系”。<strong>注意</strong>: 在此模式下，如果 <code>x/y</code> 单位比率不等于 1 则角度会显得扭曲。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>初始海龟朝向</th>
<th>正数角度</th>
</tr>
</thead>
<tbody>
<tr>
<td>“standard”</td>
<td>朝右 (东)</td>
<td>逆时针</td>
</tr>
<tr>
<td>“logo”</td>
<td>朝上 (北)</td>
<td>顺时针</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mode(<span class="string">"logo"</span>)   <span class="comment"># resets turtle heading to north</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mode()</span><br><span class="line"><span class="string">'logo'</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.colormode</code>(<em>cmode=None</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>cmode</strong> – 数值 1.0 或 255 其中之一</p>
</li>
</ul>
<p>返回颜色模式或将其设为 1.0 或 255。构成颜色三元组的 <em>r</em>, <em>g</em>, <em>b</em> 数值必须在 0..<em>cmode</em> 范围之内。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.colormode(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(<span class="number">240</span>, <span class="number">160</span>, <span class="number">80</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">     ...</span><br><span class="line">TurtleGraphicsError: bad color sequence: (<span class="number">240</span>, <span class="number">160</span>, <span class="number">80</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.colormode()</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.colormode(<span class="number">255</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.colormode()</span><br><span class="line"><span class="number">255</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(<span class="number">240</span>,<span class="number">160</span>,<span class="number">80</span>)</span><br></pre></td></tr></table></figure>
<p><code>turtle.getcanvas</code>()</p>
<p>返回此 TurtleScreen 的 Canvas 对象。供了解 Tkinter 的 Canvas 对象内部机理的人士使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv = screen.getcanvas()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv</span><br><span class="line">&lt;turtle.ScrolledCanvas object ...&gt;</span><br></pre></td></tr></table></figure>
<p><code>turtle.getshapes</code>()</p>
<p>返回所有当前可用海龟形状的列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.getshapes()</span><br><span class="line">[<span class="string">'arrow'</span>, <span class="string">'blank'</span>, <span class="string">'circle'</span>, ..., <span class="string">'turtle'</span>]</span><br></pre></td></tr></table></figure>
<p><code>turtle.register_shape</code>(<em>name</em>, <em>shape=None</em>)</p>
<p><code>turtle.addshape</code>(<em>name</em>, <em>shape=None</em>)</p>
<p>调用此函数有三种不同方式:</p>
<ol>
<li><p><em>name</em> 为一个 gif 文件的文件名， <em>shape</em> 为 <code>None</code>: 安装相应的图像形状。:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.register_shape(<span class="string">"turtle.gif"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当海龟转向时图像形状 <em>不会</em> 转动，因此无法显示海龟的朝向!</p>
</blockquote>
</li>
<li><p><em>name</em> 为指定的字符串，<em>shape</em> 为由坐标值对构成的元组: 安装相应的多边形形状。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.register_shape(<span class="string">"triangle"</span>, ((<span class="number">5</span>,<span class="number">-3</span>), (<span class="number">0</span>,<span class="number">5</span>), (<span class="number">-5</span>,<span class="number">-3</span>)))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><em>name</em> 为指定的字符串， 为一个 (复合) <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Shape" target="_blank" rel="noopener"><code>Shape</code></a> 类对象: 安装相应的复合形状。</li>
</ol>
<p>将一个海龟形状加入 TurtleScreen 的形状列表。只有这样注册过的形状才能通过执行 <code>shape(shapename)</code> 命令来使用。</p>
<p><code>turtle.turtles</code>()</p>
<p>返回屏幕上的海龟列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> turtle <span class="keyword">in</span> screen.turtles():</span><br><span class="line"><span class="meta">... </span>    turtle.color(<span class="string">"red"</span>)</span><br></pre></td></tr></table></figure>
<p><code>turtle.window_height</code>()</p>
<p>返回海龟窗口的高度。:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.window_height()</span><br><span class="line"><span class="number">480</span></span><br></pre></td></tr></table></figure>
<p><code>turtle.window_width</code>()</p>
<p>返回海龟窗口的宽度。:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.window_width()</span><br><span class="line"><span class="number">640</span></span><br></pre></td></tr></table></figure>
<h3 id="Screen-专有方法-而非继承自-TurtleScreen"><a href="#Screen-专有方法-而非继承自-TurtleScreen" class="headerlink" title="Screen 专有方法, 而非继承自 TurtleScreen"></a>Screen 专有方法, 而非继承自 TurtleScreen</h3><ul>
<li><p><code>turtle.bye</code>()</p>
<p>关闭海龟绘图窗口。</p>
</li>
<li><p><code>turtle.exitonclick</code>()</p>
<p>将 bye() 方法绑定到 Screen 上的鼠标点击事件。如果配置字典中 “using_IDLE” 的值为 <code>False</code> (默认值) 则同时进入主事件循环。注: 如果启动 IDLE 时使用了 <code>-n</code> 开关 (无子进程)，<code>turtle.cfg</code> 中此数值应设为 <code>True</code>。在此情况下 IDLE 本身的主事件循环同样会作用于客户脚本。</p>
</li>
<li><p><code>turtle.setup</code>(<em>width=_CFG[“width”], height=_CFG[“height”], startx=_CFG[“leftright”], starty=_CFG[“topbottom”]</em>)</p>
<p>设置主窗口的大小和位置。默认参数值保存在配置字典中，可通过 <code>turtle.cfg</code> 文件进行修改。</p>
<ul>
<li><strong>width</strong> – 如为一个整型数值，表示大小为多少像素，如为一个浮点数值，则表示屏幕的占比；默认为屏幕的 50%</li>
<li><strong>height</strong> – 如为一个整型数值，表示高度为多少像素，如为一个浮点数值，则表示屏幕的占比；默认为屏幕的 75%</li>
<li><strong>startx</strong> – 如为正值，表示初始位置距离屏幕左边缘多少像素，负值表示距离右边缘，<code>None</code> 表示窗口水平居中</li>
<li><strong>starty</strong> – 如为正值，表示初始位置距离屏幕上边缘多少像素，负值表示距离下边缘，<code>None</code> 表示窗口垂直居中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.setup (width=<span class="number">200</span>, height=<span class="number">200</span>, startx=<span class="number">0</span>, starty=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>             <span class="comment"># sets window to 200x200 pixels, in upper left of screen</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.setup(width=<span class="number">.75</span>, height=<span class="number">0.5</span>, startx=<span class="literal">None</span>, starty=<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>             <span class="comment"># sets window to 75% of screen by 50% of screen and centers</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>turtle.title</code>(<em>titlestring</em>)</p>
<ul>
<li><p>参数</p>
<p><strong>titlestring</strong> – 一个字符串，显示为海龟绘图窗口的标题栏文本</p>
</li>
</ul>
<p>设置海龟窗口标题为 <em>titlestring</em> 指定的文本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.title(<span class="string">"Welcome to the turtle zoo!"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="公共类"><a href="#公共类" class="headerlink" title="公共类"></a>公共类</h2><ul>
<li><p><em>class</em> <code>turtle.RawTurtle</code>(<em>canvas</em>)</p>
</li>
<li><p><em>class</em> <code>turtle.RawPen</code>(<em>canvas</em>)</p>
<p>参数<strong>canvas</strong> – 一个 <code>tkinter.Canvas</code> , <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ScrolledCanvas" target="_blank" rel="noopener"><code>ScrolledCanvas</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 类对象创建一个海龟。海龟对象具有 “Turtle/RawTurtle 方法” 一节所述的全部方法。</p>
</li>
<li><p><em>class</em> <code>turtle.Turtle</code></p>
<p>RawTurtle 的子类，具有相同的接口，但其绘图场所为默认的 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Screen" target="_blank" rel="noopener"><code>Screen</code></a> 类对象，在首次使用时自动创建。</p>
</li>
<li><p><em>class</em> <code>turtle.TurtleScreen</code>(<em>cv</em>)</p>
<p>参数<strong>cv</strong> – 一个 <code>tkinter.Canvas</code> 类对象提供面向屏幕的方法例如 <code>setbg()</code> 等。说明见上文。</p>
</li>
<li><p><em>class</em> <code>turtle.Screen</code></p>
<p>TurtleScreen 的子类，<a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#screenspecific" target="_blank" rel="noopener">增加了四个方法</a>.</p>
</li>
<li><p><em>class</em> <code>turtle.ScrolledCanvas</code>(<em>master</em>)</p>
<p>参数<strong>master</strong> – 可容纳 ScrolledCanvas 的 Tkinter 部件，即添加了滚动条的 Tkinter-canvas由 Screen 类使用，使其能够自动提供一个 ScrolledCanvas 作为海龟的绘图场所。</p>
</li>
<li><p><em>class</em> <code>turtle.Shape</code>(<em>type_</em>, <em>data</em>)</p>
<p>参数<strong>type_</strong> – 字符串 “polygon”, “image”, “compound” 其中之一实现形状的数据结构。<code>(type_, data)</code> 必须遵循以下定义:</p>
<p>| <em>type_</em>    | <em>data</em>                                                       |<br>| ———- | ———————————————————— |<br>| “polygon”  | 一个多边形元组，即由坐标值对构成的元组                       |<br>| “image”    | 一个图片 (此形式仅限内部使用!)                               |<br>| “compound” | <code>None</code> (复合形状必须使用 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Shape.addcomponent" target="_blank" rel="noopener"><code>addcomponent()</code></a> 方法来构建) |</p>
</li>
<li><p><code>addcomponent</code>(<em>poly</em>, <em>fill</em>, <em>outline=None</em>)</p>
<ul>
<li><p><strong>poly</strong> – 一个多边形，即由数值对构成的元组</p>
</li>
<li><p><strong>fill</strong> – 一种颜色，将用来填充 <em>poly</em> 指定的多边形</p>
</li>
<li><p><strong>outline</strong> – 一种颜色，用于多边形的轮廓 (如有指定)</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>poly = ((<span class="number">0</span>,<span class="number">0</span>),(<span class="number">10</span>,<span class="number">-5</span>),(<span class="number">0</span>,<span class="number">10</span>),(<span class="number">-10</span>,<span class="number">-5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Shape(<span class="string">"compound"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.addcomponent(poly, <span class="string">"red"</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># ... add more components and then use register_shape()</span></span><br></pre></td></tr></table></figure>
<p>参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#compoundshapes" target="_blank" rel="noopener">复合形状</a>。<em>**</em></p>
</li>
</ul>
</li>
<li><p><em>class</em> <code>turtle.Vec2D</code>(<em>x</em>, <em>y</em>)</p>
<p>一个二维矢量类，用来作为实现海龟绘图的辅助类。也可能在海龟绘图程序中使用。派生自元组，因此矢量也属于元组!</p>
<p>提供的运算 (<em>a</em>, <em>b</em> 为矢量, <em>k</em> 为数值):</p>
<ul>
<li><code>a + b</code> 矢量加法</li>
<li><code>a - b</code> 矢量减法</li>
<li><code>a * b</code> 内积</li>
<li><code>k * a</code> 和 <code>a * k</code> 与标量相乘</li>
<li><code>abs(a)</code> a 的绝对值</li>
<li><code>a.rotate(angle)</code> 旋转</li>
</ul>
</li>
</ul>
<h2 id="帮助与配置"><a href="#帮助与配置" class="headerlink" title="帮助与配置"></a>帮助与配置</h2><h3 id="如何使用帮助"><a href="#如何使用帮助" class="headerlink" title="如何使用帮助"></a>如何使用帮助</h3><p>Screen 和 Turtle 类的公用方法以文档字符串提供了详细的文档。因此可以利用 Python 帮助工具获取这些在线帮助信息:</p>
<ul>
<li><p>当使用 IDLE 时，输入函数/方法调用将弹出工具提示显示其签名和文档字符串的头几行。</p>
</li>
<li><p>对文法或函数调用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#help" target="_blank" rel="noopener"><code>help()</code></a> 将显示其文档字符串:</p>
<p>>&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(Screen.bgcolor)</span><br><span class="line">Help on method bgcolor <span class="keyword">in</span> module turtle:</span><br><span class="line"></span><br><span class="line">bgcolor(self, *args) unbound turtle.Screen method</span><br><span class="line">    Set <span class="keyword">or</span> <span class="keyword">return</span> backgroundcolor of the TurtleScreen.</span><br><span class="line"></span><br><span class="line">    Arguments (<span class="keyword">if</span> given): a color string <span class="keyword">or</span> three numbers</span><br><span class="line">    <span class="keyword">in</span> the range <span class="number">0.</span>.colormode <span class="keyword">or</span> a <span class="number">3</span>-tuple of such numbers.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &gt;&gt;&gt; screen.bgcolor(<span class="string">"orange"</span>)</span><br><span class="line">      &gt;&gt;&gt; screen.bgcolor()</span><br><span class="line">      <span class="string">"orange"</span></span><br><span class="line">      &gt;&gt;&gt; screen.bgcolor(<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">0.5</span>)</span><br><span class="line">      &gt;&gt;&gt; screen.bgcolor()</span><br><span class="line">      <span class="string">"#800080"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(Turtle.penup)</span><br><span class="line">Help on method penup <span class="keyword">in</span> module turtle:</span><br><span class="line"></span><br><span class="line">penup(self) unbound turtle.Turtle method</span><br><span class="line">    Pull the pen up -- no drawing when moving.</span><br><span class="line"></span><br><span class="line">    Aliases: penup | pu | up</span><br><span class="line"></span><br><span class="line">    No argument</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; turtle.penup()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>方法对应函数的文档字符串的形式会有一些修改:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(bgcolor)</span><br><span class="line">Help on function bgcolor <span class="keyword">in</span> module turtle:</span><br><span class="line"></span><br><span class="line">bgcolor(*args)</span><br><span class="line">    Set <span class="keyword">or</span> <span class="keyword">return</span> backgroundcolor of the TurtleScreen.</span><br><span class="line"></span><br><span class="line">    Arguments (<span class="keyword">if</span> given): a color string <span class="keyword">or</span> three numbers</span><br><span class="line">    <span class="keyword">in</span> the range <span class="number">0.</span>.colormode <span class="keyword">or</span> a <span class="number">3</span>-tuple of such numbers.</span><br><span class="line"></span><br><span class="line">    Example::</span><br><span class="line"></span><br><span class="line">      &gt;&gt;&gt; bgcolor(<span class="string">"orange"</span>)</span><br><span class="line">      &gt;&gt;&gt; bgcolor()</span><br><span class="line">      <span class="string">"orange"</span></span><br><span class="line">      &gt;&gt;&gt; bgcolor(<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">0.5</span>)</span><br><span class="line">      &gt;&gt;&gt; bgcolor()</span><br><span class="line">      <span class="string">"#800080"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(penup)</span><br><span class="line">Help on function penup <span class="keyword">in</span> module turtle:</span><br><span class="line"></span><br><span class="line">penup()</span><br><span class="line">    Pull the pen up -- no drawing when moving.</span><br><span class="line"></span><br><span class="line">    Aliases: penup | pu | up</span><br><span class="line"></span><br><span class="line">    No argument</span><br><span class="line"></span><br><span class="line">    Example:</span><br><span class="line">    &gt;&gt;&gt; penup()</span><br></pre></td></tr></table></figure>
<p>这些修改版文档字符串是在导入时与方法对应函数的定义一起自动生成的。</p>
<h3 id="文档字符串翻译为不同的语言"><a href="#文档字符串翻译为不同的语言" class="headerlink" title="文档字符串翻译为不同的语言"></a>文档字符串翻译为不同的语言</h3><p>可使用工具创建一个字典，键为方法名，值为 Screen 和 Turtle 类公共方法的文档字符串。</p>
<ul>
<li><p><code>turtle.write_docstringdict</code>(<em>filename=”turtle_docstringdict”</em>)</p>
<p>参数<strong>filename</strong> – 一个字符串，表示文件名创建文档字符串字典并将其写入 filename 指定的 Python 脚本文件。此函数必须显示地调用 (海龟绘图类并不使用此函数)。文档字符串字典将被写入到 Python 脚本文件 <code>*filename*.py</code>。该文件可作为模板用来将文档字符串翻译为不同语言。</p>
</li>
</ul>
<p>如果你 (或你的学生) 想使用本国语言版本的 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 在线帮助，你必须翻译文档字符串并保存结果文件，例如 <code>turtle_docstringdict_german.py</code>.</p>
<p>如果你在 <code>turtle.cfg</code> 文件中加入了相应的条目，此字典将在导入模块时被读取并替代原有的英文版文档字符串。</p>
<p>在撰写本文档时已经有了德语和意大利语版的文档字符串字典。(更多需求请联系 <a href="mailto:glingl%40aon.at" target="_blank" rel="noopener">glingl@aon.at</a>)</p>
<h3 id="如何配置-Screen-和-Turtle"><a href="#如何配置-Screen-和-Turtle" class="headerlink" title="如何配置 Screen 和 Turtle"></a>如何配置 Screen 和 Turtle</h3><p>内置的默认配置是模仿旧 turtle 模块的外观和行为，以便尽可能地与其保持兼容。</p>
<p>如果你想使用不同的配置，以便更好地反映此模块的特性或是更适合你的需求，例如在课堂中使用，你可以准备一个配置文件 <code>turtle.cfg</code>，该文件将在导入模块时被读取并根据其中的设定修改模块配置。</p>
<p>内置的配置对应以下的 turtle.cfg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">width = <span class="number">0.5</span></span><br><span class="line">height = <span class="number">0.75</span></span><br><span class="line">leftright = <span class="literal">None</span></span><br><span class="line">topbottom = <span class="literal">None</span></span><br><span class="line">canvwidth = <span class="number">400</span></span><br><span class="line">canvheight = <span class="number">300</span></span><br><span class="line">mode = standard</span><br><span class="line">colormode = <span class="number">1.0</span></span><br><span class="line">delay = <span class="number">10</span></span><br><span class="line">undobuffersize = <span class="number">1000</span></span><br><span class="line">shape = classic</span><br><span class="line">pencolor = black</span><br><span class="line">fillcolor = black</span><br><span class="line">resizemode = noresize</span><br><span class="line">visible = <span class="literal">True</span></span><br><span class="line">language = english</span><br><span class="line">exampleturtle = turtle</span><br><span class="line">examplescreen = screen</span><br><span class="line">title = Python Turtle Graphics</span><br><span class="line">using_IDLE = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>选定条目的简短说明:</p>
<ul>
<li>开头的四行对应 <code>Screen.setup()</code> 方法的参数。</li>
<li>第 5 和 6 行对应 <code>Screen.screensize()</code> 方法的参数。</li>
<li><em>shape</em> 可以是任何内置形状，即: arrow, turtle 等。更多信息可用 <code>help(shape)</code> 查看。</li>
<li>如果你想使用无填充色 (即令海龟变透明)，你必须写 <code>fillcolor = &quot;&quot;</code> (但 cfg 文件中所有非空字符串都不可加引号)。</li>
<li>如果你想令海龟反映其状态，你必须使用 <code>resizemode = auto</code>。</li>
<li>如果你设置语言例如 <code>language = italian</code> 则文档字符串字典 <code>turtle_docstringdict_italian.py</code> 将在导入模块时被加载 (如果导入路径即 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 的目录中存在此文件。</li>
<li><em>exampleturtle</em> 和 <em>examplescreen</em> 条目定义了相应对象在文档字符串中显示的名称。方法文档字符串转换为函数文档字符串时将从文档字符串中删去这些名称。</li>
<li><em>using_IDLE</em>: 如果你经常使用 IDLE 并启用其 -n 开关 (“无子进程”) 则应将此项设为 <code>True</code>，这将阻止 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.exitonclick" target="_blank" rel="noopener"><code>exitonclick()</code></a> 进入主事件循环。</li>
</ul>
<p><code>turtle.cfg</code> 文件可以保存于 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 所在目录，当前工作目录也可以有一个同名文件。后者会重载覆盖前者的设置。</p>
<p><code>Lib/turtledemo</code> 目录中也有一个 <code>turtle.cfg</code> 文件。你可以将其作为示例进行研究，并在运行演示时查看其作用效果 (但最好不要在演示查看器中运行)。</p>
<h2 id="turtledemo-—-演示脚本集"><a href="#turtledemo-—-演示脚本集" class="headerlink" title="turtledemo — 演示脚本集"></a><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtledemo" target="_blank" rel="noopener"><code>turtledemo</code></a> — 演示脚本集</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtledemo" target="_blank" rel="noopener"><code>turtledemo</code></a> 包汇集了一组演示脚本。这些脚本可以通过以下命令打开所提供的演示查看器运行和查看:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m turtledemo</span><br></pre></td></tr></table></figure>
<p>此外，你也可以单独运行其中的演示脚本。例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m turtledemo.bytedesign</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtledemo" target="_blank" rel="noopener"><code>turtledemo</code></a> 包目录中的内容:</p>
<ul>
<li>一个演示查看器 <code>__main__.py</code>，可用来查看脚本的源码并即时运行。</li>
<li>多个脚本文件，演示 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 模块的不同特性。所有示例可通过 Examples 菜单打开。也可以单独运行每个脚本。</li>
<li>一个 <code>turtle.cfg</code> 文件，作为说明如何编写并使用模块配置文件的示例模板。</li>
</ul>
<p>演示脚本清单如下:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>相关特性</th>
</tr>
</thead>
<tbody>
<tr>
<td>bytedesign</td>
<td>复杂的传统海龟绘图模式</td>
<td><code>tracer()</code>, delay, <code>update()</code></td>
</tr>
<tr>
<td>chaos</td>
<td>绘制 Verhulst 动态模型，演示通过计算机的运算可能会生成令人惊叹的结果</td>
<td>世界坐标系</td>
</tr>
<tr>
<td>clock</td>
<td>绘制模拟时钟显示本机的当前时间</td>
<td>海龟作为表针, ontimer</td>
</tr>
<tr>
<td>colormixer</td>
<td>试验 r, g, b 颜色模式</td>
<td><code>ondrag()</code> 当鼠标拖动</td>
</tr>
<tr>
<td>forest</td>
<td>绘制 3 棵广度优先树</td>
<td>随机化</td>
</tr>
<tr>
<td>fractalcurves</td>
<td>绘制 Hilbert &amp; Koch 曲线</td>
<td>递归</td>
</tr>
<tr>
<td>lindenmayer</td>
<td>文化数学 (印度装饰艺术)</td>
<td>L-系统</td>
</tr>
<tr>
<td>minimal_hanoi</td>
<td>汉诺塔</td>
<td>矩形海龟作为汉诺盘 (shape, shapesize)</td>
</tr>
<tr>
<td>nim</td>
<td>玩经典的“尼姆”游戏，开始时有三堆小棒，与电脑对战。</td>
<td>海龟作为小棒，事件驱动 (鼠标, 键盘)</td>
</tr>
<tr>
<td>paint</td>
<td>超极简主义绘画程序</td>
<td><code>onclick()</code> 当鼠标点击</td>
</tr>
<tr>
<td>peace</td>
<td>初级技巧</td>
<td>海龟: 外观与动画</td>
</tr>
<tr>
<td>penrose</td>
<td>非周期性地使用风筝和飞镖形状铺满平面</td>
<td><code>stamp()</code> 印章</td>
</tr>
<tr>
<td>planet_and_moon</td>
<td>模拟引力系统</td>
<td>复合开关, <code>Vec2D</code> 类</td>
</tr>
<tr>
<td>round_dance</td>
<td>两两相对并不断旋转舞蹈的海龟</td>
<td>复合形状, clone shapesize, tilt, get_shapepoly, update</td>
</tr>
<tr>
<td>sorting_animate</td>
<td>动态演示不同的排序方法</td>
<td>简单对齐, 随机化</td>
</tr>
<tr>
<td>tree</td>
<td>一棵 (图形化的) 广度优先树 (使用生成器)</td>
<td><code>clone()</code> 克隆</td>
</tr>
<tr>
<td>two_canvases</td>
<td>简单设计</td>
<td>两块画布上的海龟</td>
</tr>
<tr>
<td>wikipedia</td>
<td>一个来自介绍海龟绘图的维基百科文章的图案</td>
<td><code>clone()</code>, <code>undo()</code></td>
</tr>
<tr>
<td>yinyang</td>
<td>另一个初级示例</td>
<td><code>circle()</code> 画圆</td>
</tr>
</tbody>
</table>
<p>祝你玩得开心！</p>
<h2 id="Python-2-6-之后的变化"><a href="#Python-2-6-之后的变化" class="headerlink" title="Python 2.6 之后的变化"></a>Python 2.6 之后的变化</h2><ul>
<li><code>Turtle.tracer()</code>, <code>Turtle.window_width()</code> 和 <code>Turtle.window_height()</code> 方法已被去除。具有这些名称和功能的方法现在只限于 <code>Screen</code> 类的方法。但其对应的函数仍然可用。(实际上在 Python 2.6 中这些方法就已经只是从对应的 <code>TurtleScreen</code>/<code>Screen</code> 类的方法复制而来。)</li>
<li><code>Turtle.fill()</code> 方法已被去除。<code>begin_fill()</code> 和 <code>end_fill()</code> 的行为则有细微改变: 现在每个填充过程必须以一个 <code>end_fill()</code> 调用来结束。</li>
<li>新增了一个 <code>Turtle.filling()</code> 方法。该方法返回一个布尔值: 如果填充过程正在进行为 <code>True</code>，否则为 <code>False</code>。此行为相当于 Python 2.6 中不带参数的 <code>fill()</code> 调用。</li>
</ul>
<h2 id="Python-3-0-之后的变化"><a href="#Python-3-0-之后的变化" class="headerlink" title="Python 3.0 之后的变化"></a>Python 3.0 之后的变化</h2><ul>
<li>新增了 <code>Turtle.shearfactor()</code>, <code>Turtle.shapetransform()</code> 和 <code>Turtle.get_shapepoly()</code> 方法。这样就可以使用所有标准线性变换来调整海龟形状。<code>Turtle.tiltangle()</code> 的功能已被加强: 现在可被用来获取或设置倾角。<code>Turtle.settiltangle()</code> 已弃用。</li>
<li>新增了 <code>Screen.onkeypress()</code> 方法作为对 <code>Screen.onkey()</code> 的补充，实际就是将行为绑定到 keyrelease 事件。后者相应增加了一个别名: <code>Screen.onkeyrelease()</code>。</li>
<li>新增了 <code>Screen.mainloop()</code> 方法。这样当仅需使用 Screen 和 Turtle 对象时不需要再额外导入 <code>mainloop()</code>。</li>
<li>新增了两个方法 <code>Screen.textinput()</code> 和 <code>Screen.numinput()</code>。用来弹出对话框接受输入并分别返回字符串和数值。</li>
<li>两个新的示例脚本 <code>tdemo_nim.py</code> 和 <code>tdemo_round_dance.py</code> 被加入到 <code>Lib/turtledemo</code> 目录中。</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>turtle</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library keyword</title>
    <url>/2020/03/02/python-standard-library-keyword/</url>
    <content><![CDATA[<h2 id="python-标准库-keyword"><a href="#python-标准库-keyword" class="headerlink" title="python 标准库 keyword"></a>python 标准库 keyword</h2><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200302_luoxia.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>闺女语录:</p>
<p>我和同事聊天说起,养个孩子容易吗! 我闺女说,“养什么容易啊。”</p>
<p>同事咂舌,这个小孩不简单。</p>
</blockquote>
<blockquote>
<p>每日一词:</p>
<p>candaign [kæm’peɪn]</p>
<ul>
<li>n.战役；运动（为社会、商业或政治目的而进行的一系列有计划的活动）</li>
<li>v.领导运动（如为实现政治变革或赢得竞选）</li>
<li>网络战役模式；竞选运动；广告活动</li>
</ul>
</blockquote>
<p>这估计是标准库中最简单的模块了</p>
<p>源代码比较少,这就直接贴出来了</p>
<p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/keyword.py" target="_blank" rel="noopener">Lib/keyword.py</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kwlist = [</span><br><span class="line">    <span class="string">'False'</span>,</span><br><span class="line">    <span class="string">'None'</span>,</span><br><span class="line">    <span class="string">'True'</span>,</span><br><span class="line">    <span class="string">'and'</span>,</span><br><span class="line">    <span class="string">'as'</span>,</span><br><span class="line">    <span class="string">'assert'</span>,</span><br><span class="line">    <span class="string">'async'</span>,</span><br><span class="line">    <span class="string">'await'</span>,</span><br><span class="line">    <span class="string">'break'</span>,</span><br><span class="line">    <span class="string">'class'</span>,</span><br><span class="line">    <span class="string">'continue'</span>,</span><br><span class="line">    <span class="string">'def'</span>,</span><br><span class="line">    <span class="string">'del'</span>,</span><br><span class="line">    <span class="string">'elif'</span>,</span><br><span class="line">    <span class="string">'else'</span>,</span><br><span class="line">    <span class="string">'except'</span>,</span><br><span class="line">    <span class="string">'finally'</span>,</span><br><span class="line">    <span class="string">'for'</span>,</span><br><span class="line">    <span class="string">'from'</span>,</span><br><span class="line">    <span class="string">'global'</span>,</span><br><span class="line">    <span class="string">'if'</span>,</span><br><span class="line">    <span class="string">'import'</span>,</span><br><span class="line">    <span class="string">'in'</span>,</span><br><span class="line">    <span class="string">'is'</span>,</span><br><span class="line">    <span class="string">'lambda'</span>,</span><br><span class="line">    <span class="string">'nonlocal'</span>,</span><br><span class="line">    <span class="string">'not'</span>,</span><br><span class="line">    <span class="string">'or'</span>,</span><br><span class="line">    <span class="string">'pass'</span>,</span><br><span class="line">    <span class="string">'raise'</span>,</span><br><span class="line">    <span class="string">'return'</span>,</span><br><span class="line">    <span class="string">'try'</span>,</span><br><span class="line">    <span class="string">'while'</span>,</span><br><span class="line">    <span class="string">'with'</span>,</span><br><span class="line">    <span class="string">'yield'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">iskeyword = frozenset(kwlist).__contains__</span><br></pre></td></tr></table></figure>
<p>此模块允许 Python 程序确定字符串是否为关键字。</p>
<ul>
<li><p><code>keyword.iskeyword</code>(<em>s</em>)</p>
<p>如果 <em>s</em> 是一个 Python 保留关键字则返回 <code>True</code>,否则返回<code>False</code>。</p>
</li>
<li><p><code>keyword.kwlist</code></p>
<p>序列包含为解释器定义的所有关键字。 如果任何被定义的关键字为仅在 <a href="https://docs.python.org/zh-cn/3.8/library/__future__.html#module-__future__" target="_blank" rel="noopener"><code>__future__</code></a> 语句生效是特定时间处于活动状态，则也将包含这些关键字。</p>
<p>其实就是获得所有关键字构成的列表。</p>
</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>这里主要涉及两个知识点:</p>
<ol>
<li><p>冻结集合: <code>frozenset</code> 通过这个函数,创建一个由参数构成的不可变集合。</p>
</li>
<li><p>魔术方法 <code>__contains__</code> ： 定义当使用成员测试运算符（in 或 not in）时的行为</p>
</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>keyword</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library atexit</title>
    <url>/2020/03/03/python-standard-library-atexit/</url>
    <content><![CDATA[<h1 id="python-标准库-atexit"><a href="#python-标准库-atexit" class="headerlink" title="python 标准库 atexit"></a>python 标准库 atexit</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200303_Prometheus.jpeg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>Prometheus  普罗米修斯(盗火者)</p>
<p>在希腊神话中，是最具智慧的神明之一，最早的泰坦巨神后代，名字有“先见之明”（Forethought）的意思。<a href="https://baike.baidu.com/item/%E6%B3%B0%E5%9D%A6%E5%8D%81%E4%BA%8C%E7%A5%9E/3078723" target="_blank" rel="noopener">泰坦十二神</a><a href="https://baike.baidu.com/item/%E4%BC%8A%E9%98%BF%E4%BD%A9%E6%89%98%E6%96%AF/10284100" target="_blank" rel="noopener">伊阿佩托斯</a>与<a href="https://baike.baidu.com/item/%E5%85%8B%E5%90%95%E5%A2%A8%E6%B6%85" target="_blank" rel="noopener">克吕墨涅</a>的儿子。普罗米修斯不仅创造了人类，给人类带来了火，还教会了他们许多知识和技能。</p>
<p>例句:</p>
<p>Zeus saw through the trick and felt displeased at the Titan’s favour towards men. </p>
<p>宙斯识破了这套把戏,<strong>普罗米修斯</strong>对人类的偏爱让他很不高兴.</p>
<p>扩展:</p>
<p> 电影&lt;普罗米修斯&gt;  讲述的是 21世纪末，人类的科技水平已高度发达，克隆人技术和宇宙航行早已实现，不再是梦想。与此同时，许多科学家仍孜孜不倦追索着人类起源的秘密与真相。人类可能是来自一个遥远星系的外星人创造的,经典中的经典。</p>
</blockquote>
<p><a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 模块定义了清理函数的注册和反注册函数. 被注册的函数会在解释器正常终止时执行. <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 会按照注册顺序的<em>逆序</em>执行; 如果你注册了 <code>A</code>, <code>B</code> 和 <code>C</code>, 那么在解释器终止时会依序执行 <code>C</code>, <code>B</code>, <code>A</code>.</p>
<p><strong>注意:</strong> 通过该模块注册的函数, 在程序被未被 Python 捕获的信号杀死时并不会执行, 在检测到 Python 内部致命错误以及调用了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os._exit" target="_blank" rel="noopener"><code>os._exit()</code></a> 时也不会执行.</p>
<p><em>在 3.7 版更改:</em> 当配合 C-API 子解释器使用时，已注册函数是它们所注册解释器中的局部对象。</p>
<ul>
<li><p><code>atexit.register</code>(<em>func</em>, <strong>args<em>, </em></strong>kwargs*)</p>
<p>将 <em>func</em> 注册为终止时执行的函数. 任何传给 <em>func</em> 的可选的参数都应当作为参数传给 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#atexit.register" target="_blank" rel="noopener"><code>register()</code></a>. 可以多次注册同样的函数及参数.在正常的程序终止时 (举例来说, 当调用了 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 或是主模块的执行完成时), 所有注册过的函数都会以后进先出的顺序执行. 这样做是假定更底层的模块通常会比高层模块更早引入, 因此需要更晚清理.如果在 exit 处理程序执行期间引发了异常，将会打印回溯信息 (除非引发的是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a>) 并且异常信息会被保存。 在所有 exit 处理程序获得运行机会之后，所引发的最后一个异常会被重新引发。这个函数返回 <em>func</em> 对象，可以把它当作装饰器使用。</p>
</li>
<li><p><code>atexit.unregister</code>(<em>func</em>)</p>
<p>从解释器关闭前要运行的函数列表中移除 <em>func</em>。 在调用 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#atexit.unregister" target="_blank" rel="noopener"><code>unregister()</code></a> 之后，当解释器关闭时会确保 <em>func</em> 不会被调用，即使它被多次注册。 如果 <em>func</em> 之前没有被注册，<a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#atexit.unregister" target="_blank" rel="noopener"><code>unregister()</code></a> 会静默地不做任何操作。</p>
</li>
</ul>
<p>参见</p>
<ul>
<li><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a></p>
<p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 读写 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 历史文件的有用的例子。</p>
</li>
</ul>
<h2 id="atexit-示例"><a href="#atexit-示例" class="headerlink" title="atexit 示例"></a><a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 示例</h2><p>以下简单例子演示了一个模块在被导入时如何从文件初始化一个计数器，并在程序终结时自动保存计数器的更新值，此操作不依赖于应用在终结时对此模块进行显式调用。:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    with open(&quot;counterfile&quot;) as infile:</span><br><span class="line">        _count = int(infile.read())</span><br><span class="line">except FileNotFoundError:</span><br><span class="line">    _count = 0</span><br><span class="line"></span><br><span class="line">def incrcounter(n):</span><br><span class="line">    global _count</span><br><span class="line">    _count = _count + n</span><br><span class="line"></span><br><span class="line">def savecounter():</span><br><span class="line">    with open(&quot;counterfile&quot;, &quot;w&quot;) as outfile:</span><br><span class="line">        outfile.write(&quot;%d&quot; % _count)</span><br><span class="line"></span><br><span class="line">import atexit</span><br><span class="line">atexit.register(savecounter)</span><br></pre></td></tr></table></figure>
<p>位置和关键字参数也可传入 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#atexit.register" target="_blank" rel="noopener"><code>register()</code></a> 以便传递给被调用的已注册函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def goodbye(name, adjective):</span><br><span class="line">    print(&apos;Goodbye, %s, it was %s to meet you.&apos; % (name, adjective))</span><br><span class="line"></span><br><span class="line">import atexit</span><br><span class="line">atexit.register(goodbye, &apos;Donny&apos;, &apos;nice&apos;)</span><br><span class="line"></span><br><span class="line"># or:</span><br><span class="line">atexit.register(goodbye, adjective=&apos;nice&apos;, name=&apos;Donny&apos;)</span><br></pre></td></tr></table></figure>
<p>作为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-decorator" target="_blank" rel="noopener">decorator</a>: 使用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import atexit</span><br><span class="line"></span><br><span class="line">@atexit.register</span><br><span class="line">def goodbye():</span><br><span class="line">    print(&quot;You are now leaving the Python sector.&quot;)</span><br></pre></td></tr></table></figure>
<p>只有在函数不需要任何参数调用时才能工作.</p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>atexit</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library select</title>
    <url>/2020/03/01/python-standard-library-select/</url>
    <content><![CDATA[<h1 id="python-标准库-select-等待-I-O-完成"><a href="#python-标准库-select-等待-I-O-完成" class="headerlink" title="python 标准库 select  等待 I/O 完成"></a>python 标准库 select  等待 I/O 完成</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200301_ncc_1701.webp?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>star trek n 星际迷航</p>
<p>trek n 长途跋涉</p>
<p>​      vi 旅行</p>
<p>例句：</p>
<ol>
<li>It took us a week to trek to the foot of the mountain.<br>我们花了一星期才跋涉到山脚。</li>
<li><p>I hate having to trek up that hill with all the groceries.<br>我很不愿意得带着这么多吃用杂物爬上那个山头。</p>
</li>
<li><p>The trek is especially difficult for us.<br>我们走起来更加艰难。</p>
</li>
<li>My boots were punished by our long trek in the mountains.<br>我的靴子因为我们在山中漫长的徒步而受损。</li>
</ol>
</blockquote>
<p>该模块提供了对 <code>select()</code> 和 <code>poll()</code> 函数的访问，这些函数在大多数操作系统中是可用的。在 Solaris 及其衍生版本上可用 <code>devpoll()</code>，在 Linux 2.5+ 上可用 <code>epoll()</code>，在大多数 BSD 上可用 <code>kqueue()</code>。注意，在 Windows 上，本模块仅适用于套接字；在其他操作系统上，本模块也适用于其他文件类型（特别地，在 Unix 上也适用于管道）。本模块不能用于常规文件，不能检测出（自上次读取文件后）文件是否有新数据写入。</p>
<blockquote>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#module-selectors" target="_blank" rel="noopener"><code>selectors</code></a> 模块是在 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#module-select" target="_blank" rel="noopener"><code>select</code></a> 模块原型的基础上进行高级且高效的 I/O 复用。推荐用户改用 <a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#module-selectors" target="_blank" rel="noopener"><code>selectors</code></a> 模块，除非用户希望对 OS 级的函数原型进行精确控制。</p>
</blockquote>
<p>该模块定义以下内容：</p>
<ul>
<li><p><em>exception</em> <code>select.error</code></p>
<p>一个被弃用的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的别名。<em>在 3.3 版更改:</em> 根据 <a href="https://www.python.org/dev/peps/pep-3151" target="_blank" rel="noopener"><strong>PEP 3151</strong></a>，这个类是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的别名。</p>
</li>
<li><p><code>select.devpoll</code>()</p>
<p>（仅支持 Solaris 及其衍生版本）返回一个 <code>/dev/poll</code> 轮询对象，请参阅下方 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#devpoll-objects" target="_blank" rel="noopener">/dev/poll 轮询对象</a> 获取 devpoll 对象所支持的方法。<code>devpoll()</code> 对象与实例化时允许的文件描述符数量有关，如果在程序中降低了此数值，<code>devpoll()</code> 调用将失败。如果程序提高了此数值，<code>devpoll()</code> 可能会返回一个不完整的活动文件描述符列表。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承的</a>。<em>3.3 新版功能.**在 3.4 版更改:</em> 新的文件描述符现在是不可继承的。</p>
</li>
<li><p><code>select.epoll</code>(<em>sizehint=-1</em>, <em>flags=0</em>)</p>
<p>（仅支持 Linux 2.5.44 或更高版本）返回一个 edge poll 对象，该对象可作为 I/O 事件的边缘触发或水平触发接口。<em>sizehint</em> 指示 epoll 预计需要注册的事件数。它必须为正数，或为 -1 以使用默认值。它仅在 <code>epoll_create1()</code> 不可用的旧系统上会被用到，其他情况下它没有任何作用（尽管仍会检查其值）。<em>flags</em> 已经弃用且完全被忽略。但是，如果提供该值，则它必须是 <code>0</code> 或 <code>select.EPOLL_CLOEXEC</code>，否则会抛出 <code>OSError</code> 异常。请参阅下方 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#epoll-objects" target="_blank" rel="noopener">边缘触发和水平触发的轮询 (epoll) 对象</a> 获取 epoll 对象所支持的方法。<code>epoll</code> 对象支持上下文管理器：当在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中使用时，新建的文件描述符会在运行至语句块结束时自动关闭。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承的</a>。<em>在 3.3 版更改:</em> 增加了 <em>flags</em> 参数。<em>在 3.4 版更改:</em> 增加了对 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的支持。新的文件描述符现在是不可继承的。<em>3.4 版后已移除:</em> <em>flags</em> 参数。现在默认采用 <code>select.EPOLL_CLOEXEC</code> 标志。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.set_inheritable" target="_blank" rel="noopener"><code>os.set_inheritable()</code></a> 来让文件描述符可继承。</p>
</li>
<li><p><code>select.poll</code>()</p>
<p>（部分操作系统不支持）返回一个 poll 对象，该对象支持注册和注销文件描述符，支持对描述符进行轮询以获取 I/O 事件。请参阅下方 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#poll-objects" target="_blank" rel="noopener">Poll 对象</a> 获取 poll 对象所支持的方法。</p>
</li>
<li><p><code>select.kqueue</code>()</p>
<p>（仅支持 BSD）返回一个内核队列对象，请参阅下方 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#kqueue-objects" target="_blank" rel="noopener">Kqueue 对象</a> 获取 kqueue 对象所支持的方法。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承的</a>。<em>在 3.4 版更改:</em> 新的文件描述符现在是不可继承的。</p>
</li>
<li><p><code>select.kevent</code>(<em>ident</em>, <em>filter=KQ_FILTER_READ</em>, <em>flags=KQ_EV_ADD</em>, <em>fflags=0</em>, <em>data=0</em>, <em>udata=0</em>)</p>
<p>（仅支持 BSD）返回一个内核事件对象，请参阅下方 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#kevent-objects" target="_blank" rel="noopener">Kevent 对象</a> 获取 kevent 对象所支持的方法。</p>
</li>
<li><p><code>select.select</code>(<em>rlist</em>, <em>wlist</em>, <em>xlist</em>[, <em>timeout</em>])</p>
<p>这是 Unix <code>select()</code> 系统调用的直接接口。前三个参数是由“等待对象”组成的序列，“等待对象”可以是表示文件描述符的整数，也可以是带有 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法的对象（该方法没有参数，返回一个整数）：<em>rlist</em>：等待，直到可以开始读取<em>wlist</em>：等待，直到可以开始写入<em>xlist</em>：等待“异常情况”（请参阅当前系统的手册，以获取哪些情况称为异常情况）允许使用空序列，但是否接受三个空序列取决于平台。（目前已知在 Unix 上可以但 Windows 上不行。）可选的 <em>timeout</em> 参数指定超时时长，为浮点数，以秒为单位。如果省略了 <em>timeout</em> 参数，则该函数将阻塞，直到至少一个文件描述符准备就绪。超时值为零表示轮询且永不阻塞。返回值是三个列表，包含已就绪对象，返回的三个列表是前三个参数的子集。当超时时间已到且没有文件描述符就绪时，返回三个空列表。序列中可接受的对象类型包括 Python <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">文件对象</a> (例如 <code>sys.stdin</code>、<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>os.popen()</code></a> 返回的对象)，<a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.socket" target="_blank" rel="noopener"><code>socket.socket()</code></a> 返回的套接字对象。 你也可以自定义 <em>wrapper</em> 类，只要它具有合适的 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法（该方法应返回实际的文件描述符，而不仅仅返回一个随机整数）。</p>
<blockquote>
<p>Windows 上不接受文件对象，但接受套接字。在 Windows 上，底层的 <code>select()</code> 函数由 WinSock 库提供，且不处理不是源自 WinSock 的文件描述符。</p>
</blockquote>
<p> <em>3.5 版更改:</em> 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p>
</li>
<li><p>select.PIPE_BUF</p>
<p>当一个管道已经被 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.select" target="_blank" rel="noopener"><code>select()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.poll" target="_blank" rel="noopener"><code>poll()</code></a> 或本模块中的某个接口报告为可写入时，可以在不阻塞该管道的情况下写入的最小字节数。它不适用于套接字等其他类型的文件类对象。</p>
<p>POSIX 上须保证该值不小于 512。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix</p>
</li>
</ul>
<h2 id="dev-poll-轮询对象"><a href="#dev-poll-轮询对象" class="headerlink" title="/dev/poll 轮询对象"></a><code>/dev/poll</code> 轮询对象</h2><p>Solaris 及其衍生版本具备 <code>/dev/poll</code>。<code>select()</code> 复杂度为 O（最高文件描述符），<code>poll()</code> 为 O（文件描述符数量），而 <code>/dev/poll</code> 为 O（活动的文件描述符）。</p>
<p><code>/dev/poll</code> 的行为与标准 <code>poll()</code> 对象十分类似。</p>
<ul>
<li><p><code>devpoll.close</code>()</p>
<p>关闭轮询对象的文件描述符。<em>3.4 新版功能.</em></p>
</li>
<li><p><code>devpoll.closed</code></p>
<p>如果轮询对象已关闭，则返回 <code>True</code>。<em>3.4 新版功能.</em></p>
</li>
<li><p><code>devpoll.fileno</code>()</p>
<p>返回轮询对象的文件描述符对应的数字。<em>3.4 新版功能.</em></p>
</li>
<li><p><code>devpoll.register</code>(<em>fd</em>[, <em>eventmask</em>])</p>
<p>在轮询对象中注册文件描述符。这样，将来调用 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.poll" target="_blank" rel="noopener"><code>poll()</code></a> 方法时将检查文件描述符是否有未处理的 I/O 事件。<em>fd</em> 可以是整数，也可以是带有 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法的对象（该方法返回一个整数）。文件对象已经实现了 <code>fileno()</code>，因此它们也可以用作参数。<em>eventmask</em> 是可选的位掩码，用于指定要检查的事件类型。这些常量与 <code>poll()</code> 对象所用的相同。本参数的默认值是常量 <code>POLLIN</code>、<code>POLLPRI</code> 和 <code>POLLOUT</code> 的组合。</p>
</li>
<li><p><code>devpoll.modify</code>(<em>fd</em>[, <em>eventmask</em>])</p>
<p>此方法先执行 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.devpoll.unregister" target="_blank" rel="noopener"><code>unregister()</code></a> 后执行 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.devpoll.register" target="_blank" rel="noopener"><code>register()</code></a>。直接执行此操作效率（稍微）高一些。</p>
</li>
<li><p><code>devpoll.unregister</code>(<em>fd</em>)</p>
<p>删除轮询对象正在跟踪的某个文件描述符。与 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.devpoll.register" target="_blank" rel="noopener"><code>register()</code></a> 方法类似，<em>fd</em> 可以是整数，也可以是带有 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法的对象（该方法返回一个整数）。尝试删除从未注册过的文件描述符将被安全地忽略。</p>
</li>
<li><p><code>devpoll.poll</code>([<em>timeout</em>])</p>
<p>轮询已注册的文件描述符的集合，并返回一个列表，列表可能为空，也可能有多个 <code>(fd, event)</code> 二元组，其中包含了要报告事件或错误的描述符。<em>fd</em> 是文件描述符，<em>event</em> 是一个位掩码，表示该描述符所报告的事件 — <code>POLLIN</code> 表示可以读取，<code>POLLOUT</code> 表示该描述符可以写入，依此类推。空列表表示调用超时，没有任何文件描述符报告事件。如果指定了 <em>timeout</em>，它将指定系统等待事件时，等待多长时间后返回（以毫秒为单位）。如果 <em>timeout</em> 为空，-1 或 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>，则本调用将阻塞，直到轮询对象发生事件为止。<em>在 3.5 版更改:</em> 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p>
</li>
</ul>
<h2 id="边缘触发和水平触发的轮询-epoll-对象"><a href="#边缘触发和水平触发的轮询-epoll-对象" class="headerlink" title="边缘触发和水平触发的轮询 (epoll) 对象"></a>边缘触发和水平触发的轮询 (epoll) 对象</h2><p><a href="https://linux.die.net/man/4/epoll" target="_blank" rel="noopener">https://linux.die.net/man/4/epoll</a></p>
<p><em>eventmask</em></p>
<table>
<thead>
<tr>
<th>常数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EPOLLIN</code></td>
<td>可读</td>
</tr>
<tr>
<td><code>EPOLLOUT</code></td>
<td>可写</td>
</tr>
<tr>
<td><code>EPOLLPRI</code></td>
<td>紧急数据读取</td>
</tr>
<tr>
<td><code>EPOLLERR</code></td>
<td>在关联的文件描述符上有错误情况发生</td>
</tr>
<tr>
<td><code>EPOLLHUP</code></td>
<td>关联的文件描述符已挂起</td>
</tr>
<tr>
<td><code>EPOLLET</code></td>
<td>设置触发方式为边缘触发，默认为水平触发</td>
</tr>
<tr>
<td><code>EPOLLONESHOT</code></td>
<td>设置 one-shot 模式。触发一次事件后，该描述符会在轮询对象内部被禁用。</td>
</tr>
<tr>
<td><code>EPOLLEXCLUSIVE</code></td>
<td>当已关联的描述符发生事件时，仅唤醒一个 epoll 对象。默认（如果未设置此标志）是唤醒所有轮询该描述符的 epoll 对象。</td>
</tr>
<tr>
<td><code>EPOLLRDHUP</code></td>
<td>流套接字的对侧关闭了连接或关闭了写入到一半的连接。</td>
</tr>
<tr>
<td><code>EPOLLRDNORM</code></td>
<td>等同于 <code>EPOLLIN</code></td>
</tr>
<tr>
<td><code>EPOLLRDBAND</code></td>
<td>可以读取优先数据带。</td>
</tr>
<tr>
<td><code>EPOLLWRNORM</code></td>
<td>等同于 <code>EPOLLOUT</code></td>
</tr>
<tr>
<td><code>EPOLLWRBAND</code></td>
<td>可以写入优先级数据。</td>
</tr>
<tr>
<td><code>EPOLLMSG</code></td>
<td>忽略</td>
</tr>
</tbody>
</table>
<p><em>3.6 新版功能:</em> 增加了 <code>EPOLLEXCLUSIVE</code>。仅支持 Linux Kernel 4.5 或更高版本。</p>
<ul>
<li><p><code>epoll.close</code>()</p>
<p>关闭用于控制 epoll 对象的文件描述符。</p>
</li>
<li><p><code>epoll.closed</code></p>
<p>如果 epoll 对象已关闭，则返回 <code>True</code>。</p>
</li>
<li><p><code>epoll.fileno</code>()</p>
<p>返回文件描述符对应的数字，该描述符用于控制 epoll 对象。</p>
</li>
<li><p><code>epoll.fromfd</code>(<em>fd</em>)</p>
<p>根据给定的文件描述符创建 epoll 对象。</p>
</li>
<li><p><code>epoll.register</code>(<em>fd</em>[, <em>eventmask</em>])</p>
<p>在 epoll 对象中注册一个文件描述符。</p>
</li>
<li><p><code>epoll.modify</code>(<em>fd</em>, <em>eventmask</em>)</p>
<p>修改一个已注册的文件描述符。</p>
</li>
<li><p><code>epoll.unregister</code>(<em>fd</em>)</p>
<p>从 epoll 对象中删除一个已注册的文件描述符。</p>
</li>
<li><p><code>epoll.poll</code>(<em>timeout=None</em>, <em>maxevents=-1</em>)</p>
<p>等待事件发生，timeout 是浮点数，单位为秒。<em>在 3.5 版更改:</em> 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p>
</li>
</ul>
<h2 id="Poll-对象"><a href="#Poll-对象" class="headerlink" title="Poll 对象"></a>Poll 对象</h2><p>大多数 Unix 系统支持 <code>poll()</code> 系统调用，为服务器提供了更好的可伸缩性，使服务器可以同时服务于大量客户端。<code>poll()</code> 的伸缩性更好，因为该调用内部仅列出所关注的文件描述符，而 <code>select()</code> 会构造一个 bitmap，在其中将所关注的描述符所对应的 bit 打开，然后重新遍历整个 bitmap。因此 <code>select()</code> 复杂度是 O（最高文件描述符），而 <code>poll()</code> 是 O（文件描述符数量）。</p>
<ul>
<li><p><code>poll.register</code>(<em>fd</em>[, <em>eventmask</em>])</p>
<p>在轮询对象中注册文件描述符。这样，将来调用 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.poll" target="_blank" rel="noopener"><code>poll()</code></a> 方法时将检查文件描述符是否有未处理的 I/O 事件。<em>fd</em> 可以是整数，也可以是带有 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法的对象（该方法返回一个整数）。文件对象已经实现了 <code>fileno()</code>，因此它们也可以用作参数。<em>eventmask</em> 是可选的位掩码，用于指定要检查的事件类型，它可以是常量 <code>POLLIN</code>、<code>POLLPRI</code> 和 <code>POLLOUT</code> 的组合，如下表所述。如果未指定本参数，默认将会检查所有 3 种类型的事件。</p>
<p>| 常数        | 意义                                               |<br>| ———– | ————————————————– |<br>| <code>POLLIN</code>    | 有要读取的数据                                     |<br>| <code>POLLPRI</code>   | 有紧急数据需要读取                                 |<br>| <code>POLLOUT</code>   | 准备输出：写不会阻塞                               |<br>| <code>POLLERR</code>   | 某种错误条件                                       |<br>| <code>POLLHUP</code>   | 挂起                                               |<br>| <code>POLLRDHUP</code> | 流套接字的对侧关闭了连接，或关闭了写入到一半的连接 |<br>| <code>POLLNVAL</code>  | 无效的请求：描述符未打开                           |</p>
<p>注册已注册过的文件描述符不会报错，且等同于只注册一次该描述符。</p>
</li>
<li><p><code>poll.modify</code>(<em>fd</em>, <em>eventmask</em>)</p>
<p>修改一个已注册的文件描述符，等同于 <code>register(fd, eventmask)</code>。尝试修改未注册的文件描述符会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，错误码为 <code>ENOENT</code>。</p>
</li>
<li><p><code>poll.unregister</code>(<em>fd</em>)</p>
<p>删除轮询对象正在跟踪的某个文件描述符。与 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.poll.register" target="_blank" rel="noopener"><code>register()</code></a> 方法类似，<em>fd</em> 可以是整数，也可以是带有 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法的对象（该方法返回一个整数）。尝试删除从未注册过的文件描述符会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 异常。</p>
</li>
<li><p><code>poll.poll</code>([<em>timeout</em>])</p>
<p>轮询已注册的文件描述符的集合，并返回一个列表，列表可能为空，也可能有多个 <code>(fd, event)</code> 二元组，其中包含了要报告事件或错误的描述符。<em>fd</em> 是文件描述符，<em>event</em> 是一个位掩码，表示该描述符所报告的事件 — <code>POLLIN</code> 表示可以读取，<code>POLLOUT</code> 表示该描述符可以写入，依此类推。空列表表示调用超时，没有任何文件描述符报告事件。如果指定了 <em>timeout</em>，它将指定系统等待事件时，等待多长时间后返回（以毫秒为单位）。如果 <em>timeout</em> 为空、负数 或 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>，则本调用将阻塞，直到轮询对象发生事件为止。<em>在 3.5 版更改:</em> 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p>
</li>
</ul>
<h2 id="Kqueue-对象"><a href="#Kqueue-对象" class="headerlink" title="Kqueue 对象"></a>Kqueue 对象</h2><ul>
<li><p><code>kqueue.close</code>()</p>
<p>关闭用于控制 kqueue 对象的文件描述符。</p>
</li>
<li><p><code>kqueue.closed</code></p>
<p>如果 kqueue 对象已关闭，则返回 <code>True</code>。</p>
</li>
<li><p><code>kqueue.fileno</code>()</p>
<p>返回文件描述符对应的数字，该描述符用于控制 epoll 对象。</p>
</li>
<li><p><code>kqueue.fromfd</code>(<em>fd</em>)</p>
<p>根据给定的文件描述符创建 kqueue 对象。</p>
</li>
<li><p><code>kqueue.control</code>(<em>changelist</em>, <em>max_events</em>[, <em>timeout</em>]) → eventlist</p>
<p>Kevent 的低级接口changelist 必须是一个可迭代对象，迭代出 kevent 对象，否则置为 <code>None</code>。max_events 必须是 0 或一个正整数。timeout 单位为秒（一般为浮点数），默认为 <code>None</code>，即永不超时。<em>在 3.5 版更改:</em> 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p>
</li>
</ul>
<h2 id="Kevent-对象"><a href="#Kevent-对象" class="headerlink" title="Kevent 对象"></a>Kevent 对象</h2><p><a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2" target="_blank" rel="noopener">https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2</a></p>
<p><a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2" target="_blank" rel="noopener">https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2</a></p>
<ul>
<li><p><code>kevent.ident</code></p>
<p>用于区分事件的标识值。其解释取决于筛选器，但该值通常是文件描述符。在构造函数中，该标识值可以是整数或带有 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法的对象。kevent 在内部存储整数。</p>
</li>
<li><p><code>kevent.filter</code></p>
<p>内核筛选器的名称。</p>
<p>| 常数               | 意义                                              |<br>| —————— | ————————————————- |<br>| <code>KQ_FILTER_READ</code>   | 获取描述符，并在有数据可读时返回                  |<br>| <code>KQ_FILTER_WRITE</code>  | 获取描述符，并在有数据可写时返回                  |<br>| <code>KQ_FILTER_AIO</code>    | AIO 请求                                          |<br>| <code>KQ_FILTER_VNODE</code>  | 当在 <em>fflag</em> 中监视的一个或多个请求事件发生时返回 |<br>| <code>KQ_FILTER_PROC</code>   | 监视进程ID上的事件                                |<br>| <code>KQ_FILTER_NETDEV</code> | 观察网络设备上的事件[在Mac OS X上不可用]          |<br>| <code>KQ_FILTER_SIGNAL</code> | 每当监视的信号传递到进程时返回                    |<br>| <code>KQ_FILTER_TIMER</code>  | 建立一个任意的计时器                              |</p>
</li>
</ul>
<ul>
<li><p>kevent.flags</p>
<p>筛选器操作。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>常数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>KQ_EV_ADD</code></td>
<td>添加或修改事件</td>
</tr>
<tr>
<td><code>KQ_EV_DELETE</code></td>
<td>从队列中删除事件</td>
</tr>
<tr>
<td><code>KQ_EV_ENABLE</code></td>
<td>Permitscontrol() 返回事件</td>
</tr>
<tr>
<td><code>KQ_EV_DISABLE</code></td>
<td>禁用事件</td>
</tr>
<tr>
<td><code>KQ_EV_ONESHOT</code></td>
<td>在第一次发生后删除事件</td>
</tr>
<tr>
<td><code>KQ_EV_CLEAR</code></td>
<td>检索事件后重置状态</td>
</tr>
<tr>
<td><code>KQ_EV_SYSFLAGS</code></td>
<td>内部事件</td>
</tr>
<tr>
<td><code>KQ_EV_FLAG1</code></td>
<td>内部事件</td>
</tr>
<tr>
<td><code>KQ_EV_EOF</code></td>
<td>筛选特定EOF条件</td>
</tr>
<tr>
<td><code>KQ_EV_ERROR</code></td>
<td>请参阅返回值</td>
</tr>
</tbody>
</table>
<ul>
<li>kevent.fflags</li>
</ul>
<p>筛选特定标志。</p>
<p><code>KQ_FILTER_READ</code> 和 <code>KQ_FILTER_WRITE</code> 筛选标志：</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>KQ_NOTE_LOWAT</code></td>
<td>套接字缓冲区的低水线</td>
</tr>
</tbody>
</table>
<p><code>KQ_FILTER_VNODE</code> 筛选标志：</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>KQ_NOTE_DELETE</code></td>
<td>已调用 <em>unlink()</em></td>
</tr>
<tr>
<td><code>KQ_NOTE_WRITE</code></td>
<td>发生写入</td>
</tr>
<tr>
<td><code>KQ_NOTE_EXTEND</code></td>
<td>文件已扩展</td>
</tr>
<tr>
<td><code>KQ_NOTE_ATTRIB</code></td>
<td>属性已更改</td>
</tr>
<tr>
<td><code>KQ_NOTE_LINK</code></td>
<td>链接计数已更改</td>
</tr>
<tr>
<td><code>KQ_NOTE_RENAME</code></td>
<td>文件已重命名</td>
</tr>
<tr>
<td><code>KQ_NOTE_REVOKE</code></td>
<td>对文件的访问权限已被撤销</td>
</tr>
</tbody>
</table>
<p><code>KQ_FILTER_PROC</code> filter flags:</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>KQ_NOTE_EXIT</code></td>
<td>进程已退出</td>
</tr>
<tr>
<td><code>KQ_NOTE_FORK</code></td>
<td>该进程调用了 <em>fork()</em></td>
</tr>
<tr>
<td><code>KQ_NOTE_EXEC</code></td>
<td>进程已执行新进程</td>
</tr>
<tr>
<td><code>KQ_NOTE_PCTRLMASK</code></td>
<td>内部筛选器标志</td>
</tr>
<tr>
<td><code>KQ_NOTE_PDATAMASK</code></td>
<td>内部筛选器标志</td>
</tr>
<tr>
<td><code>KQ_NOTE_TRACK</code></td>
<td>跨 <em>fork()</em> 执行进程</td>
</tr>
<tr>
<td><code>KQ_NOTE_CHILD</code></td>
<td>在 <em>NOTE_TRACK</em> 的子进程上返回</td>
</tr>
<tr>
<td><code>KQ_NOTE_TRACKERR</code></td>
<td>无法附加到子对象</td>
</tr>
</tbody>
</table>
<p><code>KQ_FILTER_NETDEV</code> 筛选器标志（在 Mac OS X 上不可用）：</p>
<table>
<thead>
<tr>
<th>常数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>KQ_NOTE_LINKUP</code></td>
<td>链接已建立</td>
</tr>
<tr>
<td><code>KQ_NOTE_LINKDOWN</code></td>
<td>链接已断开</td>
</tr>
<tr>
<td><code>KQ_NOTE_LINKINV</code></td>
<td>链接状态无效</td>
</tr>
</tbody>
</table>
<ul>
<li><p><code>kevent.data</code><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.kevent.data" target="_blank" rel="noopener">¶</a></p>
<p>筛选特定数据。</p>
</li>
<li><p><code>kevent.udata</code></p>
<p>用户自定义值。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>select</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library readline</title>
    <url>/2020/03/04/python-standard-library-readline/</url>
    <content><![CDATA[<h1 id="python-标准库-readline"><a href="#python-标准库-readline" class="headerlink" title="python  标准库 readline"></a>python  标准库 readline</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200304_remember_beyond_the_futrue.jpg?raw=true" alt></p>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=539420&auto=0&height=66"></iframe>



<p><a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 模块定义了许多方便从 Python 解释器完成和读取/写入历史文件的函数。 此模块可以直接使用，或通过支持在交互提示符下完成 Python 标识符的 <a href="https://docs.python.org/zh-cn/3.8/library/rlcompleter.html#module-rlcompleter" target="_blank" rel="noopener"><code>rlcompleter</code></a> 模块使用。 使用此模块进行的设置会同时影响解释器的交互提示符以及内置 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#input" target="_blank" rel="noopener"><code>input()</code></a> 函数提供的提示符。</p>
<p>Readline keybindings may be configured via an initialization file, typically <code>.inputrc</code> in your home directory. See <a href="https://tiswww.cwru.edu/php/chet/readline/rluserman.html#SEC9" target="_blank" rel="noopener">Readline Init File</a> in the GNU Readline manual for information about the format and allowable constructs of that file, and the capabilities of the Readline library in general.</p>
<blockquote>
<p>注解:底层的 Readline 库 API 可能使用 <code>libedit</code> 库来实现而不是 GNU readline。 在 macOS 上 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 模块会在运行时检测所使用的是哪个库。</p>
</blockquote>
<p><code>libedit</code> 所用的配置文件与 GNU readline 的不同。 如果你要在程序中载入配置字符串你可以在 <code>readline.__doc__</code> 中检测文本 “libedit” 来区分 GNU readline 和 libedit。</p>
<p>如果你是在 macOS 上使用 <em>editline</em>/<code>libedit</code> readline 模拟，则位于你的主目录中的初始化文件名称为 <code>.editrc</code>。 例如，<code>~/.editrc</code> 中的以下内容将开启 <em>vi</em> 按键绑定以及 TAB 补全:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python:bind -v</span><br><span class="line">python:bind ^I rl_complete</span><br></pre></td></tr></table></figure>
<h2 id="初始化文件"><a href="#初始化文件" class="headerlink" title="初始化文件"></a>初始化文件</h2><p>下列函数与初始化文件和用户配置有关：</p>
<ul>
<li><p><code>readline.parse_and_bind</code>(<em>string</em>)</p>
<p>执行在 <em>string</em> 参数中提供的初始化行。 此函数会调用底层库中的 <code>rl_parse_and_bind()</code>。</p>
</li>
<li><p><code>readline.read_init_file</code>([<em>filename</em>])</p>
<p>执行一个 readline 初始化文件。 默认文件名为最近所使用的文件名。 此函数会调用底层库中的 <code>rl_read_init_file()</code>。</p>
</li>
</ul>
<h2 id="行缓冲区"><a href="#行缓冲区" class="headerlink" title="行缓冲区"></a>行缓冲区</h2><p>下列函数会在行缓冲区上操作。</p>
<ul>
<li><p><code>readline.get_line_buffer</code>()</p>
<p>返回行缓冲区的当前内容 (底层库中的 <code>rl_line_buffer</code>)。</p>
</li>
<li><p><code>readline.insert_text</code>(<em>string</em>)</p>
<p>将文本插入行缓冲区的当前游标位置。 该函数会调用底层库中的 <code>rl_insert_text()</code>，但会忽略其返回值。</p>
</li>
<li><p><code>readline.redisplay</code>()</p>
<p>改变屏幕的显示以反映行缓冲区的当前内容。 该函数会调用底层库中的 <code>rl_redisplay()</code>。</p>
</li>
</ul>
<h2 id="历史文件"><a href="#历史文件" class="headerlink" title="历史文件"></a>历史文件</h2><p>下列函数会在历史文件上操作：</p>
<ul>
<li><p><code>readline.read_history_file</code>([<em>filename</em>])</p>
<p>载入一个 readline 历史文件，并将其添加到历史列表。 默认文件名为 <code>~/.history</code>。 此函数会调用底层库中的 <code>read_history()</code>。</p>
</li>
<li><p><code>readline.write_history_file</code>([<em>filename</em>])</p>
<p>将历史列表保存为 readline 历史文件，覆盖任何现有文件。 默认文件名为 <code>~/.history</code>。 此函数会调用底层库中的 <code>write_history()</code>。</p>
</li>
<li><p><code>readline.append_history_file</code>(<em>nelements</em>[, <em>filename</em>])</p>
<p>将历史列表的最后 <em>nelements</em> 项添加到历史文件。 默认文件名为 <code>~/.history</code>。 文件必须已存在。 此函数会调用底层库中的 <code>append_history()</code>。 此函数仅当 Python 编译包带有支持此功能的库版本时才会存在。<em>3.5 新版功能.</em></p>
</li>
<li><p><code>readline.get_history_length</code>()</p>
</li>
<li><p><code>readline.set_history_length</code>(<em>length</em>)</p>
<p>设置或返回需要保存到历史文件的行数。 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#readline.write_history_file" target="_blank" rel="noopener"><code>write_history_file()</code></a> 函数会通过调用底层库中的 <code>history_truncate_file()</code> 以使用该值来截取历史文件。 负值意味着不限制历史文件的大小。</p>
</li>
</ul>
<h2 id="历史列表"><a href="#历史列表" class="headerlink" title="历史列表"></a>历史列表</h2><p>以下函数会在全局历史列表上操作：</p>
<ul>
<li><p><code>readline.clear_history</code>()</p>
<p>清除当前历史。 此函数会调用底层库的 <code>clear_history()</code>。 此 Python 函数仅当 Python 编译包带有支持此功能的库版本时才会存在。</p>
</li>
<li><p><code>readline.get_current_history_length</code>()</p>
<p>返回历史列表的当前项数。 （此函数不同于 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#readline.get_history_length" target="_blank" rel="noopener"><code>get_history_length()</code></a>，后者是返回将被写入历史文件的最大行数。）</p>
</li>
<li><p><code>readline.get_history_item</code>(<em>index</em>)</p>
<p>返回序号为 <em>index</em> 的历史条目的当前内容。 条目序号从一开始。 此函数会调用底层库中的 <code>history_get()</code>。</p>
</li>
<li><p><code>readline.remove_history_item</code>(<em>pos</em>)</p>
<p>从历史列表中移除指定位置上的历史条目。 条目位置从零开始。 此函数会调用底层库中的 <code>remove_history()</code>。</p>
</li>
<li><p><code>readline.replace_history_item</code>(<em>pos</em>, <em>line</em>)</p>
<p>将指定位置上的历史条目替换为 <em>line</em>。 条目位置从零开始。 此函数会调用底层库中的 <code>replace_history_entry()</code>。</p>
</li>
<li><p><code>readline.add_history</code>(<em>line</em>)</p>
<p>将 <em>line</em> 添加到历史缓冲区，相当于是最近输入的一行。 此函数会调用底层库中的 <code>add_history()</code>。</p>
</li>
<li><p><code>readline.set_auto_history</code>(<em>enabled</em>)</p>
<p>启用或禁用当通过 readline 读取输入时自动调用 <code>add_history()</code>。 <em>enabled</em> 参数应为一个布尔值，当其为真值时启用自动历史，当其为假值时禁用自动历史。<em>3.6 新版功能.**</em>CPython implementation detail:** Auto history is enabled by default, and changes to this do not persist across multiple sessions.</p>
</li>
</ul>
<h2 id="启动钩子"><a href="#启动钩子" class="headerlink" title="启动钩子"></a>启动钩子</h2><ul>
<li><p><code>readline.set_startup_hook</code>([<em>function</em>])</p>
<p>设置或移除底层库的 <code>rl_startup_hook</code> 回调所发起调用的函数。 如果指定了 <em>function</em>，它将被用作新的钩子函数；如果省略或为 <code>None</code>，任何已安装的函数将被移除。 钩子函数将在 readline 打印第一个提示信息之前不带参数地被调用。</p>
</li>
<li><p><code>readline.set_pre_input_hook</code>([<em>function</em>])</p>
<p>设置或移除底层库的 <code>rl_pre_input_hook</code> 回调所发起调用的函数。 如果指定了 <em>function</em>，它将被用作新的钩子函数；如果省略或为 <code>None</code>，任何已安装的函数将被移除。 钩子函数将在打印第一个提示信息之后、readline 开始读取输入字符之前不带参数地被调用。 此函数仅当 Python 编译包带有支持此功能的库版本时才会存在。</p>
</li>
</ul>
<h2 id="Completion"><a href="#Completion" class="headerlink" title="Completion"></a>Completion</h2><p>以下函数与自定义单词补全函数的实现有关。 这通常使用 Tab 键进行操作，能够提示并自动补全正在输入的单词。 默认情况下，Readline 设置为由 <a href="https://docs.python.org/zh-cn/3.8/library/rlcompleter.html#module-rlcompleter" target="_blank" rel="noopener"><code>rlcompleter</code></a> 来补全交互模式解释器的 Python 标识符。 如果 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 模块要配合自定义的补全函数来使用，则需要设置不同的单词分隔符。</p>
<ul>
<li><p><code>readline.set_completer</code>([<em>function</em>])</p>
<p>设置或移除补全函数。 如果指定了 <em>function</em>，它将被用作新的补全函数；如果省略或为 <code>None</code>，任何已安装的补全函数将被移除。 补全函数的调用形式为 <code>function(text, state)</code>，其中 <em>state</em> 为 <code>0</code>, <code>1</code>, <code>2</code>, …, 直至其返回一个非字符串值。 它应当返回下一个以 <em>text</em> 开头的候选补全内容。已安装的补全函数将由传递给底层库中 <code>rl_completion_matches()</code> 的 <em>entry_func</em> 回调函数来发起调用。 <em>text</em> 字符串来自于底层库中 <code>rl_attempted_completion_function</code> 回调函数的第一个形参。</p>
</li>
<li><p><code>readline.get_completer</code>()</p>
<p>获取补全函数，如果没有设置补全函数则返回 <code>None</code>。</p>
</li>
<li><p><code>readline.get_completion_type</code>()</p>
<p>获取正在尝试的补全类型。 此函数会将底层库中的 <code>rl_completion_type</code> 变量作为一个整数返回。</p>
</li>
<li><p><code>readline.get_begidx</code>()</p>
</li>
<li><p><code>readline.get_endidx</code>()</p>
<p>获取补全域的开始和结束序号。 这些序号就是传给底层库中 <code>rl_attempted_completion_function</code> 回调函数的 <em>start</em> 和 <em>end</em> 参数。</p>
</li>
<li><p><code>readline.set_completer_delims</code>(<em>string</em>)</p>
</li>
<li><p><code>readline.get_completer_delims</code>()</p>
<p>设置或获取补全的单词分隔符。 此分隔符确定了要考虑补全的单词的开始和结束位置（补全域）。 这些函数会访问底层库的 <code>rl_completer_word_break_characters</code> 变量。</p>
</li>
<li><p><code>readline.set_completion_display_matches_hook</code>([<em>function</em>])</p>
<p>设置或移除补全显示函数。 如果指定了 <em>function</em>，它将被用作新的补全显示函数；如果省略或为 <code>None</code>，任何已安装的补全显示函数将被移除。 此函数会设置或清除底层库的 <code>rl_completion_display_matches_hook</code> 回调函数。 补全显示函数会在每次需要显示匹配项时以 <code>function(substitution, [matches], longest_match_length)</code> 的形式被调用。</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下示例演示了如何使用 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 模块的历史读取或写入函数来自动加载和保存用户主目录下名为 <code>.python_history</code> 的历史文件。 以下代码通常应当在交互会话期间从用户的 <a href="https://docs.python.org/zh-cn/3.8/using/cmdline.html#envvar-PYTHONSTARTUP" target="_blank" rel="noopener"><code>PYTHONSTARTUP</code></a> 文件自动执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> atexit</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> readline</span><br><span class="line"></span><br><span class="line">histfile = os.path.join(os.path.expanduser(<span class="string">"~"</span>), <span class="string">".python_history"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    readline.read_history_file(histfile)</span><br><span class="line">    <span class="comment"># default history len is -1 (infinite), which may grow unruly</span></span><br><span class="line">    readline.set_history_length(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">atexit.register(readline.write_history_file, histfile)</span><br></pre></td></tr></table></figure>
<p>此代码实际上会在 Python 运行于 <a href="https://docs.python.org/zh-cn/3.8/tutorial/interpreter.html#tut-interactive" target="_blank" rel="noopener">交互模式</a> 时自动运行 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/site.html#rlcompleter-config" target="_blank" rel="noopener">Readline configuration</a>)。</p>
<p>以下示例实现了同样的目标，但是通过只添加新历史的方式来支持并发的交互会话。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> atexit</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> readline</span><br><span class="line">histfile = os.path.join(os.path.expanduser(<span class="string">"~"</span>), <span class="string">".python_history"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    readline.read_history_file(histfile)</span><br><span class="line">    h_len = readline.get_current_history_length()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    open(histfile, <span class="string">'wb'</span>).close()</span><br><span class="line">    h_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(prev_h_len, histfile)</span>:</span></span><br><span class="line">    new_h_len = readline.get_current_history_length()</span><br><span class="line">    readline.set_history_length(<span class="number">1000</span>)</span><br><span class="line">    readline.append_history_file(new_h_len - prev_h_len, histfile)</span><br><span class="line">atexit.register(save, h_len, histfile)</span><br></pre></td></tr></table></figure>
<p>以下示例扩展了 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveConsole" target="_blank" rel="noopener"><code>code.InteractiveConsole</code></a> 类以支持历史保存/恢复。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> atexit</span><br><span class="line"><span class="keyword">import</span> code</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> readline</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HistoryConsole</span><span class="params">(code.InteractiveConsole)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, locals=None, filename=<span class="string">"&lt;console&gt;"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 histfile=os.path.expanduser<span class="params">(<span class="string">"~/.console-history"</span>)</span>)</span>:</span></span><br><span class="line">        code.InteractiveConsole.__init__(self, locals, filename)</span><br><span class="line">        self.init_history(histfile)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_history</span><span class="params">(self, histfile)</span>:</span></span><br><span class="line">        readline.parse_and_bind(<span class="string">"tab: complete"</span>)</span><br><span class="line">        <span class="keyword">if</span> hasattr(readline, <span class="string">"read_history_file"</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                readline.read_history_file(histfile)</span><br><span class="line">            <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            atexit.register(self.save_history, histfile)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_history</span><span class="params">(self, histfile)</span>:</span></span><br><span class="line">        readline.set_history_length(<span class="number">1000</span>)</span><br><span class="line">        readline.write_history_file(histfile)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>readline</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library code</title>
    <url>/2020/03/05/python-standard-library-code/</url>
    <content><![CDATA[<h1 id="python标准库-code"><a href="#python标准库-code" class="headerlink" title="python标准库 code"></a>python标准库 code</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200305longmao.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>龙猫 となりのトトロ (1988)</p>
<p>这可能是宫崎骏众多作品中最温馨而淳朴的片子了。</p>
<p>小时候只记得范晓萱的那首《豆豆龙》。</p>
<p>30年后的很幸运我和孩子一起看了这部片子。</p>
<p>看完了,我热泪盈眶。无法用词语去形容那种纯净的感觉。</p>
<p>回家的路上我问孩子,你看懂了吗？她点了点头。</p>
<p>我也看懂了。</p>
</blockquote>
<p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/code.py" target="_blank" rel="noopener">Lib/code.py</a></p>
<hr>
<p><code>code</code> 模块提供了在 Python 中实现 read-eval-print 循环的功能。它包含两个类和一些快捷功能，可用于构建提供交互式解释器的应用程序。</p>
<ul>
<li><p><em>class</em> <code>code.InteractiveInterpreter</code>(<em>locals=None</em>)</p>
<p>这个类处理解析器和解释器状态（用户命名空间的）；它不处理缓冲器、终端提示区或着输入文件名（文件名总是显示地传递）。可选的 <em>locals</em> 参数指定一个字典，字典里面包含将在此类执行的代码；它默认创建新的字典，其键 <code>&#39;__name__&#39;</code> 设置为 <code>&#39;__console__&#39;</code> ，键 <code>&#39;__doc__&#39;</code> 设置为 <code>None</code> 。</p>
</li>
<li><p><em>class</em> <code>code.InteractiveConsole</code>(<em>locals=None</em>, <em>filename=””</em>)</p>
<p>尽可能模拟交互式 Python 解释器的行为。此类建立在 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter" target="_blank" rel="noopener"><code>InteractiveInterpreter</code></a> 的基础上，使用熟悉的 <code>sys.ps1</code> 和 <code>sys.ps2</code> 作为输入提示符，并有输入缓冲。</p>
</li>
<li><p><code>code.interact</code>(<em>banner=None</em>, <em>readfunc=None</em>, <em>local=None</em>, <em>exitmsg=None</em>)</p>
<p>运行一个 read-eval-print 循环的便捷函数。这会创建一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveConsole" target="_blank" rel="noopener"><code>InteractiveConsole</code></a> 实例。如果提供了 <em>readfunc</em> ，会设置为 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveConsole.raw_input" target="_blank" rel="noopener"><code>InteractiveConsole.raw_input()</code></a> 方法。如果提供了 <em>local</em> ，则将其传递给 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveConsole" target="_blank" rel="noopener"><code>InteractiveConsole</code></a> 的构造函数，以用作解释器循环的默认命名空间。然后，如果提供了 <em>banner</em> 和 <em>exitmsg</em> ，实例的 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.interact" target="_blank" rel="noopener"><code>interact()</code></a> 方法会以此为标题和退出消息。控制台对象在使用后将被丢弃。<em>在 3.6 版更改:</em> 加入 <em>exitmsg</em> 参数。</p>
</li>
<li><p><code>code.compile_command</code>(<em>source</em>, <em>filename=””</em>, <em>symbol=”single”</em>)</p>
<p>这个函数主要用来模拟 Python 解释器的主循环（即 read-eval-print 循环）。难点的部分是当用户输入不完整命令时，判断能否通过之后的输入来完成（要么成为完整的命令，要么语法错误）。该函数 <em>几乎</em> 和实际的解释器主循环的判断是相同的。<em>source</em> 是源字符串； <em>filename</em> 是可选文件名，用来读取源文件，默认为 <code>&#39;&#39;</code> ； <em>symbol</em> 是可选的语法开始符号，应为 <code>&#39;single&#39;</code> （默认）或 <code>&#39;eval&#39;</code> 。如果命令完整且有效则返回一个代码对象 (等价于 <code>compile(source, filename, symbol)</code>)；如果命令不完整则返回 <code>None</code>；如果命令完整但包含语法错误则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a> 而如果命令包含无效字面值则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。</p>
</li>
</ul>
<h2 id="交互解释器对象"><a href="#交互解释器对象" class="headerlink" title="交互解释器对象"></a>交互解释器对象</h2><ul>
<li><p><code>InteractiveInterpreter.runsource</code>(<em>source</em>, <em>filename=””</em>, <em>symbol=”single”</em>)</p>
<p>在解释器中编译并运行一段源码。 所用参数与 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.compile_command" target="_blank" rel="noopener"><code>compile_command()</code></a> 一样；<em>filename</em> 的默认值为 <code>&#39;&#39;</code>，<em>symbol</em> 则为 <code>&#39;single&#39;</code>。 可能发生以下情况之一：</p>
<ul>
<li>输入不正确；<a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.compile_command" target="_blank" rel="noopener"><code>compile_command()</code></a> 引发了一个异常 (<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a>)。 将通过调用 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.showsyntaxerror" target="_blank" rel="noopener"><code>showsyntaxerror()</code></a> 方法打印语法回溯信息。 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.runsource" target="_blank" rel="noopener"><code>runsource()</code></a> 返回 <code>False</code>。</li>
<li>输入不完整，需要更多输入；函数 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.compile_command" target="_blank" rel="noopener"><code>compile_command()</code></a> 返回 <code>None</code> 。方法 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.runsource" target="_blank" rel="noopener"><code>runsource()</code></a> 返回 <code>True</code> 。</li>
<li>输入完整；<a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.compile_command" target="_blank" rel="noopener"><code>compile_command()</code></a> 返回了一个代码对象。 将通过调用 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.runcode" target="_blank" rel="noopener"><code>runcode()</code></a> 执行代码（该方法也会处理运行时异常，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a> 除外）。 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.runsource" target="_blank" rel="noopener"><code>runsource()</code></a> 返回 <code>False</code>。</li>
</ul>
<p>该返回值用于决定使用 <code>sys.ps1</code> 还是 <code>sys.ps2</code> 来作为下一行的输入提示符。</p>
</li>
<li><p><code>InteractiveInterpreter.runcode</code>(<em>code</em>)</p>
<p>执行一个代码对象。当发生异常时，调用 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.showtraceback" target="_blank" rel="noopener"><code>showtraceback()</code></a> 来显示回溯。除 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a> （允许传播）以外的所有异常都会被捕获。有关 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyboardInterrupt" target="_blank" rel="noopener"><code>KeyboardInterrupt</code></a> 的说明，该异常可能发生于此代码的其他位置，并且并不总能被捕获。 调用者应当准备好处理它。</p>
</li>
<li><p><code>InteractiveInterpreter.showsyntaxerror</code>(<em>filename=None</em>)</p>
<p>显示刚发生的语法错误。 这不会显示堆栈回溯因为语法错误并无此种信息。 如果给出了 <em>filename</em>，它会被放入异常来替代 Python 解析器所提供的默认文件名，因为它在从一个字符串读取时总是会使用 <code>&#39;&#39;</code>。 输出将由 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.write" target="_blank" rel="noopener"><code>write()</code></a> 方法来写入。</p>
</li>
<li><p><code>InteractiveInterpreter.showtraceback</code>()</p>
<p>显示刚发生的异常。 我们移除了第一个堆栈条目因为它从属于解释器对象的实现。 输出将由 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.write" target="_blank" rel="noopener"><code>write()</code></a> 方法来写入。<em>在 3.5 版更改:</em> 将显示完整的链式回溯，而不只是主回溯。</p>
</li>
<li><p><code>InteractiveInterpreter.write</code>(<em>data</em>)</p>
<p>将一个字符串写入到标准错误流 (<code>sys.stderr</code>)。 所有派生类都应重载此方法以提供必要的正确输出处理。</p>
</li>
</ul>
<h2 id="交互式控制台对象"><a href="#交互式控制台对象" class="headerlink" title="交互式控制台对象"></a>交互式控制台对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveConsole" target="_blank" rel="noopener"><code>InteractiveConsole</code></a> 类是 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter" target="_blank" rel="noopener"><code>InteractiveInterpreter</code></a> 的子类，因此它提供了解释器对象的所有方法，还有以下的额外方法。</p>
<ul>
<li><p><code>InteractiveConsole.interact</code>(<em>banner=None</em>, <em>exitmsg=None</em>)</p>
<p>近似地模拟交互式 Python 终端。 可选的 <em>banner</em> 参数指定要在第一次交互前打印的条幅；默认情况下会类似于标准 Python 解释器所打印的内容，并附上外加圆括号的终端对象类名（这样就不会与真正的解释器混淆 —— 因为确实太像了！）</p>
<p>可选的 <em>exitmsg</em> 参数指定要在退出时打印的退出消息。 传入空字符串可以屏蔽退出消息。 如果 <em>exitmsg</em> 未给出或为 <code>None</code>，则将打印默认消息。</p>
<p><em>在 3.4 版更改:</em> 要禁止打印任何条幅消息，请传递一个空字符串。</p>
<p><em>在 3.6 版更改:</em> 退出时打印退出消息。</p>
</li>
<li><p><code>InteractiveConsole.push</code>(<em>line</em>)</p>
<p>将一行源文本推入解释器。 行内容不应带有末尾换行符；它可以有内部换行符。 行内容会被添加到一个缓冲区并且会调用解释器的 <code>runsource()</code> 方法，附带缓冲区内容的拼接结果作为源文本。 如果显示命令已执行或不合法，缓冲区将被重置；否则，则命令尚未结束，缓冲区将在添加行后保持原样。 如果要求更多输入则返回值为 <code>True</code>，如果行已按某种方式被处理则返回值为 <code>False</code> (这与 <code>runsource()</code> 相同)。</p>
</li>
<li><p><code>InteractiveConsole.resetbuffer</code>()</p>
<p>从输入缓冲区中删除所有未处理的内容。</p>
</li>
<li><p><code>InteractiveConsole.raw_input</code>(<em>prompt=””</em>)</p>
<p>输出提示并读取一行。返回的行不包含末尾的换行符。当用户输入 EOF 键序列时，会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EOFError" target="_blank" rel="noopener"><code>EOFError</code></a> 异常。默认实现是从 <code>sys.stdin</code> 读取；子类可以用其他实现代替。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library sched</title>
    <url>/2020/03/07/python-standard-library-sched/</url>
    <content><![CDATA[<h1 id="python-标准库-sched-同步队列类"><a href="#python-标准库-sched-同步队列类" class="headerlink" title="python 标准库 sched 同步队列类"></a>python 标准库 sched 同步队列类</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200307_westworld2.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>什么是人工智能？难道我们其实就生活在一个被定制了的剧场中？</p>
<p>HBO 剧集 &lt;西部世界&gt; 第二季 强势回归,也许你可以找到答案。</p>
</blockquote>
<p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/sched.py" target="_blank" rel="noopener">Lib/sched.py</a></p>
<hr>
<p><a href="https://docs.python.org/zh-cn/3.8/library/sched.html#module-sched" target="_blank" rel="noopener"><code>sched</code></a> 模块定义了一个实现通用事件调度程序的类：</p>
<ul>
<li><p><em>class</em> <code>sched.scheduler</code>(<em>timefunc=time.monotonic</em>, <em>delayfunc=time.sleep</em>)</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/sched.html#sched.scheduler" target="_blank" rel="noopener"><code>scheduler</code></a> 类定义了一个调度事件的通用接口。 它需要两个函数来实际处理“外部世界” —— <em>timefunc</em> 应当不带参数地调用，并返回一个数字（“时间”，可以为任意单位）。 <em>delayfunc</em> 函数应当带一个参数调用，与 <em>timefunc</em> 的输出相兼容，并且应当延迟其所指定的时间单位。 每个事件运行后还将调用 <em>delayfunc</em> 并传入参数 <code>0</code> 以允许其他线程有机会在多线程应用中运行。<em>在 3.3 版更改:</em> <em>timefunc</em> 和 <em>delayfunc</em> 参数是可选的。<em>在 3.3 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/sched.html#sched.scheduler" target="_blank" rel="noopener"><code>scheduler</code></a> 类可以安全的在多线程环境中使用。</p>
</li>
</ul>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sched, time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = sched.scheduler(time.time, time.sleep)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_time</span><span class="params">(a=<span class="string">'default'</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"From print_time"</span>, time.time(), a)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_some_times</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(time.time())</span><br><span class="line"><span class="meta">... </span>    s.enter(<span class="number">10</span>, <span class="number">1</span>, print_time)</span><br><span class="line"><span class="meta">... </span>    s.enter(<span class="number">5</span>, <span class="number">2</span>, print_time, argument=(<span class="string">'positional'</span>,))</span><br><span class="line"><span class="meta">... </span>    s.enter(<span class="number">5</span>, <span class="number">1</span>, print_time, kwargs=&#123;<span class="string">'a'</span>: <span class="string">'keyword'</span>&#125;)</span><br><span class="line"><span class="meta">... </span>    s.run()</span><br><span class="line"><span class="meta">... </span>    print(time.time())</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_some_times()</span><br><span class="line"><span class="number">930343690.257</span></span><br><span class="line">From print_time <span class="number">930343695.274</span> positional</span><br><span class="line">From print_time <span class="number">930343695.275</span> keyword</span><br><span class="line">From print_time <span class="number">930343700.273</span> default</span><br><span class="line"><span class="number">930343700.276</span></span><br></pre></td></tr></table></figure>
<h2 id="调度器对象"><a href="#调度器对象" class="headerlink" title="调度器对象"></a>调度器对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/sched.html#sched.scheduler" target="_blank" rel="noopener"><code>scheduler</code></a> 实例拥有以下方法和属性：</p>
<ul>
<li><p><code>scheduler.enterabs</code>(<em>time</em>, <em>priority</em>, <em>action</em>, <em>argument=()</em>, <em>kwargs={}</em>)</p>
<p>安排一个新事件。 <em>time</em> 参数应该有一个数字类型兼容的返回值，与传递给构造函数的 <em>timefunc</em> 函数的返回值兼容。 计划在相同 <em>time</em> 的事件将按其 <em>priority</em> 的顺序执行。 数字越小表示优先级越高。执行事件意为执行 <code>action(*argument, **kwargs)</code>。 <em>argument</em> 是包含有 <em>action</em> 的位置参数的序列。 <em>kwargs</em> 是包含 <em>action</em> 的关键字参数的字典。返回值是一个事件，可用于以后取消事件（ 参见 <a href="https://docs.python.org/zh-cn/3.8/library/sched.html#sched.scheduler.cancel" target="_blank" rel="noopener"><code>cancel()</code></a> ）。<em>在 3.3 版更改:</em> <em>argument</em> 参数是可选的。<em>在 3.3 版更改:</em> 添加了 <em>kwargs</em> 形参。</p>
</li>
<li><p><code>scheduler.enter</code>(<em>delay</em>, <em>priority</em>, <em>action</em>, <em>argument=()</em>, <em>kwargs={}</em>)</p>
<p>安排延后 <em>delay</em> 时间单位的事件。 除了相对时间，其他参数、效果和返回值与 <a href="https://docs.python.org/zh-cn/3.8/library/sched.html#sched.scheduler.enterabs" target="_blank" rel="noopener"><code>enterabs()</code></a> 的相同。<em>在 3.3 版更改:</em> <em>argument</em> 参数是可选的。<em>在 3.3 版更改:</em> 添加了 <em>kwargs</em> 形参。</p>
</li>
<li><p><code>scheduler.cancel</code>(<em>event</em>)</p>
<p>从队列中删除事件。 如果 <em>event</em> 不是当前队列中的事件，则此方法将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。</p>
</li>
<li><p><code>scheduler.empty</code>()</p>
<p>如果事件队列为空则返回 <code>True</code>。</p>
</li>
<li><p><code>scheduler.run</code>(<em>blocking=True</em>)</p>
<p>运行所有预定事件。 此方法将等待（使用传递给构造函数的 <code>delayfunc()</code> 函数）进行下一个事件，然后执行它，依此类推，直到没有更多的计划事件。如果 <em>blocking</em> 为false，则执行由于最快到期（如果有）的预定事件，然后在调度程序中返回下一个预定调用的截止时间（如果有）。<em>action</em> 或 <em>delayfunc</em> 都可以引发异常。 在任何一种情况下，调度程序都将保持一致状态并传播异常。 如果 <em>action</em> 引发异常，则在将来调用 <a href="https://docs.python.org/zh-cn/3.8/library/sched.html#sched.scheduler.run" target="_blank" rel="noopener"><code>run()</code></a> 时不会尝试该事件。如果一系列事件的运行时间比下一个事件之前的可用时间长，那么调度程序将完全落后。 不会发生任何事件；调用代码负责取消不再相关的事件。<em>在 3.3 版更改:</em> 添加了 <em>blocking</em> 形参。</p>
</li>
<li><p><code>scheduler.queue</code></p>
<p>只读属性按照将要运行的顺序返回即将发生的事件列表。 每个事件都显示为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-named-tuple" target="_blank" rel="noopener">named tuple</a> ，包含以下字段：time、priority、action、argument、kwargs。</p>
</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>基本用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sched_basic.py</span></span><br><span class="line"><span class="keyword">import</span> sched</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">scheduler = sched.scheduler(time.time, time.sleep)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_event</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'EVENT:'</span>, time.time(), name)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'START:'</span>, time.time())</span><br><span class="line">scheduler.enter(<span class="number">2</span>, <span class="number">1</span>, print_event, (<span class="string">'first'</span>,))</span><br><span class="line">scheduler.enter(<span class="number">3</span>, <span class="number">1</span>, print_event, (<span class="string">'second'</span>,))</span><br><span class="line"></span><br><span class="line">scheduler.run()</span><br></pre></td></tr></table></figure>
<p>overloop</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sched</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">scheduler = sched.scheduler(time.time, time.sleep)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_event</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'BEGIN EVENT :'</span>, time.time(), name)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'FINISH EVENT:'</span>, time.time(), name)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'START:'</span>, time.time())</span><br><span class="line">scheduler.enter(<span class="number">2</span>, <span class="number">1</span>, long_event, (<span class="string">'first'</span>,))</span><br><span class="line">scheduler.enter(<span class="number">3</span>, <span class="number">1</span>, long_event, (<span class="string">'second'</span>,))</span><br><span class="line"></span><br><span class="line">scheduler.run()</span><br></pre></td></tr></table></figure>
<p>cancel_event</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sched</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">scheduler = sched.scheduler(time.time, time.sleep)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up a global to be modified by the threads</span></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_counter</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    print(<span class="string">'EVENT:'</span>, time.time(), name)</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'NOW:'</span>, counter)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'START:'</span>, time.time())</span><br><span class="line">e1 = scheduler.enter(<span class="number">2</span>, <span class="number">1</span>, increment_counter, (<span class="string">'E1'</span>,))</span><br><span class="line">e2 = scheduler.enter(<span class="number">3</span>, <span class="number">1</span>, increment_counter, (<span class="string">'E2'</span>,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start a thread to run the events</span></span><br><span class="line">t = threading.Thread(target=scheduler.run)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Back in the main thread, cancel the first scheduled event.</span></span><br><span class="line">scheduler.cancel(e1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for the scheduler to finish running in the thread</span></span><br><span class="line">t.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'FINAL:'</span>, counter)</span><br></pre></td></tr></table></figure>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://pymotw.com/3/sched/" target="_blank" rel="noopener">python标准库</a></p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>sched</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library futures</title>
    <url>/2020/03/06/python-standard-library-futures/</url>
    <content><![CDATA[<h1 id="python-标准库-Futures"><a href="#python-标准库-Futures" class="headerlink" title="python 标准库 Futures"></a>python 标准库 Futures</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200306_picard.webp?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>I could either watch it pappen,or be part of it！</p>
<p>孤独是困苦的；但可不要变得庸俗；因为这样，你就会发现到处都是一片沙漠。 </p>
<p>​                                                                              —叔本华 《要么庸俗，要么孤独》</p>
</blockquote>
<p>这是模块<code>asyncio</code>的一部分。</p>
<p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/asyncio/futures.py" target="_blank" rel="noopener">Lib/asyncio/futures.py</a>, <a href="https://github.com/python/cpython/tree/3.8/Lib/asyncio/base_futures.py" target="_blank" rel="noopener">Lib/asyncio/base_futures.py</a></p>
<hr>
<p><em>Future</em> 对象用来链接 <strong>底层回调式代码</strong> 和高层异步/等待式代码。</p>
<h2 id="Future-函数"><a href="#Future-函数" class="headerlink" title="Future 函数"></a>Future 函数</h2><ul>
<li><p><code>asyncio.isfuture</code>(<em>obj</em>)</p>
<p>如果 <em>obj</em> 为下面任意对象，返回 <code>True</code>：一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>asyncio.Future</code></a> 类的实例，一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>asyncio.Task</code></a> 类的实例，带有 <code>_asyncio_future_blocking</code> 属性的类似 Future 的对象。<em>3.5 新版功能.</em></p>
</li>
<li><p><code>asyncio.ensure_future</code>(<em>obj</em>, <em>**, </em>loop=None*)</p>
<p>返回：<em>obj</em> 参数会是保持原样，如果 <em>obj</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 或 类似 Future 的对象( <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.isfuture" target="_blank" rel="noopener"><code>isfuture()</code></a> 用于测试。)封装了 <em>obj</em> 的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 对象，如果 <em>obj</em> 是一个协程 (使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.iscoroutine" target="_blank" rel="noopener"><code>iscoroutine()</code></a> 进行检测)；在此情况下该协程将通过 <code>ensure_future()</code> 加入执行计划。等待 <em>obj</em> 的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 对象，如果 <em>obj</em> 是一个可等待对象( <a href="https://docs.python.org/zh-cn/3.8/library/inspect.html#inspect.isawaitable" target="_blank" rel="noopener"><code>inspect.isawaitable()</code></a> 用于测试)如果 <em>obj</em> 不是上述对象会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 异常。重要 查看 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>create_task()</code></a> 函数，它是创建新任务的首选途径。<em>在 3.5.1 版更改:</em> 这个函数接受任意 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a> 对象。</p>
</li>
<li><p><code>asyncio.wrap_future</code>(<em>future</em>, <em>**, </em>loop=None*)</p>
<p>将一个 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>concurrent.futures.Future</code></a> 对象封装到 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>asyncio.Future</code></a> 对象中。</p>
</li>
</ul>
<h2 id="Future-对象"><a href="#Future-对象" class="headerlink" title="Future 对象"></a>Future 对象</h2><ul>
<li><p><em>class</em> <code>asyncio.Future</code>(<em>**, </em>loop=None*)</p>
<p>一个 Future 代表一个异步运算的最终结果。线程不安全。</p>
<p>Future 是一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a> 对象。协程可以等待 Future 对象直到它们有结果或异常集合或被取消。</p>
<p>通常 Future 用于支持底层回调式代码(例如在协议实现中使用asyncio <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-protocol.html#asyncio-transports-protocols" target="_blank" rel="noopener">transports</a>) 与高层异步/等待式代码交互。</p>
<p>经验告诉我们永远不要面向用户的接口暴露 Future 对象，同时建议使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.loop.create_future" target="_blank" rel="noopener"><code>loop.create_future()</code></a> 来创建 Future 对象。这种方法可以让 Future 对象使用其它的事件循环实现，它可以注入自己的优化实现。</p>
<p><em>在 3.7 版更改:</em> 加入对 <a href="https://docs.python.org/zh-cn/3.8/library/contextvars.html#module-contextvars" target="_blank" rel="noopener"><code>contextvars</code></a> 模块的支持。</p>
<ul>
<li><p><code>result</code>()</p>
<p>返回 Future 的结果。如果 Future 状态为 <em>完成</em> ，并由 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_result" target="_blank" rel="noopener"><code>set_result()</code></a> 方法设置一个结果，则返回这个结果。如果 Future 状态为 <em>完成</em> ，并由 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_exception" target="_blank" rel="noopener"><code>set_exception()</code></a> 方法设置一个异常，那么这个方法会引发异常。如果 Future 已 <em>取消</em>，方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。如果 Future 的结果还不可用，此方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 异常。</p>
</li>
<li><p><code>set_result</code>(<em>result</em>)</p>
<p>将 Future 标记为 <em>完成</em> 并设置结果。如果 Future 已经 <em>完成</em> 则抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 错误。</p>
</li>
<li><p><code>set_exception</code>(<em>exception</em>)</p>
<p>将 Future 标记为 <em>完成</em> 并设置一个异常。如果 Future 已经 <em>完成</em> 则抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 错误。</p>
</li>
<li><p><code>done</code>()</p>
<p>如果 Future 为已 <em>完成</em> 则返回 <code>True</code> 。如果 Future 为 <em>取消</em> 或调用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_result" target="_blank" rel="noopener"><code>set_result()</code></a> 设置了结果或调用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_exception" target="_blank" rel="noopener"><code>set_exception()</code></a> 设置了异常，那么它就是 <em>完成</em> 。</p>
</li>
<li><p><code>cancelled</code>()</p>
<p>如果 Future 已 <em>取消</em> 则返回 <code>True</code>这个方法通常在设置结果或异常前用来检查 Future 是否已 <em>取消</em> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> fut.cancelled():</span><br><span class="line">    fut.set_result(<span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>add_done_callback</code>(<em>callback</em>, <em>**, </em>context=None*)</p>
<p>添加一个在 Future <em>完成</em> 时运行的回调函数。</p>
<p> 调用 <em>callback</em> 时，Future 对象是它的唯一参数。</p>
<p> 调用这个方法时 Future 已经 <em>完成</em> , 回调函数已被 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.loop.call_soon" target="_blank" rel="noopener"><code>loop.call_soon()</code></a> 调度。</p>
<p> 可选键值类的参数 <em>context</em> 允许 <em>callback</em> 运行在一个指定的自定义 <a href="https://docs.python.org/zh-cn/3.8/library/contextvars.html#contextvars.Context" target="_blank" rel="noopener"><code>contextvars.Context</code></a> 对象中。如果没有提供 <em>context</em> ，则使用当前上下文。</p>
<p> 可以用 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>functools.partial()</code></a> 给回调函数传递参数，例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Call 'print("Future:", fut)' when "fut" is done.</span></span><br><span class="line">fut.add_done_callback(</span><br><span class="line">    functools.partial(<span class="keyword">print</span>, <span class="string">"Future:"</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>*在 3.7 版更改:* 加入键值类形参 *context*。请参阅 [**PEP 567**](https://www.python.org/dev/peps/pep-0567) 查看更多细节。 
</code></pre><ul>
<li><p><code>remove_done_callback</code>(<em>callback</em>)</p>
<p>从回调列表中移除 <em>callback</em> 。返回被移除的回调函数的数量，通常为1，除非一个回调函数被添加多次。</p>
</li>
<li><p><code>cancel</code>()</p>
<p>取消 Future 并调度回调函数。如果 Future 已经 <em>完成</em> 或 <em>取消</em> ，返回 <code>False</code> 。否则将 Future 状态改为 <em>取消</em> 并在调度回调函数后返回 <code>True</code> 。</p>
</li>
<li><p><code>exception</code>()</p>
<p>返回 Future 已设置的异常。只有 Future 在 <em>完成</em> 时才返回异常（或者 <code>None</code> ，如果没有设置异常）。如果 Future 已 <em>取消</em>，方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。如果 Future 还没 <em>完成</em> ，这个方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 异常。</p>
</li>
<li><p><code>get_loop</code>()</p>
<p>返回 Future 对象已绑定的事件循环。<em>3.7 新版功能.</em></p>
<p> 这个例子创建一个 Future 对象，创建和调度一个异步任务去设置 Future 结果，然后等待其结果: </p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">set_after</span><span class="params">(fut, delay, value)</span>:</span></span><br><span class="line">    <span class="comment"># Sleep for *delay* seconds.</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set *value* as a result of *fut* Future.</span></span><br><span class="line">    fut.set_result(value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Get the current event loop.</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a new Future object.</span></span><br><span class="line">    fut = loop.create_future()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run "set_after()" coroutine in a parallel Task.</span></span><br><span class="line">    <span class="comment"># We are using the low-level "loop.create_task()" API here because</span></span><br><span class="line">    <span class="comment"># we already have a reference to the event loop at hand.</span></span><br><span class="line">    <span class="comment"># Otherwise we could have just used "asyncio.create_task()".</span></span><br><span class="line">    loop.create_task(</span><br><span class="line">        set_after(fut, <span class="number">1</span>, <span class="string">'... world'</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'hello ...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait until *fut* has a result (1 second) and print it.</span></span><br><span class="line">    print(<span class="keyword">await</span> fut)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意</strong>: </p>
<p>该 Future 对象是为了模仿 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>concurrent.futures.Future</code></a> 类。主要差异包含：</p>
<ul>
<li>与 asyncio 的 Future 不同，<a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>concurrent.futures.Future</code></a> 实例不是可等待对象。</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.result" target="_blank" rel="noopener"><code>asyncio.Future.result()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.exception" target="_blank" rel="noopener"><code>asyncio.Future.exception()</code></a> 不接受 <em>timeout</em> 参数。</li>
<li>Future 没有 <em>完成</em> 时 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.result" target="_blank" rel="noopener"><code>asyncio.Future.result()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.exception" target="_blank" rel="noopener"><code>asyncio.Future.exception()</code></a> 抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 异常。</li>
<li>使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.add_done_callback" target="_blank" rel="noopener"><code>asyncio.Future.add_done_callback()</code></a> 注册的回调函数不会立即调用，而是被 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.loop.call_soon" target="_blank" rel="noopener"><code>loop.call_soon()</code></a> 调度。</li>
<li>asyncio Future 不能兼容 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.wait" target="_blank" rel="noopener"><code>concurrent.futures.wait()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.as_completed" target="_blank" rel="noopener"><code>concurrent.futures.as_completed()</code></a> 函数。</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standar_library</tag>
        <tag>futures</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library XML</title>
    <url>/2020/03/10/python-standard-library-XML/</url>
    <content><![CDATA[<h1 id="python-标准库-XML-处理模块-概述"><a href="#python-标准库-XML-处理模块-概述" class="headerlink" title="python 标准库 XML 处理模块 (概述)"></a>python 标准库 XML 处理模块 (概述)</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200310_huangshi.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>黄石国家公园（<strong>Yellowstone National Park</strong>）：简称黄石公园，由<a href="https://baike.baidu.com/item/美国国家公园管理局" target="_blank" rel="noopener">美国国家公园管理局</a>负责管理。1872年3月1日它被正式命名为保护野生动物和自然资源的国家公园，于1978年被列入《<a href="https://baike.baidu.com/item/世界遗产名录/6174540" target="_blank" rel="noopener">世界遗产名录</a>》的<a href="https://baike.baidu.com/item/世界自然遗产/6505343" target="_blank" rel="noopener">世界自然遗产</a>。这是世界上第一个<a href="https://baike.baidu.com/item/国家公园/11086" target="_blank" rel="noopener">国家公园</a>。</p>
<p>黄石国家公园占地面积约为898317公顷，主要位于美国<a href="https://baike.baidu.com/item/怀俄明州" target="_blank" rel="noopener">怀俄明州</a>，部分位于<a href="https://baike.baidu.com/item/蒙大拿州" target="_blank" rel="noopener">蒙大拿州</a>和<a href="https://baike.baidu.com/item/爱达荷州" target="_blank" rel="noopener">爱达荷州</a>。黄石公园分五个区：西北的<a href="https://baike.baidu.com/item/猛犸象温泉" target="_blank" rel="noopener">猛犸象温泉</a>区以石灰石台阶为主，故也称热台阶区；东北为罗斯福区，仍保留着老西部景观；中间为峡谷区，可观赏<a href="https://baike.baidu.com/item/黄石大峡谷" target="_blank" rel="noopener">黄石大峡谷</a>和瀑布；东南为<a href="https://baike.baidu.com/item/黄石湖区" target="_blank" rel="noopener">黄石湖区</a>，主要是湖光山色；西及西南为间歇喷泉区，遍布<a href="https://baike.baidu.com/item/间歇泉" target="_blank" rel="noopener">间歇泉</a>、<a href="https://baike.baidu.com/item/温泉" target="_blank" rel="noopener">温泉</a>、蒸气池、热水潭、<a href="https://baike.baidu.com/item/泥地" target="_blank" rel="noopener">泥地</a>和喷气孔。园内设有历史古迹博物馆。</p>
</blockquote>
<p> <strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/xml/" target="_blank" rel="noopener">Lib/xml/</a> </p>
<p>用于处理XML的Python接口分组在 <code>xml</code> 包中。</p>
<blockquote>
<p>警告:</p>
<p>XML 模块对于错误或恶意构造的数据是不安全的。 如果需要解析不受信任或未经身份验证的数据，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/xml.html#xml-vulnerabilities" target="_blank" rel="noopener">XML 漏洞</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/xml.html#defused-packages" target="_blank" rel="noopener">defusedxml 和 defusedexpat 软件包</a> 部分。</p>
</blockquote>
<p>值得注意的是 <a href="https://docs.python.org/zh-cn/3.8/library/xml.html#module-xml" target="_blank" rel="noopener"><code>xml</code></a> 包中的模块要求至少有一个 SAX 兼容的 XML 解析器可用。在 Pythonm中包含 Expat 解析器，因此 <a href="https://docs.python.org/zh-cn/3.8/library/pyexpat.html#module-xml.parsers.expat" target="_blank" rel="noopener"><code>xml.parsers.expat</code></a> 模块将始终可用。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.html#module-xml.dom" target="_blank" rel="noopener"><code>xml.dom</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/xml.sax.html#module-xml.sax" target="_blank" rel="noopener"><code>xml.sax</code></a> 包的文档是 DOM 和 SAX 接口的 Python 绑定的定义。</p>
<p>XML 处理子模块包括:</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/xml.etree.elementtree.html#module-xml.etree.ElementTree" target="_blank" rel="noopener"><code>xml.etree.ElementTree</code></a>： ElementTree API，一个简单而轻量级的XML处理器</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.html#module-xml.dom" target="_blank" rel="noopener"><code>xml.dom</code></a>：DOM API 定义</p>
</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.minidom.html#module-xml.dom.minidom" target="_blank" rel="noopener"><code>xml.dom.minidom</code></a>：最小的 DOM 实现</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.pulldom.html#module-xml.dom.pulldom" target="_blank" rel="noopener"><code>xml.dom.pulldom</code></a>：支持构建部分 DOM 树</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/xml.sax.html#module-xml.sax" target="_blank" rel="noopener"><code>xml.sax</code></a>：SAX2 基类和便利函数</p>
</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/pyexpat.html#module-xml.parsers.expat" target="_blank" rel="noopener"><code>xml.parsers.expat</code></a>：Expat解析器绑定</li>
</ul>
<h2 id="XML-漏洞"><a href="#XML-漏洞" class="headerlink" title="XML 漏洞"></a>XML 漏洞</h2><p>XML 处理模块对于恶意构造的数据是不安全的。 攻击者可能滥用 XML 功能来执行拒绝服务攻击、访问本地文件、生成与其它计算机的网络连接或绕过防火墙。</p>
<p>下表概述了已知的攻击以及各种模块是否容易受到攻击。</p>
<table>
<thead>
<tr>
<th style="text-align:left">种类</th>
<th style="text-align:left">sax</th>
<th style="text-align:left">etree</th>
<th style="text-align:left">minidom</th>
<th style="text-align:left">pulldom</th>
<th style="text-align:left">xmlrpc</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">billion laughs</td>
<td style="text-align:left"><strong>易受攻击</strong></td>
<td style="text-align:left"><strong>易受攻击</strong></td>
<td style="text-align:left"><strong>易受攻击</strong></td>
<td style="text-align:left"><strong>易受攻击</strong></td>
<td style="text-align:left"><strong>易受攻击</strong></td>
</tr>
<tr>
<td style="text-align:left">quadratic blowup</td>
<td style="text-align:left"><strong>易受攻击</strong></td>
<td style="text-align:left"><strong>易受攻击</strong></td>
<td style="text-align:left"><strong>易受攻击</strong></td>
<td style="text-align:left"><strong>易受攻击</strong></td>
<td style="text-align:left"><strong>易受攻击</strong></td>
</tr>
<tr>
<td style="text-align:left">external entity expansion</td>
<td style="text-align:left">安全 (4)</td>
<td style="text-align:left">安全 (1)</td>
<td style="text-align:left">安全 (2)</td>
<td style="text-align:left">安全 (4)</td>
<td style="text-align:left">安全 (3)</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Document_type_definition" target="_blank" rel="noopener">DTD</a> retrieval</td>
<td style="text-align:left">安全 (4)</td>
<td style="text-align:left">安全</td>
<td style="text-align:left">安全</td>
<td style="text-align:left">安全 (4)</td>
<td style="text-align:left">安全</td>
</tr>
<tr>
<td style="text-align:left">decompression bomb</td>
<td style="text-align:left">安全</td>
<td style="text-align:left">安全</td>
<td style="text-align:left">安全</td>
<td style="text-align:left">安全</td>
<td style="text-align:left"><strong>易受攻击</strong></td>
</tr>
</tbody>
</table>
<ol>
<li><a href="https://docs.python.org/zh-cn/3.8/library/xml.etree.elementtree.html#module-xml.etree.ElementTree" target="_blank" rel="noopener"><code>xml.etree.ElementTree</code></a> 不会扩展外部实体并在实体发生时引发 <code>ParserError</code>。</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.minidom.html#module-xml.dom.minidom" target="_blank" rel="noopener"><code>xml.dom.minidom</code></a> 不会扩展外部实体，只是简单地返回未扩展的实体。</li>
<li><code>xmlrpclib</code> 不扩展外部实体并省略它们。</li>
<li>从 Python 3.7.1 开始，默认情况下不再处理外部通用实体。</li>
</ol>
<ul>
<li><p>billion laughs / exponential entity expansion （狂笑/递归实体扩展）</p>
<p><a href="https://en.wikipedia.org/wiki/Billion_laughs" target="_blank" rel="noopener">Billion Laughs</a> 攻击 – 也称为递归实体扩展 – 使用多级嵌套实体。 每个实体多次引用另一个实体，最终实体定义包含一个小字符串。 指数级扩展导致几千 GB 的文本，并消耗大量内存和 CPU 时间。</p>
</li>
<li><p>quadratic blowup entity expansion（二次爆炸实体扩展）</p>
<p>二次爆炸攻击类似于 <a href="https://en.wikipedia.org/wiki/Billion_laughs" target="_blank" rel="noopener">Billion Laughs</a> 攻击，它也滥用实体扩展。 它不是嵌套实体，而是一遍又一遍地重复一个具有几千个字符的大型实体。攻击不如递归情况有效，但它避免触发禁止深度嵌套实体的解析器对策。</p>
</li>
<li><p>external entity expansion</p>
<p>实体声明可以包含的不仅仅是替换文本。 它们还可以指向外部资源或本地文件。 XML 解析器访问资源并将内容嵌入到 XML 文档中。</p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Document_type_definition" target="_blank" rel="noopener">DTD</a> retrieval</p>
<p>Python 的一些 XML 库 <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.pulldom.html#module-xml.dom.pulldom" target="_blank" rel="noopener"><code>xml.dom.pulldom</code></a> 从远程或本地位置检索文档类型定义。 该功能与外部实体扩展问题具有相似的含义。</p>
</li>
<li><p>decompression bomb</p>
<p>Decompression bombs（解压炸弹，又名 <a href="https://en.wikipedia.org/wiki/Zip_bomb" target="_blank" rel="noopener">ZIP bomb</a>）适用于所有可以解析压缩 XML 流（例如 gzip 压缩的 HTTP 流或 LZMA 压缩的文件）的 XML 库。 对于攻击者来说，它可以将传输的数据量减少三个量级或更多。</p>
</li>
</ul>
<p>PyPI上 <a href="https://pypi.org/project/defusedxml/" target="_blank" rel="noopener">defusedxml</a> 的文档包含有关所有已知攻击向量的更多信息以及示例和参考。</p>
<h2 id="defusedxml-和-defusedexpat-软件包"><a href="#defusedxml-和-defusedexpat-软件包" class="headerlink" title="defusedxml 和 defusedexpat 软件包"></a><code>defusedxml</code> 和 <code>defusedexpat</code> 软件包</h2><p><a href="https://pypi.org/project/defusedxml/" target="_blank" rel="noopener">defusedxml</a> 是一个纯 Python 软件包，它修改了所有标准库 XML 解析器的子类，可以防止任何潜在的恶意操作。 对于解析不受信任的XML数据的任何服务器代码，建议使用此程序包。 该软件包还提供了有关更多 XML 漏洞（如 XPath 注入）的示例漏洞和扩展文档。</p>
<p><a href="https://pypi.org/project/defusedexpat/" target="_blank" rel="noopener">defusedexpat</a> 提供了一个修改过的 libexpat 和一个打过补丁的 <code>pyexpat</code> 模块，它有针对实体扩展DoS攻击的对策。 <code>defusedexpat</code> 模块仍然允许合理且可配置的实体扩展量。 这些修改可能包含在 Python 的某些未来版本中，但不会包含在 Python 的任何修复版本中，因为它们会破坏向后兼容性。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library argparse 2</title>
    <url>/2020/03/09/python-standard-library-argparse-2/</url>
    <content><![CDATA[<h1 id="python-标准库-argparse-续"><a href="#python-标准库-argparse-续" class="headerlink" title="python 标准库 argparse 续"></a>python 标准库 argparse 续</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200310_angrybirds.jpg?raw=true" alt></p>
<a id="more"></a>
<p>继续学习 argparse模块</p>
<h2 id="add-arguments-方法"><a href="#add-arguments-方法" class="headerlink" title="add_arguments 方法"></a>add_arguments 方法</h2><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p><code>help</code>参数主要用于参数的提示信息。 当使用 <code>-h</code> 或者 <code>--help</code> 命令行参数时将会显示下面参数的提示信息.例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&apos;frobble&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;, action=&apos;store_true&apos;,</span><br><span class="line">...                     help=&apos;foo the bars before frobbling&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;bar&apos;, nargs=&apos;+&apos;,</span><br><span class="line">...                     help=&apos;one of the bars to be frobbled&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&apos;-h&apos;])</span><br><span class="line">usage: frobble [-h] [--foo] bar [bar ...]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar     one of the bars to be frobbled</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br><span class="line"> --foo   foo the bars before frobbling</span><br></pre></td></tr></table></figure>
<p>帮助信息字符串可以包含多种类型格式化声明,避免和默认参数相混淆。这里包括 <code>%(prog)s</code> 或<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 参数的众多关键字参数,例如 <code>%(default)s</code>, <code>%(type)s</code>,请看下面的例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&apos;frobble&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;bar&apos;, nargs=&apos;?&apos;, type=int, default=42,</span><br><span class="line">...                     help=&apos;the bar to %(prog)s (default: %(default)s)&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: frobble [-h] [bar]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar     the bar to frobble (default: 42)</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br></pre></td></tr></table></figure>
<p>help 字符串支持 %格式化方式,如果你不希望在帮助字符串附近出现%,最好避免使用%%逃逸字符。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#module-argparse" target="_blank" rel="noopener"><code>argparse</code></a> 支持help入口参数切片,通过设置<code>argparse.SUPPRESS</code>参数就可以支持。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&apos;frobble&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;, help=argparse.SUPPRESS)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: frobble [-h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help  show this help message and exit</span><br></pre></td></tr></table></figure>
<h3 id="metavar"><a href="#metavar" class="headerlink" title="metavar"></a>metavar</h3><p>当 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 生成帮助消息时，它需要一些方法来引用每个预期的参数。默认情况下，参数分析器对象使用<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> 值作为每个对象的”名称”值。默认情况下，对于位置参数操作，直接使用<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> 值，对于可选参数操作，<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> 值是大写字母。因此，带有<code>dest_bar&#39;bar</code>的单一位置参数将称为”bar”。单个可选参数”-foo”，后面应跟一个命令行参数，将称为”FOO”。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'X --foo Y'</span>.split())</span><br><span class="line">Namespace(bar=<span class="string">'X'</span>, foo=<span class="string">'Y'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage:  [-h] [--foo FOO] bar</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo FOO</span><br></pre></td></tr></table></figure>
<p>可以使用元变量指定替代名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, metavar=<span class="string">'YYY'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, metavar=<span class="string">'XXX'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'X --foo Y'</span>.split())</span><br><span class="line">Namespace(bar=<span class="string">'X'</span>, foo=<span class="string">'Y'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage:  [-h] [--foo YYY] XXX</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> XXX</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo YYY</span><br></pre></td></tr></table></figure>
<p><code>metavar</code> 仅更改显示的名称 - parse_args() 对象上属性的名称仍由  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> 确定</p>
<p>nargs 的不同值可能会导致多次使用 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> 。提供 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> 的元组为每个参数指定不同的显示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-x'</span>, nargs=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="number">2</span>, metavar=(<span class="string">'bar'</span>, <span class="string">'baz'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [-h] [-x X X] [--foo bar baz]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help     show this help message <span class="keyword">and</span> exit</span><br><span class="line"> -x X X</span><br><span class="line"> --foo bar baz</span><br></pre></td></tr></table></figure>
<h3 id="dest"><a href="#dest" class="headerlink" title="dest"></a>dest</h3><p>大多数  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 操作添加一些值作为由 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 返回的对象的属性。此属性的名称由  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 的<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a>关键字参数确定。对于位置参数操作，<code>dest</code>通常作为第一个参数提供给  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'XXX'</span>])</span><br><span class="line">Namespace(bar=<span class="string">'XXX'</span>)</span><br></pre></td></tr></table></figure>
<p>对于可选的参数操作，通常从选项字符串中推断出dest的值。 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener">ArgumentParser</a>生成<code>dest</code>的值，方法是提取第一个长选项字符串并去除 初始<code>--</code>字符串。 如果没有提供长选项字符串，则通过剥离开头的“-”字符，从第一个短选项字符串派生“ dest”。 任何内部的-字符都将转换为_字符，以确保该字符串是有效的属性名称。 下面的示例说明了此行为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo-bar'</span>, <span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-x'</span>, <span class="string">'-y'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'-f 1 -x 2'</span>.split())</span><br><span class="line">Namespace(foo_bar=<span class="string">'1'</span>, x=<span class="string">'2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'--foo 1 -y 2'</span>.split())</span><br><span class="line">Namespace(foo_bar=<span class="string">'1'</span>, x=<span class="string">'2'</span>)</span><br></pre></td></tr></table></figure>
<p><code>dest</code> 允许自定义可选属性的名字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, dest=<span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'--foo XXX'</span>.split())</span><br><span class="line">Namespace(bar=<span class="string">'XXX'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Action-classes"><a href="#Action-classes" class="headerlink" title="Action classes"></a>Action classes</h3><p>这是一个实现了可调用API的函数，该函数返回一个可调用的函数，该可处理函数从命令行处理参数。 遵循此API的任何对象都可以作为操作参数传递给add_argument（）。</p>
<ul>
<li><em>class</em> <code>argparse.Action</code>(<em>option_strings</em>, <em>dest</em>, <em>nargs=None</em>, <em>const=None</em>, <em>default=None</em>, <em>type=None</em>, <em>choices=None</em>, <em>required=False</em>, <em>help=None</em>, <em>metavar=None</em>)</li>
</ul>
<p>ArgumentParser对象使用动作对象表示从命令行的一个或多个字符串解析单个参数所需的信息。 Action类必须接受两个位置参数以及传递给<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser的任何关键字参数" target="_blank" rel="noopener"><code>ArgumentParser</code>和<code>argument()</code></a>.add_argument()，但<code>action</code>本身除外。</p>
<p>Action实例（或可调用<code>action</code>参数的任何返回值）应具有定义的属性<code>dest</code>，<code>option_strings</code>，<code>default</code>，<code>type”，“ required</code>，<code>help</code>等。 确保定义这些属性的最简单方法是调用<code>Action .__ init__</code>。</p>
<p>Action 实例是可调用的，因此子类必须重写<strong>call</strong>方法，该方法应接受四个参数：</p>
<ul>
<li><code>parser</code> -  ArgumentParser对象 包含的动作</li>
<li><code>namespace</code> -  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.Namespace" target="_blank" rel="noopener"><code>Namespace</code></a> 对象通过 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a>方法返回. 大部分actions 通过 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#setattr" target="_blank" rel="noopener"><code>setattr()</code></a>方法添加属性</li>
<li><code>values</code> - 关联命令行参数,已应用任何类型转换，通过 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a>中的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#type" target="_blank" rel="noopener">type</a> 关键字参数声明类型转换</li>
<li><code>option_string</code> - 用于调用此操作的选项字符串。 option_string参数是可选的，如果该动作与位置参数相关联，则将不起作用。</li>
</ul>
<h2 id="parse-args-方法"><a href="#parse-args-方法" class="headerlink" title="parse_args() 方法"></a>parse_args() 方法</h2><ul>
<li><p><code>ArgumentParser.`</code>parse_args`(<em>args=None</em>, <em>namespace=None</em>)</p>
<p>将参数字符串转换为对象，并将其分配为名称空间的属性。 返回填充的名称空间。先前对<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument（）</code></a>的调用确定创建了哪些对象 以及它们的分配方式。 有关详细信息，请参见  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 。</p>
<ul>
<li>要解析的字符串列表。 默认值来自<a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.argv" target="_blank" rel="noopener"><code>sys.argv</code></a>。</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#namespace" target="_blank" rel="noopener">namespace</a>）-带有属性的对象。 默认为一个新的空的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.Namespace" target="_blank" rel="noopener"><code>Namespace</code></a> 对象。</li>
</ul>
</li>
</ul>
<h3 id="Option-value-syntax"><a href="#Option-value-syntax" class="headerlink" title="Option value syntax"></a>Option value syntax</h3><p> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a>方法支持多种方法来指定选项的值（如果 需要一个）。 在最简单的情况下，选项及其值作为两个单独的参数传递：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-x'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-x'</span>, <span class="string">'X'</span>])</span><br><span class="line">Namespace(foo=<span class="literal">None</span>, x=<span class="string">'X'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'FOO'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'FOO'</span>, x=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>对于长选项（名称长于单个字符的选项），选项和值也可以作为单个命令行参数传递，使用<code>=</code>分隔它们：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo=FOO'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'FOO'</span>, x=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>对于短选项（选项仅一个字符长），可以将选项及其值连接在一起：    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-xX'</span>])</span><br><span class="line">Namespace(foo=<span class="literal">None</span>, x=<span class="string">'X'</span>)</span><br></pre></td></tr></table></figure>
<p>只要仅最后一个选项（或其中一个都不要求）需要一个值，几个短选项可以仅使用一个前缀-组合在一起。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-x'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-y'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-z'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-xyzZ'</span>])</span><br><span class="line">Namespace(x=<span class="literal">True</span>, y=<span class="literal">True</span>, z=<span class="string">'Z'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="无效的参数"><a href="#无效的参数" class="headerlink" title="无效的参数"></a>无效的参数</h3><p>  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 检查各种错误，包括 模棱两可的选项，无效的类型，无效的选项，错误的位置参数数量等。遇到此类错误时，它将退出并打印错误以及用法消息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, type=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'?'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># invalid type</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'spam'</span>])</span><br><span class="line">usage: PROG [-h] [--foo FOO] [bar]</span><br><span class="line">PROG: error: argument --foo: invalid int value: <span class="string">'spam'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># invalid option</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--bar'</span>])</span><br><span class="line">usage: PROG [-h] [--foo FOO] [bar]</span><br><span class="line">PROG: error: no such option: --bar</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># wrong number of arguments</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'spam'</span>, <span class="string">'badger'</span>])</span><br><span class="line">usage: PROG [-h] [--foo FOO] [bar]</span><br><span class="line">PROG: error: extra arguments found: badger</span><br></pre></td></tr></table></figure>
<h3 id="包含-的参数"><a href="#包含-的参数" class="headerlink" title="包含 - 的参数"></a>包含 <code>-</code> 的参数</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a>方法尝试在用户明显犯错时给出错误 ，但某些情况本质上是模棱两可的。 例如，命令行参数-1可以是尝试指定选项，也可以是提供位置参数。 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 方法在这里非常谨慎：位置参数只能以<code>-</code>如果它们看起来像负数，并且解析器中没有选项看起来像负数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-x'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, nargs=<span class="string">'?'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># no negative number options, so -1 is a positional argument</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-x'</span>, <span class="string">'-1'</span>])</span><br><span class="line">Namespace(foo=<span class="literal">None</span>, x=<span class="string">'-1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># no negative number options, so -1 and -5 are positional arguments</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-x'</span>, <span class="string">'-1'</span>, <span class="string">'-5'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'-5'</span>, x=<span class="string">'-1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-1'</span>, dest=<span class="string">'one'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, nargs=<span class="string">'?'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># negative number options present, so -1 is an option</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-1'</span>, <span class="string">'X'</span>])</span><br><span class="line">Namespace(foo=<span class="literal">None</span>, one=<span class="string">'X'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># negative number options present, so -2 is an option</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-2'</span>])</span><br><span class="line">usage: PROG [-h] [<span class="number">-1</span> ONE] [foo]</span><br><span class="line">PROG: error: no such option: <span class="number">-2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># negative number options present, so both -1s are options</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-1'</span>, <span class="string">'-1'</span>])</span><br><span class="line">usage: PROG [-h] [<span class="number">-1</span> ONE] [foo]</span><br><span class="line">PROG: error: argument <span class="number">-1</span>: expected one argument</span><br></pre></td></tr></table></figure>
<p>如果您的位置参数必须以<code>-</code>开头并且看起来不像负数，则可以插入伪参数<code>&#39;-&#39;</code>来告诉<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a>  之后的所有内容都是位置参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--'</span>, <span class="string">'-f'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'-f'</span>, one=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<h3 id="参数缩写（前缀匹配）"><a href="#参数缩写（前缀匹配）" class="headerlink" title="参数缩写（前缀匹配）"></a>参数缩写（前缀匹配）</h3><p>The <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> method <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#allow-abbrev" target="_blank" rel="noopener">by default</a> allows long options to be abbreviated to a prefix, if the abbreviation is unambiguous (the prefix matches a unique option):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-bacon'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-badger'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'-bac MMM'</span>.split())</span><br><span class="line">Namespace(bacon=<span class="string">'MMM'</span>, badger=<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'-bad WOOD'</span>.split())</span><br><span class="line">Namespace(bacon=<span class="literal">None</span>, badger=<span class="string">'WOOD'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'-ba BA'</span>.split())</span><br><span class="line">usage: PROG [-h] [-bacon BACON] [-badger BADGER]</span><br><span class="line">PROG: error: ambiguous option: -ba could match -badger, -bacon</span><br></pre></td></tr></table></figure>
<p>对于可能产生多个选项的参数会产生错误。 可以通过将 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#allow-abbrev" target="_blank" rel="noopener">allow_abbrev</a>设置为False来禁用此功能。</p>
<h3 id="Beyond-sys-argv¶"><a href="#Beyond-sys-argv¶" class="headerlink" title="Beyond sys.argv¶"></a>Beyond <code>sys.argv</code><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#beyond-sys-argv" target="_blank" rel="noopener">¶</a></h3><p>有时让ArgumentParser解析除之外的参数可能会很有用。 这可以通过将字符串列表传递给<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a>来完成。 这对于在交互式提示符下进行测试很有用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(</span><br><span class="line"><span class="meta">... </span>    <span class="string">'integers'</span>, metavar=<span class="string">'int'</span>, type=int, choices=range(<span class="number">10</span>),</span><br><span class="line"><span class="meta">... </span>    nargs=<span class="string">'+'</span>, help=<span class="string">'an integer in the range 0..9'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(</span><br><span class="line"><span class="meta">... </span>    <span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>, const=sum,</span><br><span class="line"><span class="meta">... </span>    default=max, help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>])</span><br><span class="line">Namespace(accumulate=&lt;built-<span class="keyword">in</span> function max&gt;, integers=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'--sum'</span>])</span><br><span class="line">Namespace(accumulate=&lt;built-<span class="keyword">in</span> function sum&gt;, integers=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<h3 id="命名空间对象"><a href="#命名空间对象" class="headerlink" title="命名空间对象"></a>命名空间对象</h3><ul>
<li><p><em>class</em> <code>argparse.`</code>Namespace`</p>
<p>默认情况下由<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 使用的简单类来创建保存属性并返回的对象 它。</p>
</li>
</ul>
<p>此类是故意简化的，只是一个具有可读字符串表示形式的<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a>子类。 如果您希望对属性有类似dict的视图，可以使用标准的Python习惯用法<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#vars" target="_blank" rel="noopener"><code>vars()</code></a>#vars）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'BAR'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(args)</span><br><span class="line">&#123;<span class="string">'foo'</span>: <span class="string">'BAR'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>让  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a>  将属性分配给已经存在的对象，而不是 一个新的[ <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.Namespace" target="_blank" rel="noopener"><code>Namespace</code></a>  对象。 这可以通过指定<code>namespace =</code>关键字参数来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(args=[<span class="string">'--foo'</span>, <span class="string">'BAR'</span>], namespace=c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.foo</span><br><span class="line"><span class="string">'BAR'</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>argparse</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library argparse</title>
    <url>/2020/03/08/python-standard-library-argparse/</url>
    <content><![CDATA[<h1 id="python-标准库-argparse-命令行选项"><a href="#python-标准库-argparse-命令行选项" class="headerlink" title="python 标准库 argparse 命令行选项"></a>python 标准库 argparse 命令行选项</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200308_Altered_Carbon2.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>每日一词:</p>
<p> eternity  n 永恒  不朽</p>
<p>近义词:</p>
<p> invariability  n 恒久不变的东西</p>
<p> perpetuity  n 永久 永恒</p>
<p> timelessness　 n 永恒</p>
<p> permanence　  n 永久 持久</p>
<p> everlasting  adj永恒的 </p>
</blockquote>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/argparse.py" target="_blank" rel="noopener">Lib/argparse.py</a> </p>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#module-argparse" target="_blank" rel="noopener"><code>argparse</code></a> 模块可以让人轻松编写用户友好的命令行接口。程序定义它需要的参数，然后 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#module-argparse" target="_blank" rel="noopener"><code>argparse</code></a> 将弄清如何从 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.argv" target="_blank" rel="noopener"><code>sys.argv</code></a> 解析出那些参数。 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#module-argparse" target="_blank" rel="noopener"><code>argparse</code></a> 模块还会自动生成帮助和使用手册，并在用户给程序传入无效参数时报出错误信息。 </p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p> 以下代码是一个 Python 程序，它获取一个整数列表并计算总和或者最大值： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                    help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                    const=sum, default=max,</span><br><span class="line">                    help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args.accumulate(args.integers))</span><br></pre></td></tr></table></figure>
<p> 假设上面的 Python 代码保存在名为 <code>prog.py</code> 的文件中，它可以在命令行运行并提供有用的帮助消息： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python prog.py -h</span><br><span class="line">usage: prog.py [-h] [--sum] N [N ...]</span><br><span class="line"></span><br><span class="line">Process some integers.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> N           an integer <span class="keyword">for</span> the accumulator</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --sum       sum the integers (default: find the max)</span><br></pre></td></tr></table></figure>
<p> 当使用适当的参数运行时，它会输出命令行传入整数的总和或者最大值： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python prog.py <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line">$ python prog.py <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> --sum</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p> 如果传入无效参数，则会报出错误： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python prog.py a b c</span><br><span class="line">usage: prog.py [-h] [--sum] N [N ...]</span><br><span class="line">prog.py: error: argument N: invalid int value: <span class="string">'a'</span></span><br></pre></td></tr></table></figure>
<p> 以下部分将引导你完成这个示例。 </p>
<h3 id="创建一个解析器"><a href="#创建一个解析器" class="headerlink" title="创建一个解析器"></a>创建一个解析器</h3><p> 使用 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#module-argparse" target="_blank" rel="noopener"><code>argparse</code></a> 的第一步是创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br></pre></td></tr></table></figure>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象包含将命令行解析成 Python 数据类型所需的全部信息。 </p>
<h3 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h3><p> 给一个 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 添加程序参数信息是通过调用 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 方法完成的。通常，这些调用指定 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 如何获取命令行字符串并将其转换为对象。这些信息在 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 调用时被存储和使用。例如： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line"><span class="meta">... </span>                    help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line"><span class="meta">... </span>                    const=sum, default=max,</span><br><span class="line"><span class="meta">... </span>                    help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br></pre></td></tr></table></figure>
<p> 稍后，调用 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 将返回一个具有 <code>integers</code> 和 <code>accumulate</code> 两个属性的对象。<code>integers</code> 属性将是一个包含一个或多个整数的列表，而 <code>accumulate</code> 属性当命令行中指定了 <code>--sum</code> 参数时将是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sum" target="_blank" rel="noopener"><code>sum()</code></a> 函数，否则则是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#max" target="_blank" rel="noopener"><code>max()</code></a> 函数。 </p>
<h3 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h3><p> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 通过 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 方法解析参数。它将检查命令行，把每个参数转换为适当的类型然后调用相应的操作。在大多数情况下，这意味着一个简单的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.Namespace" target="_blank" rel="noopener"><code>Namespace</code></a> 对象将从命令行参数中解析出的属性构建： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--sum'</span>, <span class="string">'7'</span>, <span class="string">'-1'</span>, <span class="string">'42'</span>])</span><br><span class="line">Namespace(accumulate=&lt;built-<span class="keyword">in</span> function sum&gt;, integers=[<span class="number">7</span>, <span class="number">-1</span>, <span class="number">42</span>])</span><br></pre></td></tr></table></figure>
<p> 在脚本中，通常 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 会被不带参数调用，而 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 将自动从 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.argv" target="_blank" rel="noopener"><code>sys.argv</code></a> 中确定命令行参数。 </p>
<h2 id="ArgumentParser-对象"><a href="#ArgumentParser-对象" class="headerlink" title="ArgumentParser 对象"></a>ArgumentParser 对象</h2><p>  创建一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象。所有的参数都应当作为关键字参数传入。每个参数在下面都有它更详细的描述，但简而言之，它们是：</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#prog" target="_blank" rel="noopener">prog</a> - 程序的名称（默认：<code>sys.argv[0]</code>）</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#usage" target="_blank" rel="noopener">usage</a> - 描述程序用途的字符串（默认值：从添加到解析器的参数生成）</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#description" target="_blank" rel="noopener">description</a> - 在参数帮助文档之前显示的文本（默认值：无）</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#epilog" target="_blank" rel="noopener">epilog</a> - 在参数帮助文档之后显示的文本（默认值：无）</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#parents" target="_blank" rel="noopener">parents</a> - 一个 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象的列表，它们的参数也应包含在内</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#formatter-class" target="_blank" rel="noopener">formatter_class</a> - 用于自定义帮助文档输出格式的类</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#prefix-chars" target="_blank" rel="noopener">prefix_chars</a> - 可选参数的前缀字符集合（默认值：’-‘）</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#fromfile-prefix-chars" target="_blank" rel="noopener">fromfile_prefix_chars</a> - 当需要从文件中读取其他参数时，用于标识文件名的前缀字符集合（默认值：<code>None</code>）</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argument-default" target="_blank" rel="noopener">argument_default</a> - 参数的全局默认值（默认值： <code>None</code>）</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#conflict-handler" target="_blank" rel="noopener">conflict_handler</a> - 解决冲突选项的策略（通常是不必要的）</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#add-help" target="_blank" rel="noopener">add_help</a> - 为解析器添加一个 <code>-h/--help</code> 选项（默认值： <code>True</code>）</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#allow-abbrev" target="_blank" rel="noopener">allow_abbrev</a> - 如果缩写是无歧义的，则允许缩写长选项 （默认值：<code>True</code>）</p>
</li>
</ul>
<p>以下部分描述这些参数如何使用。 </p>
<h3 id="prog"><a href="#prog" class="headerlink" title="prog"></a>prog</h3><p> 默认情况下，<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象使用 <code>sys.argv[0]</code> 来确定如何在帮助消息中显示程序名称。这一默认值几乎总是可取的，因为它将使帮助消息与从命令行调用此程序的方式相匹配。例如，对于有如下代码的名为 <code>myprogram.py</code> 的文件： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>, help=<span class="string">'foo help'</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure>
<p> 该程序的帮助信息将显示 <code>myprogram.py</code> 作为程序名称（无论程序从何处被调用）： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python myprogram.py --help</span><br><span class="line">usage: myprogram.py [-h] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo FOO   foo help</span><br><span class="line">$ cd ..</span><br><span class="line">$ python subdir/myprogram.py --help</span><br><span class="line">usage: myprogram.py [-h] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo FOO   foo help</span><br></pre></td></tr></table></figure>
<p> 要更改这样的默认行为，可以使用 <code>prog=</code> 参数为 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 提供另一个值： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'myprogram'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: myprogram [-h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br></pre></td></tr></table></figure>
<p> 需要注意的是，无论是从 <code>sys.argv[0]</code> 或是从 <code>prog=</code> 参数确定的程序名称，都可以在帮助消息里通过 <code>%(prog)s</code> 格式串来引用。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'myprogram'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, help=<span class="string">'foo of the %(prog)s program'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: myprogram [-h] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo FOO   foo of the myprogram program</span><br></pre></td></tr></table></figure>
<h3 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h3><p> 默认情况下，<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 根据它包含的参数来构建用法消息： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="string">'?'</span>, help=<span class="string">'foo help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'+'</span>, help=<span class="string">'bar help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [-h] [--foo [FOO]] bar [bar ...]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar          bar help</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help   show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo [FOO]  foo help</span><br></pre></td></tr></table></figure>
<p> 可以通过 <code>usage=</code> 关键字参数覆盖这一默认消息： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>, usage=<span class="string">'%(prog)s [options]'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="string">'?'</span>, help=<span class="string">'foo help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'+'</span>, help=<span class="string">'bar help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [options]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar          bar help</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help   show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo [FOO]  foo help</span><br></pre></td></tr></table></figure>
<p> 在用法消息中可以使用 <code>%(prog)s</code> 格式说明符来填入程序名称。 </p>
<h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p> 大多数对 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 构造方法的调用都会使用 <code>description=</code> 关键字参数。这个参数简要描述这个程度做什么以及怎么做。在帮助消息中，这个描述会显示在命令行用法字符串和各种参数的帮助消息之间： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(description=<span class="string">'A foo that bars'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: argparse.py [-h]</span><br><span class="line"></span><br><span class="line">A foo that bars</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br></pre></td></tr></table></figure>
<p> 在默认情况下，description 将被换行以便适应给定的空间。如果想改变这种行为，见 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#formatter-class" target="_blank" rel="noopener">formatter_class</a> 参数。 </p>
<h3 id="epilog"><a href="#epilog" class="headerlink" title="epilog"></a>epilog</h3><p> 一些程序喜欢在 description 参数后显示额外的对程序的描述。这种文字能够通过给 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a>:: 提供 <code>epilog=</code> 参数而被指定。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(</span><br><span class="line"><span class="meta">... </span>    description=<span class="string">'A foo that bars'</span>,</span><br><span class="line"><span class="meta">... </span>    epilog=<span class="string">"And that's how you'd foo a bar"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: argparse.py [-h]</span><br><span class="line"></span><br><span class="line">A foo that bars</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"></span><br><span class="line">And that<span class="string">'s how you'</span>d foo a bar</span><br></pre></td></tr></table></figure>
<p> 和 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#description" target="_blank" rel="noopener">description</a> 参数一样，<code>epilog=</code> text 在默认情况下会换行，但是这种行为能够被调整通过提供 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#formatter-class" target="_blank" rel="noopener">formatter_class</a> 参数给 <code>ArgumentParse</code>. </p>
<h3 id="parents"><a href="#parents" class="headerlink" title="parents"></a>parents</h3><p> 有些时候，少数解析器会使用同一系列参数。 单个解析器能够通过提供 <code>parents=</code> 参数给 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 而使用相同的参数而不是重复这些参数的定义。<code>parents=</code> 参数使用 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象的列表，从它们那里收集所有的位置和可选的行为，然后将这写行为加到正在构建的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parent_parser = argparse.ArgumentParser(add_help=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parent_parser.add_argument(<span class="string">'--parent'</span>, type=int)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo_parser = argparse.ArgumentParser(parents=[parent_parser])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo_parser.add_argument(<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo_parser.parse_args([<span class="string">'--parent'</span>, <span class="string">'2'</span>, <span class="string">'XXX'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'XXX'</span>, parent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar_parser = argparse.ArgumentParser(parents=[parent_parser])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar_parser.add_argument(<span class="string">'--bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar_parser.parse_args([<span class="string">'--bar'</span>, <span class="string">'YYY'</span>])</span><br><span class="line">Namespace(bar=<span class="string">'YYY'</span>, parent=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p> 请注意大多数父解析器会指定 <code>add_help=False</code> . 否则， <code>ArgumentParse</code> 将会看到两个 <code>-h/--help</code> 选项（一个在父参数中一个在子参数中）并且产生一个错误。 </p>
<blockquote>
<p> 你在传parents=给那些解析器时必须完全初始化它们。如果你在子解析器之后改变父解析器是，这些改变不会反映在子解析器上。 </p>
</blockquote>
<h3 id="formatter-class"><a href="#formatter-class" class="headerlink" title="formatter_class"></a>formatter_class</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象允许通过指定备用格式化类来自定义帮助格式。目前，有四种这样的类。</p>
<ul>
<li><em>class</em> <code>argparse.RawDescriptionHelpFormatter</code></li>
<li><em>class</em> <code>argparse.RawTextHelpFormatter</code></li>
<li><em>class</em> <code>argparse.ArgumentDefaultsHelpFormatter</code></li>
<li><p><em>class</em> <code>argparse.MetavarTypeHelpFormatter</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.RawDescriptionHelpFormatter" target="_blank" rel="noopener"><code>RawDescriptionHelpFormatter</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.RawTextHelpFormatter" target="_blank" rel="noopener"><code>RawTextHelpFormatter</code></a> 在正文的描述和展示上给与了更多的控制。<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象会将 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#description" target="_blank" rel="noopener">description</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#epilog" target="_blank" rel="noopener">epilog</a> 的文字在命令行中自动换行。 </p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(</span><br><span class="line"><span class="meta">... </span>    prog=<span class="string">'PROG'</span>,</span><br><span class="line"><span class="meta">... </span>    description=<span class="string">'''this description</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        was indented weird</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            but that is okay'''</span>,</span><br><span class="line"><span class="meta">... </span>    epilog=<span class="string">'''</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            likewise for this epilog whose whitespace will</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        be cleaned up and whose words will be wrapped</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        across a couple lines'''</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [-h]</span><br><span class="line"></span><br><span class="line">this description was indented weird but that <span class="keyword">is</span> okay</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"></span><br><span class="line">likewise <span class="keyword">for</span> this epilog whose whitespace will be cleaned up <span class="keyword">and</span> whose words</span><br><span class="line">will be wrapped across a couple lines</span><br></pre></td></tr></table></figure>
<p> 传 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.RawDescriptionHelpFormatter" target="_blank" rel="noopener"><code>RawDescriptionHelpFormatter</code></a> 给 <code>formatter_class=</code> 表示 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#description" target="_blank" rel="noopener">description</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#epilog" target="_blank" rel="noopener">epilog</a> 已经被正确的格式化了，不能在命令行中被自动换行: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(</span><br><span class="line"><span class="meta">... </span>    prog=<span class="string">'PROG'</span>,</span><br><span class="line"><span class="meta">... </span>    formatter_class=argparse.RawDescriptionHelpFormatter,</span><br><span class="line"><span class="meta">... </span>    description=textwrap.dedent(<span class="string">'''\</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        Please do not mess up this text!</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        --------------------------------</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            I have indented it</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            exactly the way</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            I want it</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        '''</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [-h]</span><br><span class="line"></span><br><span class="line">Please do <span class="keyword">not</span> mess up this text!</span><br><span class="line">--------------------------------</span><br><span class="line">   I have indented it</span><br><span class="line">   exactly the way</span><br><span class="line">   I want it</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.RawTextHelpFormatter" target="_blank" rel="noopener"><code>RawTextHelpFormatter</code></a> 保留所有种类文字的空格，包括参数的描述。然而，多重的新行会被替换成一行。如果你想保留多重的空白行，可以在新行之间加空格。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentDefaultsHelpFormatter" target="_blank" rel="noopener"><code>ArgumentDefaultsHelpFormatter</code></a> 自动添加默认的值的信息到每一个帮助信息的参数中:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(</span><br><span class="line"><span class="meta">... </span>    prog=<span class="string">'PROG'</span>,</span><br><span class="line"><span class="meta">... </span>    formatter_class=argparse.ArgumentDefaultsHelpFormatter)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, type=int, default=<span class="number">42</span>, help=<span class="string">'FOO!'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'*'</span>, default=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], help=<span class="string">'BAR!'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [-h] [--foo FOO] [bar [bar ...]]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar         BAR! (default: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo FOO   FOO! (default: <span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.MetavarTypeHelpFormatter" target="_blank" rel="noopener"><code>MetavarTypeHelpFormatter</code></a> 为它的值在每一个参数中使用 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#type" target="_blank" rel="noopener">type</a> 的参数名当作它的显示名（而不是使用通常的格式 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> ): </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(</span><br><span class="line"><span class="meta">... </span>    prog=<span class="string">'PROG'</span>,</span><br><span class="line"><span class="meta">... </span>    formatter_class=argparse.MetavarTypeHelpFormatter)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, type=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, type=float)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [-h] [--foo int] float</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  float</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line">  --foo int</span><br></pre></td></tr></table></figure>
<h3 id="prefix-chars"><a href="#prefix-chars" class="headerlink" title="prefix_chars"></a>prefix_chars</h3><p>许多命令行会使用 <code>-</code> 当作前缀，比如 <code>-f/--foo</code>。如果解析器需要支持不同的或者额外的字符，比如像 <code>+f</code> 或者 <code>/foo</code> 的选项，可以在参数解析构建器中使用 <code>prefix_chars=</code> 参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>, prefix_chars=<span class="string">'-+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'+f'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'++bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'+f X ++bar Y'</span>.split())</span><br><span class="line">Namespace(bar=<span class="string">'Y'</span>, f=<span class="string">'X'</span>)</span><br></pre></td></tr></table></figure>
<p> The <code>prefix_chars=</code> 参数默认使用 <code>&#39;-&#39;</code>. 支持一系列字符，但是不包括 <code>-</code> ，这样会产生不被允许的 <code>-f/--foo</code> 选项。 </p>
<h3 id="fromfile-prefix-chars"><a href="#fromfile-prefix-chars" class="headerlink" title="fromfile_prefix_chars"></a>fromfile_prefix_chars</h3><p> 有些时候，先举个例子，当处理一个特别长的参数列表的时候，把它存入一个文件中而不是在命令行打出来会很有意义。如果 <code>fromfile_prefix_chars=</code> 参数提供给 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 构造函数，之后所有类型的字符的参数都会被当成文件处理，并且会被文件包含的参数替代。举个栗子: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'args.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> fp:</span><br><span class="line"><span class="meta">... </span>    fp.write(<span class="string">'-f\nbar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(fromfile_prefix_chars=<span class="string">'@'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-f'</span>, <span class="string">'foo'</span>, <span class="string">'@args.txt'</span>])</span><br><span class="line">Namespace(f=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure>
<p>从文件读取的参数在默认情况下必须一个一行（但是可参见 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.convert_arg_line_to_args" target="_blank" rel="noopener"><code>convert_arg_line_to_args()</code></a>）并且它们被视为与命令行上的原始文件引用参数位于同一位置。所以在以上例子中，<code>[&#39;-f&#39;, &#39;foo&#39;, &#39;@args.txt&#39;]</code> 的表示和 <code>[&#39;-f&#39;, &#39;foo&#39;, &#39;-f&#39;, &#39;bar&#39;]</code> 的表示相同。</p>
<p><code>fromfile_prefix_chars=</code> 参数默认为 <code>None</code>，意味着参数不会被当作文件对待。</p>
<h3 id="argument-default"><a href="#argument-default" class="headerlink" title="argument_default"></a>argument_default</h3><p> 一般情况下，参数默认会通过设置一个默认到 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 或者调用带一组指定键值对的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.set_defaults" target="_blank" rel="noopener"><code>ArgumentParser.set_defaults()</code></a> 方法。但是有些时候，为参数指定一个普遍适用的解析器会更有用。这能够通过传输 <code>argument_default=</code> 关键词参数给 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 来完成。举个栗子，要全局禁止在 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 中创建属性，我们提供 <code>argument_default=SUPPRESS</code>: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'?'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'1'</span>, <span class="string">'BAR'</span>])</span><br><span class="line">Namespace(bar=<span class="string">'BAR'</span>, foo=<span class="string">'1'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">Namespace()</span><br></pre></td></tr></table></figure>
<h3 id="allow-abbrev"><a href="#allow-abbrev" class="headerlink" title="allow_abbrev"></a>allow_abbrev</h3><p>正常情况下，当你向 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 方法传入一个参数列表时，它会 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#prefix-matching" target="_blank" rel="noopener">recognizes abbreviations</a>。</p>
<p>这个特性可以设置 <code>allow_abbrev</code> 为 <code>False</code> 来关闭:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>, allow_abbrev=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foobar'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foonley'</span>, action=<span class="string">'store_false'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foon'</span>])</span><br><span class="line">usage: PROG [-h] [--foobar] [--foonley]</span><br><span class="line">PROG: error: unrecognized arguments: --foon</span><br></pre></td></tr></table></figure>
<h3 id="conflict-handler"><a href="#conflict-handler" class="headerlink" title="conflict_handler"></a>conflict_handler</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象不允许在相同选项字符串下有两种行为。默认情况下， <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象会产生一个异常如果去创建一个正在使用的选项字符串参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo'</span>, help=<span class="string">'old foo help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, help=<span class="string">'new foo help'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> ..</span><br><span class="line">ArgumentError: argument --foo: conflicting option string(s): --foo</span><br></pre></td></tr></table></figure>
<p> 有些时候（例如：使用 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#parents" target="_blank" rel="noopener">parents</a>），重写旧的有相同选项字符串的参数会更有用。为了产生这种行为， <code>&#39;resolve&#39;</code> 值可以提供给 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 的 <code>conflict_handler=</code> 参数: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>, conflict_handler=<span class="string">'resolve'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo'</span>, help=<span class="string">'old foo help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, help=<span class="string">'new foo help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [-h] [-f FOO] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> -f FOO      old foo help</span><br><span class="line"> --foo FOO   new foo help</span><br></pre></td></tr></table></figure>
<p> <strong>注意</strong> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象只能移除一个行为如果它所有的选项字符串都被重写。所以，在上面的例子中，旧的 <code>-f/--foo</code> 行为 回合 <code>-f</code> 行为保持一样, 因为只有 <code>--foo</code> 选项字符串被重写。 </p>
<h3 id="add-help"><a href="#add-help" class="headerlink" title="add_help"></a>add_help</h3><p> 默认情况下，ArgumentParser 对象添加一个简单的显示解析器帮助信息的选项。举个栗子，考虑一个名为 <code>myprogram.py</code> 的文件包含如下代码: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>, help=<span class="string">'foo help'</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure>
<p> 如果 <code>-h</code> or <code>--help</code> 在命令行中被提供, 参数解析器帮助信息会打印: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python myprogram.py --help</span><br><span class="line">usage: myprogram.py [-h] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo FOO   foo help</span><br></pre></td></tr></table></figure>
<p>有时候可能会需要关闭额外的帮助信息。这可以通过在 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 中设置 <code>add_help=</code> 参数为 <code>False</code> 来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>, add_help=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, help=<span class="string">'foo help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> --foo FOO  foo help</span><br></pre></td></tr></table></figure>
<p>帮助选项一般为 <code>-h/--help</code>。如果 <code>prefix_chars=</code> 被指定并且没有包含 <code>-</code> 字符，在这种情况下， <code>-h</code> <code>--help</code> 不是有效的选项。此时， <code>prefix_chars</code> 的第一个字符将用作帮助选项的前缀。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>, prefix_chars=<span class="string">'+/'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [+h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  +h, ++help  show this help message <span class="keyword">and</span> exit</span><br></pre></td></tr></table></figure>
<h2 id="add-argument-方法"><a href="#add-argument-方法" class="headerlink" title="add_argument() 方法"></a>add_argument() 方法</h2><p> <code>ArgumentParser.add_argument</code>(<em>name or flags…</em>[, <em>action</em>][, <em>nargs</em>][, <em>const</em>][, <em>default</em>][, <em>type</em>][, <em>choices</em>][, <em>required</em>][, <em>help</em>][, <em>metavar</em>][, <em>dest</em>]) </p>
<p>定义单个的命令行参数应当如何解析。每个形参都在下面有它自己更多的描述，长话短说有：</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#name-or-flags" target="_blank" rel="noopener">name or flags</a> - 一个命名或者一个选项字符串的列表，例如 <code>foo</code> 或 <code>-f, --foo</code>。</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#action" target="_blank" rel="noopener">action</a> - 当参数在命令行中出现时使用的动作基本类型。</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#nargs" target="_blank" rel="noopener">nargs</a> - 命令行参数应当消耗的数目。</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#const" target="_blank" rel="noopener">const</a> - 被一些 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#action" target="_blank" rel="noopener">action</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#nargs" target="_blank" rel="noopener">nargs</a> 选择所需求的常数。</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#default" target="_blank" rel="noopener">default</a> - 当参数未在命令行中出现时使用的值。</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#type" target="_blank" rel="noopener">type</a> - 命令行参数应当被转换成的类型。</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#choices" target="_blank" rel="noopener">choices</a> - 可用的参数的容器。</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#required" target="_blank" rel="noopener">required</a> - 此命令行选项是否可省略 （仅选项可用）。</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#help" target="_blank" rel="noopener">help</a> - 一个此选项作用的简单描述。</li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#metavar" target="_blank" rel="noopener">metavar</a> - 在使用方法消息中使用的参数值示例。</li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> - 被添加到 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 所返回对象上的属性名。</p>
<p>以下部分描述这些参数如何使用。 </p>
</li>
</ul>
<h3 id="name-or-flags"><a href="#name-or-flags" class="headerlink" title="name or flags"></a>name or flags</h3><p> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 方法必须知道它是否是一个选项，例如 <code>-f</code> 或 <code>--foo</code>，或是一个位置参数，例如一组文件名。第一个传递给 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 的参数必须是一系列 flags 或者是一个简单的参数名。例如，可以选项可以被这样创建: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo'</span>)</span><br></pre></td></tr></table></figure>
<p>而位置参数可以这么创建:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure>
<p>当 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 被调用，选项会以 <code>-</code> 前缀识别，剩下的参数则会被假定为位置参数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'BAR'</span>])</span><br><span class="line">Namespace(bar=<span class="string">'BAR'</span>, foo=<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'BAR'</span>, <span class="string">'--foo'</span>, <span class="string">'FOO'</span>])</span><br><span class="line">Namespace(bar=<span class="string">'BAR'</span>, foo=<span class="string">'FOO'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'FOO'</span>])</span><br><span class="line">usage: PROG [-h] [-f FOO] bar</span><br><span class="line">PROG: error: the following arguments are required: bar</span><br></pre></td></tr></table></figure>
<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象将命令行参数与动作相关联。这些动作可以做与它们相关联的命令行参数的任何事，尽管大多数动作只是简单的向 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 返回的对象上添加属性。<code>action</code> 命名参数指定了这个命令行参数应当如何处理。供应的动作有： </p>
<ul>
<li><p><code>&#39;store&#39;</code> - 存储参数的值。这是默认的动作。例如: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'--foo 1'</span>.split())</span><br><span class="line">Namespace(foo=<span class="string">'1'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&#39;store_const&#39;</code> - 存储被 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#const" target="_blank" rel="noopener">const</a> 命名参数指定的值。 <code>&#39;store_const&#39;</code> 动作通常用在选项中来指定一些标志。例如: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store_const'</span>, const=<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>])</span><br><span class="line">Namespace(foo=<span class="number">42</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&#39;store_true&#39;</code> and <code>&#39;store_false&#39;</code> - 这些是 <code>&#39;store_const&#39;</code> 分别用作存储 <code>True</code> 和 <code>False</code> 值的特殊用例。另外，它们的默认值分别为 <code>False</code> 和 <code>True</code>。例如: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--bar'</span>, action=<span class="string">'store_false'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--baz'</span>, action=<span class="string">'store_false'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'--foo --bar'</span>.split())</span><br><span class="line">Namespace(foo=<span class="literal">True</span>, bar=<span class="literal">False</span>, baz=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&#39;append&#39;</code> - 存储一个列表，并且将每个参数值追加到列表中。在允许多次使用选项时很有用。例如: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'append'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'--foo 1 --foo 2'</span>.split())</span><br><span class="line">Namespace(foo=[<span class="string">'1'</span>, <span class="string">'2'</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&#39;append_const&#39;</code> - 这存储一个列表，并将 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#const" target="_blank" rel="noopener">const</a> 命名参数指定的值追加到列表中。（注意 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#const" target="_blank" rel="noopener">const</a> 命名参数默认为 <code>None</code>。）’append_const’ 动作一般在多个参数需要在同一列表中存储常数时会有用。例如: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--str'</span>, dest=<span class="string">'types'</span>, action=<span class="string">'append_const'</span>, const=str)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--int'</span>, dest=<span class="string">'types'</span>, action=<span class="string">'append_const'</span>, const=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'--str --int'</span>.split())</span><br><span class="line">Namespace(types=[&lt;class 'str'&gt;, &lt;class 'int'&gt;])</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&#39;count&#39;</code> - 计算一个关键字参数出现的数目或次数。例如，对于一个增长的详情等级来说有用: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--verbose'</span>, <span class="string">'-v'</span>, action=<span class="string">'count'</span>, default=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-vvv'</span>])</span><br><span class="line">Namespace(verbose=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p> Note, the <em>default</em> will be <code>None</code> unless explicitly set to <em>0</em>. </p>
</li>
<li><p><code>&#39;help&#39;</code> - 打印所有当前解析器中的选项和参数的完整帮助信息，然后退出。默认情况下，一个 help 动作会被自动加入解析器。关于输出是如何创建的，参与 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a>。</p>
</li>
<li><p><code>&#39;version&#39;</code> - 期望有一个 <code>version=</code> 命名参数在 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 调用中，并打印版本信息并在调用后退出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> argparse</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--version'</span>, action=<span class="string">'version'</span>, version=<span class="string">'%(prog)s 2.0'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--version'</span>])</span><br><span class="line">PROG <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&#39;extend&#39;</code> - This stores a list, and extends each argument value to the list. Example usage: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">"--foo"</span>, action=<span class="string">"extend"</span>, nargs=<span class="string">"+"</span>, type=str)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">"--foo"</span>, <span class="string">"f1"</span>, <span class="string">"--foo"</span>, <span class="string">"f2"</span>, <span class="string">"f3"</span>, <span class="string">"f4"</span>])</span><br><span class="line">Namespace(foo=[<span class="string">'f1'</span>, <span class="string">'f2'</span>, <span class="string">'f3'</span>, <span class="string">'f4'</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>3.8 新版功能.</strong> </p>
<p>您还可以通过传递 Action 子类或实现相同接口的其他对象来指定任意操作。建议的方法是扩展 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.Action" target="_blank" rel="noopener"><code>Action</code></a>，覆盖 <code>__call__</code> 方法和可选的 <code>__init__</code> 方法。</p>
<p>一个自定义动作的例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">FooAction</span><span class="params">(argparse.Action)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, option_strings, dest, nargs=None, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> nargs <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> ValueError(<span class="string">"nargs not allowed"</span>)</span><br><span class="line"><span class="meta">... </span>        super(FooAction, self).__init__(option_strings, dest, **kwargs)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, parser, namespace, values, option_string=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'%r %r %r'</span> % (namespace, values, option_string))</span><br><span class="line"><span class="meta">... </span>        setattr(namespace, self.dest, values)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, action=FooAction)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, action=FooAction)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = parser.parse_args(<span class="string">'1 --foo 2'</span>.split())</span><br><span class="line">Namespace(bar=<span class="literal">None</span>, foo=<span class="literal">None</span>) <span class="string">'1'</span> <span class="literal">None</span></span><br><span class="line">Namespace(bar=<span class="string">'1'</span>, foo=<span class="literal">None</span>) <span class="string">'2'</span> <span class="string">'--foo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args</span><br><span class="line">Namespace(bar=<span class="string">'1'</span>, foo=<span class="string">'2'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="nargs"><a href="#nargs" class="headerlink" title="nargs"></a>nargs</h3><p>ArgumentParser 对象通常关联一个单独的命令行参数到一个单独的被执行的动作。 <code>nargs</code> 命名参数关联不同数目的命令行参数到单一动作。支持的值有：</p>
<ul>
<li><p><code>N</code> （一个整数）。命令行中的 <code>N</code> 个参数会被聚集到一个列表中。 例如:</p>
<p>>&gt;&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;, nargs=2)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;bar&apos;, nargs=1)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&apos;c --foo a b&apos;.split())</span><br><span class="line">Namespace(bar=[&apos;c&apos;], foo=[&apos;a&apos;, &apos;b&apos;])</span><br></pre></td></tr></table></figure>
<p>注意 <code>nargs=1</code> 会产生一个单元素列表。这和默认的元素本身是不同的。</p>
</li>
<li><p><code>&#39;?&#39;</code>。如果可能的话，会从命令行中消耗一个参数，并产生一个单一项。如果当前没有命令行参数，则会产生 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#default" target="_blank" rel="noopener">default</a> 值。注意，对于选项，有另外的用例 - 选项字符串出现但没有跟随命令行参数，则会产生 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#const" target="_blank" rel="noopener">const</a> 值。一些说用用例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="string">'?'</span>, const=<span class="string">'c'</span>, default=<span class="string">'d'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'?'</span>, default=<span class="string">'d'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'XX'</span>, <span class="string">'--foo'</span>, <span class="string">'YY'</span>])</span><br><span class="line">Namespace(bar=<span class="string">'XX'</span>, foo=<span class="string">'YY'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'XX'</span>, <span class="string">'--foo'</span>])</span><br><span class="line">Namespace(bar=<span class="string">'XX'</span>, foo=<span class="string">'c'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">Namespace(bar=<span class="string">'d'</span>, foo=<span class="string">'d'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nargs=&#39;?&#39;</code> 的一个更普遍用法是允许可选的输入或输出文件:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'infile'</span>, nargs=<span class="string">'?'</span>, type=argparse.FileType(<span class="string">'r'</span>),</span><br><span class="line"><span class="meta">... </span>                    default=sys.stdin)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'outfile'</span>, nargs=<span class="string">'?'</span>, type=argparse.FileType(<span class="string">'w'</span>),</span><br><span class="line"><span class="meta">... </span>                    default=sys.stdout)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'input.txt'</span>, <span class="string">'output.txt'</span>])</span><br><span class="line">Namespace(infile=&lt;_io.TextIOWrapper name=<span class="string">'input.txt'</span> encoding=<span class="string">'UTF-8'</span>&gt;,</span><br><span class="line">          outfile=&lt;_io.TextIOWrapper name=<span class="string">'output.txt'</span> encoding=<span class="string">'UTF-8'</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">Namespace(infile=&lt;_io.TextIOWrapper name=<span class="string">'&lt;stdin&gt;'</span> encoding=<span class="string">'UTF-8'</span>&gt;,</span><br><span class="line">          outfile=&lt;_io.TextIOWrapper name=<span class="string">'&lt;stdout&gt;'</span> encoding=<span class="string">'UTF-8'</span>&gt;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&#39;*&#39;</code>。所有当前命令行参数被聚集到一个列表中。注意通过 <code>nargs=&#39;*&#39;</code> 来实现多个位置参数通常没有意义，但是多个选项是可能的。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="string">'*'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--bar'</span>, nargs=<span class="string">'*'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'baz'</span>, nargs=<span class="string">'*'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'a b --foo x y --bar 1 2'</span>.split())</span><br><span class="line">Namespace(bar=[<span class="string">'1'</span>, <span class="string">'2'</span>], baz=[<span class="string">'a'</span>, <span class="string">'b'</span>], foo=[<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&#39;+&#39;</code>。和 <code>&#39;*&#39;</code> 类似，所有当前命令行参数被聚集到一个列表中。另外，当前没有至少一个命令行参数时会产生一个错误信息。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, nargs=<span class="string">'+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">Namespace(foo=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">usage: PROG [-h] foo [foo ...]</span><br><span class="line">PROG: error: the following arguments are required: foo</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>argarse.REMAINDER</code>。所有剩余的命令行参数被聚集到一个列表中。这通常在从一个命令行功能传递参数到另一个命令行功能中时有用:</p>
<p>>&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'command'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'args'</span>, nargs=argparse.REMAINDER)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(parser.parse_args(<span class="string">'--foo B cmd --arg1 XX ZZ'</span>.split()))</span><br><span class="line">Namespace(args=[<span class="string">'--arg1'</span>, <span class="string">'XX'</span>, <span class="string">'ZZ'</span>], command=<span class="string">'cmd'</span>, foo=<span class="string">'B'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果不提供 <code>nargs</code> 命名参数，则消耗参数的数目将被 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#action" target="_blank" rel="noopener">action</a> 决定。通常这意味着单一项目（非列表）消耗单一命令行参数。 </p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 的const 参数用于保存不从命令行中读取但被各种 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 动作需求的常数值。最常用的两例为：</p>
<ul>
<li>当 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 通过 <code>action=&#39;store_const&#39;</code> 或 <code>action=&#39;append_const</code> 调用时。这些动作将 <code>const</code> 值添加到 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 返回的对象的属性中。在 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#action" target="_blank" rel="noopener">action</a> 的描述中查看案例。</li>
<li>当 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 通过选项（例如 <code>-f</code> 或 <code>--foo</code>）调用并且 <code>nargs=&#39;?&#39;</code> 时。这会创建一个可以跟随零个或一个命令行参数的选项。当解析命令行时，如果选项后没有参数，则将用 <code>const</code> 代替。在 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#nargs" target="_blank" rel="noopener">nargs</a> 描述中查看案例。</li>
</ul>
<p>对 <code>&#39;store_const&#39;</code> 和 <code>&#39;append_const&#39;</code> 动作， <code>const</code> 命名参数必须给出。对其他动作，默认为 <code>None</code>。</p>
<h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>所有选项和一些位置参数可能在命令行中被忽略。<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 的命名参数 <code>default</code>，默认值为 <code>None</code>，指定了在命令行参数未出现时应当使用的值。对于选项， <code>default</code> 值在选项未在命令行中出现时使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, default=<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'2'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">Namespace(foo=<span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<p>如果 <code>default</code> 值是一个字符串，解析器解析此值就像一个命令行参数。特别是，在将属性设置在 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.Namespace" target="_blank" rel="noopener"><code>Namespace</code></a> 的返回值之前，解析器应用任何提供的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#type" target="_blank" rel="noopener">type</a> 转换参数。否则解析器使用原值:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--length'</span>, default=<span class="string">'10'</span>, type=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--width'</span>, default=<span class="number">10.5</span>, type=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args()</span><br><span class="line">Namespace(length=<span class="number">10</span>, width=<span class="number">10.5</span>)</span><br></pre></td></tr></table></figure>
<p>对于 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#nargs" target="_blank" rel="noopener">nargs</a> 等于 <code>?</code> 或 <code>*</code> 的位置参数， <code>default</code> 值在没有命令行参数出现时使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, nargs=<span class="string">'?'</span>, default=<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'a'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'a'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">Namespace(foo=<span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<p>提供 <code>default=argparse.SUPPRESS</code> 导致命令行参数未出现时没有属性被添加:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, default=argparse.SUPPRESS)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">Namespace()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'1'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'1'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>默认情况下，<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象将命令行参数当作简单字符串读入。然而，命令行字符串经常需要被当作其它的类型，比如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 或者 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 的 <code>type</code> 关键词参数允许任何的类型检查和类型转换。一般的内建类型和函数可以直接被 <code>type</code> 参数使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, type=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, type=open)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'2 temp.txt'</span>.split())</span><br><span class="line">Namespace(bar=&lt;_io.TextIOWrapper name=<span class="string">'temp.txt'</span> encoding=<span class="string">'UTF-8'</span>&gt;, foo=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>当 <code>type</code> 参数被应用到默认参数时，请参考 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#default" target="_blank" rel="noopener">default</a> 参数的部分。</p>
<p>type 也可以指定写入文件,通过指定 <code>mode=</code>, <code>bufsize=</code>, <code>encoding=</code> and <code>errors=</code> 等参数调用<code>open</code>方法打开文件。举个栗子,设定<code>FileType(&#39;w&#39;)</code> 参数可以设定创建一个可写的文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, type=argparse.FileType(<span class="string">'w'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'out.txt'</span>])</span><br><span class="line">Namespace(bar=&lt;_io.TextIOWrapper name=<span class="string">'out.txt'</span> encoding=<span class="string">'UTF-8'</span>&gt;)</span><br></pre></td></tr></table></figure>
<p><code>type=</code> can take any callable that takes a single string argument and returns the converted value:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">perfect_square</span><span class="params">(string)</span>:</span></span><br><span class="line"><span class="meta">... </span>    value = int(string)</span><br><span class="line"><span class="meta">... </span>    sqrt = math.sqrt(value)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> sqrt != int(sqrt):</span><br><span class="line"><span class="meta">... </span>        msg = <span class="string">"%r is not a perfect square"</span> % string</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">raise</span> argparse.ArgumentTypeError(msg)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> value</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, type=perfect_square)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'9'</span>])</span><br><span class="line">Namespace(foo=<span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'7'</span>])</span><br><span class="line">usage: PROG [-h] foo</span><br><span class="line">PROG: error: argument foo: <span class="string">'7'</span> <span class="keyword">is</span> <span class="keyword">not</span> a perfect square</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#choices" target="_blank" rel="noopener">choices</a> 关键词参数可能会使类型检查者更方便的检查一个范围的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, type=int, choices=range(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'7'</span>])</span><br><span class="line">Namespace(foo=<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'11'</span>])</span><br><span class="line">usage: PROG [-h] &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">PROG: error: argument foo: invalid choice: <span class="number">11</span> (choose <span class="keyword">from</span> <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<h3 id="choices"><a href="#choices" class="headerlink" title="choices"></a>choices</h3><p>一些命令行参数从一组受限制的值中获取。这些可以通过容器对象,借助<code>choice</code>关键字参数传递给 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 来处理，分析命令行时，将检查参数值，如果参数不是可接受的值之一，将显示错误消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&apos;game.py&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;move&apos;, choices=[&apos;rock&apos;, &apos;paper&apos;, &apos;scissors&apos;])</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&apos;rock&apos;])</span><br><span class="line">Namespace(move=&apos;rock&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&apos;fire&apos;])</span><br><span class="line">usage: game.py [-h] &#123;rock,paper,scissors&#125;</span><br><span class="line">game.py: error: argument move: invalid choice: &apos;fire&apos; (choose from &apos;rock&apos;,</span><br><span class="line">&apos;paper&apos;, &apos;scissors&apos;)</span><br></pre></td></tr></table></figure>
<p>需要注意的是 类型转换执行后执行检查, <code>choice</code>容器必须匹配这些类型声明。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'doors.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'door'</span>, type=int, choices=range(<span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(parser.parse_args([<span class="string">'3'</span>]))</span><br><span class="line">Namespace(door=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'4'</span>])</span><br><span class="line">usage: doors.py [-h] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">doors.py: error: argument door: invalid choice: <span class="number">4</span> (choose <span class="keyword">from</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>任何容器可以通过 <code>choice</code>值来传递参数,例如 list 和 set 对象,亦或者是支持的自定义容器。</p>
<h3 id="required"><a href="#required" class="headerlink" title="required"></a>required</h3><p>通常情况下,可以通过 <code>-f</code> and <code>--bar</code>参数声明可选参数,这些参数可以在命令行执行的时候被忽略。如果想把这些单数设置成必须参数，则需要在<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a>参数中将 require参数设置成True</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;, required=True)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&apos;--foo&apos;, &apos;BAR&apos;])</span><br><span class="line">Namespace(foo=&apos;BAR&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([])</span><br><span class="line">usage: argparse.py [-h] [--foo FOO]</span><br><span class="line">argparse.py: error: option --foo is required</span><br></pre></td></tr></table></figure>
<p>就像上述例子显示的情况一样。如果一个功能被标识为必须的，在命令行执行的时候,会不断报错。</p>
<blockquote>
<p>必须参数被认为不是一个好习惯。用户期望功能都是可选的,避免成为必须参数</p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>argparse</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library XML minidom</title>
    <url>/2020/03/11/python-standard-library-XML-minidom/</url>
    <content><![CDATA[<h1 id="python-标准库-minidom"><a href="#python-标准库-minidom" class="headerlink" title="python 标准库 minidom"></a>python 标准库 minidom</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200311order.png?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>每日一词：</p>
<p>Order  美音 [‘ɔrdər] 英音  [‘ɔː(r)də(r) ]</p>
<p>词根解释:</p>
<p>order,ord,ordin(ordain) = ord,ordin<br>来自拉丁语的ord,ordin 意为to order,变形为ordain。</p>
<p>n.顺序；命令；勋章；规则</p>
<p>v.命令；整理；定货；下令</p>
<p>网络订单；秩序；目</p>
<p>下面是一个本地翻译的例句:</p>
<p>  The <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.minidom.html#xml.dom.minidom.Node.writexml" target="_blank" rel="noopener"><code>writexml()</code></a> method now preserves the attribute order specified by the user. </p>
<p>此处的order结合上下文,我翻译成 <strong>规则</strong> </p>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.minidom.html#xml.dom.minidom.Node.writexml" target="_blank" rel="noopener"><code>writexml()</code></a> 方法允许用户保留属性<strong>规则</strong>声明.</p>
</blockquote>
<p><strong>源代码：</strong> <a href="https://hg.python.org/cpython/file/2.7/Lib/xml/dom/minidom.py" target="_blank" rel="noopener">Lib / xml / dom / minidom.py</a></p>
<p><code>xml.dom.minidom</code>是文档对象模型接口的最小实现，其API类似于其他语言。它的目标是比完整的DOM更简单，也更小。不熟悉DOM的用户应考虑使用该<code>xml.etree.ElementTree</code>模块进行XML处理。</p>
<blockquote>
<p>警告:该<code>xml.dom.minidom</code>模块对恶意构建的数据不安全。如果您需要解析不可信或未经身份验证的数据，请参阅  <a href="https://docs.python.org/zh-cn/3.8/library/xml.html#xml-vulnerabilities" target="_blank" rel="noopener">XML 漏洞</a> 。</p>
</blockquote>
<p>通常，DOM应用程序首先将一些XML解析为DOM。有了<code>xml.dom.minidom</code>，这是通过解析函数完成的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.dom.minidom <span class="keyword">import</span> parse, parseString</span><br><span class="line"></span><br><span class="line">dom1 = parse(<span class="string">'c:\\temp\\mydata.xml'</span>)  <span class="comment"># parse an XML file by name</span></span><br><span class="line"></span><br><span class="line">datasource = open(<span class="string">'c:\\temp\\mydata.xml'</span>)</span><br><span class="line">dom2 = parse(datasource)  <span class="comment"># parse an open file</span></span><br><span class="line"></span><br><span class="line">dom3 = parseString(<span class="string">'&lt;myxml&gt;Some data&lt;empty/&gt; some more data&lt;/myxml&gt;'</span>)</span><br></pre></td></tr></table></figure>
<p>该<code>parse()</code>函数可以采用文件名或打开的文件对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xml.dom.minidom.parse(filename_or_file[, parser[, bufsize]])</span><br></pre></td></tr></table></figure>
<p><code>Document</code>从给定的输入中被返回 。<em>filename_or_file</em>可以是文件名，也可以是文件类对象。<em>解析器</em>（如果有的话）必须是SAX2解析器对象。该函数将更改解析器的文档处理程序并激活命名空间支持; 其他解析器配置（如设置实体解析器）必须事先完成。</p>
<p>如果你在一个字符串中有XML，你可以使用这个<code>parseString()</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xml.dom.minidom.parseString(string[, parser])</span><br></pre></td></tr></table></figure>
<p>返回一个表示字符串的文档。 此方法为该字符串创建一个StringIO对象，并将其传递给parse（）。</p>
<p>这两个函数都会返回一个<code>Document</code>代表文档内容的对象。</p>
<p><code>parse()</code>和<code>parseString()</code>功能做的是一个“DOM生成器”，可以从任何SAX解析器解析接受事件并将它们转换成DOM树连接XML解析器。这些功能的名称可能是误导性的，但在学习接口时很容易理解。文档的解析将在这些函数返回之前完成; 只是这些函数本身不提供解析器实现。</p>
<p>您也可以通过调用“DOM实现”对象上的方法来创建文档。 您可以通过调用xml.dom包中的getDOMImplementation（）函数或xml.dom.minidom模块来获取此对象。 使用xml.dom.minidom模块中的实现将始终从minidom实现中返回一个Document实例，而来自xml.dom的版本可能会提供一个替代实现（如果您安装了PyXML包，则可能会发生这种情况）。 一旦你有一个文档，你可以添加子节点来填充DOM：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.dom.minidom <span class="keyword">import</span> getDOMImplementation</span><br><span class="line"></span><br><span class="line">impl = getDOMImplementation()</span><br><span class="line"></span><br><span class="line">newdoc = impl.createDocument(<span class="literal">None</span>, <span class="string">"some_tag"</span>, <span class="literal">None</span>)</span><br><span class="line">top_element = newdoc.documentElement</span><br><span class="line">text = newdoc.createTextNode(<span class="string">'Some textual content.'</span>)</span><br><span class="line">top_element.appendChild(text)</span><br></pre></td></tr></table></figure>
<p>一旦有了DOM文档对象，就可以通过其属性和方法访问XML文档的各个部分。这些属性在DOM规范中定义。文档对象的主要属性是<code>documentElement</code>属性。它为您提供了XML文档中的主要元素：包含所有其他元素的元素。这是一个示例程序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dom3 = parseString(<span class="string">"&lt;myxml&gt;Some data&lt;/myxml&gt;"</span>)</span><br><span class="line">assert dom3.documentElement.tagName == <span class="string">"myxml"</span></span><br></pre></td></tr></table></figure>
<p>当你完成一个DOM树时，你可以选择调用unlink（）方法来鼓励早期清理不需要的对象。 unlink（）是DOM API的一个xml.dom.minidom专用扩展，它呈现节点及其后代实质上是无用的。 否则，Python的垃圾收集器将最终处理树中的对象。</p>
<p>扩展内容</p>
<p> <a href="https://www.w3.org/TR/REC-DOM-Level-1/" target="_blank" rel="noopener">文档对象模型（DOM）1级规范</a> W3C推荐的DOM支持<code>xml.dom.minidom</code>。  </p>
<h2 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h2><p>Python的DOM API的定义是作为<code>xml.dom</code>模块文档的一部分给出的。本节列出了API和<code>xml.dom.minidom</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Node.unlink()</span><br></pre></td></tr></table></figure>
<p>打破DOM内的内部引用，以便在没有循环GC的情况下在Python版本上进行垃圾回收。 即使循环GC可用，使用它也可以更快地提供大量内存，因此，在不再需要DOM对象时立即调用它是很好的做法。 这只需要在Document对象上调用，但可以在子节点上调用以放弃该节点的子节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.writexml(writer, indent=&quot;&quot;, addindent=&quot;&quot;, newl=&quot;&quot;)</span><br></pre></td></tr></table></figure>
<p>将XML写入作者对象。 作者应该有一个与文件对象接口匹配的write（）方法。 缩进参数是当前节点的缩进。 addindent参数是用于当前子节点的递增缩进。 newl参数指定用于终止换行符的字符串。</p>
<p>对于Document节点，可以使用其他关键字参数编码来指定XML标头的编码字段。</p>
<p>在<em>3.8</em>版本中 <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.minidom.html#xml.dom.minidom.Node.writexml" target="_blank" rel="noopener"><code>writexml()</code></a> 方法允许用户保留属性规则声明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Node.toxml([encoding])</span><br></pre></td></tr></table></figure>
<p>将DOM表示的XML返回为字符串。</p>
<p>如果默认编码不能表示文档中的所有字符，那么没有参数时，XML标头不会指定编码，并且结果为Unicode字符串。使用UTF-8以外的编码对此字符串进行编码可能不正确，因为UTF-8是XML的默认编码。</p>
<p>使用显式<em>编码</em> [1]参数，结果是指定编码中的字节字符串。建议始终指定此参数。为避免<code>UnicodeError</code>出现无法表示的文本数据时出现异常，应将编码参数指定为“utf-8”。</p>
<p>在<em>3.8</em>版本中   <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.minidom.html#xml.dom.minidom.Node.toxml" target="_blank" rel="noopener"><code>toxml()</code></a>  方法允许用户保留属性规则声明</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Node.toprettyxml([indent=<span class="string">""</span>[, newl=<span class="string">""</span>[, encoding=<span class="string">""</span>]]])</span><br></pre></td></tr></table></figure>
<p>返回文档的完美版本。<em>indent</em> 指定缩进字符串，并默认为制表符; <em>newl</em>指定在每行末尾发射的字符串，默认为<code>\n</code>。</p>
<p>在<em>3.8</em>版本中    <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.minidom.html#xml.dom.minidom.Node.toprettyxml" target="_blank" rel="noopener"><code>toprettyxml()</code></a>    方法允许用户保留属性规则声明</p>
<p>以下标准DOM方法对xml.dom.minidom有特殊考虑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Node.cloneNode(deep)</span><br></pre></td></tr></table></figure>
<p>尽管此方法出现在与Python 2.0一起打包的xml.dom.minidom版本中，但它被严重破坏。 这已为后续版本纠正。</p>
<h2 id="DOM例子"><a href="#DOM例子" class="headerlink" title="DOM例子"></a>DOM例子</h2><p>这个示例程序是一个简单程序的相当现实的例子。在这种特殊情况下，我们没有充分利用DOM的灵活性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.dom.minidom</span><br><span class="line"></span><br><span class="line">document = <span class="string">"""\</span></span><br><span class="line"><span class="string">&lt;slideshow&gt;</span></span><br><span class="line"><span class="string">&lt;title&gt;Demo slideshow&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;slide&gt;&lt;title&gt;Slide title&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;point&gt;This is a demo&lt;/point&gt;</span></span><br><span class="line"><span class="string">&lt;point&gt;Of a program for processing slides&lt;/point&gt;</span></span><br><span class="line"><span class="string">&lt;/slide&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;slide&gt;&lt;title&gt;Another demo slide&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;point&gt;It is important&lt;/point&gt;</span></span><br><span class="line"><span class="string">&lt;point&gt;To have more than&lt;/point&gt;</span></span><br><span class="line"><span class="string">&lt;point&gt;one slide&lt;/point&gt;</span></span><br><span class="line"><span class="string">&lt;/slide&gt;</span></span><br><span class="line"><span class="string">&lt;/slideshow&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">dom = xml.dom.minidom.parseString(document)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getText</span><span class="params">(nodelist)</span>:</span></span><br><span class="line">    rc = []</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodelist:</span><br><span class="line">        <span class="keyword">if</span> node.nodeType == node.TEXT_NODE:</span><br><span class="line">            rc.append(node.data)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(rc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleSlideshow</span><span class="params">(slideshow)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&lt;html&gt;"</span></span><br><span class="line">    handleSlideshowTitle(slideshow.getElementsByTagName(<span class="string">"title"</span>)[<span class="number">0</span>])</span><br><span class="line">    slides = slideshow.getElementsByTagName(<span class="string">"slide"</span>)</span><br><span class="line">    handleToc(slides)</span><br><span class="line">    handleSlides(slides)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&lt;/html&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleSlides</span><span class="params">(slides)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> slide <span class="keyword">in</span> slides:</span><br><span class="line">        handleSlide(slide)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleSlide</span><span class="params">(slide)</span>:</span></span><br><span class="line">    handleSlideTitle(slide.getElementsByTagName(<span class="string">"title"</span>)[<span class="number">0</span>])</span><br><span class="line">    handlePoints(slide.getElementsByTagName(<span class="string">"point"</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleSlideshowTitle</span><span class="params">(title)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&lt;title&gt;%s&lt;/title&gt;"</span> % getText(title.childNodes)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleSlideTitle</span><span class="params">(title)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&lt;h2&gt;%s&lt;/h2&gt;"</span> % getText(title.childNodes)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handlePoints</span><span class="params">(points)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&lt;ul&gt;"</span></span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">        handlePoint(point)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&lt;/ul&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handlePoint</span><span class="params">(point)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&lt;li&gt;%s&lt;/li&gt;"</span> % getText(point.childNodes)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleToc</span><span class="params">(slides)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> slide <span class="keyword">in</span> slides:</span><br><span class="line">        title = slide.getElementsByTagName(<span class="string">"title"</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"&lt;p&gt;%s&lt;/p&gt;"</span> % getText(title.childNodes)</span><br><span class="line"></span><br><span class="line">handleSlideshow(dom)</span><br></pre></td></tr></table></figure>
<h2 id="minidom和DOM标准"><a href="#minidom和DOM标准" class="headerlink" title="minidom和DOM标准"></a>minidom和DOM标准</h2><p>该<code>xml.dom.minidom</code>模块本质上是一个DOM 1.0兼容的DOM，具有一些DOM 2功能（主要是名称空间功能）。</p>
<p>在Python中使用DOM接口非常简单。以下映射规则适用：</p>
<ul>
<li><p>接口通过实例对象访问。应用程序不应该自己实例化类; 他们应该使用<code>Document</code>对象上可用的创建者函数。派生接口支持来自基本接口的所有操作（和属性）以及任何新的操作。</p>
</li>
<li><p>操作被用作方法。由于DOM只使用<a href="https://docs.python.org/2.7/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a>参数，参数按正常顺序传递（从左到右）。没有可选参数。<code>void</code>操作返回<code>None</code>。</p>
</li>
<li><p>IDL属性映射到实例属性。为了与Python的OMG IDL语言映射兼容，<code>foo</code>还可以通过访问器方法<code>_get_foo()</code>和访问属性<code>_set_foo()</code>。<code>readonly</code>属性不能改变; 这不是在运行时强制执行的。</p>
</li>
<li><p>类型<code>short int</code>，<code>unsigned int</code>，<code>unsigned long long</code>，和<code>boolean</code>所有映射到Python的整数对象。</p>
</li>
<li><p>DOMString类型映射到Python字符串。 xml.dom.minidom支持字节或Unicode字符串，但通常会生成Unicode字符串。 DOMString类型的值也可以是None，其中允许通过W3C的DOM规范获得IDL空值。</p>
</li>
<li><p>常量声明映射到各自范围内的变量（例如xml.dom.minidom.Node.PROCESSING_INSTRUCTION_NODE）; 他们不能改变。</p>
</li>
<li><p>DOMException目前在xml.dom.minidom中不受支持。 相反，xml.dom.minidom使用标准Python异常，例如TypeError和AttributeError。</p>
</li>
<li><p><code>NodeList</code>对象是使用Python的内置列表类型实现的。从Python 2.2开始，这些对象提供了DOM规范中定义的接口，但是对于早期版本的Python，它们不支持官方API。然而，它们比W3C建议中定义的接口更“Pythonic”。</p>
</li>
</ul>
<p>以下接口在xml.dom.minidom中没有实现：</p>
<ul>
<li><p><code>DOMTimeStamp</code></p>
</li>
<li><p><code>EntityReference</code></p>
</li>
</ul>
<p>其中大多数反映了XML文档中的信息，这对大多数DOM用户来说并不普遍。</p>
<h4 id="脚注、"><a href="#脚注、" class="headerlink" title="脚注、"></a>脚注、</h4><blockquote>
<p>XML输出中包含的编码字符串应符合相应的标准。例如，“UTF-8”是有效的，但“UTF8”不是。请参阅<a href="https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl和https://www.iana.org/assignments/character-sets/character-sets.xhtml。" target="_blank" rel="noopener">https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl和https://www.iana.org/assignments/character-sets/character-sets.xhtml。</a></p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>XML</tag>
        <tag>minidom</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library xml sax</title>
    <url>/2020/03/12/python-standard-library-xml-sax/</url>
    <content><![CDATA[<h1 id="python-标准库-xml-sax"><a href="#python-标准库-xml-sax" class="headerlink" title="python 标准库  xml.sax"></a>python 标准库  xml.sax</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200312_youmo.jpg?raw=true" alt></p>
<a id="more"></a>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p> <a href="https://github.com/python/cpython/tree/3.8/Lib/xml/sax/__init__.py" target="_blank" rel="noopener">Lib/xml/sax/<strong>init</strong>.py</a> </p>
<p>该<code>xml.sax</code>软件包提供了许多实现Python简单API（SAX）接口的模块。程序包本身提供SAX异常和SAX API用户最常使用的便利功能。</p>
<p>Warning</p>
<p>该<code>xml.sax</code>模块对恶意构建的数据不安全。如果您需要解析不可信或未经身份验证的数据，请参阅XML漏洞。</p>
<p>便利功能是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml.sax.make_parser([parser_list])</span><br></pre></td></tr></table></figure>
<p>创建并返回一个SAX <code>XMLReader</code>对象。找到的第一个解析器将被使用。如果提供了<em>parser_list</em>，它必须是一个字符串序列，这些字符串命名具有名为函数的模块<code>create_parser()</code>。<em>parser_list中</em>列出的模块将在解析器默认列表中的模块之前使用。</p>
<p> <em>在 3.8 版更改</em> ,parser_list参数可以是认可可迭代对象，不仅只是列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml.sax.parse(filename_or_stream, handler[, error_handler])</span><br></pre></td></tr></table></figure>
<p>创建一个SAX解析器并用它来解析文档。 以filename_or_stream形式传入的文档可以是文件名或文件对象。 处理程序参数需要是SAX ContentHandler实例。 如果给出error_handler，它必须是一个SAX ErrorHandler实例; 如果省略，则会在所有错误中引发SAXParseException。 没有回报价值; 所有的工作必须由传入的处理程序来完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml.sax.parseString(string, handler[, error_handler])</span><br></pre></td></tr></table></figure>
<p>与parse（）类似，但从作为参数接收的缓冲区字符串中解析。</p>
<p>典型的SAX应用程序使用三种对象：读者，处理程序和输入源。在这种情况下，“读者”是解析器的另一个术语，即某些代码从输入源读取字节或字符，并产生一系列事件。事件然后被分配给处理程序对象，即读者调用处理程序上的方法。因此，SAX应用程序必须获取reader对象，创建或打开输入源，创建处理程序并将这些对象连接在一起。作为准备的最后一步，读者被调用来解析输入。在解析过程中，处理程序对象的方法基于来自输入数据的结构和语法事件来调用。</p>
<p>对于这些对象，只有接口是相关的; 它们通常不是由应用程序本身实例化的。 由于Python没有明确的接口概念，因此它们被正式引入为类，但是应用程序可能会使用不从所提供的类继承的实现。 InputSource，Locator，Attributes，AttributesNS和XMLReader接口在模块xml.sax.xmlreader中定义。 处理程序接口在xml.sax.handler中定义。 为了方便，InputSource（通常直接实例化）和处理程序类也可以从xml.sax中获得。 这些接口如下所述。</p>
<p>除这些类外，<code>xml.sax</code>还提供以下异常类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.sax.SAXException(msg[, exception])</span><br></pre></td></tr></table></figure>
<p>封装XML错误或警告。该类可以包含来自XML解析器或应用程序的基本错误或警告信息：它可以被分类以提供附加功能或添加本地化。请注意，虽然<code>ErrorHandler</code>界面中定义的处理程序会接收此异常的实例，但实际并不需要引发异常 - 它也可用作信息容器。</p>
<p>实例化时，<em>msg</em> 应该是错误的可读描述。可选的<em>异常</em>参数（如果给出）应该是<code>None</code>解析代码捕获的异常，并作为信息传递。</p>
<p>这是其他SAX异常类的基类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.sax.SAXParseException(msg, exception, locator)</span><br></pre></td></tr></table></figure>
<p>解析错误引发SAXException的子类。 将此类的实例传递给SAX ErrorHandler接口的方法，以提供有关分析错误的信息。 该类支持SAX Locator接口以及SAXException接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.sax.SAXNotRecognizedException(msg[, exception])</span><br></pre></td></tr></table></figure>
<p>当SAX XMLReader遇到无法识别的特征或属性时引发SAXException的子类。 SAX应用程序和扩展可能会将此类用于类似目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.sax.SAXNotSupportedException(msg[, exception])</span><br></pre></td></tr></table></figure>
<p>SAXException的子类在SAX XMLReader被要求启用不支持的功能或将属性设置为实现不支持的值时引发。 SAX应用程序和扩展可能会将此类用于类似目的。</p>
<p>扩展内容</p>
<p>SAX：XML的简单API这个站点是定义SAX API的焦点。 它提供了Java实现和在线文档。 实现和历史信息的链接也可用。 模块xml.sax.handler应用程序提供的对象的接口定义。 模块xml.sax.saxutils用于SAX应用程序的便捷函数。 模块xml.sax.xmlreader解析器提供的对象的接口定义。</p>
<h2 id="1-SAXException对象"><a href="#1-SAXException对象" class="headerlink" title="1. SAXException对象"></a>1. SAXException对象</h2><p>该<code>SAXException</code>异常类支持下列方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SAXException.getMessage()</span><br></pre></td></tr></table></figure>
<p>返回描述错误情况的可读信息。</p>
<p><a href="javascript:;" target="_blank" rel="noopener">纠错</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SAXException.getException()</span><br></pre></td></tr></table></figure>
<p>返回一个封装的异常对象，或者<code>None</code>。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>xml</tag>
        <tag>sax</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library modulefinder</title>
    <url>/2020/03/17/python-standard-library-modulefinder/</url>
    <content><![CDATA[<h1 id="python-标准库-modulefinder"><a href="#python-标准库-modulefinder" class="headerlink" title="python 标准库 modulefinder"></a>python 标准库 modulefinder</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200317_finder.jpg?raw=true" alt></p>
<a id="more"></a>
<p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/modulefinder.py" target="_blank" rel="noopener">Lib/modulefinder.py</a></p>
<hr>
<p>该模块提供了一个 <a href="https://docs.python.org/zh-cn/3.8/library/modulefinder.html#modulefinder.ModuleFinder" target="_blank" rel="noopener"><code>ModuleFinder</code></a> 类，可用于确定脚本导入的模块集。 <code>modulefinder.py</code> 也可以作为脚本运行，给出 Python 脚本的文件名作为参数，之后将打印导入模块的报告。</p>
<ul>
<li><p><code>modulefinder.`</code>AddPackagePath`(<em>pkg_name</em>, <em>path</em>)</p>
<p>记录名为 <em>pkg_name</em> 的包可以在指定的 <em>path</em> 中找到。</p>
</li>
<li><p><code>modulefinder.`</code>ReplacePackage`(<em>oldname</em>, <em>newname</em>)</p>
<p>允许指定名为 <em>oldname</em> 的模块实际上是名为 <em>newname</em> 的包。</p>
</li>
<li><p><em>class</em> <code>modulefinder.`</code>ModuleFinder`(<em>path=None</em>, <em>debug=0</em>, <em>excludes=[]</em>, <em>replace_paths=[]</em>)</p>
<p>该类提供 <a href="https://docs.python.org/zh-cn/3.8/library/modulefinder.html#modulefinder.ModuleFinder.run_script" target="_blank" rel="noopener"><code>run_script()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/modulefinder.html#modulefinder.ModuleFinder.report" target="_blank" rel="noopener"><code>report()</code></a> 方法，用于确定脚本导入的模块集。 <em>path</em> 可以是搜索模块的目录列表；如果没有指定，则使用 <code>sys.path</code> 。 <em>debug</em> 设置调试级别；更高的值使类打印调试消息，关于它正在做什么。 <em>excludes</em> 是要从分析中排除的模块名称列表。 <em>replace_paths</em> 是将在模块路径中替换的 <code>(oldpath, newpath)</code> 元组的列表。<code>report</code>()将报告打印到标准输出，列出脚本导入的模块及其路径，以及缺少或似乎缺失的模块。<code>run_script</code>(<em>pathname</em>)分析 <em>pathname</em> 文件的内容，该文件必须包含 Python 代码。<code>modules</code>一个将模块名称映射到模块的字典。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/modulefinder.html#modulefinder-example" target="_blank" rel="noopener">ModuleFinder 的示例用法</a>。</p>
</li>
</ul>
<h2 id="ModuleFinder-的示例用法"><a href="#ModuleFinder-的示例用法" class="headerlink" title="ModuleFinder 的示例用法"></a><a href="https://docs.python.org/zh-cn/3.8/library/modulefinder.html#modulefinder.ModuleFinder" target="_blank" rel="noopener"><code>ModuleFinder</code></a> 的示例用法</h2><p>稍后将分析的脚本（bacon.py）:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re, itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> baconhameggs</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> guido.python.ham</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>将输出 bacon.py 报告的脚本:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modulefinder <span class="keyword">import</span> ModuleFinder</span><br><span class="line"></span><br><span class="line">finder = ModuleFinder()</span><br><span class="line">finder.run_script(<span class="string">'bacon.py'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Loaded modules:'</span>)</span><br><span class="line"><span class="keyword">for</span> name, mod <span class="keyword">in</span> finder.modules.items():</span><br><span class="line">    print(<span class="string">'%s: '</span> % name, end=<span class="string">''</span>)</span><br><span class="line">    print(<span class="string">','</span>.join(list(mod.globalnames.keys())[:<span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-'</span>*<span class="number">50</span>)</span><br><span class="line">print(<span class="string">'Modules not imported:'</span>)</span><br><span class="line">print(<span class="string">'\n'</span>.join(finder.badmodules.keys()))</span><br></pre></td></tr></table></figure>
<p>输出样例（可能因架构而异）:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Loaded modules:</span><br><span class="line">_types:</span><br><span class="line">copyreg:  _inverted_registry,_slotnames,__all__</span><br><span class="line">sre_compile:  isstring,_sre,_optimize_unicode</span><br><span class="line">_sre:</span><br><span class="line">sre_constants:  REPEAT_ONE,makedict,AT_END_LINE</span><br><span class="line">sys:</span><br><span class="line">re:  __module__,finditer,_expand</span><br><span class="line">itertools:</span><br><span class="line">__main__:  re,itertools,baconhameggs</span><br><span class="line">sre_parse:  _PATTERNENDERS,SRE_FLAG_UNICODE</span><br><span class="line">array:</span><br><span class="line">types:  __module__,IntType,TypeType</span><br><span class="line">---------------------------------------------------</span><br><span class="line">Modules <span class="keyword">not</span> imported:</span><br><span class="line">guido.python.ham</span><br><span class="line">baconhameggs</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>modulefinder</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library xml dom</title>
    <url>/2020/03/13/python-standard-library-xml-dom/</url>
    <content><![CDATA[<h1 id="python-标准库-XML-dom-对象API"><a href="#python-标准库-XML-dom-对象API" class="headerlink" title="python 标准库 XML dom 对象API"></a>python 标准库 XML dom 对象API</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200313_bravo.gif?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>bravo英音：[‘brɑ:’vəu]美音：[‘brɑ’vo]</p>
<p>名词 n.</p>
<ol>
<li><p>喝彩声</p>
</li>
<li><p>暴徒</p>
</li>
</ol>
<p>感叹词 int.</p>
<ol>
<li>好极了</li>
</ol>
<p>这个词必然来自拉丁语，所以法语意大利语西班牙语都有，英语也有了</p>
</blockquote>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/python/cpython/tree/3.8/Lib/xml/dom/__init__.py" target="_blank" rel="noopener">Lib/xml/dom/<strong>init</strong>.py</a> </p>
<p>本节介绍 python 中DOM 模块。</p>
<p>文档对象模型或“DOM”是万维网联盟（W3C）的跨语言API，用于访问和修改XML文档。DOM实现将XML文档呈现为树结构，或者允许客户端代码从头构建这样的结构。然后通过提供众所周知的接口的一组对象来访问该结构。</p>
<p>DOM对随机访问应用程序非常有用。SAX只允许您一次查看文档的一个位。如果您正在查看一个SAX元素，则无法访问其他元素。如果您正在查看文本节点，则无法访问包含元素。当你编写一个SAX应用程序时，你需要跟踪自己代码中某个地方的程序在文档中的位置。SAX不会为你做。另外，如果你需要在XML文档中向前看，你只是运气不好。</p>
<p>某些应用程序在事件驱动模型中无法访问树是根本不可能的。当然，你可以在SAX事件中自己构建某种树，但是DOM允许你避免编写代码。DOM是XML数据的标准树表示。</p>
<p>文档对象模型由W3C分阶段定义，或者在其术语中定义为“级别”。API的Python映射基本上基于DOM Level 2推荐。</p>
<p>通常，DOM应用程序首先将一些XML解析为DOM。 如何实现这一点完全没有被DOM Level 1覆盖，而Level 2只提供了有限的改进：有一个DOMImplementation对象类，它提供了对文档创建方法的访问，但没有办法访问XML读取器/解析器/文档构建器 独立于实现的方式。 在没有现有Document对象的情况下，也没有明确定义的方式来访问这些方法。 在Python中，每个DOM实现将提供一个函数 <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.html#xml.dom.getDOMImplementation" target="_blank" rel="noopener"><code>getDOMImplementation()</code></a>。 DOM Level 3添加了一个Load / Store规范，该规范为读者定义了一个接口，但是这在Python标准库中尚不可用。</p>
<p>一旦有了DOM文档对象，就可以通过其属性和方法访问XML文档的各个部分。这些属性在DOM规范中定义; 这部分参考手册描述了Python中规范的解释。</p>
<p>W3C提供的规范定义了用于Java，ECMAScript和OMG IDL的DOM API。这里定义的Python映射很大程度上基于IDL版本的规范，但不需要严格的遵从（尽管实现可以自由支持来自IDL的严格映射）。有关映射要求的详细讨论，请参阅一致性部分。</p>
<p>扩展内容</p>
<p> <a href="https://www.w3.org/TR/DOM-Level-2-Core/" target="_blank" rel="noopener">文档对象模型（DOM）Level 2规范</a> </p>
<p>Python DOM API所基于的W3C推荐标准。</p>
<p><a href="https://www.w3.org/TR/REC-DOM-Level-1/" target="_blank" rel="noopener">文档对象模型（DOM）1级规范</a> </p>
<p>W3C推荐的DOM支持<code>xml.dom.minidom</code>。</p>
<p><a href="http://www.omg.org/spec/PYTH/1.2/PDF" target="_blank" rel="noopener">Python语言映射规范</a></p>
<p>这指定了从OMG IDL到Python的映射。  </p>
<h2 id="模块内容"><a href="#模块内容" class="headerlink" title="模块内容"></a>模块内容</h2><p>将<code>xml.dom</code>包含以下功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml.dom.registerDOMImplementation(name, factory)</span><br></pre></td></tr></table></figure>
<p>注册<em>工厂</em>名称为功能<em>名称</em>。工厂函数应该返回一个实现<code>DOMImplementation</code>接口的对象。工厂函数可以每次都返回相同的对象，或者针对每次调用返回一个新对象，以适合特定的实现（例如，如果该实现支持一些定制）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml.dom.getDOMImplementation([name[, features]])</span><br></pre></td></tr></table></figure>
<p>返回一个合适的DOM实现。 该名称是众所周知的，DOM实现的模块名称或None。 如果不是None，则导入相应的模块，并在导入成功时返回<code>DOMImplementation</code>对象。 如果未给出名称，并且已设置环境变量PYTHON_DOM，则使用此变量查找实现。</p>
<p>如果没有给出名称，这将检查可用实现以找到具有所需功能集的实现。如果没有找到实现，请举一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a> 。<code>(feature, version)</code>要素列表必须是<code>hasFeature()</code>在可用<code>DOMImplementation</code>对象上传递给方法的一系列对。</p>
<p>还提供了一些常量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml.dom.EMPTY_NAMESPACE</span><br></pre></td></tr></table></figure>
<p>用于指示没有名称空间与DOM中的节点关联的值。 这通常可以作为节点的<code>namespaceURI</code>找到，或者用作名称空间特定方法的<code>namespaceURI</code>参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml.dom.XML_NAMESPACE</span><br></pre></td></tr></table></figure>
<p>与保留前缀关联的名称空间URI <code>xml</code>，由<a href="https://www.w3.org/TR/REC-xml-names/" target="_blank" rel="noopener">XML中</a>的<a href="https://www.w3.org/TR/REC-xml-names/" target="_blank" rel="noopener">Namespaces</a>定义（第4节）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml.dom.XMLNS_NAMESPACE</span><br></pre></td></tr></table></figure>
<p>由<a href="https://www.w3.org/TR/DOM-Level-2-Core/core.html" target="_blank" rel="noopener">文档对象模型（DOM）Level 2 Core Specification</a>（第1.1.8节）定义的名称空间声明的名称空间URI 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml.dom.XHTML_NAMESPACE</span><br></pre></td></tr></table></figure>
<p>由<a href="https://www.w3.org/TR/xhtml1/" target="_blank" rel="noopener">XHTML 1.0</a>定义的XHTML名称空间的URI <a href="https://www.w3.org/TR/xhtml1/" target="_blank" rel="noopener">：可扩展超文本标记语言</a>（3.1.1节）。</p>
<p>另外，xml.dom包含一个基本的Node类和DOM异常类。 这个模块提供的Node类没有实现DOM规范定义的任何方法或属性; 具体的DOM实现必须提供这些。 作为此模块一部分提供的Node类确实提供了用于具体Node对象上的nodeType属性的常量; 它们位于类内而不是模块级，以符合DOM规范。</p>
<h2 id="DOM中的对象"><a href="#DOM中的对象" class="headerlink" title="DOM中的对象"></a>DOM中的对象</h2><p>DOM的权威性文档是W3C的DOM规范。</p>
<p>请注意，DOM属性也可以作为节点来操作，而不是简单的字符串。然而，你必须这样做是非常罕见的，所以这种用法还没有记录。</p>
<table>
<thead>
<tr>
<th style="text-align:left">接口</th>
<th style="text-align:left">分块</th>
<th style="text-align:left">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DOMImplementation</td>
<td style="text-align:left">DOMImplementation对象</td>
<td style="text-align:left">接口的底层实现。</td>
</tr>
<tr>
<td style="text-align:left">Node</td>
<td style="text-align:left">节点对象</td>
<td style="text-align:left">文档中大多数对象的基本接口。</td>
</tr>
<tr>
<td style="text-align:left">NodeList</td>
<td style="text-align:left">NodeList对象</td>
<td style="text-align:left">一系列节点的接口。</td>
</tr>
<tr>
<td style="text-align:left">DocumentType</td>
<td style="text-align:left">DocumentType对象</td>
<td style="text-align:left">关于处理文档所需声明的信息。</td>
</tr>
<tr>
<td style="text-align:left">Document</td>
<td style="text-align:left">文档对象</td>
<td style="text-align:left">表示整个文档的对象。</td>
</tr>
<tr>
<td style="text-align:left">Element</td>
<td style="text-align:left">元素对象</td>
<td style="text-align:left">文档层次结构中的元素节点。</td>
</tr>
<tr>
<td style="text-align:left">ATTR</td>
<td style="text-align:left">属性对象</td>
<td style="text-align:left">元素节点上的属性值节点。</td>
</tr>
<tr>
<td style="text-align:left">Comment</td>
<td style="text-align:left">注释对象</td>
<td style="text-align:left">在源文档中注释的表示形式。</td>
</tr>
<tr>
<td style="text-align:left">Text</td>
<td style="text-align:left">文本和CDATASection对象</td>
<td style="text-align:left">包含文档中文本内容的节点。</td>
</tr>
<tr>
<td style="text-align:left">ProcessingInstruction</td>
<td style="text-align:left">ProcessingInstruction对象</td>
<td style="text-align:left">处理指令表示。</td>
</tr>
</tbody>
</table>
<p>附加部分描述了在Python中使用DOM定义的异常。</p>
<h3 id="DOMImplementation对象"><a href="#DOMImplementation对象" class="headerlink" title="DOMImplementation对象"></a>DOMImplementation对象</h3><p><code>DOMImplementation</code>接口为应用程序提供了一种方法来确定他们正在使用的DOM中特定功能的可用性。 DOM Level 2增加了使用<code>DOMImplementation</code>创建新的<code>Document</code>和<code>DocumentType</code>对象的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DOMImplementation.hasFeature(feature, version)</span><br></pre></td></tr></table></figure>
<p>如果实现了一对字符串<em>功能</em>和<em>版本</em>标识的功能，则返回true 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DOMImplementation.createDocument(namespaceUri, qualifiedName, doctype)</span><br></pre></td></tr></table></figure>
<p>使用具有给定<code>namespaceUri</code>和<code>qualifiedName</code>的子元素对象返回一个新的Document对象（DOM的根）。 doctype必须是由 <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.html#xml.dom.DOMImplementation.createDocumentType" target="_blank" rel="noopener"><code>createDocumentType()</code></a> 或None创建的DocumentType对象。 在Python DOM API中，前两个参数也可以是None，以表示不要创建Element子元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DOMImplementation.createDocumentType(qualifiedName, publicId, systemId)</span><br></pre></td></tr></table></figure>
<p>返回一个<code>DocumentType</code>封装给定的<em>qualifiedName</em>，<em>publicId</em>和<em>systemId</em>字符串的新对象，表示包含在XML文档类型声明中的信息。</p>
<h3 id="节点对象"><a href="#节点对象" class="headerlink" title="节点对象"></a>节点对象</h3><p>XML文档的所有组件都是Node的子类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.nodeType</span><br></pre></td></tr></table></figure>
<p>表示节点类型的整数。 这些类型的符号常量位于Node对象上：ELEMENT_NODE，ATTRIBUTE_NODE，TEXT_NODE，CDATA_SECTION_NODE，ENTITY_NODE，PROCESSING_INSTRUCTION_NODE，COMMENT_NODE，DOCUMENT_NODE，DOCUMENT_TYPE_NODE，NOTATION_NODE。 这是一个只读属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.parentNode</span><br></pre></td></tr></table></figure>
<p>当前节点的父节点，或文档节点的None。 该值始终是一个Node对象或None。 对于元素节点，这将是父元素，除了根元素，在这种情况下它将是Document对象。 对于Attr节点，这总是无。 这是一个只读属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.attributes</span><br></pre></td></tr></table></figure>
<p>一个<code>NamedNodeMap</code>属性对象。只有元素才具有实际的价值; 其他人提供<code>None</code>这个属性。这是一个只读属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.previousSibling</span><br></pre></td></tr></table></figure>
<p>紧跟在同一父节点之前的节点。例如，在<em>自身</em>元素的开始标记之前有一个结束标记的元素。当然，XML文档不仅仅包含元素，所以以前的兄弟可以是文本，评论或其他东西。如果此节点是父项的第一个子项，则此属性将为<code>None</code>。这是一个只读属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.nextSibling</span><br></pre></td></tr></table></figure>
<p>紧跟在这个父节点之后的节点。另见<code>previousSibling</code>。如果这是父项的最后一个子项，则此属性将为<code>None</code>。这是一个只读属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.childNodes</span><br></pre></td></tr></table></figure>
<p>此节点中包含的节点列表。这是一个只读属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.firstChild</span><br></pre></td></tr></table></figure>
<p>节点的第一个孩子，如果有的话，或者<code>None</code>。这是一个只读属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.lastChild</span><br></pre></td></tr></table></figure>
<p>节点的最后一个子节点，如果有的话，或者<code>None</code>。这是一个只读属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.localName</span><br></pre></td></tr></table></figure>
<p>如果有冒号，冒号后面的部分是冒号，否则整个tagName。 该值是一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.prefix</span><br></pre></td></tr></table></figure>
<p>tagName在冒号前面的部分（如果有），否则为空字符串。 该值是一个字符串，或None。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.namespaceURI</span><br></pre></td></tr></table></figure>
<p>与元素名称关联的名称空间。这将是一个字符串或<code>None</code>。这是一个只读属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.nodeName</span><br></pre></td></tr></table></figure>
<p>这对每种节点类型都有不同的含义; 有关详细信息，请参阅DOM规范。 您始终可以从另一个属性获取您在此处获得的信息，例如元素的tagName属性或属性的name属性。 对于所有节点类型，此属性的值将是一个字符串或None。 这是一个只读属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.nodeValue</span><br></pre></td></tr></table></figure>
<p>这对每种节点类型都有不同的含义; 有关详细信息，请参阅DOM规范。情况类似于<code>nodeName</code>。该值是一个字符串或<code>None</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.hasAttributes()</span><br></pre></td></tr></table></figure>
<p>如果节点具有任何属性，则返回true。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.hasChildNodes()</span><br></pre></td></tr></table></figure>
<p>如果节点有任何子节点，则返回true。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.isSameNode(other)</span><br></pre></td></tr></table></figure>
<p>如果<em>other</em> 引用与此节点相同的节点，则返回true 。这对于使用任何类型的代理体系结构的DOM实现特别有用（因为多个对象可以引用同一个节点）。</p>
<p>注意</p>
<p>这是基于建议的DOM Level 3 API，它仍处于“工作草案”阶段，但这个特定的界面似乎没有争议。来自W3C的改变不一定会影响Python DOM接口中的这种方法（尽管任何新的W3C API也会被支持）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.appendChild(newChild)</span><br></pre></td></tr></table></figure>
<p>将新的子节点添加到子节点列表末尾的此节点，并返回<em>newChild</em>。如果节点已经在树中，它将首先被移除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.insertBefore(newChild, refChild)</span><br></pre></td></tr></table></figure>
<p>在现有的子节点之前插入一个新的孩子节点。 它必须是refChild是这个节点的子节点的情况; 如果不是，则引发ValueError。 返回newChild返回。 如果refChild为None，它将在子列表的末尾插入newChild。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.removeChild(oldChild)</span><br></pre></td></tr></table></figure>
<p>删除一个子节点。 oldChild必须是该节点的子节点; 如果不是，则引发ValueError。 oldChild成功返回。 如果oldChild不会进一步使用，则应调用其unlink（）方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.replaceChild(newChild, oldChild)</span><br></pre></td></tr></table></figure>
<p>用新节点替换现有节点。<em>oldChild</em>必须是这个节点的子节点; 如果没有，则会提出<code>ValueError</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.normalize()</span><br></pre></td></tr></table></figure>
<p>加入相邻的文本节点，以便所有文本段都作为单个<code>Text</code>实例存储。这为许多应用程序简化了从DOM树处理文本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node.cloneNode(deep)</span><br></pre></td></tr></table></figure>
<p>克隆这个节点。设置<em>deep</em> 意味着克隆所有子节点。这将返回克隆。</p>
<h3 id="NodeList对象"><a href="#NodeList对象" class="headerlink" title="NodeList对象"></a>NodeList对象</h3><p>NodeList表示一系列节点。 这些对象在DOM核心推荐中以两种方式使用：一个Element对象提供一个作为其子节点列表，Node的getElementsByTagName（）和getElementsByTagNameNS（）方法返回具有此接口的对象以表示查询结果。</p>
<p>DOM Level 2建议为这些对象定义了一个方法和一个属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NodeList.item(i)</span><br></pre></td></tr></table></figure>
<p>如果还有一个，则返回序列中的第<em>i</em> 项<code>None</code>。指数<em>i</em> 不得小于零或大于或等于序列的长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NodeList.length</span><br></pre></td></tr></table></figure>
<p>序列中的节点数量。</p>
<p>另外，Python DOM接口要求提供一些额外的支持，以允许NodeList对象用作Python序列。 所有的NodeList实现都必须包含对<strong>len </strong>（）和<strong>getitem </strong>（）的支持; 这允许迭代NodeList中的for语句并正确支持len（）内置函数。</p>
<p>如果一个DOM实现支持文档的修改，那么<code>NodeList</code>实现也必须支持<a href="https://docs.python.org/2.7/reference/datamodel.html#object.__setitem__" target="_blank" rel="noopener"><code>__setitem__()</code></a>和<a href="https://docs.python.org/2.7/reference/datamodel.html#object.__delitem__" target="_blank" rel="noopener"><code>__delitem__()</code></a>方法。</p>
<h3 id="DocumentType对象"><a href="#DocumentType对象" class="headerlink" title="DocumentType对象"></a>DocumentType对象</h3><p>有关由文档声明的符号和实体的信息（包括解析器使用它并可以提供信息的外部子集）可从DocumentType对象中获得。 文档的DocumentType可以从Document对象的doctype属性中获得; 如果文档没有DOCTYPE声明，则文档的doctype属性将设置为None，而不是此接口的实例。</p>
<p><code>DocumentType</code>是专业化的<code>Node</code>，并增加了以下属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DocumentType.publicId</span><br></pre></td></tr></table></figure>
<p>文档类型定义的外部子集的公共标识符。这将是一个字符串或<code>None</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DocumentType.systemId</span><br></pre></td></tr></table></figure>
<p>文档类型定义的外部子集的系统标识符。这将作为一个字符串的URI，或<code>None</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DocumentType.internalSubset</span><br></pre></td></tr></table></figure>
<p>从文档中提供完整内部子集的字符串。这不包括包含子集的括号。如果文档没有内部子集，应该是<code>None</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DocumentType.name</span><br></pre></td></tr></table></figure>
<p><code>DOCTYPE</code>声明中给出的根元素的名称（如果存在）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DocumentType.entities</span><br></pre></td></tr></table></figure>
<p>这是一个给出外部实体定义的NamedNodeMap。 对于不止一次定义的实体名称，只提供第一个定义（其他则根据XML建议的要求被忽略）。 如果信息不是由解析器提供的，或者没有定义实体，则这可能是None。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DocumentType.notations</span><br></pre></td></tr></table></figure>
<p>这是一个NamedNodeMap，给出了符号的定义。 对于不止一次定义的记法名称，只提供第一个定义（其他则根据XML建议的要求而被忽略）。 如果信息不是由解析器提供的，或者没有定义符号，则这可能是None。</p>
<h3 id="文档对象"><a href="#文档对象" class="headerlink" title="文档对象"></a>文档对象</h3><p> <code>Document</code>表示整个XML文档，包括其组成元素，属性，处理指令，注释等。请记住它从中继承属性<code>Node</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Document.documentElement</span><br></pre></td></tr></table></figure>
<p>文档的唯一根元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Document.createElement(tagName)</span><br></pre></td></tr></table></figure>
<p>创建并返回一个新的元素节点。 元素在创建时未插入到文档中。 您需要使用其他方法之一（如insertBefore（）或appendChild（））来显式插入它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Document.createElementNS(namespaceURI, tagName)</span><br></pre></td></tr></table></figure>
<p>用命名空间创建并返回一个新元素。 tagName可能有一个前缀。 元素在创建时未插入到文档中。 您需要使用其他方法之一（如insertBefore（）或appendChild（））来显式插入它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Document.createTextNode(data)</span><br></pre></td></tr></table></figure>
<p>创建并返回包含作为参数传递的数据的文本节点。与其他创建方法一样，这个方法不会将节点插入树中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Document.createComment(data)</span><br></pre></td></tr></table></figure>
<p>创建并返回包含作为参数传递的数据的注释节点。与其他创建方法一样，这个方法不会将节点插入树中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Document.createProcessingInstruction(target, data)</span><br></pre></td></tr></table></figure>
<p>创建并返回包含作为参数传递的<em>目标</em>和<em>数据</em>的处理指令节点。与其他创建方法一样，这个方法不会将节点插入树中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Document.createAttribute(name)</span><br></pre></td></tr></table></figure>
<p>创建并返回一个属性节点。 此方法不会将属性节点与任何特定元素相关联。 您必须在适当的Element对象上使用setAttributeNode（）来使用新创建的属性实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Document.createAttributeNS(namespaceURI, qualifiedName)</span><br></pre></td></tr></table></figure>
<p>用命名空间创建并返回一个属性节点。 tagName可能有一个前缀。 此方法不会将属性节点与任何特定元素相关联。 您必须在适当的Element对象上使用setAttributeNode（）来使用新创建的属性实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Document.getElementsByTagName(tagName)</span><br></pre></td></tr></table></figure>
<p>搜索所有具有特定元素类型名称的后代（直接子代，子代孩子等）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Document.getElementsByTagNameNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure>
<p>使用特定的命名空间URI和本地名搜索所有后代（直接的子节点，子节点的子节点等）。localname是前缀后的名称空间的一部分。</p>
<h3 id="元素对象"><a href="#元素对象" class="headerlink" title="元素对象"></a>元素对象</h3><p><code>Element</code>是node的一个子类，所以继承了该类的所有属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.tagName</span><br></pre></td></tr></table></figure>
<p>元素类型名称。在使用命名空间的文档中，它可能有冒号。该值是一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.getElementsByTagName(tagName)</span><br></pre></td></tr></table></figure>
<p>与<code>Document</code>类中的等同方法类似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.getElementsByTagNameNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure>
<p>与<code>Document</code>类中的等同方法相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.hasAttribute(name)</span><br></pre></td></tr></table></figure>
<p>如果元素具有按<em>名称</em> 命名的属性，则返回true 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.hasAttributeNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure>
<p>如果元素具有由<em>namespaceURI</em>和<em>localName</em>命名的属性，则返回true 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.getAttribute(name)</span><br></pre></td></tr></table></figure>
<p>以字符串形式返回按<em>名称</em> 命名的属性的值。如果不存在这样的属性，则返回空字符串，就好像该属性没有值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.getAttributeNode(attrname)</span><br></pre></td></tr></table></figure>
<p>返回<code>Attr</code>由<em>attrname</em>命名的属性的节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.getAttributeNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure>
<p>以字符串形式返回由<em>namespaceURI</em>和<em>localName</em>命名的属性的值。如果不存在这样的属性，则返回空字符串，就好像该属性没有值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.getAttributeNodeNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure>
<p>在给定<em>namespaceURI</em>和<em>localName的情况下</em>，将属性值作为节点返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.removeAttribute(name)</span><br></pre></td></tr></table></figure>
<p>按名称删除属性。如果没有匹配的属性，则引发<code>NotFoundErr</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.removeAttributeNode(oldAttr)</span><br></pre></td></tr></table></figure>
<p>如果存在，请从属性列表中删除并返回<em>oldAttr</em>。如果<em>oldAttr</em>不存在，则提出<code>NotFoundErr</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.removeAttributeNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure>
<p>按名称删除属性。请注意，它使用localName而不是qname。如果没有匹配属性，则不会引发异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.setAttribute(name, value)</span><br></pre></td></tr></table></figure>
<p>从字符串中设置一个属性值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.setAttributeNode(newAttr)</span><br></pre></td></tr></table></figure>
<p>将新的属性节点添加到元素，如果<code>name</code>属性匹配，则在必要时替换现有的属性。如果发生替换，则将返回旧的属性节点。如果<em>newAttr</em>已被使用，<code>InuseAttributeErr</code>将会被提出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.setAttributeNodeNS(newAttr)</span><br></pre></td></tr></table></figure>
<p>添加一个新的属性节点到元素中，如果<code>namespaceURI</code>和<code>localName</code>属性匹配，则在必要时替换现有的属性。如果发生替换，则将返回旧的属性节点。如果<em>newAttr</em>已被使用，<code>InuseAttributeErr</code>将会被提出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.setAttributeNS(namespaceURI, qname, value)</span><br></pre></td></tr></table></figure>
<p>给定一个<em>namespaceURI</em> 和一个<em>qname</em>，从一个字符串中设置一个属性值。请注意，qname是整个属性名称。这与以上不同。</p>
<h3 id="属性对象"><a href="#属性对象" class="headerlink" title="属性对象"></a>属性对象</h3><p><code>Attr</code>从<code>Node</code>中继承，所以继承了它的所有属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Attr.name</span><br></pre></td></tr></table></figure>
<p>属性名称。在使用命名空间的文档中，它可能包含冒号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Attr.localName</span><br></pre></td></tr></table></figure>
<p>如果有冒号，冒号后面的部分名称，否则为整个名称。这是一个只读属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Attr.prefix</span><br></pre></td></tr></table></figure>
<p>冒号前面的部分名称，如果有的话，否则为空字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Attr.value</span><br></pre></td></tr></table></figure>
<p>属性的文本值。这是该<code>nodeValue</code>属性的同义词。</p>
<h3 id="命名的节点映射对象"><a href="#命名的节点映射对象" class="headerlink" title="命名的节点映射对象"></a>命名的节点映射对象</h3><p><code>NamedNodeMap</code>并<em>没有</em>继承<code>Node</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NamedNodeMap.length</span><br></pre></td></tr></table></figure>
<p>属性列表的长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NamedNodeMap.item(index)</span><br></pre></td></tr></table></figure>
<p>返回具有特定索引的属性。您获取属性的顺序是任意的，但对于DOM的生命周期将保持一致。每个项目是一个属性节点。通过<code>value</code>属性获取它的值。</p>
<p>也有实验方法给这个类更多的映射行为。您可以使用它们，也可以<code>getAttribute*()</code>在<code>Element</code>对象上使用标准化的方法族。</p>
<h3 id="注释对象"><a href="#注释对象" class="headerlink" title="注释对象"></a>注释对象</h3><p><code>Comment</code>代表XML文档中的评论。它是子类<code>Node</code>，但不能有子节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Comment.data</span><br></pre></td></tr></table></figure>
<p>注释的内容为一个字符串。该属性包含前导<code>和尾随之间的所有字符</code>–&gt;`，但不包括它们。</p>
<h3 id="文本和CDATASection对象"><a href="#文本和CDATASection对象" class="headerlink" title="文本和CDATASection对象"></a>文本和<code>CDATASection</code>对象</h3><p>该<code>Text</code>接口表示在XML文档中的文本。如果解析器和DOM实现支持DOM的XML扩展，那么封装在CDATA标记节中的部分文本将存储在<code>CDATASection</code>对象中。这两个接口是相同的，但为<code>nodeType</code>属性提供不同的值。</p>
<p>这些接口扩展了<code>Node</code>接口。他们不能有子节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Text.data</span><br></pre></td></tr></table></figure>
<p>文本节点的内容为字符串。</p>
<p>注意</p>
<p><code>CDATASection</code>节点的使用并不表示该节点表示一个完整的CDATA标记部分，只是该节点的内容是CDATA部分的一部分。 单个CDATA部分可以由文档树中的多个节点表示。 无法确定两个相邻的CDATASection节点是否代表不同的CDATA标记节。</p>
<h3 id="ProcessingInstruction对象"><a href="#ProcessingInstruction对象" class="headerlink" title="ProcessingInstruction对象"></a><code>ProcessingInstruction</code>对象</h3><p>表示XML文档中的处理指令; 这从<code>Node</code>接口继承并且不能有子节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ProcessingInstruction.target</span><br></pre></td></tr></table></figure>
<p>处理指令的内容直至第一个空白字符。这是一个只读属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ProcessingInstruction.data</span><br></pre></td></tr></table></figure>
<p>处理指令的内容跟在第一个空白字符之后。</p>
<h3 id="Exceptions-异常"><a href="#Exceptions-异常" class="headerlink" title="Exceptions 异常"></a><strong>Exceptions</strong> 异常</h3><p>DOM Level 2建议定义了一个单例，DOMException和一些允许应用程序确定发生的错误的常量。 DOMException实例携带一个代码属性，为特定的异常提供适当的值。</p>
<p>Python DOM接口提供了常量，但也扩展了一组异常，以便DOM中定义的每个异常代码都存在特定的异常。这些实现必须引发适当的特定异常，每个异常都带有相应的<code>code</code>属性值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.DOMException</span><br></pre></td></tr></table></figure>
<p>用于所有特定DOM异常的基本异常类。这个异常类不能直接实例化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.DomstringSizeErr</span><br></pre></td></tr></table></figure>
<p>当指定范围的文本不适合字符串时引发。这不是已知用于Python DOM实现，但可能从未使用Python编写的DOM实现中获得。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.HierarchyRequestErr</span><br></pre></td></tr></table></figure>
<p>当尝试插入不允许节点类型的节点时引发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.IndexSizeErr</span><br></pre></td></tr></table></figure>
<p>当方法的索引或大小参数为负值或超出允许值时引发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.InuseAttributeErr</span><br></pre></td></tr></table></figure>
<p>当尝试插入已存在于文档中其他位置的Attr节点时引发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.InvalidAccessErr</span><br></pre></td></tr></table></figure>
<p>如果基础对象不支持参数或操作，则引发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.InvalidCharacterErr</span><br></pre></td></tr></table></figure>
<p>如果字符串参数包含在XML 1.0建议中使用的上下文中不允许的字符，则会引发此异常。例如，尝试<code>Element</code>在元素类型名称中创建具有空格的节点会导致此错误的发生。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.InvalidModificationErr</span><br></pre></td></tr></table></figure>
<p>当尝试修改节点的类型时引发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.InvalidStateErr</span><br></pre></td></tr></table></figure>
<p>当尝试使用未定义或不再可用的对象时引发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.NamespaceErr</span><br></pre></td></tr></table></figure>
<p>如果尝试<a href="https://www.w3.org/TR/REC-xml-names/" target="_blank" rel="noopener">以XML</a>建议中的<a href="https://www.w3.org/TR/REC-xml-names/" target="_blank" rel="noopener">名称空间</a>不允许的方式更改任何对象，则会引发此异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.NotFoundErr</span><br></pre></td></tr></table></figure>
<p>在引用的上下文中不存在节点时异常。 例如，如果传入的节点在地图中不存在，NamedNodeMap.removeNamedItem（）将引发此操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.NotSupportedErr</span><br></pre></td></tr></table></figure>
<p>当实现不支持请求类型的对象或操作时引发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.NoDataAllowedErr</span><br></pre></td></tr></table></figure>
<p>如果为不支持数据的节点指定了数据，则会引发此问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.NoModificationAllowedErr</span><br></pre></td></tr></table></figure>
<p>引发尝试修改不允许修改的对象（例如对于只读节点）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.SyntaxErr</span><br></pre></td></tr></table></figure>
<p>当指定了无效或非法字符串时引发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception xml.dom.WrongDocumentErr</span><br></pre></td></tr></table></figure>
<p>当节点插入到与当前所属不同的文档中时引发，并且实现不支持将节点从一个文档迁移到另一个文档。</p>
<p>DOM建议中定义的异常代码根据此表映射到上述异常：</p>
<table>
<thead>
<tr>
<th style="text-align:left">常量</th>
<th style="text-align:left">例外</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DOMSTRING_SIZE_ERR</td>
<td style="text-align:left">DomstringSizeErr</td>
</tr>
<tr>
<td style="text-align:left">HIERARCHY_REQUEST_ERR</td>
<td style="text-align:left">HierarchyRequestErr</td>
</tr>
<tr>
<td style="text-align:left">INDEX_SIZE_ERR</td>
<td style="text-align:left">IndexSizeErr</td>
</tr>
<tr>
<td style="text-align:left">INUSE_ATTRIBUTE_ERR</td>
<td style="text-align:left">InuseAttributeErr</td>
</tr>
<tr>
<td style="text-align:left">INVALID_ACCESS_ERR</td>
<td style="text-align:left">InvalidAccessErr</td>
</tr>
<tr>
<td style="text-align:left">INVALID_CHARACTER_ERR</td>
<td style="text-align:left">InvalidCharacterErr</td>
</tr>
<tr>
<td style="text-align:left">INVALID_MODIFICATION_ERR</td>
<td style="text-align:left">InvalidModificationErr</td>
</tr>
<tr>
<td style="text-align:left">INVALID_STATE_ERR</td>
<td style="text-align:left">InvalidStateErr</td>
</tr>
<tr>
<td style="text-align:left">NAMESPACE_ERR</td>
<td style="text-align:left">NamespaceErr</td>
</tr>
<tr>
<td style="text-align:left">NOT_FOUND_ERR</td>
<td style="text-align:left">NotFoundErr</td>
</tr>
<tr>
<td style="text-align:left">NOT_SUPPORTED_ERR</td>
<td style="text-align:left">NotSupportedErr</td>
</tr>
<tr>
<td style="text-align:left">NO_DATA_ALLOWED_ERR</td>
<td style="text-align:left">NoDataAllowedErr</td>
</tr>
<tr>
<td style="text-align:left">NO_MODIFICATION_ALLOWED_ERR</td>
<td style="text-align:left">NoModificationAllowedErr</td>
</tr>
<tr>
<td style="text-align:left">SYNTAX_ERR</td>
<td style="text-align:left">SyntaxErr</td>
</tr>
<tr>
<td style="text-align:left">WRONG_DOCUMENT_ERR</td>
<td style="text-align:left">WrongDocumentErr</td>
</tr>
</tbody>
</table>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>本节介绍Python DOM API，W3C DOM推荐和Python的OMG IDL映射之间的一致性要求和关系。</p>
<h3 id="类型映射"><a href="#类型映射" class="headerlink" title="类型映射"></a>类型映射</h3><p>根据下表将DOM规范中使用的原始IDL类型映射到Python类型。</p>
<table>
<thead>
<tr>
<th style="text-align:left">IDL类型</th>
<th style="text-align:left">Python类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">布尔</td>
<td style="text-align:left">IntegerType（值为0或1）</td>
</tr>
<tr>
<td style="text-align:left">INT</td>
<td style="text-align:left">IntegerType</td>
</tr>
<tr>
<td style="text-align:left">长整型</td>
<td style="text-align:left">IntegerType</td>
</tr>
<tr>
<td style="text-align:left">无符号整数</td>
<td style="text-align:left">IntegerType</td>
</tr>
</tbody>
</table>
<p>此外，<code>DOMString</code>建议中定义的内容将映射到Python字符串或Unicode字符串。每当从DOM返回字符串时，应用程序应该能够处理Unicode。</p>
<p>IDL <code>null</code>值被映射到<code>None</code>，只要<code>null</code>API允许，该值可以被实现接受或提供。</p>
<h3 id="访问器方法"><a href="#访问器方法" class="headerlink" title="访问器方法"></a>访问器方法</h3><p>从OMG IDL到Python <code>attribute</code>的映射以Java映射的方式为IDL 声明定义访问器函数。映射IDL声明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">readonly attribute string someValue;</span><br><span class="line">         attribute string anotherValue;</span><br></pre></td></tr></table></figure>
<p>产生三种存取器函数：一个“获取”方法<code>someValue</code>（<code>_get_someValue()</code>），和“获取”和“设置”为方法<code>anotherValue</code>（<code>_get_anotherValue()</code>和<code>_set_anotherValue()</code>）。映射，尤其是不需要的IDL属性是访问正常的Python属性：<code>object.someValue</code>是<em>不是</em>工作需要，并且可能引发<code>AttributeError</code>。</p>
<p>但是，Python DOM API <em>确实</em>需要正常的属性访问。这意味着由Python IDL编译器生成的典型代理不可能工作，并且如果通过CORBA访问DOM对象，则可能需要在客户端上包装对象。虽然这确实需要对CORBA DOM客户端进行一些额外的考虑，但具有从Python使用DOM到CORBA的经验的实施者并不认为这是一个问题。所声明的属性<code>readonly</code>可能不会限制所有DOM实现中的写入访问。</p>
<p>在Python DOM API中，访问函数不是必需的。如果提供，它们应该采用由Python IDL映射定义的形式，但这些方法被认为是不必要的，因为可以直接从Python访问这些属性。不应该为<code>readonly</code>属性提供“设置”访问器。</p>
<p>IDL定义并未完全体现W3C DOM API的要求，例如某些对象的概念，如返回值为<code>getElementsByTagName()</code>“live”。Python DOM API不需要实现来执行这些需求。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>xml</tag>
        <tag>dom</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library Tkinter</title>
    <url>/2020/03/14/python-standard-library-Tkinter/</url>
    <content><![CDATA[<h1 id="python-标准库-Tkinter"><a href="#python-标准库-Tkinter" class="headerlink" title="python 标准库 Tkinter"></a>python 标准库 Tkinter</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200314_what_is_friends_mean_to_u.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>what life should mean to you ?</p>
<p>推荐这本书 中文版 翻译为：自卑与超越</p>
</blockquote>
<p>该<code>Tkinter</code>模块（“Tk接口”）是Tk GUI工具包的标准Python接口。Tk和<code>Tkinter</code>在大多数Unix平台以及Windows系统上均可用。（Tk本身不是Python的一部分;它保存在ActiveState中。）</p>
<p>注意</p>
<p><code>Tkinter</code>已被重新命名为<code>tkinter</code>Python 3. 当将源代码转换为Python 3时，<a href="https://docs.python.org/2.7/glossary.html#term-2to3" target="_blank" rel="noopener">2to3</a>工具将自动适应导入。</p>
<p>扩展内容</p>
<p> <a href="https://wiki.python.org/moin/TkInter" target="_blank" rel="noopener">Python Tkinter资源</a> Python Tkinter主题指南提供了大量关于从Python使用Tk和链接到Tk上的其他信息源的信息。<a href="http://www.tkdocs.com/" target="_blank" rel="noopener">TKDocs</a>广泛的教程和一些小部件的更友好的小部件页面。<a href="https://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html" target="_blank" rel="noopener">Tkinter参考：用于Python的GUI</a>在线参考资料。<a href="http://effbot.org/tkinterbook/" target="_blank" rel="noopener">来自effbot的Tkinter文档由effbot.org</a>支持的tkinter的在线参考。<a href="https://www.tcl.tk/man/tcl8.5/" target="_blank" rel="noopener">Tcl / Tk手册</a>最新tcl / tk版本的官方手册。由Mark Lutz <a href="http://learning-python.com/books/about-pp4e.html" target="_blank" rel="noopener">编写的Python</a>书籍，对Tkinter有很好的报道。<a href="http://www.amazon.com/Modern-Tkinter-Python-Developers-ebook/dp/B0071QDNLO/" target="_blank" rel="noopener">繁忙Python开发人员的现代Tkinter</a>由Mark Rozerman撰写关于用Python和Tkinter构建具有吸引力和现代化图形用户界面的内容。<a href="https://www.manning.com/books/python-and-tkinter-programming" target="_blank" rel="noopener">Python和Tkinter编程</a> John Grayson的书（ISBN 1-884777-81-3）。  </p>
<h2 id="1-Tkinter模块"><a href="#1-Tkinter模块" class="headerlink" title="1. Tkinter模块"></a>1. Tkinter模块</h2><p>大多数情况下，<code>Tkinter</code>模块都是您真正需要的，但也有一些额外的模块可供选择。Tk接口位于名为的二进制模块中<code>_tkinter</code>。该模块包含Tk的底层接口，不应直接由应用程序员使用。它通常是共享库（或DLL），但在某些情况下可能会与Python解释器静态链接。</p>
<p>除了Tk接口模块外，<code>Tkinter</code>还包括许多Python模块。两个最重要的模块是<code>Tkinter</code>模块本身，还有一个模块叫做<code>Tkconstants</code>。前者自动导入后者，所以要使用Tkinter，你只需要导入一个模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Tkinter</span><br></pre></td></tr></table></figure>
<p>或者更经常地：</p>
<figure class="highlight plain"><figcaption><span>Tkinter import *</span></figcaption><table><tr><td class="code"><pre><span class="line">class Tkinter.Tk(screenName=None, baseName=None, className=&apos;Tk&apos;, useTk=1)</span><br></pre></td></tr></table></figure>
<p>将<code>Tk</code>类实例化没有参数。这会创建一个Tk的顶层小部件，它通常是应用程序的主窗口。每个实例都有自己关联的Tcl解释器。</p>
<p>在版本2.4中更改：添加了<em>useTk</em>参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tkinter.Tcl(screenName=None, baseName=None, className=&apos;Tk&apos;, useTk=0)</span><br></pre></td></tr></table></figure>
<p>该<code>Tcl()</code>函数是一个工厂函数<code>Tk</code>，除了不初始化Tk子系统外，它创建的对象非常类似于该类创建的对象。在不希望创建无关的顶层窗口的环境中，或者在无法（如没有X服务器的Unix / Linux系统）环境中驱动Tcl解释器时，这通常很有用。由对象创建的<code>Tcl()</code>对象可以通过调用其<code>loadtk()</code>方法创建Toplevel窗口（并初始化Tk子系统）。</p>
<p>2.4版本中的新功能。</p>
<p>其他提供Tk支持的模块包括：</p>
<p>ScrolledTextText小部件，内置一个垂直滚动条in.tkColorChooserDialog，让用户选择一个color.tkCommonDialogBase类，用于在这里列出的其他模块中定义的对话框。tkFileDialogCommon对话框允许用户指定要打开的文件或save.tkFontUtilities以帮助 使用fonts.tkMessageBoxAccess来标准Tk对话框boxes.tkSimpleDialogBasic对话框和便捷函数.Tkdnd拖放支持Tkinter。 这是实验性的，当它在Tk窗口中用Tk DND.turtleTurtle图形取代时应该被弃用。</p>
<p>这些已经在Python 3中重新命名了; 他们都是新<code>tkinter</code>包装的子模块。</p>
<h2 id="2-Tkinter救生员系统"><a href="#2-Tkinter救生员系统" class="headerlink" title="2. Tkinter救生员系统"></a>2. Tkinter救生员系统</h2><p>本节不是为Tk或Tkinter的详尽教程而设计的。相反，它旨在作为一个制止差距，为系统提供一些入门指导。</p>
<p>Credits:</p>
<ul>
<li><p>Tkinter由Steen Lumholt和Guido van Rossum撰写。</p>
</li>
<li><p>Tk由John Ousterhout在伯克利书写。</p>
</li>
<li><p>这个Life Preserver 是由弗吉尼亚大学的马特康威编写的。</p>
</li>
<li><p>HTML渲染和一些自由编辑是由Ken Manheimer的FrameMaker版本生成的。</p>
</li>
<li><p>Fredrik Lundh详细阐述并修改了类接口描述，以使它们与Tk 4.2一致。</p>
</li>
<li><p>Mike Clarkson将文档转换为LaTeX，并编译了参考手册的用户界面章节。</p>
</li>
</ul>
<h3 id="2-1-如何使用本节"><a href="#2-1-如何使用本节" class="headerlink" title="2.1 如何使用本节"></a>2.1 如何使用本节</h3><p>本部分分为两部分：前半部分（大致）包含背景材料，后半部分可作为便于参考的键盘。</p>
<p>当试图回答“我该怎么做”这个形式的问题时，通常最好找出如何在直接Tk中做“无用”，然后将其转换回相应的<code>Tkinter</code>呼叫。Python程序员通常可以通过查看Tk文档来猜测正确的Python命令。这意味着为了使用Tkinter，你必须知道一些关于Tk的知识。这个文件不能完成这个角色，所以我们能做的最好的事情就是向您提供最好的文档。以下是一些提示：</p>
<ul>
<li><p>作者强烈建议获取Tk手册页的副本。具体来说，<code>mann</code>目录中的手册页是最有用的。该<code>man3</code>手册页介绍了C接口Tk库，因此不为脚本编写者特别有用。</p>
</li>
<li><p>Addison-Wesley出版了一本名为Tcl的书和John Ousterhout的Tk Toolkit（ISBN 0-201-63337-X），这是对新手Tcl和Tk的一个很好的介绍。这本书并非详尽无遗，对于许多细节，它都遵循手册页。</p>
</li>
<li><p><code>Tkinter.py</code> 对大多数人来说是最后的选择，但如果没有其他任何意义的话，它可能是一个很好的去处。</p>
</li>
</ul>
<p>扩展内容</p>
<p> <a href="http://tcl.activestate.com/" target="_blank" rel="noopener">ActiveState Tcl主页</a> Tk / Tcl开发主要发生在ActiveState上。<a href="http://www.amazon.com/exec/obidos/ASIN/020163337X" target="_blank" rel="noopener">Tcl和Tk工具包</a> Tcl的发明人John Ousterhout的书。<a href="http://www.beedub.com/book/" target="_blank" rel="noopener">Tcl和Tk中的实用编程</a> Brent Welch的百科全书。  </p>
<h3 id="2-2-一个简单的Hello-World程序"><a href="#2-2-一个简单的Hello-World程序" class="headerlink" title="2.2  一个简单的Hello World程序"></a>2.2  一个简单的Hello World程序</h3><figure class="highlight plain"><figcaption><span>import *</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Application(Frame):</span><br><span class="line">    def say_hi(self):</span><br><span class="line">        print &quot;hi there, everyone!&quot;</span><br><span class="line"></span><br><span class="line">    def createWidgets(self):</span><br><span class="line">        self.QUIT = Button(self)</span><br><span class="line">        self.QUIT[&quot;text&quot;] = &quot;QUIT&quot;</span><br><span class="line">        self.QUIT[&quot;fg&quot;]   = &quot;red&quot;</span><br><span class="line">        self.QUIT[&quot;command&quot;] =  self.quit</span><br><span class="line"></span><br><span class="line">        self.QUIT.pack(&#123;&quot;side&quot;: &quot;left&quot;&#125;)</span><br><span class="line"></span><br><span class="line">        self.hi_there = Button(self)</span><br><span class="line">        self.hi_there[&quot;text&quot;] = &quot;Hello&quot;,</span><br><span class="line">        self.hi_there[&quot;command&quot;] = self.say_hi</span><br><span class="line"></span><br><span class="line">        self.hi_there.pack(&#123;&quot;side&quot;: &quot;left&quot;&#125;)</span><br><span class="line"></span><br><span class="line">    def __init__(self, master=None):</span><br><span class="line">        Frame.__init__(self, master)</span><br><span class="line">        self.pack()</span><br><span class="line">        self.createWidgets()</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">app = Application(master=root)</span><br><span class="line">app.mainloop()</span><br><span class="line">root.destroy()</span><br></pre></td></tr></table></figure>
<h2 id="3-（非常）快速浏览Tcl-Tk"><a href="#3-（非常）快速浏览Tcl-Tk" class="headerlink" title="3. （非常）快速浏览Tcl / Tk"></a>3. （非常）快速浏览Tcl / Tk</h2><p>类层次结构看起来很复杂，但实际上，应用程序员几乎总是引用层次结构底部的类。</p>
<p>注意：</p>
<ul>
<li><p>提供这些类是为了在一个命名空间下组织某些功能。它们不是要独立实例化的。</p>
</li>
<li><p>该<code>Tk</code>类，就是要在应用程序中只有一次实例化。应用程序员不需要明确地实例化一个实例，只要有任何其他类实例化，系统就会创建一个。</p>
</li>
<li><p>这个<code>Widget</code>类不意味着被实例化，它只是意味着子类化才能生成“真实”的小部件（在C ++中，这被称为“抽象类”）。</p>
</li>
</ul>
<p>为了使用这个参考资料，有时候您需要知道如何阅读Tk的简短段落以及如何识别Tk命令的各个部分。（请参阅将Tk的基本Tk映射到Tkinter中，<code>Tkinter</code>以了解下面的内容。）</p>
<p>Tk脚本是Tcl程序。像所有的Tcl程序一样，Tk脚本只是由空格分隔的令牌列表。传统知识小部件就是它的<em>类</em>的<em>选项</em>，帮助配置，和<em>行动</em>，使人们做有用的事情。</p>
<p>要在Tk中创建一个小部件，该命令始终是以下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cpythond newPathname options</span><br></pre></td></tr></table></figure>
<p>classCommand_表示要制作哪种小部件（按钮，标签，菜单…）_ newPathname_是此小部件的新名称。 Tk中的所有名称都必须是唯一的。 为了帮助执行此操作，Tk中的窗口小部件以_pathnames命名，就像文件系统中的文件一样。 调用顶级小部件root。 （期间）和孩子被更多的时期划定界限。 例如，.myApp.controlPanel.okButton可能是一个窗口小部件的名称._options_configure窗口小部件的外观，在某些情况下，它的行为。 选项以标志和值列表的形式出现。 标志前面有一个’ - ‘，就像Unix shell命令标志一样，并且如果值超过一个单词，则会将值放在引号中。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">buttopython  -fg red -text <span class="string">"hi there"</span></span><br><span class="line">   ^       ^     \_____________________/</span><br><span class="line">   |       |                |</span><br><span class="line"> <span class="class"><span class="keyword">class</span>    <span class="title">new</span>            <span class="title">options</span></span></span><br><span class="line"><span class="class"><span class="title">command</span>  <span class="title">widget</span>  <span class="params">(-opt val -opt val ...)</span></span></span><br></pre></td></tr></table></figure>
<p>一旦创建，小部件的路径名变成新命令。这个新的<em>Widget命令</em>是程序员获取新Widget执行某些<em>操作</em>的句柄。在C语言中，你可以用C ++表示它为someAction（fred，someOptions），你可以将它表示为fred.someAction（someOptions），在Tk中，你会说：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.fred sompythonmeOptions</span><br></pre></td></tr></table></figure>
<p>请注意，对象名称.fred以点开头。</p>
<p>正如你所期望的那样，someAction的合法值将取决于窗口部件的类：.fred禁用如果fred是一个按钮（fred变灰），但不起作用，但如果fred是标签，则不起作用（不支持禁用标签 在Tk）。</p>
<p>someOptions的合法价值取决于行动。 某些操作（如disable）不需要参数，其他操作（如文本输入框的delete命令）需要参数来指定要删除的文本范围。</p>
<h2 id="4-将Tk映射到Tkinter"><a href="#4-将Tk映射到Tkinter" class="headerlink" title="4.将Tk映射到Tkinter"></a>4.将Tk映射到Tkinter</h2><p>Tk中的类命令对应于Tkinter中的类构造函数。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">button .fred python     =====&gt;  fred = Button()</span><br></pre></td></tr></table></figure>
<p>对象的主对象隐含在创建时给它的新名称中。在Tkinter中，明确指定了主人。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">button .panel.frepython =====&gt;  fred = Button(panel)</span><br></pre></td></tr></table></figure>
<p>Tk中的配置选项在带有数值的紧跟标签列表中给出。在Tkinter中，选项在实例构造函数中被指定为关键字参数，在配置调用中被指定为keyword-args，或者在字典样式中被指定为已建立实例的实例索引。请参见设置选项中的设置选项部分。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">button .fred -fg red python==&gt;  fred = Button(panel, fg = "red")</span><br><span class="line">.fred configure -fg red     =====&gt;  fred["fg"] = red</span><br><span class="line">                            OR ==&gt;  fred.config(fg = "red")</span><br></pre></td></tr></table></figure>
<p>在Tk中，要在小部件上执行操作，请使用小部件名称作为命令，然后使用操作名称，可能带有参数（选项）。在Tkinter中，您可以调用类实例上的方法来调用窗口小部件上的操作。Tkinter.py模块中列出了给定小部件可以执行的动作（方法）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.fred invoke             python fred.invoke()</span><br></pre></td></tr></table></figure>
<p>要给封装器（几何管理器）提供一个小部件，可以使用可选参数调用封装。在Tkinter中，Pack类拥有所有这些功能，并且各种形式的pack命令都作为方法实现。所有的小部件<code>Tkinter</code>都是从Packer中分类出来的，因此继承了所有的打包方法。有关<code>Tix</code>表格几何管理器的其他信息，请参阅模块文档。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pack .fred -side left       =pythond.pack(side = <span class="string">"left"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="5-Tk和Tkinter是如何相关的"><a href="#5-Tk和Tkinter是如何相关的" class="headerlink" title="5. Tk和Tkinter是如何相关的"></a>5. Tk和Tkinter是如何相关的</h2><p>从上到下：</p>
<p>你的应用程序在这里（Python）一个Python应用程序进行<code>Tkinter</code>调用.Tkinter（Python模块）这个调用（例如，创建一个按钮控件）在<em>Tkinter</em>模块中实现，该模块是用Python编写的。这个Python函数将解析命令和参数并将它们转换为一种形式，使它们看起来好像它们来自Tk脚本而不是Python脚本.tkinter（C）这些命令及其参数将传递给C在<em>tkinter</em>中的<em>功能</em> - 注意小写 - 扩展模块.Tk Widgets（C和Tcl）这个C函数可以调用其他C模块，包括组成Tk库的C函数。Tk在C和一些Tcl中实现。Tk小部件的Tcl部分用于将某些默认行为绑定到小部件，并且在<code>Tkinter</code>导入Python 模块的位置执行一次。（用户从不会看到这个阶段）.Tk（C）Tk Widgets的Tk部分实现了最终映射到… Xlib（C）Xlib库在屏幕上绘制图形。</p>
<h2 id="6-方便的参考"><a href="#6-方便的参考" class="headerlink" title="6.方便的参考"></a>6.方便的参考</h2><h3 id="6-1-设置选项"><a href="#6-1-设置选项" class="headerlink" title="6.1  设置选项"></a>6.1  设置选项</h3><p>选项控制一些东西，比如一个小部件的颜色和边框宽度。选项可以通过三种方式设置：</p>
<p>在创建对象时，使用关键字参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fred = Button(self, fg = <span class="string">"red"</span>, bpython)</span><br></pre></td></tr></table></figure>
<p>创建对象后，将选项名称视为字典索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fred[<span class="string">"fg"</span>] = <span class="string">"red"</span></span><br><span class="line">fred[<span class="string">"bg"</span>] = <span class="string">"bluepythononfig（）方法更新对象创建后的多个attrs</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">​```python</span></span><br><span class="line"><span class="string">fred.config(fg = "</span>red<span class="string">", bg = "</span>blue<span class="string">")</span></span><br></pre></td></tr></table></figure>
<p>python为的完整说明，请参阅相关Widget的Tk手册页。</p>
<p>请注意，手册页列出了每个窗口小部件的“标准选项”和“小部件特定选项”。前者是许多小部件通用的选项列表，后者是特定小部件特有的选项。标准选项记录在<em>选项（3）</em>手册页上。</p>
<p>本文档没有区分标准和特定于窗口小部件的选项。有些选项不适用于某些类型的小部件。给定小部件是否响应特定选项取决于小部件的类别; 按钮有一个<code>command</code>选项，标签没有。</p>
<p>给定小部件支持的选项列在该小部件的手册页中，或者可以在运行时通过调用<code>config()</code>没有参数的方法或通过调用该<code>keys()</code>小部件上的方法来查询。这些调用的返回值是一个字典，其中的键是作为字符串（例如，<code>&#39;relief&#39;</code>）的选项的名称，其值是5元组。</p>
<p>一些选项，如bg是长名称的常见选项的同义词（bg是“背景”的简写）。 传递config（）方法的简写选项的名称将返回一个2元组，而不是5元组。 传回的2元组将包含同义词的名称和“真实”选项（例如（’bg’，’background’））。</p>
<table>
<thead>
<tr>
<th style="text-align:left">指数</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">选项名称</td>
<td style="text-align:left">‘relief’</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">数据库查找的选项名称</td>
<td style="text-align:left">‘relief’</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">选项类用于数据库查找</td>
<td style="text-align:left">‘relief’</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">默认值</td>
<td style="text-align:left">‘raised’</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">当前值</td>
<td style="text-align:left">‘groove’</td>
</tr>
</tbody>
</table>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> fred.config()</span><br><span class="line">&#123;<span class="string">'relief'</span>: (<span class="string">'relief'</span>,python <span class="string">'Relief'</span>, <span class="string">'raised'</span>, <span class="string">'groove'</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>当然，打印的字典将包括所有可用选项及其值。这只是作为一个例子。</p>
<h3 id="6-2-包装工"><a href="#6-2-包装工" class="headerlink" title="6.2 包装工"></a>6.2 包装工</h3><p>封隔器是Tk的几何管理机制之一。几何管理器用于指定小部件在其容器中的定位的相对位置 - 它们是相互的<em>主人</em>。相较于较为繁琐<em>placer</em>（用于不常用，我们在这里不介绍），封隔器采用定性关系规范- <em>above</em>, <em>to the left of</em>, <em>filling</em>等等-和工作的一切，以确定确切位置坐标为你。</p>
<p>任何<em>主</em>控件的大小由内部“从控件”的大小决定。打包器用于控制从站窗口小部件在其打包的主站内出现的位置。您可以将窗口小部件封装到框架中，并将框架封装到其他框架中，以实现您所需的布局。此外，这种安排是动态调整的，以适应配置的增量变化，一旦打包完成。</p>
<p>请注意，窗口小部件在用几何管理器指定几何图形之前不会显示。忽略几何规格是一个常见的早期错误，然后在创建小部件时会感到惊讶，但没有任何内容出现。例如，小部件只有在<code>pack()</code>应用打包器的方法后才会出现。</p>
<p>可以使用关键字选项/值对调用pack（）方法，该对控制了窗口小部件出现在其容器中的位置，以及在主应用程序窗口调整大小时的行为方式。这里有些例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fred.pack()                     <span class="comment"># defaults to sidpythonfred.pack(side = "left")</span></span><br><span class="line">fred.pack(expand = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-3-封装选项"><a href="#6-3-封装选项" class="headerlink" title="6.3  封装选项"></a>6.3  封装选项</h3><p>有关打包机的更多信息及其可以选择的选项，请参阅John Ousterhout书中的手册页和第183页。</p>
<p>anchorAnchor类型。 表示封装器将每个从器件放置在parcel.expandBoolean，0或1.fillLegal值中的位置：’x’，’y’，’both’，’none’.ipadx和ipadyA distance - 指定每个从器件的内部填充 从属widget.padx和padyA距离 - 指定从属widget的每边的外部填充。sideLegal值为：’left’，’right’，’top’，’bottom’。</p>
<h3 id="6-4-耦合小部件变量"><a href="#6-4-耦合小部件变量" class="headerlink" title="6.4  耦合小部件变量"></a>6.4  耦合小部件变量</h3><p>某些小部件（如文本输入小部件）的当前值设置可以通过使用特殊选项直接连接到应用程序变量。 这些选项是可变的，文本变量，onvalue，offvalue和值。 这种连接可以两种方式工作：如果变量因任何原因而变化，它所连接的小部件将被更新以反映新值。</p>
<p>不幸的是，在Tkinter的当前实现中，不可能通过变量或文本变量选项将任意Python变量移交给小部件。 这个变量的唯一类型是从Tkinter模块中定义的类变量中分类的变量。</p>
<p>已经定义了许多有用的变量的子类：StringVar，IntVar，DoubleVar和BooleanVar。 要读取此变量的当前值，请调用get（）方法，并更改其值，您可以调用set（）方法。 如果你遵循这个协议，那么这个小部件将总是跟踪这个变量的值，而不需要你做进一步的干预。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span><span class="params">(Frame)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, master=None)</span><span class="title">pythonFrame</span>.<span class="title">__init__</span><span class="params">(self, master)</span></span></span><br><span class="line"><span class="function">        <span class="title">self</span>.<span class="title">pack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">        self.entrythingy = Entry()</span><br><span class="line">        self.entrythingy.pack()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># here is the application variable</span></span><br><span class="line">        self.contents = StringVar()</span><br><span class="line">        <span class="comment"># set it to some value</span></span><br><span class="line">        self.contents.set(<span class="string">"this is a variable"</span>)</span><br><span class="line">        <span class="comment"># tell the entry widget to watch this variable</span></span><br><span class="line">        self.entrythingy[<span class="string">"textvariable"</span>] = self.contents</span><br><span class="line"></span><br><span class="line">        <span class="comment"># and here we get a callback when the user hits return.</span></span><br><span class="line">        <span class="comment"># we will have the program print out the value of the</span></span><br><span class="line">        <span class="comment"># application variable when the user hits return</span></span><br><span class="line">        self.entrythingy.bind(<span class="string">'&lt;Key-Return&gt;'</span>,</span><br><span class="line">                              self.print_contents)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_contents</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"hi. contents of entry is now ----&gt;"</span>, \</span><br><span class="line">              self.contents.get()</span><br></pre></td></tr></table></figure>
<h3 id="6-5-窗口管理器"><a href="#6-5-窗口管理器" class="headerlink" title="6.5  窗口管理器"></a>6.5  窗口管理器</h3><p>在Tk中，有一个实用程序命令wm用于与窗口管理器交互。 wm命令的选项允许您控制标题，位置，图标位图等。 在Tkinter中，这些命令已经作为Wm类的方法实现。 Toplevel小部件从Wm类中继承，因此可以直接调用Wm方法。</p>
<p>要查看包含给定窗口小部件的顶层窗口，通常可以引用窗口小部件的主窗口。当然，如果这个小部件已经被封装在一个框架内，那么这个主框架将不会代表一个顶层窗口。要访问包含任意小部件的顶级窗口，可以调用该<code>_root()</code>方法。该方法以下划线开头，表示这个函数是实现的一部分，而不是Tk功能的接口。</p>
<p>以下是一些典型用法的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span><span class="params">(Frame)</span>:</span></span><br><span class="line">    def __inipythonmaster=None):</span><br><span class="line">        Frame.__init__(self, master)</span><br><span class="line">        self.pack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># create the application</span></span><br><span class="line">myapp = App()</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># here are method calls to the window manager class</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">myapp.master.title(<span class="string">"My Do-Nothing Application"</span>)</span><br><span class="line">myapp.master.maxsize(<span class="number">1000</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># start the program</span></span><br><span class="line">myapp.mainloop()</span><br></pre></td></tr></table></figure>
<h3 id="6-6-Tk选项数据类型"><a href="#6-6-Tk选项数据类型" class="headerlink" title="6.6 Tk选项数据类型"></a>6.6 Tk选项数据类型</h3><p>anchorLegal值是指南针的点：“n”，“ne”，“e”，“se”，“s”，“sw”，“w”，“nw”以及“center”.bitmap有八个 -in，命名位图：<code>&#39;error&#39;</code>, <code>&#39;gray25&#39;</code>, <code>&#39;gray50&#39;</code>, <code>&#39;hourglass&#39;</code>, <code>&#39;info&#39;</code>, <code>&#39;questhead&#39;</code>, <code>&#39;question&#39;</code>, <code>&#39;warning&#39;</code>。 要指定一个X位图文件名，给出该文件的完整路径，前面带@，如“@ / usr / contrib / bitmap / gumby.bit”.boolean您可以传递整数0或1或字符串“yes”或“不”.callback</p>
<p>这是任何不带参数的Python函数。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_it</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"hi there"</span></span><br><span class="line">fred[<span class="string">"command"</span>] = print_it</span><br></pre></td></tr></table></figure>
<p>colorColors可以作为rgb.txt文件中X颜色的名称，或以4位表示RGB值的字符串形式给出：“#RGB”，8位：“#RRGGBB”，12位“#RRRGGGBBB”或16位位“#RRRRGGGGBBBB”范围，其中R，G，B在这里表示任何合法的十六进制数字。有关详细信息，请参阅Ousterhout书籍的第160页.cursor可以使用cursorfont.h中的标准X光标名称，而不使用XC_前缀。例如，要获得手形光标（XC_hand2），请使用字符串“hand2”。你也可以指定你自己的位图和掩码文件。请参阅Ousterhout书的第179页。距离可以在像素或绝对距离中指定屏幕距离。像素以数字和绝对距离作为字符串给出，尾部字符表示单位：c表示厘米，i表示英寸，m表示毫米，p表示打印机的点数。例如，3.5英寸表示为“3.5i”.fontTk使用列表字体名称格式，例如{courier 10 bold}。正数的字体大小以点为单位;尺寸为负数的尺寸以pixels.geometry度量。这是一个widthxheight形式的字符串，其中宽度和高度以像素为单位测量大多数小部件（显示文本的小部件的字符数）。例如：fred [“geometry”] =“200x100”.justifyLegal 值是字符串：“left”，“center”，“right”和“fill”.region这是一个带有四个空格分隔元素的字符串，这是一个合法的距离（见上文）。例如：“2 3 4 5”和“3i 2i 4.5i 2i”和“3c 2c 4c 10.4c”都是合法的区域.relief确定小部件的边框样式。合法值是：<code>&quot;raised&quot;</code>, <code>&quot;sunken&quot;</code>, <code>&quot;flat&quot;</code>, <code>&quot;groove&quot;</code>与 <code>&quot;ridge&quot;</code>.scrollcommand这几乎总是某个滚动条小部件的set（）方法，但可以是任何只有一个参数的小部件方法。例如，请参阅Python源代码分发中的Demo / tkinter / matt / canvas-with-scrollbars.py文件.wrap：必须是“none”，“char”或“word”中的一个。</p>
<h3 id="6-7-绑定和事件"><a href="#6-7-绑定和事件" class="headerlink" title="6.7 绑定和事件"></a>6.7 绑定和事件</h3><p>通过widget命令的绑定方法，您可以监视某些事件并在发生该事件类型时触发回调函数。绑定方法的形式是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bind</span><span class="params">(self, sequence, func, add=<span class="string">''</span>)</span>:</span></span><br></pre></td></tr></table></figure>
<p>如下：</p>
<p>sequence是一个表示事件目标类型的字符串。 （有关详细信息，请参阅John Ousterhout书中的绑定手册页和第201页）。当事件发生时，调用一个带有一个参数的Python函数。 一个Event实例将作为参数传递。 （以这种方式部署的函数通常称为回调。）addis可选，可以是’’或’+’。 传递一个空字符串表示这个绑定是要替换这个事件关联的任何其他绑定。 传递’+’意味着此函数将被添加到绑定到此事件类型的函数列表中。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">def turnRed(self, event):</span><br><span class="line">    event.widget[<span class="string">"activeforeground"</span>] = <span class="string">"red"</span></span><br><span class="line"></span><br><span class="line">self.button.bind(<span class="string">"&lt;Enter&gt;"</span>, self.turnRed)</span><br></pre></td></tr></table></figure>
<p>注意事件的widget字段在turnRed（）回调中被访问。 该字段包含捕获X事件的小部件。 下表列出了您可以访问的其他事件字段以及它们在Tk中的表示方式，这在引用Tk手册页时非常有用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Tk      Tkinter Event Field             Tk      Tkinter Event Field</span><br><span class="line">--      -------------------             --      -------------------</span><br><span class="line">%f      focus                           %A      char</span><br><span class="line">%h      height                          %E      send_event</span><br><span class="line">%k      keycode                         %K      keysym</span><br><span class="line">%s      state                           %N      keysym_num</span><br><span class="line">%t      time                            %T      type</span><br><span class="line">%w      width                           %W      widget</span><br><span class="line">%x      x                               %X      x_root</span><br><span class="line">%y      y                               %Y      y_root</span><br></pre></td></tr></table></figure>
<h3 id="6-8-索引参数"><a href="#6-8-索引参数" class="headerlink" title="6.8 索引参数"></a>6.8 索引参数</h3><p>许多小部件需要传递“索引”参数。它们用于指向Text小部件中的特定位置，或指向Entry小部件中的特定字符或指向Menu小部件中的特定菜单项。</p>
<p>Entry widget indexes (index, view index, etc.)</p>
<p>条目窗口小部件具有涉及正在显示的文本中的字符位置的选项。您可以使用这些<code>Tkinter</code>函数来访问文本小部件中的这些特殊点：</p>
<p>AtEnd（）指的是textAtInsert（）中的最后一个位置，指的是文本光标isAtSelFirst（）指示选定文本的开始点的点.AtSelLast（）表示所选文本的最后一个点，finallyAt（x，y）指向到像素位置<em>x</em>，<em>y</em>处的字符（对于包含单行文本的文本输入小部件，<em>y</em>不使用<em>y</em>）。文本小部件索引文本小部件的索引符号非常丰富，最好在Tk中进行描述man pages.Menu索引（menu.invoke（），menu.entryconfig（）等）</p>
<p>一些菜单选项和方法可以操作特定的菜单条目。无论何时，对于选项或参数都需要菜单索引，您可以通过：</p>
<ul>
<li><p>一个整数，它指向窗口小部件中的条目的数字位置，从顶部开始计数，从0开始;</p>
</li>
<li><p>字符串<code>&#39;active&#39;</code>，它是指当前在光标下的菜单位置;</p>
</li>
<li><p><code>&quot;last&quot;</code>引用最后一个菜单项的字符串;</p>
</li>
<li><p>通过前面的整数<code>@</code>，如在<code>@6</code>，其中整数被解释为y像素菜单的坐标系统中的坐标;</p>
</li>
<li><p>该字符串<code>&quot;none&quot;</code>表示根本没有菜单条目，通常与menu.activate（）一起使用来停用所有条目，最后，</p>
</li>
<li><p>一个与菜单条目标签相匹配的文本字符串，从菜单顶部扫描到底部。 请注意，此索引类型在所有其他索引类型之后被考虑，这意味着标记为last，active或none的菜单项的匹配可能会被解释为上述文字。</p>
</li>
</ul>
<h3 id="6-9-图片"><a href="#6-9-图片" class="headerlink" title="6.9 图片"></a>6.9 图片</h3><p>位图/像素图像可以通过以下子类创建<code>Tkinter.Image</code>：</p>
<ul>
<li><p><code>BitmapImage</code> 可用于X11位图数据。</p>
</li>
<li><p><code>PhotoImage</code> 可用于GIF和PPM / PGM颜色位图。</p>
</li>
</ul>
<p>任何类型的图像都是通过<code>file</code>或<code>data</code>选项创建的（其他选项也可用）。</p>
<p>这个图像对象可以用于任何一个<code>image</code>小部件支持的选项（例如标签，按钮，菜单）。在这些情况下，Tk将不会保留对图像的引用。当删除对图像对象的最后一个Python引用时，图像数据也会被删除，并且无论图像在哪里使用，Tk都会显示一个空框。</p>
<h2 id="7-文件处理程序"><a href="#7-文件处理程序" class="headerlink" title="7.文件处理程序"></a>7.文件处理程序</h2><p>Tk允许你注册和取消注册一个回调函数，当一个文件描述符可能有I / O时，这个回调函数将从Tk mainloop调用。每个文件描述符只能注册一个处理程序。示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Tkinter</span><br><span class="line">widget = Tkinter.Tk()</span><br><span class="line">mask = Tkinter.READABLE | Tkinter.WRITABLE</span><br><span class="line">widget.tk.createfilehandler(file, mask, callback)</span><br><span class="line">...</span><br><span class="line">widget.tk.deletefilehandler(file)</span><br></pre></td></tr></table></figure>
<p>此功能在Windows上不可用。</p>
<p>由于您不知道有多少字节可供读取，因此您可能不想使用<code>BufferedIOBase</code>or <code>TextIOBase</code> <code>read()</code>或<code>readline()</code>方法，因为这些字节会坚持读取预定义的字节数。对于套接字，<code>recv()</code>or <code>recvfrom()</code>方法可以正常工作; 对于其他文件，请使用原始读取或<code>os.read(file.fileno(), maxbytecount)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Widget.tk.createfilehandler(file, mask, func)</span><br></pre></td></tr></table></figure>
<p>注册文件处理程序回调函数<em>func</em>。该<em>文件</em>的参数可以是与一个对象<code>fileno()</code>的方法（例如，文件或套接字对象），或一个整数文件描述符。的<em>掩模</em>参数是任何以下三个常量的或运算组合。回调被调用如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">callback(file, mask)</span><br><span class="line">Widget.tk.deletefilehandler(file)</span><br></pre></td></tr></table></figure>
<p>取消注册文件处理程序。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Tkinter.READABLETkinter.WRITABLETkinter.EXCEPTION</span><br></pre></td></tr></table></figure>
<p><em>掩码</em>参数中使用的常量。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>Tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library _thread</title>
    <url>/2020/03/16/python-standard-library-thread/</url>
    <content><![CDATA[<h1 id="python-标准库-thread"><a href="#python-标准库-thread" class="headerlink" title="python 标准库 _thread"></a>python 标准库 _thread</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200316_multiplethreading.jpg?raw=true" alt></p>
<a id="more"></a>
<p><code>python2</code> 中的<code>thread</code> 在 <code>python3</code>中叫<code>_thread</code>。相对于 <code>threading</code>来说更偏底层实现。</p>
<p>该模块提供了操作多个线程（也被称为 <em>轻量级进程</em> 或 <em>任务</em>）的底层原语 —— 多个控制线程共享全局数据空间。为了处理同步问题，也提供了简单的锁机制（也称为 <em>互斥锁</em> 或 <em>二进制信号</em>）。<a href="https://docs.python.org/zh-cn/3.8/library/threading.html#module-threading" target="_blank" rel="noopener"><code>threading</code></a> 模块基于该模块提供了更易用的高级多线程 API。</p>
<p><em>在 3.7 版更改:</em> 这个模块曾经是可选的，但现在总是可用的。</p>
<h2 id="常量和函数"><a href="#常量和函数" class="headerlink" title="常量和函数"></a>常量和函数</h2><p>这个模块定义了以下常量和函数：</p>
<ul>
<li><p><em>exception</em> <code>_thread.error</code></p>
<p>发生线程相关错误时抛出。<em>在 3.3 版更改:</em> 现在是内建异常 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 的别名。</p>
</li>
<li><p><code>_thread.LockType</code></p>
<p>锁对象的类型。</p>
</li>
<li><p><code>_thread.start_new_thread</code>(<em>function</em>, <em>args</em>[, <em>kwargs</em>])</p>
<p>开启一个新线程并返回其标识。 线程执行函数 <em>function</em> 并附带参数列表 <em>args</em> (必须是元组)。 可选的 <em>kwargs</em> 参数指定一个关键字参数字典。当函数返回时，线程会静默地退出。当函数因某个未处理异常而终结时，<a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.unraisablehook" target="_blank" rel="noopener"><code>sys.unraisablehook()</code></a> 会被调用以处理异常。 钩子参数的 <em>object</em> 属性为 <em>function</em>。 在默认情况下，会打印堆栈回溯然后该线程将退出（但其他线程会继续运行）。当函数引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a> 异常时，它会被静默地忽略。<em>在 3.8 版更改:</em> 现在会使用 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.unraisablehook" target="_blank" rel="noopener"><code>sys.unraisablehook()</code></a> 来处理未处理的异常。</p>
</li>
<li><p><code>_thread.interrupt_main</code>()</p>
<p>模拟一个 <code>signal.SIGINT</code> 信号到达主线程的效果。 线程可以使用这个函数来中断主线程。如果 Python 没有处理 <code>signal.SIGINT</code> (将它设为 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.SIG_DFL" target="_blank" rel="noopener"><code>signal.SIG_DFL</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.SIG_IGN" target="_blank" rel="noopener"><code>signal.SIG_IGN</code></a>)，此函数将不做任何事。</p>
</li>
<li><p><code>_thread.exit</code>()</p>
<p>抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a> 异常。如果没有捕获的话，这个异常会使线程退出。</p>
</li>
<li><p><code>_thread.allocate_lock</code>()</p>
<p>返回一个新的锁对象。锁中的方法在后面描述。初始情况下锁处于解锁状态。</p>
</li>
<li><p><code>_thread.get_ident</code>()</p>
<p>返回当前线程的 “线程描述符”。它是一个非零的整型数。它的值没有什么含义，主要是作为 magic cookie 使用，比如作为含有线程相关数据的字典的索引。线程描述符可能会在线程退出，新线程创建时复用。</p>
</li>
<li><p><code>_thread.get_native_id</code>()</p>
<p>返回内核分配给当前线程的原生集成线程 ID。 这是一个非负整数。 它的值可被用来在整个系统中唯一地标识这个特定线程（直到线程终结，在那之后该值可能会被 OS 回收再利用）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows, FreeBSD, Linux, macOS, OpenBSD, NetBSD, AIX。<em>3.8 新版功能.</em></p>
</li>
<li><p><code>_thread.stack_size</code>([<em>size</em>])</p>
<p>返回新建线程时使用的堆栈大小。可选参数 <em>size</em> 指定之后新建的线程的堆栈大小，而且一定要是0（根据平台或者默认配置）或者最小是32,768(32KiB)的一个正整数。如果<em>size</em>没有指定，默认是0。如果不支持改变线程堆栈大小，会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 错误。如果指定的堆栈大小不合法，会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 错误并且不会修改堆栈大小。32KiB是当前最小的能保证解释器足够堆栈空间的堆栈大小。需要注意的是部分平台对于堆栈大小会有特定的限制，例如要求大于32KiB的堆栈大小或者需要根据系统内存页面的整数倍进行分配 - 应当查阅平台文档有关详细信息（4KiB页面比较普遍，在没有更具体信息的情况下，建议的方法是使用4096的倍数作为堆栈大小）<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows，具有 POSIX 线程的系统。</p>
</li>
<li><p><code>_thread.TIMEOUT_MAX</code></p>
<p><code>Lock.acquire()</code> 方法中 <em>timeout</em> 参数允许的最大值。传入超过这个值的 timeout 会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a> 异常。<em>3.2 新版功能.</em></p>
</li>
</ul>
<h2 id="锁对象方法"><a href="#锁对象方法" class="headerlink" title="锁对象方法"></a>锁对象方法</h2><p>锁对象有以下方法：</p>
<ul>
<li><p><code>lock.acquire</code>(<em>waitflag=1</em>, <em>timeout=-1</em>)</p>
<p>没有任何可选参数时，该方法无条件申请获得锁，有必要的话会等待其他线程释放锁（同时只有一个线程能获得锁 —— 这正是锁存在的原因）。如果传入了整型参数 <em>waitflag</em>，具体的行为取决于传入的值：如果是 0 的话，只会在能够立刻获取到锁时才获取，不会等待，如果是非零的话，会像之前提到的一样，无条件获取锁。如果传入正浮点数参数 <em>timeout</em>，相当于指定了返回之前等待得最大秒数。如果传入负的 <em>timeout</em>，相当于无限期等待。如果 <em>waitflag</em> 是 0 的话，不能指定 <em>timeout</em>。如果成功获取到所会返回 <code>True</code>，否则返回 <code>False</code>。<em>在 3.2 版更改:</em> <em>timeout</em> 形参是新增的。<em>在 3.2 版更改:</em> 现在获取锁的操作可以被 POSIX 信号中断。</p>
</li>
<li><p><code>lock.release</code>()</p>
<p>释放锁。锁必须已经被获取过，但不一定是同一个线程获取的。</p>
</li>
<li><p><code>lock.locked</code>()</p>
<p>返回锁的状态：如果已被某个线程获取，返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
</ul>
<p>除了这些方法之外，锁对象也可以通过 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句使用，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"></span><br><span class="line">a_lock = _thread.allocate_lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> a_lock:</span><br><span class="line">    print(<span class="string">"a_lock is locked while this executes"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意事项：</strong></p>
<ul>
<li>线程与中断奇怪地交互：<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyboardInterrupt" target="_blank" rel="noopener"><code>KeyboardInterrupt</code></a> 异常可能会被任意一个线程捕获。（如果 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#module-signal" target="_blank" rel="noopener"><code>signal</code></a> 模块可用的话，中断总是会进入主线程。）</li>
<li>调用 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 或是抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a> 异常等效于调用 <a href="https://docs.python.org/zh-cn/3.8/library/_thread.html#_thread.exit" target="_blank" rel="noopener"><code>_thread.exit()</code></a>。</li>
<li>不可能中断锁的 <code>acquire()</code> 方法 —— <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyboardInterrupt" target="_blank" rel="noopener"><code>KeyboardInterrupt</code></a> 一场会在锁获取到之后发生。</li>
<li>当主线程退出时，由系统决定其他线程是否存活。在大多数系统中，这些线程会直接被杀掉，不会执行 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> … <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 语句，也不会执行对象析构函数。</li>
<li>当主线程退出时，不会进行正常的清理工作（除非使用了 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> … <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 语句），标准 I/O 文件也不会刷新。</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>_thread</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library dis</title>
    <url>/2020/03/19/python-standard-library-dis/</url>
    <content><![CDATA[<h1 id="python-标准库-dis"><a href="#python-标准库-dis" class="headerlink" title="python 标准库 dis"></a>python 标准库 dis</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200319_boring.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>每日一词</p>
<p>boring  英 [bɔːd] 美 [bɔrd]  </p>
<p>n.钻孔；镗削；地质钻探；钻屑</p>
<p>adj.没趣的；令人厌倦（或厌烦）的</p>
<p>v.“bore”的现在分词</p>
<p>网络无聊的；令人厌烦的；乏味的</p>
</blockquote>
<p><strong>Source code:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dis.py" target="_blank" rel="noopener">Lib/dis.py</a></p>
<hr>
<p><a href="https://docs.python.org/zh-cn/3.8/library/dis.html#module-dis" target="_blank" rel="noopener"><code>dis</code></a> 模块通过反汇编支持CPython的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytecode" target="_blank" rel="noopener">bytecode</a> 分析。该模块作为输入的 CPython 字节码在文件 <code>Include/opcode.h</code> 中定义，并由编译器和解释器使用。</p>
<p><strong>CPython implementation detail:</strong> 字节码是 CPython 解释器的实现细节。不保证不会在Python版本之间添加、删除或更改字节码。不应考虑将此模块的跨 Python VM 或 Python 版本的使用。</p>
<p><em>在 3.6 版更改:</em> 每条指令使用2个字节。以前字节数因指令而异。</p>
<p>示例：给出函数 <code>myfunc()</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(alist)</span><br></pre></td></tr></table></figure>
<p>可以使用以下命令显示 <code>myfunc()</code> 的反汇编</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(myfunc)</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (len)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">0</span> (alist)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>(“2” 是行号)。</p>
<h2 id="字节码分析"><a href="#字节码分析" class="headerlink" title="字节码分析"></a>字节码分析</h2><p><em>3.4 新版功能.</em></p>
<p>字节码分析 API 允许将 Python 代码片段包装在 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Bytecode" target="_blank" rel="noopener"><code>Bytecode</code></a> 对象中，以便轻松访问已编译代码的详细信息。</p>
<ul>
<li><p><em>class</em> <code>dis.Bytecode</code>(<em>x</em>, <em>**, </em>first_line=None<em>, </em>current_offset=None*)</p>
<p>分析的字节码对应于函数、生成器、异步生成器、协程、方法、源代码字符串或代码对象（由 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#compile" target="_blank" rel="noopener"><code>compile()</code></a> 返回）。这是下面列出的许多函数的便利包装，最值得注意的是 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.get_instructions" target="_blank" rel="noopener"><code>get_instructions()</code></a> ，迭代于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Bytecode" target="_blank" rel="noopener"><code>Bytecode</code></a> 的实例产生字节码操作 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Instruction" target="_blank" rel="noopener"><code>Instruction</code></a> 的实例。如果 <em>first_line</em> 不是 <code>None</code> ，则表示应该为反汇编代码中的第一个源代码行报告的行号。否则，源行信息（如果有的话）直接来自反汇编的代码对象。如果 <em>current_offset</em> 不是 <code>None</code> ，则它指的是反汇编代码中的指令偏移量。设置它意味着 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Bytecode.dis" target="_blank" rel="noopener"><code>dis()</code></a> 将针对指定的操作码显示“当前指令”标记。<em>classmethod</em> <code>from_traceback</code>(<em>tb</em>)从给定回溯构造一个 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Bytecode" target="_blank" rel="noopener"><code>Bytecode</code></a> 实例，将设置 <em>current_offset</em> 为异常负责的指令。<code>codeobj</code>已编译的代码对象。<code>first_line</code>代码对象的第一个源代码行（如果可用）<code>dis</code>()返回字节码操作的格式化视图（与 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.dis" target="_blank" rel="noopener"><code>dis.dis()</code></a> 打印相同，但作为多行字符串返回）。<code>info</code>()返回带有关于代码对象的详细信息的格式化多行字符串，如 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.code_info" target="_blank" rel="noopener"><code>code_info()</code></a> 。<em>在 3.7 版更改:</em> 现在可以处理协程和异步生成器对象。</p>
</li>
</ul>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bytecode = dis.Bytecode(myfunc)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> instr <span class="keyword">in</span> bytecode:</span><br><span class="line"><span class="meta">... </span>    print(instr.opname)</span><br><span class="line">...</span><br><span class="line">LOAD_GLOBAL</span><br><span class="line">LOAD_FAST</span><br><span class="line">CALL_FUNCTION</span><br><span class="line">RETURN_VALUE</span><br></pre></td></tr></table></figure>
<h2 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/dis.html#module-dis" target="_blank" rel="noopener"><code>dis</code></a> 模块还定义了以下分析函数，它们将输入直接转换为所需的输出。如果只执行单个操作，它们可能很有用，因此中间分析对象没用：</p>
<ul>
<li><p><code>dis.code_info</code>(<em>x</em>)</p>
<p>返回格式化的多行字符串，其包含详细代码对象信息的用于被提供的函数、生成器、异步生成器、协程、方法、源代码字符串或代码对象。请注意，代码信息字符串的确切内容是高度依赖于实现的，它们可能会在Python VM或Python版本中任意更改。<em>3.2 新版功能.**在 3.7 版更改:</em> 现在可以处理协程和异步生成器对象。</p>
</li>
<li><p><code>dis.show_code</code>(<em>x</em>, <em>**, </em>file=None*)</p>
<p>将提供的函数、方法。源代码字符串或代码对象的详细代码对象信息打印到 <em>file</em> （如果未指定 <em>file</em> ，则为 <code>sys.stdout</code> ）。这是 <code>print(code_info(x), file=file)</code> 的便捷简写，用于在解释器提示符下进行交互式探索。<em>3.2 新版功能.**在 3.4 版更改:</em> 添加 <em>file</em> 形参。</p>
</li>
<li><p><code>dis.dis</code>(<em>x=None</em>, <em>**, </em>file=None<em>, </em>depth=None*)</p>
<p>反汇编 <em>x</em> 对象。 <em>x</em> 可以表示模块、类、方法、函数、生成器、异步生成器、协程、代码对象、源代码字符串或原始字节码的字节序列。对于模块，它会反汇编所有功能。对于一个类，它反汇编所有方法（包括类和静态方法）。对于代码对象或原始字节码序列，它每字节码指令打印一行。它还递归地反汇编嵌套代码对象（推导式代码，生成器表达式和嵌套函数，以及用于构建嵌套类的代码）。在被反汇编之前，首先使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#compile" target="_blank" rel="noopener"><code>compile()</code></a> 内置函数将字符串编译为代码对象。如果未提供任何对象，则此函数会反汇编最后一次回溯。如果提供的话，反汇编将作为文本写入提供的 <em>file</em> 参数，否则写入 <code>sys.stdout</code> 。递归的最大深度受 <em>depth</em> 限制，除非它是 <code>None</code> 。 <code>depth=0</code> 表示没有递归。<em>在 3.4 版更改:</em> 添加 <em>file</em> 形参。<em>在 3.7 版更改:</em> 实现了递归反汇编并添加了 <em>depth</em> 参数。<em>在 3.7 版更改:</em> 现在可以处理协程和异步生成器对象。</p>
</li>
<li><p><code>dis.distb</code>(<em>tb=None</em>, <em>**, </em>file=None*)</p>
<p>如果没有传递，则使用最后一个回溯来反汇编回溯的堆栈顶部函数。 指示了导致异常的指令。如果提供的话，反汇编将作为文本写入提供的 <em>file</em> 参数，否则写入 <code>sys.stdout</code> 。<em>在 3.4 版更改:</em> 添加 <em>file</em> 形参。</p>
</li>
<li><p><code>dis.disassemble</code>(<em>code</em>, <em>lasti=-1</em>, <em>**, </em>file=None*)</p>
</li>
<li><p><code>dis.disco</code>(<em>code</em>, <em>lasti=-1</em>, <em>**, </em>file=None*)</p>
<p>反汇编代码对象，如果提供了 <em>lasti</em> ，则指示最后一条指令。输出分为以下几列：行号，用于每行的第一条指令当前指令，表示为 <code>--&gt;</code> ，一个标记的指令，用 <code>&gt;&gt;</code> 表示，指令的地址，操作码名称，操作参数，和括号中参数的解释。参数解释识别本地和全局变量名称、常量值、分支目标和比较运算符。如果提供的话，反汇编将作为文本写入提供的 <em>file</em> 参数，否则写入 <code>sys.stdout</code> 。<em>在 3.4 版更改:</em> 添加 <em>file</em> 形参。</p>
</li>
<li><p><code>dis.get_instructions</code>(<em>x</em>, <em>**, </em>first_line=None*)</p>
<p>在所提供的函数、方法、源代码字符串或代码对象中的指令上返回一个迭代器。迭代器生成一系列 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Instruction" target="_blank" rel="noopener"><code>Instruction</code></a> ，命名为元组，提供所提供代码中每个操作的详细信息。如果 <em>first_line</em> 不是 <code>None</code> ，则表示应该为反汇编代码中的第一个源代码行报告的行号。否则，源行信息（如果有的话）直接来自反汇编的代码对象。<em>3.4 新版功能.</em></p>
</li>
<li><p><code>dis.findlinestarts</code>(<em>code</em>)</p>
<p>此生成器函数使用代码对象 <em>code</em> 的 <code>co_firstlineno</code> 和 <code>co_lnotab</code> 属性来查找源代码中行开头的偏移量。它们生成为 <code>(offset, lineno)</code> 对。请参阅 <a href="https://github.com/python/cpython/tree/3.8/objects/lnotab_notes.txt" target="_blank" rel="noopener">objects/lnotab_notes.txt</a> ，了解 <code>co_lnotab</code> 格式以及如何解码它。<em>在 3.6 版更改:</em> 行号可能会减少。 以前，他们总是在增加。</p>
</li>
<li><p><code>dis.findlabels</code>(<em>code</em>)</p>
<p>检测作为跳转目标的代码对象 <em>code</em> 中的所有偏移量，并返回这些偏移量的列表。</p>
</li>
<li><p><code>dis.stack_effect</code>(<em>opcode</em>, <em>oparg=None</em>, <em>**, </em>jump=None*)</p>
<p>使用参数 <em>oparg</em> 计算 <em>opcode</em> 的堆栈效果。如果代码有一个跳转目标并且 <em>jump</em> 是 <code>True</code> ，则 <code>drag_effect()</code> 将返回跳转的堆栈效果。如果 <em>jump</em> 是 <code>False</code> ，它将返回不跳跃的堆栈效果。如果 <em>jump</em> 是 <code>None</code> （默认值），它将返回两种情况的最大堆栈效果。<em>3.4 新版功能.**在 3.8 版更改:</em> 添加 <em>jump</em> 参数。</p>
</li>
</ul>
<h2 id="Python字节码说明"><a href="#Python字节码说明" class="headerlink" title="Python字节码说明"></a>Python字节码说明</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.get_instructions" target="_blank" rel="noopener"><code>get_instructions()</code></a> 函数和 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Bytecode" target="_blank" rel="noopener"><code>Bytecode</code></a> 类提供字节码指令的详细信息的 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Instruction" target="_blank" rel="noopener"><code>Instruction</code></a> 实例：</p>
<ul>
<li><p><em>class</em> <code>dis.Instruction</code></p>
<p>字节码操作的详细信息<code>opcode</code>操作的数字代码，对应于下面列出的操作码值和 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-collections" target="_blank" rel="noopener">操作码集合</a> 中的字节码值。<code>opname</code>人类可读的操作名称<code>arg</code>操作的数字参数（如果有的话），否则为 <code>Noneargval</code>已解析的 arg 值（如果已知），否则与 arg 相同<code>argrepr</code>人类可读的操作参数描述<code>offset</code>在字节码序列中启动操作索引<code>starts_line</code>行由此操作码（如果有）启动，否则为 <code>Noneis_jump_target</code>如果其他代码跳到这里，则为 <code>True</code> ，否则为 <code>False</code><em>3.4 新版功能.</em></p>
</li>
</ul>
<p>Python编译器当前生成以下字节码指令。</p>
<p><strong>一般指令</strong></p>
<ul>
<li><p><code>NOP</code></p>
<p>什么都不做。 用作字节码优化器的占位符。</p>
</li>
<li><p><code>POP_TOP</code></p>
<p>删除堆栈顶部（TOS）项。</p>
</li>
<li><p><code>ROT_TWO</code></p>
<p>交换两个最顶层的堆栈项。</p>
</li>
<li><p><code>ROT_THREE</code></p>
<p>将第二个和第三个堆栈项向上提升一个位置，顶项移动到位置三。</p>
</li>
<li><p><code>ROT_FOUR</code></p>
<p>将第二个，第三个和第四个堆栈项向上提升一个位置，将顶项移动到第四个位置。<em>3.8 新版功能.</em></p>
</li>
<li><p><code>DUP_TOP</code></p>
<p>复制堆栈顶部的引用。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>DUP_TOP_TWO</code></p>
<p>复制堆栈顶部的两个引用，使它们保持相同的顺序。<em>3.2 新版功能.</em></p>
</li>
</ul>
<p><strong>一元操作</strong></p>
<p>一元操作获取堆栈顶部元素，应用操作，并将结果推回堆栈。</p>
<ul>
<li><p><code>UNARY_POSITIVE</code></p>
<p>实现 <code>TOS = +TOS</code> 。</p>
</li>
<li><p><code>UNARY_NEGATIVE</code></p>
<p>实现 <code>TOS = -TOS</code> 。</p>
</li>
<li><p><code>UNARY_NOT</code></p>
<p>实现 <code>TOS = not TOS</code> 。</p>
</li>
<li><p><code>UNARY_INVERT</code></p>
<p>实现 <code>TOS = ~TOS</code> 。</p>
</li>
<li><p><code>GET_ITER</code></p>
<p>实现 <code>TOS = iter(TOS)</code> 。</p>
</li>
<li><p><code>GET_YIELD_FROM_ITER</code></p>
<p>如果 <code>TOS</code> 是一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator-iterator" target="_blank" rel="noopener">generator iterator</a> 或 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 对象则保持原样。否则实现 <code>TOS = iter(TOS)</code> 。<em>3.5 新版功能.</em></p>
</li>
</ul>
<p><strong>二元操作</strong></p>
<p>二元操作从堆栈中删除堆栈顶部（TOS）和第二个最顶层堆栈项（TOS1）。 它们执行操作，并将结果放回堆栈。</p>
<ul>
<li><p><code>BINARY_POWER</code></p>
<p>实现 <code>TOS = TOS1 ** TOS</code> 。</p>
</li>
<li><p><code>BINARY_MULTIPLY</code></p>
<p>实现 <code>TOS = TOS1 * TOS</code> 。</p>
</li>
<li><p><code>BINARY_MATRIX_MULTIPLY</code></p>
<p>实现 <code>TOS = TOS1 @ TOS</code> 。<em>3.5 新版功能.</em></p>
</li>
<li><p><code>BINARY_FLOOR_DIVIDE</code></p>
<p>实现 <code>TOS = TOS1 // TOS</code>。</p>
</li>
<li><p><code>BINARY_TRUE_DIVIDE</code></p>
<p>实现 <code>TOS = TOS1 / TOS</code> 。</p>
</li>
<li><p><code>BINARY_MODULO</code></p>
<p>实现 <code>TOS = TOS1 % TOS</code> 。</p>
</li>
<li><p><code>BINARY_ADD</code></p>
<p>实现 <code>TOS = TOS1 + TOS</code> 。</p>
</li>
<li><p><code>BINARY_SUBTRACT</code></p>
<p>实现 <code>TOS = TOS1 - TOS</code> 。</p>
</li>
<li><p><code>BINARY_SUBSCR</code></p>
<p>实现 <code>TOS = TOS1[TOS]</code> 。</p>
</li>
<li><p><code>BINARY_LSHIFT</code></p>
<p>实现 <code>TOS = TOS1 &lt;&lt; TOS</code> 。</p>
</li>
<li><p><code>BINARY_RSHIFT</code></p>
<p>实现 <code>TOS = TOS1 &gt;&gt; TOS</code> 。</p>
</li>
<li><p><code>BINARY_AND</code></p>
<p>实现 <code>TOS = TOS1 &amp; TOS</code> 。</p>
</li>
<li><p><code>BINARY_XOR</code></p>
<p>实现 <code>TOS = TOS1 ^ TOS</code> 。</p>
</li>
<li><p><code>BINARY_OR</code></p>
<p>实现 <code>TOS = TOS1 | TOS</code> 。</p>
</li>
</ul>
<p><strong>就地操作</strong></p>
<p>就地操作就像二元操作，因为它们删除了TOS和TOS1，并将结果推回到堆栈上，但是当TOS1支持它时，操作就地完成，并且产生的TOS可能是（但不一定） 原来的TOS1。</p>
<ul>
<li><p><code>INPLACE_POWER</code></p>
<p>就地实现 <code>TOS = TOS1 ** TOS</code> 。</p>
</li>
<li><p><code>INPLACE_MULTIPLY</code></p>
<p>就地实现 <code>TOS = TOS1 * TOS</code> 。</p>
</li>
<li><p><code>INPLACE_MATRIX_MULTIPLY</code></p>
<p>就地实现 <code>TOS = TOS1 @ TOS</code> 。<em>3.5 新版功能.</em></p>
</li>
<li><p><code>INPLACE_FLOOR_DIVIDE</code></p>
<p>就地实现 <code>TOS = TOS1 // TOS</code> 。</p>
</li>
<li><p><code>INPLACE_TRUE_DIVIDE</code></p>
<p>就地实现 <code>TOS = TOS1 / TOS</code> 。</p>
</li>
<li><p><code>INPLACE_MODULO</code></p>
<p>就地实现 <code>TOS = TOS1 % TOS</code> 。</p>
</li>
<li><p><code>INPLACE_ADD</code></p>
<p>就地实现 <code>TOS = TOS1 + TOS</code> 。</p>
</li>
<li><p><code>INPLACE_SUBTRACT</code></p>
<p>就地实现 <code>TOS = TOS1 - TOS</code> 。</p>
</li>
<li><p><code>INPLACE_LSHIFT</code></p>
<p>就地实现 <code>TOS = TOS1 &lt;&lt; TOS</code> 。</p>
</li>
<li><p><code>INPLACE_RSHIFT</code></p>
<p>就地实现 <code>TOS = TOS1 &gt;&gt; TOS</code> 。</p>
</li>
<li><p><code>INPLACE_AND</code></p>
<p>就地实现 <code>TOS = TOS1 &amp; TOS</code> 。</p>
</li>
<li><p><code>INPLACE_XOR</code></p>
<p>就地实现 <code>TOS = TOS1 ^ TOS</code> 。</p>
</li>
<li><p><code>INPLACE_OR</code></p>
<p>就地实现 <code>TOS = TOS1 | TOS</code> 。</p>
</li>
<li><p><code>STORE_SUBSCR</code></p>
<p>实现 <code>TOS1[TOS] = TOS2</code> 。</p>
</li>
<li><p><code>DELETE_SUBSCR</code></p>
<p>实现 <code>del TOS1[TOS]</code> 。</p>
</li>
</ul>
<p><strong>协程操作码</strong></p>
<ul>
<li><p><code>GET_AWAITABLE</code></p>
<p>实现 <code>TOS = get_awaitable(TOS)</code> ，其中 <code>get_awaitable(o)</code> 返回 <code>o</code> 如果 <code>o</code> 是一个有 CO_ITERABLE_COROUTINE 标志的协程对象或生成器对象，否则解析 <code>o.__await__</code> 。<em>3.5 新版功能.</em></p>
</li>
<li><p><code>GET_AITER</code></p>
<p>实现 <code>TOS = TOS.__aiter__()</code> 。<em>3.5 新版功能.**在 3.7 版更改:</em> 已经不再支持从 <code>__aiter__</code> 返回可等待对象。</p>
</li>
<li><p><code>GET_ANEXT</code></p>
<p>实现 <code>PUSH(get_awaitable(TOS.__anext__()))</code> 。参见 <code>GET_AWAITABLE</code> 获取更多 <code>get_awaitable</code> 的细节<em>3.5 新版功能.</em></p>
</li>
<li><p><code>END_ASYNC_FOR</code></p>
<p>终止一个 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-for" target="_blank" rel="noopener"><code>async for</code></a> 循环。处理等待下一个项目时引发的异常。如果 TOS 是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopAsyncIteration" target="_blank" rel="noopener"><code>StopAsyncIteration</code></a>， 从堆栈弹出7个值，并使用后三个恢复异常状态。否则，使用堆栈中的三个值重新引发异常。从块堆栈中删除异常处理程序块。<em>3.8 新版功能.</em></p>
</li>
<li><p><code>BEFORE_ASYNC_WITH</code></p>
<p>从栈顶对象解析 <code>__aenter__</code> 和 <code>__aexit__</code> 。将 <code>__aexit__</code> 和 <code>__aenter__()</code> 的结果推入堆栈。<em>3.5 新版功能.</em></p>
</li>
<li><p><code>SETUP_ASYNC_WITH</code></p>
<p>创建一个新的帧对象。<em>3.5 新版功能.</em></p>
</li>
</ul>
<p><strong>其他操作码</strong></p>
<ul>
<li><p><code>PRINT_EXPR</code></p>
<p>实现交互模式的表达式语句。TOS从堆栈中被移除并打印。在非交互模式下，表达式语句以 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-POP_TOP" target="_blank" rel="noopener"><code>POP_TOP</code></a> 终止。</p>
</li>
<li><p><code>SET_ADD</code>(<em>i</em>)</p>
<p>调用 <code>set.add(TOS1[-i], TOS)</code> 。 用于实现集合推导。</p>
</li>
<li><p><code>LIST_APPEND</code>(<em>i</em>)</p>
<p>调用 <code>list.append(TOS[-i], TOS)</code> 。 用于实现列表推导。</p>
</li>
<li><p><code>MAP_ADD</code>(<em>i</em>)</p>
<p>调用 <code>dict.__setitem__(TOS1[-i], TOS1, TOS)</code> 。 用于实现字典推导。<em>3.1 新版功能.**在 3.8 版更改:</em> 映射值为 TOS ，映射键为 TOS1 。之前，它们被颠倒了。</p>
</li>
</ul>
<p>对于所有 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-SET_ADD" target="_blank" rel="noopener"><code>SET_ADD</code></a> 、 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-LIST_APPEND" target="_blank" rel="noopener"><code>LIST_APPEND</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-MAP_ADD" target="_blank" rel="noopener"><code>MAP_ADD</code></a> 指令，当弹出添加的值或键值对时，容器对象保留在堆栈上，以便它可用于循环的进一步迭代。</p>
<ul>
<li><p><code>RETURN_VALUE</code></p>
<p>返回 TOS 到函数的调用者。</p>
</li>
<li><p><code>YIELD_VALUE</code></p>
<p>弹出 TOS 并从一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 生成它。</p>
</li>
<li><p><code>YIELD_FROM</code></p>
<p>弹出 TOS 并将其委托给它作为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 的子迭代器。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>SETUP_ANNOTATIONS</code></p>
<p>检查 <code>__annotations__</code> 是否在 <code>locals()</code> 中定义，如果没有，它被设置为空 <code>dict</code> 。只有在类或模块体静态地包含 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-variable-annotation" target="_blank" rel="noopener">variable annotations</a> 时才会发出此操作码。<em>3.6 新版功能.</em></p>
</li>
<li><p><code>IMPORT_STAR</code></p>
<p>将所有不以 <code>&#39;_&#39;</code> 开头的符号直接从模块 TOS 加载到局部命名空间。加载所有名称后弹出该模块。这个操作码实现了 <code>from module import *</code> 。</p>
</li>
<li><p><code>POP_BLOCK</code></p>
<p>从块堆栈中删除一个块。有一块堆栈，每帧用于表示 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句等。</p>
</li>
<li><p><code>POP_EXCEPT</code></p>
<p>从块堆栈中删除一个块。 弹出的块必须是异常处理程序块，在进入 except 处理程序时隐式创建。除了从帧堆栈弹出无关值之外，最后三个弹出值还用于恢复异常状态。</p>
</li>
<li><p><code>POP_FINALLY</code>(<em>preserve_tos</em>)</p>
<p>清除值堆栈和块堆栈。如果 <em>preserve_tos</em> 不是 <code>0</code> ，则在执行其他堆栈操作后，首先从堆栈中弹出 TOS 并将其推入堆栈：如果TOS是 <code>NULL</code> 或整数（由 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BEGIN_FINALLY" target="_blank" rel="noopener"><code>BEGIN_FINALLY</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-CALL_FINALLY" target="_blank" rel="noopener"><code>CALL_FINALLY</code></a> 推入），它将从堆栈中弹出。如果TOS是异常类型（在引发异常时被推入），则从堆栈中弹出6个值，最后三个弹出值用于恢复异常状态。从块堆栈中删除异常处理程序块。它类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-END_FINALLY" target="_blank" rel="noopener"><code>END_FINALLY</code></a> ，但不会更改字节码计数器也不会引发异常。用于在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 块中实现 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#break" target="_blank" rel="noopener"><code>break</code></a> 、 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#continue" target="_blank" rel="noopener"><code>continue</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a> 。<em>3.8 新版功能.</em></p>
</li>
<li><p><code>BEGIN_FINALLY</code></p>
<p>将 <code>NULL</code> 推入堆栈以便在以下操作中使用 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-END_FINALLY" target="_blank" rel="noopener"><code>END_FINALLY</code></a> 、 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-POP_FINALLY" target="_blank" rel="noopener"><code>POP_FINALLY</code></a> 、 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-WITH_CLEANUP_START" target="_blank" rel="noopener"><code>WITH_CLEANUP_START</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-WITH_CLEANUP_FINISH" target="_blank" rel="noopener"><code>WITH_CLEANUP_FINISH</code></a> 。开始 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 块。<em>3.8 新版功能.</em></p>
</li>
<li><p><code>END_FINALLY</code></p>
<p>终止 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句。解释器回溯是否有必须重新抛出异常的情况或根据 TOS 的值继续执行。如果 TOS 是 <code>NULL</code> （由 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BEGIN_FINALLY" target="_blank" rel="noopener"><code>BEGIN_FINALLY</code></a> 推入）继续下一条指令。 TOS 被弹出。如果 TO S是一个整数（由 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-CALL_FINALLY" target="_blank" rel="noopener"><code>CALL_FINALLY</code></a> 推入），则将字节码计数器设置为 TOS 。 TOS 被弹出。如果TOS是异常类型（在引发异常时被推送），则从堆栈中弹出 6 个值，前三个弹出值用于重新引发异常，最后三个弹出值用于恢复异常状态。从块堆栈中删除异常处理程序块。</p>
</li>
<li><p><code>LOAD_BUILD_CLASS</code></p>
<p>将 <code>builtins .__ build_class__()</code> 推到堆栈上。它之后被 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-CALL_FUNCTION" target="_blank" rel="noopener"><code>CALL_FUNCTION</code></a> 调用来构造一个类。</p>
</li>
<li><p><code>SETUP_WITH</code>(<em>delta</em>)</p>
<p>此操作码在 with 块开始之前执行多个操作。首先，它从上下文管理器加载 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 并将其推入到堆栈以供以后被 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-WITH_CLEANUP_START" target="_blank" rel="noopener"><code>WITH_CLEANUP_START</code></a> 使用。然后，调用 <code>__enter__()</code> ，并推入指向 <em>delta</em> 的 finally 块。最后，调用 <code>__enter__()</code> 方法的结果被压入堆栈。一个操作码将忽略它（ <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-POP_TOP" target="_blank" rel="noopener"><code>POP_TOP</code></a> ），或将其存储在一个或多个变量（ <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-STORE_FAST" target="_blank" rel="noopener"><code>STORE_FAST</code></a> 、 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-STORE_NAME" target="_blank" rel="noopener"><code>STORE_NAME</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-UNPACK_SEQUENCE" target="_blank" rel="noopener"><code>UNPACK_SEQUENCE</code></a> ）中。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>WITH_CLEANUP_START</code></p>
<p>当 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句块退出时，开始清理堆栈。在堆栈的顶部是 <code>NULL</code> （由 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BEGIN_FINALLY" target="_blank" rel="noopener"><code>BEGIN_FINALLY</code></a> 推送）或者如果在 with 块中引发了异常，则推送 6 个值。下面是上下文管理器 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aexit__" target="_blank" rel="noopener"><code>__aexit__()</code></a> 绑定方法。如果TOS是 <code>NULL</code> ，则调用 <code>SECOND(None, None, None)</code> ，从堆栈中删除函数，离开 TOS ，并将 <code>None</code> 推送到堆栈。 否则调用 <code>SEVENTH(TOP, SECOND, THIRD)</code> ，将堆栈的底部3值向下移动，用 <code>NULL</code> 替换空位并推入 TOS 。最后拖入调用的结果。</p>
</li>
<li><p><code>WITH_CLEANUP_FINISH</code></p>
<p>当 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句块退出时，完成清理堆栈。TOS 是 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-WITH_CLEANUP_START" target="_blank" rel="noopener"><code>WITH_CLEANUP_START</code></a> 推送的 <code>__exit__()</code> 或 <code>__aexit__()</code> 函数的结果。 SECOND是 <code>None</code> 或异常类型（引发异常时推入的）。从堆栈中弹出两个值。如果 SECOND 不为 None 并且 TOS 为 true ，则展开 EXCEPT_HANDLER 块，该块是在捕获异常时创建的，并将 <code>NULL</code> 推入堆栈。</p>
</li>
</ul>
<p>以下所有操作码均使用其参数。</p>
<ul>
<li><p><code>STORE_NAME</code>(<em>namei</em>)</p>
<p>实现 <code>name = TOS</code>。 <em>namei</em> 是 <em>name</em> 在代码对象的 <code>co_names</code> 属性中的索引。 在可能的情况下，编译器会尝试使用 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-STORE_FAST" target="_blank" rel="noopener"><code>STORE_FAST</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-STORE_GLOBAL" target="_blank" rel="noopener"><code>STORE_GLOBAL</code></a>。</p>
</li>
<li><p><code>DELETE_NAME</code>(<em>namei</em>)</p>
<p>实现 <code>del name</code> ，其中 <em>namei</em> 是代码对象的 <code>co_names</code> 属性的索引。</p>
</li>
<li><p><code>UNPACK_SEQUENCE</code>(<em>count</em>)</p>
<p>将 TOS 解包为 <em>count</em> 个单独的值，它们将按从右至左的顺序被放入堆栈。</p>
</li>
<li><p><code>UNPACK_EX</code>(<em>counts</em>)</p>
<p>实现使用带星号的目标进行赋值：将 TOS 中的可迭代对象解包为单独的值，其中值的总数可以小于可迭代对象中的项数：新值之一将是由所有剩余项构成的列表。<em>counts</em> 的低字节是列表值之前的值的数量，<em>counts</em> 中的高字节则是之后的值的数量。 结果值会按从右至左的顺序入栈。</p>
</li>
<li><p><code>STORE_ATTR</code>(<em>namei</em>)</p>
<p>实现 <code>TOS.name = TOS1</code>，其中 <em>namei</em> 是 name 在 <code>co_names</code> 中的索引号。</p>
</li>
<li><p><code>DELETE_ATTR</code>(<em>namei</em>)</p>
<p>实现 <code>del TOS.name</code>，使用 <em>namei</em> 作为 <code>co_names</code> 中的索引号。</p>
</li>
<li><p><code>STORE_GLOBAL</code>(<em>namei</em>)</p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-STORE_NAME" target="_blank" rel="noopener"><code>STORE_NAME</code></a> 但会将 name 存储为全局变量。</p>
</li>
<li><p><code>DELETE_GLOBAL</code>(<em>namei</em>)</p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-DELETE_NAME" target="_blank" rel="noopener"><code>DELETE_NAME</code></a> 但会删除一个全局变量。</p>
</li>
<li><p><code>LOAD_CONST</code>(<em>consti</em>)</p>
<p>将 <code>co_consts[consti]</code> 推入栈顶。</p>
</li>
<li><p><code>LOAD_NAME</code>(<em>namei</em>)</p>
<p>将与 <code>co_names[namei]</code> 相关联的值推入栈顶。</p>
</li>
<li><p><code>BUILD_TUPLE</code>(<em>count</em>)</p>
<p>创建一个使用了来自栈的 <em>count</em> 个项的元组，并将结果元组推入栈顶。</p>
</li>
<li><p><code>BUILD_LIST</code>(<em>count</em>)</p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_TUPLE" target="_blank" rel="noopener"><code>BUILD_TUPLE</code></a> 但会创建一个列表。</p>
</li>
<li><p><code>BUILD_SET</code>(<em>count</em>)</p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_TUPLE" target="_blank" rel="noopener"><code>BUILD_TUPLE</code></a> 但会创建一个集合。</p>
</li>
<li><p><code>BUILD_MAP</code>(<em>count</em>)</p>
<p>将一个新字典对象推入栈顶。 弹出 <code>2 * count</code> 项使得字典包含 <em>count</em> 个条目: <code>{..., TOS3: TOS2, TOS1: TOS}</code>。<em>在 3.5 版更改:</em> 字典是根据栈中的项创建而不是创建一个预设大小包含 <em>count</em> 项的空字典。</p>
</li>
<li><p><code>BUILD_CONST_KEY_MAP</code>(<em>count</em>)</p>
<p>专用于常量键的 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_MAP" target="_blank" rel="noopener"><code>BUILD_MAP</code></a> 版本。 <em>count</em> 值是从栈中提取的。 栈顶的元素包含一个由键构成的元组。<em>3.6 新版功能.</em></p>
</li>
<li><p><code>BUILD_STRING</code>(<em>count</em>)</p>
<p>拼接 <em>count</em> 个来自栈的字符串并将结果字符串推入栈顶。<em>3.6 新版功能.</em></p>
</li>
<li><p><code>BUILD_TUPLE_UNPACK</code>(<em>count</em>)</p>
<p>从栈中弹出 <em>count</em> 个可迭代对象，将它们合并为单个元组，并将结果推入栈顶。 实现可迭代对象解包为元组形式 <code>(*x, *y, *z)</code>。<em>3.5 新版功能.</em></p>
</li>
<li><p><code>BUILD_TUPLE_UNPACK_WITH_CALL</code>(<em>count</em>)</p>
<p>这类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_TUPLE_UNPACK" target="_blank" rel="noopener"><code>BUILD_TUPLE_UNPACK</code></a> 但专用于 <code>f(*x, *y, *z)</code> 调用语法。 栈中 <code>count + 1</code> 位置上的项应当是相应的可调用对象 <code>f</code>。<em>3.6 新版功能.</em></p>
</li>
<li><p><code>BUILD_LIST_UNPACK</code>(<em>count</em>)</p>
<p>这类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_TUPLE_UNPACK" target="_blank" rel="noopener"><code>BUILD_TUPLE_UNPACK</code></a> 但会将一个列表而非元组推入栈顶。 实现可迭代对象解包为列表形式 <code>[*x, *y, *z]</code>。<em>3.5 新版功能.</em></p>
</li>
<li><p><code>BUILD_SET_UNPACK</code>(<em>count</em>)</p>
<p>这类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_TUPLE_UNPACK" target="_blank" rel="noopener"><code>BUILD_TUPLE_UNPACK</code></a> 但会将一个集合而非元组推入栈顶。 实现可迭代对象解包为集合形式 <code>{*x, *y, *z}</code>。<em>3.5 新版功能.</em></p>
</li>
<li><p><code>BUILD_MAP_UNPACK</code>(<em>count</em>)</p>
<p>从栈中弹出 <em>count</em> 个映射对象，将它们合并为单个字典，并将结果推入栈顶。 实现字典解包为字典形式 <code>{**x, **y, **z}</code>。<em>3.5 新版功能.</em></p>
</li>
<li><p><code>BUILD_MAP_UNPACK_WITH_CALL</code>(<em>count</em>)</p>
<p>这类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_MAP_UNPACK" target="_blank" rel="noopener"><code>BUILD_MAP_UNPACK</code></a> 但专用于 <code>f(**x, **y, **z)</code> 调用语法。 栈中 <code>count + 2</code> 位置上的项应当是相应的可调用对象 <code>f</code>。<em>3.5 新版功能.**在 3.6 版更改:</em> 可迭代对象的位置的确定方式是将操作码参数加 2 而不是将其编码到参数的第二个字节。</p>
</li>
<li><p><code>LOAD_ATTR</code>(<em>namei</em>)</p>
<p>将 TOS 替换为 <code>getattr(TOS, co_names[namei])</code>。</p>
</li>
<li><p><code>COMPARE_OP</code>(<em>opname</em>)</p>
<p>执行布尔运算操作。 操作名称可在 <code>cmp_op[opname]</code> 中找到。</p>
</li>
<li><p><code>IMPORT_NAME</code>(<em>namei</em>)</p>
<p>导入模块 <code>co_names[namei]</code>。 会弹出 TOS 和 TOS1 以提供 <em>fromlist</em> 和 <em>level</em> 参数给 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a>。 模块对象会被推入栈顶。 当前命名空间不受影响：对于一条标准 import 语句，会执行后续的 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-STORE_FAST" target="_blank" rel="noopener"><code>STORE_FAST</code></a> 指令来修改命名空间。</p>
</li>
<li><p><code>IMPORT_FROM</code>(<em>namei</em>)</p>
<p>从在 TOS 内找到的模块中加载属性 <code>co_names[namei]</code>。 结果对象会被推入栈顶，以便由后续的 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-STORE_FAST" target="_blank" rel="noopener"><code>STORE_FAST</code></a> 指令来保存。</p>
</li>
<li><p><code>JUMP_FORWARD</code>(<em>delta</em>)</p>
<p>将字节码计数器的值增加 <em>delta</em>。</p>
</li>
<li><p><code>POP_JUMP_IF_TRUE</code>(<em>target</em>)</p>
<p>如果 TOS 为真值，则将字节码计数器的值设为 <em>target</em>。 TOS 会被弹出。<em>3.1 新版功能.</em></p>
</li>
<li><p><code>POP_JUMP_IF_FALSE</code>(<em>target</em>)</p>
<p>如果 TOS 为假值，则将字节码计数器的值设为 <em>target</em>。 TOS 会被弹出。<em>3.1 新版功能.</em></p>
</li>
<li><p><code>JUMP_IF_TRUE_OR_POP</code>(<em>target</em>)</p>
<p>如果 TOS 为真值，则将字节码计数器的值设为 <em>target</em> 并将 TOS 留在栈顶。 否则（如 TOS 为假值），TOS 会被弹出。<em>3.1 新版功能.</em></p>
</li>
<li><p><code>JUMP_IF_FALSE_OR_POP</code>(<em>target</em>)</p>
<p>如果 TOS 为假值，则将字节码计数器的值设为 <em>target</em> 并将 TOS 留在栈顶。 否则（如 TOS 为假值），TOS 会被弹出。<em>3.1 新版功能.</em></p>
</li>
<li><p><code>JUMP_ABSOLUTE</code>(<em>target</em>)</p>
<p>将字节码计数器的值设为 <em>target</em>。</p>
</li>
<li><p><code>FOR_ITER</code>(<em>delta</em>)</p>
<p>TOS 是一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a>。 可调用它的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法。 如果产生了一个新值，则将其推入栈顶（将迭代器留在其下方）。 如果迭代器提示已耗尽则 TOS 会被弹出，并将字节码计数器的值增加 <em>delta</em>。</p>
</li>
<li><p><code>LOAD_GLOBAL</code>(<em>namei</em>)</p>
<p>加载名称为 <code>co_names[namei]</code> 的全局对象推入栈顶。</p>
</li>
<li><p><code>SETUP_FINALLY</code>(<em>delta</em>)</p>
<p>将一个来自 try-finally 或 try-except 子句的 try 代码块推入代码块栈顶。 相对 finally 代码块或第一个 except 代码块 <em>delta</em> 个点数。</p>
</li>
<li><p><code>CALL_FINALLY</code>(<em>delta</em>)</p>
<p>将下一条指令的地址推入栈顶并将字节码计数器的值增加 <em>delta</em>。 用于将 finally 代码块作为一个“子例程”调用。<em>3.8 新版功能.</em></p>
</li>
<li><p><code>LOAD_FAST</code>(<em>var_num</em>)</p>
<p>将指向局部对象 <code>co_varnames[var_num]</code> 的引用推入栈顶。</p>
</li>
<li><p><code>STORE_FAST</code>(<em>var_num</em>)</p>
<p>将 TOS 存放到局部对象 <code>co_varnames[var_num]</code>。</p>
</li>
<li><p><code>DELETE_FAST</code>(<em>var_num</em>)</p>
<p>移除局部对象 <code>co_varnames[var_num]</code>。</p>
</li>
<li><p><code>LOAD_CLOSURE</code>(<em>i</em>)</p>
<p>将一个包含在单元的第 <em>i</em> 个空位中的对单元的引用推入栈顶并释放可用的存储空间。 如果 <em>i</em> 小于 <em>co_cellvars</em> 的长度则变量的名称为 <code>co_cellvars[i]</code>。 否则为 <code>co_freevars[i - len(co_cellvars)]</code>。</p>
</li>
<li><p><code>LOAD_DEREF</code>(<em>i</em>)</p>
<p>加载包含在单元的第 <em>i</em> 个空位中的单元并释放可用的存储空间。 将一个对单元所包含对象的引用推入栈顶。</p>
</li>
<li><p><code>LOAD_CLASSDEREF</code>(<em>i</em>)</p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-LOAD_DEREF" target="_blank" rel="noopener"><code>LOAD_DEREF</code></a> 但在查询单元之前会首先检查局部对象字典。 这被用于加载类语句体中的自由变量。<em>3.4 新版功能.</em></p>
</li>
<li><p><code>STORE_DEREF</code>(<em>i</em>)</p>
<p>将 TOS 存放到包含在单元的第 <em>i</em> 个空位中的单元内并释放可用存储空间。</p>
</li>
<li><p><code>DELETE_DEREF</code>(<em>i</em>)</p>
<p>清空包含在单元的第 <em>i</em> 个空位中的单元并释放可用存储空间。 被用于 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#del" target="_blank" rel="noopener"><code>del</code></a> 语句。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>RAISE_VARARGS</code>(<em>argc</em>)</p>
<p>使用 <code>raise</code> 语句的 3 种形式之一引发异常，具体形式取决于 <em>argc</em> 的值：0: <code>raise</code> (重新引发之前的异常)1: <code>raise TOS</code> (在 <code>TOS</code> 上引发异常实例或类型)2: <code>raise TOS1 from TOS</code> (在 <code>TOS1</code> 上引发异常实例或类型并将 <code>__cause__</code> 设为 <code>TOS</code>)</p>
</li>
<li><p><code>CALL_FUNCTION</code>(<em>argc</em>)</p>
<p>调用一个可调用对象并传入位置参数。 <em>argc</em> 指明位置参数的数量。 栈顶包含位置参数，其中最右边的参数在最顶端。 在参数之下是一个待调用的可调用对象。 <code>CALL_FUNCTION</code> 会从栈中弹出所有参数以及可调用对象，附带这些参数调用该可调用对象，并将可调用对象所返回的返回值推入栈顶。<em>在 3.6 版更改:</em> 此操作码仅用于附带位置参数的调用。</p>
</li>
<li><p><code>CALL_FUNCTION_KW</code>(<em>argc</em>)</p>
<p>调用一个可调用对象并传入位置参数（如果有的话）和关键字参数。 <em>argc</em> 指明位置参数和关键字参数的总数量。 栈顶元素包含一个关键字参数名称的元组。 在元组之下是根据元组排序的关键字参数。 在关键字参数之下是位置参数，其中最右边的参数在最顶端。 在参数之下是一个待调用的可调用对象。 <code>CALL_FUNCTION_KW</code> 会从栈中弹出所有参数以及可调用对象，附带这些参数调用该可调用对象，并将可调用对象所返回的返回值推入栈顶。<em>在 3.6 版更改:</em> 关键字参数会被打包为一个元组而非字典，<em>argc</em> 指明参数的总数量。</p>
</li>
<li><p><code>CALL_FUNCTION_EX</code>(<em>flags</em>)</p>
<p>调用一个可调用对象并附带位置参数和关键字参数变量集合。 如果设置了 <em>flags</em> 的最低位，则栈顶包含一个由额外关键字参数组成的映射对象。 在该对象之下是一个包含位置参数的可迭代对象和一个待调用的可调用对象。 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_MAP_UNPACK_WITH_CALL" target="_blank" rel="noopener"><code>BUILD_MAP_UNPACK_WITH_CALL</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_TUPLE_UNPACK_WITH_CALL" target="_blank" rel="noopener"><code>BUILD_TUPLE_UNPACK_WITH_CALL</code></a> 可用于合并多个映射对象和包含参数的可迭代对象。 在该可调用对象被调用之前，映射对象和可迭代对象会被分别“解包”并将它们的内容分别作为关键字参数和位置参数传入。 <code>CALL_FUNCTION_EX</code> 会从栈中弹出所有参数以及可调用对象，附带这些参数调用该可调用对象，并将可调用对象所返回的返回值推入栈顶。<em>3.6 新版功能.</em></p>
</li>
<li><p><code>LOAD_METHOD</code>(<em>namei</em>)</p>
<p>从 TOS 对象加载一个名为 <code>co_names[namei]</code> 的方法。 TOS 将被弹出。 此字节码可区分两种情况：如果 TOS 有一个名称正确的方法，字节码会将未绑定方法和 TOS 推入栈顶。 TOS 将在调用未绑定方法时被用作 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-CALL_METHOD" target="_blank" rel="noopener"><code>CALL_METHOD</code></a> 的第一个参数 (<code>self</code>)。 否则会将 <code>NULL</code> 和属性查找所返回的对象推入栈顶。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>CALL_METHOD</code>(<em>argc</em>)</p>
<p>调用一个方法。 <em>argc</em> 是位置参数的数量。 关键字参数不受支持。 此操作码被设计用于配合 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-LOAD_METHOD" target="_blank" rel="noopener"><code>LOAD_METHOD</code></a> 使用。 位置参数放在栈顶。 在它们之下放在栈中的是由 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-LOAD_METHOD" target="_blank" rel="noopener"><code>LOAD_METHOD</code></a> 所描述的两个条目（或者是 <code>self</code> 和一个未绑定方法对象，或者是 <code>NULL</code> 和一个任意可调用对象）。 它们会被全部弹出并将返回值推入栈顶。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>MAKE_FUNCTION</code>(<em>flags</em>)</p>
<p>将一个新函数对象推入栈顶。 从底端到顶端，如果参数带有指定的旗标值则所使用的栈必须由这些值组成。<code>0x01</code> 一个默认值的元组，用于按位置排序的仅限位置形参以及位置或关键字形参<code>0x02</code> 一个仅限关键字形参的默认值的字典<code>0x04</code> 是一个标注字典<code>0x08</code> 一个包含用于自由变量的单元的元组，生成一个闭包与函数相关联的代码 (在 TOS1)函数的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-qualified-name" target="_blank" rel="noopener">qualified name</a> (在 TOS)</p>
</li>
<li><p><code>BUILD_SLICE</code>(<em>argc</em>)</p>
<p>将一个切片对象推入栈顶。 <em>argc</em> 必须为 2 或 3。 如果为 2，则推入 <code>slice(TOS1, TOS)</code>；如果为 3，则推入 <code>slice(TOS2, TOS1, TOS)</code>。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#slice" target="_blank" rel="noopener"><code>slice()</code></a> 内置函数了解详细信息。</p>
</li>
<li><p><code>EXTENDED_ARG</code>(<em>ext</em>)</p>
<p>为任意带有大到无法放入默认的单字节的参数的操作码添加前缀。 <em>ext</em> 存放一个附加字节作为参数中的高比特位。 对于每个操作码，最多允许三个 <code>EXTENDED_ARG</code> 前缀，构成两字节到三字节的参数。</p>
</li>
<li><p><code>FORMAT_VALUE</code>(<em>flags</em>)</p>
<p>用于实现格式化字面值字符串（f-字符串）。 从栈中弹出一个可选的 <em>fmt_spec</em>，然后是一个必须的 <em>value</em>。 <em>flags</em> 的解读方式如下：<code>(flags &amp; 0x03) == 0x00</code>: <em>value</em> 按原样格式化。<code>(flags &amp; 0x03) == 0x01</code>: 在格式化 <em>value</em> 之前调用其 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a>。<code>(flags &amp; 0x03) == 0x02</code>: 在格式化 <em>value</em> 之前调用其 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a>。<code>(flags &amp; 0x03) == 0x03</code>: 在格式化 <em>value</em> 之前调用其 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#ascii" target="_blank" rel="noopener"><code>ascii()</code></a>。<code>(flags &amp; 0x04) == 0x04</code>: 从栈中弹出 <em>fmt_spec</em> 并使用它，否则使用空的 <em>fmt_spec</em>。使用 <code>PyObject_Format()</code> 执行格式化。 结果会被推入栈顶。<em>3.6 新版功能.</em></p>
</li>
<li><p><code>HAVE_ARGUMENT</code></p>
<p>这不是一个真正的操作码。 它用于标明使用参数和不使用参数的操作码 (分别为 <code>&lt; HAVE_ARGUMENT</code> 和 <code>&gt;= HAVE_ARGUMENT</code>) 之间的分隔线。<em>在 3.6 版更改:</em> 现在每条指令都带有参数，但操作码 <code>&lt; HAVE_ARGUMENT</code> 会忽略它。 之前仅限操作码 <code>&gt;= HAVE_ARGUMENT</code> 带有参数。</p>
</li>
</ul>
<h2 id="操作码集合"><a href="#操作码集合" class="headerlink" title="操作码集合"></a>操作码集合</h2><p>提供这些集合用于字节码指令的自动内省：</p>
<ul>
<li><p><code>dis.opname</code></p>
<p>操作名称的序列，可使用字节码来索引。</p>
</li>
<li><p><code>dis.opmap</code></p>
<p>映射操作名称到字节码的字典</p>
</li>
<li><p><code>dis.cmp_op</code></p>
<p>所有比较操作名称的序列。</p>
</li>
<li><p><code>dis.hasconst</code></p>
<p>访问常量的字节码序列。</p>
</li>
<li><p><code>dis.hasfree</code></p>
<p>访问自由变量的字节码序列（请注意这里所说的‘自由’是指在当前作用域中被内部作用域所引用的名称，或在外部作用域中被此作用域所引用的名称。 它 <em>并不</em> 包括对全局或内置作用域的引用）。</p>
</li>
<li><p><code>dis.hasname</code></p>
<p>按名称访问属性的字节码序列。</p>
</li>
<li><p><code>dis.hasjrel</code></p>
<p>具有相对跳转目标的字节码序列。</p>
</li>
<li><p><code>dis.hasjabs</code></p>
<p>具有绝对跳转目标的字节码序列。</p>
</li>
<li><p><code>dis.haslocal</code></p>
<p>访问局部变量的字节码序列。</p>
</li>
<li><p><code>dis.hascompare</code></p>
<p>布尔运算的字节码序列。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>dis</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library pwd</title>
    <url>/2020/03/20/python-standard-library-pwd/</url>
    <content><![CDATA[<h1 id="python-标准库-pwd-用户密码数据库"><a href="#python-标准库-pwd-用户密码数据库" class="headerlink" title="python 标准库 pwd 用户密码数据库"></a>python 标准库 pwd 用户密码数据库</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200320_pwd.png?raw=true" alt></p>
<a id="more"></a>
<ul>
<li><p>此模块可以访问 Unix 用户账户名及密码数据库，在所有 Unix 版本上均可使用。</p>
<p>密码数据库中的条目以元组对象返回，属性对应 <code>passwd</code> 中的结构（属性如下所示，可参考 ）：</p>
<p>| 索引 | 属性        | 意义               |<br>| :— | :———- | :—————– |<br>| 0    | <code>pw_name</code>   | 登录名             |<br>| 1    | <code>pw_passwd</code> | 密码，可能已经加密 |<br>| 2    | <code>pw_uid</code>    | 用户 ID 数值       |<br>| 3    | <code>pw_gid</code>    | 组 ID 数值         |<br>| 4    | <code>pw_gecos</code>  | 用户名或备注       |<br>| 5    | <code>pw_dir</code>    | 用户主目录         |<br>| 6    | <code>pw_shell</code>  | 用户的命令解释器   |</p>
<p>其中 uid 和 gid 是整数，其他是字符串，如果找不到对应的项目，抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 异常。</p>
<p>注解:</p>
<p> 传统的 Unix 系统中，<code>pw_passwd</code> 的值通常使用 DES 导出的算法加密（参阅 <a href="https://docs.python.org/zh-cn/3.8/library/crypt.html#module-crypt" target="_blank" rel="noopener"><code>crypt</code></a> 模块）。不过现在的 unix 系统使用 <em>影子密码</em> 系统。在这些 unix 上，<em>pw_passwd</em> 只包含星号（<code>&#39;*&#39;</code>）或字母（<code>&#39;x&#39;</code>），而加密的密码存储在文件 <code>/etc/shadow</code> 中，此文件不是全局可读的。在 <em>pw_passwd</em> 中是否包含有用信息是系统相关的。如果可以访问到加密的密码，就需要使用 <a href="https://docs.python.org/zh-cn/3.8/library/spwd.html#module-spwd" target="_blank" rel="noopener"><code>spwd</code></a> 模块了。</p>
<p>本模块定义如下内容：</p>
<ul>
<li><p><code>pwd.getpwuid</code>(<em>uid</em>)</p>
<p>给定用户的数值 ID，返回密码数据库的对应项目。</p>
</li>
<li><p><code>pwd.getpwnam</code>(<em>name</em>)</p>
<p>给定用户名，返回密码数据库的对应项目。</p>
</li>
<li><p><code>pwd.getpwall</code>()</p>
<p>返回密码数据库中所有项目的列表，顺序不是固定的。</p>
</li>
</ul>
<p>参见:</p>
<ul>
<li><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/grp.html#module-grp" target="_blank" rel="noopener"><code>grp</code></a></p>
<p>针对用户组数据库的接口，与本模块类似。</p>
</li>
<li><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/spwd.html#module-spwd" target="_blank" rel="noopener"><code>spwd</code></a></p>
<p>针对影子密码数据库的接口，与本模块类似。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>pwd</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library doctest</title>
    <url>/2020/03/15/python-standard-library-doctest/</url>
    <content><![CDATA[<h1 id="python-标准库-doctest"><a href="#python-标准库-doctest" class="headerlink" title="python  标准库 doctest"></a>python  标准库 doctest</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200316_westworld_3.jpg?raw=true" alt></p>
<a id="more"></a>
<p><code>doctest</code>模块搜索看起来像交互式Python会话的文本片段，然后执行这些会话以验证它们完全按照所示方式工作。有几种常用的方法可以使用doctest：</p>
<ul>
<li><p>通过验证所有交互式示例仍按记录工作来检查模块的文档是否是最新的。</p>
</li>
<li><p>通过验证测试文件或测试对象中的交互式示例如预期工作来执行回归测试。</p>
</li>
<li><p>为包编写教程文档，用输入输出示例大量地说明。根据实例或说明文本是否被强调，这具有“识字测试”或“可执行文档”的味道。</p>
</li>
</ul>
<p>这是一个完整但很小的示例模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">This is the "example" module.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The example module supplies one function, factorial().  For example,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>factorial(5)</span></span><br><span class="line"><span class="string">120</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""Return the factorial of n, an exact integer &gt;= 0.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the result is small enough to fit in an int, return an int.</span></span><br><span class="line"><span class="string">    Else return a long.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; [factorial(n) for n in range(6)]</span></span><br><span class="line"><span class="string">    [1, 1, 2, 6, 24, 120]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; [factorial(long(n)) for n in range(6)]</span></span><br><span class="line"><span class="string">    [1, 1, 2, 6, 24, 120]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30)</span></span><br><span class="line"><span class="string">    265252859812191058636308480000000L</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30L)</span></span><br><span class="line"><span class="string">    265252859812191058636308480000000L</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(-1)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    ValueError: n must be &gt;= 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Factorials of floats are OK, but the float must be an exact integer:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30.1)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    ValueError: n must be exact integer</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30.0)</span></span><br><span class="line"><span class="string">    265252859812191058636308480000000L</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    It must also not be ridiculously large:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(1e100)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    OverflowError: n too large</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"n must be &gt;= 0"</span>)</span><br><span class="line">    <span class="keyword">if</span> math.floor(n) != n:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"n must be exact integer"</span>)</span><br><span class="line">    <span class="keyword">if</span> n+<span class="number">1</span> == n:  <span class="comment"># catch a value like 1e300</span></span><br><span class="line">        <span class="keyword">raise</span> OverflowError(<span class="string">"n too large"</span>)</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    factor = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> factor &lt;= n:</span><br><span class="line">        result *= factor</span><br><span class="line">        factor += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure>
<p>如果您直接从命令行运行<code>example.py</code>，那么<code>doctest</code>可以发挥它的魔力：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ python example.py</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>没有输出！这很正常，而且这意味着所有的例子都有效。传递<code>-v</code>给脚本，并<code>doctest</code>打印它正在尝试的详细日志，并在最后打印摘要：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ python example.py -v</span><br><span class="line">Trying:</span><br><span class="line">    factorial(<span class="number">5</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    <span class="number">120</span></span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    [factorial(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">Expecting:</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    [factorial(long(n)) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">Expecting:</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p>以此类推，最终结局如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Trying:</span><br><span class="line">    factorial(<span class="number">1e100</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">        ...</span><br><span class="line">    OverflowError: n too large</span><br><span class="line">ok</span><br><span class="line"><span class="number">2</span> items passed all tests:</span><br><span class="line">   <span class="number">1</span> tests <span class="keyword">in</span> __main__</span><br><span class="line">   <span class="number">8</span> tests <span class="keyword">in</span> __main__.factorial</span><br><span class="line"><span class="number">9</span> tests <span class="keyword">in</span> <span class="number">2</span> items.</span><br><span class="line"><span class="number">9</span> passed <span class="keyword">and</span> <span class="number">0</span> failed.</span><br><span class="line">Test passed.</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>这就是你需要知道的开始有效使用<code>doctest</code>！跳入。以下部分提供完整的详细信息。请注意，标准Python测试套件和库中有很多文档测试的例子。在标准测试文件中可以找到特别有用的示例<code>Lib/test/test_doctest.py</code>。</p>
<h2 id="1-简单用法：检查Docstrings中的示例"><a href="#1-简单用法：检查Docstrings中的示例" class="headerlink" title="1.简单用法：检查Docstrings中的示例"></a>1.简单用法：检查Docstrings中的示例</h2><p>开始使用doctest的最简单的方法（但不一定是您继续这样做的方式）是结束每个模块<code>M</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure>
<p>然后<code>doctest</code>在模块中检查文档字符串<code>M</code>。</p>
<p>将模块作为脚本运行会导致文档字符串中的示例得到执行和验证：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python M.py</span><br></pre></td></tr></table></figure>
<p>这将不会显示任何东西，除非一个例子失败，在这种情况下，失败的例子和失败的原因被打印到标准输出，并且输出的最后一行是<code>***Test Failed*** N failures.</code>，其中<em>N</em>是数字失败的例子。</p>
<p>改为使用开关运行<code>-v</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python M.py -v</span><br></pre></td></tr></table></figure>
<p>并且所有尝试过的示例的详细报告都会打印到标准输出，并在最后列出各种摘要。</p>
<p>您可以通过传递<code>verbose=True</code>来强制详细模式<code>testmod()</code>，或通过传递来禁止它<code>verbose=False</code>。在任何一种情况下，<code>sys.argv</code>都不会被检查<code>testmod()</code>（如此通过<code>-v</code>或没有影响）。</p>
<p>自Python 2.6以来，还有一个用于运行的命令行快捷方式<code>testmod()</code>。您可以指示Python解释器直接从标准库运行doctest模块，并在命令行上传递模块名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m doctest -v example.py</span><br></pre></td></tr></table></figure>
<p>这将<code>example.py</code>作为独立模块导入并<code>testmod()</code>在其上运行。请注意，如果文件是软件包的一部分并从该软件包导入其他子模块，则可能无法正常工作。</p>
<p>有关更多信息<code>testmod()</code>，请参阅基本API一节。</p>
<h2 id="2-简单的用法：检查文本文件中的示例"><a href="#2-简单的用法：检查文本文件中的示例" class="headerlink" title="2.简单的用法：检查文本文件中的示例"></a>2.简单的用法：检查文本文件中的示例</h2><p>doctest的另一个简单应用是在文本文件中测试交互式示例。这可以通过以下<code>testfile()</code>功能完成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line">doctest.testfile(<span class="string">"example.txt"</span>)</span><br></pre></td></tr></table></figure>
<p>该短脚本执行并验证文件中包含的任何交互式Python示例<code>example.txt</code>。文件内容被视为一个巨大的文档字符串; 该文件不需要包含Python程序！例如，也许<code>example.txt</code>包含这个：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">The ``example`` module</span><br><span class="line">======================</span><br><span class="line"></span><br><span class="line">Using ``factorial``</span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line">This <span class="keyword">is</span> an example text file <span class="keyword">in</span> reStructuredText format.  First <span class="keyword">import</span></span><br><span class="line">``factorial`` <span class="keyword">from</span> the ``example`` module:</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">from</span> example <span class="keyword">import</span> factorial</span><br><span class="line"></span><br><span class="line">Now use it:</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; factorial(<span class="number">6</span>)</span><br><span class="line">    <span class="number">120</span></span><br></pre></td></tr></table></figure>
<p>运行<code>doctest.testfile(&quot;example.txt&quot;)</code>然后在这个文档中找到错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">File <span class="string">"./example.txt"</span>, line <span class="number">14</span>, <span class="keyword">in</span> example.txt</span><br><span class="line">Failed example:</span><br><span class="line">    factorial(<span class="number">6</span>)</span><br><span class="line">Expected:</span><br><span class="line">    <span class="number">120</span></span><br><span class="line">Got:</span><br><span class="line">    <span class="number">720</span></span><br></pre></td></tr></table></figure>
<p>与<code>testmod()</code>一样，<code>testfile()</code>除非例子失败，否则不会显示任何内容。如果一个例子失败了，那么失败的例子和失败的原因将被打印到标准输出中，格式为<code>testmod()</code>。</p>
<p>默认情况下，<code>testfile()</code>查找调用模块目录中的文件。有关可用于指示其在其他位置查找文件的可选参数的说明，请参见Basic API一节。</p>
<p>就像<code>testmod()</code>，<code>testfile()</code>可以通过<code>-v</code>命令行开关或可选的关键字参数<em>verbose</em>来设置详细程度。</p>
<p>自Python 2.6以来，还有一个用于运行的命令行快捷方式<code>testfile()</code>。您可以指示Python解释器直接从标准库运行doctest模块，并在命令行上传递文件名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m doctest -v example.txt</span><br></pre></td></tr></table></figure>
<p>因为文件名并不以此结束<code>.py</code>，因此<code>doctest</code>推断它必须与其一起运行<code>testfile()</code>，而不是<code>testmod()</code>。</p>
<p>有关更多信息<code>testfile()</code>，请参阅基本API一节。</p>
<h2 id="3-它是如何工作的"><a href="#3-它是如何工作的" class="headerlink" title="3.它是如何工作的"></a>3.它是如何工作的</h2><p>本节将详细介绍doctest如何工作：查看它的文档字符串，它如何查找交互式示例，它使用的执行上下文，它如何处理异常以及如何使用选项标志来控制其行为。这是编写doctest示例时需要了解的信息; 有关在这些示例上实际运行doctest的信息，请参阅以下各节。</p>
<h3 id="3-1-哪些Docstrings被检查？"><a href="#3-1-哪些Docstrings被检查？" class="headerlink" title="3.1. 哪些Docstrings被检查？"></a>3.1. 哪些Docstrings被检查？</h3><p>模块docstring，以及所有函数，类和方法文档字符串被搜索。导入到模块中的对象不被搜索。</p>
<p>另外，如果<code>M.__test__</code>存在且“为真”，则它必须是字典，并且每个条目将（字符串）名称映射到函数对象，类对象或字符串。从中找到的函数和类对象文档字符串<code>M.__test__</code>被搜索，字符串被视为文档字符串。在输出，一键<code>K</code>在<code>M.__test__</code>出现与名称</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;name of M&gt;.__test__.K</span><br></pre></td></tr></table></figure>
<p>找到的任何类都以相似的方式递归搜索，以测试其包含的方法和嵌套类中的文档字符串。</p>
<p>在版本2.4中进行了更改：“专用名称”概念已被弃用且不再有记录。</p>
<h3 id="3-2-Docstring示例如何被认可？"><a href="#3-2-Docstring示例如何被认可？" class="headerlink" title="3.2. Docstring示例如何被认可？"></a>3.2. Docstring示例如何被认可？</h3><p>在大多数情况下，交互式控制台会话的复制和粘贴工作正常，但doctest并不试图精确模拟任何特定的Python shell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># comments are ignored</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> x == <span class="number">13</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"yes"</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"no"</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"NO"</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"NO!!!"</span></span><br><span class="line">...</span><br><span class="line">no</span><br><span class="line">NO</span><br><span class="line">NO!!!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>任何期望的输出必须紧跟在包含代码的最后一行<code>&#39;&gt;&gt;&gt; &#39;</code>或<code>&#39;... &#39;</code>一行之后，并且预期的输出（如果有的话）扩展到下一行<code>&#39;&gt;&gt;&gt; &#39;</code>或全空白行。</p>
<p>细则：</p>
<ul>
<li><p>预期的输出不能包含全空白行，因为这样的行被用来表示预期输出的结束。如果预期的输出包含空白行，请<code>&lt;BLANKLINE&gt;</code>在doctest示例中输入空行。新的2.4版本：<code>&lt;BLANKLINE&gt;</code>加入; 没有办法在以前的版本中使用包含空行的预期输出。</p>
</li>
<li><p>所有硬标签字符都被扩展为空格，使用8列制表位。测试代码生成的输出中的选项卡不会被修改。由于示例输出<em>中的</em>任何硬标签<em>都是</em>展开的，这意味着如果代码输出包含硬标签，则doctest可以通过的唯一方式是如果<code>NORMALIZE_WHITESPACE</code>选项或指令有效。或者，可以重写测试以捕获输出并将其作为测试的一部分与预期值进行比较。源代码中对制表符的处理是通过反复试验得出的，并且已被证明是处理它们的最不容易出错的方式。通过编写自定义<code>DocTestParser</code>类，可以使用不同的算法来处理选项卡。</p>
</li>
<li><p>输出到标准输出被捕获，但不输出到标准错误（异常追溯通过不同的方式捕获）。 </p>
</li>
<li><p>如果在交互式会话中通过反斜线继续行，或者出于任何其他原因使用反斜杠，则应该使用原始文档字符串，该字符串将按照键入时的方式保存反斜杠：</p>
</li>
</ul>
<blockquote>
<p>def f(x): …     r’’’Backslashes in a raw docstring: m\n’’’ &gt;&gt;&gt; print f.<strong>doc</strong> Backslashes in a raw docstring: m\n </p>
</blockquote>
<p>否则，反斜杠将被解释为字符串的一部分。例如，<code>\n</code>以上将被解释为一个换行符。或者，您可以在doctest版本中将每个反斜杠加倍（并且不使用原始字符串）：</p>
<blockquote>
<p>def f(x): …     ‘’’Backslashes in a raw docstring: m\n’’’ &gt;&gt;&gt; print f.<strong>doc</strong> Backslashes in a raw docstring: m\n </p>
</blockquote>
<ul>
<li>起始栏无关紧要：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="string">"Easy!"</span></span><br><span class="line">      &gt;&gt;&gt; <span class="keyword">import</span> math</span><br><span class="line">          &gt;&gt;&gt; math.floor(<span class="number">1.9</span>)</span><br><span class="line">          <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>并且从开始示例的初始行中出现的预期输出中删除了许多主要的空白字符<code>&#39;&gt;&gt;&gt;&#39;</code>。</p>
<h3 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h3><p>默认情况下，每次<a href="https://docs.python.org/3/library/doctest.html#module-doctest" target="_blank" rel="noopener"><code>doctest</code></a>发现一个文档字符串进行测试，它采用的是 <em>浅拷贝</em>的<code>M</code>的全局，使运行测试不会改变模块真实的全局，因此，在一个测试<code>M</code>不能离开屑不小心让另外一个背后测试工作。这意味着示例可以自由使用任何在顶层定义的<code>M</code>名称，以及在运行的文档字符串中定义的名称。示例无法看到其他文档中定义的名称。</p>
<p>你可以通过强制使用自己的字典作为执行上下文 <code>globs=your_dict</code>来<a href="https://docs.python.org/3/library/doctest.html#doctest.testmod" target="_blank" rel="noopener"><code>testmod()</code></a>或<a href="https://docs.python.org/3/library/doctest.html#doctest.testfile" target="_blank" rel="noopener"><code>testfile()</code></a>替代。</p>
<h3 id="什么是例外？"><a href="#什么是例外？" class="headerlink" title="什么是例外？"></a>什么是例外？</h3><p>没问题，只要回溯是该示例生成的唯一输出：只需粘贴回溯。<a href="https://docs.python.org/3/library/doctest.html#id2" target="_blank" rel="noopener">[1]</a>由于回溯包含可能快速变化的细节（例如，确切的文件路径和行号），所以这是doctest很难灵活接受的一种情况。</p>
<p>简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].remove(<span class="number">42</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: list.remove(x): x <span class="keyword">not</span> <span class="keyword">in</span> list</span><br></pre></td></tr></table></figure>
<p>该文档测试成功，如果<a href="https://docs.python.org/3/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>提出，详情如图所示。<code>list.remove(x):</code> <code>x</code> <code>not</code> <code>in</code> <code>list</code></p>
<p>预期的异常输出必须以追溯标题开头，该标题可以是以下两行中的任一行，缩写与示例的第一行相同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">Traceback (innermost last):</span><br></pre></td></tr></table></figure>
<p>traceback头后面跟着一个可选的traceback堆栈，其内容被doctest忽略。回溯堆栈通常被忽略，或者从交互式会话逐字复制。</p>
<p>跟踪堆栈后面是最有趣的部分：包含异常类型和细节的行。这通常是追溯的最后一行，但如果异常具有多行详细信息，则可以跨越多行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> ValueError(<span class="string">'multi\n    line\ndetail'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: multi</span><br><span class="line">    line</span><br><span class="line">detail</span><br></pre></td></tr></table></figure>
<p>最后三行（以开始<a href="https://docs.python.org/3/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>）与异常的类型和细节进行比较，其余部分将被忽略。</p>
<p>最佳做法是省略追溯堆栈，除非它为示例增加了重要的文档值。所以最后一个例子可能更好，因为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> ValueError(<span class="string">'multi\n    line\ndetail'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    ...</span><br><span class="line">ValueError: multi</span><br><span class="line">    line</span><br><span class="line">detail</span><br></pre></td></tr></table></figure>
<p>请注意，回溯处理非常特别。特别是，在改写的例子中，使用<code>...</code>独立于doctest的 <a href="https://docs.python.org/3/library/doctest.html#doctest.ELLIPSIS" target="_blank" rel="noopener"><code>ELLIPSIS</code></a>选项。这个例子中的省略号可以省略，或者可以是三个（或三百个）逗号或数字，或者Monty Python skit的缩进记录。</p>
<p>一些细节你应该阅读一次，但不需要记住：</p>
<ul>
<li><p>Doctest无法猜测您的预期输出是来自异常追溯还是来自普通打印。因此，例如，预计<code>ValueError: 42 is prime</code>会传递一个示例，无论是否<code>ValueError</code>实际提出，或者该示例仅打印该追溯文本。实际上，普通输出很少以追溯标题行开始，所以这不会产生实际问题。</p>
</li>
<li><p>回溯堆栈的每一行（如果存在）必须比示例的第一行缩进得更远，<em>或者</em>以非字母数字字符开始。追溯标题后面的第一行缩写相同，并以字母数字开头，作为异常详细信息的开始。当然这对于真正的回溯来说是正确的。</p>
</li>
<li><p>当<code>IGNORE_EXCEPTION_DETAIL</code>指定doctest选项时，将忽略最左侧冒号后面的所有内容以及异常名称中的所有模块信息。</p>
</li>
<li><p>交互式shell省略了一些<code>SyntaxError</code>s 的追溯标题行。但doctest使用traceback标题行来区分异常和非异常。因此，在极少数情况下，如果您需要测试一个<code>SyntaxError</code>省略traceback头的测试，则需要手动将traceback头行添加到测试示例中。</p>
</li>
<li><p>对于某些<code>SyntaxError</code>s，Python使用<code>^</code>标记来显示语法错误的字符位置：</p>
</li>
</ul>
<blockquote>
<p>1 1   File “<stdin>“, line 1     1 1       ^ SyntaxError: invalid syntax </stdin></p>
</blockquote>
<p>由于显示错误位置的行出现在异常类型和细节之前，因此它们不会被doctest检查。例如，即使将<code>^</code>标记放在错误的位置，也会通过以下测试：</p>
<blockquote>
<p>1 1   File “<stdin>“, line 1     1 1     ^ SyntaxError: invalid syntax </stdin></p>
</blockquote>
<h3 id="3-5-Option-Flags"><a href="#3-5-Option-Flags" class="headerlink" title="3.5. Option Flags"></a>3.5. Option Flags</h3><p>许多选项标志控制着doctest行为的各个方面。这些标志的符号名称作为模块常量提供，可以<a href="https://docs.python.org/2.7/reference/expressions.html#bitwise" target="_blank" rel="noopener">按位或运算</a>并传递给各种函数。这些名称也可以在doctest指令中使用。</p>
<p>第一组选项定义测试语义，控制doctest如何确定实际输出是否与示例预期输出相匹配的方面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.DONT_ACCEPT_TRUE_FOR_1</span><br></pre></td></tr></table></figure>
<p>默认情况下，如果预期的输出块只包含<code>1</code>，只是含有实际输出块<code>1</code>或仅<code>True</code>被认为是一个匹配，并类似地用于<code>0</code>对<code>False</code>。当<code>DONT_ACCEPT_TRUE_FOR_1</code>指定时，不允许替换。缺省行为迎合了Python将许多函数的返回类型从整数更改为布尔值; 希望“小整数”输出的doctests在这些情况下仍然有效。这个选项可能会消失，但不会持续数年。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.DONT_ACCEPT_BLANKLINE</span><br></pre></td></tr></table></figure>
<p>默认情况下，如果预期的输出块包含仅包含字符串的行<code>&lt;BLANKLINE&gt;</code>，则该行将匹配实际输出中的空行。由于真正的空行界定了预期的输出，因此这是沟通预期空行的唯一方式。什么时候<code>DONT_ACCEPT_BLANKLINE</code>被指定，这个替代是不允许的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.NORMALIZE_WHITESPACE</span><br></pre></td></tr></table></figure>
<p>指定时，所有空白（空格和换行符）都被视为相等。预期输出中的任何空白序列都将与实际输出中的任何空白序列相匹配。默认情况下，空白必须完全匹配。<code>NORMALIZE_WHITESPACE</code>当预期输出的行很长时，并且您想要在源代码中的多行中包装它时，它特别有用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.ELLIPSIS</span><br></pre></td></tr></table></figure>
<p>指定时，<code>...</code>预期输出中的省略号标记（）可以匹配实际输出中的任何子字符串。这包括跨越行边界的子字符串和空的子字符串，所以最好保持简单的使用。复杂的用途可能会导致相同类型的“oops，它匹配得太多了！” <code>.*</code>在正则表达式中很容易出现意外。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.IGNORE_EXCEPTION_DETAIL</span><br></pre></td></tr></table></figure>
<p>指定时，即使异常详细信息不匹配，如果引发了期望类型的异常，那么期望异常的示例也会通过。例如，<code>ValueError: 42</code>如果引发的实际异常是预期的例子<code>ValueError: 3*14</code>，但会失败，例如，如果<code>TypeError</code>引发。</p>
<p>它也会忽略Python 3 doctest报告中使用的模块名称。因此，无论测试是在Python 2.7还是Python 3.2（或更高版本）下运行，这两种变体都可以与指定的标志一起使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; raise CustomError(<span class="string">'message'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">CustomError: message</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; raise CustomError(<span class="string">'message'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">my_module.CustomError: message</span><br></pre></td></tr></table></figure>
<p>请注意，<code>ELLIPSIS</code>也可以用于忽略异常消息的详细信息，但根据是否将模块详细信息作为异常名称的一部分进行打印，此类测试可能仍会失败。使用<code>IGNORE_EXCEPTION_DETAIL</code>和来自Python 2.3的细节也是编写文档测试的唯一明确方式，它不关心异常细节，但仍然在Python 2.3或更低版本中继续传递（这些版本不支持doctest指令并将它们忽略为不相关的注释） 。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; (<span class="number">1</span>, <span class="number">2</span>)[<span class="number">3</span>] = <span class="string">'moo'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line"><span class="built_in">TypeError</span>: object doesn<span class="string">'t support item assignment</span></span><br></pre></td></tr></table></figure>
<p>虽然Python 2.4中的细节更改为“不”而不是“不”，但在Python 2.3以及更高版本的Python版本中通过了指定的标志。</p>
<p>在 3.2 版更改:：<code>IGNORE_EXCEPTION_DETAIL</code>现在也忽略了与包含被测异常的模块有关的任何信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.SKIP</span><br></pre></td></tr></table></figure>
<p>指定时，请不要运行该示例。这在doctest示例既可用作文档也可用作测试用例的情况下非常有用，应将其用于文档目的，但不应进行检查。例如，该示例的输出可能是随机的; 或者该示例可能依赖于测试驱动程序无法使用的资源。</p>
<p>SKIP标志也可用于临时“注释”示例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.COMPARISON_FLAGS</span><br></pre></td></tr></table></figure>
<p>将上面的所有比较标志掩盖起来。</p>
<p>第二组选项控制如何报告测试失败：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.REPORT_UDIFF</span><br></pre></td></tr></table></figure>
<p>指定时，涉及多行预期和实际输出的故障将使用统一差异显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.REPORT_CDIFF</span><br></pre></td></tr></table></figure>
<p>指定时，涉及多行预期输出和实际输出的故障将使用上下文差异显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.REPORT_NDIFF</span><br></pre></td></tr></table></figure>
<p>指定时，<code>difflib.Differ</code>使用与常用<code>ndiff.py</code>实用程序相同的算法计算差异。这是标记线内和线间差异的唯一方法。例如，如果预期输出的一行包含数字<code>1</code>，其中实际输出包含字母<code>l</code>，则会插入一行，并在其中插入用于标记不匹配列位置的插入符号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.REPORT_ONLY_FIRST_FAILURE</span><br></pre></td></tr></table></figure>
<p>指定时，显示每个doctest中的第一个失败示例，但禁止所有其他示例的输出。这将防止doctest报告因早期故障而中断的正确示例; 但它也可能隐藏不正确的例子，不依靠第一次失败而失败。当<code>REPORT_ONLY_FIRST_FAILURE</code>指定时，剩余的示例仍在运行，并仍然计入报告的故障总数; 只有输出被抑制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.FAIL_FAST</span><br></pre></td></tr></table></figure>
<p>指定时，在第一个失败示例后退出，不要尝试运行其余示例。因此，报告的故障数最多为 1。此标志在调试期间可能很有用，因为第一次失败后的示例不会生成调试输出。</p>
<p>3.4版新功能</p>
<p>还有一种方法可以注册新的选项标志名称，但除非您打算<code>doctest</code>通过子类扩展内部函数，否则这种方法并不有用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doctest.register_optionflag(name)</span><br></pre></td></tr></table></figure>
<p>用给定名称创建一个新选项标志，并返回新标志的整数值。<code>register_optionflag()</code>可用于子类化<code>OutputChecker</code>或<code>DocTestRunner</code>创建您的子类支持的新选项。<code>register_optionflag()</code>应该总是使用以下习惯用法来调用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MY_FLAG = register_optionflag(<span class="string">'MY_FLAG'</span>)</span><br></pre></td></tr></table></figure>
<p>New in version 2.4.</p>
<h3 id="3-6-Directives"><a href="#3-6-Directives" class="headerlink" title="3.6. Directives"></a>3.6. Directives</h3><p>Doctest指令可用于修改单个示例的选项标志。Doctest指令是遵循示例源代码的特殊Python注释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">directive             ::=  <span class="string">"#"</span> <span class="string">"doctest:"</span> directive_options</span><br><span class="line">directive_options     ::=  directive_option (<span class="string">","</span> directive_option)\*</span><br><span class="line">directive_option      ::=  on_or_off directive_option_name</span><br><span class="line">on_or_off             ::=  <span class="string">"+"</span> \| <span class="string">"-"</span></span><br><span class="line">directive_option_name ::=  <span class="string">"DONT_ACCEPT_BLANKLINE"</span> \| <span class="string">"NORMALIZE_WHITESPACE"</span> \| ...</span><br></pre></td></tr></table></figure>
<p><code>+</code>or <code>-</code>和指令选项名称之间不允许有空格。指令选项名称可以是上面解释的任何选项标志名称。</p>
<p>一个例子的doctest指令修改了doctest的这个例子的行为。使用<code>+</code>启用这个名字的行为，或<code>-</code>将其禁用。</p>
<p>例如，这个测试通过：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> range(<span class="number">20</span>) <span class="comment"># doctest: +NORMALIZE_WHITESPACE</span></span><br><span class="line">[<span class="number">0</span>,   <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,</span><br><span class="line"><span class="number">10</span>,  <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure>
<p>如果没有指令，它会失败，这是因为实际输出在单个数字列表元素之前没有两个空格，并且因为实际输出在单行上。这个测试也通过了，并且还需要一个指令来做到这一点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> range(<span class="number">20</span>) <span class="comment"># doctest: +ELLIPSIS</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, ..., <span class="number">18</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure>
<p>多条指令可用于单条物理线路，用逗号分隔：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> range(<span class="number">20</span>) <span class="comment"># doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span></span><br><span class="line">[<span class="number">0</span>,    <span class="number">1</span>, ...,   <span class="number">18</span>,    <span class="number">19</span>]</span><br></pre></td></tr></table></figure>
<p>如果单个示例使用多个指令注释，则将它们合并：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print range(20) # doctest: +ELLIPSIS</span><br><span class="line">...                 # doctest: +NORMALIZE_WHITESPACE</span><br><span class="line">[<span class="number">0</span>,    <span class="number">1</span>, ...,   <span class="number">18</span>,    <span class="number">19</span>]</span><br></pre></td></tr></table></figure>
<p>如前例所示，您可以将<code>...</code>行添加到仅包含指令的示例中。当一个例子对于指令很容易适合同一行时太长了，这会很有用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print range(<span class="number">5</span>) + range(<span class="number">10</span>,<span class="number">20</span>) + range(<span class="number">30</span>,<span class="number">40</span>) + range(<span class="number">50</span>,<span class="number">60</span>)</span><br><span class="line">... # doctest: +ELLIPSIS</span><br><span class="line">[<span class="number">0</span>, ..., <span class="number">4</span>, <span class="number">10</span>, ..., <span class="number">19</span>, <span class="number">30</span>, ..., <span class="number">39</span>, <span class="number">50</span>, ..., <span class="number">59</span>]</span><br></pre></td></tr></table></figure>
<p>请注意，由于默认情况下所有选项都被禁用，并且指令仅适用于它们出现的示例，因此启用选项（通过<code>+</code>指令）通常是唯一有意义的选择。但是，选项标志也可以传递给运行doctests的函数，建立不同的默认值。在这种情况下，通过<code>-</code>指令禁用选项可能很有用。</p>
<p>2.4版新增功能：增加了对doctest指令的支持。</p>
<h3 id="3-7-警告"><a href="#3-7-警告" class="headerlink" title="3.7. 警告"></a>3.7. 警告</h3><p><code>doctest</code>严格要求在预期产出中要求完全匹配。如果即使单个字符不匹配，测试也会失败。这可能会让你感到惊讶，因为你确切地知道Python做了什么，并且不能保证输出。例如，在打印字典时，Python不保证键值对将以任何特定的顺序打印，因此像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line">&#123;<span class="string">"Hermione"</span>: <span class="string">"hippogryph"</span>, <span class="string">"Harry"</span>: <span class="string">"broomstick"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>很脆弱！一种解决方法是做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo() == &#123;<span class="string">"Hermione"</span>: <span class="string">"hippogryph"</span>, <span class="string">"Harry"</span>: <span class="string">"broomstick"</span>&#125;</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>代替。另一个是要做的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d = foo().items()</span><br><span class="line">&gt;&gt;&gt; d.sort()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">[(<span class="string">'Harry'</span>, <span class="string">'broomstick'</span>), (<span class="string">'Hermione'</span>, <span class="string">'hippogryph'</span>)]</span><br></pre></td></tr></table></figure>
<p>还有其他的，但你明白了。</p>
<p>另一个不好的想法是打印嵌入对象地址的东西，比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="number">1.0</span>) <span class="comment"># certain to fail some of the time</span></span><br><span class="line"><span class="number">7948648</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C()   <span class="comment"># the default repr() for instances embeds an address</span></span><br><span class="line">&lt;__main__.C instance at <span class="number">0x00AC18F0</span>&gt;</span><br></pre></td></tr></table></figure>
<p><code>ELLIPSIS</code>指令为最后一个示例提供了一个很好的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C() <span class="comment">#doctest: +ELLIPSIS</span></span><br><span class="line">&lt;__main__.C instance at <span class="number">0</span>x...&gt;</span><br></pre></td></tr></table></figure>
<p>浮点数也受到跨平台的小输出变化的影响，因为Python遵循平台C库进行浮点格式化，而C库在质量上差别很大。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; 1./7  # risky</span><br><span class="line"><span class="number">0.14285714285714285</span></span><br><span class="line">&gt;&gt;&gt; print 1./7 # safer</span><br><span class="line"><span class="number">0.142857142857</span></span><br><span class="line">&gt;&gt;&gt; print round(1./7, 6) # much safer</span><br><span class="line"><span class="number">0.142857</span></span><br></pre></td></tr></table></figure>
<p>表格<code>I/2.**J</code>中的数字在所有平台上都是安全的，而且我通常会编写一些doctest的例子来生成这种格式的数字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3.</span>/<span class="number">4</span>  <span class="comment"># utterly safe</span></span><br><span class="line"><span class="number">0.75</span></span><br></pre></td></tr></table></figure>
<p>简单的分数对于人们来说也更容易理解，并且这使得更好的文档。</p>
<h2 id="4-基本API"><a href="#4-基本API" class="headerlink" title="4.基本API"></a>4.基本API</h2><p>函数<code>testmod()</code>和<code>testfile()</code>提供了一个简单的界面，文档测试，应该是足够了最基本的用途。有关这两个函数的不太正式的介绍，请参见简单用法：检查文档字符串和简单用法中的示例：检查文本文件中的示例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.testfile(filename[, module_relative][, name][, package][, globs][, verbose][, report][, optionflags][, extraglobs][, raise_on_error][, parser][, encoding])</span><br></pre></td></tr></table></figure>
<p>除<em>文件名</em>以外的所有参数都是可选的，并应以关键字形式指定。</p>
<p>在名为<em>filename</em>的文件中测试示例。返回<code>(failure_count, test_count)</code>。</p>
<p>可选参数<em>module_relative</em>指定应如何解释文件名：</p>
<ul>
<li><p>如果<em>module_relative</em>是<code>True</code>（缺省值），则<em>filename</em>指定一个与操作系统无关的模块相对路径。默认情况下，这个路径是相对于调用模块的目录；但是如果指定了<em>package</em>参数，那么它与该包相关。为了确保OS独立性，<em>文件名</em>应该使用<code>/</code>字符来分隔路径段，并且可能不是绝对路径（即它可能不以开头<code>/</code>）。</p>
</li>
<li><p>如果<em>module_relative</em>是<code>False</code>，则<em>filename</em>指定一个OS特定的路径。路径可以是绝对的或相对的; 相对路径相对于当前工作目录被解析。</p>
</li>
</ul>
<p>可选参数<em>名称</em>给出测试的名称; 默认情况下，或者<code>None</code>，<code>os.path.basename(filename)</code>被使用。</p>
<p>可选参数<em>包</em>是一个Python包或一个Python包的名称，其目录应该用作模块相关文件名的基本目录。如果未指定包，则调用模块的目录将用作模块相关文件名的基本目录。如果<em>module_relative</em>是指定<em>包，</em>那是错误的。<code>False</code></p>
<p>可选参数<em>globs</em>在执行示例时给出了一个用作全局变量的字典。这个词典的一个新的浅拷贝是为doctest创建的，所以它的例子从一个干净的石板开始。默认情况下，或者如果<code>None</code>使用新的空字典。</p>
<p>可选参数<em>extraglobs</em>给出了一个合并到用于执行示例的全局变量中的字典。这适用于<code>dict.update()</code>：如果<em>globs</em>和<em>extraglobs</em>具有共同的键，则<em>extraglobs</em>中的关联值出现在组合字典中。默认情况下，或者如果<code>None</code>，不使用额外的全局变量。这是一个允许doctests参数化的高级功能。例如，可以为基类编写一个doctest，使用该类的通用名称，然后通过传递将泛型名称映射到要测试的子类的<em>extraglobs</em>字典来测试任意数量的子类。</p>
<p>可选参数<em>详细信息</em>如果为true，则会打印大量内容，如果为false，则仅打印失败; 默认情况下，或者如果<code>None</code>，当且仅当<code>&#39;-v&#39;</code>在时才是<code>sys.argv</code>。</p>
<p>可选的参数<em>报告</em>在最后打印摘要时为真，否则在最后不打印任何内容。在详细模式下，摘要是详细的，否则摘要非常简短（实际上，如果所有测试都通过，则为空）。</p>
<p>可选参数<em>optionflags</em>或一起选项标志。请参见选项标志部分。</p>
<p>可选参数<em>raise_on_error</em>默认为false。如果为true，则在例子中发生第一次失败或意外异常时引发异常。这样可以对故障进行事后调试。默认行为是继续运行示例。</p>
<p>可选参数<em>解析器</em>指定<code>DocTestParser</code>应该用于从文件中提取测试的一个（或子类）。它默认为一个普通的解析器（即，<code>DocTestParser()</code>）。</p>
<p>可选的参数<em>编码</em>指定应该用于将文件转换为unicode的编码。</p>
<p>2.4版本中的新功能。</p>
<p>在版本2.5中更改：添加了参数<em>编码</em>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doctest.testmod([m][, name][, globs][, verbose][, report][, optionflags][, extraglobs][, raise_on_error][, exclude_empty])</span><br></pre></td></tr></table></figure>
<p>所有参数都是可选的，除<em>m</em>外的所有参数都应以关键字形式指定。</p>
<p>在从<em>m开始</em>可以访问的函数和类中的docstrings中的测试示例（或者<code>__main__</code>如果<em>m</em>没有提供或者是<code>None</code>，则为module ），以<code>m.__doc__</code>。开头。</p>
<p>还有可以从字典中获得的测试例子<code>m.__test__</code>，如果它存在与否<code>None</code>。<code>m.__test__</code>将名称（字符串）映射到函数，类和字符串; 函数和类docstrings搜索的例子; 字符串被直接搜索，就好像它们是docstrings一样。</p>
<p>仅搜索附加到属于模块<em>m的</em>对象的文档字符串。</p>
<p>返回<code>(failure_count, test_count)</code>。</p>
<p>可选参数<em>名称</em>给出模块的名称; 默认情况下，或者<code>None</code>，<code>m.__name__</code>被使用。</p>
<p>可选参数<em>exclude_empty</em>默认为false。如果属实，则没有找到doctests的对象将被排除在考虑之外。默认值是向后兼容的黑客，使代码仍然使用<code>doctest.master.summarize()</code>连同<code>testmod()</code>继续得到输出，没有测试对象。新构造函数的<em>exclude_empty</em>参数<code>DocTestFinder</code>默认为true。</p>
<p>可选参数<em>extraglobs</em>，<em>verbose</em>，<em>report</em>，<em>optionflags</em>，<em>raise_on_error</em>和<em>globs</em>与<code>testfile()</code>上述函数相同，只是<em>globs</em>默认为<code>m.__dict__</code>。</p>
<p>在版本2.3中更改：添加了参数<em>optionflags</em>。</p>
<p>在版本2.4中更改：添加了参数<em>extraglobs</em>，<em>raise_on_error</em>和<em>exclude_empty</em>。</p>
<p>在版本2.5中更改：可选参数<em>isprivate</em>，在2.4中弃用，已被删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doctest.run_docstring_examples(f, globs[, verbose][, name][, compileflags][, optionflags])</span><br></pre></td></tr></table></figure>
<p>与对象<em>f</em>相关的测试例子; 例如，<em>f</em>可以是字符串，模块，函数或类对象。</p>
<p>字典参数<em>glob的</em>浅拷贝用于执行上下文。</p>
<p>失败消息中使用可选参数<em>名称</em>，缺省值为<code>&quot;NoName&quot;</code>。</p>
<p>如果可选参数<em>verbose</em>为true，则即使没有失败，也会生成输出。默认情况下，仅在发生示例故障时才会生成输出。</p>
<p>可选参数<em>compileflags</em>给出了运行示例时应由Python编译器使用的一组标志。默认情况下，或者如果<code>None</code>，推导的标志对应于在<em>globs中</em>找到的一组未来特征。</p>
<p>可选参数<em>optionflags</em>与<code>testfile()</code>上面的函数一样。</p>
<h2 id="5-Unittest-API"><a href="#5-Unittest-API" class="headerlink" title="5. Unittest API"></a>5. Unittest API</h2><p>随着您的文档测试模块集合的增长，您需要一种系统地运行所有文档测试的方法。在Python 2.4之前，<code>doctest</code>有一个几乎没有文档记录的<code>Tester</code>类，它提供了一个基本方法来组合多个模块的doctests。<code>Tester</code>是虚弱的，实际上最严重的Python测试框架建立在<code>unittest</code>模块上，它提供了许多灵活的方法来结合多个来源的测试。所以，在Python 2.4，<code>doctest</code>的<code>Tester</code>类已被弃用，<code>doctest</code>提供了可用于创建两个函数<code>unittest</code>从模块和包含文档测试的文本文件的测试套件。要与<code>unittest</code>测试发现集成，<code>load_tests()</code>在您的测试模块中包含一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line"><span class="keyword">import</span> my_module_with_doctests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_tests</span><span class="params">(loader, tests, ignore)</span>:</span></span><br><span class="line">    tests.addTests(doctest.DocTestSuite(my_module_with_doctests))</span><br><span class="line">    <span class="keyword">return</span> tests</span><br></pre></td></tr></table></figure>
<p>有两个主要的功能可以用<code>unittest.TestSuite</code>文本文件和模块创建实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doctest.DocFileSuite(*paths, [module_relative][, package][, setUp][, tearDown][, globs][, optionflags][, parser][, encoding])</span><br></pre></td></tr></table></figure>
<p>将doctest测试从一个或多个文本文件转换为<code>unittest.TestSuite</code>。</p>
<p>返回的<code>unittest.TestSuite</code>内容将由unittest框架运行并在每个文件中运行交互式示例。如果任何文件中的示例失败，则合成的单元测试将失败，并<code>failureException</code>引发异常，显示包含测试的文件的名称和一个（有时是近似的）行号。</p>
<p>将一个或多个路径（字符串）传递给要检查的文本文件。</p>
<p>选项可以作为关键字参数提供：</p>
<p>可选参数<em>module_relative</em>指定应如何解释<em>路径中</em>的文件名：</p>
<ul>
<li><p>如果<em>module_relative</em>是<code>True</code>（缺省值），则<em>路径</em>中的每个文件名指定与操作系统无关的模块相对路径。默认情况下，这个路径是相对于调用模块的目录; 但是如果指定了<em>package</em>参数，那么它与该包相关。为确保操作系统无关性，每个文件名应使用<code>/</code>字符来分隔路径段，并且可能不是绝对路径（即可能不以其开头<code>/</code>）。</p>
</li>
<li><p>如果<em>module_relative</em>是<code>False</code>，则<em>路径</em>中的每个文件名都指定一个OS特定的路径。路径可以是绝对的或相对的; 相对路径相对于当前工作目录被解析。</p>
</li>
</ul>
<p>可选参数<em>包</em>是Python包或Python包的名称，其目录应该用作<em>路径中</em>与模块相关的文件名的基本目录。如果未指定包，则调用模块的目录将用作模块相关文件名的基本目录。如果<em>module_relative</em>是指定<em>包，</em>那是<code>False</code>错误的。</p>
<p>可选参数<em>setUp</em>指定测试套件的设置函数。这在每个文件中运行测试之前被调用。该<em>的setUp</em>函数将被传递一个<code>DocTest</code>对象。setUp函数可以在测试的<em>globs</em>属性通过时访问测试全局变量。</p>
<p>可选参数<em>tearDown</em>指定测试套件的拆卸函数。这是在每个文件中运行测试后调用的。在<em>拆卸</em>会被传递给一个<code>DocTest</code>对象。setUp函数可以在测试的<em>globs</em>属性通过时访问测试全局变量。</p>
<p>可选参数<em>globs</em>是包含测试的初始全局变量的字典。每个测试都会创建一本新字典。默认情况下，<em>globs</em>是一个新的空字典。</p>
<p>可选参数<em>optionflags</em>指定测试的默认doctest选项，由各个选项标记组合或创建。请参见选项标志部分。请参阅<code>set_unittest_reportflags()</code>下面的功能以更好地设置报告选项。</p>
<p>可选参数<em>解析器</em>指定<code>DocTestParser</code>应该用于从文件中提取测试的一个（或子类）。它默认为一个普通的解析器（即，<code>DocTestParser()</code>）。</p>
<p>可选的参数<em>编码</em>指定应该用于将文件转换为unicode的编码。</p>
<p>2.4版本中的新功能。</p>
<p>在版本2.5中进行了更改：将全局<code>__file__</code>添加到提供给使用文本文件加载的文档测试的全局文件中<code>DocFileSuite()</code>。</p>
<p>在版本2.5中更改：添加了参数<em>编码</em>。</p>
<p>注意</p>
<p>不像<code>testmod()</code>和<code>DocTestFinder</code>，<code>ValueError</code>如果<em>模块不</em>包含文档字符串，该函数会引发一个问题。您可以通过传递一个<code>DocTestFinder</code>实例作为<em>test_finder</em>参数，并将其<em>exclude_empty</em>关键字参数设置为<code>False</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>finder = doctest.DocTestFinder(exclude_empty=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suite = doctest.DocTestSuite(test_finder=finder)</span><br><span class="line">doctest.DocTestSuite([module][, globs][, extraglobs][, test_finder][, setUp][, tearDown][, checker])</span><br></pre></td></tr></table></figure>
<p>将模块的doctest测试转换为一个模块<code>unittest.TestSuite</code>。</p>
<p>返回的<code>unittest.TestSuite</code>是由unittest框架运行并在模块中运行每个doctest。如果有任何文档测试失败，则合成的单元测试失败，并<code>failureException</code>引发异常，显示包含测试的文件的名称和一个（有时是近似的）行号。</p>
<p>可选参数<em>模块</em>提供要测试的模块。它可以是一个模块对象或一个（可能点缀的）模块名称。如果未指定，则使用调用此函数的模块。</p>
<p>可选参数<em>globs</em>是包含测试的初始全局变量的字典。每个测试都会创建一本新字典。默认情况下，<em>globs</em>是一个新的空字典。</p>
<p>可选参数<em>extraglobs</em>指定一组额外的全局变量，这是合并成的<em>水珠</em>。默认情况下，不使用额外的全局变量。</p>
<p>可选参数<em>test_finder</em>是<code>DocTestFinder</code>用于从模块中提取doctests 的对象（或插入替换）。</p>
<p>可选参数<em>setUp</em>，<em>tearDown</em>和<em>optionflags</em>与<code>DocFileSuite()</code>上面的函数相同。</p>
<p>2.3版本的新功能。</p>
<p>在版本2.4中更改：添加了参数<em>globs</em>，<em>extraglobs</em>，<em>test_finder</em>，<em>setUp</em>，<em>tearDown</em>和<em>optionflags</em> ; 这个功能现在使用和。一样的搜索技术<code>testmod()</code>。</p>
<p>在幕后，<code>DocTestSuite()</code>创建<code>unittest.TestSuite</code>出的<code>doctest.DocTestCase</code>实例，<code>DocTestCase</code>是的子类<code>unittest.TestCase</code>。<code>DocTestCase</code>这里没有记录（这是一个内部细节），但是研究它的代码可以回答关于<code>unittest</code>集成确切细节的问题。</p>
<p>同样，<code>DocFileSuite()</code>创建<code>unittest.TestSuite</code>出的<code>doctest.DocFileCase</code>实例，<code>DocFileCase</code>是的子类<code>DocTestCase</code>。</p>
<p>因此创建<code>unittest.TestSuite</code>运行实例的两种方式<code>DocTestCase</code>。这对于一个微妙的原因很重要：当你<code>doctest</code>自己运行函数时，可以<code>doctest</code>通过将选项标志传递给<code>doctest</code>函数来直接控制正在使用的选项。但是，如果你正在编写一个<code>unittest</code>框架，<code>unittest</code>最终控制何时以及如何运行测试。框架作者通常希望控制<code>doctest</code>报表选项（可能例如由命令行选项指定），但是没有办法将选项传递<code>unittest</code>给<code>doctest</code>测试运行者。</p>
<p>出于这个原因，<code>doctest</code>还支持通过此功能支持<code>doctest</code>特定于<code>unittest</code>支持的报告标志的概念：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.set_unittest_reportflags(flags)</span><br></pre></td></tr></table></figure>
<p>设置<code>doctest</code>要使用的报告标志。</p>
<p>参数<em>标志</em>或一起选项标志。请参见选项标志部分。只能使用“报告标志”。</p>
<p>这是一个模块全局设置，并影响模块运行的所有将来的doctests <code>unittest</code>：在<code>DocTestCase</code>实例构建时查看为测试用例指定的选项标记<code>DocTestCase</code>的<code>runTest()</code>方法。如果没有指定报告的标志（这是典型的和预期的情况下），<code>doctest</code>的<code>unittest</code>报告标志是<a href="https://docs.python.org/2.7/reference/expressions.html#bitwise" target="_blank" rel="noopener">按位或运算</a>进入选项标志，因此增强选项标志传递给创建运行文档测试<code>DocTestRunner</code>实例。如果时指定的任何报告的标志例如构建<code>DocTestCase</code>，<code>doctest</code>的<code>unittest</code>报告标志被忽略。</p>
<p>在函数被调用之前生效的报告标志的值由函数返回<code>unittest</code>。</p>
<p>New in version 2.4.</p>
<h2 id="6-Advanced-API"><a href="#6-Advanced-API" class="headerlink" title="6. Advanced API"></a>6. Advanced API</h2><p>基本的API是一个简单的包装，旨在使doctest易于使用。它相当灵活，应该满足大多数用户的需求; 但是，如果您需要对测试进行更精细的控制，或者希望扩展doctest的功能，那么您应该使用高级API。</p>
<p>高级API围绕两个容器类进行，这两个容器类用于存储从doctest案例中提取的交互式示例：</p>
<ul>
<li><p><code>Example</code>：一个Python <a href="https://docs.python.org/2.7/glossary.html#term-statement" target="_blank" rel="noopener">语句</a>，与它的预期输出配对。</p>
</li>
<li><p><code>DocTest</code>：<code>Example</code>s 的集合，通常从单个文档字符串或文本文件中提取。</p>
</li>
</ul>
<p>定义其他处理类来查找，分析和运行，并检查doctest示例：</p>
<ul>
<li><p><code>DocTestFinder</code>：查找给定模块中的所有文档字符串，并使用<code>DocTestParser</code>a <code>DocTest</code>从包含交互式示例的每个文档字符串中创建一个。</p>
</li>
<li><p><code>DocTestParser</code>：<code>DocTest</code>从字符串中创建一个对象（例如对象的文档字符串）。</p>
</li>
<li><p><code>DocTestRunner</code>：执行<code>DocTest</code>中的例子，并使用一个<code>OutputChecker</code>来验证它们的输出。</p>
</li>
<li><p><code>OutputChecker</code>：将doctest示例中的实际输出与预期输出进行比较，并确定它们是否匹配。</p>
</li>
</ul>
<p>下图总结了这些处理类之间的关系：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">                            list <span class="keyword">of</span>:</span><br><span class="line">+------+                   +---------+</span><br><span class="line">|<span class="built_in">module</span>| --DocTestFinder-&gt; | DocTest | --DocTestRunner-&gt; results</span><br><span class="line">+------+    |        ^     +---------+     |       ^    (printed)</span><br><span class="line">            |        |     | Example |     |       |</span><br><span class="line">            v        |     |   ...   |     v       |</span><br><span class="line">           DocTestParser   | Example |   OutputChecker</span><br><span class="line">                           +---------+</span><br></pre></td></tr></table></figure>
<h3 id="6-1-DocTest-Objects"><a href="#6-1-DocTest-Objects" class="headerlink" title="6.1. DocTest Objects"></a>6.1. DocTest Objects</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class doctest.DocTest(examples, globs, name, filename, lineno, docstring)</span><br></pre></td></tr></table></figure>
<p>应该在单个命名空间中运行的doctest示例的集合。构造函数参数用于初始化相同名称的属性。</p>
<p>2.4版本中的新功能。</p>
<p><code>DocTest</code>定义了以下属性。它们由构造函数初始化，不应该直接修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">examples</span><br></pre></td></tr></table></figure>
<p><code>Example</code>编码应该由此测试运行的各个交互式Python示例的对象列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">globs</span><br></pre></td></tr></table></figure>
<p>应该运行示例的名称空间（又称全局变量）。这是一个将名称映射到值的字典。<code>globs</code>在测试运行之后，示例所做的任何对名称空间的更改（例如绑定新变量）都会反映出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name</span><br></pre></td></tr></table></figure>
<p>一个字符串名称标识<code>DocTest</code>。通常，这是测试从中提取的对象或文件的名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filename</span><br></pre></td></tr></table></figure>
<p>这<code>DocTest</code>是从中提取的文件的名称; 或者<code>None</code>如果文件名是未知的，或者如果<code>DocTest</code>没有从文件中提取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lineno</span><br></pre></td></tr></table></figure>
<p>行号在<code>filename</code>哪里<code>DocTest</code>开始，或<code>None</code>行号是否不可用。该行号相对于文件的开头是从零开始的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docstring</span><br></pre></td></tr></table></figure>
<p>从中提取测试<code>None</code>的字符串，或者字符串不可用，或者测试未从字符串中提取。</p>
<h3 id="6-2-示例对象"><a href="#6-2-示例对象" class="headerlink" title="6.2. 示例对象"></a>6.2. 示例对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class doctest.Example(source, want[, exc_msg][, lineno][, indent][, options])</span><br></pre></td></tr></table></figure>
<p>一个交互式示例，由Python语句及其预期输出组成。构造函数参数用于初始化相同名称的属性。</p>
<p>2.4版本中的新功能。</p>
<p><code>Example</code>定义了以下属性。它们由构造函数初始化，不应该直接修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source</span><br></pre></td></tr></table></figure>
<p>包含示例源代码的字符串。这个源代码由一个Python语句组成，并且总是以换行符结尾; 构造函数在必要时添加一个换行符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">want</span><br></pre></td></tr></table></figure>
<p>运行示例源代码的预期输出（来自标准输出，或者异常情况下的回溯）。<code>want</code>除非没有输出，否则以换行符结束，在这种情况下，它是一个空字符串。构造函数在必要时添加一个换行符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exc_msg</span><br></pre></td></tr></table></figure>
<p>该示例生成的异常消息，如果该示例预计会生成异常; 或者<code>None</code>如果不希望产生异常。该异常消息与返回值进行比较<code>traceback.format_exception_only()</code>。<code>exc_msg</code>除非是换行符，否则以换行符结尾<code>None</code>。如果需要，构造函数会添加一个换行符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lineno</span><br></pre></td></tr></table></figure>
<p>包含示例开始处的示例的字符串中的行号。该行号相对于包含字符串的开头是从零开始的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">indent</span><br></pre></td></tr></table></figure>
<p>包含字符串中的示例缩进，即示例第一个提示之前的空格字符数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options</span><br></pre></td></tr></table></figure>
<p>从选项标记到<code>True</code>or的字典映射<code>False</code>，用于覆盖此示例的默认选项。任何未包含在此字典中的选项标志都保留默认值（由<code>DocTestRunner</code>s 指定<code>optionflags</code>）。默认情况下，不设置任何选项。</p>
<h3 id="6-3-DocTestFinder对象"><a href="#6-3-DocTestFinder对象" class="headerlink" title="6.3. DocTestFinder对象"></a>6.3. DocTestFinder对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">doctest</span>.<span class="title">DocTestFinder</span><span class="params">([verbose][, parser][, recurse][, exclude_empty])</span></span></span><br></pre></td></tr></table></figure>
<p>一个处理类，用于<code>DocTest</code>从文档字符串及其包含对象的文档字符串中提取与给定对象相关的s。<code>DocTest</code>s可以从下列对象类型中提取：模块，函数，类，方法，静态方法，类方法和属性。</p>
<p>可选参数<em>verbose</em>可用于显示查找器搜索的对象。它默认为<code>False</code>（不输出）。</p>
<p>可选参数<em>解析器</em>指定<code>DocTestParser</code>用于从文档字符串中提取文档测试的对象（或插入替换）。</p>
<p>如果可选参数<em>recurse</em>为false，那么<code>DocTestFinder.find()</code>将只检查给定的对象，而不检查任何包含的对象。</p>
<p>如果可选参数<em>exclude_empty</em>为false，<code>DocTestFinder.find()</code>则将包含具有空文档字符串的对象的测试。</p>
<p>2.4版本中的新功能。</p>
<p><code>DocTestFinder</code> 定义了以下方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find(obj[, name][, module][, globs][, extraglobs])</span><br></pre></td></tr></table></figure>
<p>返回<code>DocTest</code>由<em>obj</em>的文档字符串或其包含的任何对象的文档字符串定义的s 的列表。</p>
<p>可选参数<em>名称</em>指定对象的名称; 这个名字将被用来为返回的<code>DocTest</code>s 构造名字。如果没有指定<em>名称</em>，则<code>obj.__name__</code>使用。</p>
<p>可选参数<em>模块</em>是包含给定对象的模块。如果模块没有被指定或者是<code>None</code>，则测试发现者将尝试自动确定正确的模块。使用该对象的模块：</p>
<ul>
<li><p>作为默认命名空间，如果没有指定<em>globs</em>。</p>
</li>
<li><p>阻止DocTestFinder从其他模块导入的对象中提取DocTests。（包含模块以外的<em>模块的</em>包含对象将被忽略。）</p>
</li>
<li><p>查找包含该对象的文件的名称。</p>
</li>
<li><p>帮助查找文件中对象的行号。</p>
</li>
</ul>
<p>如果<em>模块</em>是<code>False</code>，则不会尝试找到该模块。这是很晦涩的，主要用于测试doctest本身：如果<em>module</em>是<code>False</code>，或者是<code>None</code>但不能自动找到，那么所有对象都被认为属于（不存在的）模块，因此所有包含的对象将（递归地）被搜索为doctests。</p>
<p>对于每个全局<code>DocTest</code>通过组合形成<em>水珠</em>和<em>extraglobs</em>（在绑定<em>extraglobs</em>倍率绑定在<em>水珠</em>）。为每个字典创建一个新的globals字典的浅表副本<code>DocTest</code>。如果未指定<em>globs</em>，则默认为模块的<strong>_dict</strong> <em>（如果已指定）或</em><code>*{}*</code><em>以其他方式指定。如果_extraglobs</em>没有被指定，那么它默认为<code>{}</code>。</p>
<h3 id="6-4-DocTestParser对象"><a href="#6-4-DocTestParser对象" class="headerlink" title="6.4. DocTestParser对象"></a>6.4. DocTestParser对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">doctest</span>.<span class="title">DocTestParser</span></span></span><br></pre></td></tr></table></figure>
<p>一个处理类，用于从字符串中提取交互式示例，并使用它们创建<code>DocTest</code>对象。</p>
<p>2.4版本中的新功能。</p>
<p><code>DocTestParser</code> 定义了以下方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">get_doctest(string, globs, name, filename, lineno)</span><br></pre></td></tr></table></figure>
<p>从给定的字符串中提取所有doctest示例，并将它们收集到一个<code>DocTest</code>对象中。</p>
<p><em>globs</em>，<em>name</em>，<em>filename</em>和<em>lineno</em>是新<code>DocTest</code>对象的属性。请参阅文档以<code>DocTest</code>获取更多信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">get_examples(string[, name])</span><br></pre></td></tr></table></figure>
<p>从给定的字符串中提取所有doctest示例，并将它们作为<code>Example</code>对象列表返回。行号是从0开始的。可选参数<em>名称</em>是标识此字符串的名称，仅用于错误消息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parse(string[, name])</span><br></pre></td></tr></table></figure>
<p>将给定的字符串分成示例和干预文本，并将它们作为交替<code>Example</code>s和字符串的列表返回。<code>Example</code>s的行号是基于0的。可选参数<em>名称</em>是标识此字符串的名称，仅用于错误消息。</p>
<h3 id="6-5-DocTestRunner对象"><a href="#6-5-DocTestRunner对象" class="headerlink" title="6.5. DocTestRunner对象"></a>6.5. DocTestRunner对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class doctest.DocTestRunner([checker][, verbose][, optionflags])</span><br></pre></td></tr></table></figure>
<p>处理类用于执行和验证<code>DocTest</code>中的交互式示例。</p>
<p>预期产出与实际产出之间的比较由<code>OutputChecker</code>。这种比较可以用许多选项标志来定制; 有关更多信息，请参阅选项标志部分。如果选项标志不足，则可以通过<code>OutputChecker</code>向构造函数传递一个子类来定制比较。</p>
<p>测试运行者的显示输出可以通过两种方式进行控制。首先，可以传递一个输出函数<code>TestRunner.run()</code>; 这个函数将会被显示的字符串调用。它默认为<code>sys.stdout.write</code>。如果捕获的输出不充分，则显示输出也可以通过继承DocTestRunner，并覆盖方法定制<code>report_start()</code>，<code>report_success()</code>，<code>report_unexpected_exception()</code>，和<code>report_failure()</code>。</p>
<p>可选的关键字参数<em>检查器</em>指定<code>OutputChecker</code>应该用于比较预期输出与doctest示例的实际输出的对象（或插入替换）。</p>
<p>可选的关键字参数<em>verbose</em>控制着<code>DocTestRunner</code>冗长。如果<em>详细</em>是<code>True</code>，则会在每个示例运行时打印信息。如果<em>详细</em>是<code>False</code>，则只打印故障。如果<em>verbose</em>未指定，或者<code>None</code>使用详细输出，则使用命令行开关<code>-v</code>。</p>
<p>可选的关键字参数<em>optionflags</em>可用于控制测试运行器如何将预期输出与实际输出进行比较，以及它如何显示故障。有关更多信息，请参见选项标志部分。</p>
<p>2.4版本中的新功能。</p>
<p><code>DocTestParser</code> 定义了以下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">report_start(out, test, example)</span><br></pre></td></tr></table></figure>
<p>报告测试运行人员即将处理给出的示例。提供此方法以允许其子类<code>DocTestRunner</code>定制其输出；它不应该直接调用。</p>
<p><em>例子</em>就是要处理的例子。<em>测试</em>是<em>包含示例</em>的测试。<em>out</em>是传递给的输出函数<code>DocTestRunner.run()</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">report_success(out, test, example, got)</span><br></pre></td></tr></table></figure>
<p>报告给出的示例已成功运行。提供此方法以允许其子类<code>DocTestRunner</code>定制其输出；它不应该直接调用。</p>
<p><em>例子</em>就是要处理的例子。<em>得到的</em>是实例的实际输出。<em>测试</em>是包含<em>示例</em>的测试。<em>out</em>是传递给的输出函数<code>DocTestRunner.run()</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">report_failure(out, test, example, got)</span><br></pre></td></tr></table></figure>
<p>报告给出的例子失败。提供此方法以允许其子类<code>DocTestRunner</code>定制其输出; 它不应该直接调用。</p>
<p><em>例子</em>就是要处理的例子。<em>得到的</em>是实例的实际输出。<em>测试</em>是包含<em>示例</em>的测试。<em>out</em>是传递给的输出函数<code>DocTestRunner.run()</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">report_unexpected_exception(out, test, example, exc_info)</span><br></pre></td></tr></table></figure>
<p>报告给出的示例引发了意外的异常。提供此方法以允许其子类<code>DocTestRunner</code>定制其输出; 它不应该直接调用。</p>
<p><em>例子</em>就是要处理的例子。<em>exc_info</em>是包含有关意外异常（由返回的<code>sys.exc_info()</code>）的信息的元组。<em>测试</em>是包含<em>示例</em>的测试。<em>out</em>是传递给的输出函数<code>DocTestRunner.run()</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run(test[, compileflags][, out][, clear_globs])</span><br></pre></td></tr></table></figure>
<p>运行在实施例中<em>测试</em>（一个<code>DocTest</code>对象），并使用写入器功能显示结果<em>出来</em>。</p>
<p>这些示例在命名空间中运行<code>test.globs</code>。如果<em>clear_globs</em>为true（缺省值），那么该名称空间将在测试运行后清除，以帮助进行垃圾回收。如果您想在测试完成后检查名称空间，请使用<em>clear_globs = False</em>。</p>
<p><em>compileflags</em>给出了运行示例时Python编译器应该使用的一组标志。如果未指定，则它将默认为适用于<em>globs</em>的future-import标志集。</p>
<p>每个示例的输出都使用<code>DocTestRunner</code>输出检查器进行检查，并且结果由这些<code>DocTestRunner.report_*()</code>方法进行格式化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">summarize([verbose])</span><br></pre></td></tr></table></figure>
<p>打印由此DocTestRunner运行的所有测试用例的摘要，并返回一个<a href="https://docs.python.org/2.7/glossary.html#term-named-tuple" target="_blank" rel="noopener">指定的元组</a> <code>TestResults(failed, attempted)</code>。</p>
<p>可选的<em>详细</em>参数控制摘要的详细程度。如果没有指定<code>DocTestRunner</code>详细程度，则使用冗长度。</p>
<p>在版本2.6中更改：使用命名的元组。</p>
<h3 id="6-6-OutputChecker对象"><a href="#6-6-OutputChecker对象" class="headerlink" title="6.6. OutputChecker对象"></a>6.6. OutputChecker对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class doctest.OutputChecker</span><br></pre></td></tr></table></figure>
<p>用于检查doctest示例的实际输出是否与预期输出匹配的类。<code>OutputChecker</code>定义了两种方法：<code>check_output()</code>，它比较给定的一对输出，如果匹配则返回真; 并<code>output_difference()</code>返回一个描述两个输出之间差异的字符串。</p>
<p>2.4版本中的新功能。</p>
<p><code>OutputChecker</code> 定义了以下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">check_output(want, got, optionflags)</span><br></pre></td></tr></table></figure>
<p><code>True</code>如果示例（<em>got</em>）的实际输出与预期输出（<em>想要</em>）匹配，则返回。如果这些字符串相同，则始终认为它们匹配；但取决于测试运行器使用的选项标志，还可以使用几种非精确匹配类型。有关选项标志的更多信息，请参见选项标志部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output_difference(example, got, optionflags)</span><br></pre></td></tr></table></figure>
<p>返回一个字符串，描述给定示例（<em>示例</em>）的预期输出与实际输出（<em>获得</em>）之间的差异。<em>optionflags</em>是用来比较<em>想要</em>和<em>得到</em>的选项标志的集合。</p>
<h2 id="7-调试"><a href="#7-调试" class="headerlink" title="7.调试"></a>7.调试</h2><p>Doctest提供了几种调试doctest示例的机制：</p>
<ul>
<li><p>几个函数将doctests转换为可执行的Python程序，可以在Python调试器下运行<code>pdb</code>。</p>
</li>
<li><p><code>DebugRunner</code>类是的一个子类<code>DocTestRunner</code>的是提高用于第一故障的例子的异常，包含有关实施例的信息。该信息可用于对示例执行事后调试。</p>
</li>
<li><p><code>unittest</code>通过<code>DocTestSuite()</code>支持由<code>debug()</code>所定义的方法生成的案例<code>unittest.TestCase</code>。</p>
</li>
<li><p>您可以<code>pdb.set_trace()</code>在doctest示例中添加调用，并在执行该行时放入Python调试器。然后你可以检查变量的当前值，等等。例如，假设<code>a.py</code>只包含这个模块docstring：</p>
</li>
</ul>
<blockquote>
<p> “”” &gt;&gt;&gt; def f(x): …     g(x*2) &gt;&gt;&gt; def g(x): …     print x+3 …     import pdb; pdb.set_trace() &gt;&gt;&gt; f(3) 9 “”” </p>
</blockquote>
<p> 然后，一个交互式Python会话可能如下所示：</p>
<blockquote>
<p>import a, doctest &gt;&gt;&gt; doctest.testmod(a) –Return– &gt; <doctest a1>(3)g()-&gt;None -&gt; import pdb; pdb.set_trace() (Pdb) list   1     def g(x):   2         print x+3   3  -&gt;     import pdb; pdb.set_trace() EOF print x 6 (Pdb) step –Return– &gt; <doctest a0>(2)f()-&gt;None -&gt; g(x<em>2) (Pdb) list   1     def f(x):   2  -&gt;     g(x</em>2) EOF print x 3 (Pdb) step –Return– &gt; <doctest a2>(1)?()-&gt;None -&gt; f(3) (Pdb) cont (0, 3) &gt;&gt;&gt; </doctest></doctest></doctest></p>
</blockquote>
<p>  在版本2.4中进行了更改：<code>pdb.set_trace()</code>添加了在文档测试中使用有用的功能。</p>
<p>将doctests转换为Python代码的函数，并可能在调试器下运行综合代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.script_from_examples(s)</span><br></pre></td></tr></table></figure>
<p>将带有示例的文本转换为脚本。</p>
<p>参数<em>s</em>是一个包含doctest示例的字符串。该字符串被转换为Python脚本，其中<em>s</em>中的doctest示例转换为常规代码，其他所有内容都转换为Python注释。生成的脚本作为字符串返回。例如，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line"><span class="keyword">print</span> doctest.script_from_examples(<span class="string">r"""</span></span><br><span class="line"><span class="string">    Set x and y to 1 and 2.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y = 1, 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Print their sum:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print x+y</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">"""</span>)</span><br></pre></td></tr></table></figure>
<p>显示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set x and y to 1 and 2.</span></span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Print their sum:</span></span><br><span class="line"><span class="keyword">print</span> x+y</span><br><span class="line"><span class="comment"># Expected:</span></span><br><span class="line"><span class="comment">## 3</span></span><br></pre></td></tr></table></figure>
<p>该函数在其他函数的内部使用（请参见下文），但是当您想要将交互式Python会话转换为Python脚本时，该函数也很有用。</p>
<p>2.4版本中的新功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.testsource(module, name)</span><br></pre></td></tr></table></figure>
<p>将对象的doctest转换为脚本。</p>
<p>参数<em>模块</em>是一个模块对象，或者一个模块的虚线名称，包含其文档感兴趣的对象。参数<em>名称</em>是具有感兴趣的doctests的对象的名称（在模块内）。结果是一个字符串，包含对象的文档字符串转换为Python脚本，<code>script_from_examples()</code>如上所述。例如，如果模块<code>a.py</code>包含顶级函数<code>f()</code>，那么</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a, doctest</span><br><span class="line">print doctest.testsource(a, <span class="string">"a.f"</span>)</span><br></pre></td></tr></table></figure>
<p>打印函数<code>f()</code>的文档字符串的脚本版本，将文档转换为代码，其余部分放在注释中。</p>
<p>2.3版本的新功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.debug(module, name[, pm])</span><br></pre></td></tr></table></figure>
<p>调试对象的doctests。</p>
<p>该<em>模块</em>和<em>名称</em>参数是相同的功能<code>testsource()</code>之上。已命名对象的文档字符串的合成Python脚本被写入临时文件，然后该文件在Python调试器的控制下运行<code>pdb</code>。</p>
<p><code>module.__dict__</code>本地和全局执行上下文都使用浅表副本。</p>
<p>可选参数<em>pm</em>控制是否使用验尸调试。如果<em>pm</em>具有真值，则脚本文件将直接运行，并且仅当脚本通过引发未处理的异常终止时才会涉及调试器。如果确实如此，则通过<code>pdb.post_mortem()</code>从未处理的异常中传递回溯对象来调用验尸调试。如果<em>pm</em>没有被指定，或者是false，那么通过传递一个适当的<code>execfile()</code>调用来从脚本开始运行脚本<code>pdb.run()</code>。</p>
<p>2.3版本的新功能。</p>
<p>在版本2.4中更改：添加了<em>pm</em>参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctest.debug_src(src[, pm][, globs])</span><br></pre></td></tr></table></figure>
<p>用字符串调试doctests。</p>
<p>这与<code>debug()</code>上面的函数类似，只是通过<em>src</em>参数直接指定了包含doctest示例的字符串。</p>
<p>可选参数<em>pm</em>与<code>debug()</code>上面的函数具有相同的含义。</p>
<p>可选的参数<em>globs</em>给出了一个字典，用作本地和全局执行上下文。如果未指定，或者<code>None</code>使用空字典。如果指定，则使用字典的浅表副本。</p>
<p>2.4版本中的新功能。</p>
<p><code>DebugRunner</code>级和特殊的例外可能提高，最感兴趣的测试框架的作者，并且只在这里勾勒。查看源代码，尤其<code>DebugRunner</code>是docstring（这是一个doctest！）以获取更多详细信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class doctest.DebugRunner([checker][, verbose][, optionflags])</span><br></pre></td></tr></table></figure>
<p>只要<code>DocTestRunner</code>遇到故障，它的一个子类就会引发异常。如果发生意外异常，则会引发<code>UnexpectedException</code>异常，包含测试，示例和原始异常。如果输出不匹配，则会<code>DocTestFailure</code>引发异常，包含测试，示例和实际输出。</p>
<p>有关构造函数参数和方法的信息，请参阅<code>DocTestRunner</code>高级API一节中的文档。</p>
<p><code>DebugRunner</code>实例可能会引发两个例外情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception doctest.DocTestFailure(test, example, got)</span><br></pre></td></tr></table></figure>
<p><code>DocTestRunner</code>表示doctest示例的实际输出与预期输出不符的异常。构造函数参数用于初始化相同名称的属性。</p>
<p><code>DocTestFailure</code> 定义了以下属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DocTestFailure.test</span><br></pre></td></tr></table></figure>
<p><code>DocTest</code>示例失败时正在运行的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DocTestFailure.example</span><br></pre></td></tr></table></figure>
<p><code>Example</code>失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DocTestFailure.got</span><br></pre></td></tr></table></figure>
<p>示例的实际输出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exception doctest.UnexpectedException(test, example, exc_info)</span><br></pre></td></tr></table></figure>
<p>一个异常<code>DocTestRunner</code>提示表示doctest示例引发了意外异常。构造函数参数用于初始化相同名称的属性。</p>
<p><code>UnexpectedException</code> 定义了以下属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UnexpectedException.test</span><br></pre></td></tr></table></figure>
<p><code>DocTest</code>示例失败时正在运行的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UnexpectedException.example</span><br></pre></td></tr></table></figure>
<p><code>Example</code>失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UnexpectedException.exc_info</span><br></pre></td></tr></table></figure>
<p>包含有关意外异常的信息的元组，返回的是<code>sys.exc_info()</code>。</p>
<h2 id="8-Soapbox"><a href="#8-Soapbox" class="headerlink" title="8. Soapbox"></a>8. Soapbox</h2><p>正如引言中提到的，<code>doctest</code>已经发展到三个主要用途：</p>
<ol>
<li>检查文档字符串中的示例。</li>
</ol>
<p>\2. 回归测试。</p>
<p>\3. 可执行文档/文字测试。</p>
<p>这些用途具有不同的要求，区分它们很重要。特别是，用不明确的测试用例填充文档字符串会导致错误的文档。</p>
<p>在编写文档字符串时，请小心选择文档字符串示例。有一个学问需要学习 - 起初可能并不自然。示例应该为文档增加真正的价值。一个很好的例子往往可以说很多话。如果谨慎处理，这些示例对您的用户来说将是非常宝贵的，并且会随着时间的推移和事情的变化而回报多次收集它们所需的时间。我仍然惊讶于我的一个<code>doctest</code>示例在“无害”更改后停止工作的频率。</p>
<p>Doctest也是回归测试的绝佳工具，特别是如果你不吝啬解释性文本。通过插入散文和例子，跟踪实际正在测试的内容以及为什么更容易。当一个测试失败时，好的散文可以使得更容易找出问题所在，以及应该如何解决问题。的确，您可以在基于代码的测试中编写大量的评论，但很少有程序员会这样做。许多人已经发现使用doctest方法会导致更清晰的测试。也许这只是因为doctest使编写散文比编写代码容易一些，而在代码中编写注释有点困难。我认为它比以上更深刻：编写基于doctest的测试时的自然态度是您想解释软件的优点，并用示例来说明它们。这反过来自然会导致以最简单的功能开始的测试文件，并在逻辑上进展到复杂性和边缘情况。一个连贯的叙述是结果，而不是一组孤立的函数，它们似乎随机地测试孤立的功能位。这是一种不同的态度，产生不同的结果，模糊了测试和解释之间的区别。</p>
<p>回归测试最好局限于专用对象或文件。有几种组织测试的选项：</p>
<ul>
<li><p>将包含测试用例的文本文件编写为交互式示例，并使用<code>testfile()</code>或测试这些文件<code>DocFileSuite()</code>。这是推荐的，尽管对于从一开始就使用doctest设计的新项目来说，这是最容易做到的。</p>
</li>
<li><p>定义名为<code>_regrtest_topic</code>包含单个文档字符串的函数，其中包含指定主题的测试用例。这些功能可以包含在与模块相同的文件中，或者分离到单独的测试文件中。</p>
</li>
<li><p>定义<code>__test__</code>从回归测试主题到包含测试用例的文档字符串的字典映射。</p>
</li>
</ul>
<p>当您将测试放入模块中时，模块本身可以成为测试运行者。当测试失败时，您可以安排测试运行者在调试问题时仅重新运行失败的doctest。这是一个这样的测试运行者的最小例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    flags = doctest.REPORT_NDIFF|doctest.REPORT_ONLY_FIRST_FAILURE</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">        name = sys.argv[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> globals():</span><br><span class="line">            obj = globals()[name]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            obj = __test__[name]</span><br><span class="line">        doctest.run_docstring_examples(obj, globals(), name=name,</span><br><span class="line">                                       optionflags=flags)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fail, total = doctest.testmod(optionflags=flags)</span><br><span class="line">        print(<span class="string">"&#123;&#125; failures out of &#123;&#125; tests"</span>.format(fail, total))</span><br></pre></td></tr></table></figure>
<h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><p>不支持包含预期输出和异常的示例。试图猜测一个结束和另一个开始的地方太容易出错，这也会导致一个令人困惑的测试。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>doctest</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library Built-in Exception</title>
    <url>/2020/03/21/python-standard-library-Built-in-Exception/</url>
    <content><![CDATA[<h1 id="python-标准库-内置异常"><a href="#python-标准库-内置异常" class="headerlink" title="python 标准库 内置异常"></a>python 标准库 内置异常</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200321_exception.jpg?raw=true" alt></p>
<a id="more"></a>
<p>在 Python 中，所有异常必须为一个派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 的类的实例。 在带有提及一个特定类的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 子句的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句中，该子句也会处理任何派生自该类的异常类（但不处理 <em>它</em> 所派生出的异常类）。 通过子类化创建的两个不相关异常类永远是不等效的，既使它们具有相同的名称。</p>
<p>下面列出的内置异常可通过解释器或内置函数来生成。除非另有说明，它们都会具有一个提示导致错误详细原因的“关联值”。 这可以是一个字符串或由多个信息项（例如一个错误码和一个解释错误的字符串）组成的元组。 关联值通常会作为参数被传递给异常类的构造器。</p>
<p>用户代码可以引发内置异常。 这可被用于测试异常处理程序或报告错误条件，“就像” 在解释器引发了相同异常的情况时一样；但是请注意，没有任何机制能防止用户代码引发不适当的错误。</p>
<p>内置异常类可以被子类化以定义新的异常；鼓励程序员从 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 类或它的某个子类而不是从 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 来派生新的异常。 关于定义异常的更多信息可以在 Python 教程的 <a href="https://docs.python.org/zh-cn/3.8/tutorial/errors.html#tut-userexceptions" target="_blank" rel="noopener">用户自定义异常</a> 部分查看。</p>
<p>当在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句中引发（或重新引发）异常时，<code>__context__</code> 会被自动设为所捕获的最后一个异常；如果新的异常未被处理，则最终显示的回溯信息将包括原始的异常和最后的异常。</p>
<p>当引发一个新的异常（而不是简单地使用 <code>raise</code> 来重新引发当前在处理的异常）时，隐式的异常上下文可以通过使用带有 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#raise" target="_blank" rel="noopener"><code>raise</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 来补充一个显式的原因:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> new_exc <span class="keyword">from</span> original_exc</span><br></pre></td></tr></table></figure>
<p>跟在 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 之后的表达式必须为一个异常或 <code>None</code>。 它将在所引发的异常上被设置为 <code>__cause__</code>。 设置 <code>__cause__</code> 还会隐式地将 <code>__suppress_context__</code> 属性设为 <code>True</code>，这样使用 <code>raise new_exc from None</code> 可以有效地将旧异常替换为新异常来显示其目的 (例如将 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>)，同时让旧异常在 <code>__context__</code> 中保持可用状态以便在调试时进行内省。</p>
<p>除了异常本身的回溯以外，默认的回溯还会显示这些串连的异常。 <code>__cause__</code> 中的显式串连异常如果存在将总是显示。 <code>__context__</code> 中的隐式串连异常仅在 <code>__cause__</code> 为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 并且 <code>__suppress_context__</code> 为假值时显示。</p>
<p>不论在哪种情况下，异常本身总会在任何串连异常之后显示，以便回溯的最后一行总是显示所引发的最后一个异常。</p>
<h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><p>下列异常主要被用作其他异常的基类。</p>
<ul>
<li><p><em>exception</em> <code>BaseException</code></p>
<p>所有内置异常的基类。 它不应该被用户自定义类直接继承 (这种情况请使用 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a>)。 如果在此类的实例上调用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a>，则会返回实例的参数表示，或者当没有参数时返回空字符串。<code>args</code>传给异常构造器的参数元组。 某些内置异常 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>) 接受特定数量的参数并赋予此元组中的元素特殊的含义，而其他异常通常只接受一个给出错误信息的单独字符串。<code>with_traceback</code>(<em>tb</em>)此方法将 <em>tb</em> 设为异常的新回溯信息并返回该异常对象。 它通常以如下的形式在异常处理程序中使用:<code>try:    ... except SomeException:    tb = sys.exc_info()[2]    raise OtherException(...).with_traceback(tb)</code></p>
</li>
<li><p><em>exception</em> <code>Exception</code></p>
<p>所有内置的非系统退出类异常都派生自此类。 所有用户自定义异常也应当派生自此类。</p>
</li>
<li><p><em>exception</em> <code>ArithmeticError</code></p>
<p>此基类用于派生针对各种算术类错误而引发的内置异常: <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ZeroDivisionError" target="_blank" rel="noopener"><code>ZeroDivisionError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FloatingPointError" target="_blank" rel="noopener"><code>FloatingPointError</code></a>。</p>
</li>
<li><p><em>exception</em> <code>BufferError</code></p>
<p>当与 <a href="https://docs.python.org/zh-cn/3.8/c-api/buffer.html#bufferobjects" target="_blank" rel="noopener">缓冲区</a> 相关的操作无法执行时将被引发。</p>
</li>
<li><p><em>exception</em> <code>LookupError</code></p>
<p>此基类用于派生当映射或序列所使用的键或索引无效时引发的异常: <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。 这可以通过 <a href="https://docs.python.org/zh-cn/3.8/library/codecs.html#codecs.lookup" target="_blank" rel="noopener"><code>codecs.lookup()</code></a> 来直接引发。</p>
</li>
</ul>
<h2 id="具体异常"><a href="#具体异常" class="headerlink" title="具体异常"></a>具体异常</h2><p>以下异常属于经常被引发的异常。</p>
<ul>
<li><p><em>exception</em> <code>AssertionError</code></p>
<p>当 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#assert" target="_blank" rel="noopener"><code>assert</code></a> 语句失败时将被引发。</p>
</li>
<li><p><em>exception</em> <code>AttributeError</code></p>
<p>当属性引用 (参见 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#attribute-references" target="_blank" rel="noopener">属性引用</a>) 或赋值失败时将被引发。 （当一个对象根本不支持属性引用或属性赋值时则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。）</p>
</li>
<li><p><em>exception</em> <code>EOFError</code></p>
<p>当 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#input" target="_blank" rel="noopener"><code>input()</code></a> 函数未读取任何数据即达到文件结束条件 (EOF) 时将被引发。 （另外，<code>io.IOBase.read()</code> 和 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.readline" target="_blank" rel="noopener"><code>io.IOBase.readline()</code></a> 方法在遇到 EOF 则将返回一个空字符串。）</p>
</li>
<li><p><em>exception</em> <code>FloatingPointError</code></p>
<p>目前未被使用。</p>
</li>
<li><p><em>exception</em> <code>GeneratorExit</code></p>
<p>当一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 或 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 被关闭时将被引发；参见 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.close" target="_blank" rel="noopener"><code>generator.close()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine.close" target="_blank" rel="noopener"><code>coroutine.close()</code></a>。 它直接继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a>，因为从技术上来说它并不是一个错误。</p>
</li>
<li><p><em>exception</em> <code>ImportError</code></p>
<p>当 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句尝试加载模块遇到麻烦时将被引发。 并且当 <code>from ... import</code> 中的 “from list” 存在无法找到的名称时也会被引发。<code>name</code> 与 <code>path</code> 属性可通过对构造器使用仅关键字参数来设定。 设定后它们将分别表示被尝试导入的模块名称与触发异常的任意文件所在路径。<em>在 3.3 版更改:</em> 添加了 <code>name</code> 与 <code>path</code> 属性。</p>
</li>
<li><p><em>exception</em> <code>ModuleNotFoundError</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a> 的子类，当一个模块无法被定位时将由 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 引发。 当在 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中找到 <code>None</code> 时也会被引发。<em>3.6 新版功能.</em></p>
</li>
<li><p><em>exception</em> <code>IndexError</code></p>
<p>当序列抽取超出范围时将被引发。 （切片索引会被静默截短到允许的范围；如果指定索引不是整数则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 会被引发。）</p>
</li>
<li><p><em>exception</em> <code>KeyError</code></p>
<p>当在现有键集合中找不到指定的映射（字典）键时将被引发。</p>
</li>
<li><p><em>exception</em> <code>KeyboardInterrupt</code></p>
<p>当用户按下中断键 (通常为 Control-C 或 Delete) 时将被引发。 在执行期间，会定期检测中断信号。 该异常继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 以确保不会被处理 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的代码意外捕获，这样可以避免退出解释器。</p>
</li>
<li><p><em>exception</em> <code>MemoryError</code></p>
<p>当一个操作耗尽内存但情况仍可（通过删除一些对象）进行挽救时将被引发。 关联的值是一个字符串，指明是哪种（内部）操作耗尽了内存。 请注意由于底层的内存管理架构（C 的 <code>malloc()</code> 函数），解释器也许并不总是能够从这种情况下完全恢复；但它毕竟可以引发一个异常，这样就能打印出栈回溯信息，以便找出导致问题的失控程序。</p>
</li>
<li><p><em>exception</em> <code>NameError</code></p>
<p>当某个局部或全局名称未找到时将被引发。 此异常仅用于非限定名称。 关联的值是一条错误信息，其中包含未找到的名称。</p>
</li>
<li><p><em>exception</em> <code>NotImplementedError</code></p>
<p>此异常派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 在用户自定义的基类中，抽象方法应当在其要求所派生类重载该方法，或是在其要求所开发的类提示具体实现尚待添加时引发此异常。注解 它不应当用来表示一个运算符或方法根本不能被支持 – 在此情况下应当让特定运算符 / 方法保持未定义，或者在子类中将其设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。注解 <code>NotImplementedError</code> 和 <code>NotImplemented</code> 不可互换，即使它们有相似的名称和用途。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#NotImplemented" target="_blank" rel="noopener"><code>NotImplemented</code></a> 了解有关何时使用它们的详细说明。</p>
</li>
<li><p><em>exception</em> <code>OSError</code>([<em>arg</em>])</p>
</li>
<li><p><em>exception</em> <code>OSError</code>(<em>errno</em>, <em>strerror</em>[, <em>filename</em>[, <em>winerror</em>[, <em>filename2</em>]]])</p>
<p>此异常在一个系统函数返回系统相关的错误时将被引发，此类错误包括 I/O 操作失败例如 “文件未找到” 或 “磁盘已满” 等（不包括非法参数类型或其他偶然性错误）。</p>
<p>构造器的第二种形式可设置如下所述的相应属性。 如果未指定这些属性则默认为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。 为了能向下兼容，如果传入了三个参数，则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException.args" target="_blank" rel="noopener"><code>args</code></a> 属性将仅包含由前两个构造器参数组成的 2 元组。</p>
<p>构造器实际返回的往往是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的某个子类，如下文 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#os-exceptions" target="_blank" rel="noopener">OS exceptions</a> 中所描述的。 具体的子类取决于最终的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 值。 此行为仅在直接或通过别名来构造 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 时发生，并且在子类化时不会被继承。</p>
<ul>
<li><p><code>errno</code></p>
<p>来自于 C 变量 <code>errno</code> 的数字错误码。</p>
</li>
<li><p><code>winerror</code></p>
<p>在 Windows 下，此参数将给出原生的 Windows 错误码。 而 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 属性将是该原生错误码在 POSIX 平台下的近似转换形式。在 Windows 下，如果 <em>winerror</em> 构造器参数是一个整数，则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 属性会根据 Windows 错误码来确定，而 <em>errno</em> 参数会被忽略。 在其他平台上，<em>winerror</em> 参数会被忽略，并且 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.winerror" target="_blank" rel="noopener"><code>winerror</code></a> 属性将不存在。</p>
</li>
<li><p><code>strerror</code></p>
<p>操作系统所提供的相应错误信息。 它在 POSIX 平台中由 C 函数 <code>perror()</code> 来格式化，在 Windows 中则是由 <code>FormatMessage()</code>。</p>
</li>
<li><p><code>filename</code></p>
</li>
<li><p><code>filename2</code></p>
<p>对于与文件系统路径有关 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unlink" target="_blank" rel="noopener"><code>os.unlink()</code></a>) 的异常，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename" target="_blank" rel="noopener"><code>filename</code></a> 是传给函数的文件名。 对于涉及两个文件系统路径的函数 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a>)，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename2" target="_blank" rel="noopener"><code>filename2</code></a> 将是传给函数的第二个文件名。</p>
</li>
</ul>
<p><em>在 3.3 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EnvironmentError" target="_blank" rel="noopener"><code>EnvironmentError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IOError" target="_blank" rel="noopener"><code>IOError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#WindowsError" target="_blank" rel="noopener"><code>WindowsError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.error" target="_blank" rel="noopener"><code>socket.error</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.error" target="_blank" rel="noopener"><code>select.error</code></a> 与 <code>mmap.error</code> 已被合并到 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>，构造器可能返回其中一个子类。</p>
<p><em>在 3.4 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename" target="_blank" rel="noopener"><code>filename</code></a> 属性现在将是传给函数的原始文件名，而不是经过编码或基于文件系统编码进行解码之后的名称。 此外还添加了 <em>filename2</em> 构造器参数和属性。</p>
</li>
<li><p><em>exception</em> <code>OverflowError</code></p>
<p>当算术运算的结果大到无法表示时将被引发。 这对整数来说不可能发生（宁可引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#MemoryError" target="_blank" rel="noopener"><code>MemoryError</code></a> 也不会放弃尝试）。 但是出于历史原因，有时也会在整数超出要求范围的情况下引发 OverflowError。 因为在 C 中缺少对浮点异常处理的标准化，大多数浮点运算都不会做检查。</p>
</li>
<li><p><em>exception</em> <code>RecursionError</code></p>
<p>此异常派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 它会在解释器检测发现超过最大递归深度 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getrecursionlimit" target="_blank" rel="noopener"><code>sys.getrecursionlimit()</code></a>) 时被引发。<em>3.5 新版功能:</em> 在此之前将只引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p>
</li>
<li><p><em>exception</em> <code>ReferenceError</code></p>
<p>此异常将在使用 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.proxy" target="_blank" rel="noopener"><code>weakref.proxy()</code></a> 函数所创建的弱引用来访问该引用的某个已被作为垃圾回收的属性时被引发。 有关弱引用的更多信息请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块。</p>
</li>
<li><p><em>exception</em> <code>RuntimeError</code></p>
<p>当检测到一个不归属于任何其他类别的错误时将被引发。 关联的值是一个指明究竟发生了什么问题的字符串。</p>
</li>
<li><p><em>exception</em> <code>StopIteration</code></p>
<p>由内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法所引发，用来表示该迭代器不能产生下一项。</p>
<p>该异常对象只有一个属性 <code>value</code>，它在构造该异常时作为参数给出，默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p>
<p>当一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 或 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 函数返回时，将引发一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 实例，函数返回的值将被用作异常构造器的 <code>value</code> 形参。</p>
<p>如果某个生成器代码直接或间接地引发了 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a>，它会被转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> (并将 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 保留为导致新异常的原因)。</p>
<p><em>在 3.3 版更改:</em> 添加了 <code>value</code> 属性及其被生成器函数用作返回值的功能。</p>
<p><em>在 3.5 版更改:</em> 引入了通过 <code>from __future__ import generator_stop</code> 来实现 RuntimeError 转换，参见 <a href="https://www.python.org/dev/peps/pep-0479" target="_blank" rel="noopener"><strong>PEP 479</strong></a>。</p>
<p><em>在 3.7 版更改:</em> 默认对所有代码启用 <a href="https://www.python.org/dev/peps/pep-0479" target="_blank" rel="noopener"><strong>PEP 479</strong></a>: 在生成器中引发的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 错误将被转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p>
</li>
<li><p><em>exception</em> <code>StopAsyncIteration</code></p>
<p>必须由一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterator" target="_blank" rel="noopener">asynchronous iterator</a> 对象的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__" target="_blank" rel="noopener"><code>__anext__()</code></a> 方法来引发以停止迭代操作。<em>3.5 新版功能.</em></p>
</li>
<li><p><em>exception</em> <code>SyntaxError</code></p>
<p>当解析器遇到语法错误时将被引发。 这可以发生在 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句，对内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 的调用，或者读取原始脚本或标准输入（也包括交互模式）的时候。该类的实例包含有属性 <code>filename</code>, <code>lineno</code>, <code>offset</code> 和 <code>text</code> 用于方便地访问相应的详细信息。 异常实例的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a> 仅返回消息文本。</p>
</li>
<li><p><em>exception</em> <code>IndentationError</code></p>
<p>与不正确的缩进相关的语法错误的基类。 这是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>TabError</code></p>
<p>当缩进包含对制表符和空格符不一致的使用时将被引发。 这是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndentationError" target="_blank" rel="noopener"><code>IndentationError</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>SystemError</code></p>
<p>当解释器发现内部错误，但情况看起来尚未严重到要放弃所有希望时将被引发。 关联的值是一个指明发生了什么问题的字符串（表示为低层级的符号）。你应当将此问题报告给你所用 Python 解释器的作者或维护人员。 请确认报告 Python 解释器的版本号 (<code>sys.version</code>; 它也会在交互式 Python 会话开始时被打印出来)，具体的错误消息（异常所关联的值）以及可能触发该错误的程序源码。</p>
</li>
<li><p><em>exception</em> <code>SystemExit</code></p>
<p>此异常由 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 函数引发。 它继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 以确保不会被处理 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的代码意外捕获。 这允许此异常正确地向上传播并导致解释器退出。 如果它未被处理，则 Python 解释器就将退出；不会打印任何栈回溯信息。 构造器接受的可选参数与传递给 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 的相同。 如果该值为一个整数，则它指明系统退出状态码（会传递给 C 的 <code>exit()</code> 函数）；如果该值为 <code>None</code>，则退出状态码为零；如果该值为其他类型（例如字符串），则会打印对象的值并将退出状态码设为一。</p>
<p>对 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 的调用会被转换为一个异常以便能执行清理处理程序 (<a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句)，并且使得调试器可以执行一段脚本而不必冒失去控制的风险。 如果绝对确实地需要立即退出（例如在调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>os.fork()</code></a> 之后的子进程中）则可使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os._exit" target="_blank" rel="noopener"><code>os._exit()</code></a>.</p>
<ul>
<li><p><code>code</code></p>
<p>传给构造器的退出状态码或错误信息（默认为 <code>None</code>。）</p>
</li>
</ul>
</li>
<li><p><em>exception</em> <code>TypeError</code></p>
<p>当一个操作或函数被应用于类型不适当的对象时将被引发。 关联的值是一个字符串，给出有关类型不匹配的详情。此异常可以由用户代码引发，以表明尝试对某个对象进行的操作不受支持也不应当受支持。 如果某个对象应当支持给定的操作但尚未提供相应的实现，所要引发的适当异常应为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a>。传入参数的类型错误 (例如在要求 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 时却传入了 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a>) 应当导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>，但传入参数的值错误 (例如传入要求范围之外的数值) 则应当导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。</p>
</li>
<li><p><em>exception</em> <code>UnboundLocalError</code></p>
<p>当在函数或方法中对某个局部变量进行引用，但该变量并未绑定任何值时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NameError" target="_blank" rel="noopener"><code>NameError</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>UnicodeError</code></p>
<p>当发生与 Unicode 相关的编码或解码错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 的一个子类。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 具有一些描述编码或解码错误的属性。 例如 <code>err.object[err.start:err.end]</code> 会给出导致编解码器失败的特定无效输入。</p>
<ul>
<li><p><code>encoding</code></p>
<p>引发错误的编码名称。</p>
</li>
<li><p><code>reason</code></p>
<p>描述特定编解码器错误的字符串。</p>
</li>
<li><p><code>object</code></p>
<p>编解码器试图要编码或解码的对象。</p>
</li>
<li><p><code>start</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 中无效数据的开始位置索引。</p>
</li>
<li><p><code>end</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 中无效数据的末尾位置索引（不含）。</p>
</li>
</ul>
</li>
<li><p><em>exception</em> <code>UnicodeEncodeError</code></p>
<p>当在编码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>UnicodeDecodeError</code></p>
<p>当在解码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>UnicodeTranslateError</code></p>
<p>在转写过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p>
</li>
<li><p><em>exception</em> <code>ValueError</code></p>
<p>当操作或函数接收到具有正确类型但值不适合的参数，并且情况不能用更精确的异常例如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 来描述时将被引发。</p>
</li>
<li><p><em>exception</em> <code>ZeroDivisionError</code></p>
<p>当除法或取余运算的第二个参数为零时将被引发。 关联的值是一个字符串，指明操作数和运算的类型。</p>
</li>
</ul>
<p>下列异常被保留以与之前的版本相兼容；从 Python 3.3 开始，它们都是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的别名。</p>
<ul>
<li><em>exception</em> <code>EnvironmentError</code></li>
</ul>
<ul>
<li><em>exception</em> <code>IOError</code></li>
</ul>
<ul>
<li><p><em>exception</em> <code>WindowsError</code></p>
<p>限在 Windows 中可用。</p>
</li>
</ul>
<h3 id="OS-异常"><a href="#OS-异常" class="headerlink" title="OS 异常"></a>OS 异常</h3><p>下列异常均为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的子类，它们将根据系统错误代码被引发。</p>
<ul>
<li><p><em>exception</em> <code>BlockingIOError</code></p>
<p>当一个操作会被某个设置为非阻塞操作的对象（例如套接字）所阻塞时将被引发。 对应于 <code>errno</code> <code>EAGAIN</code>, <code>EALREADY</code>, <code>EWOULDBLOCK</code> 和 <code>EINPROGRESS</code>。除了 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 已有的属性，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BlockingIOError" target="_blank" rel="noopener"><code>BlockingIOError</code></a> 还有一个额外属性：<code>characters_written</code>一个整数，表示在被阻塞前已写入到流的字符数。 当使用来自 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#module-io" target="_blank" rel="noopener"><code>io</code></a> 模块的带缓冲 I/O 类时此属性可用。</p>
</li>
<li><p><em>exception</em> <code>ChildProcessError</code></p>
<p>当一个子进程上的操作失败时将被引发。 对应于 <code>errno</code> <code>ECHILD</code>。</p>
</li>
<li><p><em>exception</em> <code>ConnectionError</code></p>
<p>与连接相关问题的基类。其子类有 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BrokenPipeError" target="_blank" rel="noopener"><code>BrokenPipeError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionAbortedError" target="_blank" rel="noopener"><code>ConnectionAbortedError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionRefusedError" target="_blank" rel="noopener"><code>ConnectionRefusedError</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionResetError" target="_blank" rel="noopener"><code>ConnectionResetError</code></a>。</p>
</li>
<li><p><em>exception</em> <code>BrokenPipeError</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当试图写入另一端已被关闭的管道，或是试图写入已关闭写入的套接字时将被引发。 对应于 <code>errno</code> <code>EPIPE</code> 和 <code>ESHUTDOWN</code>。</p>
</li>
<li><p><em>exception</em> <code>ConnectionAbortedError</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接尝试被对端中止时将被引发。 对应于 <code>errno</code> <code>ECONNABORTED</code>。</p>
</li>
<li><p><em>exception</em> <code>ConnectionRefusedError</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接尝试被对端拒绝时将被引发。 对应于 <code>errno</code> <code>ECONNREFUSED</code>。</p>
</li>
<li><p><em>exception</em> <code>ConnectionResetError</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接被对端重置时将被引发。 对应于 <code>errno</code> <code>ECONNRESET</code>。</p>
</li>
<li><p><em>exception</em> <code>FileExistsError</code></p>
<p>当试图创建一个已存在的文件或目录时将被引发。 对应于 <code>errno</code> <code>EEXIST</code>。</p>
</li>
<li><p><em>exception</em> <code>FileNotFoundError</code></p>
<p>当所请求的文件或目录不存在时将被引发。 对应于 <code>errno</code> <code>ENOENT</code>。</p>
</li>
<li><p><em>exception</em> <code>InterruptedError</code></p>
<p>当系统调用被输入信号中断时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EINTR" target="_blank" rel="noopener"><code>EINTR</code></a>。<em>在 3.5 版更改:</em> 当系统调用被某个信号中断时，Python 现在会重试系统调用，除非该信号的处理程序引发了其它异常 (原理参见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>) 而不是引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a>。</p>
</li>
<li><p><em>exception</em> <code>IsADirectoryError</code></p>
<p>当请求对一个目录执行文件操作 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.remove" target="_blank" rel="noopener"><code>os.remove()</code></a>) 将被引发。 对应于 <code>errno</code> <code>EISDIR</code>。</p>
</li>
<li><p><em>exception</em> <code>NotADirectoryError</code></p>
<p>当请求对一个非目录对象执行目录操作 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>os.listdir()</code></a>) 时将被引发。 对应于 <code>errno</code> <code>ENOTDIR</code>。</p>
</li>
<li><p><em>exception</em> <code>PermissionError</code></p>
<p>当在没有足够操作权限的情况下试图执行某个操作时将被引发 —— 例如缺少文件系统权限。 对应于 <code>errno</code> <code>EACCES</code> 和 <code>EPERM</code>。</p>
</li>
<li><p><em>exception</em> <code>ProcessLookupError</code></p>
<p>当给定的进程不存在时将被引发。 对应于 <code>errno</code> <code>ESRCH</code>。</p>
</li>
<li><p><em>exception</em> <code>TimeoutError</code></p>
<p>当一个系统函数发生系统级超时的情况下将被引发。 对应于 <code>errno</code> <code>ETIMEDOUT</code>。</p>
</li>
</ul>
<p><em>3.3 新版功能:</em> 添加了以上所有 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的子类。</p>
<p>参见: </p>
<p><a href="https://www.python.org/dev/peps/pep-3151" target="_blank" rel="noopener"><strong>PEP 3151</strong></a> - 重写 OS 和 IO 异常的层次结构</p>
<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>下列异常被用作警告类别；请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/warnings.html#warning-categories" target="_blank" rel="noopener">警告类别</a> 文档了解详情。</p>
<ul>
<li><p><em>exception</em> <code>Warning</code></p>
<p>警告类别的基类。</p>
</li>
<li><p><em>exception</em> <code>UserWarning</code></p>
<p>用户代码所产生警告的基类。</p>
</li>
<li><p><em>exception</em> <code>DeprecationWarning</code></p>
<p>如果所发出的警告是针对其他 Python 开发者的，则以此作为与已弃用特性相关警告的基类。</p>
</li>
<li><p><em>exception</em> <code>PendingDeprecationWarning</code></p>
<p>对于已过时并预计在未来弃用，但目前尚未弃用的特性相关警告的基类。这个类很少被使用，因为针对未来可能的弃用发出警告的做法并不常见，而针对当前已有的弃用则推荐使用 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#DeprecationWarning" target="_blank" rel="noopener"><code>DeprecationWarning</code></a>。</p>
</li>
<li><p><em>exception</em> <code>SyntaxWarning</code></p>
<p>与模糊的语法相关的警告的基类。</p>
</li>
<li><p><em>exception</em> <code>RuntimeWarning</code></p>
<p>与模糊的运行时行为相关的警告的基类。</p>
</li>
<li><p><em>exception</em> <code>FutureWarning</code></p>
<p>如果所发出的警告是针对以 Python 所编写应用的最终用户的，则以此作为与已弃用特性相关警告的基类。</p>
</li>
<li><p><em>exception</em> <code>ImportWarning</code></p>
<p>与在模块导入中可能的错误相关的警告的基类。</p>
</li>
<li><p><em>exception</em> <code>UnicodeWarning</code></p>
<p>与 Unicode 相关的警告的基类。</p>
</li>
<li><p><em>exception</em> <code>BytesWarning</code></p>
<p>与 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 相关的警告的基类。</p>
</li>
<li><p><em>exception</em> <code>ResourceWarning</code></p>
<p>与资源使用相关的警告的基类。 会被默认的警告过滤器忽略。<em>3.2 新版功能.</em></p>
</li>
</ul>
<h2 id="异常层次结构"><a href="#异常层次结构" class="headerlink" title="异常层次结构"></a>异常层次结构</h2><p> 内置异常的类层级结构如下： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- StopAsyncIteration</span><br><span class="line">      +-- ArithmeticError</span><br><span class="line">      |    +-- FloatingPointError</span><br><span class="line">      |    +-- OverflowError</span><br><span class="line">      |    +-- ZeroDivisionError</span><br><span class="line">      +-- AssertionError</span><br><span class="line">      +-- AttributeError</span><br><span class="line">      +-- BufferError</span><br><span class="line">      +-- EOFError</span><br><span class="line">      +-- ImportError</span><br><span class="line">      |    +-- ModuleNotFoundError</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br><span class="line">      +-- MemoryError</span><br><span class="line">      +-- NameError</span><br><span class="line">      |    +-- UnboundLocalError</span><br><span class="line">      +-- **OSError**</span><br><span class="line">      |    +-- BlockingIOError</span><br><span class="line">      |    +-- ChildProcessError</span><br><span class="line">      |    +-- ConnectionError</span><br><span class="line">      |    |    +-- BrokenPipeError</span><br><span class="line">      |    |    +-- ConnectionAbortedError</span><br><span class="line">      |    |    +-- ConnectionRefusedError</span><br><span class="line">      |    |    +-- ConnectionResetError</span><br><span class="line">      |    +-- FileExistsError</span><br><span class="line">      |    +-- FileNotFoundError</span><br><span class="line">      |    +-- InterruptedError</span><br><span class="line">      |    +-- IsADirectoryError</span><br><span class="line">      |    +-- NotADirectoryError</span><br><span class="line">      |    +-- PermissionError</span><br><span class="line">      |    +-- ProcessLookupError</span><br><span class="line">      |    +-- TimeoutError</span><br><span class="line">      +-- ReferenceError</span><br><span class="line">      +-- RuntimeError</span><br><span class="line">      |    +-- NotImplementedError</span><br><span class="line">      |    +-- RecursionError</span><br><span class="line">      +-- SyntaxError</span><br><span class="line">      |    +-- IndentationError</span><br><span class="line">      |         +-- TabError</span><br><span class="line">      +-- SystemError</span><br><span class="line">      +-- TypeError</span><br><span class="line">      +-- ValueError</span><br><span class="line">      |    +-- UnicodeError</span><br><span class="line">      |         +-- UnicodeDecodeError</span><br><span class="line">      |         +-- UnicodeEncodeError</span><br><span class="line">      |         +-- UnicodeTranslateError</span><br><span class="line">      +-- Warning</span><br><span class="line">           +-- DeprecationWarning</span><br><span class="line">           +-- PendingDeprecationWarning</span><br><span class="line">           +-- RuntimeWarning</span><br><span class="line">           +-- SyntaxWarning</span><br><span class="line">           +-- UserWarning</span><br><span class="line">           +-- FutureWarning</span><br><span class="line">           +-- ImportWarning</span><br><span class="line">           +-- UnicodeWarning</span><br><span class="line">           +-- BytesWarning</span><br><span class="line">           +-- ResourceWarning</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>esp32 micropython tutorial 01 environment setup</title>
    <url>/2020/03/23/esp32-micropython-tutorial-01-environment-setup/</url>
    <content><![CDATA[<h1 id="esp32-micropython-之旅-01-环境搭建"><a href="#esp32-micropython-之旅-01-环境搭建" class="headerlink" title="esp32  micropython 之旅 01 环境搭建"></a>esp32  micropython 之旅 01 环境搭建</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/ardunio_logo.jpg?raw=true" alt></p>
<a id="more"></a>
<p>今天开始另一个系列的文章,有关嵌入式的专题,希望大家能支持我！</p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><table>
<thead>
<tr>
<th>环境</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>win7 64位 旗舰版</td>
</tr>
<tr>
<td>micropython</td>
<td>v1.12</td>
</tr>
<tr>
<td>esp32</td>
<td>uno D1 R32</td>
</tr>
<tr>
<td>ardunio ide</td>
<td>v1.8.12</td>
</tr>
</tbody>
</table>
<h2 id="开箱时刻"><a href="#开箱时刻" class="headerlink" title="开箱时刻"></a>开箱时刻</h2><p>某宝买了一个不到30块钱的板子,支持蓝牙、WIFI,4m缓存,直接开搞</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/b3c9d52def57969321ed5dad73c169a.jpg?raw=true" alt></p>
<p>开箱通电</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/6fd65f0e334bf5b843ec2a3367e0b7c.jpg?raw=true" alt></p>
<p>安装驱动部分我一篇再说,下面是具体刷<code>micropython</code>固件过程</p>
<h2 id="安装-esptool"><a href="#安装-esptool" class="headerlink" title="安装 esptool"></a>安装 esptool</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install esptool</span><br></pre></td></tr></table></figure>
<h2 id="擦除固件"><a href="#擦除固件" class="headerlink" title="擦除固件"></a>擦除固件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">esptool.py --chip esp32 --port /dev/ttyUSB0 erase_flash</span><br></pre></td></tr></table></figure>
<h2 id="刷micropython固件"><a href="#刷micropython固件" class="headerlink" title="刷micropython固件"></a>刷micropython固件</h2><p><a href="https://micropython.org/download#esp32" target="_blank" rel="noopener">固件下载地址</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">esptool.py --port COM13 write_flash 0x1000 esp32-idf3-20200323-v1.12-270-g38ccb4c64.bin</span><br></pre></td></tr></table></figure>
<h2 id="编写小灯闪亮程序"><a href="#编写小灯闪亮程序" class="headerlink" title="编写小灯闪亮程序"></a>编写小灯闪亮程序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line">p0 = Pin(<span class="number">2</span>,Pin.OUT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p0.value(<span class="number">0</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    p0.value(<span class="number">1</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<h2 id="通过ampy命令推送到uno中"><a href="#通过ampy命令推送到uno中" class="headerlink" title="通过ampy命令推送到uno中"></a>通过ampy命令推送到uno中</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install adafruit-ampy</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ampy --port COM13 put blink.py</span><br></pre></td></tr></table></figure>
<h2 id="查看固件中的文件"><a href="#查看固件中的文件" class="headerlink" title="查看固件中的文件"></a>查看固件中的文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Type "help()" for more information.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import os</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; os.listdir()</span></span><br><span class="line">['boot.py', 'blink.py']</span><br></pre></td></tr></table></figure>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">os.remove('blink.py')</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>引脚问题还没解决,小灯正常应该可以点亮,以后有得玩了。</p>
]]></content>
      <categories>
        <category>micropython</category>
        <category>esp32</category>
      </categories>
      <tags>
        <tag>micropython</tag>
        <tag>esp32</tag>
        <tag>esptool</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library re</title>
    <url>/2020/03/18/python-standard-library-re/</url>
    <content><![CDATA[<h1 id="python-标准库-re-正则表达式"><a href="#python-标准库-re-正则表达式" class="headerlink" title="python 标准库 re 正则表达式"></a>python 标准库 re 正则表达式</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200318_china.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>此生无悔入华夏,来世愿在种花家。</p>
</blockquote>
<p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/re.py" target="_blank" rel="noopener">Lib/re.py</a></p>
<hr>
<p>这个模块提供了与 Perl 语言类似的正则表达式匹配操作。</p>
<p>模式和被搜索的字符串既可以是 Unicode 字符串 (<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>) ，也可以是8位字节串 (<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>)。 但是，Unicode 字符串与8位字节串不能混用：也就是说，你不能用一个字节串模式去匹配 Unicode 字符串，反之亦然；类似地，当进行替换操作时，替换字符串的类型也必须与所用的模式和搜索字符串的类型一致。</p>
<p>正则表达式使用反斜杠字符 (<code>&#39;\&#39;</code>) 来表示特殊形式或是允许在使用特殊字符时不引发它们的特殊含义。 这会与 Python 的字符串字面值中对相同字符出于相同目的的用法产生冲突；例如，要匹配一个反斜杠字面值，用户可能必须写成 <code>&#39;\\\\&#39;</code> 来作为模式字符串，因为正则表达式必须为 <code>\\</code>，而每个反斜杠在普通 Python 字符串字面值中又必须表示为 <code>\\</code>。 而且还要注意，在 Python 的字符串字面值中使用的反斜杠如果有任何无效的转义序列，现在将会产生 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#DeprecationWarning" target="_blank" rel="noopener"><code>DeprecationWarning</code></a> 并将在未来改为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a>。 此行为即使对于正则表达式来说有效的转义字符同样会发生。</p>
<p>解决办法是对于正则表达式样式使用 Python 的原始字符串表示法；在带有 <code>&#39;r&#39;</code> 前缀的字符串字面值中，反斜杠不必做任何特殊处理。 因此 <code>r&quot;\n&quot;</code> 表示包含 <code>&#39;\&#39;</code> 和 <code>&#39;n&#39;</code> 两个字符的字符串，而 <code>&quot;\n&quot;</code> 则表示只包含一个换行符的字符串。 样式在 Python 代码中通常都会使用这种原始字符串表示法来表示。</p>
<p>绝大部分正则表达式操作都提供为模块函数和方法，在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re-objects" target="_blank" rel="noopener">编译正则表达式</a>. 这些函数是一个捷径，不需要先编译一个正则对象，但是损失了一些优化参数。</p>
<p>参见:</p>
<p>第三方模块 <a href="https://pypi.org/project/regex/" target="_blank" rel="noopener">regex</a> , 提供了与标准库 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#module-re" target="_blank" rel="noopener"><code>re</code></a> 模块兼容的API接口, 同时还提供了额外的功能和更全面的Unicode支持。</p>
<h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><p>一个正则表达式（或RE）指定了一集与之匹配的字符串；模块内的函数可以让你检查某个字符串是否跟给定的正则表达式匹配（或者一个正则表达式是否匹配到一个字符串，这两种说法含义相同）。</p>
<p>正则表达式可以拼接； 如果 <em>A</em> 和 <em>B</em> 都是正则表达式， 那么 <em>AB</em> 也是正则表达式。 通常， 如果字符串 <em>p</em> 匹配 <em>A</em> 并且另一个字符串 <em>q</em> 匹配 <em>B</em>, 那么 <em>pq</em> 可以匹配 AB。除非 <em>A</em> 或者 <em>B</em> 包含低优先级操作，<em>A</em> 和 <em>B</em> 存在边界条件；或者命名组引用。所以，复杂表达式可以很容易的从这里描述的简单源语表达式构建。 了解更多正则表达式理论和实现，参考the Friedl book <a href="https://docs.python.org/zh-cn/3.8/library/re.html#frie09" target="_blank" rel="noopener">[Frie09]</a> ，或者其他编译器构建的书籍。</p>
<p>以下是正则表达式格式的简要说明。更详细的信息和演示，参考 <a href="https://docs.python.org/zh-cn/3.8/howto/regex.html#regex-howto" target="_blank" rel="noopener">正则表达式HOWTO</a>。</p>
<p>正则表达式可以包含普通或者特殊字符。绝大部分普通字符，比如 <code>&#39;A&#39;</code>, <code>&#39;a&#39;</code>, 或者 <code>&#39;0&#39;</code>，都是最简单的正则表达式。它们就匹配自身。你可以拼接普通字符，所以 <code>last</code> 匹配字符串 <code>&#39;last&#39;</code>. （在这一节的其他部分，我们将用 <code>this special style</code> 这种方式表示正则表达式，通常不带引号，要匹配的字符串用 <code>&#39;in single quotes&#39;</code> ，单引号形式。）</p>
<p>有些字符，比如 <code>&#39;|&#39;</code> 或者 <code>&#39;(&#39;</code>，属于特殊字符。 特殊字符既可以表示它的普通含义， 也可以影响它旁边的正则表达式的解释。</p>
<p>重复修饰符 (<code>*</code>, <code>+</code>, <code>?</code>, <code>{m,n}</code>, 等) 不能直接嵌套。这样避免了非贪婪后缀 <code>?</code> 修饰符，和其他实现中的修饰符产生的多义性。要应用一个内层重复嵌套，可以使用括号。 比如，表达式 <code>(?:a{6})*</code> 匹配6个 <code>&#39;a&#39;</code> 字符重复任意次数。</p>
<p>特殊字符是：</p>
<ul>
<li><p><code>.</code></p>
<p>(点) 在默认模式，匹配除了换行的任意字符。如果指定了标签 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.DOTALL" target="_blank" rel="noopener"><code>DOTALL</code></a> ，它将匹配包括换行符的任意字符。</p>
</li>
<li><p><code>^</code></p>
<p>(插入符号) 匹配字符串的开头， 并且在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.MULTILINE" target="_blank" rel="noopener"><code>MULTILINE</code></a> 模式也匹配换行后的首个符号。</p>
</li>
<li><p><code>$</code></p>
<p>匹配字符串尾或者换行符的前一个字符，在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.MULTILINE" target="_blank" rel="noopener"><code>MULTILINE</code></a> 模式匹配换行符的前一个字符。 <code>foo</code> 匹配 <code>&#39;foo&#39;</code> 和 <code>&#39;foobar&#39;</code> , 但正则 <code>foo$</code> 只匹配 <code>&#39;foo&#39;</code>。更有趣的是， 在 <code>&#39;foo1\nfoo2\n&#39;</code> 搜索 <code>foo.$</code> ，通常匹配 <code>&#39;foo2&#39;</code> ，但在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.MULTILINE" target="_blank" rel="noopener"><code>MULTILINE</code></a> 模式 ，可以匹配到 <code>&#39;foo1&#39;</code> ；在 <code>&#39;foo\n&#39;</code> 搜索 <code>$</code> 会找到两个空串：一个在换行前，一个在字符串最后。</p>
</li>
<li><p><code>*</code></p>
<p>对它前面的正则式匹配0到任意次重复， 尽量多的匹配字符串。 <code>ab*</code> 会匹配 <code>&#39;a&#39;</code>， <code>&#39;ab&#39;</code>， 或者 <code>&#39;a&#39;后面跟随任意个 &#39;b&#39;</code>。</p>
</li>
<li><p><code>+</code></p>
<p>对它前面的正则式匹配1到任意次重复。 <code>ab+</code> 会匹配 <code>&#39;a&#39;</code> 后面跟随1个以上到任意个 <code>&#39;b&#39;</code>，它不会匹配 <code>&#39;a&#39;</code>。</p>
</li>
<li><p><code>?</code></p>
<p>对它前面的正则式匹配0到1次重复。 <code>ab?</code> 会匹配 <code>&#39;a&#39;</code> 或者 <code>&#39;ab&#39;</code>。</p>
</li>
<li><p><code>*?</code>, <code>+?</code>, <code>??</code></p>
<p><code>&#39;*&#39;</code>, <code>&#39;+&#39;</code>，和 <code>&#39;?&#39;</code> 修饰符都是 <em>贪婪的</em>；它们在字符串进行尽可能多的匹配。有时候并不需要这种行为。如果正则式 <code>&lt;.*&gt;</code> 希望找到 <code>&#39; b &#39;</code>，它将会匹配整个字符串，而不仅是 <code>&#39;&#39;</code>。在修饰符之后添加 <code>?</code> 将使样式以 <em>非贪婪<code>方式或者 :dfn:</code>最小</em> 方式进行匹配； 尽量 <em>少</em> 的字符将会被匹配。 使用正则式 <code>&lt;.*?&gt;</code> 将会仅仅匹配 <code>&#39;&#39;</code>。</p>
</li>
<li><p><code>{m}</code></p>
<p>对其之前的正则式指定匹配 <em>m</em> 个重复；少于 <em>m</em> 的话就会导致匹配失败。比如， <code>a{6}</code> 将匹配6个 <code>&#39;a&#39;</code> , 但是不能是5个。</p>
</li>
<li><p><code>{m,n}</code></p>
<p>对正则式进行 <em>m</em> 到 <em>n</em> 次匹配，在 <em>m</em> 和 <em>n</em> 之间取尽量多。 比如，<code>a{3,5}</code> 将匹配 3 到 5个 <code>&#39;a&#39;</code>。忽略 <em>m</em> 意为指定下界为0，忽略 <em>n</em> 指定上界为无限次。 比如 <code>a{4,}b</code> 将匹配 <code>&#39;aaaab&#39;</code> 或者1000个 <code>&#39;a&#39;</code> 尾随一个 <code>&#39;b&#39;</code>，但不能匹配 <code>&#39;aaab&#39;</code>。逗号不能省略，否则无法辨别修饰符应该忽略哪个边界。</p>
</li>
<li><p><code>{m,n}?</code></p>
<p>前一个修饰符的非贪婪模式，只匹配尽量少的字符次数。比如，对于 <code>&#39;aaaaaa&#39;</code>， <code>a{3,5}</code> 匹配 5个 <code>&#39;a&#39;</code> ，而 <code>a{3,5}?</code> 只匹配3个 <code>&#39;a&#39;</code>。</p>
</li>
<li><p><code>\</code></p>
<p>转义特殊字符（允许你匹配 <code>&#39;*&#39;</code>, <code>&#39;?&#39;</code>, 或者此类其他），或者表示一个特殊序列；特殊序列之后进行讨论。如果你没有使用原始字符串（ <code>r&#39;raw&#39;</code> ）来表达样式，要牢记Python也使用反斜杠作为转义序列；如果转义序列不被Python的分析器识别，反斜杠和字符才能出现在字符串中。如果Python可以识别这个序列，那么反斜杠就应该重复两次。这将导致理解障碍，所以高度推荐，就算是最简单的表达式，也要使用原始字符串。</p>
</li>
<li><p><code>[]</code></p>
<p>用于表示一个字符集合。在一个集合中：字符可以单独列出，比如 <code>[amk]</code> 匹配 <code>&#39;a&#39;</code>， <code>&#39;m&#39;</code>， 或者 <code>&#39;k&#39;</code>。可以表示字符范围，通过用 <code>&#39;-&#39;</code> 将两个字符连起来。比如 <code>[a-z]</code> 将匹配任何小写ASCII字符， <code>[0-5][0-9]</code> 将匹配从 <code>00</code> 到 <code>59</code> 的两位数字， <code>[0-9A-Fa-f]</code> 将匹配任何十六进制数位。 如果 <code>-</code> 进行了转义 （比如 <code>[a\-z]</code>）或者它的位置在首位或者末尾（如 <code>[-a]</code> 或 <code>[a-]</code>），它就只表示普通字符 <code>&#39;-&#39;</code>。特殊字符在集合中，失去它的特殊含义。比如 <code>[(+*)]</code> 只会匹配这几个文法字符 <code>&#39;(&#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;*&#39;</code>, or <code>&#39;)&#39;</code>。字符类如 <code>\w</code> 或者 <code>\S</code> (如下定义) 在集合内可以接受，它们可以匹配的字符由 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 或者 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>LOCALE</code></a> 模式决定。不在集合范围内的字符可以通过 <em>取反</em> 来进行匹配。如果集合首字符是 <code>&#39;^&#39;</code> ，所有 <em>不</em> 在集合内的字符将会被匹配，比如 <code>[^5]</code> 将匹配所有字符，除了 <code>&#39;5&#39;</code>， <code>[^^]</code> 将匹配所有字符，除了 <code>&#39;^&#39;</code>. <code>^</code> 如果不在集合首位，就没有特殊含义。在集合内要匹配一个字符 <code>&#39;]&#39;</code>，有两种方法，要么就在它之前加上反斜杠，要么就把它放到集合首位。比如， <code>[()[\]{}]</code> 和 <code>[]()[{}]</code> 都可以匹配括号。<a href="https://unicode.org/reports/tr18/" target="_blank" rel="noopener">Unicode Technical Standard #18</a> 里的嵌套集合和集合操作支持可能在未来添加。这将会改变语法，所以为了帮助这个改变，一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FutureWarning" target="_blank" rel="noopener"><code>FutureWarning</code></a> 将会在有多义的情况里被 <code>raise</code>，包含以下几种情况，集合由 <code>&#39;[&#39;</code> 开始，或者包含下列字符序列 <code>&#39;--&#39;</code>, <code>&#39;&amp;&amp;&#39;</code>, <code>&#39;~~&#39;</code>, 和 <code>&#39;||&#39;</code>。为了避免警告，需要将它们用反斜杠转义。<em>在 3.7 版更改:</em> 如果一个字符串构建的语义在未来会改变的话，一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FutureWarning" target="_blank" rel="noopener"><code>FutureWarning</code></a> 会 <code>raise</code> 。</p>
</li>
<li><p><code>|</code></p>
<p><code>A|B</code>， <em>A</em> 和 <em>B</em> 可以是任意正则表达式，创建一个正则表达式，匹配 <em>A</em> 或者 <em>B</em>. 任意个正则表达式可以用 <code>&#39;|&#39;</code> 连接。它也可以在组合（见下列）内使用。扫描目标字符串时， <code>&#39;|&#39;</code> 分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。意思就是，一旦 <em>A</em> 匹配成功， <em>B</em> 就不再进行匹配，即便它能产生一个更好的匹配。或者说，<code>&#39;|&#39;</code> 操作符绝不贪婪。 如果要匹配 <code>&#39;|&#39;</code> 字符，使用 <code>\|</code>， 或者把它包含在字符集里，比如 <code>[|]</code>.</p>
</li>
<li><p><code>(...)</code></p>
<p>（组合），匹配括号内的任意正则表达式，并标识出组合的开始和结尾。匹配完成后，组合的内容可以被获取，并可以在之后用 <code>\number</code> 转义序列进行再次匹配，之后进行详细说明。要匹配字符 <code>&#39;(&#39;</code> 或者 <code>&#39;)&#39;</code>, 用 <code>\(</code> 或 <code>\)</code>, 或者把它们包含在字符集合里: <code>[(]</code>, <code>[)]</code>.</p>
</li>
<li><p><code>(?…)</code></p>
<p>这是个扩展标记法 （一个 <code>&#39;?&#39;</code> 跟随 <code>&#39;(&#39;</code> 并无含义）。 <code>&#39;?&#39;</code> 后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合； <code>(?P...)</code> 是唯一的例外。 以下是目前支持的扩展。</p>
</li>
<li><p><code>(?aiLmsux)</code></p>
<p>( <code>&#39;a&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;L&#39;</code>, <code>&#39;m&#39;</code>, <code>&#39;s&#39;</code>, <code>&#39;u&#39;</code>, <code>&#39;x&#39;</code> 中的一个或多个) 这个组合匹配一个空字符串；这些字符对正则表达式设置以下标记 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.A" target="_blank" rel="noopener"><code>re.A</code></a> (只匹配ASCII字符), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.I" target="_blank" rel="noopener"><code>re.I</code></a> (忽略大小写), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.L" target="_blank" rel="noopener"><code>re.L</code></a> (语言依赖), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.M" target="_blank" rel="noopener"><code>re.M</code></a> (多行模式), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.S" target="_blank" rel="noopener"><code>re.S</code></a> (点dot匹配全部字符), <code>re.U</code> (Unicode匹配), and <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.X" target="_blank" rel="noopener"><code>re.X</code></a> (冗长模式)。 (这些标记在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#contents-of-module-re" target="_blank" rel="noopener">模块内容</a> 中描述) 如果你想将这些标记包含在正则表达式中，这个方法就很有用，免去了在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.compile" target="_blank" rel="noopener"><code>re.compile()</code></a> 中传递 <em>flag</em> 参数。标记应该在表达式字符串首位表示。</p>
</li>
<li><p><code>(?:…)</code></p>
<p>正则括号的非捕获版本。 匹配在括号内的任何正则表达式，但该分组所匹配的子字符串 <em>不能</em> 在执行匹配后被获取或是之后在模式中被引用。</p>
</li>
<li><p><code>(?aiLmsux-imsx:…)</code></p>
<p>(<code>&#39;a&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;L&#39;</code>, <code>&#39;m&#39;</code>, <code>&#39;s&#39;</code>, <code>&#39;u&#39;</code>, <code>&#39;x&#39;</code> 中的0或者多个， 之后可选跟随 <code>&#39;-&#39;</code> 在后面跟随 <code>&#39;i&#39;</code> , <code>&#39;m&#39;</code> , <code>&#39;s&#39;</code> , <code>&#39;x&#39;</code> 中的一到多个 .) 这些字符为表达式的其中一部分 <em>设置</em> 或者 <em>去除</em> 相应标记 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.A" target="_blank" rel="noopener"><code>re.A</code></a> (只匹配ASCII), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.I" target="_blank" rel="noopener"><code>re.I</code></a> (忽略大小写), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.L" target="_blank" rel="noopener"><code>re.L</code></a> (语言依赖), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.M" target="_blank" rel="noopener"><code>re.M</code></a> (多行), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.S" target="_blank" rel="noopener"><code>re.S</code></a> (点匹配所有字符), <code>re.U</code> (Unicode匹配), and <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.X" target="_blank" rel="noopener"><code>re.X</code></a> (冗长模式)。(标记描述在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#contents-of-module-re" target="_blank" rel="noopener">模块内容</a> .)<code>&#39;a&#39;</code>, <code>&#39;L&#39;</code> and <code>&#39;u&#39;</code> 作为内联标记是相互排斥的， 所以它们不能结合在一起，或者跟随 <code>&#39;-&#39;</code> 。 当他们中的某个出现在内联组中，它就覆盖了括号组内的匹配模式。在Unicode样式中， <code>(?a:...)</code> 切换为 只匹配ASCII， <code>(?u:...)</code> 切换为Unicode匹配 (默认). 在byte样式中 <code>(?L:...)</code> 切换为语言依赖模式， <code>(?a:...)</code> 切换为 只匹配ASCII (默认)。这种方式只覆盖组合内匹配，括号外的匹配模式不受影响。<em>3.6 新版功能.**在 3.7 版更改:</em> 符号 <code>&#39;a&#39;</code>, <code>&#39;L&#39;</code> 和 <code>&#39;u&#39;</code> 同样可以用在一个组合内。</p>
</li>
<li><p><code>(?P…)</code></p>
<p>（命名组合）类似正则组合，但是匹配到的子串组在外部是通过定义的 <em>name</em> 来获取的。组合名必须是有效的Python标识符，并且每个组合名只能用一个正则表达式定义，只能定义一次。一个符号组合同样是一个数字组合，就像这个组合没有被命名一样。命名组合可以在三种上下文中引用。如果样式是 <code>(?P[&#39;&quot;]).*?(?P=quote)</code> （也就是说，匹配单引号或者双引号括起来的字符串)：引用组合 “quote” 的上下文引用方法在正则式自身内<code>(?P=quote)</code> (如示)<code>\1</code>处理匹配对象 <em>m</em><code>m.group(&#39;quote&#39;)m.end(&#39;quote&#39;)</code> (等)传递到 <code>re.sub()</code> 里的 <em>repl</em> 参数中<code>\g\g&lt;1&gt;\1</code></p>
</li>
<li><p><code>(?P=name)</code></p>
<p>反向引用一个命名组合；它匹配前面那个叫 <em>name</em> 的命名组中匹配到的串同样的字串。</p>
</li>
<li><p><code>(?#…)</code></p>
<p>注释；里面的内容会被忽略。</p>
</li>
<li><p><code>(?=…)</code></p>
<p>匹配 <code>…</code> 的内容，但是并不消费样式的内容。这个叫做 <em>lookahead assertion</em>。比如， <code>Isaac (?=Asimov)</code> 匹配 <code>&#39;Isaac &#39;</code> 只有在后面是 <code>&#39;Asimov&#39;</code> 的时候。</p>
</li>
<li><p><code>(?!…)</code></p>
<p>匹配 <code>…</code> 不符合的情况。这个叫 <em>negative lookahead assertion</em> （前视取反）。比如说， <code>Isaac (?!Asimov)</code> 只有后面 <em>不</em> 是 <code>&#39;Asimov&#39;</code> 的时候才匹配 <code>&#39;Isaac &#39;</code> 。</p>
</li>
<li><p><code>(?&lt;=…)</code></p>
<p>匹配字符串的当前位置，它的前面匹配 <code>…</code> 的内容到当前位置。这叫:dfn:positive lookbehind assertion （正向后视断定）。 <code>(?&lt;=abc)def</code> 会在 <code>&#39;abcdef&#39;</code> 中找到一个匹配，因为后视会往后看3个字符并检查是否包含匹配的样式。包含的匹配样式必须是定长的，意思就是 <code>abc</code> 或 <code>a|b</code> 是允许的，但是 <code>a*</code> 和 <code>a{3,4}</code> 不可以。注意以 positive lookbehind assertions 开始的样式，如 <code>(?&lt;=abc)def</code> ，并不是从 a 开始搜索，而是从 d 往回看的。你可能更加愿意使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>search()</code></a> 函数，而不是 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.match" target="_blank" rel="noopener"><code>match()</code></a> 函数：&gt;&gt;&gt;<code>&gt;&gt;&gt; import re &gt;&gt;&gt; m = re.search(&#39;(?&lt;=abc)def&#39;, &#39;abcdef&#39;) &gt;&gt;&gt; m.group(0) &#39;def&#39;</code>这个例子搜索一个跟随在连字符后的单词：&gt;&gt;&gt;<code>&gt;&gt;&gt; m = re.search(r&#39;(?&lt;=-)\w+&#39;, &#39;spam-egg&#39;) &gt;&gt;&gt; m.group(0) &#39;egg&#39;</code><em>在 3.5 版更改:</em> 添加定长组合引用的支持。</p>
</li>
<li><p>`(?</p>
<p>匹配当前位置之前不是 <code>...</code> 的样式。这个叫 <em>negative lookbehind assertion</em> （后视断定取非）。类似正向后视断定，包含的样式匹配必须是定长的。由 negative lookbehind assertion 开始的样式可以从字符串搜索开始的位置进行匹配。</p>
</li>
<li><p><code>(?(id/name)yes-pattern|no-pattern)</code></p>
<p>如果给定的 <em>id</em> 或 <em>name</em> 存在，将会尝试匹配 <code>yes-pattern</code> ，否则就尝试匹配 <code>no-pattern</code>，<code>no-pattern</code> 可选，也可以被忽略。比如， <code>(&lt;)?(\w+@\w+(?:\.\w+)+)(?(1)&gt;|$)</code> 是一个email样式匹配，将匹配 <code>&#39;&#39;</code> 或 <a href="mailto:`&#39;user@host.com" target="_blank" rel="noopener">`&#39;user@host.com</a>‘<code>，但不会匹配</code>‘ ，也不会匹配 <a href="mailto:`&#39;user@host.com" target="_blank" rel="noopener">`&#39;user@host.com</a>&gt;’`。</p>
</li>
</ul>
<p>由 <code>&#39;\&#39;</code> 和一个字符组成的特殊序列在以下列出。 如果普通字符不是ASCII数位或者ASCII字母，那么正则样式将匹配第二个字符。比如，<code>\$</code> 匹配字符 <code>&#39;$&#39;</code>.</p>
<ul>
<li><p><code>\number</code></p>
<p>匹配数字代表的组合。每个括号是一个组合，组合从1开始编号。比如 <code>(.+) \1</code> 匹配 <code>&#39;the the&#39;</code> 或者 <code>&#39;55 55&#39;</code>, 但不会匹配 <code>&#39;thethe&#39;</code> (注意组合后面的空格)。这个特殊序列只能用于匹配前面99个组合。如果 <em>number</em> 的第一个数位是0， 或者 <em>number</em> 是三个八进制数，它将不会被看作是一个组合，而是八进制的数字值。在 <code>&#39;[&#39;</code> 和 <code>&#39;]&#39;</code> 字符集合内，任何数字转义都被看作是字符。</p>
</li>
<li><p><code>\A</code></p>
<p>只匹配字符串开始。</p>
</li>
<li><p><code>\b</code></p>
<p>匹配空字符串，但只在单词开始或结尾的位置。一个单词被定义为一个单词字符的序列。注意，通常 <code>\b</code> 定义为 <code>\w</code> 和 <code>\W</code> 字符之间，或者 <code>\w</code> 和字符串开始/结尾的边界， 意思就是 <code>r&#39;\bfoo\b&#39;</code> 匹配 <code>&#39;foo&#39;</code>, <code>&#39;foo.&#39;</code>, <code>&#39;(foo)&#39;</code>, <code>&#39;bar foo baz&#39;</code> 但不匹配 <code>&#39;foobar&#39;</code> 或者 <code>&#39;foo3&#39;</code>。默认情况下，Unicode字母和数字是在Unicode样式中使用的，但是可以用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 标记来更改。如果 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>LOCALE</code></a> 标记被设置的话，词的边界是由当前语言区域设置决定的，<code>\b</code> 表示退格字符，以便与Python字符串文本兼容。</p>
</li>
<li><p><code>\B</code></p>
<p>匹配空字符串，但 <em>不</em> 能在词的开头或者结尾。意思就是 <code>r&#39;py\B&#39;</code> 匹配 <code>&#39;python&#39;</code>, <code>&#39;py3&#39;</code>, <code>&#39;py2&#39;</code>, 但不匹配 <code>&#39;py&#39;</code>, <code>&#39;py.&#39;</code>, 或者 <code>&#39;py!&#39;</code>. <code>\B</code> 是 <code>\b</code> 的取非，所以Unicode样式的词语是由Unicode字母，数字或下划线构成的，虽然可以用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 标志来改变。如果使用了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>LOCALE</code></a> 标志，则词的边界由当前语言区域设置。</p>
</li>
<li><p><code>\d</code></p>
<p>对于 Unicode (str) 样式：匹配任何Unicode十进制数（就是在Unicode字符目录[Nd]里的字符）。这包括了 <code>[0-9]</code> ，和很多其他的数字字符。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 标志，就只匹配 <code>[0-9]</code> 。对于8位(bytes)样式：匹配任何十进制数，就是 <code>[0-9]</code>。</p>
</li>
<li><p><code>\D</code></p>
<p>匹配任何非十进制数字的字符。就是 <code>\d</code> 取非。 如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 标志，就相当于 <code>[^0-9]</code> 。</p>
</li>
<li><p><code>\s</code></p>
<p>对于 Unicode (str) 样式：匹配任何Unicode空白字符（包括 <code>[ \t\n\r\f\v]</code> ，还有很多其他字符，比如不同语言排版规则约定的不换行空格）。如果 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 被设置，就只匹配 <code>[ \t\n\r\f\v]</code> 。对于8位(bytes)样式：匹配ASCII中的空白字符，就是 <code>[ \t\n\r\f\v]</code> 。</p>
</li>
<li><p><code>\S</code></p>
<p>匹配任何非空白字符。就是 <code>\s</code> 取非。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 标志，就相当于 <code>[^ \t\n\r\f\v]</code> 。</p>
</li>
<li><p><code>\w</code></p>
<p>对于 Unicode (str) 样式：匹配Unicode词语的字符，包含了可以构成词语的绝大部分字符，也包括数字和下划线。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 标志，就只匹配 <code>[a-zA-Z0-9_]</code> 。对于8位(bytes)样式：匹配ASCII字符中的数字和字母和下划线，就是 <code>[a-zA-Z0-9_]</code> 。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>LOCALE</code></a> 标记，就匹配当前语言区域的数字和字母和下划线。</p>
</li>
<li><p><code>\W</code></p>
<p>匹配任何不是单词字符的字符。 这与 <code>\w</code> 正相反。 如果使用了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 旗标，这就等价于 <code>[^a-zA-Z0-9_]</code>。 如果使用了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>LOCALE</code></a> 旗标，则会匹配在当前区域设置中不是字母数字又不是下划线的字符。</p>
</li>
<li><p><code>\Z</code></p>
<p>只匹配字符串尾。</p>
</li>
</ul>
<p>绝大部分Python的标准转义字符也被正则表达式分析器支持。:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\a      \b      \f      \n</span><br><span class="line">\N      \r      \t      \u</span><br><span class="line">\U      \v      \x      \\</span><br></pre></td></tr></table></figure>
<p>（注意 <code>\b</code> 被用于表示词语的边界，它只在字符集合内表示退格，比如 <code>[\b]</code> 。）</p>
<p><code>&#39;\u&#39;</code>, <code>&#39;\U&#39;</code> 和 <code>&#39;\N&#39;</code> 转义序列只在 Unicode 模式中可被识别。 在 bytes 模式中它们会导致错误。 未知的 ASCII 字母转义序列保留在未来使用，会被当作错误来处理。</p>
<p>八进制转义包含为一个有限形式。如果首位数字是 0， 或者有三个八进制数位，那么就认为它是八进制转义。其他的情况，就看作是组引用。对于字符串文本，八进制转义最多有三个数位长。</p>
<p><em>在 3.3 版更改:</em> 增加了 <code>&#39;\u&#39;</code> 和 <code>&#39;\U&#39;</code> 转义序列。</p>
<p><em>在 3.6 版更改:</em> 由 <code>&#39;\&#39;</code> 和一个ASCII字符组成的未知转义会被看成错误。</p>
<p><em>在 3.8 版更改:</em> 添加了 <code>&#39;\N{name}&#39;</code> 转义序列。 与在字符串字面值中一样，它扩展了命名 Unicode 字符 (例如 <code>&#39;\N{EM DASH}&#39;</code>)。</p>
<h2 id="模块内容"><a href="#模块内容" class="headerlink" title="模块内容"></a>模块内容</h2><p>模块定义了几个函数，常量，和一个例外。有些函数是编译后的正则表达式方法的简化版本（少了一些特性）。绝大部分重要的应用，总是会先将正则表达式编译，之后在进行操作。</p>
<p><em>在 3.6 版更改:</em> 标志常量现在是 <code>RegexFlag</code> 类的实例，这个类是 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>enum.IntFlag</code></a> 的子类。</p>
<ul>
<li><p><code>re.compile</code>(<em>pattern</em>, <em>flags=0</em>)</p>
<p>将正则表达式的样式编译为一个 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re-objects" target="_blank" rel="noopener">正则表达式对象</a> （正则对象），可以用于匹配，通过这个对象的方法 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.match" target="_blank" rel="noopener"><code>match()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 以及其他如下描述。这个表达式的行为可以通过指定 <em>标记</em> 的值来改变。值可以是以下任意变量，可以通过位的OR操作来结合（ <code>|</code> 操作符）。</p>
<p>序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prog = re.compile(pattern)</span><br><span class="line">result = prog.match(string)</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = re.match(pattern, string)</span><br></pre></td></tr></table></figure>
<p>如果需要多次使用这个正则表达式的话，使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.compile" target="_blank" rel="noopener"><code>re.compile()</code></a> 和保存这个正则对象以便复用，可以让程序更加高效。</p>
<p>注解：通过 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.compile" target="_blank" rel="noopener"><code>re.compile()</code></a> 编译后的样式，和模块级的函数会被缓存， 所以少数的正则表达式使用无需考虑编译的问题。</p>
</li>
<li><p><code>re.A</code></p>
</li>
<li><p><code>re.ASCII</code></p>
<p>让 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code>, <code>\d</code>, <code>\D</code>, <code>\s</code> 和 <code>\S</code> 只匹配ASCII，而不是Unicode。这只对Unicode样式有效，会被byte样式忽略。相当于前面语法中的内联标志 <code>(?a)</code> 。注意，为了保持向后兼容， <code>re.U</code> 标记依然存在（还有他的同义 <code>re.UNICODE</code> 和嵌入形式 <code>(?u)</code> ) ， 但是这些在 Python 3 是冗余的，因为默认字符串已经是Unicode了（并且Unicode匹配不允许byte出现)。</p>
</li>
<li><p><code>re.DEBUG</code></p>
<p>显示编译时的debug信息，没有内联标记。</p>
</li>
<li><p><code>re.I</code></p>
</li>
<li><p><code>re.IGNORECASE</code></p>
<p>进行忽略大小写匹配；表达式如 <code>[A-Z]</code> 也会匹配小写字符。Unicode匹配（比如 <code>Ü</code> 匹配 <code>ü</code>）同样有用，除非设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>re.ASCII</code></a> 标记来禁用非ASCII匹配。当前语言区域不会改变这个标记，除非设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>re.LOCALE</code></a> 标记。这个相当于内联标记 <code>(?i)</code> 。注意，当设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.IGNORECASE" target="_blank" rel="noopener"><code>IGNORECASE</code></a> 标记，搜索Unicode样式 <code>[a-z]</code> 或 <code>[A-Z]</code> 的结合时，它将会匹配52个ASCII字符和4个额外的非ASCII字符： ‘İ’ (U+0130, 拉丁大写的 I 带个点在上面), ‘ı’ (U+0131, 拉丁小写没有点的 I ), ‘ſ’ (U+017F, 拉丁小写长 s) and ‘K’ (U+212A, 开尔文符号).如果使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 标记，就只匹配 ‘a’ 到 ‘z’ 和 ‘A’ 到 ‘Z’ 。</p>
</li>
<li><p><code>re.L</code></p>
</li>
<li><p><code>re.LOCALE</code></p>
<p>由当前语言区域决定 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code> 和大小写敏感匹配。这个标记只能对byte样式有效。这个标记不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个 “习惯”，而且只对8位字节有效。Unicode匹配在Python 3 里默认启用，并可以处理不同语言。 这个对应内联标记 <code>(?L)</code> 。</p>
<p><em>在 3.6 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>re.LOCALE</code></a> 只能用于byte样式，而且不能和 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>re.ASCII</code></a> 一起用。</p>
<p><em>在 3.7 版更改:</em> 设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>re.LOCALE</code></a> 标记的编译正则对象不再在编译时依赖语言区域设置。语言区域设置只在匹配的时候影响其结果。</p>
</li>
<li><p><code>re.M</code></p>
</li>
<li><p><code>re.MULTILINE</code></p>
<p>设置以后，样式字符 <code>&#39;^&#39;</code> 匹配字符串的开始，和每一行的开始（换行符后面紧跟的符号）；样式字符 <code>&#39;$&#39;</code> 匹配字符串尾，和每一行的结尾（换行符前面那个符号）。默认情况下，<code>’^’</code> 匹配字符串头，<code>&#39;$&#39;</code> 匹配字符串尾。对应内联标记 <code>(?m)</code> 。</p>
</li>
<li><p><code>re.S</code></p>
</li>
<li><p><code>re.DOTALL</code></p>
<p>让 <code>&#39;.&#39;</code> 特殊字符匹配任何字符，包括换行符；如果没有这个标记，<code>&#39;.&#39;</code> 就匹配 <em>除了</em> 换行符的其他任意字符。对应内联标记 <code>(?s)</code> 。</p>
</li>
<li><p><code>re.X</code></p>
</li>
<li><p><code>re.VERBOSE</code></p>
<p>这个标记允许你编写更具可读性更友好的正则表达式。通过分段和添加注释。空白符号会被忽略，除非在一个字符集合当中或者由反斜杠转义，或者在 <code>*?</code>, <code>(?:</code> or <code>(?P&lt;…&gt;</code> 分组之内。当一个行内有 <code>#</code> 不在字符集和转义序列，那么它之后的所有字符都是注释。意思就是下面两个正则表达式等价地匹配一个十进制数字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = re.compile(<span class="string">r"""\d +  # the integral part</span></span><br><span class="line"><span class="string">                   \.    # the decimal point</span></span><br><span class="line"><span class="string">                   \d *  # some fractional digits"""</span>, re.X)</span><br><span class="line">b = re.compile(<span class="string">r"\d+\.\d*"</span>)</span><br></pre></td></tr></table></figure>
<p>对应内联标记 <code>(?x)</code> 。</p>
</li>
<li><p><code>re.search</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p>扫描整个 <em>字符串</em> 找到匹配样式的第一个位置，并返回一个相应的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a>。如果没有匹配，就返回一个 <code>None</code> ； 注意这和找到一个零长度匹配是不同的。</p>
</li>
<li><p><code>re.match</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p>如果 <em>string</em> 开始的0或者多个字符匹配到了正则表达式样式，就返回一个相应的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a> 。 如果没有匹配，就返回 <code>None</code> ；注意它跟零长度匹配是不同的。注意即便是 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.MULTILINE" target="_blank" rel="noopener"><code>MULTILINE</code></a> 多行模式， <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.match" target="_blank" rel="noopener"><code>re.match()</code></a> 也只匹配字符串的开始位置，而不匹配每行开始。如果你想定位 <em>string</em> 的任何位置，使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>search()</code></a> 来替代（也可参考 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#search-vs-match" target="_blank" rel="noopener">search() vs. match()</a> ）</p>
</li>
<li><p><code>re.fullmatch</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p>如果整个 <em>string</em> 匹配到正则表达式样式，就返回一个相应的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a> 。 否则就返回一个 <code>None</code> ；注意这跟零长度匹配是不同的。<em>3.4 新版功能.</em></p>
</li>
<li><p><code>re.split</code>(<em>pattern</em>, <em>string</em>, <em>maxsplit=0</em>, <em>flags=0</em>)</p>
<p>用 <em>pattern</em> 分开 <em>string</em> 。 如果在 <em>pattern</em> 中捕获到括号，那么所有的组里的文字也会包含在列表里。如果 <em>maxsplit</em> 非零， 最多进行 <em>maxsplit</em> 次分隔， 剩下的字符全部返回到列表的最后一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\W+'</span>, <span class="string">'Words, words, words.'</span>)</span><br><span class="line">[<span class="string">'Words'</span>, <span class="string">'words'</span>, <span class="string">'words'</span>, <span class="string">''</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'(\W+)'</span>, <span class="string">'Words, words, words.'</span>)</span><br><span class="line">[<span class="string">'Words'</span>, <span class="string">', '</span>, <span class="string">'words'</span>, <span class="string">', '</span>, <span class="string">'words'</span>, <span class="string">'.'</span>, <span class="string">''</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\W+'</span>, <span class="string">'Words, words, words.'</span>, <span class="number">1</span>)</span><br><span class="line">[<span class="string">'Words'</span>, <span class="string">'words, words.'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">'[a-f]+'</span>, <span class="string">'0a3B9'</span>, flags=re.IGNORECASE)</span><br><span class="line">[<span class="string">'0'</span>, <span class="string">'3'</span>, <span class="string">'9'</span>]</span><br></pre></td></tr></table></figure>
<p>如果分隔符里有捕获组合，并且匹配到字符串的开始，那么结果将会以一个空字符串开始。对于结尾也是一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'(\W+)'</span>, <span class="string">'...words, words...'</span>)</span><br><span class="line">[<span class="string">''</span>, <span class="string">'...'</span>, <span class="string">'words'</span>, <span class="string">', '</span>, <span class="string">'words'</span>, <span class="string">'...'</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure>
<p>这样的话，分隔组将会出现在结果列表中同样的位置。</p>
<p>样式的空匹配将分开字符串，但只在不相临的状况生效。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\b'</span>, <span class="string">'Words, words, words.'</span>)</span><br><span class="line">  [<span class="string">''</span>, <span class="string">'Words'</span>, <span class="string">', '</span>, <span class="string">'words'</span>, <span class="string">', '</span>, <span class="string">'words'</span>, <span class="string">'.'</span>]</span><br><span class="line">  &gt;&gt;&gt; re.split(<span class="string">r'\W*'</span>, <span class="string">'...words...'</span>)</span><br><span class="line">  [<span class="string">''</span>, <span class="string">''</span>, <span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'s'</span>, <span class="string">''</span>, <span class="string">''</span>]</span><br><span class="line">  &gt;&gt;&gt; re.split(<span class="string">r'(\W*)'</span>, <span class="string">'...words...'</span>)</span><br><span class="line">  [<span class="string">''</span>, <span class="string">'...'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'w'</span>, <span class="string">''</span>, <span class="string">'o'</span>, <span class="string">''</span>, <span class="string">'r'</span>, <span class="string">''</span>, <span class="string">'d'</span>, <span class="string">''</span>, <span class="string">'s'</span>, <span class="string">'...'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  <em>在 3.1 版更改:</em> 增加了可选标记参数。</p>
<p>  <em>在 3.7 版更改:</em> 增加了空字符串的样式分隔。</p>
<ul>
<li><p><code>re.findall</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p>对 <em>string</em> 返回一个不重复的 <em>pattern</em> 的匹配列表， <em>string</em> 从左到右进行扫描，匹配按找到的顺序返回。如果样式里存在一到多个组，就返回一个组合列表；就是一个元组的列表（如果样式里有超过一个组合的话）。空匹配也会包含在结果里。</p>
<p><em>在 3.7 版更改:</em> 非空匹配现在可以在前一个空匹配之后出现了。</p>
</li>
<li><p><code>re.finditer</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p><em>pattern</em> 在 <em>string</em> 里所有的非重复匹配，返回为一个迭代器 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a> 保存了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a> 。 <em>string</em> 从左到右扫描，匹配按顺序排列。空匹配也包含在结果里。<em>在 3.7 版更改:</em> 非空匹配现在可以在前一个空匹配之后出现了。</p>
</li>
<li><p><code>re.sub</code>(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count=0</em>, <em>flags=0</em>)</p>
<p>返回通过使用 <em>repl</em> 替换在 <em>string</em> 最左边非重叠出现的 <em>pattern</em> 而获得的字符串。 如果样式没有找到，则不加改变地返回 <em>string</em>。 <em>repl</em> 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理。 也就是说，<code>\n</code> 会被转换为一个换行符，<code>\r</code> 会被转换为一个回车附，依此类推。 未知的 ASCII 字符转义序列保留在未来使用，会被当作错误来处理。 其他未知转义序列例如 <code>\&amp;</code> 会保持原样。 向后引用像是 <code>\6</code> 会用样式中第 6 组所匹配到的子字符串来替换。 例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):'</span>,</span><br><span class="line"><span class="meta">... </span>       <span class="string">r'static PyObject*\npy_\1(void)\n&#123;'</span>,</span><br><span class="line"><span class="meta">... </span>       <span class="string">'def myfunc():'</span>)</span><br><span class="line"><span class="string">'static PyObject*\npy_myfunc(void)\n&#123;'</span></span><br></pre></td></tr></table></figure>
<p>如果 <em>repl</em> 是一个函数，那它会对每个非重复的 <em>pattern</em> 的情况调用。这个函数只能有一个 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a> 参数，并返回一个替换后的字符串。比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">dashrepl</span><span class="params">(matchobj)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> matchobj.group(<span class="number">0</span>) == <span class="string">'-'</span>: <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="string">'-'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">'-&#123;1,2&#125;'</span>, dashrepl, <span class="string">'pro----gram-files'</span>)</span><br><span class="line"><span class="string">'pro--gram files'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'\sAND\s'</span>, <span class="string">' &amp; '</span>, <span class="string">'Baked Beans And Spam'</span>, flags=re.IGNORECASE)</span><br><span class="line"><span class="string">'Baked Beans &amp; Spam'</span></span><br></pre></td></tr></table></figure>
<p> 样式可以是一个字符串或者一个<a href="https://docs.python.org/zh-cn/3.8/library/re.html#re-objects" target="_blank" rel="noopener">样式对象</a>。可选参数 <em>count</em> 是要替换的最大次数；<em>count</em> 必须是非负整数。如果忽略这个参数，或者设置为0，所有的匹配都会被替换。空匹配只在不相临连续的情况被更替，所以 <code>sub(&#39;x*&#39;, &#39;-&#39;, &#39;abxd&#39;)</code> 返回 <code>&#39;-a-b--d-&#39;</code> 。</p>
<p>在字符串类型的 <em>repl</em> 参数里，如上所述的转义和向后引用中，<code>\g</code> 会使用命名组合 <code>name</code>，（在 <code>(?P…)</code> 语法中定义） <code>\g</code> 会使用数字组；<code>\g&lt;2&gt;</code> 就是 <code>\2</code>，但它避免了二义性，如 <code>\g&lt;2&gt;0</code>。 <code>\20</code> 就会被解释为组20，而不是组2后面跟随一个字符 <code>&#39;0&#39;</code>。向后引用 <code>\g&lt;0&gt;</code> 把 <em>pattern</em> 作为一整个组进行引用。</p>
<p><em>在 3.1 版更改:</em> 增加了可选标记参数。</p>
<p><em>在 3.5 版更改:</em> 不匹配的组合替换为空字符串。<em>在 3.6 版更改:</em> <em>pattern</em> 中的未知转义（由 <code>&#39;\&#39;</code> 和一个 ASCII 字符组成）被视为错误。<em>在 3.7 版更改:</em> <em>repl</em> 中的未知转义（由 <code>&#39;\&#39;</code> 和一个 ASCII 字符组成）被视为错误。<em>在 3.7 版更改:</em> 样式中的空匹配相邻接时会被替换。</p>
</li>
<li><p><code>re.subn</code>(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count=0</em>, <em>flags=0</em>)</p>
<p>行为与 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.sub" target="_blank" rel="noopener"><code>sub()</code></a> 相同，但是返回一个元组 <code>(字符串, 替换次数)</code>.<em>在 3.1 版更改:</em> 增加了可选标记参数。<em>在 3.5 版更改:</em> 不匹配的组合替换为空字符串。</p>
</li>
<li><p><code>re.escape</code>(<em>pattern</em>)</p>
<p>转义 <em>pattern</em> 中的特殊字符。如果你想对任意可能包含正则表达式元字符的文本字符串进行匹配，它就是有用的。比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(re.escape(<span class="string">'http://www.python.org'</span>))</span><br><span class="line">http://www\.python\.org</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>legal_chars = string.ascii_lowercase + string.digits + <span class="string">"!#$%&amp;'*+-.^_`|~:"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'[%s]+'</span> % re.escape(legal_chars))</span><br><span class="line">[abcdefghijklmnopqrstuvwxyz0123456789!\<span class="comment">#\$%\&amp;'\*\+\-\.\^_`\|\~:]+</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>operators = [<span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>, <span class="string">'/'</span>, <span class="string">'**'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'|'</span>.join(map(re.escape, sorted(operators, reverse=<span class="literal">True</span>))))</span><br><span class="line">/|\-|\+|\*\*|\*</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  这个函数不能被用于 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.sub" target="_blank" rel="noopener"><code>sub()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.subn" target="_blank" rel="noopener"><code>subn()</code></a> 的替换字符串，只有反斜杠应该被转义。 例如:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits_re = <span class="string">r'\d+'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample = <span class="string">'/usr/sbin/sendmail - 0 errors, 12 warnings'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(re.sub(digits_re, digits_re.replace(<span class="string">'\\'</span>, <span class="string">r'\\'</span>), sample))</span><br><span class="line">/usr/sbin/sendmail - \d+ errors, \d+ warnings</span><br></pre></td></tr></table></figure>
<p>  <em>在 3.3 版更改:</em> <code>&#39;_&#39;</code> 不再被转义。<em>在 3.7 版更改:</em> 只有在正则表达式中具有特殊含义的字符才会被转义。 因此， <code>&#39;!&#39;</code>, <code>&#39;&quot;&#39;</code>, <code>&#39;%&#39;</code>, <code>&quot;&#39;&quot;</code>, <code>&#39;,&#39;</code>, <code>&#39;/&#39;</code>, <code>&#39;:&#39;</code>, <code>&#39;;&#39;</code>, <code>&#39;&lt;&#39;</code>, <code>&#39;=&#39;</code>, <code>&#39;&gt;&#39;</code>, <code>&#39;@&#39;</code> 和 <code>&quot;</code>“` 将不再会被转义。</p>
<ul>
<li><p><code>re.purge</code>()</p>
<p>清除正则表达式缓存。</p>
</li>
<li><p><em>exception</em> <code>re.error</code>(<em>msg</em>, <em>pattern=None</em>, <em>pos=None</em>)</p>
<p><code>raise</code> 一个例外。当传递到函数的字符串不是一个有效正则表达式的时候（比如，包含一个不匹配的括号）或者其他错误在编译时或匹配时产生。如果字符串不包含样式匹配，是不会被视为错误的。错误实例有以下附加属性：</p>
<ul>
<li><p><code>msg</code>未格式化的错误消息。</p>
</li>
<li><p><code>pattern</code>正则表达式样式。</p>
</li>
<li><p><code>pos</code>编译失败的 <em>pattern</em> 的位置索引（可以是 <code>None</code> ）。</p>
</li>
<li><p><code>lineno</code>对应 <em>pos</em> (可以是 <code>None</code>) 的行号。</p>
</li>
<li><p><code>colno</code>对应 <em>pos</em> (可以是 <code>None</code>) 的列号。</p>
<p><em>在 3.5 版更改:</em> 添加了附加属性。</p>
</li>
</ul>
</li>
</ul>
<h2 id="正则表达式对象-（正则对象）"><a href="#正则表达式对象-（正则对象）" class="headerlink" title="正则表达式对象 （正则对象）"></a>正则表达式对象 （正则对象）</h2><p>编译后的正则表达式对象支持一下方法和属性：</p>
<ul>
<li><p><code>Pattern.search</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>扫描整个 <em>string</em> 寻找第一个匹配的位置， 并返回一个相应的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a>。如果没有匹配，就返回 <code>None</code> ；注意它和零长度匹配是不同的。可选的第二个参数 <em>pos</em> 给出了字符串中开始搜索的位置索引；默认为 <code>0</code>，它不完全等价于字符串切片； <code>&#39;^&#39;</code> 样式字符匹配字符串真正的开头，和换行符后面的第一个字符，但不会匹配索引规定开始的位置。可选参数 <em>endpos</em> 限定了字符串搜索的结束；它假定字符串长度到 <em>endpos</em> ， 所以只有从 <code>pos</code> 到 <code>endpos - 1</code> 的字符会被匹配。如果 <em>endpos</em> 小于 <em>pos</em>，就不会有匹配产生；另外，如果 <em>rx</em> 是一个编译后的正则对象， <code>rx.search(string, 0, 50)</code> 等价于 <code>rx.search(string[:50], 0)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = re.compile(<span class="string">"d"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern.search(<span class="string">"dog"</span>)     <span class="comment"># Match at index 0</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">1</span>), match=<span class="string">'d'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern.search(<span class="string">"dog"</span>, <span class="number">1</span>)  <span class="comment"># No match; search doesn't include the "d"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Pattern.match</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>如果 <em>string</em> 的 <em>开始位置</em> 能够找到这个正则样式的任意个匹配，就返回一个相应的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a>。如果不匹配，就返回 <code>None</code> ；注意它与零长度匹配是不同的。可选参数 <em>pos</em> 和 <em>endpos</em> 与 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 含义相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = re.compile(<span class="string">"o"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern.match(<span class="string">"dog"</span>)      <span class="comment"># No match as "o" is not at the start of "dog".</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern.match(<span class="string">"dog"</span>, <span class="number">1</span>)   <span class="comment"># Match as "o" is the 2nd character of "dog".</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">1</span>, <span class="number">2</span>), match=<span class="string">'o'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如果你想定位匹配在 <em>string</em> 中的位置，使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 来替代（另参考 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#search-vs-match" target="_blank" rel="noopener">search() vs. match()</a>）。</p>
</li>
<li><p><code>Pattern.fullmatch</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>如果整个 <em>string</em> 匹配这个正则表达式，就返回一个相应的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a> 。 否则就返回 <code>None</code> ； 注意跟零长度匹配是不同的。可选参数 <em>pos</em> 和 <em>endpos</em> 与 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 含义相同.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = re.compile(<span class="string">"o[gh]"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern.fullmatch(<span class="string">"dog"</span>)      <span class="comment"># No match as "o" is not at the start of "dog".</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern.fullmatch(<span class="string">"ogre"</span>)     <span class="comment"># No match as not the full string matches.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern.fullmatch(<span class="string">"doggie"</span>, <span class="number">1</span>, <span class="number">3</span>)   <span class="comment"># Matches within given limits.</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">1</span>, <span class="number">3</span>), match=<span class="string">'og'</span>&gt;</span><br></pre></td></tr></table></figure>
<p><em>3.4 新版功能.</em></p>
</li>
<li><p><code>Pattern.split</code>(<em>string</em>, <em>maxsplit=0</em>)</p>
<p>等价于 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.split" target="_blank" rel="noopener"><code>split()</code></a> 函数，使用了编译后的样式。</p>
</li>
<li><p><code>Pattern.findall</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>类似函数 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.findall" target="_blank" rel="noopener"><code>findall()</code></a> ， 使用了编译后样式，但也可以接收可选参数 <em>pos</em> 和 <em>endpos</em> ，限制搜索范围，就像 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>search()</code></a>。</p>
</li>
<li><p><code>Pattern.finditer</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>类似函数 <code>finiter()</code> ， 使用了编译后样式，但也可以接收可选参数 <em>pos</em> 和 <em>endpos</em> ，限制搜索范围，就像 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>search()</code></a>。</p>
</li>
<li><p><code>Pattern.sub</code>(<em>repl</em>, <em>string</em>, <em>count=0</em>)</p>
<p>等价于 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.sub" target="_blank" rel="noopener"><code>sub()</code></a> 函数，使用了编译后的样式。</p>
</li>
<li><p><code>Pattern.subn</code>(<em>repl</em>, <em>string</em>, <em>count=0</em>)</p>
<p>等价于 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.subn" target="_blank" rel="noopener"><code>subn()</code></a> 函数，使用了编译后的样式。</p>
</li>
<li><p><code>Pattern.flags</code></p>
<p>正则匹配标记。这是可以传递给 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.compile" target="_blank" rel="noopener"><code>compile()</code></a> 的参数，任何 <code>(?…)</code> 内联标记，隐性标记比如 <code>UNICODE</code> 的结合。</p>
</li>
<li><p><code>Pattern.groups</code></p>
<p>捕获组合的数量。</p>
</li>
<li><p><code>Pattern.groupindex</code></p>
<p>映射由 <code>(?P)</code> 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的。</p>
</li>
<li><p><code>Pattern.pattern</code></p>
<p>编译对象的原始样式字符串。</p>
</li>
</ul>
<p><em>在 3.7 版更改:</em> 添加 <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#copy.copy" target="_blank" rel="noopener"><code>copy.copy()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#copy.deepcopy" target="_blank" rel="noopener"><code>copy.deepcopy()</code></a> 函数的支持。编译后的正则表达式对象被认为是原子性的。</p>
<h2 id="匹配对象"><a href="#匹配对象" class="headerlink" title="匹配对象"></a>匹配对象</h2><p>匹配对象总是有一个布尔值 <code>True</code>。如果没有匹配的话 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.match" target="_blank" rel="noopener"><code>match()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 返回 <code>None</code> 所以你可以简单的用 <code>if</code> 语句来判断是否匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">match = re.search(pattern, string)</span><br><span class="line">if match:</span><br><span class="line">    process(match)</span><br></pre></td></tr></table></figure>
<p>匹配对象支持以下方法和属性：</p>
<ul>
<li><p><code>Match.expand</code>(<em>template</em>)</p>
<p>对 <em>template</em> 进行反斜杠转义替换并且返回，就像 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.sub" target="_blank" rel="noopener"><code>sub()</code></a> 方法中一样。转义如同 <code>\n</code> 被转换成合适的字符，数字引用(<code>\1</code>, <code>\2</code>)和命名组合(<code>\g&lt;1&gt;</code>, <code>\g</code>) 替换为相应组合的内容。<em>在 3.5 版更改:</em> 不匹配的组合替换为空字符串。</p>
</li>
<li><p><code>Match.group</code>([<em>group1</em>, <em>…</em>])</p>
<p>返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，组1默认到0（整个匹配都被返回）。 如果一个组N 参数值为 0，相应的返回值就是整个匹配字符串；如果它是一个范围 [1..99]，结果就是相应的括号组字符串。如果一个组号是负数，或者大于样式中定义的组数，一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 索引错误就 <code>raise</code>。如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(\w+) (\w+)"</span>, <span class="string">"Isaac Newton, physicist"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)       <span class="comment"># The entire match</span></span><br><span class="line"><span class="string">'Isaac Newton'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)       <span class="comment"># The first parenthesized subgroup.</span></span><br><span class="line"><span class="string">'Isaac'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)       <span class="comment"># The second parenthesized subgroup.</span></span><br><span class="line"><span class="string">'Newton'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>, <span class="number">2</span>)    <span class="comment"># Multiple arguments give us a tuple.</span></span><br><span class="line">(<span class="string">'Isaac'</span>, <span class="string">'Newton'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  <code>如果正则表达式使用了</code>(?P…)<code>语法， *groupN* 参数就也可能是命名组合的名字。如果一个字符串参数在样式中未定义为组合名，一个 [</code>IndexError<code>](https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError) 就</code>raise<code>。</code></p>
<p>  `一个相对复杂的例子</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)"</span>, <span class="string">"Malcolm Reynolds"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="string">'first_name'</span>)</span><br><span class="line"><span class="string">'Malcolm'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="string">'last_name'</span>)</span><br><span class="line"><span class="string">'Reynolds'</span></span><br></pre></td></tr></table></figure>
<p>  如果一个组匹配成功多次，就只返回最后一个匹配</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(..)+"</span>, <span class="string">"a1b2c3"</span>)  <span class="comment"># Matches 3 times.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)                        <span class="comment"># Returns only the last match.</span></span><br><span class="line"><span class="string">'c3'</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>Match.__getitem__</code>(<em>g</em>)</p>
<p>这个等价于 <code>m.group(g)</code>。这允许更方便的引用一个匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(\w+) (\w+)"</span>, <span class="string">"Isaac Newton, physicist"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="number">0</span>]       <span class="comment"># The entire match</span></span><br><span class="line"><span class="string">'Isaac Newton'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="number">1</span>]       <span class="comment"># The first parenthesized subgroup.</span></span><br><span class="line"><span class="string">'Isaac'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="number">2</span>]       <span class="comment"># The second parenthesized subgroup.</span></span><br><span class="line"><span class="string">'Newton'</span></span><br></pre></td></tr></table></figure>
<p> ‘Newton’ `<em>3.6 新版功能.</em></p>
</li>
<li><p><code>Match.groups</code>(<em>default=None</em>)</p>
<p>返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合。 <em>default</em> 参数用于不参与匹配的情况，默认为 <code>None</code>。例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(\d+)\.(\d+)"</span>, <span class="string">"24.1632"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()</span><br><span class="line">(<span class="string">'24'</span>, <span class="string">'1632'</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们使小数点可选，那么不是所有的组都会参与到匹配当中。这些组合默认会返回一个 <code>None</code> ，除非指定了 <em>default</em> 参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(\d+)\.?(\d+)?"</span>, <span class="string">"24"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()      <span class="comment"># Second group defaults to None.</span></span><br><span class="line">(<span class="string">'24'</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups(<span class="string">'0'</span>)   <span class="comment"># Now, the second group defaults to '0'.</span></span><br><span class="line">(<span class="string">'24'</span>, <span class="string">'0'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Match.groupdict</code>(<em>default=None</em>)</p>
<p>返回一个字典，包含了所有的 <em>命名</em> 子组。key就是组名。 <em>default</em> 参数用于不参与匹配的组合；默认为 <code>None</code>。 例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)"</span>, <span class="string">"Malcolm Reynolds"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groupdict()</span><br><span class="line">&#123;<span class="string">'first_name'</span>: <span class="string">'Malcolm'</span>, <span class="string">'last_name'</span>: <span class="string">'Reynolds'</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Match.start</code>([<em>group</em>])</p>
</li>
<li><p><code>Match.end</code>([<em>group</em>])</p>
<p>返回 <em>group</em> 匹配到的字串的开始和结束标号。<em>group</em> 默认为0（意思是整个匹配的子串）。如果 <em>group</em> 存在，但未产生匹配，就返回 <code>-1</code> 。对于一个匹配对象 <em>m</em>， 和一个未参与匹配的组 <em>g</em> ，组 <em>g</em> (等价于 <code>m.group(g)</code>)产生的匹配是</p>
<p><code>m.string[m.start(g):m.end(g)]</code></p>
<p>注意 <code>m.start(group)</code> 将会等于 <code>m.end(group)</code> ，如果 <em>group</em> 匹配一个空字符串的话。比如，在 <code>m = re.search(&#39;b(c?)&#39;, &#39;cba&#39;)</code> 之后，<code>m.start(0)</code> 为 1, <code>m.end(0)</code> 为 2, <code>m.start(1)</code> 和 <code>m.end(1)</code> 都是 2, <code>m.start(2)</code> raise 一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 例外。这个例子会从email地址中移除掉 <em>remove_this</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>email = <span class="string">"tony@tiremove_thisger.net"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">"remove_this"</span>, email)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>email[:m.start()] + email[m.end():]</span><br><span class="line"><span class="string">'tony@tiger.net'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Match.span</code>([<em>group</em>])</p>
<p>对于一个匹配 <em>m</em> ， 返回一个二元组 <code>(m.start(group), m.end(group))</code> 。 注意如果 <em>group</em> 没有在这个匹配中，就返回 <code>(-1, -1)</code> 。<em>group</em> 默认为0，就是整个匹配。</p>
</li>
<li><p><code>Match.pos</code></p>
<p><em>pos</em> 的值，会传递给 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.match" target="_blank" rel="noopener"><code>match()</code></a> 的方法 a <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re-objects" target="_blank" rel="noopener">正则对象</a> 。这个是正则引擎开始在字符串搜索一个匹配的索引位置。</p>
</li>
<li><p><code>Match.endpos</code></p>
<p><em>endpos</em> 的值，会传递给 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.match" target="_blank" rel="noopener"><code>match()</code></a> 的方法 a <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re-objects" target="_blank" rel="noopener">正则对象</a> 。这个是正则引擎停止在字符串搜索一个匹配的索引位置。</p>
</li>
<li><p><code>Match.lastindex</code></p>
<p>捕获组的最后一个匹配的整数索引值，或者 <code>None</code> 如果没有匹配产生的话。比如，对于字符串 <code>&#39;ab&#39;</code>，表达式 <code>(a)b</code>, <code>((a)(b))</code>, 和 <code>((ab))</code> 将得到 <code>lastindex == 1</code> ， 而 <code>(a)(b)</code> 会得到 <code>lastindex == 2</code> 。</p>
</li>
<li><p><code>Match.lastgroup</code></p>
<p>最后一个匹配的命名组名字，或者 <code>None</code> 如果没有产生匹配的话。</p>
</li>
<li><p><code>Match.re</code></p>
<p>返回产生这个实例的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re-objects" target="_blank" rel="noopener">正则对象</a> ， 这个实例是由 正则对象的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.match" target="_blank" rel="noopener"><code>match()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 方法产生的。</p>
</li>
<li><p><code>Match.string</code></p>
<p>传递到 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.match" target="_blank" rel="noopener"><code>match()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 的字符串。</p>
</li>
</ul>
<p><em>在 3.7 版更改:</em> 添加了对 <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#copy.copy" target="_blank" rel="noopener"><code>copy.copy()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#copy.deepcopy" target="_blank" rel="noopener"><code>copy.deepcopy()</code></a> 的支持。匹配对象被看作是原子性的。</p>
<h2 id="正则表达式例子"><a href="#正则表达式例子" class="headerlink" title="正则表达式例子"></a>正则表达式例子</h2><h3 id="检查对子"><a href="#检查对子" class="headerlink" title="检查对子"></a>检查对子</h3><p>在这个例子里，我们使用以下辅助函数来更好地显示匹配对象:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def displaymatch(match):</span><br><span class="line">    if match is None:</span><br><span class="line">        return None</span><br><span class="line">    return &apos;&lt;Match: %r, groups=%r&gt;&apos; % (match.group(), match.groups())</span><br></pre></td></tr></table></figure>
<p>假设你在写一个扑克程序，一个玩家的一手牌为五个字符的串，每个字符表示一张牌，”a” 就是 A, “k” K， “q” Q, “j” J, “t” 为 10, “2” 到 “9” 表示2 到 9。</p>
<p>要看给定的字符串是否有效，我们可以按照以下步骤</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>valid = re.compile(<span class="string">r"^[a2-9tjqk]&#123;5&#125;$"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>displaymatch(valid.match(<span class="string">"akt5q"</span>))  <span class="comment"># Valid.</span></span><br><span class="line"><span class="string">"&lt;Match: 'akt5q', groups=()&gt;"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>displaymatch(valid.match(<span class="string">"akt5e"</span>))  <span class="comment"># Invalid.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>displaymatch(valid.match(<span class="string">"akt"</span>))    <span class="comment"># Invalid.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>displaymatch(valid.match(<span class="string">"727ak"</span>))  <span class="comment"># Valid.</span></span><br><span class="line"><span class="string">"&lt;Match: '727ak', groups=()&gt;"</span></span><br></pre></td></tr></table></figure>
<p>最后一手牌，<code>&quot;727ak&quot;</code> ，包含了一个对子，或者两张同样数值的牌。要用正则表达式匹配它，应该使用向后引用如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair = re.compile(<span class="string">r".*(.).*\1"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>displaymatch(pair.match(<span class="string">"717ak"</span>))     <span class="comment"># Pair of 7s.</span></span><br><span class="line"><span class="string">"&lt;Match: '717', groups=('7',)&gt;"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>displaymatch(pair.match(<span class="string">"718ak"</span>))     <span class="comment"># No pairs.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>displaymatch(pair.match(<span class="string">"354aa"</span>))     <span class="comment"># Pair of aces.</span></span><br><span class="line"><span class="string">"&lt;Match: '354aa', groups=('a',)&gt;"</span></span><br></pre></td></tr></table></figure>
<p>要找出对子由什么牌组成，开发者可以按照下面的方式来使用匹配对象的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Match.group" target="_blank" rel="noopener"><code>group()</code></a> 方法:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair = re.compile(<span class="string">r".*(.).*\1"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair.match(<span class="string">"717ak"</span>).group(<span class="number">1</span>)</span><br><span class="line"><span class="string">'7'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Error because re.match() returns None, which doesn't have a group() method:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair.match(<span class="string">"718ak"</span>).group(<span class="number">1</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#23&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    re.match(<span class="string">r".*(.).*\1"</span>, <span class="string">"718ak"</span>).group(<span class="number">1</span>)</span><br><span class="line">AttributeError: <span class="string">'NoneType'</span> object has no attribute <span class="string">'group'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair.match(<span class="string">"354aa"</span>).group(<span class="number">1</span>)</span><br><span class="line"><span class="string">'a'</span></span><br></pre></td></tr></table></figure>
<h3 id="模拟-scanf"><a href="#模拟-scanf" class="headerlink" title="模拟 scanf()"></a>模拟 scanf()</h3><p>Python 目前没有一个类似c函数 <code>scanf()</code> 的替代品。正则表达式通常比 <code>scanf()</code> 格式字符串要更强大一些，但也带来更多复杂性。下面的表格提供了 <code>scanf()</code> 格式符和正则表达式大致相同的映射。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><code>scanf()</code> 格式符</th>
<th style="text-align:left">正则表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>%c</code></td>
<td style="text-align:left"><code>.</code></td>
</tr>
<tr>
<td style="text-align:left"><code>%5c</code></td>
<td style="text-align:left"><code>.{5}</code></td>
</tr>
<tr>
<td style="text-align:left"><code>%d</code></td>
<td style="text-align:left"><code>[-+]?\d+</code></td>
</tr>
<tr>
<td style="text-align:left"><code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%g</code></td>
<td style="text-align:left">`[-+]?(\d+(.\d*)?</td>
<td>.\d+)([eE][-+]?\d+)?`</td>
</tr>
<tr>
<td style="text-align:left"><code>%i</code></td>
<td style="text-align:left">`[-+]?(0[xX][\dA-Fa-f]+</td>
<td>0[0-7]*</td>
<td>\d+)`</td>
</tr>
<tr>
<td style="text-align:left"><code>%o</code></td>
<td style="text-align:left"><code>[-+]?[0-7]+</code></td>
</tr>
<tr>
<td style="text-align:left"><code>%s</code></td>
<td style="text-align:left"><code>\S+</code></td>
</tr>
<tr>
<td style="text-align:left"><code>%u</code></td>
<td style="text-align:left"><code>\d+</code></td>
</tr>
<tr>
<td style="text-align:left"><code>%x</code>, <code>%X</code></td>
<td style="text-align:left"><code>[-+]?(0[xX])?[\dA-Fa-f]+</code></td>
</tr>
</tbody>
</table>
<p>从文件名和数字提取字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/usr/sbin/sendmail - <span class="number">0</span> errors, <span class="number">4</span> warnings</span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>scanf()</code> 格式化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%s - %d errors, %d warnings</span><br></pre></td></tr></table></figure>
<p>等价的正则表达式是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(\S+) - (\d+) errors, (\d+) warnings</span><br></pre></td></tr></table></figure>
<h3 id="search-vs-match"><a href="#search-vs-match" class="headerlink" title="search() vs. match()"></a>search() vs. match()</h3><p>Python 提供了两种不同的操作：基于 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.match" target="_blank" rel="noopener"><code>re.match()</code></a> 检查字符串开头，或者 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>re.search()</code></a> 检查字符串的任意位置（默认Perl中的行为）。</p>
<p>例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">"c"</span>, <span class="string">"abcdef"</span>)    <span class="comment"># No match</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">"c"</span>, <span class="string">"abcdef"</span>)   <span class="comment"># Match</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">2</span>, <span class="number">3</span>), match=<span class="string">'c'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>search()</code></a> 中，可以用 <code>&#39;^&#39;</code> 作为开始来限制匹配到字符串的首位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">"c"</span>, <span class="string">"abcdef"</span>)    <span class="comment"># No match</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">"^c"</span>, <span class="string">"abcdef"</span>)  <span class="comment"># No match</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">"^a"</span>, <span class="string">"abcdef"</span>)  <span class="comment"># Match</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">1</span>), match=<span class="string">'a'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>注意 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.MULTILINE" target="_blank" rel="noopener"><code>MULTILINE</code></a> 多行模式中函数 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.match" target="_blank" rel="noopener"><code>match()</code></a> 只匹配字符串的开始，但使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>search()</code></a> 和以 <code>&#39;^&#39;</code> 开始的正则表达式会匹配每行的开始</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(&apos;X&apos;, &apos;A\nB\nX&apos;, re.MULTILINE)  # No match</span><br><span class="line">&gt;&gt;&gt; re.search(&apos;^X&apos;, &apos;A\nB\nX&apos;, re.MULTILINE)  # Match</span><br><span class="line">&lt;re.Match object; span=(4, 5), match=&apos;X&apos;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="建立一个电话本"><a href="#建立一个电话本" class="headerlink" title="建立一个电话本"></a>建立一个电话本</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.split" target="_blank" rel="noopener"><code>split()</code></a> 将字符串用参数传递的样式分隔开。这个方法对于转换文本数据到易读而且容易修改的数据结构，是很有用的，如下面的例子证明。</p>
<p>首先，这里是输入。 它通常来自一个文件，这里我们使用三重引号字符串语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">"""Ross McFluff: 834.345.1254 155 Elm Street</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>Ronald Heathmore: 892.345.3428 436 Finley Avenue</span></span><br><span class="line"><span class="string"><span class="meta">... </span>Frank Burger: 925.541.7625 662 South Dogwood Way</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>Heather Albrecht: 548.326.4584 919 Park Place"""</span></span><br></pre></td></tr></table></figure>
<p>条目用一个或者多个换行符分开。现在我们将字符串转换为一个列表，每个非空行都有一个条目:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>entries = re.split(<span class="string">"\n+"</span>, text)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>entries</span><br><span class="line">[<span class="string">'Ross McFluff: 834.345.1254 155 Elm Street'</span>,</span><br><span class="line"><span class="string">'Ronald Heathmore: 892.345.3428 436 Finley Avenue'</span>,</span><br><span class="line"><span class="string">'Frank Burger: 925.541.7625 662 South Dogwood Way'</span>,</span><br><span class="line"><span class="string">'Heather Albrecht: 548.326.4584 919 Park Place'</span>]</span><br></pre></td></tr></table></figure>
<p>最终，将每个条目分割为一个由名字、姓氏、电话号码和地址组成的列表。我们为 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.split" target="_blank" rel="noopener"><code>split()</code></a> 使用了 <code>maxsplit</code> 形参，因为地址中包含有被我们作为分割模式的空格符:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[re.split(<span class="string">":? "</span>, entry, <span class="number">3</span>) <span class="keyword">for</span> entry <span class="keyword">in</span> entries]</span><br><span class="line">[[<span class="string">'Ross'</span>, <span class="string">'McFluff'</span>, <span class="string">'834.345.1254'</span>, <span class="string">'155 Elm Street'</span>],</span><br><span class="line">[<span class="string">'Ronald'</span>, <span class="string">'Heathmore'</span>, <span class="string">'892.345.3428'</span>, <span class="string">'436 Finley Avenue'</span>],</span><br><span class="line">[<span class="string">'Frank'</span>, <span class="string">'Burger'</span>, <span class="string">'925.541.7625'</span>, <span class="string">'662 South Dogwood Way'</span>],</span><br><span class="line">[<span class="string">'Heather'</span>, <span class="string">'Albrecht'</span>, <span class="string">'548.326.4584'</span>, <span class="string">'919 Park Place'</span>]]</span><br></pre></td></tr></table></figure>
<p><code>:?</code> 样式匹配姓后面的冒号，因此它不出现在结果列表中。如果 <code>maxsplit</code> 设置为 <code>4</code> ，我们还可以从地址中获取到房间号:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[re.split(<span class="string">":? "</span>, entry, <span class="number">4</span>) <span class="keyword">for</span> entry <span class="keyword">in</span> entries]</span><br><span class="line">[[<span class="string">'Ross'</span>, <span class="string">'McFluff'</span>, <span class="string">'834.345.1254'</span>, <span class="string">'155'</span>, <span class="string">'Elm Street'</span>],</span><br><span class="line">[<span class="string">'Ronald'</span>, <span class="string">'Heathmore'</span>, <span class="string">'892.345.3428'</span>, <span class="string">'436'</span>, <span class="string">'Finley Avenue'</span>],</span><br><span class="line">[<span class="string">'Frank'</span>, <span class="string">'Burger'</span>, <span class="string">'925.541.7625'</span>, <span class="string">'662'</span>, <span class="string">'South Dogwood Way'</span>],</span><br><span class="line">[<span class="string">'Heather'</span>, <span class="string">'Albrecht'</span>, <span class="string">'548.326.4584'</span>, <span class="string">'919'</span>, <span class="string">'Park Place'</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="文字整理"><a href="#文字整理" class="headerlink" title="文字整理"></a>文字整理</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.sub" target="_blank" rel="noopener"><code>sub()</code></a> 替换字符串中出现的样式的每一个实例。这个例子证明了使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.sub" target="_blank" rel="noopener"><code>sub()</code></a> 来整理文字，或者随机化每个字符的位置，除了首位和末尾字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def repl(m):</span><br><span class="line">...     inner_word = list(m.group(2))</span><br><span class="line">...     random.shuffle(inner_word)</span><br><span class="line">...     return m.group(1) + &quot;&quot;.join(inner_word) + m.group(3)</span><br><span class="line">&gt;&gt;&gt; text = &quot;Professor Abdolmalek, please report your absences promptly.&quot;</span><br><span class="line">&gt;&gt;&gt; re.sub(r&quot;(\w)(\w+)(\w)&quot;, repl, text)</span><br><span class="line">&apos;Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.&apos;</span><br><span class="line">&gt;&gt;&gt; re.sub(r&quot;(\w)(\w+)(\w)&quot;, repl, text)</span><br><span class="line">&apos;Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.&apos;</span><br></pre></td></tr></table></figure>
<h3 id="找到所有副词"><a href="#找到所有副词" class="headerlink" title="找到所有副词"></a>找到所有副词</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.findall" target="_blank" rel="noopener"><code>findall()</code></a> 匹配样式 <em>所有</em> 的出现，不仅是像 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>search()</code></a> 中的第一个匹配。比如，如果一个作者希望找到文字中的所有副词，他可能会按照以下方法用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.findall" target="_blank" rel="noopener"><code>findall()</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; text = &quot;He was carefully disguised but captured quickly by police.&quot;</span><br><span class="line">&gt;&gt;&gt; re.findall(r&quot;\w+ly&quot;, text)</span><br><span class="line">[&apos;carefully&apos;, &apos;quickly&apos;]</span><br></pre></td></tr></table></figure>
<h3 id="找到所有副词和位置"><a href="#找到所有副词和位置" class="headerlink" title="找到所有副词和位置"></a>找到所有副词和位置</h3><p>如果需要匹配样式的更多信息， <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.finditer" target="_blank" rel="noopener"><code>finditer()</code></a> 可以起到作用，它提供了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a> 作为返回值，而不是字符串。继续上面的例子，如果一个作者希望找到所有副词和它的位置，可以按照下面方法使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.finditer" target="_blank" rel="noopener"><code>finditer()</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; text = &quot;He was carefully disguised but captured quickly by police.&quot;</span><br><span class="line">&gt;&gt;&gt; for m in re.finditer(r&quot;\w+ly&quot;, text):</span><br><span class="line">...     print(&apos;%02d-%02d: %s&apos; % (m.start(), m.end(), m.group(0)))</span><br><span class="line">07-16: carefully</span><br><span class="line">40-47: quickly</span><br></pre></td></tr></table></figure>
<h3 id="原始字符记法"><a href="#原始字符记法" class="headerlink" title="原始字符记法"></a>原始字符记法</h3><p>原始字符串记法 (<code>r&quot;text&quot;</code>) 保持正则表达式正常。否则，每个正则式里的反斜杠(<code>&#39;\&#39;</code>) 都必须前缀一个反斜杠来转义。比如，下面两行代码功能就是完全一致的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&quot;\W(.)\1\W&quot;, &quot; ff &quot;)</span><br><span class="line">&lt;re.Match object; span=(0, 4), match=&apos; ff &apos;&gt;</span><br><span class="line">&gt;&gt;&gt; re.match(&quot;\\W(.)\\1\\W&quot;, &quot; ff &quot;)</span><br><span class="line">&lt;re.Match object; span=(0, 4), match=&apos; ff &apos;&gt;</span><br></pre></td></tr></table></figure>
<p>当需要匹配一个字符反斜杠，它必须在正则表达式中转义。在原始字符串记法，就是 <code>r&quot;\\&quot;</code>。否则就必须用 <code>&quot;\\\\&quot;</code>，来表示同样的意思</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&quot;\\&quot;, r&quot;\\&quot;)</span><br><span class="line">&lt;re.Match object; span=(0, 1), match=&apos;\\&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; re.match(&quot;\\\\&quot;, r&quot;\\&quot;)</span><br><span class="line">&lt;re.Match object; span=(0, 1), match=&apos;\\&apos;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="写一个词法分析器"><a href="#写一个词法分析器" class="headerlink" title="写一个词法分析器"></a>写一个词法分析器</h3><p>一个 <a href="https://en.wikipedia.org/wiki/Lexical_analysis" target="_blank" rel="noopener">词法器或词法分析器</a> 分析字符串，并分类成目录组。 这是写一个编译器或解释器的第一步。</p>
<p>文字目录是由正则表达式指定的。这个技术是通过将这些样式合并为一个主正则式，并且循环匹配来实现的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">Token = collections.namedtuple(<span class="string">'Token'</span>, [<span class="string">'type'</span>, <span class="string">'value'</span>, <span class="string">'line'</span>, <span class="string">'column'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tokenize</span><span class="params">(code)</span>:</span></span><br><span class="line">    keywords = &#123;<span class="string">'IF'</span>, <span class="string">'THEN'</span>, <span class="string">'ENDIF'</span>, <span class="string">'FOR'</span>, <span class="string">'NEXT'</span>, <span class="string">'GOSUB'</span>, <span class="string">'RETURN'</span>&#125;</span><br><span class="line">    token_specification = [</span><br><span class="line">        (<span class="string">'NUMBER'</span>,   <span class="string">r'\d+(\.\d*)?'</span>),  <span class="comment"># Integer or decimal number</span></span><br><span class="line">        (<span class="string">'ASSIGN'</span>,   <span class="string">r':='</span>),           <span class="comment"># Assignment operator</span></span><br><span class="line">        (<span class="string">'END'</span>,      <span class="string">r';'</span>),            <span class="comment"># Statement terminator</span></span><br><span class="line">        (<span class="string">'ID'</span>,       <span class="string">r'[A-Za-z]+'</span>),    <span class="comment"># Identifiers</span></span><br><span class="line">        (<span class="string">'OP'</span>,       <span class="string">r'[+\-*/]'</span>),      <span class="comment"># Arithmetic operators</span></span><br><span class="line">        (<span class="string">'NEWLINE'</span>,  <span class="string">r'\n'</span>),           <span class="comment"># Line endings</span></span><br><span class="line">        (<span class="string">'SKIP'</span>,     <span class="string">r'[ \t]+'</span>),       <span class="comment"># Skip over spaces and tabs</span></span><br><span class="line">        (<span class="string">'MISMATCH'</span>, <span class="string">r'.'</span>),            <span class="comment"># Any other character</span></span><br><span class="line">    ]</span><br><span class="line">    tok_regex = <span class="string">'|'</span>.join(<span class="string">'(?P&lt;%s&gt;%s)'</span> % pair <span class="keyword">for</span> pair <span class="keyword">in</span> token_specification)</span><br><span class="line">    line_num = <span class="number">1</span></span><br><span class="line">    line_start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> mo <span class="keyword">in</span> re.finditer(tok_regex, code):</span><br><span class="line">        kind = mo.lastgroup</span><br><span class="line">        value = mo.group()</span><br><span class="line">        column = mo.start() - line_start</span><br><span class="line">        <span class="keyword">if</span> kind == <span class="string">'NUMBER'</span>:</span><br><span class="line">            value = float(value) <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">in</span> value <span class="keyword">else</span> int(value)</span><br><span class="line">        <span class="keyword">elif</span> kind == <span class="string">'ID'</span> <span class="keyword">and</span> value <span class="keyword">in</span> keywords:</span><br><span class="line">            kind = value</span><br><span class="line">        <span class="keyword">elif</span> kind == <span class="string">'NEWLINE'</span>:</span><br><span class="line">            line_start = mo.end()</span><br><span class="line">            line_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> kind == <span class="string">'SKIP'</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> kind == <span class="string">'MISMATCH'</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">f'<span class="subst">&#123;value!r&#125;</span> unexpected on line <span class="subst">&#123;line_num&#125;</span>'</span>)</span><br><span class="line">        <span class="keyword">yield</span> Token(kind, value, line_num, column)</span><br><span class="line"></span><br><span class="line">statements = <span class="string">'''</span></span><br><span class="line"><span class="string">    IF quantity THEN</span></span><br><span class="line"><span class="string">        total := total + price * quantity;</span></span><br><span class="line"><span class="string">        tax := price * 0.05;</span></span><br><span class="line"><span class="string">    ENDIF;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> tokenize(statements):</span><br><span class="line">    print(token)</span><br></pre></td></tr></table></figure>
<p>这个词法器产生以下输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Token(type=<span class="string">'IF'</span>, value=<span class="string">'IF'</span>, line=<span class="number">2</span>, column=<span class="number">4</span>)</span><br><span class="line">Token(type=<span class="string">'ID'</span>, value=<span class="string">'quantity'</span>, line=<span class="number">2</span>, column=<span class="number">7</span>)</span><br><span class="line">Token(type=<span class="string">'THEN'</span>, value=<span class="string">'THEN'</span>, line=<span class="number">2</span>, column=<span class="number">16</span>)</span><br><span class="line">Token(type=<span class="string">'ID'</span>, value=<span class="string">'total'</span>, line=<span class="number">3</span>, column=<span class="number">8</span>)</span><br><span class="line">Token(type=<span class="string">'ASSIGN'</span>, value=<span class="string">':='</span>, line=<span class="number">3</span>, column=<span class="number">14</span>)</span><br><span class="line">Token(type=<span class="string">'ID'</span>, value=<span class="string">'total'</span>, line=<span class="number">3</span>, column=<span class="number">17</span>)</span><br><span class="line">Token(type=<span class="string">'OP'</span>, value=<span class="string">'+'</span>, line=<span class="number">3</span>, column=<span class="number">23</span>)</span><br><span class="line">Token(type=<span class="string">'ID'</span>, value=<span class="string">'price'</span>, line=<span class="number">3</span>, column=<span class="number">25</span>)</span><br><span class="line">Token(type=<span class="string">'OP'</span>, value=<span class="string">'*'</span>, line=<span class="number">3</span>, column=<span class="number">31</span>)</span><br><span class="line">Token(type=<span class="string">'ID'</span>, value=<span class="string">'quantity'</span>, line=<span class="number">3</span>, column=<span class="number">33</span>)</span><br><span class="line">Token(type=<span class="string">'END'</span>, value=<span class="string">';'</span>, line=<span class="number">3</span>, column=<span class="number">41</span>)</span><br><span class="line">Token(type=<span class="string">'ID'</span>, value=<span class="string">'tax'</span>, line=<span class="number">4</span>, column=<span class="number">8</span>)</span><br><span class="line">Token(type=<span class="string">'ASSIGN'</span>, value=<span class="string">':='</span>, line=<span class="number">4</span>, column=<span class="number">12</span>)</span><br><span class="line">Token(type=<span class="string">'ID'</span>, value=<span class="string">'price'</span>, line=<span class="number">4</span>, column=<span class="number">15</span>)</span><br><span class="line">Token(type=<span class="string">'OP'</span>, value=<span class="string">'*'</span>, line=<span class="number">4</span>, column=<span class="number">21</span>)</span><br><span class="line">Token(type=<span class="string">'NUMBER'</span>, value=<span class="number">0.05</span>, line=<span class="number">4</span>, column=<span class="number">23</span>)</span><br><span class="line">Token(type=<span class="string">'END'</span>, value=<span class="string">';'</span>, line=<span class="number">4</span>, column=<span class="number">27</span>)</span><br><span class="line">Token(type=<span class="string">'ENDIF'</span>, value=<span class="string">'ENDIF'</span>, line=<span class="number">5</span>, column=<span class="number">4</span>)</span><br><span class="line">Token(type=<span class="string">'END'</span>, value=<span class="string">';'</span>, line=<span class="number">5</span>, column=<span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/re.html#id1" target="_blank" rel="noopener">Frie09</a></p>
<p>Friedl, Jeffrey. Mastering Regular Expressions. 第三版, O’Reilly Media, 2009. 第三版不再使用Python, 但第一版提供了编写正则表达式的良好细节。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>esp32 micropython 03 webrepl</title>
    <url>/2020/03/27/esp32-micropython-03-webrepl/</url>
    <content><![CDATA[<h1 id="esp32-micropython-之旅-03-webrepl"><a href="#esp32-micropython-之旅-03-webrepl" class="headerlink" title="esp32  micropython 之旅 03 webrepl"></a>esp32  micropython 之旅 03 webrepl</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200327_dianlu.jpg?raw=true" alt></p>
<a id="more"></a>
<h2 id="使用network模块连接WIFI"><a href="#使用network模块连接WIFI" class="headerlink" title="使用network模块连接WIFI"></a>使用network模块连接WIFI</h2><p><code>network</code>模块是和网络相关的模块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> network <span class="comment"># 导入network模块</span></span><br><span class="line">wifi = network.WLAN(network.STA_IF)  <span class="comment"># 设置为STA_IF模式，即接入wifi路由器的模式AP_IF为作为热点</span></span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200327_wifi.png?raw=true" alt></p>
<p>接下来我们需要激活wifi，并进行连接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wifi.active(<span class="literal">True</span>) <span class="comment"># 将wifi激活</span></span><br><span class="line">wifi.connect(<span class="string">'&lt;essid&gt;'</span>,<span class="string">'&lt;password&gt;'</span>) <span class="comment">#连接至wifi</span></span><br></pre></td></tr></table></figure>
<h3 id="查看wifi连接状态"><a href="#查看wifi连接状态" class="headerlink" title="查看wifi连接状态"></a>查看wifi连接状态</h3><p>使用<code>ifconfig</code>查看网络状态：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wifi.ifconfig()</span><br></pre></td></tr></table></figure>
<h2 id="WebREPL"><a href="#WebREPL" class="headerlink" title="WebREPL"></a>WebREPL</h2><p>WebREPL是一个使用Web前端技术栈构建的单页应用。</p>
<p><strong>WebREPL允许你通过WiFi使用MicroPython的REPL，通过浏览器连接，使用了WebSockt通信协议</strong>。</p>
<p>在MicroPython的网站上托管了WebREPL的单页应用，点击如下链接即可访问：</p>
<p><a href="http://micropython.org/webrepl" target="_blank" rel="noopener">http://micropython.org/webrepl</a></p>
<p>两个步骤</p>
<ul>
<li>初始化WebREPL</li>
<li>开启WebREPL</li>
</ul>
<h3 id="初始化WebREPL"><a href="#初始化WebREPL" class="headerlink" title="初始化WebREPL"></a>初始化WebREPL</h3><p>初次使用WebREPL，我们先要使用<code>webrepl_setup</code>模块来进行初始化设置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> webrepl_setup</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200327_repl_confirm_password.png?raw=true" alt></p>
<p>当你看到亲切的<code>&gt;&gt;&gt;</code>提示符时，则表明你已成功的连接到了WebREPL</p>
<h3 id="开启WebREPL"><a href="#开启WebREPL" class="headerlink" title="开启WebREPL"></a>开启WebREPL</h3><p>接下来，我们直接开启webrepl的服务:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> webrepl</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>webrepl.start()</span><br></pre></td></tr></table></figure>
<p>如上两句指令执行后，如下图所示：</p>
<h3 id="连接WebREPL"><a href="#连接WebREPL" class="headerlink" title="连接WebREPL"></a>连接WebREPL</h3><p>访问<a href="http://micropython.org/webrepl" target="_blank" rel="noopener">http://micropython.org/webrepl</a></p>
<p>输入正确的URL,然后点击Connet按钮</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200327_repl_connection_success.png?raw=true" alt></p>
<h3 id="试试WebREPL"><a href="#试试WebREPL" class="headerlink" title="试试WebREPL"></a>试试WebREPL</h3><p>现在，你可以在这个Web页面上欢快的玩耍了。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>micropython</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>esp32</tag>
        <tag>micorpython</tag>
        <tag>webrepl</tag>
      </tags>
  </entry>
  <entry>
    <title>esp32 micropython using uPycraft IDE</title>
    <url>/2020/03/24/esp32-micropython-using-uPyCraft/</url>
    <content><![CDATA[<h1 id="esp32-micropython-之旅-02-使用uPycraft-IDE"><a href="#esp32-micropython-之旅-02-使用uPycraft-IDE" class="headerlink" title="esp32 micropython 之旅 02 使用uPycraft IDE"></a>esp32 micropython 之旅 02 使用uPycraft IDE</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326getting-started-esp32.jpg?raw=true" alt></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次使用命令方式推送代码烧录到固件,今天介绍下micropython的几个著名的IDE。</p>
<h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><ul>
<li>Thonny IDE </li>
<li>uPyCraft IDE.</li>
</ul>
<h3 id="使用uPyCraft"><a href="#使用uPyCraft" class="headerlink" title="使用uPyCraft"></a>使用<strong>uPyCraft</strong></h3><h4 id="Step-1-点击这个链接下载uPyCraft-的-exe文件"><a href="#Step-1-点击这个链接下载uPyCraft-的-exe文件" class="headerlink" title="Step 1.  点击这个链接下载uPyCraft 的.exe文件"></a><strong>Step 1.</strong>  点击这个<a href="https://github.com/DFRobot/uPyCraft" target="_blank" rel="noopener">链接</a>下载<strong>uPyCraft</strong> 的.exe文件</h4><h4 id="Step-2-双击安装包-打开安装后偶uPyCraft-可能是这个样子"><a href="#Step-2-双击安装包-打开安装后偶uPyCraft-可能是这个样子" class="headerlink" title="Step 2.   双击安装包,打开安装后偶uPyCraft 可能是这个样子"></a><strong>Step 2.</strong>   双击安装包,打开安装后偶uPyCraft 可能是这个样子</h4><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326-Installing-uPyCraft-IDE-on-Windows-to-Program-ESP32.png?raw=true" alt></p>
<h4 id="uPyCraft-核心组件"><a href="#uPyCraft-核心组件" class="headerlink" title="uPyCraft 核心组件"></a>uPyCraft 核心组件</h4><h5 id="1-Folder-and-Files"><a href="#1-Folder-and-Files" class="headerlink" title="1. Folder and Files"></a>1. Folder and Files</h5><ul>
<li><p>Device ：设备 是esp32还是esp8266 还是microbit</p>
</li>
<li><p>SD : 包含文件存储的 SD 卡。很多不开发版都支持SD </p>
</li>
<li><p>uPy_lib:  包含micropython 内置模块</p>
</li>
<li><p>workSpace : 将保结果存到本地</p>
</li>
</ul>
<h5 id="2-Editor-：编写python代码。"><a href="#2-Editor-：编写python代码。" class="headerlink" title="2. Editor ：编写python代码。"></a>2. Editor ：编写python代码。</h5><p><strong>3. Shell/Terminal:</strong>  终端</p>
<h5 id="4-Tools-创建新文件，保存和上传文件到开发板上，关闭连接等功能。"><a href="#4-Tools-创建新文件，保存和上传文件到开发板上，关闭连接等功能。" class="headerlink" title="4. Tools:   创建新文件，保存和上传文件到开发板上，关闭连接等功能。"></a><strong>4. Tools:</strong>   创建新文件，保存和上传文件到开发板上，关闭连接等功能。</h5><h3 id="开始烧录最新的-esp32-micropython-固件"><a href="#开始烧录最新的-esp32-micropython-固件" class="headerlink" title="开始烧录最新的 esp32 micropython 固件"></a>开始烧录最新的 esp32 micropython 固件</h3><p>首先,从<a href="https://micropython.org/download#esp32" target="_blank" rel="noopener">这个</a>站点,下载最新的esp32 micropython固件</p>
<p><strong>Step 2.</strong>,打开 <strong>uPyCraft</strong> ，点击 <strong>*Tools-&gt; Serial**</strong> 选择映射端口. </p>
<p>  <img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326Flashing-MicroPython-Firmware-on-ESP32-Board.png?raw=true" alt></p>
<p> <strong>Step 2.</strong> 选择<strong>*Tools-&gt;board*</strong>.这里我们选择esp32</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326-using-uPyCrfaft-burn-micropython.png?raw=true" alt></p>
<p> <strong>Step 3.</strong> 开始烧录</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326Flashing-MicroPython-Firmware-on-ESP32.png?raw=true" alt></p>
<h3 id="使用-uPyCraft-IDE-上传代码到esp32"><a href="#使用-uPyCraft-IDE-上传代码到esp32" class="headerlink" title="使用  uPyCraft IDE 上传代码到esp32"></a>使用  <strong>uPyCraft IDE</strong> 上传代码到esp32</h3><p><strong>Step 1.</strong> 打开 uPyCraft IDE 和 <strong>Tools-&gt;boards</strong>，选择你的主板</p>
<p><strong>Step 2.</strong> 直接点击 <strong><em>tools-&gt; Serial\</em></strong> 选择COM口.</p>
<p><strong>Step 3.</strong> 点击Connect 连接IDE和esp主板</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326Uploading-the-Code%20into-ESP32.png?raw=true" alt></p>
<p> <strong>Step 4.</strong> 如果连接正常,则下面的终端区会显示  <strong>&gt;&gt;&gt;</strong> 符号,此时可以执行micropython的命令。</p>
<p>  <strong>Step 5.</strong>现在点击iNew File,并保存到本地。</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326Programming-and-uploading-the-code-into-ESP32-using-uPyCraft-IDE.png?raw=true" alt></p>
<p><strong>Step 6.</strong> 点击新创建的文件,开始编写小灯程序的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line">led = Pin(<span class="number">2</span>, Pin.OUT)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    led.value(<span class="keyword">not</span> led.value())</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>​    </p>
<p> <strong>Step 7.</strong> 点击 <strong><em>Download and run\</em></strong> 按钮</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326uPyCraft-IDE-blink-script-to-board.png?raw=true" alt></p>
<p> <strong>Step 8.</strong> 重新测试代码是否正确,点击 <strong><em>En/Reset\</em></strong> 按钮。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>不知道什么原因,win7操作系统 uPycraft 就是识别不了 我的板子,换成win10 一次性搞定。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>micropython</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>micropython</tag>
        <tag>esp32</tag>
        <tag>uPycraft</tag>
      </tags>
  </entry>
  <entry>
    <title>Still a teenager</title>
    <url>/2020/04/05/Still-a-teenager/</url>
    <content><![CDATA[<h1 id="归来仍是少年"><a href="#归来仍是少年" class="headerlink" title="归来仍是少年"></a>归来仍是少年</h1><p><img src="http://a3.att.hudong.com/36/19/01300000660677127669194340150.jpg" alt></p>
<a id="more"></a>
<p>很久没有更新博客了,一来是需要自己整理下思路,二来是自己也要学习,不想因为这样降低博客的质量。<br>坚持了70多天中断了,感觉有点可惜，但是想来也对自己有个交代。</p>
<p>停下也是为了更好的往下走。</p>
<p>一年前的今天,我父亲还健在。</p>
<p>清明时节雨纷纷的季节，一年前的事情仍旧历历在目。</p>
<p>阴历三月初一是父亲的生日,寻思给父亲过个生日,3月底才出的院。父亲明显感觉比以前气色差了很多。</p>
<p>老人有讲究,不到80大寿,不宜大操大办。因此我给父亲订了蛋糕,俺娘准备了父亲喜欢吃的蚬子长寿面,就一家人简简单单过了一个生日。</p>
<p>父亲的那天胃口格外的好，吃了两大碗面条。我和母亲对视了一眼,心里感觉好了一点。</p>
<p>席间和闺女还做起了游戏,闺女想骑大马,但是考虑到父亲身体还很虚弱,就让媳妇领到一边去玩。</p>
<p>去厨房刷碗,母亲小声告诉我。你爸好几天都难受的睡不着觉了。我心里咯噔一下,只能提醒母亲注意,随时给我打电话。</p>
<p>聊起了很多小时候的事。</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200405_father_and_mother.jpg?raw=true" alt></p>
<p>印象中爸爸年轻时候喜欢各种运动,足篮排乒乓没有不会的,会吹笛子,会画画,照片看是个俊美的男子。</p>
<p>后来遇到了母亲,有了我和姐姐,足球也踢不动了,担任了厂队的领队,那段风风火火的日子,我经常去球场看球。</p>
<p>想起下雨天,我在水坑打闹,弄得一身白衣服变成了灰色,父亲回家用毛巾狠狠抽了我。</p>
<p>其实抽完,父亲就觉得后悔,谁都有调皮的时候。</p>
<p>回到大连,房子正在装修,我接到一个女同学电话。我父亲问起来,大学有没有要好的女同学,有合适的可以处处看。我那时候还是懵懂的年纪,只知道傻乎乎的笑。</p>
<p>年龄越来越大了,父亲表面没说什么,其实心里着实着急。</p>
<p>我也装傻充愣,在以找对象名义,又玩了好几年。</p>
<p>终于婚了,父亲拉着我媳妇的手,就说一句话,好好过啊,有啥需要就找我们。我偷偷看到,老爷子眼角有了泪花。</p>
<p>婚房房子装修的日子,爸妈全程建工,登梯子爬高,为了一个门帘从金三角老两口硬是走了回来。我姐夫调侃说,看出来了,这是儿啊。</p>
<p>老爷子私下问我,啥时候准备要孩子啊。我说不着急,反问俺爸: 您着急了。俺爸说,能不着急吗,我和你妈都多大年纪了,趁腿脚好,还能帮你带带。</p>
<p>孩子啼哭的那一刻,我突然意识到这个小生命的诞生,让我从一个黄花少年,也当了爹。</p>
<p>媳妇怀孕期间一直反应很大,从开始怀孕一直吐到产床。父亲一直担心,孩子会有影响。</p>
<p>当护士把孩子报过来的时候,老爷子乐的合不拢嘴,一个劲的念叨,挺好挺好。</p>
<p>因为母亲过来带孩子,忽视了父亲的身体,老爷子自己不想给我们添麻烦,终于2016年的冬天,老爷子突然因病入院。</p>
<p>进手术室前,父亲就说了一句话,我还想活着看孙女上小学呢！期间母亲一直在哭,我们只能祈祷手术能成功。</p>
<p>事后,主治医生说,这个手术风险很高,正常人基本上下不了手术台,更何况我父亲有20年的糖尿病,并发症一来,谁也没招。正常40分钟的手术做了2个半小时,老爷子硬是挺了过来。</p>
<p>不到一个月的时间,又因为大面积静脉渗血导致心肌炎,又一次去了手术室……..</p>
<p>我急急忙忙跑去医院,看到俺爸浑身插着十几个管子的时候,我控制不住自己,眼泪止不住流。</p>
<p>老爷子慢慢恢复了过来,看着他那神采奕奕的眼睛慢慢失去了光,我意识到,这场病对于俺爸意味着什么。</p>
<p>2017年十月一,我记得很清楚,我开车领着俺爸去看了东港的喷泉。老爷子走路都费劲了,不到200米的路,歇了十几趟。我搀扶着父亲,手上就剩下骨头了。我扭过头,强忍着泪水。那是父亲最后一次出远门。</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200405_father.jpg?raw=true" alt></p>
<p>2018年春节,家人都聚在一起,那时父亲的头发已经全白了。</p>
<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200405_father_and_famliy.jpg?raw=true" alt></p>
<p>19年,刚过完春节,父亲觉得心脏不舒服,就去住院了。凌晨2点,我给父亲送去医院住院。没来得及告诉俺姐。等到住院手续办理完。我才给俺姐打电话,谁知道俺姐也来同一个医院住院了。老爷子一听到俺姐也住院了,眼泪就流下来了,那时候还没有床位,就一个劲念叨,我要等着俺老闺女来。俺姐来了,父亲就抱着俺姐哭了起来。</p>
<p>晚上需要有人陪护,怕我睡不好,故意说我打呼噜影响他睡眠,就让我回家睡。</p>
<p>医生也把我们家属叫到一起,详细说明了父亲现在的病情,距离上次手术过去了三年,现在最重要的不是糖尿病,也不是静脉栓塞,而是心脏。老爷子现在的身体已经不能再做手术了。建议回家静养。我们听了感觉心里很难受。不停追问医生还有没有更好的办法。医生虽然没明着说没有,其实也间接说明病情已经很严重了。</p>
<p>父亲是一个很聪明的人,从医生的只言片语里也清楚自己时日无多。</p>
<p>3月底了,有一天我去医院陪护,父亲拉着我的手说,去走廊溜达溜达。他背靠在护士站的台子前,和我说了一段意味深长的话，他说,我知道我现在心脏是大问题,一旦出问题,3分钟人就没了,我的银行卡都在你妈那,房子你和你姐一人一半,房产证都在你妈那,有事找你妈。我以为父亲是开玩笑,说道,咋的,你这是交代后事啊。父亲突然严肃了起来,说,对,就是交代下。我心里一沉。</p>
<p>4月7号,我正好陪孩子去上英语课,突然接到了母亲的电话,快来,你爸不行了。</p>
<p>当我打车冲过去的时候,父亲已经永远离开了我们。120又急救了将近20分钟,脉搏一直都是一条直线。领队说,老爷子心脏病突发,走了,没遭罪，子女看看是否还需要送医院,否则就在死亡确认书上签字吧。听到这个的时候,我整个大脑都一片空白了。</p>
<p>姐夫赶紧联系了殡葬的人,过了不到十分钟，办事的人说,来孝子来给老爷子净身。我用毛巾给父亲擦脸,感受到父亲的温度。我到现在都不相信,父亲永远的离开了我们。就像睡着了一样。</p>
<p>我实在写不下去了……..</p>
<p>想想对父亲的承诺,说出了院,还能带着父亲去趟澡堂子,这辈子再也不可能实现了。</p>
<p>归来还是少年吗？体会到为人父,为人夫的责任,你就不会再是孩子了。</p>
<p>如今一周年了,我只想对我父亲说,<strong>儿子想你了,你还能回来不？</strong></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>using selenium execute JavaScript controll browser scroll</title>
    <url>/2020/04/10/using-selenium-execute-JavaScript-controll-browser-scroll/</url>
    <content><![CDATA[<h1 id="selenium中使用JavaScript控制浏览器"><a href="#selenium中使用JavaScript控制浏览器" class="headerlink" title="selenium中使用JavaScript控制浏览器"></a>selenium中使用JavaScript控制浏览器</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//移动到元素element对象的“顶端”与当前窗口的“顶部”对齐</span></span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"arguments[0].scrollIntoView();"</span>, element);</span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"arguments[0].scrollIntoView(true);"</span>, element);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//移动到元素element对象的“底端”与当前窗口的“底部”对齐</span></span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"arguments[0].scrollIntoView(false);"</span>, element);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//移动到页面最底部</span></span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"window.scrollTo(0, document.body.scrollHeight)"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//移动到指定的坐标(相对当前的坐标移动)</span></span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"window.scrollBy(0, 700)"</span>);</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//结合上面的scrollBy语句，相当于移动到700+800=1600像素位置</span></span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"window.scrollBy(0, 800)"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//移动到窗口绝对位置坐标，如下移动到纵坐标1600像素位置</span></span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"window.scrollTo(0, 1600)"</span>);</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//结合上面的scrollTo语句，仍然移动到纵坐标1200像素位置</span></span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"window.scrollTo(0, 1200)"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>selenium</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>selenium</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title>from beginning to setup a typescript develop environment</title>
    <url>/2020/04/13/from-beginning-to-setup-a-typescript-develop-environment/</url>
    <content><![CDATA[<h1 id="从零开始搭建typescript开发环境"><a href="#从零开始搭建typescript开发环境" class="headerlink" title="从零开始搭建typescript开发环境"></a>从零开始搭建typescript开发环境</h1><p><img src="https://pic3.zhimg.com/v2-7ae2e2942fa8ae187a24cae8afe9547e_1200x500.jpg" alt></p>
<a id="more"></a>
<h2 id="【背景】"><a href="#【背景】" class="headerlink" title="【背景】"></a>【背景】</h2><p>从零开始搭建一个typescript项目中使用了lite-server 模块,备忘一下</p>
<h2 id="【解决方案】"><a href="#【解决方案】" class="headerlink" title="【解决方案】"></a>【解决方案】</h2><h3 id="项目下-创建一个-bs-config-json文件"><a href="#项目下-创建一个-bs-config-json文件" class="headerlink" title="项目下 创建一个 bs-config.json文件"></a>项目下 创建一个 <code>bs-config.json</code>文件</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"port"</span> : <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">"files"</span>: [<span class="string">"../dist/**/*.&#123;html,htm,css,js&#125;"</span>],</span><br><span class="line">    <span class="attr">"server"</span>: &#123;<span class="attr">"baseDir"</span> : <span class="string">"./dist"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>port 参数指定端口</li>
<li>files 指定包含的文件类型</li>
<li>server 中 baseDir参数指定 静态文件所在目录,根据自己项目目录结构调整</li>
</ul>
<h3 id="添加-lite-server-到-package-json-的-script"><a href="#添加-lite-server-到-package-json-的-script" class="headerlink" title="添加 lite-server 到 package.json 的 script"></a>添加 lite-server 到 package.json 的 script</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "lite-server",</span><br><span class="line">    "tsc-build": "tsc -w",</span><br><span class="line">    "tsc-watch": "nodemon dist/hello.js"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<h3 id="命令行运行"><a href="#命令行运行" class="headerlink" title="命令行运行"></a>命令行运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>
<h2 id="【参考文档】"><a href="#【参考文档】" class="headerlink" title="【参考文档】"></a>【参考文档】</h2><p><a href="https://github.com/johnpapa/lite-server" target="_blank" rel="noopener">lite-server官方github</a></p>
]]></content>
      <categories>
        <category>typescript</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>lite-server</tag>
      </tags>
  </entry>
  <entry>
    <title>make django3.1 backend markdown support</title>
    <url>/2020/09/14/make_django3.1_backend_markdown_support/</url>
    <content><![CDATA[<h1 id="django3-1-后台添加markdown支持"><a href="#django3-1-后台添加markdown支持" class="headerlink" title="django3.1 后台添加markdown支持"></a>django3.1 后台添加markdown支持</h1><p><img src="https://media.vanityfair.com/photos/54caaa85b8f23e3a0314d5ae/master/w_768,c_limit/image.png" alt></p>
<a id="more"></a>
<h2 id="首先安装-django-mdeditor"><a href="#首先安装-django-mdeditor" class="headerlink" title="首先安装 django-mdeditor"></a>首先安装 <code>django-mdeditor</code></h2><p><code>python pip install django-mdeditor</code></p>
<h2 id="settings-py-中添加"><a href="#settings-py-中添加" class="headerlink" title="settings.py 中添加"></a>settings.py 中添加</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="string">'blog'</span>,</span><br><span class="line">    <span class="string">'mdeditor'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment"># add uploads文件夹</span></span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">'uploads'</span>)  <span class="comment">#uploads必须存在，且在项目目录下</span></span><br><span class="line">MEDIA_URL = <span class="string">'/media/'</span></span><br></pre></td></tr></table></figure>
<h2 id="添加站点路由-mysite-urls-py"><a href="#添加站点路由-mysite-urls-py" class="headerlink" title="添加站点路由 mysite/urls.py"></a>添加站点路由 <code>mysite/urls.py</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"><span class="keyword">from</span> django.conf.urls.static <span class="keyword">import</span>  static</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'blog/'</span>, include((<span class="string">'blog.urls'</span>,<span class="string">'blog'</span>),namespace=<span class="string">'blog'</span>)),</span><br><span class="line">    path(<span class="string">'mdeditor/'</span>,include(<span class="string">'mdeditor.urls'</span>)),</span><br><span class="line">]</span><br><span class="line"><span class="keyword">if</span> settings.DEBUG:</span><br><span class="line">    <span class="comment"># static files (images, css, javascript, etc.)</span></span><br><span class="line">    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</span><br></pre></td></tr></table></figure>
<h2 id="修改blog下models-py中内容类型"><a href="#修改blog下models-py中内容类型" class="headerlink" title="修改blog下models.py中内容类型"></a>修改blog下<code>models.py</code>中内容类型</h2><p><code>导入MDTextField</code><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> mdeditor.fields <span class="keyword">import</span> MDTextField</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogPost</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length= <span class="number">150</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># body = models.TextField()</span></span><br><span class="line">    body = MDTextField()</span><br><span class="line"></span><br><span class="line">    create_time = models.DateTimeField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"&lt;BlogPost <span class="subst">&#123;self.title&#125;</span>&gt;"</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name =<span class="string">"文章"</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure></p>
<h2 id="blog应用views-py"><a href="#blog应用views-py" class="headerlink" title="blog应用views.py"></a>blog应用views.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">details</span><span class="params">(request, blog_id)</span>:</span></span><br><span class="line">    blog = get_object_or_404 (BlogPost, pk=blog_id)</span><br><span class="line">    blog.body = markdown(blog.body, extensions=[</span><br><span class="line">        <span class="comment"># 包含 缩写、表格等常用扩展</span></span><br><span class="line">        <span class="string">'markdown.extensions.extra'</span>,</span><br><span class="line">        <span class="comment"># 语法高亮扩展</span></span><br><span class="line">        <span class="string">'markdown.extensions.codehilite'</span>,</span><br><span class="line">        <span class="comment">#允许我们自动生成目录</span></span><br><span class="line">         <span class="string">'markdown.extensions.toc'</span>,</span><br><span class="line">        ])</span><br><span class="line">    <span class="keyword">return</span> render (request, <span class="string">'blog_detail.html'</span>, &#123;<span class="string">'blog'</span>: blog&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="前台页面添加markdown-css支持"><a href="#前台页面添加markdown-css支持" class="headerlink" title="前台页面添加markdown css支持"></a>前台页面添加markdown css支持</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.bootcss.com/github-markdown-css/3.0.1/github-markdown.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="前台页面添加-safe渲染"><a href="#前台页面添加-safe渲染" class="headerlink" title="前台页面添加 safe渲染"></a>前台页面添加 safe渲染</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; blog.title &#125;&#125;</span><br><span class="line">&#123;&#123; blog.body | safe &#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重新启动服务"><a href="#重新启动服务" class="headerlink" title="重新启动服务"></a>重新启动服务</h2><p><code>python manage.py runserver 127.0.0.1:8000</code></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Farewell, 2020</title>
    <url>/2020/12/26/Farewell-2020/</url>
    <content><![CDATA[<h1 id="Farewell-2020"><a href="#Farewell-2020" class="headerlink" title="Farewell, 2020"></a>Farewell, 2020</h1><p><img src="https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/7acb0a46f21fbe09cd42640566600c338744ad87.jpg" alt></p>
<a id="more"></a>
<p>2020年还有不到五天就要过去了,时光如梭,这一年一眨眼就过去了。</p>
<p>大连又一次迎来了第三次新冠疫情,大街上冷冷清清。商场里也没有往日的喧闹。这个城市又一次变得安静了下来。</p>
<p>2020年,大家说得最多的一个字就是”难”。大家好不容易挺过来,来势汹汹的疫情打乱了节奏。很多人心情跌落谷底。</p>
<p>昨天回到家,媳妇说孩子网课表现很优秀,一边跟着老师听讲,一边和老师互动,还知道静音,非常投入，孩子这是长大了。我心里却不是滋味,和去年疫情相比,网课一天不上,天天就是看平板电脑形成了强烈的反差。孩子不是长大了,是社会让她不得不遵守规则。</p>
<p>学生问我,你白天上课,晚上还上晚课,收入一定很高,我笑了笑说,还可以吧,他接着又问,你肯定是学校股东,要不谁能这么拼命。我回答,成年人的世界里哪有什么不容易。师生相视一笑。大家都明白,个中滋味自己体会吧。</p>
<p>疫情让我们明白一些道理,什么都没有活着和生存更重要。只要活着,就有希望。</p>
<p>2020让我们体会到生命的伟大,致敬那些工作在一线的医护工作者们,他们是最美的逆行者。</p>
<p>致敬那些为了后勤保障,辛勤工作的各行各业的人们,他们社会能正常运转。</p>
<p>为人父,为人母,体会到了父母的艰辛。</p>
<p>就像奥特曼经常说的一样,相信光，会守护世界。每个人心中都有奥特曼。我也会守护我的家人,守护我身边的一切。</p>
<p>希望在新的一年,一切都会变好。</p>
<p>祝愿大家都身体健康,因为有光,就有希望。</p>
<p>未来可期,再见2020!</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>how to export django project dependency</title>
    <url>/2020/09/15/how-to-export-django-project-dependency/</url>
    <content><![CDATA[<h1 id="如何导出django项目依赖第三方库"><a href="#如何导出django项目依赖第三方库" class="headerlink" title="如何导出django项目依赖第三方库"></a>如何导出<code>django</code>项目依赖第三方库</h1><p><img src="https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=f979fd647b8da9774e7a8e2d8061d421/d000baa1cd11728bf4f9b275c0fcc3cec2fd2c94.jpg" alt></p>
<a id="more"></a>
<h2 id="使用pip-freeze-导出"><a href="#使用pip-freeze-导出" class="headerlink" title="使用pip freeze 导出"></a>使用<code>pip freeze</code> 导出</h2><p>针对大部分使用<code>virtualenv</code> 或<code>venv</code>，<code>pipenv</code> 虚拟环境的项目而言,导出第三方依赖很容易,运行下面的命令即可</p>
<p><code>pip freeze &gt; requirements.txt</code></p>
<h2 id="非虚拟环境如何导出项目依赖"><a href="#非虚拟环境如何导出项目依赖" class="headerlink" title="非虚拟环境如何导出项目依赖"></a>非虚拟环境如何导出项目依赖</h2><h3 id="安装-pipreqs库"><a href="#安装-pipreqs库" class="headerlink" title="安装 pipreqs库"></a>安装 <code>pipreqs</code>库</h3><p><code>pip install pipreqs</code></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>进入项目根目录,使用下面的指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipreqs ./</span><br></pre></td></tr></table></figure>
<h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\code\django_blog\mysite&gt;pipreqs ./</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "c:\python38\lib\runpy.py", line 194, in _run_module_as_main</span><br><span class="line">    return _run_code(code, main_globals, None,</span><br><span class="line">  File "c:\python38\lib\runpy.py", line 87, in _run_code</span><br><span class="line">    exec(code, run_globals)</span><br><span class="line">  File "C:\Python38\Scripts\pipreqs.exe\__main__.py", line 9, in &lt;module&gt;</span><br><span class="line">  File "c:\python38\lib\site-packages\pipreqs\pipreqs.py", line 470, in main</span><br><span class="line">    init(args)</span><br><span class="line">  File "c:\python38\lib\site-packages\pipreqs\pipreqs.py", line 406, in init</span><br><span class="line">    candidates = get_all_imports(input_path,</span><br><span class="line">  File "c:\python38\lib\site-packages\pipreqs\pipreqs.py", line 122, in get_all_imports</span><br><span class="line">    contents = f.read()</span><br><span class="line">UnicodeDecodeError: 'gbk' codec can't decode byte 0xae in position 403: illegal multibyte sequence</span><br></pre></td></tr></table></figure>
<h3 id="添加命令行参数-encoding-utf-8"><a href="#添加命令行参数-encoding-utf-8" class="headerlink" title="添加命令行参数 encoding=utf-8"></a>添加命令行参数 <code>encoding=utf-8</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pipreqs ./ --encoding=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>node14.4 run hexo TypeError [ERR_INVALID_ARG_TYPE]</title>
    <url>/2020/12/27/node14-4-run-hexo-TypeError-ERR-INVALID-ARG-TYPE/</url>
    <content><![CDATA[<h1 id="Node升级到14-4-hexo-运行失败"><a href="#Node升级到14-4-hexo-运行失败" class="headerlink" title="Node升级到14.4 hexo 运行失败"></a>Node升级到14.4 hexo 运行失败</h1><p><img src="https://www.prajwaldesai.com/wp-content/uploads/2014/01/error-code.jpeg" alt></p>
<a id="more"></a>
<p>node刚升级到14.4,结果发现使用<code>hexo d</code>命令部署到<code>gitee</code>上发现如下错误</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; typeError [ERR_INVALID_ARG_TYPE]: The <span class="string">"mode"</span> argument must be <span class="built_in">integer</span>. Received an instance of Object</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>查阅相关资料发现是node版本太高导致,最终将node降级到12.14.0后,重新部署就成功了。</p>
<p>当然你也可以使用nvm来切换node版本。</p>
]]></content>
      <categories>
        <category>hexo</category>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript keep i variable value in loop</title>
    <url>/2021/01/11/Javascript-keep-i-variable-value-in-loop/</url>
    <content><![CDATA[<h1 id="JavaScript的循环中保留变量i的值"><a href="#JavaScript的循环中保留变量i的值" class="headerlink" title="JavaScript的循环中保留变量i的值"></a>JavaScript的循环中保留变量i的值</h1><p><img src="https://www.programiz.com/sites/tutorial2program/files/for-loop_0.jpg" alt></p>
<a id="more"></a>
<p>又一波疫情,本来就景气的大连又一次雪上加霜。只要有希望,一切都会好的。</p>
<blockquote>
<p>循环是我们常用的控制语句，在<code>javascript</code>中每次循环结束后其 i 值会指向最后一次的结果，这样循环注册事件时使用到 i 值便会出错</p>
</blockquote>
<p>点击图片切换背景的<code>javascript</code>脚本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/1.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/2.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/3.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/4.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"> <span class="keyword">var</span> imgs = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>).querySelectorAll(<span class="string">'img'</span>)</span></span><br><span class="line"><span class="actionscript"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgs.length; i++) &#123;</span></span><br><span class="line"><span class="actionscript">    imgs[i].onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">       <span class="comment">// console.log(imgs[i].src);</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(i);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.style.backgroundImage = <span class="string">'url('</span> + imgs[i].src + <span class="string">')'</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>直接报错:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property 'src' of undefined</span><br></pre></td></tr></table></figure>
<p>打印变量<code>i</code>,永远都是指向最大索引值4</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 4</span></span><br></pre></td></tr></table></figure>
<p>下面是解决方案 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种解决方案： this关键字</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgs.length; i++) &#123;</span><br><span class="line">    imgs[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">// console.log(imgs[i].src);</span></span><br><span class="line">       <span class="built_in">console</span>.log(i);</span><br><span class="line">       <span class="built_in">document</span>.body.style.backgroundImage = <span class="string">'url('</span> + <span class="keyword">this</span>.src + <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//第二种解决方案: 自动执行函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgs.length; i++) &#123;</span><br><span class="line">            (<span class="function"><span class="keyword">function</span> (<span class="params">inner</span>) </span>&#123;</span><br><span class="line">                imgs[inner].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(imgs[inner]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)(i);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//第三种解决方案 闭包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imgs.length; i++) &#123;</span><br><span class="line">            imgs[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params">inner</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(inner);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;(i);</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//第四种解决方案 let 块级作用域</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imgs.length; i++) &#123;</span><br><span class="line">            imgs[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(i);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>循环</tag>
        <tag>闭包</tag>
        <tag>es6</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>how to use maketrans in python3</title>
    <url>/2021/04/09/how-to-use-maketrans-in-python3/</url>
    <content><![CDATA[<h1 id="如何在python3中使用maketrans"><a href="#如何在python3中使用maketrans" class="headerlink" title="如何在python3中使用maketrans"></a>如何在python3中使用maketrans</h1><p><img src="https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/b999a9014c086e064153b48607087bf40bd1cb00.jpg" alt></p>
<a id="more"></a>
<h2 id="python3中的maketrans"><a href="#python3中的maketrans" class="headerlink" title="python3中的maketrans"></a>python3中的maketrans</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote>
<p>Python maketrans() 方法用于给 translate()方法创建字符映射转换表。</p>
<p>可以只接受一个参数，此时这个参数是个字典类型（暂不研究这种情况）。</p>
<p>对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串，表示转换的目标。两个字符串的长度必须相同，为一一对应的关系。</p>
<p>在Python3中可以有第三个参数，表示要删除的字符，也是字符串。</p>
<p>一般 maketrans() 方法需要配合 translate() 方法一起使用。</p>
<p><strong>注：</strong>Python3.4 以后已经不需要从外部 string 模块中来调用 maketrans() 方法了，取而代之的是内建函数: bytearray.maketrans()、bytes.maketrans()、str.maketrans()。</p>
</blockquote>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li>python3中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str.maketrans(intab,outtab[,delchars])</span><br></pre></td></tr></table></figure>
<ul>
<li>python2中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">string.maketrans(intab,outtab)</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>intab – 需要转换的字符组成的字符串。</li>
<li>outtab – 转换的目标字符组成的字符串。</li>
<li>delchars – 可选参数，表示要删除的字符组成的字符串。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个字符映射转换表供 translate()方法调用。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>借用 <a href="http://www.pythonchallenge.com/pc/def/map.html" target="_blank" rel="noopener">python挑战</a> 第一关</p>
<p>提示信息显示:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">K--&gt;M </span><br><span class="line">O--&gt;Q</span><br><span class="line">E--&gt;G</span><br></pre></td></tr></table></figure>
<p>每个字母向后移动两位就是加密之前的单词了,于是就有下面的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> str = <span class="string">"g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj."</span></span><br><span class="line"> </span><br><span class="line">table=str.maketrans(<span class="string">'abcdefghijklmnopqrstuvwxyz'</span>,<span class="string">'cdefghijklmnopqrstuvwxyzab'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> str.translate(table)</span><br></pre></td></tr></table></figure>
<p>翻译过来: i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that’s why this text is so long. using string.maketrans() is recommended. now apply on the url</p>
<p>通过转换得到下一关的地址</p>
<p><a href="http://www.pythonchallenge.com/pc/def/ocr.html" target="_blank" rel="noopener">http://www.pythonchallenge.com/pc/def/ocr.html</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu install nodejs config taobao source</title>
    <url>/2021/04/07/ubuntu-install-nodejs-config-taobao-source/</url>
    <content><![CDATA[<h1 id="Ubuntu-npm-切换淘宝镜像源"><a href="#Ubuntu-npm-切换淘宝镜像源" class="headerlink" title="Ubuntu npm 切换淘宝镜像源"></a>Ubuntu npm 切换淘宝镜像源</h1><p><img src="https://up.enterdesk.com/edpic/97/66/ed/9766edaddc5a38b512222fc387f83d9f.jpg" alt></p>
<a id="more"></a>
<h2 id="npm-切换到淘宝源"><a href="#npm-切换到淘宝源" class="headerlink" title="npm 切换到淘宝源"></a>npm 切换到淘宝源</h2><p>默认的npm下载地址：<a href="http://www.npmjs.org/" target="_blank" rel="noopener">http://www.npmjs.org/</a><br>淘宝npm镜像的地址：<a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a><br>临时使用淘宝源：</p>
<pre><code>$ npm --registry https://registry.npm.taobao.org install node-red-contrib-composer@latest
</code></pre><h2 id="全局配置切换到淘宝源："><a href="#全局配置切换到淘宝源：" class="headerlink" title="全局配置切换到淘宝源："></a>全局配置切换到淘宝源：</h2><pre><code>$ npm config set registry https://registry.npm.taobao.org
</code></pre><h2 id="全局配置切换到官方源："><a href="#全局配置切换到官方源：" class="headerlink" title="全局配置切换到官方源："></a>全局配置切换到官方源：</h2><pre><code>$ npm config set registry http://www.npmjs.org
</code></pre><h3 id="检测是否切换到了淘宝源："><a href="#检测是否切换到了淘宝源：" class="headerlink" title="检测是否切换到了淘宝源："></a>检测是否切换到了淘宝源：</h3><pre><code>$ npm info underscore
</code></pre>]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>fix FinalShell error channel is not opened</title>
    <url>/2022/08/22/fix-FinalShell-error-channel-is-not-opened/</url>
    <content><![CDATA[<h1 id="解决FinalShell-终端错误-channel-is-not-opened"><a href="#解决FinalShell-终端错误-channel-is-not-opened" class="headerlink" title="解决FinalShell 终端错误 channel is not opened"></a>解决FinalShell 终端错误 <code>channel is not opened</code></h1><p><img src="https://pic.zsucai.com/files/2020/1220/ffpic0224ddfere07725.jpg" alt></p>
<a id="more"></a>
<blockquote>
<p>打开虚拟机连接FinalShell出现久联不上的问题,显示显示连接上,不一会就断掉,报错为channel is not opened.</p>
</blockquote>
<h2 id="1-打开虚拟机-找到相关配置文件"><a href="#1-打开虚拟机-找到相关配置文件" class="headerlink" title="1.打开虚拟机:找到相关配置文件"></a>1.打开虚拟机:找到相关配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<h2 id="2-找到被注释的-UseDNS-yes去掉-更改为UseDNS-no-完成后ESC退出编辑模式-使用-wq-回车保存并退出"><a href="#2-找到被注释的-UseDNS-yes去掉-更改为UseDNS-no-完成后ESC退出编辑模式-使用-wq-回车保存并退出" class="headerlink" title="2.找到被注释的#UseDNS yes去掉#,更改为UseDNS no,完成后ESC退出编辑模式,使用 :wq 回车保存并退出"></a>2.找到被注释的<code>#UseDNS yes</code>去掉#,更改为<code>UseDNS no</code>,完成后ESC退出编辑模式,使用 :wq 回车保存并退出</h2><h2 id="3-重启sshd服务"><a href="#3-重启sshd服务" class="headerlink" title="3.重启sshd服务"></a>3.重启sshd服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>终端</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>missing you</title>
    <url>/2021/04/21/missing-you/</url>
    <content><![CDATA[<h1 id="夜已深-天凉-想您了"><a href="#夜已深-天凉-想您了" class="headerlink" title="夜已深,天凉,想您了"></a>夜已深,天凉,想您了</h1><p><img src="https://bpic.588ku.com/element_origin_min_pic/19/04/11/e9a157f9c729af7aac211ce53eb1b8a7.jpg" alt></p>
<a id="more"></a>
<p>对一个人的思念可以到什么程度？可能只有真正失去的人才能懂吧。一晃父亲离开我们已经2年了…….</p>
<p>前段时间无意中看到迟尚斌因病逝世的消息,突然想起了父亲生前也是球迷。</p>
<p>回想起小时候,爸爸每周六都要看cctv5转播的意大利联赛,我也耳濡目染喜欢上了足球。</p>
<p>“足球是圆的,没到最后一刻,一切皆有可能。”马拉多纳、齐达内、博格坎普、伊基塔那些在球场上闪耀的球星,我只要听到他们的名字内心都莫名的激动。</p>
<p>然而父亲并没有让我踢足球,我记得又一次我自己拿了个破足球在球场上踢,爸爸默默走过来说:你也喜欢足球？我点了点头。知道为啥不让你踢足球吗？我摇了摇头。因为你太瘦了,足球对抗性太强,怕你受伤。我似懂非懂的点了点头。</p>
<p>我和父亲的话题也渐渐多了起来,从五大联赛到欧洲杯、世界杯到甲A联赛,基本上有关足球的东西都是茶余饭后的谈资。我熬夜看球,父亲慢慢熬不了夜,只能让我把白天录播的时间给他记下来,他白天没事的时候看。每次看到漂亮的进球总想和父亲分享,一转身,父亲已经睡着了。</p>
<p>父亲中年的时候担任分厂足球队的教练,我偷摸在场边看着父亲,整个人在球场上的感觉都不一样了。心里别提多自豪了。听妈妈说,你爸年轻的时候,不光是足球,篮球、排球都很厉害,刚开始还能踢前锋,伴随着年龄增长,就改踢中场,到最后只能踢后卫了。我没想到爸爸还有这么风光的经历。我眼中的父亲,话很少,很严厉,工作起来很认真。</p>
<p>说点高兴的事,爸爸告诉你个事儿,今年女足挺进了世界杯,贾秀全也是大连人。我想您在天上应该也会很开心的。</p>
<p>一天,媳妇调侃闺女说,你以后找对象会找你爸这样的吗？闺女说,不会啊,因为爸爸只有一个啊。我听到了,心里莫名感动。现在能理解为人父母那份不需要回报的心了。</p>
<p>挚爱亲朋的离开,与其悲伤,我们只能选择坚强。做好一个父亲,尽可能地呵护家人,我会照顾好自己，父亲不用再为我担心。</p>
<p>夜已深,父亲,我又想您了。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>word和pdf转换</title>
    <url>/2022/12/06/word%E5%92%8Cpdf%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="使用Python-进行word和pdf转换"><a href="#使用Python-进行word和pdf转换" class="headerlink" title="使用Python 进行word和pdf转换"></a>使用Python 进行word和pdf转换</h1><p><img src="https://img.wmzhe.top/pics/f4/4c/f44ccd1b1ae065727d5f80ce8bdfdc6e.jpg" alt></p>
<a id="more"></a>
<h2 id="安装第三方库"><a href="#安装第三方库" class="headerlink" title="安装第三方库"></a>安装第三方库</h2><p><code>pip install docx2pdf</code></p>
<ul>
<li>WORD TO PDF</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> docx2pdf <span class="keyword">import</span> convert</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件位置</span></span><br><span class="line">path = <span class="string">'d:/word_list/'</span></span><br><span class="line"><span class="comment"># 定义空list,存放文件夹中的文件名</span></span><br><span class="line">files = []</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">    <span class="keyword">if</span> file.endswith(<span class="string">".docx"</span>):</span><br><span class="line">        files.append(path+file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">   a = convert(file,file.split(<span class="string">'.'</span>)[<span class="number">0</span>]+<span class="string">'.pdf'</span>) <span class="comment">#创建生成的pdf文件和文件名的文件名</span></span><br><span class="line">   time.sleep(<span class="number">1.2</span>)</span><br><span class="line"></span><br><span class="line">   print(file+<span class="string">'转换成功'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>PDF TO WORD</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pdf2docx <span class="keyword">import</span> Converter</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#批量pdf转word</span></span><br><span class="line"></span><br><span class="line">path = <span class="string">'d:/pdf_list/'</span></span><br><span class="line"><span class="comment"># 定义空list,存放文件夹中的文件名</span></span><br><span class="line">files = []</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">    <span class="keyword">if</span> file.endswith(<span class="string">".pdf"</span>):</span><br><span class="line">        files.append(path+file)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">    a = Converter(file)</span><br><span class="line">    a.convert(file.split(<span class="string">'.'</span>)[<span class="number">0</span>]+<span class="string">'.docx'</span>) <span class="comment">#创建生成的docx文件和文件名的文件名</span></span><br><span class="line">    a.close()</span><br><span class="line">    print(file+<span class="string">'转换成功'</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>办公</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard_library fileinput</title>
    <url>/2020/03/22/python-standard-library-fileinput/</url>
    <content><![CDATA[<h1 id="Python-标准库-fileinput"><a href="#Python-标准库-fileinput" class="headerlink" title="Python 标准库 fileinput"></a>Python 标准库 fileinput</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200323_input-output.jpg?raw=true" alt></p>
<a id="more"></a>
<p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/fileinput.py" target="_blank" rel="noopener">Lib/fileinput.py</a></p>
<hr>
<p>此模块实现了一个辅助类和一些函数用来快速编写访问标准输入或文件列表的循环。 如果你只想要读写一个文件请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>。</p>
<p>典型用法为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fileinput</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input():</span><br><span class="line">    process(line)</span><br></pre></td></tr></table></figure>
<p>此程序会迭代 <code>sys.argv[1:]</code> 中列出的所有文件内的行，如果列表为空则会使用 <code>sys.stdin</code>。 如果有一个文件名为 <code>&#39;-&#39;</code>，它也会被替换为 <code>sys.stdin</code> 并且可选参数 <em>mode</em> 和 <em>openhook</em> 会被忽略。 要指定替代文件列表，请将其作为第一个参数传给 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.input" target="_blank" rel="noopener"><code>input()</code></a>。 也允许使用单个文件。</p>
<p>所有文件都默认以文本模式打开，但你可以通过在调用 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.input" target="_blank" rel="noopener"><code>input()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput</code></a> 时指定 <em>mode</em> 形参来重载此行为。 如果在打开或读取文件时发生了 I/O 错误，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>。</p>
<p><em>在 3.3 版更改:</em> 原来会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IOError" target="_blank" rel="noopener"><code>IOError</code></a>；现在它是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的别名。</p>
<p>如果 <code>sys.stdin</code> 被使用超过一次，则第二次之后的使用将不返回任何行，除非是被交互式的使用，或都是被显式地重置 (例如使用 <code>sys.stdin.seek(0)</code>)。</p>
<p>空文件打开后将立即被关闭；它们在文件列表中会被注意到的唯一情况只有当最后打开的文件为空的时候。</p>
<p>反回的行不会对换行符做任何处理，这意味着文件中的最后一行可能不带换行符。</p>
<p>想要控制文件的打开方式，你可以通过将 <em>openhook</em> 形参传给 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.input" target="_blank" rel="noopener"><code>fileinput.input()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput()</code></a> 来提供一个打开钩子。 此钩子必须为一个函数，它接受两个参数，<em>filename</em> 和 <em>mode</em>，并返回一个以相应模式打开的文件类对象。 此模块已经提供了两个有用的钩子。</p>
<p>以下函数是此模块的初始接口：</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p><code>fileinput.input</code>(<em>files=None</em>, <em>inplace=False</em>, <em>backup=’’</em>, <em>**, </em>mode=’r’<em>, </em>openhook=None*)</p>
<p>创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput</code></a> 类的实例。 该实例将被用作此模块中函数的全局状态，并且还将在迭代期间被返回使用。 此函数的形参将被继续传递给 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput</code></a> 类的构造器。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput</code></a> 实例可以在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中被用作上下文管理器。 在这个例子中，<em>input</em> 在 <code>with</code> 语句结束后将会被关闭，即使发生了异常也是如此:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with fileinput.input(files=(&apos;spam.txt&apos;, &apos;eggs.txt&apos;)) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        process(line)</span><br></pre></td></tr></table></figure>
<p><em>在 3.2 版更改:</em> 可以被用作上下文管理器。</p>
<p><em>在 3.8 版更改:</em> 关键字形参 <em>mode</em> 和 <em>openhook</em> 现在是仅限关键字形参。</p>
</li>
</ul>
<p>下列函数会使用 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.input" target="_blank" rel="noopener"><code>fileinput.input()</code></a> 所创建的全局状态；如果没有活动的状态，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p>
<ul>
<li><p><code>fileinput.filename</code>()</p>
<p>返回当前被读取的文件名。 在第一行被读取之前，返回 <code>None</code>。</p>
</li>
<li><p><code>fileinput.fileno</code>()</p>
<p>返回以整数表示的当前文件“文件描述符”。 当未打开文件时（处在第一行和文件之间），返回 <code>-1</code>。</p>
</li>
<li><p><code>fileinput.lineno</code>()</p>
<p>返回已被读取的累计行号。 在第一行被读取之前，返回 <code>0</code>。 在最后一个文件的最后一行被读取之后，返回该行的行号。</p>
</li>
<li><p><code>fileinput.filelineno</code>()</p>
<p>返回当前文件中的行号。 在第一行被读取之前，返回 <code>0</code>。 在最后一个文件的最后一行被读取之后，返回此文件中该行的行号。</p>
</li>
<li><p><code>fileinput.isfirstline</code>()</p>
<p>如果刚读取的行是其所在文件的第一行则返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><code>fileinput.isstdin</code>()</p>
<p>如果最后读取的行来自 <code>sys.stdin</code> 则返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><code>fileinput.nextfile</code>()</p>
<p>关闭当前文件以使下次迭代将从下一个文件（如果存在）读取第一行；不是从该文件读取的行将不会被计入累计行数。 直到下一个文件的第一行被读取之后文件名才会改变。 在第一行被读取之前，此函数将不会生效；它不能被用来跳过第一个文件。 在最后一个文件的最后一行被读取之后，此函数将不再生效。</p>
</li>
<li><p><code>fileinput.close</code>()</p>
<p>关闭序列。</p>
</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>此模块所提供的实现了序列行为的类同样也可用于子类化：</p>
<ul>
<li><p><em>class</em> <code>fileinput.FileInput</code>(<em>files=None</em>, <em>inplace=False</em>, <em>backup=’’</em>, <em>**, </em>mode=’r’<em>, </em>openhook=None*)</p>
<p>类 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput</code></a> 是一个实现；它的方法 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.filename" target="_blank" rel="noopener"><code>filename()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.fileno" target="_blank" rel="noopener"><code>fileno()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.lineno" target="_blank" rel="noopener"><code>lineno()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.filelineno" target="_blank" rel="noopener"><code>filelineno()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.isfirstline" target="_blank" rel="noopener"><code>isfirstline()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.isstdin" target="_blank" rel="noopener"><code>isstdin()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.nextfile" target="_blank" rel="noopener"><code>nextfile()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.close" target="_blank" rel="noopener"><code>close()</code></a> 对应于此模块中具有相同名称的函数。 此外它还有一个 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.TextIOBase.readline" target="_blank" rel="noopener"><code>readline()</code></a> 方法可返回下一个输入行，以及一个 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法，该方法实现了序列行为。 这种序列必须以严格的序列顺序来读写；随机读写和 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.TextIOBase.readline" target="_blank" rel="noopener"><code>readline()</code></a> 不可以被混用。</p>
<p>通过 <em>mode</em> 你可以指定要传给 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 的文件模式。 它必须为 <code>&#39;r&#39;</code>, <code>&#39;rU&#39;</code>, <code>&#39;U&#39;</code> 和 <code>&#39;rb&#39;</code> 中的一个。</p>
<p><em>openhook</em> 如果给出则必须为一个函数，它接受两个参数 <em>filename</em> 和 <em>mode</em>，并相应地返回一个打开的文件类对象。 你不能同时使用 <em>inplace</em> 和 <em>openhook</em>。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput</code></a> 实例可以在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中被用作上下文管理器。 在这个例子中，<em>input</em> 在 <code>with</code> 语句结束后将会被关闭，即使发生了异常也是如此:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> FileInput(files=(<span class="string">'spam.txt'</span>, <span class="string">'eggs.txt'</span>)) <span class="keyword">as</span> input:</span><br><span class="line">    process(input)</span><br></pre></td></tr></table></figure>
<p><em>在 3.2 版更改:</em> 可以被用作上下文管理器。</p>
<p><em>3.4 版后已移除:</em> <code>&#39;rU&#39;</code> 和 <code>&#39;U&#39;</code> 模式。</p>
<p><em>3.8 版后已移除:</em> 对 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法的支持已弃用。</p>
<p><em>在 3.8 版更改:</em> 关键字形参 <em>mode</em> 和 <em>openhook</em> 现在是仅限关键字形参。</p>
</li>
</ul>
<p><strong>可选的原地过滤:</strong> 如果传递了关键字参数 <code>inplace=True</code> 给 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.input" target="_blank" rel="noopener"><code>fileinput.input()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput</code></a> 构造器，则文件会被移至备份文件并将标准输出定向到输入文件（如果已存在与备份文件同名的文件，它将被静默地替换）。 这使得编写一个能够原地重写其输入文件的过滤器成为可能。 如果给出了 <em>backup</em> 形参 (通常形式为 <code>backup=&#39;.&lt;some extension&gt;&#39;</code>)，它将指定备份文件的扩展名，并且备份文件会被保留；默认情况下扩展名为 <code>&#39;.bak&#39;</code> 并且它会在输出文件关闭时被删除。 在读取标准输入时原地过滤会被禁用。</p>
<p>此模块提供了以下两种打开文件钩子：</p>
<ul>
<li><p><code>fileinput.hook_compressed</code>(<em>filename</em>, <em>mode</em>)</p>
<p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/gzip.html#module-gzip" target="_blank" rel="noopener"><code>gzip</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块透明地打开 gzip 和 bzip2 压缩的文件（通过扩展名 <code>&#39;.gz&#39;</code> 和 <code>&#39;.bz2&#39;</code> 来识别）。 如果文件扩展名不是 <code>&#39;.gz&#39;</code> 或 <code>&#39;.bz2&#39;</code>，文件会以正常方式打开（即使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 并且不带任何解压操作）。使用示例: <code>fi = fileinput.FileInput(openhook=fileinput.hook_compressed)</code></p>
</li>
<li><p><code>fileinput.hook_encoded</code>(<em>encoding</em>, <em>errors=None</em>)</p>
<p>返回一个通过 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 打开每个文件的钩子，使用给定的 <em>encoding</em> 和 <em>errors</em> 来读取文件。使用示例: <code>fi = fileinput.FileInput(openhook=fileinput.hook_encoded(&quot;utf-8&quot;, &quot;surrogateescape&quot;))</code><em>在 3.6 版更改:</em> 添加了可选的 <em>errors</em> 形参。</p>
</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><em>利用fileinput及re做日志分析: 提取所有含日期的行</em></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">#--样本文件--</span></span><br><span class="line">aaa</span><br><span class="line"><span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">30</span>  Error: **** Due to System Disk spacke <span class="keyword">not</span> enough...</span><br><span class="line">bbb</span><br><span class="line"><span class="number">1970</span><span class="number">-01</span><span class="number">-02</span> <span class="number">10</span>:<span class="number">20</span>:<span class="number">30</span>  Error: **** Due to System Out of Memory...</span><br><span class="line">ccc</span><br><span class="line"> </span><br><span class="line"><span class="comment">#---测试脚本---</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> fileinput</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line">pattern = <span class="string">'d&#123;4&#125;-d&#123;2&#125;-d&#123;2&#125; d&#123;2&#125;:d&#123;2&#125;:d&#123;2&#125;'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input(<span class="string">'error.log'</span>,backup=<span class="string">'.bak'</span>,inplace=<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> re.search(pattern,line):</span><br><span class="line">        sys.stdout.write(=&gt; )</span><br><span class="line">        sys.stdout.write(line)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#---测试结果---</span></span><br><span class="line">=&gt; 1970-01-01 13:45:30  Error: **** Due to System Disk spacke not enough...</span><br><span class="line">=&gt; 1970-01-02 10:20:30  Error: **** Due to System Out of Memory...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>fileinput</tag>
      </tags>
  </entry>
  <entry>
    <title>python standard library os</title>
    <url>/2020/02/20/python-standard-library-os/</url>
    <content><![CDATA[<h1 id="python-标准库-os"><a href="#python-标准库-os" class="headerlink" title="python 标准库 os"></a>python 标准库 os</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200220_os.jpg?raw=true" alt></p>
<a id="more"></a>
<blockquote>
<p>每日一词：</p>
<p> <a href="https://www.hujiang.com/ciku/bustle/" target="_blank" rel="noopener">bustle</a> v.[I] 1.闹哄哄地忙乱；匆忙；奔忙 2.充满 v.[T] 催促；使忙碌 n. 忙乱；喧扰 </p>
<p>短语：</p>
<p> hustle and bustle  熙熙攘攘</p>
<p> <a href="https://www.hujiang.com/ciku/bustle_in_and_out/" target="_blank" rel="noopener">bustle in and out</a> </p>
<p> <a href="https://www.hujiang.com/ciku/bustle_about/" target="_blank" rel="noopener">bustle about</a>  sth</p>
<p>近义词:</p>
<p>run out of one’s feet </p>
<p>on the fly<br>on the hump<br>on the jump </p>
</blockquote>
<p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/os.py" target="_blank" rel="noopener">Lib/os.py</a></p>
<hr>
<p>本模块提供了一种使用与操作系统相关的功能的便捷式途径。 如果你只是想读写一个文件，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>，如果你想操作文件路径，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 模块，如果你想读取通过命令行给出的所有文件中的所有行，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#module-fileinput" target="_blank" rel="noopener"><code>fileinput</code></a> 模块。 为了创建临时文件和目录，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#module-tempfile" target="_blank" rel="noopener"><code>tempfile</code></a> 模块，对于高级文件和目录处理，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 模块。</p>
<p>关于这些函数的可用性的说明：</p>
<ul>
<li>Python中所有依赖于操作系统的内置模块的设计都是这样，只要不同的操作系统某一相同的功能可用，它就使用相同的接口。例如，函数 <code>os.stat(path)</code> 以相同的格式返回关于 <em>path</em> 的状态信息（该格式源于 POSIX 接口）。</li>
<li>特定于某一操作系统的扩展通过操作 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块也是可用的，但是使用它们当然是对可移植性的一种威胁。</li>
<li>所有接受路径或文件名的函数都同时支持字节串和字符串对象，并在返回路径或文件名时使用相应类型的对象作为结果。</li>
<li>在 VxWorks 系统上，os.fork, os.execv 和 os.spawn<em>p</em> 不被支持。</li>
</ul>
<blockquote>
<p> 如果使用无效或无法访问的文件名与路径，或者其他类型正确但操作系统不接受的参数，此模块的所有函数都抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> （或者它的子类）。 </p>
</blockquote>
<ul>
<li><p><em>exception</em> <code>os.error</code></p>
<p>内建的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常的一个别名。</p>
</li>
<li><p><code>os.name</code></p>
<p>导入的依赖特定操作系统的模块的名称。以下名称目前已注册: <code>&#39;posix&#39;</code>, <code>&#39;nt&#39;</code>, <code>&#39;java&#39;</code>.</p>
</li>
</ul>
<blockquote>
<p><a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.platform" target="_blank" rel="noopener"><code>sys.platform</code></a> 有更详细的描述. <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.uname" target="_blank" rel="noopener"><code>os.uname()</code></a> 只给出系统提供的版本信息。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/platform.html#module-platform" target="_blank" rel="noopener"><code>platform</code></a> 模块对系统的标识有更详细的检查。</p>
</blockquote>
<h2 id="文件名，命令行参数，以及环境变量。"><a href="#文件名，命令行参数，以及环境变量。" class="headerlink" title="文件名，命令行参数，以及环境变量。"></a>文件名，命令行参数，以及环境变量。</h2><p>在 Python 中，使用字符串类型表示文件名、命令行参数和环境变量。 在某些系统上，在将这些字符串传递给操作系统之前，必须将这些字符串解码为字节。 Python 使用文件系统编码来执行此转换（请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getfilesystemencoding" target="_blank" rel="noopener"><code>sys.getfilesystemencoding()</code></a> ）。</p>
<p><em>在 3.1 版更改:</em> 在某些系统上，使用文件系统编码进行转换可能会失败。 在这种情况下，Python 会使用 <a href="https://docs.python.org/zh-cn/3.8/library/codecs.html#surrogateescape" target="_blank" rel="noopener">代理转义编码错误处理器</a>，这意味着在解码时，不可解码的字节被 Unicode 字符 U+DCxx 替换，并且这些字节在编码时再次转换为原始字节。</p>
<p>文件系统编码必须保证成功解码小于 128 的所有字节。如果文件系统编码无法提供此保证， API 函数可能会引发 UnicodeErrors 。</p>
<h2 id="进程参数"><a href="#进程参数" class="headerlink" title="进程参数"></a>进程参数</h2><p>这些函数和数据项提供了操作当前进程和用户的信息。</p>
<ul>
<li><p><code>os.ctermid</code>()</p>
<p>返回与进程控制终端对应的文件名。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.environ</code></p>
<p>一个表示字符串环境的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-mapping" target="_blank" rel="noopener">mapping</a> 对象。 例如，<code>environ[&#39;HOME&#39;]</code> 是你的主目录（在某些平台上）的路径名，相当于 C 中的 <code>getenv(&quot;HOME&quot;)</code>。这个映射是在第一次导入 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块时捕获的，通常作为 Python 启动时处理 <code>site.py</code> 的一部分。除了通过直接修改 <code>os.environ</code> 之外，在此之后对环境所做的更改不会反映在 <code>os.environ</code> 中。如果平台支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 函数，这个映射除了可以用于查询环境外还能用于修改环境。 当这个映射被修改时，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 将被自动调用。在Unix系统上，键和值会使用 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getfilesystemencoding" target="_blank" rel="noopener"><code>sys.getfilesystemencoding()</code></a> 和 <code>&#39;surrogateescape&#39;</code> 的错误处理。如果你想使用其他的编码，使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environb" target="_blank" rel="noopener"><code>environb</code></a>。注解 直接调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 并不会影响 <code>os.environ</code>，所以推荐直接修改 <code>os.environ</code>。注解 在某些平台上，包括 FreeBSD 和 Mac OS X，设置 <code>environ</code> 可能导致内存泄露。参阅 <code>putenv()</code> 的系统文档。如果平台没有提供 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a>, 为了使启动的子进程使用修改后的环境，一份修改后的映射会被传给合适的进程创建函数。如果平台支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> 函数，你可以通过删除映射中元素的方式来删除对应的环境变量。当一个元素被从 <code>os.environ</code> 删除时，以及 <code>pop()</code> 或 <code>clear()</code> 被调用时， <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> 会被自动调用。</p>
</li>
<li><p><code>os.environb</code></p>
<p>字节版本的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>environ</code></a>: 一个以字节串表示环境的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-mapping" target="_blank" rel="noopener">mapping</a> 对象。 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>environ</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environb" target="_blank" rel="noopener"><code>environb</code></a> 是同步的（修改 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environb" target="_blank" rel="noopener"><code>environb</code></a> 会更新 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>environ</code></a>，反之亦然）。只有在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_bytes_environ" target="_blank" rel="noopener"><code>supports_bytes_environ</code></a> 为 <code>True</code> 的时候 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environb" target="_blank" rel="noopener"><code>environb</code></a> 才是可用的。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>os.chdir</code>(<em>path</em>)</p>
</li>
<li><p><code>os.fchdir</code>(<em>fd</em>)</p>
</li>
<li><p><code>os.getcwd</code>()</p>
<p>以上函数请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os-file-dir" target="_blank" rel="noopener">文件和目录</a> 。</p>
</li>
<li><p><code>os.fsencode</code>(<em>filename</em>)</p>
<p>编码 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">路径类</a> <em>文件名</em> 为文件系统接受的形式，使用 <code>&#39;surrogateescape&#39;</code> 代理转义编码错误处理器，在Windows系统上会使用 <code>&#39;strict&#39;</code> ；返回 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 字节类型不变。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsdecode" target="_blank" rel="noopener"><code>fsdecode()</code></a> 是此函数的逆向函数。<em>3.2 新版功能.**在 3.6 版更改:</em> 增加对实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>os.PathLike</code></a> 接口的对象的支持。</p>
</li>
<li><p><code>os.fsdecode</code>(<em>filename</em>)</p>
<p>从文件系统编码方式解码为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">路径类</a> 文件名，使用 <code>&#39;surrogateescape&#39;</code> 代理转义编码错误处理器，在Windows系统上会使用 <code>&#39;strict&#39;</code> ；返回 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 字符串不变。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsencode" target="_blank" rel="noopener"><code>fsencode()</code></a> 是此函数的逆向函数。<em>3.2 新版功能.**在 3.6 版更改:</em> 增加对实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>os.PathLike</code></a> 接口的对象的支持。</p>
</li>
<li><p><code>os.fspath</code>(<em>path</em>)</p>
<p>返回路径的文件系统表示。如果传入的是 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型的字符串，将原样返回。否则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike.__fspath__" target="_blank" rel="noopener"><code>__fspath__()</code></a> 将被调用，如果得到的是一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型的对象，那就返回这个值。其他所有情况则会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 异常。<em>3.6 新版功能.</em></p>
</li>
<li><p><em>class</em> <code>os.PathLike</code></p>
<p>某些对象用于表示文件系统中的路径（如 <a href="https://docs.python.org/zh-cn/3.8/library/pathlib.html#pathlib.PurePath" target="_blank" rel="noopener"><code>pathlib.PurePath</code></a> 对象），本类是这些对象的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class" target="_blank" rel="noopener">抽象基类</a>。<em>3.6 新版功能.**abstractmethod</em> <code>__fspath__</code>()返回当前对象的文件系统表示。这个方法只应该返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 字符串或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 字节串，请优先选择 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 字符串。</p>
</li>
<li><p><code>os.getenv</code>(<em>key</em>, <em>default=None</em>)</p>
<p>如果存在，返回环境变量 <em>key</em> 的值，否则返回 <em>default</em>。 <em>key</em> ， <em>default</em> 和返回值均为 str 字符串类型。在Unix系统上，键和值会使用 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getfilesystemencoding" target="_blank" rel="noopener"><code>sys.getfilesystemencoding()</code></a> 和’surrogateescape’ 错误处理进行解码。如果你想使用其他的编码，使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getenvb" target="_blank" rel="noopener"><code>os.getenvb()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 大部分的Unix系统，Windows。</p>
</li>
<li><p><code>os.getenvb</code>(<em>key</em>, <em>default=None</em>)</p>
<p>如果存在环境变量 <em>key</em> 那么返回其值，否则返回 <em>default</em>。 <em>key</em> ， <em>default</em> 和返回值均为bytes字节串类型。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getenvb" target="_blank" rel="noopener"><code>getenvb()</code></a> 仅在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_bytes_environ" target="_blank" rel="noopener"><code>supports_bytes_environ</code></a> 为 <code>True</code> 时可用。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 大部分的Unix系统。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>os.get_exec_path</code>(<em>env=None</em>)</p>
<p>返回将用于搜索可执行文件的目录列表，与在外壳程序中启动一个进程时相似。指定的 <em>env</em> 应为用于搜索 PATH 的环境变量字典。默认情况下，当 <em>env</em> 为 <code>None</code> 时，将会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>environ</code></a> 。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>os.getegid</code>()</p>
<p>返回当前进程的有效组ID。对应当前进程执行文件的 “set id” 位。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.geteuid</code>()</p>
<p>返回当前进程的有效用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.getgid</code>()</p>
<p>返回当前进程的实际组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.getgrouplist</code>(<em>user</em>, <em>group</em>)</p>
<p>返回该用户所在的组 ID 列表。可能 <em>group</em> 参数没有在返回的列表中，实际上用户应该也是属于该 <em>group</em>。<em>group</em> 参数一般可以从储存账户信息的密码记录文件中找到。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.getgroups</code>()</p>
<p>返回当前进程对应的组ID列表<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
<blockquote>
<p>注解：在Mac OS X系统中，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 会和其他 Unix 平台有些不同。如果 Python 解释器是在 <code>10.5</code> 或更早版本中部署，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 返回当前用户进程相关的有效组ID列表。 该列表长度由于系统预设的接口限制，最长为 16。 而且在适当的权限下，返回结果还会因 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 而发生变化；如果 Python 解释器是在 <code>10.5</code> 以上版本中部署，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 返回进程所属有效用户 ID 所对应的用户的组 ID 列表，组用户列表可能因为进程的生存周期而发生变动，而且也不会因为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.setgroups" target="_blank" rel="noopener"><code>setgroups()</code></a> 的调用而发生，返回的组用户列表长度也没有长度 16 的限制。在部署中，Python 解释器用到的变量 <code>MACOSX_DEPLOYMENT_TARGET</code> 可以用 <a href="https://docs.python.org/zh-cn/3.8/library/sysconfig.html#sysconfig.get_config_var" target="_blank" rel="noopener"><code>sysconfig.get_config_var()</code></a>。</p>
</blockquote>
</li>
<li><p><code>os.getlogin</code>()</p>
<p>返回通过控制终端进程进行登录的用户名。在多数情况下，使用 <a href="https://docs.python.org/zh-cn/3.8/library/getpass.html#getpass.getuser" target="_blank" rel="noopener"><code>getpass.getuser()</code></a> 会更有效，因为后者会通过检查环境变量 <code>LOGNAME</code> 或 <code>USERNAME</code> 来查找用户，再由 <code>pwd.getpwuid(os.getuid())[0]</code> 来获取当前用户 ID 的登录名。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p>
</li>
<li><p><code>os.getpgid</code>(<em>pid</em>)</p>
<p>根据进程id <em>pid</em> 返回进程的组 ID 列表。如果 <em>pid</em> 为 0，则返回当前进程的进程组 ID 列表<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.getpgrp</code>()</p>
<p>返回当时进程组的ID<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.getpid</code>()</p>
<p>返回当前进程ID</p>
</li>
<li><p><code>os.getppid</code>()</p>
<p>返回父进程ID。当父进程已经结束，在Unix中返回的ID是初始进程(1)中的一个，在Windows中仍然是同一个进程ID，该进程ID有可能已经被进行进程所占用。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加WIndows的支持。</p>
</li>
<li><p><code>os.getpriority</code>(<em>which</em>, <em>who</em>)</p>
<p>获取程序调度优先级。<em>which</em> 参数值可以是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PROCESS" target="_blank" rel="noopener"><code>PRIO_PROCESS</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PGRP" target="_blank" rel="noopener"><code>PRIO_PGRP</code></a>，或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_USER" target="_blank" rel="noopener"><code>PRIO_USER</code></a> 中的一个，<em>who</em> 是相对于 <em>which</em> (<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PROCESS" target="_blank" rel="noopener"><code>PRIO_PROCESS</code></a> 的进程标识符，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PGRP" target="_blank" rel="noopener"><code>PRIO_PGRP</code></a> 的进程组标识符和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_USER" target="_blank" rel="noopener"><code>PRIO_USER</code></a> 的用户ID)。当 <em>who</em> 为 0 时（分别）表示调用的进程，调用进程的进程组或调用进程所属的真实用户 ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.PRIO_PROCESS</code></p>
</li>
<li><p><code>os.PRIO_PGRP</code></p>
</li>
<li><p><code>os.PRIO_USER</code></p>
<p>函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getpriority" target="_blank" rel="noopener"><code>getpriority()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.setpriority" target="_blank" rel="noopener"><code>setpriority()</code></a> 的参数。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.getresuid</code>()</p>
<p>返回一个由 (ruid, euid, suid) 所组成的元组，分别表示当前进程的真实用户ID，有效用户ID和甲暂存用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>os.getresgid</code>()</p>
<p>返回一个由 (rgid, egid, sgid) 所组成的元组，分别表示当前进程的真实组ID，有效组ID和暂存组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>os.getuid</code>()</p>
<p>返回当前进程的真实用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.initgroups</code>(<em>username</em>, <em>gid</em>)</p>
<p>调用系统 initgroups()，使用指定用户所在的所有值来初始化组访问列表，包括指定的组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>os.putenv</code>(<em>key</em>, <em>value</em>)</p>
<p>将名为 <em>key</em> 的环境变量值设置为 <em>value</em>。该变量名修改会影响由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>os.system()</code></a>， <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a> ，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>fork()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execv" target="_blank" rel="noopener"><code>execv()</code></a> 发起的子进程。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 大部分的Unix系统，Windows。注解 在一些平台，包括 FreeBSD 和 Mac OS X，设置 <code>environ</code> 可能导致内存泄露。详情参考 putenv 相关系统文档。当系统支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 时，<code>os.environ</code> 中的参数赋值会自动转换为对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 的调用。不过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 的调用不会更新 <code>os.environ</code>，因此最好使用 <code>os.environ</code> 对变量赋值。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.putenv</code>，附带参数 <code>key</code>, <code>value</code>。</p>
</li>
<li><p><code>os.setegid</code>(<em>egid</em>)</p>
<p>设置当前进程的有效组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.seteuid</code>(<em>euid</em>)</p>
<p>设置当前进程的有效用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.setgid</code>(<em>gid</em>)</p>
<p>设置当前进程的组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.setgroups</code>(<em>groups</em>)</p>
<p>将 <em>group</em> 参数值设置为与当进程相关联的附加组ID列表。<em>group</em> 参数必须为一个序列，每个元素应为每个组的数字ID。该操作通常只适用于超级用户。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。注解 在 Mac OS X 中，<em>groups</em> 的长度不能超过系统定义的最大有效组 ID 个数，一般为 16。 如果它没有返回与调用 setgroups() 所设置的相同的组列表，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 的文档。</p>
</li>
<li><p><code>os.setpgrp</code>()</p>
<p>根据已实现的版本（如果有）来调用系统 <code>setpgrp()</code> 或 <code>setpgrp(0, 0)</code> 。相关说明，请参考 Unix 手册。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.setpgid</code>(<em>pid</em>, <em>pgrp</em>)</p>
<p>使用系统调用 <code>setpgid()</code>，将 <em>pid</em> 对应进程的组ID设置为 <em>pgrp</em>。相关说明，请参考 Unix 手册。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.setpriority</code>(<em>which</em>, <em>who</em>, <em>priority</em>)</p>
<p>设置程序调度优先级。 <em>which</em> 的值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PROCESS" target="_blank" rel="noopener"><code>PRIO_PROCESS</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PGRP" target="_blank" rel="noopener"><code>PRIO_PGRP</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_USER" target="_blank" rel="noopener"><code>PRIO_USER</code></a> 之一，而 <em>who</em> 会相对于 <em>which</em> (<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PROCESS" target="_blank" rel="noopener"><code>PRIO_PROCESS</code></a> 的进程标识符, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PGRP" target="_blank" rel="noopener"><code>PRIO_PGRP</code></a> 的进程组标识符和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_USER" target="_blank" rel="noopener"><code>PRIO_USER</code></a> 的用户 ID) 被解析。 <em>who</em> 值为零 (分别) 表示调用进程，调用进程的进程组或调用进程的真实用户 ID。 <em>priority</em> 是范围在 -20 至 19 的值。 默认优先级为 0；较小的优先级数值会更优先被调度。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.setregid</code>(<em>rgid</em>, <em>egid</em>)</p>
<p>设置当前进程的真实和有效组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.setresgid</code>(<em>rgid</em>, <em>egid</em>, <em>sgid</em>)</p>
<p>设置当前进程的真实，有效和暂存组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>os.setresuid</code>(<em>ruid</em>, <em>euid</em>, <em>suid</em>)</p>
<p>设置当前进程的真实，有效和暂存用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>os.setreuid</code>(<em>ruid</em>, <em>euid</em>)</p>
<p>设置当前进程的真实和有效用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.getsid</code>(<em>pid</em>)</p>
<p>调用系统调用 <code>getsid()</code>。相关说明，请参考 Unix 手册。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.setsid</code>()</p>
<p>使用系统调用 <code>getsid()</code>。相关说明，请参考 Unix 手册。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.setuid</code>(<em>uid</em>)</p>
<p>设置当前进程的用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.strerror</code>(<em>code</em>)</p>
<p>根据 <em>code</em> 中的错误码返回错误消息。 在某些平台上当给出未知错误码时 <code>strerror()</code> 将返回 <code>NULL</code> 并会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。</p>
</li>
<li><p><code>os.supports_bytes_environ</code></p>
<p>如果操作系统上原生环境类型是字节型则为 <code>True</code> (例如在 Windows 上为 <code>False</code>)。<em>3.2 新版功能.</em></p>
</li>
<li><p><code>os.umask</code>(<em>mask</em>)</p>
<p>设定当前数值掩码并返回之前的掩码。</p>
</li>
<li><p><code>os.uname</code>()</p>
<p>返回当前操作系统的识别信息。返回值是一个有5个属性的对象：<code>sysname</code> - 操作系统名<code>nodename</code> - 机器在网络上的名称（需要先设定）<code>release</code> - 操作系统发行信息<code>version</code> - 操作系统版本信息<code>machine</code> - 硬件标识符为了向后兼容，该对象也是可迭代的，像是一个按照 <code>sysname</code>，<code>nodename</code>，<code>release</code>，<code>version</code>，和 <code>machine</code> 顺序组成的元组。有些系统会将 <code>nodename</code> 截短为 8 个字符或截短至前缀部分；获取主机名的一个更好方式是 <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.gethostname" target="_blank" rel="noopener"><code>socket.gethostname()</code></a> 或甚至可以用 <code>socket.gethostbyaddr(socket.gethostname())</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 较新的 Unix 版本。<em>在 3.3 版更改:</em> 返回结果的类型由元组变成一个类似元组的对象，同时具有命名的属性。</p>
</li>
<li><p><code>os.unsetenv</code>(<em>key</em>)</p>
<p>取消设置（删除）名为 <em>key</em> 的环境变量。变量名的改变会影响由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>os.system()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>fork()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execv" target="_blank" rel="noopener"><code>execv()</code></a> 触发的子进程。当系统支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> ，删除在 <code>os.environ</code> 中的变量会自动转换为对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> 的调用。但是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> 不能更新 <code>os.environ</code>，因此最好直接删除 <code>os.environ</code> 中的变量。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.unsetenv</code>，附带参数 <code>key</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 大部分的Unix系统。</p>
</li>
</ul>
<h2 id="创建文件对象"><a href="#创建文件对象" class="headerlink" title="创建文件对象"></a>创建文件对象</h2><p>这些函数创建新的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file objects</a> 。（参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>open()</code></a> 以获取打开文件描述符的相关信息。）</p>
<ul>
<li><p><code>os.fdopen</code>(<em>fd</em>, <strong>args<em>, </em></strong>kwargs*)</p>
<p>返回打开文件描述符 <em>fd</em> 对应文件的对象。类似内建 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 函数，二者接受同样的参数。不同之处在于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a> 第一个参数应该为整数。</p>
</li>
</ul>
<h2 id="文件描述符操作"><a href="#文件描述符操作" class="headerlink" title="文件描述符操作"></a>文件描述符操作</h2><p>这些函数对文件描述符所引用的 I/O 流进行操作。</p>
<p>文件描述符是一些小的整数，对应于当前进程所打开的文件。例如，标准输入的文件描述符通常是0，标准输出是1，标准错误是2。之后被进程打开的文件的文件描述符会被依次指定为3，4，5等。“文件描述符”这个词有点误导性，在 Unix 平台中套接字和管道也被文件描述符所引用。</p>
<p>当需要时，可以用 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 可以获得 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> 所对应的文件描述符。需要注意的是，直接使用文件描述符会绕过文件对象的方法，会忽略如数据内部缓冲等情况。</p>
<ul>
<li><p><code>os.close</code>(<em>fd</em>)</p>
<p>关闭文件描述符 <em>fd</em>。注解 该功能适用于低级 I/O 操作，必须用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pipe" target="_blank" rel="noopener"><code>pipe()</code></a> 返回的文件描述符。若要关闭由内建函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a> 返回的 “文件对象”，则应使用其相应的 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.close" target="_blank" rel="noopener"><code>close()</code></a> 方法。</p>
</li>
<li><p><code>os.closerange</code>(<em>fd_low</em>, <em>fd_high</em>)</p>
<p>关闭从 <em>fd_low</em> （包括）到 <em>fd_high</em> （排除）间的文件描述符，并忽略错误。类似（但快于）:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> fd <span class="keyword">in</span> range(fd_low, fd_high):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.close(fd)</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>os.copy_file_range</code>(<em>src</em>, <em>dst</em>, <em>count</em>, <em>offset_src=None</em>, <em>offset_dst=None</em>)</p>
<p>从文件描述符 <em>src</em> 复制 <em>count</em> 字节，从偏移量 <em>offset_src</em> 开始读取，到文件描述符 <em>dst</em>，从偏移量 <em>offset_dst</em> 开始写入。如果 <em>offset_src</em> 为 None，则 <em>src</em> 将从当前位置开始读取；<em>offset_dst</em> 同理。<em>src</em> 和 <em>dst</em> 指向的文件必须处于相同的文件系统，否则将会抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 被设为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EXDEV" target="_blank" rel="noopener"><code>errno.EXDEV</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 。此复制的完成没有额外的从内核到用户空间再回到内核的数据转移花费。另外，一些文件系统可能实现额外的优化。完成复制就如同打开两个二进制文件一样。返回值是复制的字节的数目。这可能低于需求的数目。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">Availability</a>: Linux kernel &gt;= 4.5 或 glibc &gt;= 2.27。<em>3.8 新版功能.</em></p>
</li>
<li><p><code>os.device_encoding</code>(<em>fd</em>)</p>
<p>如果连接到终端，则返回一个与 <em>fd</em> 关联的设备描述字符，否则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p>
</li>
<li><p><code>os.dup</code>(<em>fd</em>)</p>
<p>返回一个文件描述符 <em>fd</em> 的副本。该文件描述符的副本是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承的</a>。在 Windows 中，当复制一个标准流（0: stdin, 1: stdout, 2: stderr）时，新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">可继承的</a>。<em>在 3.4 版更改:</em> 新的文件描述符现在是不可继承的。</p>
</li>
<li><p><code>os.dup2</code>(<em>fd</em>, <em>fd2</em>, <em>inheritable=True</em>)</p>
<p>把文件描述符 <em>fd</em> 复制为 <em>fd2</em>，必要时先关闭后者。返回 <em>fd2</em>。新的文件描述符默认是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">可继承的</a>，除非在 <em>inheritable</em> 为 <code>False</code> 时，是不可继承的。<em>在 3.4 版更改:</em> 添加可选参数 <em>inheritable</em>。<em>在 3.7 版更改:</em> 成功时返回 <em>fd2</em>，以过去的版本中，总是返回 <code>None</code>。</p>
</li>
<li><p><code>os.fchmod</code>(<em>fd</em>, <em>mode</em>)</p>
<p>将 <em>fd</em> 指定文件的权限状态修改为 <em>mode</em>。可以参考 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>chmod()</code></a> 中列出 <em>mode</em> 的可用值。从Python 3.3开始，这相当于 <code>os.chmod(fd, mode)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chmod</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.fchown</code>(<em>fd</em>, <em>uid</em>, <em>gid</em>)</p>
<p>分别将 <em>fd</em> 指定文件的所有者和组 ID 修改为 <em>uid</em> 和 <em>gid</em> 的值。若不想变更其中的某个 ID，可将相应值设为 -1。参考 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chown" target="_blank" rel="noopener"><code>chown()</code></a>。从 Python 3.3 开始，这相当于 <code>os.chown(fd, uid, gid)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chown</code>，附带参数 <code>path</code>、<code>uid</code>、<code>gid</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.fdatasync</code>(<em>fd</em>)</p>
<p>强制将文件描述符 <em>fd</em> 指定文件写入磁盘。不强制更新元数据。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
<blockquote>
<p> 该功能在 MacOS 中不可用。 </p>
</blockquote>
</li>
<li><p><code>os.fpathconf</code>(<em>fd</em>, <em>name</em>)</p>
<p>返回与打开的文件有关的系统配置信息。<em>name</em> 指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX.1，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 <code>pathconf_names</code> 字典中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 <em>name</em>。如果 <em>name</em> 是一个字符串且不是已定义的名称，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。如果当前系统不支持 <em>name</em> 指定的配置名称，即使该名称存在于 <code>pathconf_names</code>，也会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，错误码为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EINVAL" target="_blank" rel="noopener"><code>errno.EINVAL</code></a>。从 Python 3.3 起，此功能等价于 <code>os.pathconf(fd, name)</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.fstat</code>(<em>fd</em>)</p>
<p>获取文件描述符 <em>fd</em> 的状态. 返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 对象。从 Python 3.3 起，此功能等价于 <code>os.stat(fd)</code>。</p>
<blockquote>
<p>参见：  <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 函数。</p>
</blockquote>
</li>
<li><p><code>os.fstatvfs</code>(<em>fd</em>)</p>
<p>返回文件系统的信息，该文件系统是文件描述符 <em>fd</em> 指向的文件所在的文件系统，与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.statvfs" target="_blank" rel="noopener"><code>statvfs()</code></a> 一样。从 Python 3.3 开始，它等效于 <code>os.statvfs(fd)</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.fsync</code>(<em>fd</em>)</p>
<p>强制将文件描述符 <em>fd</em> 指向的文件写入磁盘。在 Unix，这将调用原生 <code>fsync()</code> 函数；在 Windows，则是 MS <code>_commit()</code> 函数。如果要写入的是缓冲区内的 Python <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">文件对象</a> <em>f</em>，请先执行 <code>f.flush()</code>，然后执行 <code>os.fsync(f.fileno())</code>，以确保与 <em>f</em> 关联的所有内部缓冲区都写入磁盘。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p>
</li>
<li><p><code>os.ftruncate</code>(<em>fd</em>, <em>length</em>)</p>
<p>截断文件描述符 <em>fd</em> 指向的文件，以使其最大为 <em>length</em> 字节。从 Python 3.3 开始，它等效于 <code>os.truncate(fd, length)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.truncate</code>，附带参数 <code>fd</code>, <code>length</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.5 版更改:</em> 添加了 Windows 支持</p>
</li>
<li><p><code>os.get_blocking</code>(<em>fd</em>)</p>
<p>获取文件描述符的阻塞模式：如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_NONBLOCK" target="_blank" rel="noopener"><code>O_NONBLOCK</code></a> 标志位，返回 <code>False</code>，如果该标志位被清除，返回 <code>True</code>。参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.set_blocking" target="_blank" rel="noopener"><code>set_blocking()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.socket.setblocking" target="_blank" rel="noopener"><code>socket.socket.setblocking()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.5 新版功能.</em></p>
</li>
<li><p><code>os.isatty</code>(<em>fd</em>)</p>
<p>如果文件描述符 <em>fd</em> 打开且已连接至 tty 设备（或类 tty 设备），返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><code>os.lockf</code>(<em>fd</em>, <em>cmd</em>, <em>len</em>)</p>
<p>在打开的文件描述符上，使用、测试或删除 POSIX 锁。<em>fd</em> 是一个打开的文件描述符。<em>cmd</em> 指定要进行的操作，它们是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_LOCK" target="_blank" rel="noopener"><code>F_LOCK</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_TLOCK" target="_blank" rel="noopener"><code>F_TLOCK</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_ULOCK" target="_blank" rel="noopener"><code>F_ULOCK</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_TEST" target="_blank" rel="noopener"><code>F_TEST</code></a> 中的一个。<em>len</em> 指定哪部分文件需要锁定。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.lockf</code>，附带参数 <code>fd</code>、<code>cmd</code>、<code>len</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.F_LOCK</code></p>
</li>
<li><p><code>os.F_TLOCK</code></p>
</li>
<li><p><code>os.F_ULOCK</code></p>
</li>
<li><p><code>os.F_TEST</code></p>
<p>标志位，用于指定 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lockf" target="_blank" rel="noopener"><code>lockf()</code></a> 进行哪一种操作。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.lseek</code>(<em>fd</em>, <em>pos</em>, <em>how</em>)</p>
<p>将文件描述符 <em>fd</em> 的当前位置设置为 <em>pos</em>，位置的计算方式 <em>how</em> 如下：设置为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.SEEK_SET" target="_blank" rel="noopener"><code>SEEK_SET</code></a> 或 <code>0</code> 表示从文件开头计算，设置为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.SEEK_CUR" target="_blank" rel="noopener"><code>SEEK_CUR</code></a> 或 <code>1</code> 表示从文件当前位置计算，设置为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.SEEK_END" target="_blank" rel="noopener"><code>SEEK_END</code></a> 或 <code>2</code> 表示文件末尾计算。返回新指针位置，这个位置是从文件开头计算的，单位是字节。</p>
</li>
<li><p><code>os.SEEK_SET</code></p>
</li>
<li><p><code>os.SEEK_CUR</code></p>
</li>
<li><p><code>os.SEEK_END</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lseek" target="_blank" rel="noopener"><code>lseek()</code></a> 函数的参数，它们的值分别为 0、1 和 2。<em>3.3 新版功能:</em> 某些操作系统可能支持其他值，例如 <code>os.SEEK_HOLE</code> 或 <code>os.SEEK_DATA</code>。</p>
</li>
<li><p><code>os.open</code>(<em>path</em>, <em>flags</em>, <em>mode=0o777</em>, <em>**, </em>dir_fd=None*)</p>
<p>打开文件 <em>path</em>，根据 <em>flags</em> 设置各种标志位，并根据 <em>mode</em> 设置其权限状态。当计算 <em>mode</em> 时，会首先根据当前 umask 值将部分权限去除。本方法返回新文件的描述符。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承</a> 的。有关 flag 和 mode 取值的说明，请参见 C 运行时文档。标志位常量（如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_RDONLY" target="_blank" rel="noopener"><code>O_RDONLY</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_WRONLY" target="_blank" rel="noopener"><code>O_WRONLY</code></a>）在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中定义。特别地，在 Windows 上需要添加 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_BINARY" target="_blank" rel="noopener"><code>O_BINARY</code></a> 才能以二进制模式打开文件。本函数带有 <em>dir_fd</em> 参数，支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>open</code>，附带参数 <code>path</code>、<code>mode</code>、<code>flags</code>。<em>在 3.4 版更改:</em> 新的文件描述符现在是不可继承的。</p>
<blockquote>
<p>注解：本函数适用于底层的 I/O。常规用途请使用内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>，该函数的 <code>read()</code> 和 <code>write()</code> 方法（及其他方法）会返回 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">文件对象</a>。要将文件描述符包装在文件对象中，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a>。</p>
</blockquote>
<p><em>3.3 新版功能:</em> <em>dir_fd</em> 参数。</p>
<p><em>在 3.5 版更改:</em> 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>以下常量是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>open()</code></a> 函数 <em>flags</em> 参数的选项。可以用按位或运算符 <code>|</code> 将它们组合使用。部分常量并非在所有平台上都可用。有关其可用性和用法的说明，请参阅 <em><a href="https://manpages.debian.org/open(2" target="_blank" rel="noopener">open(2)</a>)</em> 手册（Unix 上）或 <a href="https://msdn.microsoft.com/en-us/library/z0kc8e3z.aspx" target="_blank" rel="noopener">MSDN</a> （Windows 上）。</p>
<ul>
<li><p><code>os.O_RDONLY</code></p>
</li>
<li><p><code>os.O_WRONLY</code></p>
</li>
<li><p><code>os.O_RDWR</code></p>
</li>
<li><p><code>os.O_APPEND</code></p>
</li>
<li><p><code>os.O_CREAT</code></p>
</li>
<li><p><code>os.O_EXCL</code></p>
</li>
<li><p><code>os.O_TRUNC</code></p>
<p>上述常量在 Unix 和 Windows 上均可用。</p>
</li>
<li><p><code>os.O_DSYNC</code></p>
</li>
<li><p><code>os.O_RSYNC</code></p>
</li>
<li><p><code>os.O_SYNC</code></p>
</li>
<li><p><code>os.O_NDELAY</code></p>
</li>
<li><p><code>os.O_NONBLOCK</code></p>
</li>
<li><p><code>os.O_NOCTTY</code></p>
</li>
<li><p><code>os.O_CLOEXEC</code></p>
<p>这个常数仅在 Unix 系统中可用。<em>在 3.3 版更改:</em> 增加 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_CLOEXEC" target="_blank" rel="noopener"><code>O_CLOEXEC</code></a> 常量。</p>
</li>
<li><p><code>os.O_BINARY</code></p>
</li>
<li><p><code>os.O_NOINHERIT</code></p>
</li>
<li><p><code>os.O_SHORT_LIVED</code></p>
</li>
<li><p><code>os.O_TEMPORARY</code></p>
</li>
<li><p><code>os.O_RANDOM</code></p>
</li>
<li><p><code>os.O_SEQUENTIAL</code></p>
</li>
<li><p><code>os.O_TEXT</code></p>
<p>这个常数仅在 Windows 系统中可用。</p>
</li>
<li><p><code>os.O_ASYNC</code></p>
</li>
<li><p><code>os.O_DIRECT</code></p>
</li>
<li><p><code>os.O_DIRECTORY</code></p>
</li>
<li><p><code>os.O_NOFOLLOW</code></p>
</li>
<li><p><code>os.O_NOATIME</code></p>
</li>
<li><p><code>os.O_PATH</code></p>
</li>
<li><p><code>os.O_TMPFILE</code></p>
</li>
<li><p><code>os.O_SHLOCK</code></p>
</li>
<li><p><code>os.O_EXLOCK</code></p>
<p>上述常量是扩展常量，如果 C 库未定义它们，则不存在。<em>在 3.4 版更改:</em> 在支持的系统上增加 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_PATH" target="_blank" rel="noopener"><code>O_PATH</code></a>。增加 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_TMPFILE" target="_blank" rel="noopener"><code>O_TMPFILE</code></a>，仅在 Linux Kernel 3.11 或更高版本可用。</p>
</li>
<li><p><code>os.openpty</code>()</p>
<p>打开一对新的伪终端，返回一对文件描述符 <code>（主，从）</code>，分别为 pty 和 tty。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承</a> 的。对于（稍微）轻量一些的方法，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/pty.html#module-pty" target="_blank" rel="noopener"><code>pty</code></a> 模块。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 某些 Unix。<em>在 3.4 版更改:</em> 新的文件描述符不再可继承。</p>
</li>
<li><p><code>os.pipe</code>()</p>
<p>创建一个管道，返回一对分别用于读取和写入的文件描述符 <code>(r, w)</code>。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承</a> 的。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.4 版更改:</em> 新的文件描述符不再可继承。</p>
</li>
<li><p><code>os.pipe2</code>(<em>flags</em>)</p>
<p>创建带有 <em>flags</em> 标志位的管道。可通过对以下一个或多个值进行“或”运算来构造这些 <em>flags</em>：<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_NONBLOCK" target="_blank" rel="noopener"><code>O_NONBLOCK</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_CLOEXEC" target="_blank" rel="noopener"><code>O_CLOEXEC</code></a>。返回一对分别用于读取和写入的文件描述符 <code>(r, w)</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 某些 Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.posix_fallocate</code>(<em>fd</em>, <em>offset</em>, <em>len</em>)</p>
<p>确保为 <em>fd</em> 指向的文件分配了足够的磁盘空间，该空间从偏移量 <em>offset</em> 开始，到 <em>len</em> 字节为止。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.posix_fadvise</code>(<em>fd</em>, <em>offset</em>, <em>len</em>, <em>advice</em>)</p>
<p>声明即将以特定模式访问数据，使内核可以提前进行优化。数据范围是从 <em>fd</em> 所指向文件的 <em>offset</em> 开始，持续 <em>len</em> 个字节。<em>advice</em> 的取值是如下之一：<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_NORMAL" target="_blank" rel="noopener"><code>POSIX_FADV_NORMAL</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_SEQUENTIAL" target="_blank" rel="noopener"><code>POSIX_FADV_SEQUENTIAL</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_RANDOM" target="_blank" rel="noopener"><code>POSIX_FADV_RANDOM</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_NOREUSE" target="_blank" rel="noopener"><code>POSIX_FADV_NOREUSE</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_WILLNEED" target="_blank" rel="noopener"><code>POSIX_FADV_WILLNEED</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_DONTNEED" target="_blank" rel="noopener"><code>POSIX_FADV_DONTNEED</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.POSIX_FADV_NORMAL</code></p>
</li>
<li><p><code>os.POSIX_FADV_SEQUENTIAL</code></p>
</li>
<li><p><code>os.POSIX_FADV_RANDOM</code></p>
</li>
<li><p><code>os.POSIX_FADV_NOREUSE</code></p>
</li>
<li><p><code>os.POSIX_FADV_WILLNEED</code></p>
</li>
<li><p><code>os.POSIX_FADV_DONTNEED</code></p>
<p>用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_fadvise" target="_blank" rel="noopener"><code>posix_fadvise()</code></a> 的 <em>advice</em> 参数的标志位，指定可能使用的访问模式。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.pread</code>(<em>fd</em>, <em>n</em>, <em>offset</em>)</p>
<p>从文件描述符 <em>fd</em> 所指向文件的偏移位置 <em>offset</em> 开始，读取至多 <em>n</em> 个字节，而保持文件偏移量不变。返回所读取字节的字节串 (bytestring)。如果到达了 <em>fd</em> 指向的文件末尾，则返回空字节对象。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.preadv</code>(<em>fd</em>, <em>buffers</em>, <em>offset</em>, <em>flags=0</em>)</p>
<p>从文件描述符 <em>fd</em> 所指向文件的偏移位置 <em>offset</em> 开始，将数据读取至可变 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 缓冲区 <em>buffers</em> 中，保持文件偏移量不变。将数据依次存放到每个缓冲区中，填满一个后继续存放到序列中的下一个缓冲区，来保存其余数据。flags 参数可以由零个或多个标志位进行按位或运算来得到：<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.RWF_HIPRI" target="_blank" rel="noopener"><code>RWF_HIPRI</code></a><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.RWF_NOWAIT" target="_blank" rel="noopener"><code>RWF_NOWAIT</code></a>返回实际读取的字节总数，该总数可以小于所有对象的总容量。操作系统可能对允许使用的缓冲区数量有限制（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 获取 <code>&#39;SC_IOV_MAX&#39;</code> 值）。本方法结合了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.readv" target="_blank" rel="noopener"><code>os.readv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pread" target="_blank" rel="noopener"><code>os.pread()</code></a> 的功能。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 2.6.30 或更高版本，FreeBSD 6.0 或更高版本，OpenBSD 2.7 或更高版本。使用标志位需要 Linux 4.6 或更高版本。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>os.RWF_NOWAIT</code></p>
<p>不要等待无法立即获得的数据。如果指定了此标志，那么当需要从后备存储器中读取数据，或等待文件锁时，系统调用将立即返回。如果成功读取数据，则返回读取的字节数。如果未读取到数据，则返回 <code>-1</code>，并将错误码 errno 置为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EAGAIN" target="_blank" rel="noopener"><code>errno.EAGAIN</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 4.14 或更高版本。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>os.RWF_HIPRI</code></p>
<p>高优先级读/写。允许基于块的文件系统对设备进行轮询，这样可以降低延迟，但可能会占用更多资源。目前在 Linux 上，此功能仅在使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_DIRECT" target="_blank" rel="noopener"><code>O_DIRECT</code></a> 标志打开的文件描述符上可用。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 4.6 或更高版本。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>os.pwrite</code>(<em>fd</em>, <em>str</em>, <em>offset</em>)</p>
<p>将 <em>str</em> 中的字节串 (bytestring) 写入文件描述符 <em>fd</em> 的偏移位置 <em>offset</em> 处，保持文件偏移量不变。返回实际写入的字节数。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.pwritev</code>(<em>fd</em>, <em>buffers</em>, <em>offset</em>, <em>flags=0</em>)</p>
<p>将缓冲区 <em>buffers</em> 的内容写入文件描述符 <em>fd</em> 的偏移位置 <em>offset</em> 处，保持文件偏移量不变。缓冲区 <em>buffers</em> 必须是由 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 组成的序列。缓冲区以数组顺序处理。先写入第一个缓冲区的全部内容，再写入第二个缓冲区，照此继续。flags 参数可以由零个或多个标志位进行按位或运算来得到：<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.RWF_DSYNC" target="_blank" rel="noopener"><code>RWF_DSYNC</code></a><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.RWF_SYNC" target="_blank" rel="noopener"><code>RWF_SYNC</code></a>返回实际写入的字节总数。操作系统可能对允许使用的缓冲区数量有限制（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 获取 <code>&#39;SC_IOV_MAX&#39;</code> 值）。本方法结合了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.writev" target="_blank" rel="noopener"><code>os.writev()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pwrite" target="_blank" rel="noopener"><code>os.pwrite()</code></a> 的功能。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 2.6.30 或更高版本，FreeBSD 6.0 或更高版本，OpenBSD 2.7 或更高版本。使用标志位需要 Linux 4.7 或更高版本。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>os.RWF_DSYNC</code></p>
<p>提供立即写入功能，等效于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_DSYNC" target="_blank" rel="noopener"><code>O_DSYNC</code></a> <code>open(2)</code> 标志。该标志仅作用于系统调用写入的数据。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 4.7 或更高版本。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>os.RWF_SYNC</code></p>
<p>提供立即写入功能，等效于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_SYNC" target="_blank" rel="noopener"><code>O_SYNC</code></a> <code>open(2)</code> 标志。该标志仅作用于系统调用写入的数据。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 4.7 或更高版本。<em>3.7 新版功能.</em></p>
</li>
<li><p><code>os.read</code>(<em>fd</em>, <em>n</em>)</p>
<p>从文件描述符 <em>fd</em> 中读取至多 <em>n</em> 个字节。返回所读取字节的字节串 (bytestring)。如果到达了 <em>fd</em> 指向的文件末尾，则返回空字节对象。</p>
<blockquote>
<p> 该功能适用于低级 I/O 操作，必须用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pipe" target="_blank" rel="noopener"><code>pipe()</code></a> 返回的文件描述符。若要读取由内建函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a> 返回的 “文件对象”，则应使用其相应的 <code>read()</code> 或 <code>readline()</code> 方法。 </p>
</blockquote>
<p> <em>在 3.5 版更改:</em> 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。 </p>
</li>
<li><p><code>os.sendfile</code>(<em>out</em>, <em>in</em>, <em>offset</em>, <em>count</em>)</p>
<p><code>os.sendfile</code>(<em>out</em>, <em>in</em>, <em>offset</em>, <em>count</em>, [<em>headers</em>, ][<em>trailers</em>, ]<em>flags=0</em>)</p>
<p>将文件描述符 <em>in</em> 中的 <em>count</em> 字节复制到文件描述符 <em>out</em> 的偏移位置 <em>offset</em> 处。返回复制的字节数，如果到达 EOF，返回 0。</p>
<p>定义了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sendfile" target="_blank" rel="noopener"><code>sendfile()</code></a> 的所有平台均支持第一种函数用法。</p>
<p>在 Linux 上，将 <em>offset</em> 设置为 <code>None</code>，则从 <em>in</em> 的当前位置开始读取，并更新 <em>in</em> 的位置。</p>
<p>第二种函数用法可以在 Mac OS X 和 FreeBSD 上使用，其中，<em>headers</em> 和 <em>trailers</em> 是任意的缓冲区序列，它们分别在写入 <em>in</em> 的数据前、后被写入。返回值与第一种用法相同。</p>
<p>在 Mac OS X 和 FreeBSD 上，将 <em>count</em> 设为 0 表示持续复制直到 <em>in</em> 的结尾。</p>
<p>所有平台都支持将套接字作为 <em>out</em> 文件描述符，有些平台也支持其他类型（如常规文件或管道）。</p>
<p>跨平台应用程序不应使用 <em>headers</em>、<em>trailers</em> 和 <em>flags</em> 参数。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
<blockquote>
<p> 注解：有关 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sendfile" target="_blank" rel="noopener"><code>sendfile()</code></a> 的高级封装，参见 <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.socket.sendfile" target="_blank" rel="noopener"><code>socket.socket.sendfile()</code></a>。</p>
</blockquote>
</li>
<li><p><code>os.set_blocking</code>(<em>fd</em>, <em>blocking</em>)</p>
<p>设置指定文件描述符的阻塞模式：如果 blocking 为 <code>False</code>，则为该描述符设置 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_NONBLOCK" target="_blank" rel="noopener"><code>O_NONBLOCK</code></a> 标志位，反之则清除该标志位。参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.get_blocking" target="_blank" rel="noopener"><code>get_blocking()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.socket.setblocking" target="_blank" rel="noopener"><code>socket.socket.setblocking()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.5 新版功能.</em></p>
</li>
<li><p><code>os.SF_NODISKIO</code></p>
</li>
<li><p><code>os.SF_MNOWAIT</code></p>
</li>
<li><p><code>os.SF_SYNC</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sendfile" target="_blank" rel="noopener"><code>sendfile()</code></a> 函数的参数（假设当前实现支持这些参数）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.readv</code>(<em>fd</em>, <em>buffers</em>)</p>
<p>从文件描述符 <em>fd</em> 将数据读取至多个可变的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 缓冲区 <em>buffers</em> 中。将数据依次存放到每个缓冲区中，填满一个后继续存放到序列中的下一个缓冲区，来保存其余数据。返回实际读取的字节总数，该总数可以小于所有对象的总容量。操作系统可能对允许使用的缓冲区数量有限制（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 获取 <code>&#39;SC_IOV_MAX&#39;</code> 值）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.tcgetpgrp</code>(<em>fd</em>)</p>
<p>返回与 <em>fd</em> 指定的终端相关联的进程组（<em>fd</em> 是由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 返回的已打开的文件描述符）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.tcsetpgrp</code>(<em>fd</em>, <em>pg</em>)</p>
<p>设置与 <em>fd</em> 指定的终端相关联的进程组为 <em>pg\</em>（<em>fd</em> 是由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 返回的已打开的文件描述符）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.ttyname</code>(<em>fd</em>)</p>
<p>返回一个字符串，该字符串表示与文件描述符 <em>fd</em> 关联的终端。如果 <em>fd</em> 没有与终端关联，则抛出异常。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.write</code>(<em>fd</em>, <em>str</em>)</p>
<p>将 <em>str</em> 中的字节串 (bytestring) 写入文件描述符 <em>fd</em>。返回实际写入的字节数。</p>
<blockquote>
<p> 该功能适用于低级 I/O 操作，必须用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pipe" target="_blank" rel="noopener"><code>pipe()</code></a> 返回的文件描述符。若要写入由内建函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdout" target="_blank" rel="noopener"><code>sys.stdout</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stderr" target="_blank" rel="noopener"><code>sys.stderr</code></a> 返回的 “文件对象”，则应使用其相应的 <code>write()</code> 方法。 </p>
</blockquote>
<p> <em>在 3.5 版更改:</em> 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。 </p>
</li>
<li><p><code>os.writev</code>(<em>fd</em>, <em>buffers</em>)</p>
<p>将缓冲区 <em>buffers</em> 的内容写入文件描述符 <em>fd</em>。缓冲区 <em>buffers</em> 必须是由 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 组成的序列。缓冲区以数组顺序处理。先写入第一个缓冲区的全部内容，再写入第二个缓冲区，照此继续。</p>
<p>返回实际写入的字节总数。</p>
<p>操作系统可能对允许使用的缓冲区数量有限制（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 获取 <code>&#39;SC_IOV_MAX&#39;</code> 值）。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
<p><em>3.3 新版功能.</em></p>
</li>
</ul>
<h3 id="查询终端的尺寸"><a href="#查询终端的尺寸" class="headerlink" title="查询终端的尺寸"></a>查询终端的尺寸</h3><p><em>3.3 新版功能.</em></p>
<ul>
<li><p><code>os.get_terminal_size</code>(<em>fd=STDOUT_FILENO</em>)</p>
<p>返回终端窗口的尺寸，格式为 <code>(columns, lines)</code>，它是类型为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.terminal_size" target="_blank" rel="noopener"><code>terminal_size</code></a> 的元组。可选参数 <code>fd</code> （默认为 <code>STDOUT_FILENO</code> 或标准输出）指定应查询的文件描述符。如果文件描述符未连接到终端，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_terminal_size" target="_blank" rel="noopener"><code>shutil.get_terminal_size()</code></a> 是供常规使用的高阶函数，<code>os.get_terminal_size</code> 是其底层的实现。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p>
</li>
<li><p><em>class</em> <code>os.terminal_size</code></p>
<p>元组的子类，存储终端窗口尺寸 <code>(columns, lines)</code>。<code>columns</code>终端窗口的宽度，单位为字符。<code>lines</code>终端窗口的高度，单位为字符。</p>
</li>
</ul>
<h3 id="文件描述符的继承"><a href="#文件描述符的继承" class="headerlink" title="文件描述符的继承"></a>文件描述符的继承</h3><p><em>3.4 新版功能.</em></p>
<p>每个文件描述符都有一个 “inheritable”（可继承）标志位，该标志位控制了文件描述符是否可以由子进程继承。从 Python 3.4 开始，由 Python 创建的文件描述符默认是不可继承的。</p>
<p>在 UNIX 上，执行新程序时，不可继承的文件描述符在子进程中是关闭的，其他文件描述符将被继承。</p>
<p>在 Windows 上，不可继承的句柄和文件描述符在子进程中是关闭的，但标准流（文件描述符 0、1 和 2 即标准输入、标准输出和标准错误）是始终继承的。如果使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 函数，所有可继承的句柄和文件描述符都将被继承。如果使用 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 模块，将关闭除标准流以外的所有文件描述符，并且仅当 <em>close_fds</em> 参数为 <code>False</code> 时才继承可继承的句柄。</p>
<ul>
<li><p><code>os.get_inheritable</code>(<em>fd</em>)</p>
<p>获取指定文件描述符的“可继承”标志位（为布尔值）。</p>
</li>
<li><p><code>os.set_inheritable</code>(<em>fd</em>, <em>inheritable</em>)</p>
<p>设置指定文件描述符的“可继承”标志位。</p>
</li>
<li><p><code>os.get_handle_inheritable</code>(<em>handle</em>)</p>
<p>获取指定句柄的“可继承”标志位（为布尔值）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。</p>
</li>
<li><p><code>os.set_handle_inheritable</code>(<em>handle</em>, <em>inheritable</em>)</p>
<p>设置指定句柄的“可继承”标志位。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。</p>
</li>
</ul>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>在某些 Unix 平台上，许多函数支持以下一项或多项功能：</p>
<ul>
<li><p><strong>指定文件描述符为参数：</strong> 通常在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中提供给函数的 <em>path</em> 参数必须是表示文件路径的字符串，但是，某些函数现在可以接受其 <em>path</em> 参数为打开文件描述符，该函数将对描述符指向的文件进行操作。（对于 POSIX 系统，Python 将调用以 <code>f</code> 开头的函数变体（如调用 <code>fchdir</code> 而不是 <code>chdir</code>）。）</p>
<p>可以用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_fd" target="_blank" rel="noopener"><code>os.supports_fd</code></a> 检查某个函数在你的平台上是否支持将 <em>path</em> 参数指定为文件描述符。如果不支持，使用该功能将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p>
<p>如果该函数还支持 <em>dir_fd</em> 或 <em>follow_symlinks</em> 参数，那么用文件描述符作为 <em>path</em> 后就不能再指定上述参数了。</p>
</li>
<li><p><strong>基于目录描述符的相对路径：</strong> 如果 <em>dir_fd</em> 不是 <code>None</code>，它就应该是一个指向目录的文件描述符，这时待操作的 path 应该是相对路径，相对路径是相对于前述目录的。如果 path 是绝对路径，则 <em>dir_fd</em> 将被忽略。（对于 POSIX 系统，Python 将调用该函数的变体，变体以 <code>at</code> 结尾，可能以 <code>f</code> 开头（如调用 <code>faccessat</code> 而不是 <code>access</code>）。</p>
<p>可以用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_dir_fd" target="_blank" rel="noopener"><code>os.supports_dir_fd</code></a> 检查某个函数在你的平台上是否支持 <em>dir_fd</em>。如果不支持，使用该功能将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p>
</li>
<li><p><strong>不跟踪符号链接：</strong> 如果 <em>follow_symlinks</em> 为 <code>False</code>，并且待操作路径的最后一个元素是符号链接，则该函数将在符号链接本身而不是链接所指向的文件上操作。（对于 POSIX 系统，Python 将调用该函数的 <code>l...</code> 变体。）</p>
<p>可以用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_follow_symlinks" target="_blank" rel="noopener"><code>os.supports_follow_symlinks</code></a> 检查某个函数在你的平台上是否支持 <em>follow_symlinks</em>。如果不支持，使用该功能将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p>
</li>
<li><p><code>os.access</code>(<em>path</em>, <em>mode</em>, <em>**, </em>dir_fd=None<em>, </em>effective_ids=False<em>, </em>follow_symlinks=True*)</p>
<p>使用 实际用户ID/用户组ID 测试对 <em>path</em> 的访问。请注意，大多数测试操作将使用 有效用户ID/用户组ID，因此可以在 suid/sgid 环境中运用此例程，来测试调用用户是否具有对 <em>path</em> 的指定访问权限。<em>mode</em> 为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_OK" target="_blank" rel="noopener"><code>F_OK</code></a> 时用于测试 <em>path</em> 是否存在，也可以对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.R_OK" target="_blank" rel="noopener"><code>R_OK</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.W_OK" target="_blank" rel="noopener"><code>W_OK</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.X_OK" target="_blank" rel="noopener"><code>X_OK</code></a> 中的一个或多个进行“或”运算来测试指定权限。允许访问则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>，否则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>。更多信息请参见 Unix 手册页 <em><a href="https://manpages.debian.org/access(2" target="_blank" rel="noopener">access(2)</a>)</em>。本函数支持指定 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。如果 <em>effective_ids</em> 为 <code>True</code>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>access()</code></a> 将使用 有效用户ID/用户组ID 而非 实际用户ID/用户组ID 进行访问检查。您的平台可能不支持 <em>effective_ids</em>，您可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_effective_ids" target="_blank" rel="noopener"><code>os.supports_effective_ids</code></a> 检查它是否可用。如果不可用，使用它时会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p>
<blockquote>
<p>注解：使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>access()</code></a> 来检查用户是否具有某项权限（如打开文件的权限），然后再使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 打开文件，这样做存在一个安全漏洞，因为用户可能会在检查和打开文件之间的时间里做其他操作。推荐使用 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-eafp" target="_blank" rel="noopener">EAFP</a> 技术。如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> os.access(<span class="string">"myfile"</span>, os.R_OK):</span><br><span class="line">&gt;     <span class="keyword">with</span> open(<span class="string">"myfile"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">&gt;         <span class="keyword">return</span> fp.read()</span><br><span class="line">&gt; <span class="keyword">return</span> <span class="string">"some default data"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>​      最好写成: </p>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">try</span>:</span><br><span class="line">&gt;     fp = open(<span class="string">"myfile"</span>)</span><br><span class="line">&gt; <span class="keyword">except</span> PermissionError:</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="string">"some default data"</span></span><br><span class="line">&gt; <span class="keyword">else</span>:</span><br><span class="line">&gt;     <span class="keyword">with</span> fp:</span><br><span class="line">&gt;         <span class="keyword">return</span> fp.read()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>即使 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>access()</code></a> 指示 I/O 操作会成功，但实际操作仍可能失败，尤其是对网络文件系统的操作，其权限语义可能超出常规的 POSIX 权限位模型。</p>
</blockquote>
<ul>
<li><p><code>os.F_OK</code></p>
</li>
<li><p><code>os.R_OK</code></p>
</li>
<li><p><code>os.W_OK</code></p>
</li>
<li><p><code>os.X_OK</code></p>
<p>作为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>access()</code></a> 的 <em>mode</em> 参数的可选值，分别测试 <em>path</em> 的存在性、可读性、可写性和可执行性。</p>
</li>
<li><p><code>os.chdir</code>(<em>path</em>)</p>
<p>将当前工作目录更改为 <em>path</em>。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。其中，描述符必须指向打开的目录，不能是打开的文件。本函数可以抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 及其子类的异常，如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileNotFoundError" target="_blank" rel="noopener"><code>FileNotFoundError</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#PermissionError" target="_blank" rel="noopener"><code>PermissionError</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotADirectoryError" target="_blank" rel="noopener"><code>NotADirectoryError</code></a> 异常。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chdir</code>，附带参数 <code>path</code>。<em>3.3 新版功能:</em> 在某些平台上新增支持将 <em>path</em> 参数指定为文件描述符。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.chflags</code>(<em>path</em>, <em>flags</em>, <em>**, </em>follow_symlinks=True*)</p>
<p>将 <em>path</em> 的 flags 设置为其他由数字表示的 <em>flags</em>。<em>flags</em> 可以用以下值按位或组合起来（以下值在 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中定义）：<a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_NODUMP" target="_blank" rel="noopener"><code>stat.UF_NODUMP</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_IMMUTABLE" target="_blank" rel="noopener"><code>stat.UF_IMMUTABLE</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_APPEND" target="_blank" rel="noopener"><code>stat.UF_APPEND</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_OPAQUE" target="_blank" rel="noopener"><code>stat.UF_OPAQUE</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_NOUNLINK" target="_blank" rel="noopener"><code>stat.UF_NOUNLINK</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_COMPRESSED" target="_blank" rel="noopener"><code>stat.UF_COMPRESSED</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_HIDDEN" target="_blank" rel="noopener"><code>stat.UF_HIDDEN</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_ARCHIVED" target="_blank" rel="noopener"><code>stat.SF_ARCHIVED</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_IMMUTABLE" target="_blank" rel="noopener"><code>stat.SF_IMMUTABLE</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_APPEND" target="_blank" rel="noopener"><code>stat.SF_APPEND</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_NOUNLINK" target="_blank" rel="noopener"><code>stat.SF_NOUNLINK</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_SNAPSHOT" target="_blank" rel="noopener"><code>stat.SF_SNAPSHOT</code></a>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chflags</code>，附带参数 <code>path</code>、<code>flags</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能:</em> <em>follow_symlinks</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.chmod</code>(<em>path</em>, <em>mode</em>, <em>**, </em>dir_fd=None<em>, </em>follow_symlinks=True*)</p>
<p>将 <em>path</em> 的 mode 更改为其他由数字表示的 <em>mode</em>。<em>mode</em> 可以用以下值之一，也可以将它们按位或组合起来（以下值在 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中定义）：</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ISUID" target="_blank" rel="noopener"><code>stat.S_ISUID</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ISGID" target="_blank" rel="noopener"><code>stat.S_ISGID</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ENFMT" target="_blank" rel="noopener"><code>stat.S_ENFMT</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ISVTX" target="_blank" rel="noopener"><code>stat.S_ISVTX</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IREAD" target="_blank" rel="noopener"><code>stat.S_IREAD</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IWRITE" target="_blank" rel="noopener"><code>stat.S_IWRITE</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IEXEC" target="_blank" rel="noopener"><code>stat.S_IEXEC</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRWXU" target="_blank" rel="noopener"><code>stat.S_IRWXU</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRUSR" target="_blank" rel="noopener"><code>stat.S_IRUSR</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IWUSR" target="_blank" rel="noopener"><code>stat.S_IWUSR</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IXUSR" target="_blank" rel="noopener"><code>stat.S_IXUSR</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRWXG" target="_blank" rel="noopener"><code>stat.S_IRWXG</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRGRP" target="_blank" rel="noopener"><code>stat.S_IRGRP</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IWGRP" target="_blank" rel="noopener"><code>stat.S_IWGRP</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IXGRP" target="_blank" rel="noopener"><code>stat.S_IXGRP</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRWXO" target="_blank" rel="noopener"><code>stat.S_IRWXO</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IROTH" target="_blank" rel="noopener"><code>stat.S_IROTH</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IWOTH" target="_blank" rel="noopener"><code>stat.S_IWOTH</code></a></li>
<li><p><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IXOTH" target="_blank" rel="noopener"><code>stat.S_IXOTH</code></a></p>
<p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符</a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">指定基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。 </p>
</li>
</ul>
<blockquote>
<p> 尽管 Windows 支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>chmod()</code></a>，但只能用它设置文件的只读标志（<code>stat.S_IWRITE</code> 和 <code>stat.S_IREAD</code> 常量或对应的整数值）。所有其他标志位都会被忽略。</p>
</blockquote>
</li>
</ul>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chmod</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。</p>
<p><em>3.3 新版功能:</em> 添加了指定 <em>path</em> 为文件描述符的支持，以及 <em>dir_fd</em> 和 <em>follow_symlinks</em> 参数。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
<ul>
<li><p><code>os.chown</code>(<em>path</em>, <em>uid</em>, <em>gid</em>, <em>**, </em>dir_fd=None<em>, </em>follow_symlinks=True*)</p>
<p>将 <em>path</em> 的用户和组 ID 分别修改为数字形式的 <em>uid</em> 和 <em>gid</em>。若要使其中某个 ID 保持不变，请将其置为 -1。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符</a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">指定基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。参见更高阶的函数 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.chown" target="_blank" rel="noopener"><code>shutil.chown()</code></a>，除了数字 ID 之外，它也接受名称。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chown</code>，附带参数 <code>path</code>、<code>uid</code>、<code>gid</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能:</em> 添加了指定 <em>path</em> 为文件描述符的支持，以及 <em>dir_fd</em> 和 <em>follow_symlinks</em> 参数。<em>在 3.6 版更改:</em> 支持 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.chroot</code>(<em>path</em>)</p>
<p>将当前进程的根目录更改为 <em>path</em>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.fchdir</code>(<em>fd</em>)</p>
<p>将当前工作目录更改为文件描述符 <em>fd</em> 指向的目录。fd 必须指向打开的目录而非文件。从 Python 3.3 开始，它等效于 <code>os.chdir(fd)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chdir</code>，附带参数 <code>path</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.getcwd</code>()</p>
<p>返回表示当前工作目录的字符串。</p>
</li>
<li><p><code>os.getcwdb</code>()</p>
<p>返回表示当前工作目录的字节串 (bytestring)。<em>在 3.8 版更改:</em> 在 Windows 上，本函数现在会使用 UTF-8 编码格式而不是 ANSI 代码页：请参看 <a href="https://www.python.org/dev/peps/pep-0529" target="_blank" rel="noopener"><strong>PEP 529</strong></a> 了解具体原因。 该函数在 Windows 上不再被弃用。</p>
</li>
<li><p><code>os.lchflags</code>(<em>path</em>, <em>flags</em>)</p>
<p>将 <em>path</em> 的 flags 设置为其他由数字表示的 <em>flags</em>，与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chflags" target="_blank" rel="noopener"><code>chflags()</code></a> 类似，但不跟踪符号链接。从 Python 3.3 开始，它等效于 <code>os.chflags(path, flags, follow_symlinks=False)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chflags</code>，附带参数 <code>path</code>、<code>flags</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.lchmod</code>(<em>path</em>, <em>mode</em>)</p>
<p>将 <em>path</em> 的权限状态修改为 <em>mode</em>。如果 path 是符号链接，则影响符号链接本身而非链接目标。可以参考 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>chmod()</code></a> 中列出 <em>mode</em> 的可用值。从 Python 3.3 开始，它等效于 <code>os.chmod(path, mode, follow_symlinks=False)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chmod</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.lchown</code>(<em>path</em>, <em>uid</em>, <em>gid</em>)</p>
<p>将 <em>path</em> 的用户和组 ID 分别修改为数字形式的 <em>uid</em> 和 <em>gid</em>，本函数不跟踪符号链接。从 Python 3.3 开始，它等效于 <code>os.chown(path, uid, gid, follow_symlinks=False)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chown</code>，附带参数 <code>path</code>、<code>uid</code>、<code>gid</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.link</code>(<em>src</em>, <em>dst</em>, <em>**, </em>src_dir_fd=None<em>, </em>dst_dir_fd=None<em>, </em>follow_symlinks=True*)</p>
<p>创建一个指向 <em>src</em> 的硬链接，名为 <em>dst</em>。本函数支持将 <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 中的一个或两个指定为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>，支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.link</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加了对 Windows 的支持。<em>3.3 新版功能:</em> 添加 <em>src_dir_fd</em>、<em>dst_dir_fd</em> 和 <em>follow_symlinks</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p>
</li>
<li><p><code>os.listdir</code>(<em>path=’.’</em>)</p>
<p>返回一个列表，该列表包含了 <em>path</em> 中所有文件与目录的名称。该列表按任意顺序排列，并且不包含特殊条目 <code>&#39;.&#39;</code> 和 <code>&#39;..&#39;</code>，即使它们确实在目录中存在。<em>path</em> 可以是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。如果 <em>path</em> 是（直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入） <code>bytes</code> 类型，则返回的文件名也将是 <code>bytes</code> 类型，其他情况下是 <code>str</code> 类型。本函数也支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>，其中描述符必须指向目录。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.listdir</code>，附带参数 <code>path</code>。</p>
<blockquote>
<p>要将 <code>str</code> 类型的文件名编码为 <code>bytes</code>，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsencode" target="_blank" rel="noopener"><code>fsencode()</code></a>。</p>
</blockquote>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 函数返回目录内文件名的同时，也返回文件属性信息，它在某些具体情况下能提供更好的性能。</p>
</li>
</ul>
<p><em>在 3.2 版更改:</em> <em>path</em> 变为可选参数。</p>
<p><em>3.3 新版功能:</em> 新增支持将 <em>path</em> 参数指定为打开的文件描述符。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
<ul>
<li><code>os.lstat</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</li>
</ul>
<p>在给定路径上执行本函数，其操作相当于 <code>lstat()</code> 系统调用，类似于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 但不跟踪符号链接。返回值是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 对象。</p>
<p>在不支持符号链接的平台上，本函数是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 的别名。</p>
<p>从 Python 3.3 起，此功能等价于 <code>os.stat(path, dir_fd=dir_fd, follow_symlinks=False)</code>。</p>
<p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。</p>
<p><em>在 3.2 版更改:</em> 添加对 Windows 6.0 (Vista) 符号链接的支持。</p>
<p><em>在 3.3 版更改:</em> 添加了 <em>dir_fd</em> 参数。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p>
<p><em>在 3.8 版更改:</em> 目前在 Windows 上，遇到表示另一个路径的重解析点（即名称代理，包括符号链接和目录结点），本函数将打开它。其他种类的重解析点由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 交由操作系统解析。</p>
<ul>
<li><p><code>os.mkdir</code>(<em>path</em>, <em>mode=0o777</em>, <em>**, </em>dir_fd=None*)</p>
<p>创建一个名为 <em>path</em> 的目录，应用以数字表示的权限模式 <em>mode</em>。如果目录已存在，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileExistsError" target="_blank" rel="noopener"><code>FileExistsError</code></a> 异常。某些系统会忽略 <em>mode</em>。如果没有忽略它，那么将首先从它中减去当前的 umask 值。如果除最后 9 位（即 <em>mode</em> 八进制的最后 3 位）之外，还设置了其他位，则其他位的含义取决于各个平台。在某些平台上，它们会被忽略，应显式调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>chmod()</code></a> 进行设置。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。如果需要创建临时目录，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#module-tempfile" target="_blank" rel="noopener"><code>tempfile</code></a> 模块中的 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>tempfile.mkdtemp()</code></a> 函数。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.mkdir</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.makedirs</code>(<em>name</em>, <em>mode=0o777</em>, <em>exist_ok=False</em>)</p>
<p>递归目录创建函数。与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.mkdir" target="_blank" rel="noopener"><code>mkdir()</code></a> 类似，但会自动创建到达最后一级目录所需要的中间目录。<em>mode</em> 参数会传递给 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.mkdir" target="_blank" rel="noopener"><code>mkdir()</code></a>，用来创建最后一级目录，对于该参数的解释，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#mkdir-modebits" target="_blank" rel="noopener">mkdir() 中的描述</a>。要设置某些新建的父目录的权限，可以在调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.makedirs" target="_blank" rel="noopener"><code>makedirs()</code></a> 之前设置 umask。现有父目录的权限不会更改。如果 <em>exist_ok</em> 为 <code>False</code> (默认值)，则如果目标目录已存在将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileExistsError" target="_blank" rel="noopener"><code>FileExistsError</code></a>。</p>
<blockquote>
<p>如果要创建的路径元素包含 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pardir" target="_blank" rel="noopener"><code>pardir</code></a> (如 UNIX 系统中的 “..”) <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.makedirs" target="_blank" rel="noopener"><code>makedirs()</code></a> 将无法明确目标。</p>
</blockquote>
</li>
</ul>
<p>本函数能正确处理 UNC 路径。</p>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.mkdir</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。</p>
<p><em>3.2 新版功能:</em> <em>exist_ok</em> 参数。</p>
<p><em>在 3.4.1 版更改:</em> 在 Python 3.4.1 以前，如果 <em>exist_ok</em> 为 <code>True</code>，且目录已存在，且 <em>mode</em> 与现有目录的权限不匹配，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.makedirs" target="_blank" rel="noopener"><code>makedirs()</code></a> 仍会抛出错误。由于无法安全地实现此行为，因此在 Python 3.4.1 中将该行为删除。请参阅 <a href="https://bugs.python.org/issue21082" target="_blank" rel="noopener">bpo-21082</a>。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
<p><em>在 3.7 版更改:</em> <em>mode</em> 参数不再影响新创建的中间目录的权限。</p>
<ul>
<li><p><code>os.mkfifo</code>(<em>path</em>, <em>mode=0o666</em>, <em>**, </em>dir_fd=None*)</p>
<p>创建一个名为 <em>path</em> 的 FIFO（命名管道，一种先进先出队列），具有以数字表示的权限状态 <em>mode</em>。将从 mode 中首先减去当前的 umask 值。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。FIFO 是可以像常规文件一样访问的管道。FIFO 如果没有被删除（如使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unlink" target="_blank" rel="noopener"><code>os.unlink()</code></a>），会一直存在。通常，FIFO 用作“客户端”和“服务器”进程之间的汇合点：服务器打开 FIFO 进行读取，而客户端打开 FIFO 进行写入。请注意，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.mkfifo" target="_blank" rel="noopener"><code>mkfifo()</code></a> 不会打开 FIFO — 它只是创建汇合点。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.mknod</code>(<em>path</em>, <em>mode=0o600</em>, <em>device=0</em>, <em>**, </em>dir_fd=None*)</p>
<p>创建一个名为 <em>path</em> 的文件系统节点（文件，设备专用文件或命名管道）。<em>mode</em> 指定权限和节点类型，方法是将权限与下列节点类型 <code>stat.S_IFREG</code>、<code>stat.S_IFCHR</code>、<code>stat.S_IFBLK</code> 和 <code>stat.S_IFIFO</code> 之一（按位或）组合（这些常量可以在 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中找到）。对于 <code>stat.S_IFCHR</code> 和 <code>stat.S_IFBLK</code>，<em>device</em> 参数指定了新创建的设备专用文件（可能会用到 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.makedev" target="_blank" rel="noopener"><code>os.makedev()</code></a>），否则该参数将被忽略。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.major</code>(<em>device</em>)</p>
<p>提取主设备号，提取自原始设备号（通常是 <code>stat</code> 中的 <code>st_dev</code> 或 <code>st_rdev</code> 字段）。</p>
</li>
<li><p><code>os.minor</code>(<em>device</em>)</p>
<p>提取次设备号，提取自原始设备号（通常是 <code>stat</code> 中的 <code>st_dev</code> 或 <code>st_rdev</code> 字段）。</p>
</li>
<li><p><code>os.makedev</code>(<em>major</em>, <em>minor</em>)</p>
<p>将主设备号和次设备号组合成原始设备号。</p>
</li>
<li><p><code>os.pathconf</code>(<em>path</em>, <em>name</em>)</p>
<p>返回所给名称的文件有关的系统配置信息。<em>name</em> 指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX.1，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 <code>pathconf_names</code> 字典中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 <em>name</em>。如果 <em>name</em> 是一个字符串且不是已定义的名称，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。如果当前系统不支持 <em>name</em> 指定的配置名称，即使该名称存在于 <code>pathconf_names</code>，也会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，错误码为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EINVAL" target="_blank" rel="noopener"><code>errno.EINVAL</code></a>。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.pathconf_names</code></p>
<p>字典，表示映射关系，为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pathconf" target="_blank" rel="noopener"><code>pathconf()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fpathconf" target="_blank" rel="noopener"><code>fpathconf()</code></a> 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.readlink</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</p>
<p>返回一个字符串，为符号链接指向的实际路径。其结果可以是绝对或相对路径。如果是相对路径，则可用 <code>os.path.join(os.path.dirname(path), result)</code> 转换为绝对路径。如果 <em>path</em> 是字符串对象（直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入），则结果也将是字符串对象，且此类调用可能会引发 UnicodeDecodeError。如果 <em>path</em> 是字节对象（直接传入或间接传入），则结果将会是字节对象。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。当尝试解析的路径可能含有链接时，请改用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.realpath" target="_blank" rel="noopener"><code>realpath()</code></a> 以正确处理递归和平台差异。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加对 Windows 6.0 (Vista) 符号链接的支持。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 在 Unix 上可以接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。<em>在 3.8 版更改:</em> 在 Windows 上接受 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 和字节对象。<em>在 3.8 版更改:</em> 增加了对目录链接的支持，且返回值改为了“替换路径”的形式（通常带有 <code>\\?\</code> 前缀），而不是先前那样返回可选的 “print name” 字段。</p>
</li>
<li><p><code>os.remove</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</p>
<p>移除（删除）文件 <em>path</em>。如果 <em>path</em> 是目录，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IsADirectoryError" target="_blank" rel="noopener"><code>IsADirectoryError</code></a> 异常。请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rmdir" target="_blank" rel="noopener"><code>rmdir()</code></a> 删除目录。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。在 Windows 上，尝试删除正在使用的文件会抛出异常。而在 Unix 上，虽然该文件的条目会被删除，但分配给文件的存储空间仍然不可用，直到原始文件不再使用为止。本函数在语义上与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unlink" target="_blank" rel="noopener"><code>unlink()</code></a> 相同。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.remove</code>，附带参数 <code>path</code>、<code>dir_fd</code>。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.removedirs</code>(<em>name</em>)</p>
<p>递归删除目录。工作方式类似于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rmdir" target="_blank" rel="noopener"><code>rmdir()</code></a>，不同之处在于，如果成功删除了末尾一级目录，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.removedirs" target="_blank" rel="noopener"><code>removedirs()</code></a> 会尝试依次删除 <em>path</em> 中提到的每个父目录，直到抛出错误为止（但该错误会被忽略，因为这通常表示父目录不是空目录）。例如，<code>os.removedirs(&#39;foo/bar/baz&#39;)</code> 将首先删除目录 <code>&#39;foo/bar/baz&#39;</code>，然后如果 <code>&#39;foo/bar&#39;</code> 和 <code>&#39;foo&#39;</code> 为空，则继续删除它们。如果无法成功删除末尾一级目录，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.remove</code>，附带参数 <code>path</code>、<code>dir_fd</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.rename</code>(<em>src</em>, <em>dst</em>, <em>**, </em>src_dir_fd=None<em>, </em>dst_dir_fd=None*)</p>
<p>将文件或目录 <em>src</em> 重命名为 <em>dst</em>。如果 <em>dst</em> 已存在，则下列情况下将会操作失败，并抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的子类：在 Windows 上，如果 <em>dst</em> 已存在，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileExistsError" target="_blank" rel="noopener"><code>FileExistsError</code></a> 异常。在 Unix 上，如果 <em>src</em> 是文件而 <em>dst</em> 是目录，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IsADirectoryError" target="_blank" rel="noopener"><code>IsADirectoryError</code></a> 异常，反之则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotADirectoryError" target="_blank" rel="noopener"><code>NotADirectoryError</code></a> 异常。如果两者都是目录且 <em>dst</em> 为空，则 <em>dst</em> 将被静默替换。如果 <em>dst</em> 是非空目录，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。如果两者都是文件，则在用户具有权限的情况下，将对 <em>dst</em> 进行静默替换。如果 <em>src</em> 和 <em>dst</em> 在不同的文件系统上，则本操作在某些 Unix 分支上可能会失败。如果成功，重命名操作将是一个原子操作（这是 POSIX 的要求）。本函数支持将 <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 中的一个或两个指定为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。如果需要在不同平台上都能替换目标，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.replace" target="_blank" rel="noopener"><code>replace()</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.rename</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。<em>3.3 新版功能:</em> <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p>
</li>
<li><p><code>os.renames</code>(<em>old</em>, <em>new</em>)</p>
<p>递归重命名目录或文件。工作方式类似 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>rename()</code></a>，除了会首先创建新路径所需的中间目录。重命名后，将调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.removedirs" target="_blank" rel="noopener"><code>removedirs()</code></a> 删除旧路径中不需要的目录。注解 如果用户没有权限删除末级的目录或文件，则本函数可能会无法建立新的目录结构。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.rename</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>old</em> 和 <em>new</em>。</p>
</li>
<li><p><code>os.replace</code>(<em>src</em>, <em>dst</em>, <em>**, </em>src_dir_fd=None<em>, </em>dst_dir_fd=None*)</p>
<p>将文件或目录 <em>src</em> 重命名为 <em>dst</em>。如果 <em>dst</em> 是目录，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。如果 <em>dst</em> 已存在且为文件，则在用户具有权限的情况下，将对其进行静默替换。如果 <em>src</em> 和 <em>dst</em> 在不同的文件系统上，本操作可能会失败。如果成功，重命名操作将是一个原子操作（这是 POSIX 的要求）。本函数支持将 <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 中的一个或两个指定为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.rename</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。<em>3.3 新版功能.**在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p>
</li>
<li><p><code>os.rmdir</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</p>
<p>移除（删除）目录 <em>path</em>。如果目录不存在或不为空，则会分别抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileNotFoundError" target="_blank" rel="noopener"><code>FileNotFoundError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。要删除整个目录树，可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree" target="_blank" rel="noopener"><code>shutil.rmtree()</code></a>。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.rmdir</code>，附带参数 <code>path</code>、<code>dir_fd</code>。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.scandir</code>(<em>path=’.’</em>)</p>
<p>返回一个迭代出 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry" target="_blank" rel="noopener"><code>os.DirEntry</code></a> 对象的迭代器，这些对象对应于 <em>path</em> 目录中的条目。条目的生成顺序是任意的，特殊条目 <code>&#39;.&#39;</code> 和 <code>&#39;..&#39;</code> 不包括在内。如果需要文件类型或文件属性信息，使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 代替 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>listdir()</code></a> 可以大大提高这部分代码的性能，因为如果操作系统在扫描目录时返回的是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry" target="_blank" rel="noopener"><code>os.DirEntry</code></a> 对象，则该对象包含了这些信息。所有 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry" target="_blank" rel="noopener"><code>os.DirEntry</code></a> 的方法都可能执行一次系统调用，但是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.is_dir" target="_blank" rel="noopener"><code>is_dir()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.is_file" target="_blank" rel="noopener"><code>is_file()</code></a> 通常只在有符号链接时才执行一次系统调用。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.stat" target="_blank" rel="noopener"><code>os.DirEntry.stat()</code></a> 在 Unix 上始终需要一次系统调用，而在 Windows 上只在有符号链接时才需要。<em>path</em> 可以是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。如果 <em>path</em> 是（直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入的） <code>bytes</code> 类型，那么每个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry" target="_blank" rel="noopener"><code>os.DirEntry</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.name" target="_blank" rel="noopener"><code>name</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.path" target="_blank" rel="noopener"><code>path</code></a> 属性将是 <code>bytes</code> 类型，其他情况下是 <code>str</code> 类型。本函数也支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>，其中描述符必须指向目录。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.scandir</code>，附带参数 <code>path</code>。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 迭代器支持 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-context-manager" target="_blank" rel="noopener">上下文管理</a> 协议，并具有以下方法：<code>scandir.close</code>()关闭迭代器并释放占用的资源。当迭代器迭代完毕，或垃圾回收，或迭代过程出错时，将自动调用本方法。但仍建议显式调用它或使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句。</p>
<p><em>3.6 新版功能.</em></p>
<p>下面的例子演示了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的简单用法，用来显示给定 <em>path</em> 中所有不以 <code>&#39;.&#39;</code> 开头的文件（不包括目录）。<code>entry.is_file()</code> 通常不会增加一次额外的系统调用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> os.scandir(path) <span class="keyword">as</span> it:</span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> it:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> entry.name.startswith(<span class="string">'.'</span>) <span class="keyword">and</span> entry.is_file():</span><br><span class="line">            print(entry.name)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在基于 Unix 的系统上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 使用系统的 <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html" target="_blank" rel="noopener">opendir()</a> 和 <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html" target="_blank" rel="noopener">readdir()</a> 函数。在 Windows 上，它使用 Win32 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418(v=vs.85" target="_blank" rel="noopener">FindFirstFileW</a>.aspx) 和 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364428(v=vs.85" target="_blank" rel="noopener">FindNextFileW</a>.aspx) 函数。</p>
</blockquote>
<p><em>.5 新版功能.</em></p>
<p><em>3.6 新版功能:</em> 添加了对 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-context-manager" target="_blank" rel="noopener">上下文管理</a> 协议和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir.close" target="_blank" rel="noopener"><code>close()</code></a> 方法的支持。如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 迭代器没有迭代完毕且没有显式关闭，其析构函数将发出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ResourceWarning" target="_blank" rel="noopener"><code>ResourceWarning</code></a> 警告。</p>
<p>本函数接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
<p><em>在 3.7 版更改:</em> 在 Unix 上新增支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。</p>
</li>
<li><p><em>class</em> <code>os.DirEntry</code></p>
<p>由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 生成的对象，用于显示目录内某个条目的文件路径和其他文件属性。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 将在不进行额外系统调用的情况下，提供尽可能多的此类信息。每次进行 <code>stat()</code> 或 <code>lstat()</code> 系统调用时，<code>os.DirEntry</code> 对象会将结果缓存下来。</p>
<p><code>os.DirEntry</code> 实例不适合存储在长期存在的数据结构中，如果你知道文件元数据已更改，或者自调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 以来已经经过了很长时间，请调用 <code>os.stat(entry.path)</code> 来获取最新信息。</p>
<p>因为 <code>os.DirEntry</code> 方法可以进行系统调用，所以它也可能抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。如需精确定位错误，可以逐个调用 <code>os.DirEntry</code> 中的方法来捕获 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>，并适当处理。</p>
<p>为了能直接用作 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>，<code>os.DirEntry</code> 实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口。</p>
<p><code>os.DirEntry</code> 实例所包含的属性和方法如下：</p>
<ul>
<li><p><code>name</code></p>
<p>本条目的基本文件名，是根据 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数得出的相对路径。如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数是 <code>bytes</code> 类型，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.name" target="_blank" rel="noopener"><code>name</code></a> 属性也是 <code>bytes</code> 类型，否则为 <code>str</code>。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsdecode" target="_blank" rel="noopener"><code>fsdecode()</code></a> 解码 byte 类型的文件名。</p>
</li>
<li><p><code>path</code></p>
<p>本条目的完整路径：等效于 <code>os.path.join(scandir_path, entry.name)</code>，其中 <em>scandir_path</em> 就是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数。仅当 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数为绝对路径时，本路径才是绝对路径。如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">文件描述符</a>，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>path</code></a> 属性与上述 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.name" target="_blank" rel="noopener"><code>name</code></a> 属性相同。如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数是 <code>bytes</code> 类型，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>path</code></a> 属性也是 <code>bytes</code> 类型，否则为 <code>str</code>。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsdecode" target="_blank" rel="noopener"><code>fsdecode()</code></a> 解码 byte 类型的文件名。</p>
</li>
<li><p><code>inode</code>()</p>
<p>返回本条目的索引节点号 (inode number)。这一结果是缓存在 <code>os.DirEntry</code> 对象中的，请调用 <code>os.stat(entry.path, follow_symlinks=False).st_ino</code> 来获取最新信息。一开始没有缓存时，在 Windows 上需要一次系统调用，但在 Unix 上不需要。</p>
</li>
<li><p><code>is_dir</code>(<em>**, </em>follow_symlinks=True*)</p>
<p>如果本条目是目录，或是指向目录的符号链接，则返回 <code>True</code>。如果本条目是文件，或指向任何其他类型的文件，或该目录不再存在，则返回 <code>False</code>。如果 <em>follow_symlinks</em> 是 <code>False</code>，那么仅当本条目为目录时返回 <code>True</code> （不跟踪符号链接），如果本条目是任何类型的文件，或该文件不再存在，则返回 <code>False</code>。这一结果是缓存在 <code>os.DirEntry</code> 对象中的，且 <em>follow_symlinks</em> 为 <code>True</code> 和 <code>False</code> 时的缓存是分开的。请调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ISDIR" target="_blank" rel="noopener"><code>stat.S_ISDIR()</code></a> 来获取最新信息。一开始没有缓存时，大多数情况下不需要系统调用。特别是对于非符号链接，Windows 和 Unix 都不需要系统调用，除非某些 Unix 文件系统（如网络文件系统）返回了 <code>dirent.d_type == DT_UNKNOWN</code>。如果本条目是符号链接，则需要一次系统调用来跟踪它（除非 <em>follow_symlinks</em> 为 <code>False</code>）。本方法可能抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#PermissionError" target="_blank" rel="noopener"><code>PermissionError</code></a> 异常，但 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileNotFoundError" target="_blank" rel="noopener"><code>FileNotFoundError</code></a> 异常会被内部捕获且不会抛出。</p>
</li>
<li><p><code>is_file</code>(<em>**, </em>follow_symlinks=True*)</p>
<p>如果本条目是文件，或是指向文件的符号链接，则返回 <code>True</code>。如果本条目是目录，或指向目录，或指向其他非文件条目，或该文件不再存在，则返回 <code>False</code>。如果 <em>follow_symlinks</em> 是 <code>False</code>，那么仅当本条目为文件时返回 <code>True</code> （不跟踪符号链接），如果本条目是目录或其他非文件条目，或该文件不再存在，则返回 <code>False</code>。这一结果是缓存在 <code>os.DirEntry</code> 对象中的。缓存、系统调用、异常抛出都与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.is_dir" target="_blank" rel="noopener"><code>is_dir()</code></a> 一致。</p>
</li>
<li><p><code>is_symlink</code>()</p>
<p>如果本条目是符号链接（即使是断开的链接），返回 <code>True</code>。如果是目录或任何类型的文件，或本条目不再存在，返回 <code>False</code>。这一结果是缓存在 <code>os.DirEntry</code> 对象中的，请调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>os.path.islink()</code></a> 来获取最新信息。一开始没有缓存时，大多数情况下不需要系统调用。其实 Windows 和 Unix 都不需要系统调用，除非某些 Unix 文件系统（如网络文件系统）返回了 <code>dirent.d_type == DT_UNKNOWN</code>。本方法可能抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#PermissionError" target="_blank" rel="noopener"><code>PermissionError</code></a> 异常，但 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileNotFoundError" target="_blank" rel="noopener"><code>FileNotFoundError</code></a> 异常会被内部捕获且不会抛出。</p>
</li>
<li><p><code>stat</code>(<em>**, </em>follow_symlinks=True*)</p>
<p>返回本条目对应的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 对象。本方法默认会跟踪符号链接，要获取符号链接本身的 stat，请添加 <code>follow_symlinks=False</code> 参数。在 Unix 上，本方法需要一次系统调用。在 Windows 上，仅在 <em>follow_symlinks</em> 为 <code>True</code> 且该条目是一个重解析点（如符号链接或目录结点）时，才需要一次系统调用。在 Windows 上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 的 <code>st_ino</code>、<code>st_dev</code> 和 <code>st_nlink</code> 属性总是为零。请调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 以获得这些属性。这一结果是缓存在 <code>os.DirEntry</code> 对象中的，且 <em>follow_symlinks</em> 为 <code>True</code> 和 <code>False</code> 时的缓存是分开的。请调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 来获取最新信息。</p>
</li>
</ul>
<p>注意，<code>os.DirEntry</code> 和 <a href="https://docs.python.org/zh-cn/3.8/library/pathlib.html#pathlib.Path" target="_blank" rel="noopener"><code>pathlib.Path</code></a> 的几个属性和方法之间存在很好的对应关系。具体来说是 <code>name</code> 属性，以及 <code>is_dir()</code>、<code>is_file()</code>、<code>is_symlink()</code> 和 <code>stat()</code> 方法，在两个类中具有相同的含义。</p>
<p><em>3.5 新版功能.</em></p>
<p><em>在 3.6 版更改:</em> 添加了对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口的支持。在 Windows 上添加了对 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型路径的支持。</p>
</li>
<li><p><code>os.stat</code>(<em>path</em>, <em>**, </em>dir_fd=None<em>, </em>follow_symlinks=True*)</p>
<p>获取文件或文件描述符的状态。在所给路径上执行等效于 <code>stat()</code> 系统调用的操作。<em>path</em> 可以是字符串类型，或（直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入的） bytes 类型，或打开的文件描述符。返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 对象。</p>
<p>本函数默认会跟踪符号链接，要获取符号链接本身的 stat，请添加 <code>follow_symlinks=False</code> 参数，或使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>lstat()</code></a>。</p>
<p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。</p>
<p>在 Windows 上，传入 <code>follow_symlinks=False</code> 将禁用所有名称代理重解析点，其中包括符号链接和目录结点。其他类型的重解析点将直接打开，比如不像链接的或系统无法跟踪的重解析点。当多个链接形成一个链时，本方法可能会返回原始链接的 stat，无法完整遍历到非链接的对象。在这种情况下，要获取最终路径的 stat，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.realpath" target="_blank" rel="noopener"><code>os.path.realpath()</code></a> 函数尽可能地解析路径，并在解析结果上调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>lstat()</code></a>。这不适用于空链接或交接点，否则会抛出异常。</p>
<p>示例:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statinfo = os.stat(<span class="string">'somefile.txt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statinfo</span><br><span class="line">os.stat_result(st_mode=<span class="number">33188</span>, st_ino=<span class="number">7876932</span>, st_dev=<span class="number">234881026</span>,</span><br><span class="line">st_nlink=<span class="number">1</span>, st_uid=<span class="number">501</span>, st_gid=<span class="number">501</span>, st_size=<span class="number">264</span>, st_atime=<span class="number">1297230295</span>,</span><br><span class="line">st_mtime=<span class="number">1297230027</span>, st_ctime=<span class="number">1297230027</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statinfo.st_size</span><br><span class="line"><span class="number">264</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fstat" target="_blank" rel="noopener"><code>fstat()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>lstat()</code></a> 函数。</p>
</blockquote>
<p><em>3.3 新版功能:</em> 增加 <em>dir_fd</em> 和 <em>follow_symlinks</em> 参数，可指定文件描述符代替路径。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
<p><em>在 3.8 版更改:</em> 在 Windows 上，本方法将跟踪系统能解析的所有重解析点，并且传入 <code>follow_symlinks=False</code> 会停止跟踪所有名称代理重解析点。现在，如果操作系统遇到无法跟踪的重解析点，<em>stat</em> 将返回原始路径的信息，就像已指定 <code>follow_symlinks=False</code> 一样，而不会抛出异常。</p>
<p><em>class</em> <code>os.stat_result</code></p>
<p>本对象的属性大致对应于 <code>stat</code> 结构体成员，主要作为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fstat" target="_blank" rel="noopener"><code>os.fstat()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>os.lstat()</code></a> 的返回值。</p>
<p>属性：</p>
<ul>
<li><p><code>st_mode</code></p>
<p>文件模式：包括文件类型和文件模式位（即权限位）。</p>
</li>
<li><p><code>st_ino</code></p>
<p>与平台有关，但如果不为零，则根据 <code>st_dev</code> 值唯一地标识文件。通常：在 Unix 上该值表示索引节点号 (inode number)。在 Windows 上该值表示 <a href="https://msdn.microsoft.com/en-us/library/aa363788" target="_blank" rel="noopener">文件索引号</a> 。</p>
</li>
<li><p><code>st_dev</code></p>
<p>该文件所在设备的标识符。</p>
</li>
<li><p><code>st_nlink</code></p>
<p>硬链接的数量。</p>
</li>
<li><p><code>st_uid</code></p>
<p>文件所有者的用户 ID。</p>
</li>
<li><p><code>st_gid</code></p>
<p>文件所有者的用户组 ID。</p>
</li>
<li><p><code>st_size</code></p>
<p>文件大小（以字节为单位），文件可以是常规文件或符号链接。符号链接的大小是它包含的路径的长度，不包括末尾的空字节。</p>
</li>
</ul>
<p>时间戳：</p>
<ul>
<li><p><code>st_atime</code></p>
<p>最近的访问时间，以秒为单位。</p>
</li>
<li><p><code>st_mtime</code></p>
<p>最近的修改时间，以秒为单位。</p>
</li>
<li><p><code>st_ctime</code></p>
<p>取决于平台：在 Unix 上表示最近的元数据更改时间，在 Windows 上表示创建时间，以秒为单位。</p>
</li>
<li><p><code>st_atime_ns</code></p>
<p>最近的访问时间，以纳秒表示，为整数。</p>
</li>
<li><p><code>st_mtime_ns</code></p>
<p>最近的修改时间，以纳秒表示，为整数。</p>
</li>
<li><p><code>st_ctime_ns</code></p>
<p>取决于平台：在 Unix 上表示最近的元数据更改时间，在 Windows 上表示创建时间，以纳秒表示，为整数。</p>
</li>
</ul>
<blockquote>
<p> <code>st_atime</code>](<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime)、[`st_mtime`](https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime)" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime)、[`st_mtime`](https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime)</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime" target="_blank" rel="noopener"><code>st_ctime</code></a> 属性的确切含义和分辨率取决于操作系统和文件系统。例如，在使用 FAT 或 FAT32 文件系统的 Windows 上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime" target="_blank" rel="noopener"><code>st_mtime</code></a> 有 2 秒的分辨率，而 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime" target="_blank" rel="noopener"><code>st_atime</code></a> 仅有 1 天的分辨率。详细信息请参阅操作系统文档。</p>
<p>类似地，尽管 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime_ns" target="_blank" rel="noopener"><code>st_atime_ns</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime_ns" target="_blank" rel="noopener"><code>st_mtime_ns</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime_ns" target="_blank" rel="noopener"><code>st_ctime_ns</code></a> 始终以纳秒表示，但许多系统并不提供纳秒精度。在确实提供纳秒精度的系统上，用于存储 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime" target="_blank" rel="noopener"><code>st_atime</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime" target="_blank" rel="noopener"><code>st_mtime</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime" target="_blank" rel="noopener"><code>st_ctime</code></a> 的浮点对象无法保留所有精度，因此不够精确。如果需要确切的时间戳，则应始终使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime_ns" target="_blank" rel="noopener"><code>st_atime_ns</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime_ns" target="_blank" rel="noopener"><code>st_mtime_ns</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime_ns" target="_blank" rel="noopener"><code>st_ctime_ns</code></a>。</p>
</blockquote>
<p>在某些 Unix 系统上（如 Linux 上），以下属性可能也可用：</p>
<ul>
<li><p><code>st_blocks</code></p>
<p>为文件分配的字节块数，每块 512 字节。文件是稀疏文件时，它可能小于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_size" target="_blank" rel="noopener"><code>st_size</code></a>/512。</p>
</li>
<li><p><code>st_blksize</code></p>
<p>“首选的” 块大小，用于提高文件系统 I/O 效率。写入文件时块大小太小可能会导致读取-修改-重写效率低下。</p>
</li>
<li><p><code>st_rdev</code></p>
<p>设备类型（如果是 inode 设备）。</p>
</li>
<li><p><code>st_flags</code></p>
<p>用户定义的文件标志位。</p>
</li>
</ul>
<p>在其他 Unix 系统上（如 FreeBSD 上），以下属性可能可用（但仅当 root 使用它们时才被填充）：</p>
<ul>
<li><p><code>st_gen</code></p>
<p>文件生成号。</p>
</li>
<li><p><code>st_birthtime</code></p>
<p>文件创建时间。</p>
</li>
</ul>
<p>在 Solaris 及其衍生版本上，以下属性可能也可用：</p>
<ul>
<li><p><code>st_fstype</code></p>
<p>文件所在文件系统的类型的唯一标识，为字符串。</p>
</li>
</ul>
<p>在 Mac OS 系统上，以下属性可能也可用：</p>
<ul>
<li><p><code>st_rsize</code></p>
<p>文件的实际大小。</p>
</li>
<li><p><code>st_creator</code></p>
<p>文件的创建者。</p>
</li>
<li><p><code>st_type</code></p>
<p>文件类型。</p>
</li>
</ul>
<p>在 Windows 系统上，以下属性也可用：</p>
<ul>
<li><p><code>st_file_attributes</code></p>
<p>Windows 文件属性：<code>dwFileAttributes</code>，由 <code>GetFileInformationByHandle()</code> 返回的 <code>BY_HANDLE_FILE_INFORMATION</code> 结构体的成员之一。请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中的 <code>FILE_ATTRIBUTE_*</code> 常量。</p>
</li>
<li><p><code>st_reparse_tag</code></p>
<p>当 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_file_attributes" target="_blank" rel="noopener"><code>st_file_attributes</code></a> 存在 <code>FILE_ATTRIBUTE_REPARSE_POINT</code> 集合时，本字段包含重解析点类型标记。请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中的 <code>IO_REPARSE_TAG_*</code> 常量。</p>
</li>
</ul>
<p>标准模块 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 中定义了函数和常量，这些函数和常量可用于从 <code>stat</code> 结构体中提取信息。（在 Windows 上，某些项填充的是虚值。）</p>
<p>为了向后兼容，一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 实例还可以作为至少包含 10 个整数的元组访问，以提供 <code>stat</code> 结构中最重要（和可移植）的成员，整数顺序为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mode" target="_blank" rel="noopener"><code>st_mode</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ino" target="_blank" rel="noopener"><code>st_ino</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_dev" target="_blank" rel="noopener"><code>st_dev</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_nlink" target="_blank" rel="noopener"><code>st_nlink</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_uid" target="_blank" rel="noopener"><code>st_uid</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_gid" target="_blank" rel="noopener"><code>st_gid</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_size" target="_blank" rel="noopener"><code>st_size</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime" target="_blank" rel="noopener"><code>st_atime</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime" target="_blank" rel="noopener"><code>st_mtime</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime" target="_blank" rel="noopener"><code>st_ctime</code></a>。某些实现可能在末尾还有更多项。为了与旧版 Python 兼容，以元组形式访问 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 始终返回整数。</p>
<p><em>3.3 新版功能:</em> 添加了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime_ns" target="_blank" rel="noopener"><code>st_atime_ns</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime_ns" target="_blank" rel="noopener"><code>st_mtime_ns</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime_ns" target="_blank" rel="noopener"><code>st_ctime_ns</code></a> 成员。</p>
<p><em>3.5 新版功能:</em> 在 Windows 上添加了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_file_attributes" target="_blank" rel="noopener"><code>st_file_attributes</code></a> 成员。</p>
<p><em>在 3.5 版更改:</em> 在 Windows 上，如果可用，会返回文件索引作为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ino" target="_blank" rel="noopener"><code>st_ino</code></a> 的值。</p>
<p><em>3.7 新版功能:</em> 在 Solaris 及其衍生版本上添加了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_fstype" target="_blank" rel="noopener"><code>st_fstype</code></a> 成员。</p>
<p><em>3.8 新版功能:</em> 在 Windows 上添加了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_reparse_tag" target="_blank" rel="noopener"><code>st_reparse_tag</code></a> 成员。</p>
<p><em>在 3.8 版更改:</em> 在 Windows 上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mode" target="_blank" rel="noopener"><code>st_mode</code></a> 成员现在可以根据需要将特殊文件标识为 <code>S_IFCHR</code>、<code>S_IFIFO</code> 或 <code>S_IFBLK</code>。</p>
<ul>
<li><p><code>os.statvfs</code>(<em>path</em>)</p>
<p>在所给的路径上执行 <code>statvfs()</code> 系统调用。返回值是一个对象，其属性描述了所给路径上的文件系统，并且与 <code>statvfs</code> 结构体的成员相对应，即：<code>f_bsize</code>, <code>f_frsize</code>, <code>f_blocks</code>, <code>f_bfree</code>, <code>f_bavail</code>, <code>f_files</code>, <code>f_ffree</code>, <code>f_favail</code>, <code>f_flag</code>, <code>f_namemax</code>, <code>f_fsid</code>。</p>
<p>为 <code>f_flag</code> 属性位定义了两个模块级常量：如果存在 <code>ST_RDONLY</code> 位，则文件系统以只读挂载；如果存在 <code>ST_NOSUID</code> 位，则文件系统禁用或不支持 setuid/setgid 位。</p>
<p>为基于 GNU/glibc 的系统还定义了额外的模块级常量。它们是 <code>ST_NODEV</code> （禁止访问设备专用文件），<code>ST_NOEXEC</code> （禁止执行程序），<code>ST_SYNCHRONOUS</code> （写入后立即同步），<code>ST_MANDLOCK</code> （允许文件系统上的强制锁定），<code>ST_WRITE</code> （写入文件/目录/符号链接），<code>ST_APPEND</code> （仅追加文件），<code>ST_IMMUTABLE</code> （不可变文件），<code>ST_NOATIME</code> （不更新访问时间），<code>ST_NODIRATIME</code> （不更新目录访问时间），<code>ST_RELATIME</code> （相对于 mtime/ctime 更新访问时间）。</p>
<p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
<p><em>在 3.2 版更改:</em> 添加了 <code>ST_RDONLY</code> 和 <code>ST_NOSUID</code> 常量。</p>
<p><em>3.3 新版功能:</em> 新增支持将 <em>path</em> 参数指定为打开的文件描述符。</p>
<p><em>在 3.4 版更改:</em> 添加了 <code>ST_NODEV</code>、<code>ST_NOEXEC</code>、<code>ST_SYNCHRONOUS</code>、<code>ST_MANDLOCK</code>、<code>ST_WRITE</code>、<code>ST_APPEND</code>、<code>ST_IMMUTABLE</code>、<code>ST_NOATIME</code>、<code>ST_NODIRATIME</code> 和 <code>ST_RELATIME</code> 常量。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
<p><em>3.7 新版功能:</em> 添加了 <code>f_fsid</code>。</p>
</li>
</ul>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">os.supports_dir_fd</span><br></pre></td></tr></table></figure>
<p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 对象，指示 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中的哪些函数接受一个打开的文件描述符作为 <em>dir_fd</em> 参数。不同平台提供的功能不同，且 Python 用于实现 <em>dir_fd</em> 参数的底层函数并非在 Python 支持的所有平台上都可用。考虑到一致性，支持 <em>dir_fd</em> 的函数始终允许指定描述符，但如果在底层不支持时调用了该函数，则会抛出异常。（在所有平台上始终支持将 <em>dir_fd</em> 指定为 <code>None</code>。）</p>
<p>要检查某个函数是否接受打开的文件描述符作为 <em>dir_fd</em> 参数，请在 <code>supports_dir_fd</code> 前使用 <code>in</code> 运算符。例如，如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 在当前平台上接受打开的文件描述符作为 <em>dir_fd</em> 参数，则此表达式的计算结果为 <code>True</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.stat <span class="keyword">in</span> os.supports_dir_fd</span><br></pre></td></tr></table></figure>
<p>目前 <em>dir_fd</em> 参数仅在 Unix 平台上有效，在 Windows 上均无效。</p>
<p><em>3.3 新版功能.</em></p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">os.supports_effective_ids</span><br></pre></td></tr></table></figure>
<p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 对象，指示 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>os.access()</code></a> 是否允许在当前平台上将其 <em>effective_ids</em> 参数指定为 <code>True</code>。（所有平台都支持将 <em>effective_ids</em> 指定为 <code>False</code>。）如果当前平台支持，则集合将包含 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>os.access()</code></a>，否则集合为空。</p>
<p>如果当前平台上的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>os.access()</code></a> 支持 <code>effective_ids=True</code>，则此表达式的计算结果为 <code>True</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.access <span class="keyword">in</span> os.supports_effective_ids</span><br></pre></td></tr></table></figure>
<p>目前仅 Unix 平台支持 <em>effective_ids</em>，Windows 不支持。</p>
<p><em>3.3 新版功能.</em></p>
</li>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.supports_fd</span><br></pre></td></tr></table></figure>
<p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 对象，指示在当前平台上 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中的哪些函数接受一个打开的文件描述符作为 <em>path</em> 参数。不同平台提供的功能不同，且 Python 所使用到的底层函数（用于实现接受描述符作为 <em>path</em>）并非在 Python 支持的所有平台上都可用。</p>
<p>要判断某个函数是否接受打开的文件描述符作为 <em>path</em> 参数，请在 <code>supports_fd</code> 前使用 <code>in</code> 运算符。例如，如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chdir" target="_blank" rel="noopener"><code>os.chdir()</code></a> 在当前平台上接受打开的文件描述符作为 <em>path</em> 参数，则此表达式的计算结果为 <code>True</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.chdir <span class="keyword">in</span> os.supports_fd</span><br></pre></td></tr></table></figure>
<p><em>3.3 新版功能.</em></p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">os.supports_follow_symlinks</span><br></pre></td></tr></table></figure>
<p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 对象，指示在当前平台上 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中的哪些函数的 <em>follow_symlinks</em> 参数可指定为 <code>False</code>。不同平台提供的功能不同，且 Python 用于实现 <em>follow_symlinks</em> 的底层函数并非在 Python 支持的所有平台上都可用。考虑到一致性，支持 <em>follow_symlinks</em> 的函数始终允许将其指定为 <code>False</code>，但如果在底层不支持时调用了该函数，则会抛出异常。（在所有平台上始终支持将 <em>follow_symlinks</em> 指定为 <code>True</code>。）</p>
<p>要检查某个函数的 <em>follow_symlinks</em> 参数是否可以指定为 <code>False</code>，请在 <code>supports_follow_symlinks</code> 前使用 <code>in</code> 运算符。例如，如果在当前平台上调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 时可以指定 <code>follow_symlinks=False</code>，则此表达式的计算结果为 <code>True</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.stat <span class="keyword">in</span> os.supports_follow_symlinks</span><br></pre></td></tr></table></figure>
<p><em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.symlink</code>(<em>src</em>, <em>dst</em>, <em>target_is_directory=False</em>, <em>**, </em>dir_fd=None*)</p>
<p>创建一个指向 <em>src</em> 的符号链接，名为 <em>dst</em>。</p>
<p>在 Windows 上，符号链接可以表示文件或目录两种类型，并且不会动态改变类型。如果目标存在，则新建链接的类型将与目标一致。否则，如果 <em>target_is_directory</em> 为 <code>True</code>，则符号链接将创建为目录链接，为 <code>False</code> （默认）将创建为文件链接。在非 Windows 平台上，<em>target_is_directory</em> 被忽略。</p>
<p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a></p>
<blockquote>
<p>在 Windows 10 或更高版本上，如果启用了开发人员模式，非特权帐户可以创建符号链接。如果开发人员模式不可用/未启用，则需要 <em>SeCreateSymbolicLinkPrivilege</em> 权限，或者该进程必须以管理员身份运行。</p>
<p>当本函数由非特权账户调用时，抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p>
</blockquote>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.symlink</code>，附带参数 <code>src</code>、<code>dst</code>、<code>dir_fd</code>。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p>
<p><em>在 3.2 版更改:</em> 添加对 Windows 6.0 (Vista) 符号链接的支持。</p>
<p><em>3.3 新版功能:</em> 添加了 <em>dir_fd</em> 参数，现在在非 Windows 平台上允许 <em>target_is_directory</em> 参数。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p>
<p><em>在 3.8 版更改:</em> 针对启用了开发人员模式的 Windows，添加了非特权账户创建符号链接的支持。</p>
</li>
<li><p><code>os.sync</code>()</p>
<p>强制将所有内容写入磁盘。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.truncate</code>(<em>path</em>, <em>length</em>)</p>
<p>截断 <em>path</em> 对应的文件，以使其最大为 <em>length</em> 字节。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.truncate</code>，附带参数 <code>path</code>, <code>length</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>3.3 新版功能.**在 3.5 版更改:</em> 添加了 Windows 支持<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.unlink</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</p>
<p>移除（删除）文件 <em>path</em>。该函数在语义上与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.remove" target="_blank" rel="noopener"><code>remove()</code></a> 相同，<code>unlink</code> 是其传统的 Unix 名称。请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.remove" target="_blank" rel="noopener"><code>remove()</code></a> 的文档以获取更多信息。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.remove</code>，附带参数 <code>path</code>、<code>dir_fd</code>。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.utime</code>(<em>path</em>, <em>times=None</em>, <em>**, [</em>ns<em>, ]</em>dir_fd=None<em>, </em>follow_symlinks=True*)</p>
<p>设置文件 <em>path</em> 的访问时间和修改时间。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.utime" target="_blank" rel="noopener"><code>utime()</code></a> 有 <em>times</em> 和 <em>ns</em> 两个可选参数，它们指定了设置给 <em>path</em> 的时间，用法如下：  </p>
<ul>
<li>如果指定 <em>ns</em>，它必须是一个 <code>(atime_ns, mtime_ns)</code> 形式的二元组，其中每个成员都是一个表示纳秒的整数。</li>
<li>如果 <em>times</em> 不为 <code>None</code>，则它必须是 <code>(atime, mtime)</code> 形式的二元组，其中每个成员都是一个表示秒的 int 或 float。</li>
<li>如果 <em>times</em> 为 <code>None</code> 且未指定 <em>ns</em>，则相当于指定 <code>ns=(atime_ns, mtime_ns)</code>，其中两个时间均为当前时间。</li>
</ul>
<p>同时为 <em>times</em> 和 <em>ns</em> 指定元组会出错。</p>
<p>注意，根据操作系统记录访问时间和修改时间的分辨率，后续的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 调用可能不会返回此处设置的确切时间。请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a>。保留精确时间的最佳方法是使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 结果对象中的 <em>st_atime_ns</em> 和 <em>st_mtime_ns</em> 字段，并将 <em>ns</em> 参数设置为 utime。</p>
<p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符</a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">指定基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。</p>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.utime</code>，附带参数 <code>path</code>、<code>times</code>、<code>ns</code>、<code>dir_fd</code>。</p>
<p><em>3.3 新版功能:</em> 新增支持将 <em>path</em> 参数指定为打开的文件描述符，以及支持 <em>dir_fd</em>、<em>follow_symlinks</em> 和 <em>ns</em> 参数。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.walk</code>(<em>top</em>, <em>topdown=True</em>, <em>onerror=None</em>, <em>followlinks=False</em>)</p>
<p>生成目录树中的文件名，方式是按上-&gt;下或下-&gt;上顺序浏览目录树。对于以 <em>top</em> 为根的目录树中的每个目录（包括 <em>top</em> 本身），它都会生成一个三元组 <code>(dirpath, dirnames, filenames)</code>。</p>
<p><em>dirpath</em> 是一个字符串，表示目录的路径。<em>dirnames</em> 是一个列表，内含 <em>dirpath</em> 中子目录的名称（不包括 <code>&#39;.&#39;</code> 和 <code>&#39;..&#39;</code> ）。<em>filenames</em> 也是列表，内含 <em>dirpath</em> 中文件（非目录）的名称。注意，列表中的名称不包含路径部分。要获取 <em>dirpath</em> 中文件或目录的完整路径（从 <em>top</em> 起始），请执行 <code>os.path.join(dirpath, name)</code>。</p>
<p>如果可选参数 <em>topdown</em> 为 <code>True</code> 或未指定，则在所有子目录的三元组之前生成父目录的三元组（目录是自上而下生成的）。如果 <em>topdown</em> 为 <code>False</code>，则在所有子目录的三元组生成之后再生成父目录的三元组（目录是自下而上生成的）。无论 <em>topdown</em> 为何值，在生成目录及其子目录的元组之前，都将检索全部子目录列表。</p>
<p>当 <em>topdown</em> 为 <code>True</code> 时，调用者可以就地修改 <em>dirnames</em> 列表（也许用到了 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#del" target="_blank" rel="noopener"><code>del</code></a> 或切片），而 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 将仅仅递归到仍保留在 <em>dirnames</em> 中的子目录内。这可用于减少搜索、加入特定的访问顺序，甚至可在继续 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 之前告知 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 由调用者新建或重命名的目录的信息。当 <em>topdown</em> 为 <code>False</code> 时，修改 <em>dirnames</em> 对 walk 的行为没有影响，因为在自下而上模式中，<em>dirnames</em> 中的目录是在 <em>dirpath</em> 本身之前生成的。</p>
<p>默认将忽略 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 调用中的错误。如果指定了可选参数 <em>onerror</em>，它应该是一个函数。出错时它会被调用，参数是一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 实例。它可以报告错误然后继续遍历，或者抛出异常然后中止遍历。注意，可以从异常对象的 <code>filename</code> 属性中获取出错的文件名。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 默认不会递归进指向目录的符号链接。可以在支持符号链接的系统上将 <em>followlinks</em> 设置为 <code>True</code>，以访问符号链接指向的目录。</p>
<blockquote>
<p> 注意，如果链接指向自身的父目录，则将 <em>followlinks</em> 设置为 <code>True</code> 可能导致无限递归。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 不会记录它已经访问过的目录。 </p>
<p> 如果传入的是相对路径，请不要在恢复 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 之间更改当前工作目录。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 不会更改当前目录，并假定其调用者也不会更改当前目录。 </p>
</blockquote>
<p>下面的示例遍历起始目录内所有子目录，打印每个目录内的文件占用的字节数，CVS 子目录不会被遍历:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> join, getsize</span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">'python/Lib/email'</span>):</span><br><span class="line">    print(root, <span class="string">"consumes"</span>, end=<span class="string">" "</span>)</span><br><span class="line">    print(sum(getsize(join(root, name)) <span class="keyword">for</span> name <span class="keyword">in</span> files), end=<span class="string">" "</span>)</span><br><span class="line">    print(<span class="string">"bytes in"</span>, len(files), <span class="string">"non-directory files"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'CVS'</span> <span class="keyword">in</span> dirs:</span><br><span class="line">        dirs.remove(<span class="string">'CVS'</span>)  <span class="comment"># don't visit CVS directories</span></span><br></pre></td></tr></table></figure>
<p>在下一个示例（<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree" target="_blank" rel="noopener"><code>shutil.rmtree()</code></a> 的简单实现）中，必须使树自下而上遍历，因为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rmdir" target="_blank" rel="noopener"><code>rmdir()</code></a> 只允许在目录为空时删除目录:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Delete everything reachable from the directory named in "top",</span></span><br><span class="line"><span class="comment"># assuming there are no symbolic links.</span></span><br><span class="line"><span class="comment"># CAUTION:  This is dangerous!  For example, if top == '/', it</span></span><br><span class="line"><span class="comment"># could delete all your disk files.</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(top, topdown=<span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">        os.remove(os.path.join(root, name))</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> dirs:</span><br><span class="line">        os.rmdir(os.path.join(root, name))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><em>在 3.5 版更改:</em> 现在，本函数调用的是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>os.scandir()</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>os.listdir()</code></a>，从而减少了调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 的次数而变得更快。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
<ul>
<li><p><code>os.fwalk</code>(<em>top=’.’</em>, <em>topdown=True</em>, <em>onerror=None</em>, <em>**, </em>follow_symlinks=False<em>, </em>dir_fd=None*)</p>
<p>本方法的行为与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 完全一样，除了它产生的是 4 元组 <code>(dirpath, dirnames, filenames, dirfd)</code>，并且它支持 <code>dir_fd</code>。</p>
<p><em>dirpath</em>、<em>dirnames</em> 和 <em>filenames</em> 与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 输出的相同，<em>dirfd</em> 是指向目录 <em>dirpath</em> 的文件描述符。</p>
<p>本函数始终支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。但是请注意，与其他函数不同，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fwalk" target="_blank" rel="noopener"><code>fwalk()</code></a> 的 <em>follow_symlinks</em> 的默认值为 <code>False</code>。</p>
<blockquote>
<p> 由于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fwalk" target="_blank" rel="noopener"><code>fwalk()</code></a> 会生成文件描述符，而它们仅在下一个迭代步骤前有效，因此如果要将描述符保留更久，则应复制它们（比如使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.dup" target="_blank" rel="noopener"><code>dup()</code></a>）。 </p>
</blockquote>
<p>下面的示例遍历起始目录内所有子目录，打印每个目录内的文件占用的字节数，CVS 子目录不会被遍历:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> root, dirs, files, rootfd <span class="keyword">in</span> os.fwalk(<span class="string">'python/Lib/email'</span>):</span><br><span class="line">    print(root, <span class="string">"consumes"</span>, end=<span class="string">""</span>)</span><br><span class="line">    print(sum([os.stat(name, dir_fd=rootfd).st_size <span class="keyword">for</span> name <span class="keyword">in</span> files]),</span><br><span class="line">          end=<span class="string">""</span>)</span><br><span class="line">    print(<span class="string">"bytes in"</span>, len(files), <span class="string">"non-directory files"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'CVS'</span> <span class="keyword">in</span> dirs:</span><br><span class="line">        dirs.remove(<span class="string">'CVS'</span>)  <span class="comment"># don't visit CVS directories</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在下一个示例中，必须使树自下而上遍历，因为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rmdir" target="_blank" rel="noopener"><code>rmdir()</code></a> 只允许在目录为空时删除目录:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Delete everything reachable from the directory named in "top",</span></span><br><span class="line"><span class="comment"># assuming there are no symbolic links.</span></span><br><span class="line"><span class="comment"># CAUTION:  This is dangerous!  For example, if top == '/', it</span></span><br><span class="line"><span class="comment"># could delete all your disk files.</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> root, dirs, files, rootfd <span class="keyword">in</span> os.fwalk(top, topdown=<span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">        os.unlink(name, dir_fd=rootfd)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> dirs:</span><br><span class="line">        os.rmdir(name, dir_fd=rootfd)</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
<p>3<em>.3 新版功能.</em></p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
<p><em>在 3.7 版更改:</em> 添加了对 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型路径的支持。</p>
<ul>
<li><p><code>os.memfd_create</code>(<em>name</em>[, <em>flags=os.MFD_CLOEXEC</em>])</p>
<p>创建一个匿名文件，返回指向该文件的文件描述符。<em>flags</em> 必须是系统上可用的 <code>os.MFD_*</code> 常量之一（或将它们按位“或”组合起来）。新文件描述符默认是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承的</a>。</p>
<p><em>name</em> 提供的名称会被用作文件名，并且 <code>/proc/self/fd/</code> 目录中相应符号链接的目标将显示为该名称。显示的名称始终以 <code>memfd:</code> 为前缀，并且仅用于调试目的。名称不会影响文件描述符的行为，因此多个文件可以有相同的名称，不会有副作用。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 3.17 或更高版本，且装有 glibc 2.27 或更高版本。</p>
<p><em>3.8 新版功能.</em> </p>
</li>
<li><p><code>os.MFD_CLOEXEC</code></p>
</li>
<li><p><code>os.MFD_ALLOW_SEALING</code></p>
</li>
<li><p><code>os.MFD_HUGETLB</code></p>
</li>
<li><p><code>os.MFD_HUGE_SHIFT</code></p>
</li>
<li><p><code>os.MFD_HUGE_MASK</code></p>
</li>
<li><p><code>os.MFD_HUGE_64KB</code></p>
</li>
<li><p><code>os.MFD_HUGE_512KB</code></p>
</li>
<li><p><code>os.MFD_HUGE_1MB</code></p>
</li>
<li><p><code>os.MFD_HUGE_2MB</code></p>
</li>
<li><p><code>os.MFD_HUGE_8MB</code></p>
</li>
<li><p><code>os.MFD_HUGE_16MB</code></p>
</li>
<li><p><code>os.MFD_HUGE_32MB</code></p>
</li>
<li><p><code>os.MFD_HUGE_256MB</code></p>
</li>
<li><p><code>os.MFD_HUGE_512MB</code></p>
</li>
<li><p><code>os.MFD_HUGE_1GB</code></p>
</li>
<li><p><code>os.MFD_HUGE_2GB</code></p>
</li>
<li><p><code>os.MFD_HUGE_16GB</code></p>
<p>以上标志位可以传递给 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.memfd_create" target="_blank" rel="noopener"><code>memfd_create()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 3.17 或更高版本，且装有 glibc 2.27 或更高版本。<code>MFD_HUGE*</code> 标志仅在 Linux 4.14 及以上可用。</p>
<p><em>3.8 新版功能.</em></p>
</li>
</ul>
<h3 id="Linux-扩展属性"><a href="#Linux-扩展属性" class="headerlink" title="Linux 扩展属性"></a>Linux 扩展属性</h3><p><em>3.3 新版功能.</em></p>
<p>这些函数仅在 Linux 上可用。</p>
<ul>
<li><p><code>os.getxattr</code>(<em>path</em>, <em>attribute</em>, <em>**, </em>follow_symlinks=True*)</p>
<p>返回 <em>path</em> 的扩展文件系统属性 <em>attribute</em> 的值。<em>attribute</em> 可以是 bytes 或 str （直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入）。如果是 str，则使用文件系统编码来编码字符串。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.getxattr</code>，附带参数 <code>path</code>、<code>attribute</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>path</em> 和 <em>attribute</em>。</p>
</li>
<li><p><code>os.listxattr</code>(<em>path=None</em>, <em>**, </em>follow_symlinks=True*)</p>
<p>返回一个列表，包含 <em>path</em> 的所有扩展文件系统属性。列表中的属性都表示为字符串，它们是根据文件系统编码解码出来的。如果 <em>path</em> 为 <code>None</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listxattr" target="_blank" rel="noopener"><code>listxattr()</code></a> 将检查当前目录。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.listxattr</code>，附带参数 <code>path</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os.removexattr</code>(<em>path</em>, <em>attribute</em>, <em>**, </em>follow_symlinks=True*)</p>
<p>从 <em>path</em> 中删除扩展文件系统属性 <em>attribute</em>。<em>attribute</em> 应该是 bytes 或 str （直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入）。如果是 str，则使用文件系统编码来编码字符串。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.removexattr</code>，附带参数 <code>path</code>、<code>attribute</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>path</em> 和 <em>attribute</em>。</p>
</li>
<li><p><code>os.setxattr</code>(<em>path</em>, <em>attribute</em>, <em>value</em>, <em>flags=0</em>, <em>**, </em>follow_symlinks=True*)</p>
<p>将 <em>path</em> 的扩展文件系统属性 <em>attribute</em> 设置为 <em>value</em>。<em>attribute</em> 必须是没有空字符的 bytes 或 str （直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入）。如果是 str，则应使用文件系统编码进行编码。<em>flags</em> 可以是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.XATTR_REPLACE" target="_blank" rel="noopener"><code>XATTR_REPLACE</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.XATTR_CREATE" target="_blank" rel="noopener"><code>XATTR_CREATE</code></a>。如果指定 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.XATTR_REPLACE" target="_blank" rel="noopener"><code>XATTR_REPLACE</code></a> 而该属性不存在，则抛出 <code>EEXISTS</code> 异常。如果指定 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.XATTR_CREATE" target="_blank" rel="noopener"><code>XATTR_CREATE</code></a> 而该属性已经存在，则不会创建该属性，抛出 <code>ENODATA</code> 异常。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。</p>
<blockquote>
<p> Linux kernel 2.6.39 以下版本的一个 bug 导致在某些文件系统上，flags 参数会被忽略。 </p>
</blockquote>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.setxattr</code>，附带参数 <code>path</code>、<code>attribute</code>、<code>value</code>、<code>flags</code>。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>path</em> 和 <em>attribute</em>。</p>
</li>
<li><p><code>os.XATTR_SIZE_MAX</code></p>
<p>一条扩展属性的值的最大大小。在当前的 Linux 上是 64 KiB。</p>
</li>
<li><p><code>os.XATTR_CREATE</code></p>
<p>这是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.setxattr" target="_blank" rel="noopener"><code>setxattr()</code></a> 的 flags 参数的可取值，它表示该操作必须创建一个属性。</p>
</li>
<li><p><code>os.XATTR_REPLACE</code></p>
<p>这是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.setxattr" target="_blank" rel="noopener"><code>setxattr()</code></a> 的 flags 参数的可取值，它表示该操作必须替换现有属性。</p>
</li>
</ul>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>下列函数可用于创建和管理进程。</p>
<p>所有 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*</code></a> 函数都接受一个参数列表，用来给新程序加载到它的进程中。在所有情况下，传递给新程序的第一个参数是程序本身的名称，而不是用户在命令行上输入的参数。对于 C 程序员来说，这就是传递给 <code>main()</code> 函数的 <code>argv[0]</code>。例如，<code>os.execv(&#39;/bin/echo&#39;, [&#39;foo&#39;, &#39;bar&#39;])</code> 只会在标准输出上打印 <code>bar</code>，而 <code>foo</code> 会被忽略。</p>
<ul>
<li><p><code>os.abort</code>()</p>
<p>发送 <code>SIGABRT</code> 信号到当前进程。在 Unix 上，默认行为是生成一个核心转储。在 Windows 上，该进程立即返回退出代码 <code>3</code>。请注意，使用 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.signal" target="_blank" rel="noopener"><code>signal.signal()</code></a> 可以为 <code>SIGABRT</code> 注册 Python 信号处理程序，而调用本函数将不会调用按前述方法注册的程序。</p>
</li>
<li><p><code>os.add_dll_directory</code>(<em>path</em>)</p>
<p>将路径添加到 DLL 搜索路径。当需要解析扩展模块的依赖时（扩展模块本身通过 sys.path 解析），会使用该搜索路径，<a href="https://docs.python.org/zh-cn/3.8/library/ctypes.html#module-ctypes" target="_blank" rel="noopener"><code>ctypes</code></a> 也会使用该搜索路径。要移除目录，可以在返回的对象上调用 <strong>close()</strong>，也可以在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句内使用本方法。参阅 <a href="https://msdn.microsoft.com/44228cf2-6306-466c-8f16-f513cd3ba8b5" target="_blank" rel="noopener">Microsoft 文档</a> 获取如何加载 DLL 的信息。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.add_dll_directory</code>，附带参数 <code>path</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。<em>3.8 新版功能:</em> 早期版本的 CPython 解析 DLL 时用的是当前进程的默认行为。这会导致不一致，比如不是每次都会去搜索 <code>PATH</code> 和当前工作目录，且系统函数（如 <code>AddDllDirectory</code> ）失效。在 3.8 中，DLL 的两种主要加载方式现在可以显式覆盖进程的行为，以确保一致性。请参阅 <a href="https://docs.python.org/zh-cn/3.8/whatsnew/3.8.html#bpo-36085-whatsnew" target="_blank" rel="noopener">移植说明</a> 了解如何更新你的库。</p>
</li>
<li><p><code>os.execl</code>(<em>path</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>)</p>
</li>
<li><p><code>os.execle</code>(<em>path</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>, <em>env</em>)</p>
</li>
<li><p><code>os.execlp</code>(<em>file</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>)</p>
</li>
<li><p><code>os.execlpe</code>(<em>file</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>, <em>env</em>)</p>
</li>
<li><p><code>os.execv</code>(<em>path</em>, <em>args</em>)</p>
</li>
<li><p><code>os.execve</code>(<em>path</em>, <em>args</em>, <em>env</em>)</p>
</li>
<li><p><code>os.execvp</code>(<em>file</em>, <em>args</em>)</p>
</li>
<li><p><code>os.execvpe</code>(<em>file</em>, <em>args</em>, <em>env</em>)</p>
<p>这些函数都将执行一个新程序，以替换当前进程。它们没有返回值。在 Unix 上，新程序会加载到当前进程中，且进程号与调用者相同。过程中的错误会被报告为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p>
<p>当前进程会被立即替换。打开的文件对象和描述符都不会刷新，因此如果这些文件上可能缓冲了数据，则应在调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*</code></a> 函数之前使用 <code>sys.stdout.flush()</code> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsync" target="_blank" rel="noopener"><code>os.fsync()</code></a> 刷新它们。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*</code></a> 函数的 “l” 和 “v” 变体不同在于命令行参数的传递方式。如果在编码时固定了参数数量，则 “l” 变体可能是最方便的，各参数作为 <code>execl*()</code> 函数的附加参数传入即可。当参数数量可变时，”v” 变体更方便，参数以列表或元组的形式作为 <em>args</em> 参数传递。在这两种情况下，子进程的第一个参数都应该是即将运行的命令名称，但这不是强制性的。</p>
<p>结尾包含 “p” 的变体（<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execlp" target="_blank" rel="noopener"><code>execlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execlpe" target="_blank" rel="noopener"><code>execlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execvp" target="_blank" rel="noopener"><code>execvp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execvpe" target="_blank" rel="noopener"><code>execvpe()</code></a> ）将使用 <code>PATH</code> 环境变量来查找程序 <em>file</em>。当环境被替换时（使用下一段讨论的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*e</code></a> 变体之一），<code>PATH</code> 变量将来自于新环境。其他变体 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>execl()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execle" target="_blank" rel="noopener"><code>execle()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execv" target="_blank" rel="noopener"><code>execv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 不使用 <code>PATH</code> 变量来查找程序，因此 <em>path</em> 必须包含正确的绝对或相对路径。</p>
<p>对于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execle" target="_blank" rel="noopener"><code>execle()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execlpe" target="_blank" rel="noopener"><code>execlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execvpe" target="_blank" rel="noopener"><code>execvpe()</code></a> （都以 “e” 结尾），<em>env</em> 参数是一个映射，用于定义新进程的环境变量（代替当前进程的环境变量）。而函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>execl()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execlp" target="_blank" rel="noopener"><code>execlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execv" target="_blank" rel="noopener"><code>execv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execvp" target="_blank" rel="noopener"><code>execvp()</code></a> 会将当前进程的环境变量过继给新进程。</p>
<p>某些平台上的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 可以将 <em>path</em> 指定为打开的文件描述符。当前平台可能不支持此功能，可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_fd" target="_blank" rel="noopener"><code>os.supports_fd</code></a> 检查它是否支持。如果不可用，则使用它会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.exec</code>，附带参数 <code>path</code>、<code>args</code>、<code>env</code>。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p>
<p><em>3.3 新版功能:</em> 新增支持将 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 的 <em>path</em> 参数指定为打开的文件描述符。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
</li>
<li><p><code>os._exit</code>(<em>n</em>)</p>
<p>以状态码 <em>n</em> 退出进程，不会调用清理处理程序，不会刷新 stdio，等等。</p>
<blockquote>
<p> 退出的标准方法是使用 <code>sys.exit(n)</code>。而 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os._exit" target="_blank" rel="noopener"><code>_exit()</code></a> 通常只应在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>fork()</code></a> 出的子进程中使用。 </p>
</blockquote>
<p> 以下是已定义的退出代码，可以用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os._exit" target="_blank" rel="noopener"><code>_exit()</code></a>，尽管它们不是必需的。这些退出代码通常用于 Python 编写的系统程序，例如邮件服务器的外部命令传递程序。 </p>
<blockquote>
<p> 其中部分退出代码在部分 Unix 平台上可能不可用，因为平台间存在差异。如果底层平台定义了这些常量，那上层也会定义。 </p>
</blockquote>
</li>
<li><p><code>os.EX_OK</code></p>
<p>退出代码，表示未发生任何错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_USAGE</code></p>
<p>退出代码，表示命令使用不正确，如给出的参数数量有误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_DATAERR</code></p>
<p>退出代码，表示输入数据不正确。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_NOINPUT</code></p>
<p>退出代码，表示某个输入文件不存在或不可读。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_NOUSER</code></p>
<p>退出代码，表示指定的用户不存在。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_NOHOST</code></p>
<p>退出代码，表示指定的主机不存在。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_UNAVAILABLE</code></p>
<p>退出代码，表示所需的服务不可用。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_SOFTWARE</code></p>
<p>退出代码，表示检测到内部软件错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_OSERR</code></p>
<p>退出代码，表示检测到操作系统错误，例如无法 fork 或创建管道。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_OSFILE</code></p>
<p>退出代码，表示某些系统文件不存在、无法打开或发生其他错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_CANTCREAT</code></p>
<p>退出代码，表示无法创建用户指定的输出文件。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_IOERR</code></p>
<p>退出代码，表示对某些文件进行读写时发生错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_TEMPFAIL</code></p>
<p>退出代码，表示发生了暂时性故障。它可能并非意味着真正的错误，例如在可重试的情况下无法建立网络连接。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_PROTOCOL</code></p>
<p>退出代码，表示协议交换是非法的、无效的或无法解读的。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_NOPERM</code></p>
<p>退出代码，表示没有足够的权限执行该操作（但不适用于文件系统问题）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_CONFIG</code></p>
<p>退出代码，表示发生某种配置错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.EX_NOTFOUND</code></p>
<p>退出代码，表示的内容类似于“找不到条目”。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.fork</code>()</p>
<p>Fork 出一个子进程。在子进程中返回 <code>0</code>，在父进程中返回子进程的进程号。如果发生错误，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。注意，当从线程中使用 <code>fork()</code> 时，某些平台（包括 FreeBSD &lt;= 6.3 和 Cygwin）存在已知问题。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.fork</code>，没有附带参数。<em>在 3.8 版更改:</em> 不再支持在子解释器中调用 <code>fork()</code> （将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常）</p>
<p> 有关 SSL 模块与 fork() 结合的应用，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/ssl.html#module-ssl" target="_blank" rel="noopener"><code>ssl</code></a>。 </p>
<p> <a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix </p>
</li>
<li><p><code>os.forkpty</code>()</p>
<p>Fork 出一个子进程，使用新的伪终端作为子进程的控制终端。返回一对 <code>(pid, fd)</code>，其中 <em>pid</em> 在子进程中为 <code>0</code>，这是父进程中新子进程的进程号，而 <em>fd</em> 是伪终端主设备的文件描述符。对于更便于移植的方法，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/pty.html#module-pty" target="_blank" rel="noopener"><code>pty</code></a> 模块。如果发生错误，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.forkpty</code>，没有附带参数。<em>在 3.8 版更改:</em> 不再支持在子解释器中调用 <code>forkpty()</code> （将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 某些 Unix。</p>
</li>
<li><p><code>os.kill</code>(<em>pid</em>, <em>sig</em>)</p>
<p>将信号 <em>sig</em> 发送至进程 <em>pid</em>。特定平台上可用的信号常量定义在 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#module-signal" target="_blank" rel="noopener"><code>signal</code></a> 模块中。Windows： <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.CTRL_C_EVENT" target="_blank" rel="noopener"><code>signal.CTRL_C_EVENT</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.CTRL_BREAK_EVENT" target="_blank" rel="noopener"><code>signal.CTRL_BREAK_EVENT</code></a> 信号是特殊信号，只能发送给共享同一个控制台窗口的控制台进程，如某些子进程。<em>sig</em> 取任何其他值将导致该进程被 TerminateProcess API 无条件终止，且退出代码为 <em>sig</em>。Windows 版本的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.kill" target="_blank" rel="noopener"><code>kill()</code></a> 还需要传入待结束进程的句柄。另请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.pthread_kill" target="_blank" rel="noopener"><code>signal.pthread_kill()</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.kill</code>，附带参数 <code>pid</code>、<code>sig</code>。<em>3.2 新版功能:</em> Windows 支持。</p>
</li>
<li><p><code>os.killpg</code>(<em>pgid</em>, <em>sig</em>)</p>
<p>将信号 <em>sig</em> 发送给进程组 <em>pgid</em>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.killpg</code>，附带参数 <code>pgid</code>、<code>sig</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.nice</code>(<em>increment</em>)</p>
<p>将进程的优先级（nice 值）增加 <em>increment</em>，返回新的 nice 值。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.plock</code>(<em>op</em>)</p>
<p>将程序段锁定到内存中。<em>op</em> 的值（定义在  中）决定了哪些段被锁定。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.popen</code>(<em>cmd</em>, <em>mode=’r’</em>, <em>buffering=-1</em>)</p>
<p>打开一个管道，它通往 / 接受自命令 <em>cmd</em>。返回值是连接到管道的文件对象，根据 <em>mode</em> 是 <code>&#39;r&#39;</code> （默认）还是 <code>&#39;w&#39;</code> 决定该对象可以读取还是写入。<em>buffering</em> 参数与内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 相应的参数含义相同。返回的文件对象只能读写文本字符串，不能是字节类型。</p>
<p>如果子进程成功退出，则 <code>close</code> 方法返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。如果发生错误，则返回子进程的返回码。在 POSIX 系统上，如果返回码为正，则它就是进程返回值左移一个字节后的值。如果返回码为负，则进程是被信号终止的，返回码取反后就是该信号。（例如，如果子进程被终止，则返回值可能是 <code>- signal.SIGKILL</code>。）在 Windows 系统上，返回值包含子进程的返回码（有符号整数）。</p>
<p>本方法是使用 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#subprocess.Popen" target="_blank" rel="noopener"><code>subprocess.Popen</code></a> 实现的，如需更强大的方法来管理和沟通子进程，请参阅该类的文档。</p>
</li>
<li><p><code>os.posix_spawn</code>(<em>path</em>, <em>argv</em>, <em>env</em>, <em>**, </em>file_actions=None<em>, </em>setpgroup=None<em>, </em>resetids=False<em>, </em>setsid=False<em>, </em>setsigmask=()<em>, </em>setsigdef=()<em>, </em>scheduler=None*)</p>
<p>包装 <code>posix_spawn()</code> C 库 API，使其可以从 Python 调用。</p>
<p>大多数用户应使用 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#subprocess.run" target="_blank" rel="noopener"><code>subprocess.run()</code></a> 代替 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_spawn" target="_blank" rel="noopener"><code>posix_spawn()</code></a>。</p>
<p>仅位置参数 (Positional-only arguments) <em>path</em>、<em>args</em> 和 <em>env</em> 与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 中的类似。</p>
<p><em>path</em> 参数是可执行文件的路径，<em>path</em> 中应该包含目录。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_spawnp" target="_blank" rel="noopener"><code>posix_spawnp()</code></a> 可直接传入可执行文件名称，不带有目录。</p>
<p><em>file_actions</em> 参数可以是由元组组成的序列，序列描述了对子进程中指定文件描述符采取的操作，这些操作会在 C 库实现的 <code>fork()</code> 和 <code>exec()</code> 步骤间完成。每个元组的第一个元素必须是下面列出的三个类型指示符之一，用于描述元组剩余的元素：</p>
<ul>
<li><p><code>os.POSIX_SPAWN_OPEN</code></p>
<p>(<code>os.POSIX_SPAWN_OPEN</code>, <em>fd</em>, <em>path</em>, <em>flags</em>, <em>mode</em>)执行 <code>os.dup2(os.open(path, flags, mode), fd)</code>。</p>
</li>
<li><p><code>os.POSIX_SPAWN_CLOSE</code></p>
<p>(<code>os.POSIX_SPAWN_CLOSE</code>, <em>fd</em>)执行 <code>os.close(fd)</code>。</p>
</li>
<li><p><code>os.POSIX_SPAWN_DUP2</code></p>
<p>(<code>os.POSIX_SPAWN_DUP2</code>, <em>fd</em>, <em>new_fd</em>)执行 <code>os.dup2(fd, new_fd)</code>。</p>
</li>
</ul>
<p>这些元组对应于 C 库 <code>posix_spawn_file_actions_addopen()</code>， <code>posix_spawn_file_actions_addclose()</code> 和 <code>posix_spawn_file_actions_adddup2()</code> API 调用，它们为调用 <code>posix_spawn()</code> 自身做准备。</p>
<p><em>setpgroup</em> 参数将子进程的进程组设置为指定值。如果指定值为 0，则子进程的进程组 ID 将与其进程 ID 相同。如果未设置 <em>setpgroup</em> 值，则子进程将继承父进程的进程组 ID。本参数对应于 C 库 <code>POSIX_SPAWN_SETPGROUP</code> 标志。</p>
<p>如果 <em>resetids</em> 参数为 <code>True</code>，则会将子进程的有效用户 ID 和有效组 ID 重置为父进程的实际用户 ID 和实际组 ID。如果该参数为 <code>False</code>，则子进程保留父进程的有效用户 ID 和有效组 ID。无论哪种情况，若在可执行文件上启用了 “设置用户 ID” 和 “设置组 ID” 权限位，它们将覆盖有效用户 ID 和有效组 ID 的设置。本参数对应于 C 库 <code>POSIX_SPAWN_RESETIDS</code> 标志。</p>
<p>如果 <em>setsid</em> 参数为 <code>True</code>，它将为 posix_spawn 新建一个会话 ID。<em>setsid</em> 需要 <code>POSIX_SPAWN_SETSID</code> 或 <code>POSIX_SPAWN_SETSID_NP</code> 标志，否则会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p>
<p><em>setsigmask</em> 参数将信号掩码设置为指定的信号集合。如果未使用该参数，则子进程将继承父进程的信号掩码。本参数对应于 C 库 <code>POSIX_SPAWN_SETSIGMASK</code> 标志。</p>
<p><em>sigdef</em> 参数将集合中所有信号的操作全部重置为默认。本参数对应于 C 库 <code>POSIX_SPAWN_SETSIGDEF</code> 标志。</p>
<p><em>scheduler</em> 参数必须是一个元组，其中包含调度器策略（可选）以及携带了调度器参数的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_param" target="_blank" rel="noopener"><code>sched_param</code></a> 实例。在调度器策略所在位置为 <code>None</code> 表示未提供该值。本参数是 C 库 <code>POSIX_SPAWN_SETSCHEDPARAM</code> 和 <code>POSIX_SPAWN_SETSCHEDULER</code> 标志的组合。</p>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.posix_spawn</code>，附带参数 <code>path</code>、<code>argv</code>、<code>env</code>。</p>
<p><em>3.8 新版功能.</em></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.posix_spawnp</code>(<em>path</em>, <em>argv</em>, <em>env</em>, <em>**, </em>file_actions=None<em>, </em>setpgroup=None<em>, </em>resetids=False<em>, </em>setsid=False<em>, </em>setsigmask=()<em>, </em>setsigdef=()<em>, </em>scheduler=None*)</p>
<p>包装 <code>posix_spawnp()</code> C 库 API，使其可以从 Python 调用。</p>
<p>与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_spawn" target="_blank" rel="noopener"><code>posix_spawn()</code></a> 相似，但是系统会在 <code>PATH</code> 环境变量指定的目录列表中搜索可执行文件 <em>executable</em> （与 <code>execvp(3)</code> 相同）。</p>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.posix_spawn</code>，附带参数 <code>path</code>、<code>argv</code>、<code>env</code>。</p>
<p><em>3.8 新版功能.</em></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_spawn" target="_blank" rel="noopener"><code>posix_spawn()</code></a> 文档。</p>
</li>
<li><p><code>os.register_at_fork</code>(<em>**, </em>before=None<em>, </em>after_in_parent=None<em>, </em>after_in_child=None*)</p>
<p>注册可调用对象，在使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>os.fork()</code></a> 或类似的进程克隆 API 派生新的子进程时，这些对象会运行。参数是可选的，且为仅关键字 (Keyword-only) 参数。每个参数指定一个不同的调用点。</p>
<ul>
<li><em>before</em> 是一个函数，在 fork 子进程前调用。</li>
<li><em>after_in_parent</em> 是一个函数，在 fork 子进程后从父进程调用。</li>
<li><em>after_in_child</em> 是一个函数，从子进程中调用。</li>
</ul>
<p>只有希望控制权回到 Python 解释器时，才进行这些调用。典型的 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>子进程</code></a> 启动时不会触发它们，因为子进程不会重新进入解释器。</p>
<p>在注册的函数中，用于 fork 前运行的函数将按与注册相反的顺序调用。用于 fork 后（从父进程或子进程）运行的函数按注册顺序调用。</p>
<p>注意，第三方 C 代码的 <code>fork()</code> 调用可能不会调用这些函数，除非它显式调用了 <a href="https://docs.python.org/zh-cn/3.8/c-api/sys.html#c.PyOS_BeforeFork" target="_blank" rel="noopener"><code>PyOS_BeforeFork()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/c-api/sys.html#c.PyOS_AfterFork_Parent" target="_blank" rel="noopener"><code>PyOS_AfterFork_Parent()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/c-api/sys.html#c.PyOS_AfterFork_Child" target="_blank" rel="noopener"><code>PyOS_AfterFork_Child()</code></a>。</p>
<p>函数注册后无法注销。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
<p><em>3.7 新版功能.</em></p>
</li>
<li><p><code>os.spawnl</code>(<em>mode</em>, <em>path</em>, <em>…</em>)</p>
</li>
<li><p><code>os.spawnle</code>(<em>mode</em>, <em>path</em>, <em>…</em>, <em>env</em>)</p>
</li>
<li><p><code>os.spawnlp</code>(<em>mode</em>, <em>file</em>, <em>…</em>)</p>
</li>
<li><p><code>os.spawnlpe</code>(<em>mode</em>, <em>file</em>, <em>…</em>, <em>env</em>)</p>
</li>
<li><p><code>os.spawnv</code>(<em>mode</em>, <em>path</em>, <em>args</em>)</p>
</li>
<li><p><code>os.spawnve</code>(<em>mode</em>, <em>path</em>, <em>args</em>, <em>env</em>)</p>
</li>
<li><p><code>os.spawnvp</code>(<em>mode</em>, <em>file</em>, <em>args</em>)</p>
</li>
<li><p><code>os.spawnvpe</code>(<em>mode</em>, <em>file</em>, <em>args</em>, <em>env</em>)<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener">¶</a></p>
<p>在新进程中执行程序 <em>path</em>。</p>
<p>（注意，<a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 模块提供了更强大的工具来生成新进程并跟踪执行结果，使用该模块比使用这些函数更好。尤其应当检查 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#subprocess-replacements" target="_blank" rel="noopener">Replacing Older Functions with the subprocess Module</a> 部分。）</p>
<p><em>mode</em> 为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_NOWAIT" target="_blank" rel="noopener"><code>P_NOWAIT</code></a> 时，本函数返回新进程的进程号。<em>mode</em> 为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_WAIT" target="_blank" rel="noopener"><code>P_WAIT</code></a> 时，如果进程正常退出，返回退出代码，如果被终止，返回 <code>-signal</code>，其中 <em>signal</em> 是终止进程的信号。在 Windows 上，进程号实际上是进程句柄，因此可以与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 函数一起使用。</p>
<p>注意在 VxWorks 上，新进程被终止时，本函数不会返回 <code>-signal</code>，而是会抛出 OSError 异常。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 函数的 “l” 和 “v” 变体不同在于命令行参数的传递方式。如果在编码时固定了参数数量，则 “l” 变体可能是最方便的，各参数作为 <code>spawnl*()</code> 函数的附加参数传入即可。当参数数量可变时，”v” 变体更方便，参数以列表或元组的形式作为 <em>args</em> 参数传递。在这两种情况下，子进程的第一个参数都必须是即将运行的命令名称。</p>
<p>结尾包含第二个 “p” 的变体（<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlp" target="_blank" rel="noopener"><code>spawnlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlpe" target="_blank" rel="noopener"><code>spawnlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvp" target="_blank" rel="noopener"><code>spawnvp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener"><code>spawnvpe()</code></a>）将使用 <code>PATH</code> 环境变量来查找程序 <em>file</em>。当环境被替换时（使用下一段讨论的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*e</code></a> 变体之一），<code>PATH</code> 变量将来自于新环境。其他变体 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawnl()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnle" target="_blank" rel="noopener"><code>spawnle()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnv" target="_blank" rel="noopener"><code>spawnv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnve" target="_blank" rel="noopener"><code>spawnve()</code></a> 不使用 <code>PATH</code> 变量来查找程序，因此 <em>path</em> 必须包含正确的绝对或相对路径。</p>
<p>对于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnle" target="_blank" rel="noopener"><code>spawnle()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlpe" target="_blank" rel="noopener"><code>spawnlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnve" target="_blank" rel="noopener"><code>spawnve()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener"><code>spawnvpe()</code></a> （都以 “e” 结尾），<em>env</em> 参数是一个映射，用于定义新进程的环境变量（代替当前进程的环境变量）。而函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawnl()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlp" target="_blank" rel="noopener"><code>spawnlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnv" target="_blank" rel="noopener"><code>spawnv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvp" target="_blank" rel="noopener"><code>spawnvp()</code></a> 会将当前进程的环境变量过继给新进程。注意，<em>env</em> 字典中的键和值必须是字符串。无效的键或值将导致函数出错，返回值为 <code>127</code>。</p>
<p>例如，以下对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlp" target="_blank" rel="noopener"><code>spawnlp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener"><code>spawnvpe()</code></a> 的调用是等效的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">  os.spawnlp(os.P_WAIT, <span class="string">'cp'</span>, <span class="string">'cp'</span>, <span class="string">'index.html'</span>, <span class="string">'/dev/null'</span>)</span><br><span class="line"></span><br><span class="line">  L = [<span class="string">'cp'</span>, <span class="string">'index.html'</span>, <span class="string">'/dev/null'</span>]</span><br><span class="line">os.spawnvpe(os.P_WAIT, <span class="string">'cp'</span>, L, os.environ)</span><br></pre></td></tr></table></figure>
<p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.spawn</code>，附带参数 <code>mode</code>、<code>path</code>、<code>args</code>、<code>env</code>。</p>
</li>
</ul>
<p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlp" target="_blank" rel="noopener"><code>spawnlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlpe" target="_blank" rel="noopener"><code>spawnlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvp" target="_blank" rel="noopener"><code>spawnvp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener"><code>spawnvpe()</code></a> 在 Windows 上不可用。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnle" target="_blank" rel="noopener"><code>spawnle()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnve" target="_blank" rel="noopener"><code>spawnve()</code></a> 在 Windows 上不是线程安全的，建议使用 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 模块替代。</p>
<p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p>
<ul>
<li><p><code>os.P_NOWAIT</code></p>
</li>
<li><p><code>os.P_NOWAITO</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 系列函数的 <em>mode</em> 参数的可取值。如果给出这些值中的任何一个，则 <code>spawn*()</code> 函数将在创建新进程后立即返回，且返回值为进程号。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p>
</li>
<li><p><code>os.P_WAIT</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 系列函数的 <em>mode</em> 参数的可取值。如果将 <em>mode</em> 指定为该值，则 <code>spawn*()</code> 函数将在新进程运行完毕后返回，运行成功则返回进程的退出代码，被信号终止则返回 <code>-signal</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p>
</li>
<li><p><code>os.P_DETACH</code></p>
</li>
<li><p><code>os.P_OVERLAY</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 系列函数的 <em>mode</em> 参数的可取值。它们比上面列出的值可移植性差。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_DETACH" target="_blank" rel="noopener"><code>P_DETACH</code></a> 与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_NOWAIT" target="_blank" rel="noopener"><code>P_NOWAIT</code></a> 相似，但是新进程会与父进程的控制台脱离。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_OVERLAY" target="_blank" rel="noopener"><code>P_OVERLAY</code></a> 则会替换当前进程，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 函数将不会返回。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。</p>
</li>
<li><p><code>os.startfile</code>(<em>path</em>[, <em>operation</em>])</p>
<p>使用已关联的应用程序打开文件。当 <em>operation</em> 未指定或指定为 <code>&#39;open&#39;</code> 时，这类似于在 Windows 资源管理器中双击文件，或在交互式命令行中将文件名作为 <strong>start</strong> 命令的参数：通过扩展名相关联的应用程序（如果有）打开文件。当指定另一个 <em>operation</em> 时，它必须是一个“命令动词” (“command verb”)，该词指定对文件执行的操作。Microsoft 文档中的常用动词有 <code>&#39;print&#39;</code> 和 <code>&#39;edit&#39;</code> （用于文件），以及 <code>&#39;explore&#39;</code> 和 <code>&#39;find&#39;</code> （用于目录）。关联的应用程序启动后 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.startfile" target="_blank" rel="noopener"><code>startfile()</code></a> 就会立即返回。本函数没有等待应用程序关闭的选项，也没有办法检索应用程序的退出状态。<em>path</em> 参数是基于当前目录的相对路径。如果要使用绝对路径，请确保第一个字符不是斜杠 (<code>&#39;/&#39;</code>)，是斜杠的话底层的 Win32 <code>ShellExecute()</code> 函数将失效。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.normpath" target="_blank" rel="noopener"><code>os.path.normpath()</code></a> 函数确保路径已针对 Win32 正确编码。为了减少解释器的启动开销，直到第一次调用本函数后，才解析 Win32 <code>ShellExecute()</code> 函数。如果无法解析该函数，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.startfile</code>，附带参数 <code>path</code>、<code>operation</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。</p>
</li>
<li><p><code>os.system</code>(<em>command</em>)</p>
<p>在子 shell 中执行命令（字符串）。这是调用标准 C 函数 <code>system()</code> 来实现的，因此限制条件与该函数相同。对 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a> 等的更改不会反映在执行命令的环境中。<em>command</em> 产生的任何输出将被发送到解释器标准输出流。在 Unix 上，返回值是进程的退出状态，编码格式与为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait" target="_blank" rel="noopener"><code>wait()</code></a> 指定的格式相同。注意，POSIX 没有指定 C 函数 <code>system()</code> 返回值的含义，因此 Python 函数的返回值与系统有关。在 Windows 上，返回值是运行 <em>command</em> 后系统 Shell 返回的值。该 Shell 由 Windows 环境变量 <code>COMSPEC</code>: 给出：通常是 <strong>cmd.exe</strong>，它会返回命令的退出状态。在使用非原生 Shell 的系统上，请查阅 Shell 的文档。<a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 模块提供了更强大的工具来生成新进程并跟踪执行结果，使用该模块比使用本函数更好。参阅 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 文档中的 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#subprocess-replacements" target="_blank" rel="noopener">Replacing Older Functions with the subprocess Module</a> 部分以获取有用的帮助。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.system</code>，附带参数 <code>command</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p>
</li>
<li><p><code>os.times</code>()</p>
<p>返回当前的全局进程时间。返回值是一个有 5 个属性的对象：<code>user</code> - 用户时间<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>system</code></a> - 系统时间<code>children_user</code> - 所有子进程的用户时间<code>children_system</code> - 所有子进程的系统时间<code>elapsed</code> - 从过去的固定时间点起，经过的真实时间为了向后兼容，该对象的行为也类似于五元组，按照 <code>user</code>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>system</code></a>，<code>children_user</code>，<code>children_system</code> 和 <code>elapsed</code> 顺序组成。在 Unix 上请参阅 <em><a href="https://manpages.debian.org/times(2" target="_blank" rel="noopener">times(2)</a>)</em> 和 <em><a href="https://manpages.debian.org/times(3" target="_blank" rel="noopener">times(3)</a>)</em> 手册页，在 Windows 上请参阅 <a href="https://docs.microsoft.com/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocesstimes" target="_blank" rel="noopener">the GetProcessTimes MSDN</a> 。在 Windows 上，只有 <code>user</code> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>system</code></a> 是已知的，其他属性均为零。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.3 版更改:</em> 返回结果的类型由元组变成一个类似元组的对象，同时具有命名的属性。</p>
</li>
<li><p><code>os.wait</code>()</p>
<p>等待子进程执行完毕，返回一个元组，包含其 pid 和退出状态指示：一个 16 位数字，其低字节是终止该进程的信号编号，高字节是退出状态码（信号编号为零的情况下），如果生成了核心文件，则低字节的高位会置位。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.waitid</code>(<em>idtype</em>, <em>id</em>, <em>options</em>)</p>
<p>等待一个或多个子进程执行完毕。<em>idtype</em> 可以是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_PID" target="_blank" rel="noopener"><code>P_PID</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_PGID" target="_blank" rel="noopener"><code>P_PGID</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_ALL" target="_blank" rel="noopener"><code>P_ALL</code></a>。<em>id</em> 指定要等待的 pid。<em>options</em> 是由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WEXITED" target="_blank" rel="noopener"><code>WEXITED</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WSTOPPED" target="_blank" rel="noopener"><code>WSTOPPED</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WCONTINUED" target="_blank" rel="noopener"><code>WCONTINUED</code></a> 中的一个或多个进行或运算构造的，且额外可以与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WNOHANG" target="_blank" rel="noopener"><code>WNOHANG</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WNOWAIT" target="_blank" rel="noopener"><code>WNOWAIT</code></a> 进行或运算。返回值是一个对象，对应着 <code>siginfo_t</code> 结构体中的数据，即： <code>si_pid</code>, <code>si_uid</code>, <code>si_signo</code>, <code>si_status</code>, <code>si_code</code> 或 <code>None</code> （如果指定了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WNOHANG" target="_blank" rel="noopener"><code>WNOHANG</code></a> 且没有子进程处于等待状态）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.P_PID</code></p>
</li>
<li><p><code>os.P_PGID</code></p>
</li>
<li><p><code>os.P_ALL</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitid" target="_blank" rel="noopener"><code>waitid()</code></a> 的 <em>idtype</em> 参数的可取值。它们影响 <em>id</em> 的解释方式。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.WEXITED</code></p>
</li>
<li><p><code>os.WSTOPPED</code></p>
</li>
<li><p><code>os.WNOWAIT</code></p>
<p>用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitid" target="_blank" rel="noopener"><code>waitid()</code></a> 的 <em>options</em> 参数的标志位，指定要等待的子进程信号。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.CLD_EXITED</code></p>
</li>
<li><p><code>os.CLD_DUMPED</code></p>
</li>
<li><p><code>os.CLD_TRAPPED</code></p>
</li>
<li><p><code>os.CLD_CONTINUED</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitid" target="_blank" rel="noopener"><code>waitid()</code></a> 返回的结果中，<code>si_code</code> 的可取值。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p>
</li>
<li><p><code>os.waitpid</code>(<em>pid</em>, <em>options</em>)</p>
<p>本函数的细节在 Unix 和 Windows 上有不同之处。</p>
<p>在 Unix 上：等待进程号为 <em>pid</em> 的子进程执行完毕，返回一个元组，内含其进程 ID 和退出状态指示（编码与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait" target="_blank" rel="noopener"><code>wait()</code></a> 相同）。调用的语义受整数 <em>options</em> 的影响，常规操作下该值应为 <code>0</code>。</p>
<p>如果 <em>pid</em> 大于 <code>0</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 会获取该指定进程的状态信息。如果 <em>pid</em> 为 <code>0</code>，则获取当前进程所在进程组中的所有子进程的状态。如果 <em>pid</em> 为 <code>-1</code>，则获取当前进程的子进程状态。如果 <em>pid</em> 小于 <code>-1</code>，则获取进程组 <code>-pid</code> （ <em>pid</em> 的绝对值）中所有进程的状态。</p>
<p>当系统调用返回 -1 时，将抛出带有错误码的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p>
<p>在 Windows 上：等待句柄为 <em>pid</em> 的进程执行完毕，返回一个元组，内含 <em>pid</em> 以及左移 8 位后的退出状态码（移位简化了跨平台使用本函数）。小于或等于 <code>0</code> 的 <em>pid</em> 在 Windows 上没有特殊含义，且会抛出异常。整数值 <em>options</em> 无效。<em>pid</em> 可以指向任何 ID 已知的进程，不一定是子进程。调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 函数时传入 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_NOWAIT" target="_blank" rel="noopener"><code>P_NOWAIT</code></a> 将返回合适的进程句柄。</p>
<p><em>在 3.5 版更改:</em> 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p>
</li>
<li><p><code>os.wait3</code>(<em>options</em>)</p>
<p>与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 相似，差别在于没有进程 ID 参数，且返回一个 3 元组，其中包括子进程 ID，退出状态指示和资源使用信息。关于资源使用信息的详情，请参考 <a href="https://docs.python.org/zh-cn/3.8/library/resource.html#module-resource" target="_blank" rel="noopener"><code>resource</code></a>.<a href="https://docs.python.org/zh-cn/3.8/library/resource.html#resource.getrusage" target="_blank" rel="noopener"><code>getrusage()</code></a>。option 参数与传入 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait4" target="_blank" rel="noopener"><code>wait4()</code></a> 的相同。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.wait4</code>(<em>pid</em>, <em>options</em>)</p>
<p>与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 相似，差别在本方法返回一个 3 元组，其中包括子进程 ID，退出状态指示和资源使用信息。关于资源使用信息的详情，请参考 <a href="https://docs.python.org/zh-cn/3.8/library/resource.html#module-resource" target="_blank" rel="noopener"><code>resource</code></a>.<a href="https://docs.python.org/zh-cn/3.8/library/resource.html#resource.getrusage" target="_blank" rel="noopener"><code>getrusage()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait4" target="_blank" rel="noopener"><code>wait4()</code></a> 的参数与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 的参数相同。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.WNOHANG</code></p>
<p>用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 的选项，如果没有立即可用的子进程状态，则立即返回。在这种情况下，函数返回 <code>(0, 0)</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.WCONTINUED</code></p>
<p>被任务控制 (job control) 停止的子进程，如果上次报告状态后已恢复运行，则此选项将报告这些子进程。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 部分 Unix 系统。</p>
</li>
<li><p><code>os.WUNTRACED</code></p>
<p>已停止的子进程，如果自停止以来尚未报告其当前状态，则此选项将报告这些子进程。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
</ul>
<p>下列函数采用进程状态码作为参数，状态码由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>system()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait" target="_blank" rel="noopener"><code>wait()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 返回。它们可用于确定进程上发生的操作。</p>
<ul>
<li><p><code>os.WCOREDUMP</code>(<em>status</em>)</p>
<p>如果为该进程生成了核心转储，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.WIFCONTINUED</code>(<em>status</em>)</p>
<p>如果进程被任务控制 (job control) 停止后，又重新继续运行，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.WIFSTOPPED</code>(<em>status</em>)</p>
<p>如果进程已停止，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.WIFSIGNALED</code>(<em>status</em>)</p>
<p>如果进程由于信号而退出，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.WIFEXITED</code>(<em>status</em>)</p>
<p>如果进程使用 <em><a href="https://manpages.debian.org/exit(2" target="_blank" rel="noopener">exit(2)</a>)</em> 系统调用退出，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.WEXITSTATUS</code>(<em>status</em>)</p>
<p>如果 <code>WIFEXITED(status)</code> 为值，则将整数形参返回给 <em><a href="https://manpages.debian.org/exit(2" target="_blank" rel="noopener">exit(2)</a>)</em> 系统调用。 否则，返回值将没有任何意义。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.WSTOPSIG</code>(<em>status</em>)</p>
<p>返回导致进程停止的信号。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.WTERMSIG</code>(<em>status</em>)</p>
<p>返回导致进程退出的信号。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
</ul>
<h2 id="调度器接口"><a href="#调度器接口" class="headerlink" title="调度器接口"></a>调度器接口</h2><p>这些函数控制操作系统如何为进程分配 CPU 时间。 它们仅在某些 Unix 平台上可用。 更多细节信息请查阅你所用 Unix 的指南页面。</p>
<p><em>3.3 新版功能.</em></p>
<p>以下调度策略如果被操作系统支持就会对外公开。</p>
<ul>
<li><p><code>os.SCHED_OTHER</code></p>
<p>默认调度策略。</p>
</li>
<li><p><code>os.SCHED_BATCH</code></p>
<p>用于 CPU 密集型进程的调度策略，它会尽量为计算机中的其余任务保留交互性。</p>
</li>
<li><p><code>os.SCHED_IDLE</code></p>
<p>用于极低优先级的后台任务的调度策略。</p>
</li>
<li><p><code>os.SCHED_SPORADIC</code></p>
<p>用于偶发型服务程序的调度策略。</p>
</li>
<li><p><code>os.SCHED_FIFO</code></p>
<p>先进先出的调度策略。</p>
</li>
<li><p><code>os.SCHED_RR</code></p>
<p>循环式的调度策略。</p>
</li>
<li><p><code>os.SCHED_RESET_ON_FORK</code></p>
<p>此旗标可与任何其他调度策略进行 OR 运算。 当带有此旗标的进程设置分叉时，其子进程的调度策略和优先级会被重置为默认值。</p>
</li>
<li><p><em>class</em> <code>os.sched_param</code>(<em>sched_priority</em>)</p>
<p>这个类表示在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_setparam" target="_blank" rel="noopener"><code>sched_setparam()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_setscheduler" target="_blank" rel="noopener"><code>sched_setscheduler()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_getparam" target="_blank" rel="noopener"><code>sched_getparam()</code></a> 中使用的可修改调度形参。 它属于不可变对象。目前它只有一个可能的形参：<code>sched_priority</code>一个调度策略的调度优先级。</p>
</li>
<li><p><code>os.sched_get_priority_min</code>(<em>policy</em>)</p>
<p>获取 <em>policy</em> 的最小优先级数值。 <em>policy</em> 是以上调度策略常量之一。</p>
</li>
<li><p><code>os.sched_get_priority_max</code>(<em>policy</em>)</p>
<p>获取 <em>policy</em> 的最高优先级数值。 <em>policy</em> 是以上调度策略常量之一。</p>
</li>
<li><p><code>os.sched_setscheduler</code>(<em>pid</em>, <em>policy</em>, <em>param</em>)</p>
<p>设置 PID 为 <em>pid</em> 的进程的调度策略。<em>pid</em> 为 0 指的是调用本方法的进程。<em>policy</em> 是以上调度策略常量之一。<em>param</em> 是一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_param" target="_blank" rel="noopener"><code>sched_param</code></a> 实例。</p>
</li>
<li><p><code>os.sched_getscheduler</code>(<em>pid</em>)</p>
<p>返回 PID 为 <em>pid</em> 的进程的调度策略。<em>pid</em> 为 0 指的是调用本方法的进程。返回的结果是以上调度策略常量之一。</p>
</li>
<li><p><code>os.sched_setparam</code>(<em>pid</em>, <em>param</em>)</p>
<p>设置 PID 为 <em>pid</em> 的进程的某个调度参数。<em>pid</em> 为 0 指的是调用本方法的进程。<em>param</em> 是一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_param" target="_blank" rel="noopener"><code>sched_param</code></a> 实例。</p>
</li>
<li><p><code>os.sched_getparam</code>(<em>pid</em>)</p>
<p>返回 PID 为 <em>pid</em> 的进程的调度参数为一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_param" target="_blank" rel="noopener"><code>sched_param</code></a> 实例。<em>pid</em> 为 0 指的是调用本方法的进程。</p>
</li>
<li><p><code>os.sched_rr_get_interval</code>(<em>pid</em>)</p>
<p>返回 PID 为 <em>pid</em> 的进程在时间片轮转调度下的时间片长度（单位为秒）。<em>pid</em> 为 0 指的是调用本方法的进程。</p>
</li>
<li><p><code>os.sched_yield</code>()</p>
<p>自愿放弃 CPU。</p>
</li>
<li><p><code>os.sched_setaffinity</code>(<em>pid</em>, <em>mask</em>)</p>
<p>将 PID 为 <em>pid</em> 的进程（为零则为当前进程）限制到一组 CPU 上。<em>mask</em> 是整数的可迭代对象，表示应将进程限制在其中的一组 CPU。</p>
</li>
<li><p><code>os.sched_getaffinity</code>(<em>pid</em>)</p>
<p>返回 PID 为 <em>pid</em> 的进程（为零则为当前进程）被限制到的那一组 CPU。</p>
</li>
</ul>
<h2 id="其他系统信息"><a href="#其他系统信息" class="headerlink" title="其他系统信息"></a>其他系统信息</h2><ul>
<li><p><code>os.confstr</code>(<em>name</em>)</p>
<p>返回字符串格式的系统配置信息。<em>name</em> 指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 <code>confstr_names</code> 字典的键中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 <em>name</em>。</p>
<p>如果 <em>name</em> 指定的配置值未定义，返回 <code>None</code>。</p>
<p>如果 <em>name</em> 是一个字符串且不是已定义的名称，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。如果当前系统不支持 <em>name</em> 指定的配置名称，即使该名称存在于 <code>confstr_names</code>，也会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，错误码为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EINVAL" target="_blank" rel="noopener"><code>errno.EINVAL</code></a>。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>s.confstr_names</code></p>
<p>字典，表示映射关系，为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.confstr" target="_blank" rel="noopener"><code>confstr()</code></a> 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.cpu_count</code>()</p>
<p>返回系统的 CPU 数量。不确定则返回 <code>None</code>。该数量不同于当前进程可以使用的CPU数量。可用的CPU数量可以由 <code>len(os.sched_getaffinity(0))</code> 方法获得。<em>3.4 新版功能.</em></p>
</li>
<li><p><code>os.getloadavg</code>()</p>
<p>返回系统运行队列中最近 1、5 和 15 分钟内的平均进程数。无法获得平均负载则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.sysconf</code>(<em>name</em>)</p>
<p>返回整数格式的系统配置信息。如果 <em>name</em> 指定的配置值未定义，返回 <code>-1</code>。对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.confstr" target="_blank" rel="noopener"><code>confstr()</code></a> 的 <em>name</em> 参数的注释在此处也适用。当前已知的配置名称在 <code>sysconf_names</code> 字典中提供。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
<li><p><code>os.sysconf_names</code></p>
<p>字典，表示映射关系，为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p>
</li>
</ul>
<p>以下数据值用于支持对路径本身的操作。所有平台都有定义。</p>
<p>对路径的高级操作在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 模块中定义。</p>
<ul>
<li><p><code>os.curdir</code></p>
<p>操作系统用来表示当前目录的常量字符串。在 Windows 和 POSIX 上是 <code>&#39;.&#39;</code>。在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 中也可用。</p>
</li>
</ul>
<ul>
<li><p><code>os.pardir</code></p>
<p>操作系统用来表示父目录的常量字符串。在 Windows 和 POSIX 上是 <code>&#39;..&#39;</code>。在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 中也可用。</p>
</li>
</ul>
<ul>
<li><p><code>os.defpath</code></p>
<p>在环境变量没有 <code>&#39;PATH&#39;</code> 键的情况下，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*p*</code></a> and <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*p*</code></a> 使用的默认搜索路径。在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 中也可用。</p>
</li>
<li><p><code>os.linesep</code></p>
<p>当前平台用于分隔（或终止）行的字符串。它可以是单个字符，如 POSIX 上是 <code>&#39;\n&#39;</code>，也可以是多个字符，如 Windows 上是 <code>&#39;\r\n&#39;</code>。在写入以文本模式（默认模式）打开的文件时，请不要使用 <em>os.linesep</em> 作为行终止符，请在所有平台上都使用一个 <code>&#39;\n&#39;</code> 代替。</p>
</li>
<li><p><code>os.devnull</code></p>
<p>空设备的文件路径。如 POSIX 上为 <code>&#39;/dev/null&#39;</code>，Windows 上为 <code>&#39;nul&#39;</code>。在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 中也可用。</p>
</li>
<li><p><code>os.RTLD_LAZY</code></p>
</li>
<li><p><code>os.RTLD_NOW</code></p>
</li>
<li><p><code>os.RTLD_GLOBAL</code></p>
</li>
<li><p><code>os.RTLD_LOCAL</code></p>
</li>
<li><p><code>os.RTLD_NODELETE</code></p>
</li>
<li><p><code>os.RTLD_NOLOAD</code></p>
</li>
<li><p><code>os.RTLD_DEEPBIND</code></p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.setdlopenflags" target="_blank" rel="noopener"><code>setdlopenflags()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getdlopenflags" target="_blank" rel="noopener"><code>getdlopenflags()</code></a> 函数所使用的标志。请参阅 Unix 手册页 <em><a href="https://manpages.debian.org/dlopen(3" target="_blank" rel="noopener">dlopen(3)</a>)</em> 获取不同标志的含义。<em>3.3 新版功能.</em></p>
</li>
</ul>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><ul>
<li><p><code>os.getrandom</code>(<em>size</em>, <em>flags=0</em>)</p>
<p>获得最多为 <em>size</em> 的随机字节。本函数返回的字节数可能少于请求的字节数。</p>
<p>这些字节可用于为用户空间的随机数生成器提供种子，或用于加密目的。</p>
<p><code>getrandom()</code> 依赖于从设备驱动程序和其他环境噪声源收集的熵。不必要地读取大量数据将对使用 <code>/dev/random</code> 和 <code>/dev/urandom</code> 设备的其他用户产生负面影响。</p>
<p>flags 参数是一个位掩码，可以是零个或多个下列值以或运算组合： <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.GRND_RANDOM" target="_blank" rel="noopener"><code>os.GRND_RANDOM</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.GRND_NONBLOCK" target="_blank" rel="noopener"><code>GRND_NONBLOCK</code></a>。</p>
<p>另请参阅 <a href="http://man7.org/linux/man-pages/man2/getrandom.2.html" target="_blank" rel="noopener">Linux getrandom() 手册页</a> 。</p>
<p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 3.17 或更高版本。</p>
<p><em>3.6 新版功能.</em></p>
</li>
<li><p><code>os.urandom</code>(<em>size</em>)</p>
<p>返回大小为 <em>size</em> 的字符串，它是适合加密使用的随机字节。本函数从系统指定的随机源获取随机字节。对于加密应用程序，返回的数据应有足够的不可预测性，尽管其确切的品质取决于操作系统的实现。在 Linux 上，如果 <code>getrandom()</code> 系统调用可用，它将以阻塞模式使用：阻塞直到系统的 urandom 熵池初始化完毕（内核收集了 128 位熵）。原理请参阅 <a href="https://www.python.org/dev/peps/pep-0524" target="_blank" rel="noopener"><strong>PEP 524</strong></a>。在 Linux 上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getrandom" target="_blank" rel="noopener"><code>getrandom()</code></a> 可以以非阻塞模式（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.GRND_NONBLOCK" target="_blank" rel="noopener"><code>GRND_NONBLOCK</code></a> 标志）获取随机字节，或者轮询直到系统的 urandom 熵池初始化完毕。在类 Unix 系统上，随机字节是从 <code>/dev/urandom</code> 设备读取的。如果 <code>/dev/urandom</code> 设备不可用或不可读，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。在 Windows 上将使用 <code>CryptGenRandom()</code>。参见 <a href="https://docs.python.org/zh-cn/3.8/library/secrets.html#module-secrets" target="_blank" rel="noopener"><code>secrets</code></a> 模块提供了更高级的功能。所在平台会提供随机数生成器，有关其易于使用的接口，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/random.html#random.SystemRandom" target="_blank" rel="noopener"><code>random.SystemRandom</code></a>。<em>在 3.6.0 版更改:</em> 在 Linux 上，<code>getrandom()</code> 现在以阻塞模式使用，以提高安全性。<em>在 3.5.2 版更改:</em> 在 Linux 上，如果 <code>getrandom()</code> 系统调用阻塞（urandom 熵池尚未初始化完毕），则退回一步读取 <code>/dev/urandom</code>。<em>在 3.5 版更改:</em> 在 Linux 3.17 和更高版本上，现在使用 <code>getrandom()</code> 系统调用（如果可用）。在 OpenBSD 5.6 和更高版本上，现在使用 <code>getentropy()</code> C 函数。这些函数避免了使用内部文件描述符。</p>
</li>
<li><p><code>os.GRND_NONBLOCK</code></p>
<p>默认情况下，从 <code>/dev/random</code> 读取时，如果没有可用的随机字节，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getrandom" target="_blank" rel="noopener"><code>getrandom()</code></a> 会阻塞；从 <code>/dev/urandom</code> 读取时，如果熵池尚未初始化，则会阻塞。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.GRND_NONBLOCK" target="_blank" rel="noopener"><code>GRND_NONBLOCK</code></a> 标志，则这些情况下 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getrandom" target="_blank" rel="noopener"><code>getrandom()</code></a> 不会阻塞，而是立即抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BlockingIOError" target="_blank" rel="noopener"><code>BlockingIOError</code></a> 异常。<em>3.6 新版功能.</em></p>
</li>
<li><p><code>os.GRND_RANDOM</code></p>
<p>如果设置了此标志位，那么将从 <code>/dev/random</code> 池而不是 <code>/dev/urandom</code> 池中提取随机字节。</p>
<p><em>3.6 新版功能.</em></p>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>standard_library</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>os</tag>
      </tags>
  </entry>
</search>
