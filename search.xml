<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[windows jupyter notebook nbextension usage]]></title>
    <url>%2F2020%2F01%2F04%2Fwindows-jupyter-notebook-nbextension-usage%2F</url>
    <content type="text"><![CDATA[windows下jupyter 安装nbextension 插件填坑记 环境 软件和操作系统 版本号 操作系统 win7 64位 sp1 python版本 3.6.2 jupyter core 4.5.0 jupyter notebook 6.0.0 问题描述本来以为给jupyter安装个插件,分分钟搞定的事,结果三天了还是没解决。 我回家用win10的电脑,5分钟搞定。 尝试了各种方式,卸载重装,修改环境变量,换不同的python版本。后来我快要放放弃的时候，我终于搞定了。 问题定位我突然想到,是不是因为我安装了anaconda,于是增加了搜索关键字,终于发现了问题所在。 正确操作步骤 确定是已经安装好anaconda 要在anaconda prompt模式下(重要的事情说三遍,三遍,三遍，此处省略一万字,万马奔腾) pip install jupyter_contrib_nbextensions 配置：jupyter contrib nbextension install --user --skip-running-check 启动jupyter notebook，“Nbextensions”出现在导航栏中，在勾选目录。 查看 jupyter 版本123456789101112(base) C:\Users\Mr.Sui&gt;jupyter --versionjupyter core : 4.5.0jupyter-notebook : 6.0.0qtconsole : 4.5.1ipython : 7.6.1ipykernel : 5.1.1jupyter client : 5.3.1jupyter lab : 1.0.2nbconvert : 5.5.0ipywidgets : 7.5.0nbformat : 4.4.0traitlets : 4.3.2 有用的插件 代码导航功能 Table of Contents 变量检查器 Variable Inspector 显示单元格运行的时间和长度 Excute time 折叠/放下标题 Collapsible Headings 折叠代码 Codefolding 隐藏代码 hide input 隐藏选定代码 hide input all 隐藏所有代码 代码自动补全 Hinterland 通知 Notify Jupyter Notebook 首先你要勾选Notify扩展，其次再点击按钮正式启动。你选择的时间是Jupyter Notebook运行的最短时间，到点后它会向你发送通知 隐藏活动状态栏 zenmode tqdm_notebook 为循环代码显示执行进度条 12# 先安装 tqdm ：pip install tqdm# 使用时导入：from tqdm import tqdm_notebook 脚本自动保存 AutoSaveTime 参考文章官网教程 jupyter notebook的插件拓展—-jupyter_contrib_nbextensions 使用Jupyter Notebook编写技术文档]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>juypter</tag>
        <tag>nbextension</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python standard library webbrowser]]></title>
    <url>%2F2020%2F01%2F03%2Fpython-standard-library-webbrowser%2F</url>
    <content type="text"><![CDATA[python 标准库之 webbrowser没啥前提一张图表示我现在的心情 标准库 webbrowserwebbrowser 模块提供了一个高级接口，允许向用户显示基于Web的文档。 在大多数情况下，只需从该模块调用 open() 函数就可以了。 在 Unix 下，图形浏览器在 X11 下是首选，但如果图形浏览器不可用或 X11 显示不可用，则将使用文本模式浏览器。 如果使用文本模式浏览器，则调用进程将阻塞，直到用户退出浏览器。 如果存在环境变量 BROWSER ，则将其解释为 os.pathsep 分隔的浏览器列表，以便在平台默认值之前尝试。 当列表部分的值包含字符串 ％s 时，它被解释为一个文字浏览器命令行，用于替换 ％s 的参数 URL ；如果该部分不包含 ％s，则它只被解释为要启动的浏览器的名称。 脚本 webbrowser 可以用作模块的命令行界面。它接受一个 URL 作为参数。还接受以下可选参数：-n 如果可能，在新的浏览器窗口中打开 URL ； -t 在新的浏览器页面（“标签”）中打开 URL。这些选择当然是相互排斥的。用法示例: 1python -m webbrowser -t "https://jeffsui.github.io" 异常exception webbrowser.Error 发生浏览器控件错误时引发异常。 函数 webbrowser.`open`(url, new=0, autoraise=True) 使用默认浏览器显示 url。 如果 new 为 0，则尽可能在同一浏览器窗口中打开 url。 如果 new 为 1，则尽可能打开新的浏览器窗口。 如果 new 为 2，则尽可能打开新的浏览器页面（“标签”）。 如果 autoraise 为 “True”，则会尽可能置前窗口（请注意，在许多窗口管理器下，无论此变量的设置如何，都会置前窗口）。请注意，在某些平台上，尝试使用此函数打开文件名，可能会起作用并启动操作系统的关联程序。 但是，这种方式不被支持也不可移植。使用 url 参数会引发 auditing event webbrowser.open 。 webbrowser.open_new(url) 如果可能，在默认浏览器的新窗口中打开 url，否则，在唯一的浏览器窗口中打开 url。 webbrowser.open_new_tab(url) 如果可能，在默认浏览器的新页面（“标签”）中打开 url，否则等效于 open_new()。 webbrowser.get(*using=None*) 返回浏览器类型为 using 指定的控制器对象。 如果 using 为 None，则返回适用于调用者环境的默认浏览器的控制器。 webbrowser.register(name, constructor, instance=None, **, preferred=False*) 注册 name 浏览器类型。 注册浏览器类型后， get() 函数可以返回该浏览器类型的控制器。 如果没有提供 instance，或者为 None，constructor 将在没有参数的情况下被调用，以在需要时创建实例。 如果提供了 instance，则永远不会调用 constructor，并且可能是 None。将 preferred 设置为 True 使得这个浏览器成为 get() 不带参数调用的首选结果。 否则，只有在您计划设置 BROWSER 变量，或使用与您声明的处理程序的名称相匹配的非空参数调用 get() 时，此入口点才有用。 浏览器类型预定义了许多浏览器类型。 此表给出了可以传递给 get() 函数的类型名称以及控制器类的相应实例化，这些都在此模块中定义。 类型名 类名 注释 &#39;mozilla&#39; Mozilla(&#39;mozilla&#39;) &#39;firefox&#39; Mozilla(&#39;mozilla&#39;) &#39;netscape&#39; Mozilla(&#39;netscape&#39;) &#39;galeon&#39; Galeon(&#39;galeon&#39;) &#39;epiphany&#39; Galeon(&#39;epiphany&#39;) &#39;skipstone&#39; BackgroundBrowser(&#39;skipstone&#39;) &#39;kfmclient&#39; Konqueror() (1) &#39;konqueror&#39; Konqueror() (1) &#39;kfm&#39; Konqueror() (1) &#39;mosaic&#39; BackgroundBrowser(&#39;mosaic&#39;) &#39;opera&#39; Opera() &#39;grail&#39; Grail() &#39;links&#39; GenericBrowser(&#39;links&#39;) &#39;elinks&#39; Elinks(&#39;elinks&#39;) &#39;lynx&#39; GenericBrowser(&#39;lynx&#39;) &#39;w3m&#39; GenericBrowser(&#39;w3m&#39;) &#39;windows-default&#39; WindowsDefault (2) &#39;macosx&#39; MacOSX(&#39;default&#39;) (3) &#39;safari&#39; MacOSX(&#39;safari&#39;) (3) &#39;google-chrome&#39; Chrome(&#39;google-chrome&#39;) &#39;chrome&#39; Chrome(&#39;chrome&#39;) &#39;chromium&#39; Chromium(&#39;chromium&#39;) &#39;chromium-browser&#39; Chromium(&#39;chromium-browser&#39;) 简单的例子: 1234567url = 'http://docs.python.org/'# Open URL in a new tab, if a browser window is already open.webbrowser.open_new_tab(url)# Open URL in new window, raising the window if possible.webbrowser.open_new(url) 浏览器控制器对象浏览器控制器提供三个与模块级便捷函数相同的方法： controller.open(url, new=0, autoraise=True)` 使用此控制器处理的浏览器显示 url。 如果 new 为 1，则尽可能打开新的浏览器窗口。 如果 new 为 2，则尽可能打开新的浏览器页面（“标签”）。 controller.open_new(url)` 如果可能，在此控制器处理的浏览器的新窗口中打开 url ，否则，在唯一的浏览器窗口中打开 url 。 别名 open_new()。 controller.open_new_tab(url)` 如果可能，在此控制器处理的浏览器的新页面（“标签”）中打开 url，否则等效于 open_new() 总结标准库中的webbrowser只提供了一个简单的操作本地浏览器的接口。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>webbrowser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python standard library csv]]></title>
    <url>%2F2020%2F01%2F02%2Fpython-standard-library-csv%2F</url>
    <content type="text"><![CDATA[python 标准库学习之csv前言2019年立的flag,今年继续,标准库系列文章继续更新。 今天是真冷啊,屋里头才16℃,只能用一张图来表示我的心情。 标准库 csv文档路径python标准库csv CSV 文件格式文件扩展名为.csv,通用的电子表格文件格式,经常使用在数据分析中。 分隔符可能有所差别, python中的csv模块提供了对csv文件的读写操作,非常方便。 csv 常用方法csv.reader(csvfile,dialect=&#39;excel&#39;, ***fmtparams) 返回一个reader对象,该对象遍历csvfile。csv对象可以是任何对象,只要这个对象支持iteratable协议,并在每次调用__next__()方法时都返回字符串即可。如果csvfile是文件对象,则打开它时应使用newline=&#39;&#39;。可选参数dialect是用于不同的csv文件类型,它可以是 Dialect 类的子类的实例，也可以是 list_dialects() 函数返回的字符串之一。完整的解释可以参考csv文件格式参数。 csv文件的每一行都会默认当做字符串列表解析,除非指定了 QUOTE_NONNUMERIC 格式选项（在这种情况下，未加引号的字段会转换为浮点数），否则不会执行自动数据类型转换。 一个读文件例子 1234567&gt;&gt;&gt; import csv&gt;&gt;&gt; with open('eggs.csv', newline='') as csvfile:... spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')... for row in spamreader:... print(', '.join(row))Spam, Spam, Spam, Spam, Spam, Baked BeansSpam, Lovely Spam, Wonderful Spam csv.writer(csvfile, dialect=&#39;excel&#39;, **fmtparams) 返回一个 writer 对象，该对象负责将用户的数据在给定的文件类对象上转换为带分隔符的字符串。csvfile 可以是具有 write() 方法的任何对象。如果 csvfile 是文件对象，则打开它时应使用 newline=&#39;&#39;。 为了尽量简化与数据库 API 模块之间的对接，None 值会写入为空字符串。虽然这个转换是不可逆的，但它让 SQL 空数据值转储到 CSV 文件更容易，而无需预处理从 cursor.fetch* 调用返回的数据。写入前，所有非字符串数据都先用 str() 转化为字符串再写入。 一个写文件例子 123456import csvwith open('eggs.csv', 'w', newline='') as csvfile: spamwriter = csv.writer(csvfile, delimiter=' ', quotechar='|', quoting=csv.QUOTE_MINIMAL) spamwriter.writerow(['Spam'] * 5 + ['Baked Beans']) spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam']) csv.register_dialect(name[, dialect[, **fmtparams]]) 将 name 与 dialect 关联起来。name 必须是字符串。要指定变种 (dialect)，可以给出 Dialect 的子类，或给出 fmtparams 关键字参数，或两者都给出（此时关键字参数会覆盖 dialect 参数）。 有关方言和格式设置参数的完整详细信息，请参见 方言格式参数 部分。 其他方法: csv.unregister_dialect(name) 从变种注册表中删除 name 对应的变种。如果 name 不是已注册的变种名称，则抛出 Error 异常。 csv.get_dialect(name) 返回 name 对应的变种。如果 name 不是已注册的变种名称，则抛出 Error 异常。该函数返回的是不可变的 Dialect 对象。 csv.list_dialects() 返回所有已注册变种的名称。 csv.field_size_limit([new_limit]) 返回解析器当前允许的最大字段大小。如果指定了 new_limit，则它将成为新的最大字段大小。 csv模块定义的类class csv.DictReader(*f*, *fieldnames=None*, *restkey=None*, *restval=None*, *dialect=&#39;excel&#39;*, **args*, ***kwds*) 创建一个对象，该对象在操作上类似于常规 reader，但是将每行中的信息映射到一个 dict，该 dict 的键由 fieldnames 可选参数给出。 fieldnames 参数是一个 sequence。如果省略 fieldnames，则文件 f 第一行中的值将用作字段名。无论字段名是如何确定的，字典都将保留其原始顺序。 如果某一行中的字段多于字段名，则其余字段将放入列表中，字段名由 restkey 指定（默认为 None）。如果非空白行的字段少于字段名，则缺少的值将用 None 填充。 所有其他可选或关键字参数都传递给底层的 reader 实例。 3.8 中,返回的行是 dict 类型。 一个使用DictReader例子 1234567891011&gt;&gt;&gt; import csv&gt;&gt;&gt; with open('names.csv', newline='') as csvfile:... reader = csv.DictReader(csvfile)... for row in reader:... print(row['first_name'], row['last_name'])...Eric IdleJohn Cleese&gt;&gt;&gt; print(row)&#123;'first_name': 'John', 'last_name': 'Cleese'&#125; class csv.DictWriter(f, fieldnames, restval=&#39;&#39;, extrasaction=&#39;raise&#39;, dialect=&#39;excel&#39;, **args, **kwds) 创建一个对象，该对象在操作上类似常规 writer，但会将字典映射到输出行。 fieldnames 参数是由键组成的 序列，它指定字典中值的顺序，这些值会按指定顺序传递给 writerow() 方法并写入文件 f。 如果字典缺少 fieldnames 中的键，则可选参数 restval 用于指定要写入的值。 如果传递给 writerow() 方法的字典的某些键在 fieldnames 中找不到，则可选参数 extrasaction 用于指定要执行的操作。 如果将其设置为默认值 &#39;raise&#39;，则会引发 ValueError。 如果将其设置为 &#39;ignore&#39;，则字典中的其他键值将被忽略。 所有其他可选或关键字参数都传递给底层的 writer 实例。 注意，与 DictReader 类不同，DictWriter 类的 fieldnames 参数不是可选参数 一个使用DictWriter写入文件例子 12345678910import csvwith open('names.csv', 'w', newline='') as csvfile: fieldnames = ['first_name', 'last_name'] writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() writer.writerow(&#123;'first_name': 'Baked', 'last_name': 'Beans'&#125;) writer.writerow(&#123;'first_name': 'Lovely', 'last_name': 'Spam'&#125;) writer.writerow(&#123;'first_name': 'Wonderful', 'last_name': 'Spam'&#125;) 其他方法: class csv.Dialect Dialect 类是主要依赖于其属性的容器类，用于将定义好的参数传递给特定的 reader 或 writer 实例。 class csv.excel excel 类定义了 Excel 生成的 CSV 文件的常规属性。它在变种注册表中的名称是 &#39;excel&#39;。 class csv.excel_tab excel_tab 类定义了 Excel 生成的、制表符分隔的 CSV 文件的常规属性。它在变种注册表中的名称是 &#39;excel-tab&#39;。 class csv.unix_dialect unix_dialect 类定义了在 UNIX 系统上生成的 CSV 文件的常规属性，即使用 &#39;\n&#39; 作为换行符，且所有字段都有引号包围。它在变种注册表中的名称是 &#39;unix&#39;。 class csv.SnifferSniffer 类用于推断 CSV 文件的格式。 Sniffer 类提供了两个方法： sniff(sample, delimiters=None) 分析给定的 sample 并返回一个 Dialect 子类，该子类中包含了分析出的格式参数。如果给出可选的 delimiters 参数，则该参数会被解释为字符串，该字符串包含了可能的有效定界符。 has_header(sample) 分析示例文本（假定为 CSV 格式），如果第一行很可能是一系列列标题，则返回 True。 一个使用Sniffer的例子: 12345ith open('example.csv', newline='') as csvfile: dialect = csv.Sniffer().sniff(csvfile.read(1024)) csvfile.seek(0) reader = csv.reader(csvfile, dialect) # ... process CSV file contents here ... csv 中定义的常量 csv.`QUOTE_ALL` 指示 writer 对象给所有字段加上引号。 csv.`QUOTE_MINIMAL` 指示 writer 对象仅为包含特殊字符（例如 定界符、引号字符 或 行结束符 中的任何字符）的字段加上引号。 csv.`QUOTE_NONNUMERIC` 指示 writer 对象为所有非数字字段加上引号。指示 reader 将所有未用引号引出的字段转换为 float 类型。 csv.`QUOTE_NONE` 指示 writer 对象不使用引号引出字段。当 定界符 出现在输出数据中时，其前面应该有 转义符。如果未设置 转义符，则遇到任何需要转义的字符时，writer 都会抛出 Error 异常。指示 reader 不对引号字符进行特殊处理。 csv模块定义了以下异常： exception csv.`Error` 该异常可能由任何发生错误的函数抛出。 备注如果没有指定 newline=&#39;&#39;，则嵌入引号中的换行符将无法正确解析，并且在写入时，使用 \r\n 换行的平台会有多余的 \r 写入。由于 csv 模块会执行自己的（通用）换行符处理，因此指定 newline=&#39;&#39; 应该总是安全的。 总结csv模块是一个非常实用的处理csv文件的标准库，提供了两个核心类。一个是把csv文件对象当作字符串列表解析csv文件的类，另一个是把csv文件对象当作字典解析的类。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>csv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[using python venv to create virtual environment]]></title>
    <url>%2F2019%2F12%2F26%2Fusing-python-venv-to-create-virtual-environment%2F</url>
    <content type="text"><![CDATA[python env 创建虚拟环境前言又断更了,长此以往,我可能无法完成100天打卡任务了。 红包是刺激自己前进的动力。 python 标准库03之虚拟环境创建参考文档 python目前官方推荐的工具是venv 顺便介绍下目前常用的python虚拟环境工具 virsualenv pyvenv (3.3,3.4中推荐的虚拟环境创建工具,3.6中被弃用) venv(3.6以后推荐的虚拟环境创建工具) 创建虚拟环境使用下面的命令创建一个虚拟环境 1python3 -m venv /path/to/new/virtual/environment windows下使用venv来创建虚拟环境 1c:\&gt;c:\Python35\python -m venv c:\path\to\myenv 使用-h参数可以查看venv命令行的帮助文档 1234567891011121314151617181920212223242526usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] ENV_DIR [ENV_DIR ...]Creates virtual Python environments in one or more target directories.positional arguments: ENV_DIR A directory to create the environment in.optional arguments: -h, --help show this help message and exit --system-site-packages Give the virtual environment access to the system site-packages dir. --symlinks Try to use symlinks rather than copies, when symlinks are not the default for the platform. --copies Try to use copies rather than symlinks, even when symlinks are the default for the platform. --clear Delete the contents of the environment directory if it already exists, before environment creation. --upgrade Upgrade the environment directory to use this version of Python, assuming Python has been upgraded in-place. --without-pip Skips installing or upgrading pip in the virtual environment (pip is bootstrapped by default) --prompt PROMPT Provides an alternative prompt prefix for this environment. 除非你使用了--without-pip 参数,否则 ensurepip 模块会默认安装pip指令到创建好的虚拟环境中。 一旦一个虚拟环境被创建，可以通过下面的命令激活这个虚拟环境。不同平台下的激活方式略有不同,下面总结了各个平台下虚拟环境的激活命令脚本,请参考。 激活虚拟环境 平台 Shell 用于激活虚拟环境的命令 POSIX bash/zsh $ source /bin/activate fish $ . /bin/activate.fish csh/tcsh $ source /bin/activate.csh PowerShell Core $ /bin/Activate.ps1 Windows cmd.exe C:> \Scripts\activate.bat PowerShell PS C:> \Scripts\Activate.ps1 You don’t specifically need to activate an environment; activation just prepends the virtual environment’s binary directory to your path, so that “python” invokes the virtual environment’s Python interpreter and you can run installed scripts without having to use their full path. However, all scripts installed in a virtual environment should be runnable without activating it, and run with the virtual environment’s Python automatically. You can deactivate a virtual environment by typing “deactivate” in your shell. The exact mechanism is platform-specific and is an internal implementation detail (typically a script or shell function will be used). 你无需关心如何激活一个虚拟环境；使用相对于项目当前路径下的可执行方法,python解析器就可以激活虚拟环境。已经激活的虚拟环境, 就可以使用python的命令直接执行脚本或者安装其他软件包到当前的虚拟环境，而不需要关心是否会污染本地python环境的问题。同样，使用deactivate 就可以退出当前的虚拟环境。 API下面展示的是一个使用EnvBuilder 创建一个自定义虚拟环境的脚本。 1class venv.EnvBuilder(system_site_packages=False, clear=False, symlinks=False, upgrade=False, with_pip=False, prompt=None) create(env_dir) system_site_packages – 一个Boolean值,是否将site-packages添加到虚拟环境中 默认是False. clear – 一个Boolean值,如果为真,将会在创建环境之前清除已经存在的目标路径. symlinks – 一个Boolean值,如果为真,将会在创建环境前删除包含内容的目录 upgrade – 一个Boolean值,如果为真, 则将用正在运行的Python升级现有环境 - 用于在Python就地升级（默认为False）时使用。. with_pip – 一个Boolean值,如果为真,pip命令将会安装到虚拟环境中 ,使用 ensurepip 的默认 --default-pip 参数选项. prompt – 在激活虚拟环境后使用的字符串（默认为None表示将使用环境的目录名称）。. 1234567891011def create(self, env_dir): """ Create a virtualized Python environment in a directory. env_dir is the target directory to create an environment in. """ env_dir = os.path.abspath(env_dir) context = self.ensure_directories(env_dir) self.create_configuration(context) self.setup_python(context) self.setup_scripts(context) self.post_setup(context) ensure_directories(env_dir) 创建环境目录和所有必需的目录，并返回一个上下文对象。这只是属性（如路径）的持有者，供其他方法使用。这些目录已被允许存在，只要其中一个clear或被upgrade指定为允许在现有环境目录上进行操作即可。 create_configuration(context) pyvenv.cfg在环境中创建配置文件。 setup_python(context) 在环境中创建Python可执行文件（以及Windows下的DLL）的副本。在POSIX系统中，如果一个特定的可执行文件 python3.x使用，符号链接python和python3将创建指向该可执行文件，除非已存在具有这些名称的文件。 setup_scripts(context) 将适合该平台的激活脚本安装到虚拟环境中。 post_setup(context) 一种占位符方法，可以在第三方实现中重写，以在虚拟环境中预安装包或执行其他后创建步骤。 此外，EnvBuilder提供这种工具方法，可以从被称为setup_scripts()或post_setup()在子类中，以协助安装自定义脚本到虚拟环境中。install_scripts（上下文，路径）路径是应包含子目录“common”，“posix”，“nt”的目录的路径，每个目录都包含指向环境中bin目录的脚本。os.name经过一些文本替换占位符后，“common”的内容和相应的目录被复制： __VENV_DIR__ 被替换为环境目录的绝对路径。 __VENV_NAME__ 被替换为环境名称（环境目录的最终路径段）。 __VENV_PROMPT__ 被提示符替换（环境名称由括号括起来，并带有下面的空格） __VENV_BIN_NAME__被替换为bin目录的名称（bin或者Scripts）。 __VENV_PYTHON__被替换为环境可执行文件的绝对路径。允许目录存在（用于在现有环境正在升级时）。 还有一个模块级的便利功能： 12venv.create（env_dir，system_site_packages = False，clear = False，symlinks =False，with_pip = False ） EnvBuilder用给定的关键字参数创建一个参数，并调用create()并使用env_dir参数。 一个扩展EnvBuilder例子以下脚本展示了如何EnvBuilder通过实现将setuptools和pip安装到创建的虚拟环境中的子类来进行扩展： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214import osimport os.pathfrom subprocess import Popen, PIPEimport sysfrom threading import Threadfrom urllib.parse import urlparsefrom urllib.request import urlretrieveimport venvclass ExtendedEnvBuilder(venv.EnvBuilder): """ This builder installs setuptools and pip so that you can pip or easy_install other packages into the created virtual environment. :param nodist: If true, setuptools and pip are not installed into the created virtual environment. :param nopip: If true, pip is not installed into the created virtual environment. :param progress: If setuptools or pip are installed, the progress of the installation can be monitored by passing a progress callable. If specified, it is called with two arguments: a string indicating some progress, and a context indicating where the string is coming from. The context argument can have one of three values: 'main', indicating that it is called from virtualize() itself, and 'stdout' and 'stderr', which are obtained by reading lines from the output streams of a subprocess which is used to install the app. If a callable is not specified, default progress information is output to sys.stderr. """ def __init__(self, *args, **kwargs): self.nodist = kwargs.pop('nodist', False) self.nopip = kwargs.pop('nopip', False) self.progress = kwargs.pop('progress', None) self.verbose = kwargs.pop('verbose', False) super().__init__(*args, **kwargs) def post_setup(self, context): """ Set up any packages which need to be pre-installed into the virtual environment being created. :param context: The information for the virtual environment creation request being processed. """ os.environ['VIRTUAL_ENV'] = context.env_dir if not self.nodist: self.install_setuptools(context) # Can't install pip without setuptools if not self.nopip and not self.nodist: self.install_pip(context) def reader(self, stream, context): """ Read lines from a subprocess' output stream and either pass to a progress callable (if specified) or write progress information to sys.stderr. """ progress = self.progress while True: s = stream.readline() if not s: break if progress is not None: progress(s, context) else: if not self.verbose: sys.stderr.write('.') else: sys.stderr.write(s.decode('utf-8')) sys.stderr.flush() stream.close() def install_script(self, context, name, url): _, _, path, _, _, _ = urlparse(url) fn = os.path.split(path)[-1] binpath = context.bin_path distpath = os.path.join(binpath, fn) # Download script into the virtual environment's binaries folder urlretrieve(url, distpath) progress = self.progress if self.verbose: term = '\n' else: term = '' if progress is not None: progress('Installing %s ...%s' % (name, term), 'main') else: sys.stderr.write('Installing %s ...%s' % (name, term)) sys.stderr.flush() # Install in the virtual environment args = [context.env_exe, fn] p = Popen(args, stdout=PIPE, stderr=PIPE, cwd=binpath) t1 = Thread(target=self.reader, args=(p.stdout, 'stdout')) t1.start() t2 = Thread(target=self.reader, args=(p.stderr, 'stderr')) t2.start() p.wait() t1.join() t2.join() if progress is not None: progress('done.', 'main') else: sys.stderr.write('done.\n') # Clean up - no longer needed os.unlink(distpath) def install_setuptools(self, context): """ Install setuptools in the virtual environment. :param context: The information for the virtual environment creation request being processed. """ url = 'https://bitbucket.org/pypa/setuptools/downloads/ez_setup.py' self.install_script(context, 'setuptools', url) # clear up the setuptools archive which gets downloaded pred = lambda o: o.startswith('setuptools-') and o.endswith('.tar.gz') files = filter(pred, os.listdir(context.bin_path)) for f in files: f = os.path.join(context.bin_path, f) os.unlink(f) def install_pip(self, context): """ Install pip in the virtual environment. :param context: The information for the virtual environment creation request being processed. """ url = 'https://raw.github.com/pypa/pip/master/contrib/get-pip.py' self.install_script(context, 'pip', url)def main(args=None): compatible = True if sys.version_info &lt; (3, 3): compatible = False elif not hasattr(sys, 'base_prefix'): compatible = False if not compatible: raise ValueError('This script is only for use with ' 'Python 3.3 or later') else: import argparse parser = argparse.ArgumentParser(prog=__name__, description='Creates virtual Python ' 'environments in one or ' 'more target ' 'directories.') parser.add_argument('dirs', metavar='ENV_DIR', nargs='+', help='A directory in which to create the 'virtual environment.') parser.add_argument('--no-setuptools', default=False, action='store_true', dest='nodist', help="Don't install setuptools or pip in the " "virtual environment.") parser.add_argument('--no-pip', default=False, action='store_true', dest='nopip', help="Don't install pip in the virtual " "environment.") parser.add_argument('--system-site-packages', default=False, action='store_true', dest='system_site', help='Give the virtual environment access to the ' 'system site-packages dir.') if os.name == 'nt': use_symlinks = False else: use_symlinks = True parser.add_argument('--symlinks', default=use_symlinks, action='store_true', dest='symlinks', help='Try to use symlinks rather than copies, ' 'when symlinks are not the default for ' 'the platform.') parser.add_argument('--clear', default=False, action='store_true', dest='clear', help='Delete the contents of the ' 'virtual environment ' 'directory if it already ' 'exists, before virtual ' 'environment creation.') parser.add_argument('--upgrade', default=False, action='store_true', dest='upgrade', help='Upgrade the virtual ' 'environment directory to ' 'use this version of ' 'Python, assuming Python ' 'has been upgraded ' 'in-place.') parser.add_argument('--verbose', default=False, action='store_true', dest='verbose', help='Display the output ' 'from the scripts which ' 'install setuptools and pip.') options = parser.parse_args(args) if options.upgrade and options.clear: raise ValueError('you cannot supply --upgrade and --clear together.') builder = ExtendedEnvBuilder(system_site_packages=options.system_site, clear=options.clear, symlinks=options.symlinks, upgrade=options.upgrade, nodist=options.nodist, nopip=options.nopip, verbose=options.verbose) for d in options.dirs: builder.create(d)if __name__ == '__main__': rc = 1 try: main() rc = 0 except Exception as e: print('Error: %s' % e, file=sys.stderr) sys.exit(rc) 实践在windows下vscode中通过venv 创建虚拟环境步骤: powershell下,执行命令 python -m venv .venv 执行激活命令 .\Scripts\activate.ps1 退出虚拟环境 在项目目录下执行deactivate 即可。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python standard library -2 dictionary]]></title>
    <url>%2F2019%2F12%2F23%2Fpython-standard-library-2-dictionary%2F</url>
    <content type="text"><![CDATA[python 标准库学习笔记 – dictionary0.0 前言家里孩子发烧了,延迟更新标准库学习笔记 折腾了三个晚上,一家三口都累倒了。 人生就好比一个蹒跚学步的孩童,很容易被外界环境影响。 1.0 标准库- 内置函数参考文档: 内置类型-字典 python中主要内置类型包括numbers,sequences,mappings,classes,instance和exception。 1.1 逻辑值检测任何对象都可以进行逻辑值检测,以便在if 或while作为条件或是作为上下文所指返回值是布尔类型的表达式来使用。所以就有下面的用法。 12345L = []if(L): passwhile(L): pass 一个对象在默认情况下被认为是True,除非该对象定义了__boolean__() 方法且返回False 或者定义__len__()方法且返回零。下面三种情况的内置对象都会被认为是逻辑假值。 None 或 False 任何数值类型的零 空的序列和多项集 包括 空字符串、空列表、空集合、空字典、空元组以及空数列(reange(0)) 1.2 布尔运算 – and,or,not 运算 结果 注释 x or y if x is false, then y, else x 短路运算,只有第一个为假的时候才会对第二个求值 x and y if x is false, then x, else y 短路运算,只有第二个为真的时候才会对第二个求值 not x if x is false, then True, else False 逻辑取反 1.3 比较运算 运算 含义 &lt; 严格小于 &lt;= 小于或等于 &gt; 严格大于 &gt;= 大于或等于 == 等于 != 不等于 is 对象标识 is not 否定的对象标识 ==tips== 不同类型的对象之间不能使用比较运算,除非定义了对应的方法，例如__lt__(),__eq__()这样的函数 具有不同标识的类的实例,比较结果为False,除非你自己定义了__eq__()方法 一个类实例不能与相同类或的其他实例或其他类型的对象进行排序,除非定义了对应的方法，包括 __lt__(), __le__(), __gt__() 以及 __ge__() 1.4 数字类型 – int、float、complexpython中存在三种不同的数字类型: 整数, 浮点数 和 复数*。 运算 结果 注释 完整文档 x + y x 和 y 的和 x - y x 和 y 的差 x * y x 和 y 的乘积 x / y x 和 y 的商 x // y x 和 y 的商数 取整 x % y remainder of x / y 不可用于负数 -x x 取反 +x x 不变 abs(x) x 的绝对值或大小 abs() int(x) 将 x 转换为整数 小数会被截断 int() float(x) 将 x 转换为浮点数 (4)(6) float() complex(re, im) 一个带有实部 re 和虚部 im 的复数。im 默认为0。 (6) complex() c.conjugate() 复数 c 的共轭 divmod(x, y) (x // y, x % y) (2) divmod() pow(x, y) x 的 y 次幂 (5) pow() x ** y x 的 y 次幂 (5) 所有的numbers.Real类型（包括int 和 float)还包括以下运算: 运算 结果 math.trunc(x) x 截断为 Integral round(x[, n\]) x 舍入到 n 位小数，半数值会舍入到偶数。 如果省略 n，则默认为 0。 math.floor(x) &lt;= x 的最大 Integral math.ceil(x) &gt;= x 的最小 Integral 1.5 整数类型的附加方法int.bit_length() 返回以二进制表示一个整数锁需要的位数，不包括符号位和前面的零 1.6 浮点数类型的附加方法float.as_integer_ratio() 返回一对整数，其比率正好等于原浮点数并且分母为正数。 无穷大会引发 OverflowError 而 NaN 则会引发 ValueError。 float.is_integer() 如果 float 实例可用有限位整数表示则返回 True，否则返回 False: float.hex() 以十六进制字符串的形式返回一个浮点数表示。 对于有限浮点数，这种表示法将总是包含前导的 0x 和尾随的 p 加指数。 classmethod float.fromhex(s) 返回以十六进制字符串 s 表示的浮点数的类方法。 字符串 s 可以带有前导和尾随的空格。 ==tips==: float.hex() 是实例方法, float.fromhex(s)是类方法 1234&gt;&gt;&gt; float.fromhex('0x3.a7p10')3740.0&gt;&gt;&gt; float.hex(3740.0)'0x1.d380000000000p+11' 1.7 数字类型的哈希运算一个例子说明 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import sys, mathdef hash_fraction(m, n): """Compute the hash of a rational number m / n. Assumes m and n are integers, with n positive. Equivalent to hash(fractions.Fraction(m, n)). """ P = sys.hash_info.modulus # Remove common factors of P. (Unnecessary if m and n already coprime.) while m % P == n % P == 0: m, n = m // P, n // P if n % P == 0: hash_value = sys.hash_info.inf else: # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P. hash_value = (abs(m) % P) * pow(n, P - 2, P) % P if m &lt; 0: hash_value = -hash_value if hash_value == -1: hash_value = -2 return hash_valuedef hash_float(x): """Compute the hash of a float x.""" if math.isnan(x): return sys.hash_info.nan elif math.isinf(x): return sys.hash_info.inf if x &gt; 0 else -sys.hash_info.inf else: return hash_fraction(*x.as_integer_ratio())def hash_complex(z): """Compute the hash of a complex number z.""" hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag) # do a signed reduction modulo 2**sys.hash_info.width M = 2**(sys.hash_info.width - 1) hash_value = (hash_value &amp; (M - 1)) - (hash_value &amp; M) if hash_value == -1: hash_value = -2 return hash_value 1.8 映射类型 – dictpython中目前只有一种映射类型, 字典,映射属于可变对象。映射类型会将hashtable值映射到任意对象. 字典的键 几乎可以是任意值， 可hash的任意值,也就是包含列表、字典和其他可变类型的值,不可以用来充当字典中的键。 1.创建字典字典可以通过将以逗号分隔的 键: 值 对列表包含于花括号之内来创建，例如: {&#39;jack&#39;: 4098, &#39;sjoerd&#39;: 4127} 或 {4098: &#39;jack&#39;, 4127: &#39;sjoerd&#39;}，也可以通过 dict 构造器来创建。 2.构造函数class dict(**kwarg) class dict(mapping, **kwarg) class dict(iterable, **kwarg) 3. 其他函数 函数名 描述 list(d) 返回字典 d 中使用的所有键的列表。 len(d) 返回字典 d 中的项数。 d[key] 返回 d 中以 key 为键的项。 如果映射中不存在 key 则会引发 KeyError。 [1] d[key] = value 给d[key]的值设为value del d[key] 将 d[key] 从 d 中移除。 如果映射中不存在 key 则会引发 KeyError。 key in d 如果 d 中存在键 key 则返回 True，否则返回 False。 key not in d 等价于 not key in d。 iter(d) 返回以字典的键为元素的迭代器 clear() 移除字典中的所有元素。 copy() 返回原字典的浅拷贝。 classmethod fromkeys(iterable[, value]) 使用来自 iterable 的键创建一个新字典，并将键值设为 value。 get(key[, default]) 如果 key 存在于字典中则返回 key 的值，否则返回 default。 如果 default 未给出则默认为 None，因而此方法绝不会引发 KeyError。 items() 返回由字典项 ((键, 值) 对) 组成的一个新视图。 keys() 返回由字典键组成的一个新视图 pop(key[, default]) 如果 key 存在于字典中则将其移除并返回其值，否则返回 default。 如果 default 未给出且 key 不存在于字典中，则会引发 KeyError。 popitem() 从字典中移除并返回一个 (键, 值) 对。 键值对会按 LIFO 的顺序被返回。 reversed(d) 返回一个逆序获取字典键的迭代器 setdefault(key[, default]) 如果字典存在键 key ，返回它的值。如果不存在，插入值为 default 的键 key ，并返回 default 。 default 默认为 None。 update([other]) 使用来自 other 的键/值对更新字典，覆盖原有的键。 values() 返回由字典值组成的一个新视图 [2] 1234567891011121314#[1] 如果字典的子类定义了方法 __missing__() 并且 key 不存在，则 d[key] 操作将调用该方法并附带键 key 作为参数。 d[key] 随后将返回或引发 __missing__(key) 调用所返回或引发的任何对象或异常。 没有其他操作或方法会发起调用 __missing__()。 如果未定义 __missing__()，则会引发 KeyError。 __missing__() 必须是一个方法；它不能是一个实例变量:&gt;&gt;&gt; class Counter(dict):... def __missing__(self, key):... return 0&gt;&gt;&gt; c = Counter()&gt;&gt;&gt; c['red']0&gt;&gt;&gt; c['red'] += 1&gt;&gt;&gt; c['red']1#[2]两个 dict.values() 视图之间的相等性比较将总是返回 False。 这在 dict.values() 与其自身比较时也同样适用: &gt;&gt;&gt; d = &#123;'a': 1&#125;&gt;&gt;&gt; d.values() == d.values()False 字典比较: 两个字典的比较当且仅当它们具有相同的 (键, 值) 对时才会相等（不考虑顺序）。 排序比较 (‘&lt;’, ‘&lt;=’, ‘&gt;=’, ‘&gt;’) 会引发 TypeError。 字典会保留插入时的顺序。 请注意对键的更新不会影响顺序。 删除并再次添加的键将被插入到末尾。 1234567891011121314&gt;&gt;&gt; d = &#123;"one": 1, "two": 2, "three": 3, "four": 4&#125;&gt;&gt;&gt; d&#123;'one': 1, 'two': 2, 'three': 3, 'four': 4&#125;&gt;&gt;&gt; list(d)['one', 'two', 'three', 'four']&gt;&gt;&gt; list(d.values())[1, 2, 3, 4]&gt;&gt;&gt; d["one"] = 42&gt;&gt;&gt; d&#123;'one': 42, 'two': 2, 'three': 3, 'four': 4&#125;&gt;&gt;&gt; del d["two"]&gt;&gt;&gt; d["two"] = None&gt;&gt;&gt; d&#123;'one': 42, 'three': 3, 'four': 4, 'two': None&#125; 4.字典视图对象由 dict.keys(), dict.values() 和 dict.items() 所返回的对象是 视图对象。 该对象提供字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。 字典视图函数 描述 len(dictview) 返回字典中的条目数 iter(dictview) 返回字典中的键、值或项（以 (键, 值) 为元素的元组表示）的迭代器 [1] x in dictview 如果 x 是对应字典中存在的键、值或项（在最后一种情况下 x 应为一个 (键, 值) 元组） 则返回 True reversed(dictview) 返回一个逆序获取字典键、值或项的迭代器。 视图将按与插入时相反的顺序进行迭代。 [2] 1234567891011121314151617181920212223242526272829#键视图类似于集合，因为其条目不重复且可哈希。 如果所有值都是可哈希的，即 (键, 值) 对也是不重复且可哈希的，那么条目视图也会类似于集合。 （值视图则不被视为类似于集合，因其条目通常都是有重复的。） 对于类似于集合的视图，为抽象基类 collections.abc.Set 所定义的全部操作都是有效的 (例如 ==, &lt; 或 ^)。&gt;&gt;&gt; dishes = &#123;'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500&#125;&gt;&gt;&gt; keys = dishes.keys()&gt;&gt;&gt; values = dishes.values()&gt;&gt;&gt; # iteration&gt;&gt;&gt; n = 0&gt;&gt;&gt; for val in values:... n += val&gt;&gt;&gt; print(n)504&gt;&gt;&gt; # keys and values are iterated over in the same order (insertion order)&gt;&gt;&gt; list(keys)['eggs', 'sausage', 'bacon', 'spam']&gt;&gt;&gt; list(values)[2, 1, 1, 500]&gt;&gt;&gt; # view objects are dynamic and reflect dict changes&gt;&gt;&gt; del dishes['eggs']&gt;&gt;&gt; del dishes['sausage']&gt;&gt;&gt; list(keys)['bacon', 'spam']&gt;&gt;&gt; # set operations&gt;&gt;&gt; keys &amp; &#123;'eggs', 'bacon', 'salad'&#125;&#123;'bacon'&#125;&gt;&gt;&gt; keys ^ &#123;'sausage', 'juice'&#125;&#123;'juice', 'sausage', 'bacon', 'spam'&#125; 2.0 小结 字典是可变类型,键只能是由非hash的数据类型充当 字典子类的__missing__方法。 字典视图的元素为不重复且可哈希。 一张图总结如下 后记记得五年前听过的一句话,赠给自己,也赠给凑巧看到这篇博文的有缘人。 种一棵树最好的时间是在十年前，其次是现在。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>dictionary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python_standard_library_1_string]]></title>
    <url>%2F2019%2F12%2F20%2Fpython-standard-library-1-string%2F</url>
    <content type="text"><![CDATA[python 标准库学习笔记 – string前言今天是2019年12月20日,刚刚晴朗的天 入冬以来的第二场雪就悄然而至 从今天开始,坚持更新博文100天,也算是对python学习的总结。那么从哪里开始呢？ 那就从python标准库开始撸吧。 操作系统 win7 sp1 64位 标准版 python版本 3.8 工具 vscode 标准库基础在不同操作系统,标准库的路径有所不同,以windows平台为例,我的python安装在C:\Python38 标准库文件就在C:\Python38\Lib 文件夹下 标准库分为几个部分,参考标准库介绍 内置函数:不需要import就可以使用的函数,例如 print 内置异常 内置模块 文本 二进制数据 数据类型 数学 函数式编程模块 文件和目录访问 数据持久化 文件格式 加密服务 并发执行 网络和进程间通信 互联网数据处理 互联网协议和支持 多媒体服务 国际化 程序框架 Tk图形用户界面 开发工具 调试和分析 软件打包和分发 python运行时服务 自定义python解释器 导入模块 Python语言服务 杂项服务 Windows系统相关模块 Unix专有服务 被取代的模块 day1 标准库 string参考：文本处理服务 string常见字符串操作 字符串常量123__all__ = ["ascii_letters", "ascii_lowercase", "ascii_uppercase", "capwords", "digits", "hexdigits", "octdigits", "printable", "punctuation", "whitespace", "Formatter", "Template"] 测试如下： 123456789101112import stringprint(string.__all__)print(string.ascii_letters) #abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZprint(string.ascii_lowercase) #abcdefghijklmnopqrstuvwxyzprint(string.ascii_uppercase) #ABCDEFGHIJKLMNOPQRSTUVWXYZprint(string.digits)# 十进制数字常数 0123456789print(string.hexdigits)#十六进制数字常数 0123456789abcdefABCDEFprint(string.octdigits)#八进制数字常数 01234567print(string.punctuation)print(string.printable)print(string.whitespace) 其中： string.whitespace ：由被视为空白符号的 ASCII 字符组成的字符串。 其中包括空格、制表、换行、回车、进纸和纵向制表符。 自定义字符串格式化 主要函数 功能 format(format_string, *args, **kwargs) 它采用格式字符串和一组任意位置和关键字参数。它只是一个调用vformat（）的包装器。 vformat(format_string, args, kwargs) 执行格式化的实际工作 parse(format_string) 循环遍历format_string并返回一个可迭代的元组（literal_text，field_name，format_spec，conversion）。 1234567891011121314151617181920212223242526data = ("Pi = ",3.1415926)strtmp = "This is a test:&#123;&#125;&#123;:.4f&#125;"formatter = string.Formatter()strtmp = formatter.vformat(strtmp,data,&#123;&#125;)print(strtmp) #This is a test:&#123;&#125;&#123;:.4f&#125;data =&#123;"key1":3.1415926,"key2":"Pi: ="&#125;strtmp = "This is a test:&#123;key2&#125;&#123;key1&#125;"formatter = string.Formatter()strtmp = formatter.vformat(strtmp,(),data)print(strtmp)import stringdata = ("Pi=",3.1415926)strtmp = "This is a test:&#123;&#125;&#123;:.4f&#125;"formatter = string.Formatter()formatter.vformat(strtmp,data,&#123;&#125;)print(strtmp) #This is a test:&#123;&#125;&#123;:.4f&#125;data =&#123;"key1":3.1415926,"key2":"Pi: ="&#125;strtmp = "This is a test:&#123;key2&#125;&#123;key1&#125;"formatter = string.Formatter()strtmp = formatter.vformat(strtmp,(),data)print(strtmp) 12345678910111213141516171819202122import stringstrtmp = "This is a test:&#123;&#125;&#123;:.4f&#125;"formatter = string.Formatter()strtuple = formatter.parse(strtmp)for i, v in enumerate(strtuple): print(i, v) ''' 0 ('This is a test:', '', '', None) 1 ('', '', '.4f', None) '''strtmp = "This is a test:&#123;Key2&#125;&#123;Key1&#125;"formatter = string.Formatter()strtuple = formatter.parse(strtmp)for i, v in enumerate(strtuple): print(i, v) ''' 0 ('This is a test:', 'Key2', '', None) 1 ('', 'Key1', '', None) '''# string.Formatter.parse(format_string) End 格式化字符串范例按位置访问参数123456789tupdata = ("This","is","a","test") # 元组formatstr = '&#123;0&#125; &#123;1&#125; &#123;2&#125; &#123;3&#125;'.format("This","is","a","test") print(formatstr) # This is a testformatstr = '&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;'.format(*tupdata) # *data 解包参数序列print(formatstr) # This is a testformatstr = '&#123;3&#125; &#123;2&#125; &#123;1&#125; &#123;0&#125;'.format(*tupdata) # *data 解包参数序列print(formatstr) # test a is Thisformatstr = '&#123;2&#125; &#123;3&#125; &#123;1&#125; &#123;2&#125; &#123;3&#125;'.format(*tupdata) # 参数可以重复print(formatstr) # a test is a test 按关键字访问参数12345dicdata = &#123;'Author':'leacoder','Time':'2019/04/17'&#125;formatstr = 'The author is &#123;Author&#125;，The time is &#123;Time&#125;'.format(Author='leacoder',Time='2019/04/17')print(formatstr) # The author is leacoder，The time is 2019/04/17formatstr = 'The author is &#123;Author&#125;，The time is &#123;Time&#125;'.format(**dicdata)print(formatstr) # The author is leacoder，The time is 2019/04/17 访问参数的属性12345678class Point: def __init__(self,x,y): self.x ,self.y = x, ypoint = Point(4,2)formatstr = 'Thie point is (&#123;key.x&#125;,&#123;key.y&#125;)'.format(key = point) # key 可为其他 print(formatstr) # Thie point is (4,2)formatstr = 'Thie point is (&#123;point.x&#125;,&#123;point.y&#125;)'.format(point = point) # point 可为其他 print(formatstr) # Thie point is (4,2) 访问参数的各项12345tupdata = ("leacoder","2019/04/17") # 元组formatstr = 'The author is &#123;0[0]&#125;,The time is &#123;0[1]&#125;'.format(tupdata)print(formatstr) # The author is leacoder,The time is 2019/04/17formatstr = 'The author is &#123;0[0]&#125;,The time is &#123;0[1]&#125;'.format(*tupdata) # 注意区别print(formatstr) # The author is l,The time is e 对齐文本并指定宽度12345678formatstr = '&#123;:&lt;30&#125;'.format('left aligned') # 左对齐 30位print(formatstr) # ‘left aligned ’ 为了体现位数加了‘’formatstr = '&#123;:&gt;30&#125;'.format('right aligned') # 右对齐 30位print(formatstr) # ‘ right aligned’formatstr = '&#123;:^30&#125;'.format('centered') # 中间对齐 30位print(formatstr) # ‘ centered ’formatstr = '&#123;:*^30&#125;'.format('centered') # 使用* 作为填充字符print(formatstr) # ‘***********centered***********’ Replacing %+f, %-f, and % f and specifying a sign: 替换％+ f，％ - f和％f并指定符号:123456formatstr = '&#123;:+f&#125;; &#123;:+f&#125;'.format(3.14, -3.14) # 总是显示它符号print(formatstr) # ‘+3.140000; -3.140000’formatstr = '&#123;: f&#125;; &#123;: f&#125;'.format(3.14, -3.14) # 正数前显示空格print(formatstr) # ‘ 3.140000; -3.140000’formatstr = '&#123;:-f&#125;; &#123;:-f&#125;'.format(3.14, -3.14) # 只显示负号 同 '&#123;:f&#125;; &#123;:f&#125;'print(formatstr) # ‘3.140000; -3.140000’ Replacing %x and %o and converting the value to different bases: 替换％x和％o并将值转换为不同的进制123456formatstr = "int: &#123;0:d&#125;; hex: &#123;0:x&#125;; oct: &#123;0:o&#125;; bin: &#123;0:b&#125;".format(64)print(formatstr) # int: 64; hex: 40; oct: 100; bin: 1000000formatstr = "int: &#123;0:d&#125;; hex: &#123;0:#x&#125;; oct: &#123;0:#o&#125;; bin: &#123;0:#b&#125;".format(64)print(formatstr) # int: 64; hex: 0x40; oct: 0o100; bin: 0b1000000formatstr = "int: &#123;0:d&#125;; hex: &#123;0:#x&#125;; oct: &#123;0:#o&#125;; bin: &#123;0:#b&#125;".format(0b1000001) # 也支持其他进制print(formatstr) # int: 65; hex: 0x41; oct: 0o101; bin: 0b100000 使用逗号作为千位分隔符1234points = 1total = 3formatstr = 'points / total = &#123;:.2%&#125;'.format(points/total)print(formatstr) # points / total = 33.33% 使用特定类型的格式1234import datetimed = datetime.datetime(2019, 4, 17, 22, 49, 2) # 2019/04/17 22:49:02formatstr = '&#123;:%Y-%m-%d %H:%M:%S&#125;'.format(d)print(formatstr) # 2019-04-17 22:49:02 模板字符串模板字符串规则12345678910'''模板字符串提供更简单的字符串替换，如PEP 292中所述 https://www.python.org/dev/peps/pep-0292/模板字符串支持基于$的替换，使用以下规则： 1、$$是转义; 它被替换为单个$。 2、$identifier 一个替换占位符，用于匹配映射关键字“identifier”默认情况下， “标识符”仅限于以下划线或ASCII字母开头的任何不区分大小写的ASCII字母数字字符串（包括下划线）。$字符后面的第一个非标识符字符结束此占位符。 3、$ &#123;identifier&#125;相当于$ identifier。当有效标识符字符跟随占位符但不是占位符的一部分时，例如“$ &#123;noun&#125; ification”，则需要它。 4、字符串中$的任何其他形式都将导致引发ValueError。字符串模块提供实现这些规则的Template类。class string.Template(template)''' class string.`Template`(template)substitute(mapping,**kwargs)123456789101112131415161718'''执行模板替换，返回一个新字符串。 mapping 为任意字典类对象，其中的键将匹配模板中的占位符。 或者你也可以提供一组关键字参数，其中的关键字即对应占位符。 当同时给出 mapping 和 kwds 并且存在重复时，则以 kwds 中的占位符为优先'''s = Template('The Author is $Author, The Time is $Time') # 使用Template类构造函数kewds = &#123;'Author':'leacoder', 'Time':'2019/04/18 00:01:38'&#125;templatestr = s.substitute(Author='leacoder', Time='2019/04/18 00:01:38') # **kewdsprint(templatestr) # The Author is leacoder, The Time is 2019/04/18 00:01:38templatestr = s.substitute(**kewds) # **kewdsprint(templatestr) # The Author is leacoder, The Time is 2019/04/18 00:01:38templatestr = s.substitute(kewds) # mappingprint(templatestr) # The Author is leacoder, The Time is 2019/04/18 00:01:38templatestr = s.substitute(kewds,Author='250',Time = 'No Time') # mapping **kewdsprint(templatestr) # The Author is 250, The Time is No Timekewds1 = &#123;'Author':'leacoder'&#125;templatestr = s.substitute(kewds1)print(templatestr) # KeyError: 'Time'# substitute(mapping, **kwds) End safe_substitute(mapping, **kwds)12345678'''类似于 substitute()，不同之处是如果有占位符未在 mapping 和 kwds 中找到，不是引发 KeyError 异常，而是将原始占位符不加修改地显示在结果字符串中。 另一个与 substitute() 的差异是任何在其他情况下出现的 $ 将简单地返回 $ 而不是引发 ValueError。'''# safe_substitute(mapping, **kwds)kewds1 = &#123;'Author':'leacoder'&#125;templatestr = s.safe_substitute(kewds1)print(templatestr) # The Author is leacoder, The Time is $Time# safe_substitute(mapping, **kwds) End 辅助函数string.`capwords`(s, sep=None）123'''使用 str.split() 将参数拆分为单词，使用 str.capitalize() 将单词转为大写形式，使用 str.join() 将大写的单词进行拼接。 如果可选的第二个参数 sep 被省略或为 None，则连续的空白字符会被替换为单个空格符并且开头和末尾的空白字符会被移除，否则 sep 会被用来拆分和拼接单词''']]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>standard_library</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode Cannot edit in read-only editor]]></title>
    <url>%2F2019%2F12%2F12%2Fvscode-Cannot-edit-in-read-only-editor%2F</url>
    <content type="text"><![CDATA[vscode Cannot edit in read-only editor 错误解决原因 使用了Run Code插件,output是只读的 解决方法将 run code设置为在Terminal中运行 1File -&gt; Preferences -&gt; Settings 找到 run code in terminal 打上 √ 或 在settings.json文件中,添加一行配置信息 1"code-runner.runInTerminal": true]]></content>
      <categories>
        <category>python</category>
        <category>IDEs</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install python3.8 on Centos6.5]]></title>
    <url>%2F2019%2F12%2F03%2FInstall-python3-8-on-Centos6-5%2F</url>
    <content type="text"><![CDATA[1. 安装必要的工具1sudo yum install yum-utils 2. 使用 yum-builddep 命令 设置 python 编译环境，下载缺少的依赖1sudo yum-builddep python 3. 下载 python3 的源代码源代码可以在 https://www.python.org/ftp/python/ 下载 1curl -O https://www.python.org/ftp/python/3.8.0/Python-3.8.0a1.tgz 4. 对源代码进行解压并编译安装1234tar xf Python-3.8.0a1.tgzcd Python-3.8.0a1./configuresudo make &amp;&amp; make install 5. 现在 python3 已经完成安装，使用 python3 -version 查看版本号显示 Python 3.8.0a1 表示已经成功 1python3 --version 6. 如果你想把 python3 作为默认python 解析器，可以进行如下设置1alias python='/usr/local/bin/python3.8' 7. 配置阿里pip源1234567891011[root@localhost ~]# cd [root@localhost ~]# mkdir .pip[root@localhost ~]# cd .pip[root@localhost .pip]# vim pip.conf#文件内容如下[global]index-url = http://mirrors.aliyun.com/pypi/simple [install]trusted-host=mirrors.aliyun.com]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios devices list]]></title>
    <url>%2F2019%2F12%2F02%2Fios-devices-list%2F</url>
    <content type="text"><![CDATA[ios 设备一览表iPhone 设备 时间 CPU 分辨率 大小 密度 @Nx iOS系统 iPhone 2007 armv6 320 x 480 3.5 165 @1x 1.0 - 3.1.3 iPhone 3G 2008 armv6 320 x 480 3.5 165 @1x 2.0 - 4.2.1 iPhone 3GS 2009 armv7 320 x 480 3.5 165 @1x 3.0 - 6.1.4 iPhone 4 (GSM) 2010 armv7 640 x 960 3.5 330 @2x 4.0 - 7.1.2 iPhone 4 (CDMA) 2011 armv7 640 x 960 3.5 330 @2x 4.2.4 - 7.1.2 iPhone 4S 2011 armv7 640 x 960 3.5 330 @2x 5.0 - 9.3.5 iPhone 5 2012 armv7s 640 x 1136 4 326 @2x 6.0 - 10.3.3 iPhone 5c 2013 armv7s 640 x 1136 4 326 @2x 7.0 - 10.3.3 iPhone 5s 2013 arm64 640 x 1136 4 326 @2x 7.0 - iPhone 6 2014 arm64 750 x 1334 4.7 326 @2x 8.0 - iPhone 6 Plus 2014 arm64 1242 x 2208 5.5 461 @3x 8.0 - iPhone 6s 2015 arm64 750 x 1334 4.7 326 @2x 9.0 - iPhone 6s Plus 2015 arm64 1242 x 2208 5.5 461 @3x 9.0 - iPhone SE 2016 arm64 640 x 1136 4 326 @2x 9.3 - iPhone 7 2016 arm64 750 x 1334 4.7 326 @2x 10.0 - iPhone 7 Plus 2016 arm64 1242 x 2208 5.5 461 @3x 10.0 - iPhone 8 2017 arm64 750 x 1334 4.7 326 @2x 11.0 - iPhone 8 Plus 2017 arm64 1242 x 2208 5.5 461 @3x 11.0 - iPhone X 2017 arm64 1125 x 2436 5.8 463 @3x 11.0 - iPhone XS 2018 arm64 1125 x 2436 5.8 463 @3x 12.0 - iPhone XS Max 2018 arm64 1242 x 2688 6.5 458 @3x 12.0 - iPhone XR 2018 arm64 828 x 1792 6.1 326 @2x 12.0 - iPhone 11 2019 arm64 828 x 1792 6.1 326 @2x 13.0 - iPhone 11 Pro 2019 arm64 1125 x 2436 5.8 458 @3x 13.0 - iPhone 11 Pro Max 2019 arm64 1242 x 2688 6.5 458 @3x 13.0 - 注：屏幕分辨率单位为英寸(inch)，分辨率密度单位为ppi iPad 设备 发布年份 CPU架构 分辨率 @Nx iOS系统 iPad 2010 armv7 768 x 1024 @1x 3.2 - 5.1.1 iPad 2 2011 armv7 768 x 1024 @1x 4.3 - 9.3.5 iPad (3rd) 2012 armv7 1536 x 2048 @2x 5.1 - 9.3.5 iPad mini 2012 armv7s 768 x 1024 @1x 6.0 - 9.3.5 iPad (4rd) 2012 armv7s 1536 x 2048 @2x 6.0 - iPad Air 2013 arm64 1536 x 2048 @2x 7.0 - iPad mini Retina 2013 arm64 1536 x 2048 @2x 7.0 - iPad Air 2 2014 arm64 1536 x 2048 @2x 8.1 - iPad mini 3 2014 arm64 1536 x 2048 @2x 8.1 - iPad mini 4 2015 arm64 1536 x 2048 @2x 9.0 - iPad Pro (12.9) 2015 arm64 2048 x 2732 @2x 9.1 - iPad Pro (9.7) 2016 arm64 1536 x 2048 @2x 9.3 - iPad (5rd) 2017 arm64 1536 x 2048 @2x 10.2.1 - iPad Pro (10.5) 2017 arm64 1668 x 2224 @2x 10.3.2 - iPad Pro (12.9-2) 2017 arm64 2048 x 2732 @2x 10.3.2 - iPad (10.2) 2019 arm64 1620 x 2160 @2x iPadOS iPod touch 设备 发布年份 CPU架构 分辨率 @Nx iOS系统 iPod touch 2007 armv6 320 x 480 @1x 1.1 - 3.1.3 iPod touch (2nd) 2008 armv6 320 x 480 @1x 2.1.1 - 4.2.1 iPod touch (3rd) 2009 armv7 320 x 480 @1x 3.1 - 5.1.1 iPod touch (4th) 2010 armv7 640 x 960 @2x 4.1 - 6.1.4 iPod touch (5th) 2012 armv7 640 x 1136 @2x 6.0 - 9.3.5 iPod touch (6th) 2015 arm64 640 x 1136 @2x 8.4 - 参考文档iOS设备一览表]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>app</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git diff usage]]></title>
    <url>%2F2019%2F11%2F21%2Fgit-diff-usage%2F</url>
    <content type="text"><![CDATA[Git 中 diff 命令使用整理总结工作中常用的git 命令, 今天是一个非常有用的命令 git diff 主要作用是用来比较差异，包括 commits之间,commit 和 工作区间 差异 命令格式如下： 12345git diff [&lt;options&gt;] [&lt;commit&gt;] [--] [&lt;path&gt;…​]git diff [&lt;options&gt;] --cached [&lt;commit&gt;] [--] [&lt;path&gt;…​]git diff [&lt;options&gt;] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…​]git diff [&lt;options&gt;] &lt;blob&gt; &lt;blob&gt;git diff [&lt;options&gt;] --no-index [--] &lt;path&gt; &lt;path&gt; 1. 比较工作区与暂存区1git diff 不加参数 2. 比较暂存区与 本地 最新版本 (最后一次commit)1git diff --cached 3. 比较工作区与最新本地版本库1git diff HEAD 4. 比较工作区与commit-id的差异1git diff commit-id 5. 比较暂存区与指定commit-id的差异1git diff --cached commit-id 6. 比较两个commit-id之间的差异1git diff commit-id commit-id 7. 比较不同本地分支的差异1git diff dev # 当前所处分支为master 8. 比较本地分支和远程分支之间的差异12git fetch origin mastergit diff master origin/master 9. 比较差异只显示文件名1git diff --name-only 10 . 比较差异 显示更改文件状态1git diff --name-status]]></content>
      <categories>
        <category>版本管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript get checkbox checked value]]></title>
    <url>%2F2019%2F09%2F28%2Fjavascript-get-checkbox-checked-value%2F</url>
    <content type="text"><![CDATA[javascript如何获取checkbox被选中的值预备知识javascript dom 常用方法 方法名 描述 例子 document.getElementById 返回给定id属性值的元素节点相对应的对象 document.getElementsByTagName 返回给定name属性的元素节点对应的元素集合 var hobbies = document.getElementsByName(“hobbies”); element.nextSibling 返回该元素紧跟的一个节点 nodeValue 获取节点中的文本值 ,例如：跑步 跑步 数组常用方法： 方法 或者 属性 说明 例子 arrayObject.length 属性：数组长度 arrayObject.push() 向数组末尾添加一个或多个元素 var arr = new Array(3) arr[0] = “George” arr[1] = “John” arr[2] = “Thomas” 页面如下：12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;javascript获取复选框值方法&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;input type="checkbox" name="hobbies" id="hobbies" class="hobbies" value="1"&gt;游泳 &lt;input type="checkbox" name="hobbies" id="hobbies" class="hobbies" value="2"&gt;跑步 &lt;/p&gt; &lt;p&gt; &lt;button id="btn1"&gt;获取复选框值&lt;/button&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 方法一 通过复选框的name属性,遍历后将被选中的复选框的值输出 checkbox[index].nextSibling.nodeValue: 获取的是checkbox中标签包裹的文本值 123456789function get_checkbox_val() &#123; var hobbies = document.getElementsByName("hobbies"); for (let index = 0; index &lt; hobbies.length; index++) &#123; if (hobbies[index].checked) &#123; alert(hobbies[index].value + "," + hobbies[index].nextSibling.nodeValue); &#125; &#125; &#125; 方法二 建立一个数组,使用push方法将被选中的元素保存到数组 123456789function get_checkbox_val_with_array() &#123; var arr = []; for (let index = 0; index &lt; hobbies.length; index++) &#123; if (hobbies[index].checked) &#123; arr.push(hobbies[index].value); &#125; &#125; alert(arr); &#125; 方法三 通过class选择器 获取被选中的复选框的值 123456789function get_checkbox_val_with_selector() &#123; var hobbies = document.getElementsByClassName('hobbies'); for (let index = 0; index &lt; hobbies.length; index++) &#123; if (hobbies[index].checked) &#123; checkedValue = hobbies[index].value; alert(hobbies[index].value + "," + hobbies[index].nextSibling.nodeValue); &#125; &#125; &#125; 使用jquery 需要引入jquery,这里我使用国内的cdn jquery中通过each() 方法遍历所有被选中的复选框的值 12345678910&lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt; $('#btn1').click(function () &#123; $("input[name='hobbies']:checked").each(function () &#123; alert($(this).val()); &#125;); &#125;); &lt;/script&gt; &lt;/script&gt; ==tips== : $(“input[name=’xxxx’]:checked”) 被选中的复选框对象集合]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>checkbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中Boolean_Object与Boolean_Primitives]]></title>
    <url>%2F2019%2F09%2F20%2Fjavascript%E4%B8%ADBoolean-Object%E4%B8%8EBoolean-Primitives%2F</url>
    <content type="text"><![CDATA[先看下面的脚本，预测下结果 123456var flag = true;console.log(typeof(flag));//booleanvar fa = Boolean(true);console.log(typeof(fa));//booleanvar ff = new Boolean(true);console.log(typeof(ff)); //Object 在 jslint中明确提示 new Boolean(true)；do not use Boolean as a constructor. (W053)jshint(W053) 接下来的例子 123456789if(flag)&#123; console.log("true is true");&#125;if(fa)&#123; console.log("Boolean is true");&#125;if(ff)&#123; console.log("Object Boolean is true");&#125; 结果如下 123true is trueBoolean is trueObject Boolean is true 修改脚本： 123456var flag = true;console.log(typeof(false));//booleanvar fa = Boolean(false);console.log(typeof(fa));//booleanvar ff = new Boolean(false);console.log(typeof(ff)); //Object 结果竟然显示： 1Object Boolean is true 后来查阅资料发现, JavaScript的其他数据类型都可以转换成Boolean类型，注意！！！只有这几种类型会转换为false 123456undefinednull0-0NaN"" (空字符串) 其他都转化为true,包括空对象{}，空数组[] ， 负数 ，false的对象包装等。 123456789101112if(-1)&#123; console.log('-1转换为true');&#125;if(&#123;&#125;)&#123; console.log('&#123;&#125;转换为true');&#125;if([])&#123; console.log('[]转换为true');&#125;if(new Boolean(false))&#123; console.log('new Boolean(false)转换为true');&#125; new Boolean(false)是布尔值的包装对象 typeof (new Boolean(false)) // ‘object’ ,所以 转换为boolean是true，而不是false。 从另一个层面也证明了为啥jslint 禁止在构造方法里使用Boolean类型的数据。 后记Boolean.valueOf() 可以返回Boolean对象对应的值类型 1234/**/if(ff.valueOf())&#123; console.log("Object Boolean is true"); &#125; 补充对于数字0 连续使用两次!! 仍旧返回false. 123var fa = Boolean(0);console.log(fa); //falseconsole.log(!!0);//false 参考文章 JavaScript Boolean( new Boolean(false) ) 其实是true The Difference Between Boolean Objects and Boolean Primitives in JavaScript]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>Boolean</tag>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how to add 163 music to hexo]]></title>
    <url>%2F2019%2F09%2F06%2Fhow-to-add-163-music-to-hexo%2F</url>
    <content type="text"><![CDATA[如何给hexo添加网易音乐先看看效果 1.访问网易云首页，选择你喜欢的音乐，点击生成外链,我不希望音乐一直播放,如果来访的朋友想听,点击下播放就好。 这里我选择二十岁的某一天 2. 复制iframe插件下的src里的地址 3. 修改themes/next/layout/sidebar.swig文件12345&#123;% if theme.background_music %&#125; &lt;div&gt; &lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="210" height="110" src="&#123;&#123; theme.background_music &#125;&#125;"&gt;&lt;/iframe&gt; &lt;/div&gt;&#123;% endif %&#125; 4.添加音乐地址到主题1background_music : //music.163.com/outchain/player?type=2&amp;id=247172&amp;auto=1&amp;height=66]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>网易音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how to Sort Python Dictionaries by Key or Value]]></title>
    <url>%2F2019%2F07%2F28%2Fhow-to-Sort-Python-Dictionaries-by-Key-or-Value%2F</url>
    <content type="text"><![CDATA[众所周知,python中字典是无序的,那么该如何对字典排序呢？ 例如下面的字典： 1numbers = &#123;'second': 2,'first': 1, 'third': 3, 'Fourth': 4&#125; 我们可以通过list()函数打印value,12&gt;&gt;&gt;list(numbers)['second', 'first', 'third', 'Fourth'] 备注: python3.6.4 以上的版本,字典根据插入的顺序自动排序 如何根据key 对字典排序可以使用python的内置函数sorted 来对字典排序,如下面的代码 12&gt;&gt;&gt; sorted(numbers)['Fourth', 'first', 'second', 'third'] 结果有点差强人意,因为默认sorted函数是根据字母的顺序升序排列的,这里的字典中 key 恰好是字母，所以才会显示这个结果。 根据value对字典排序用同样的方法,我们可以根据value来排序 12&gt;&gt;&gt; sorted(numbers.values())[1, 2, 3, 4] 如何根据自定义的规则对字典排序sorted函数还有一个可选参数叫key,注意这里的key和字典的key没有关系,根据指定的key 来进行排序,实现的机制类似迭代器。来看这个例子： 12&gt;&gt;&gt; sorted(numbers,key=numbers.__getitem__)['first', 'second', 'third', 'Fourth'] 这里我们使用了字典类中内置函数__getitem__ 在遍历字典值的过程中,获取对应的值来对字典排序 关于__getitem__ 函数的详细说明，请参考官方文档。 当然我们也可以使用列表推导的方式来进行排序(实质上是转化成了列表来进行排序) 1234&gt;&gt;&gt; sorted(numbers,key=numbers.__getitem__,reverse=True)['Fourth', 'third', 'second', 'first']&gt;&gt;&gt; [value for (key,value) in sorted(numbers.items(),reverse=True)][3, 2, 1, 4] 字典的key是数字或者字母的情况下对字典排序12&gt;&gt;&gt; sorted(numbers,key=str.lower)['first', 'Fourth', 'second', 'third'] 我们定义一个新的字典 12345&gt;&gt;&gt; month = dict(one='January', two='February', three='March', four='April', five='May') 通过__getitem__方法比较 我们定义的字典month中对应的值 123&gt;&gt;&gt; numbermap = &#123;'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5&#125;&gt;&gt;&gt; sorted(month, key=numbermap.__getitem__)['one', 'two', 'three', 'four', 'five'] 同样的原理,可以使用列表推导来实现排序 12&gt;&gt;&gt; [month[i] for i in sorted(month,key=numbermap.__getitem__)]['January', 'February', 'March', 'April', 'May'] 定义一个方法来定义我们自己的排序规则1234567891011def repeats(string): # Lower the case in the string string = string.lower() # Get a set of the unique letters uniques = set(string) # Count the max occurrences of each unique letter counts = [string.count(letter) for letter in uniques] return max(counts) 根据字母小写排序 12&gt;&gt;&gt; sorted(month.values(), key=repeats, reverse=True)['February', 'January', 'March', 'April', 'May'] 使用lambda表达式排序使用lambda表达式 12&gt;&gt;&gt; sorted(month.items(),key=lambda x:x[1])[('four', 'April'), ('two', 'February'), ('one', 'January'), ('three', 'March'), ('five', 'May')] 12&gt;&gt;&gt; sorted(month.items(),key=lambda x:x[0])[('five', 'May'), ('four', 'April'), ('one', 'January'), ('three', 'March'), ('two', 'February')] 其中： lambda x:x[1] 表明根据值排序 lambda x:x[0] 表明根据键排序 以上就是python中对字典排序的一个总结,希望能帮到大家。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>dict</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-undefined-description]]></title>
    <url>%2F2019%2F06%2F11%2Fjavascript-undefined-description%2F</url>
    <content type="text"><![CDATA[Javascript 基础拾遗之undefined先看一个例子： 123var a;console.log(a);//undefinedconsole.log(typeof(a)); //undefined javascript中的数据类型包括undefined，null,boolean,number,string,boolean六种类型(ECMAScript 2015) undefined 小结undefined 类型的意思是当前对象未定义,适用于下面几种情况 变量声明,但未赋值 对象没有赋值的属性,该属性的值为undefined 调用函数参数,但是未提供参数，该参数的值为undefined 函数没有返回值时,默认返回undefined 再看下面的例子 123456789101112131415161718//1.var i;console.log(i);//2.var o = new Object();console.log(o.p);//3.function test(a)&#123; console.log(typeof a); // undefined return a;&#125;test();//4.myfunc()function myfunc()&#123; //console.log("my function.");&#125;console.log(myfunc()); 需要区别下面这个情况,不同浏览器提示信息可能会不同(Chrome和IE测试) 12console.log(b);// Uncaught ReferenceError: b is not defined 如何判断为空下面三种判断方法： 123456// 方式1if(typeof age === 'undefined')// 方式2if(age === undefined)// 方式3if(varName) //万能判断,包括boolean 参考文档火狐JavaScript教程 stackoverflow如何检查undefined]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Build path entry is missing /src/test/java missing问题解决]]></title>
    <url>%2F2019%2F06%2F03%2FMaven-webapp-buildpath-missing-test-folder%2F</url>
    <content type="text"><![CDATA[[问题描述]通过maven构建webapp,发现缺少java和test目录 [解决方案] project –right click –build path– config build path – libraries – double click “JRE System Library”–choose “workspace default JRE” OK 如下图所示]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how-to-fix-cannot-change-version-of-project-dynamic-web-module-to-3.1-in-Eclipse]]></title>
    <url>%2F2019%2F06%2F03%2Fhow-to-fix-cannot-change-version-of-project-dynamic-web-module-to-3.1-in-Eclipse%2F</url>
    <content type="text"><![CDATA[1.问题描述 试图转换Dynamic Web Module 发生如下错误: 12Cannot change version of project facet Dynamic Web Module to 3.0 One or more constraints have not been satisfied 操作步骤： 右键点击项目 选择Properties 点击Project facet 选项 更改Dynamic Web Module, 2.3 到 3.1 ,如下图 2. 解决步骤Step 1： 选择navigator 视图 Step 2: 打开org.eclipse.wst.common.project.facet.core.xml 修改jst.web 的值2.3 为 3.1 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;faceted-project&gt; &lt;fixed facet="wst.jsdt.web"/&gt; &lt;installed facet="jst.jaxrs" version="2.0"/&gt; &lt;installed facet="wst.jsdt.web" version="1.0"/&gt; &lt;installed facet="java" version="1.8"/&gt; &lt;installed facet="jst.web" version="3.1"/&gt;&lt;/faceted-project&gt; 注意 jst.web版本3.1,那么java版本必须是1.7以上才可以 Step 3: 刷新项目 鼠标右键点击项目 F5刷新项目 清理项目 点击顶部菜单栏 Project 选择Clean maven更新 鼠标右键点击项目名称 选择Maven 选择Update project 3. 问题总结没有清理项目就直接更新,缓存造成更新失败。 参考链接 how-to-fix-cannot-change-version-of-project-dynamic-web-module-to-3.1-in-Eclipse]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>java</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo建站搭建流程]]></title>
    <url>%2F2019%2F05%2F31%2Fhexo%E5%BB%BA%E7%AB%99%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[下载并安装 Visual Studio Code, 官方下载 下载并安装 Nodejs, 官方下载 12node -vnpm -v npm 镜像源修改为 淘宝NPM镜像 1npm install -g cnpm --registry=https://registry.npm.taobao.org 下载并安装 Git, 官方下载 123#配置名字和邮箱git config --global user.name &quot;test&quot;git config --global user.email &quot;test@.com&quot; 安装 Hexo, 官方文档 12cnpm install -g hexo-clihexo -v 初始化博客目录 1234cd Dhexo init blogcd blogcnpm install 启动服务器,本地预览 1hexo server Hexo 常用站点配置_config.yml 12345678910#网站标题title: test#作者昵称author: test#站点描述[签名]description: 站点描述#网站地址url: http://www.test.com#文章的链接格式permalink: :title.html 添加标签 1234#生成文件路径 source/tags/index.mdhexo new page tags#编辑index.md,添加typetype: &quot;tags&quot; 添加分类 1234#生成文件路径 source/categories/index.mdhexo new page categories#编辑index.md,添加typetype: &quot;categories&quot; 文章添加标签与分类 12345categories: - hexotags: - hexo - github 设置阅读全文 12#在文章中使用 &lt;!-- more --&gt; 手动截断 &lt;!-- more --&gt; Hexo 主题,这里选择 Next, Github地址 文档安装 Next 主题 1git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题并设置语言,站点配置 12theme: nextlanguage: zh-CN 主题常用配置,themes/next/_config.yml 12345678910111213141516171819#主题外观设定scheme: Gemini#设置菜单menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive#设置代码高亮主题highlight_theme: night eighties#添加友情链接links: test: http://www.test.com#文章自动添加版权声明post_copyright: enable: true#返回顶部按钮显示百分比sidebar: scrollpercent: true 设置RSS,安装hexo-generator-feed 1cnpm install hexo-generator-feed --save 安装hexo-generator-searchdb,添加百度/谷歌/本地 自定义站点内容搜索 1cnpm install hexo-generator-searchdb --save 启用搜索,主题配置 12local_search: enable: true 配置搜索,站点配置 12345search: path: search.xml field: post format: html limit: 7777 设置favicon.ico,将favicon.ico上传至站点根目录/source 目录下,主题配置 123favicon: small: favicon.ico medium: favicon.ico 部署Hexo至Github安装 hexo-deployer-git 1cnpm install hexo-deployer-git --save 站点配置 123deploy: type: git repo: https://github.com/github账号/github账号.github.io.git 生成并部署 1hexo d -g Github 自定义域名,由于Hexo每次部署到Github都会覆盖Github的域名配置,所以直接在Hexo配置,然后再部署,在根目录下的source目录下新建CNAME文件,无后缀名 12#自定义域名xxx.com 解析域名到 github.io,记录类型 = CNAME, 记录值 = github账号.github.io 码云新建一个项目, 路径 https://gitee.com/test/test.git Hexo 目录说明 12.deploy_git Hexo默认的.git配置文件夹public 根据source文件夹内容自动生成 进入 Hexo根目录,执行以下命令,先删除 themes/next 目录下的 .gitignore 文件 12345678910#初始化仓库git init#添加远程主机git remote add origin https://gitee.com/test/test.git#添加目录下所有文件,不包含 .gitignore 声明的文件git add .#添加更新说明git commit -m &quot;hexo first commit&quot;#推送更新到云端服务器git push -u origin master 创建 test 目录,将 Git 的内容同步到本地并安装Hexo 1234567mkdir testcd testgit initgit remote add origin https://gitee.com/test/test.gitgit fetch --allgit reset --hard origin/mastercnpm install blog 目录是A电脑, test 目录是B电脑, 更新文章后的同步操作： 12345678#A电脑修改了 test.md,添加更新说明并推送到远程仓库,使用git status查看状态会显示刚刚更改过的文件状态git commit -m &quot;update test.md&quot;git push origin mastergit status#B电脑同步更新git pull origin master#可以通过指定当前目录工作分支与远程仓库分支之间的链接关系git branch --set-upstream-to=origin/master master hexo 数据文件,通用配置文件,新建 source/_data 目录, 主题的配置可以在此目录下配置,以 Next 主题为例,在此目录下新建 next.yml, 则 next.yml 的配置会覆盖 themes/next/_config.yml 的相同配置]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>搭建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python创建字典的几种方法]]></title>
    <url>%2F2019%2F05%2F28%2Fpython%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[python创建字典的几种方法1. 创建空字典123&gt;&gt;&gt; dic = &#123;&#125;&gt;&gt;&gt; type(dic)&lt;type &apos;dict&apos;&gt; 另一种形式：12temp = dict()temp[&apos;name&apos;] = &apos;xiaoming&apos; 2. 直接赋值创建123&gt;&gt;&gt; dic = &#123;&apos;spam&apos;:1, &apos;egg&apos;:2, &apos;bar&apos;:3&#125;&gt;&gt;&gt; dic&#123;&apos;bar&apos;: 3, &apos;egg&apos;: 2, &apos;spam&apos;: 1&#125; 3. 通过关键字dict和关键字参数创建123&gt;&gt;&gt; dic = dict(spam = 1, egg = 2, bar =3)&gt;&gt;&gt; dic&#123;&apos;bar&apos;: 3, &apos;egg&apos;: 2, &apos;spam&apos;: 1&#125; 4. 通过二元组列表创建1234&gt;&gt;&gt; list = [(&apos;spam&apos;, 1), (&apos;egg&apos;, 2), (&apos;bar&apos;, 3)]&gt;&gt;&gt; dic = dict(list)&gt;&gt;&gt; dic&#123;&apos;bar&apos;: 3, &apos;egg&apos;: 2, &apos;spam&apos;: 1&#125; 5. dict和zip结合创建123&gt;&gt;&gt; dic = dict(zip(&apos;abc&apos;, [1, 2, 3]))&gt;&gt;&gt; dic&#123;&apos;a&apos;: 1, &apos;c&apos;: 3, &apos;b&apos;: 2&#125; 6. 通过字典推导式创建123&gt;&gt;&gt; dic = &#123;i:2*i for i in range(3)&#125;&gt;&gt;&gt; dic&#123;0: 0, 1: 2, 2: 4&#125; 7. 通过dict.fromkeys()创建123&gt;&gt;&gt; dic = dict.fromkeys(range(3), &apos;x&apos;)&gt;&gt;&gt; dic&#123;0: &apos;x&apos;, 1: &apos;x&apos;, 2: &apos;x&apos;&#125; 8. 其他1234&gt;&gt;&gt; list = [&apos;x&apos;, 1, &apos;y&apos;, 2, &apos;z&apos;, 3]&gt;&gt;&gt; dic = dict(zip(list[::2], list[1::2]))&gt;&gt;&gt; dic&#123;&apos;y&apos;: 2, &apos;x&apos;: 1, &apos;z&apos;: 3&#125;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python操作sqlite3]]></title>
    <url>%2F2019%2F05%2F28%2Fpython%E6%93%8D%E4%BD%9Csqlite3%2F</url>
    <content type="text"><![CDATA[sqlite3 简介1234567891011121314151617181920212223242526272829303132SQLite数据库是一款非常小巧的嵌入式开源数据库软件，也就是说没有独立的维护进程，所有的维护都来自于程序本身。在python中，使用sqlite3创建数据库的连接，当我们指定的数据库文件不存在的时候连接对象会自动创建数据库文件；如果数据库文件已经存在，则连接对象不会再创建数据库文件，而是直接打开该数据库文件。 连接对象可以是硬盘上面的数据库文件，也可以是建立在内存中的，在内存中的数据库 执行完任何操作后，都不需要提交事务的(commit) 创建在硬盘上面： conn = sqlite3.connect(&apos;c:\\test\\test.db&apos;) 创建在内存上面： conn = sqlite3.connect(&apos;&quot;memory:&apos;) 下面我们一硬盘上面创建数据库文件为例来具体说明： conn = sqlite3.connect(&apos;c:\\test\\hongten.db&apos;) 其中conn对象是数据库链接对象，而对于数据库链接对象来说，具有以下操作： commit() --事务提交 rollback() --事务回滚 close() --关闭一个数据库链接 cursor() --创建一个游标 cu = conn.cursor() 这样我们就创建了一个游标对象：cu 在sqlite3中，所有sql语句的执行都要在游标对象的参与下完成 对于游标对象cu，具有以下具体操作： execute() --执行一条sql语句 executemany() --执行多条sql语句 close() --游标关闭 fetchone() --从结果中取出一条记录 fetchmany() --从结果中取出多条记录 fetchall() --从结果中取出所有记录 scroll() --游标滚动 sqlite3常用操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2019-03-14 16:10:24# @Author : Jeff.Sui (215687736@qq.com)# @Link : http://example.org# @Version : $Id$import sqlite3con = sqlite3.connect(&quot;:memory:&quot;)c = con.cursor()# Create tablec.execute(&apos;&apos;&apos;CREATE TABLE stocks (date text, trans text, symbol text, qty real, price real)&apos;&apos;&apos;)# Insert a row of datac.execute(&quot;INSERT INTO stocks VALUES (?,?,?,?,?)&quot;, (&apos;2006-03-27&apos;,&apos;BUY&apos;,&apos;RHAT&apos;,100,60.14))# Larger example that inserts many records at a timepurchases = [(&apos;2006-03-28&apos;, &apos;BUY&apos;, &apos;IBM&apos;, 1000, 45.00), (&apos;2006-04-05&apos;, &apos;BUY&apos;, &apos;MSFT&apos;, 1000, 72.00), (&apos;2006-04-06&apos;, &apos;SELL&apos;, &apos;IBM&apos;, 500, 53.00), (&apos;2006-04-07&apos;, &apos;SELL&apos;, &apos;MSFT&apos;, 500, 74.00), (&apos;2006-04-08&apos;, &apos;SELL&apos;, &apos;IBM&apos;, 500, 54.00), (&apos;2006-04-09&apos;, &apos;SELL&apos;, &apos;MSFT&apos;, 500, 73.00), (&apos;2006-04-10&apos;, &apos;SELL&apos;, &apos;MSFT&apos;, 500, 75.00), (&apos;2006-04-12&apos;, &apos;SELL&apos;, &apos;IBM&apos;, 500, 55.00), ]c.executemany(&apos;INSERT INTO stocks VALUES (?,?,?,?,?)&apos;, purchases)# Save (commit) the changescon.commit()# Do this insteadt = (&apos;RHAT&apos;,)c.execute(&apos;SELECT * FROM stocks WHERE symbol=?&apos;, t)#print(c.fetchone())#for row in c.execute(&apos;SELECT * FROM stocks ORDER BY price&apos;):# print(row) #for row in c.execute(&apos;SELECT * FROM stocks LIMIT 5 OFFSET 0&apos;):# print(row)for row in c.execute(&apos;SELECT * FROM stocks LIMIT 5 OFFSET 1&apos;): print(row)#Select Top N * From# ====================================================================================# SQLite 日期 &amp; 时间# ====================================================================================print(&apos;=&apos;*30)print(&apos;SQLite 日期 &amp; 时间&apos;)print(&apos;=&apos;*30)# 计算当前日期c.execute(&quot;SELECT date(&apos;now&apos;)&quot;)print(c.fetchone())# 计算当前月份的最后一天：c.execute(&quot;SELECT date(&apos;now&apos;,&apos;start of month&apos;,&apos;+1 month&apos;,&apos;-1 day&apos;);&quot;)print(c.fetchone())# 计算给定 UNIX 时间戳 1092941466 的日期和时间：c.execute(&quot;SELECT datetime(1092941466, &apos;unixepoch&apos;);&quot;)print(c.fetchone())# 计算给定 UNIX 时间戳 1092941466 相对本地时区的日期和时间：c.execute(&quot;SELECT datetime(1092941466, &apos;unixepoch&apos;, &apos;localtime&apos;);&quot;)print(c.fetchone())# 计算当前的 UNIX 时间戳：c.execute(&quot;SELECT datetime(1092941466, &apos;unixepoch&apos;, &apos;localtime&apos;);&quot;)print(c.fetchone())# 计算美国&quot;独立宣言&quot;签署以来的天数：c.execute(&quot;SELECT julianday(&apos;now&apos;) - julianday(&apos;1776-07-04&apos;);&quot;)print(c.fetchone())# 计算从 2004 年某一特定时刻以来的秒数：c.execute(&quot;SELECT strftime(&apos;%s&apos;,&apos;now&apos;) - strftime(&apos;%s&apos;,&apos;2004-01-01 02:34:56&apos;);&quot;)print(c.fetchone())# 计算当年 10 月的第一个星期二的日期：c.execute(&quot;SELECT date(&apos;now&apos;,&apos;start of year&apos;,&apos;+9 months&apos;,&apos;weekday 2&apos;);&quot;)print(c.fetchone())# 计算从 UNIX 纪元算起的以秒为单位的时间（类似 strftime(&apos;%s&apos;,&apos;now&apos;) ，不同的是这里有包括小数部分）：c.execute(&quot;SELECT (julianday(&apos;now&apos;) - 2440587.5)*86400.0;&quot;)print(c.fetchone())# 在 UTC 与本地时间值之间进行转换，当格式化日期时，使用 utc 或 localtime 修饰符，如下所示：c.execute(&quot;SELECT time(&apos;12:00&apos;, &apos;localtime&apos;);&quot;)print(c.fetchone())# c.execute(&quot;SELECT time(&apos;12:00&apos;, &apos;utc&apos;);&quot;)print(c.fetchone())con.close()# ====================================================================================# SQLite 常用函数# ====================================================================================print(&apos;=&apos;*30)print(&apos;SQLite 常用函数&apos;)print(&apos;=&apos;*30)con = sqlite3.connect(&quot;:memory:&quot;)c = con.cursor()# Create tablec.execute(&apos;&apos;&apos;CREATE TABLE COMPANY (ID integer, NAME text, AGE integer, ADDRESS text, SALARY real)&apos;&apos;&apos;)# Larger example that inserts many records at a timepurchases = [(1,&apos;Paul&apos;,32,&apos;California&apos;,20000.0), (2,&apos;Allen&apos;,25,&apos;Texas&apos;,15000.0), (3,&apos;Teddy&apos;,23,&apos;Norway&apos;,20000.0), (4,&apos;Mark&apos;,25,&apos;Rich-Mond&apos;,65000.0), (5,&apos;David&apos;,27,&apos;Texas&apos;,85000.0), (6,&apos;Kim&apos;,22,&apos;South-Hall&apos;,45000.0), (7,&apos;James&apos;,24,&apos;Houston&apos;,10000.0)]c.executemany(&apos;INSERT INTO COMPANY VALUES (?,?,?,?,?)&apos;, purchases)# Save (commit) the changescon.commit()# 返回数据库表最后 n 行记录# 先计算一个数据库表中的行数c.execute(&quot;SELECT count(*) FROM COMPANY;&quot;)last = c.fetchone()[0]n = 5c.execute(&quot;SELECT * FROM COMPANY LIMIT ? OFFSET ?;&quot;, (n, last-n))for row in c: print(row)# 计算一个数据库表中的行数c.execute(&quot;SELECT count(*) FROM COMPANY;&quot;)print(c.fetchone())# 选择某列的最大值c.execute(&quot;SELECT max(salary) FROM COMPANY;&quot;)print(c.fetchone())# 选择某列的最小值c.execute(&quot;SELECT min(salary) FROM COMPANY;&quot;)print(c.fetchone())# 计算某列的平均值c.execute(&quot;SELECT avg(salary) FROM COMPANY;&quot;)print(c.fetchone())# 为一个数值列计算总和c.execute(&quot;SELECT sum(salary) FROM COMPANY;&quot;)print(c.fetchone())# 返回一个介于 -9223372036854775808 和 +9223372036854775807 之间的伪随机整数c.execute(&quot;SELECT random() AS Random;&quot;)print(c.fetchone())# 返回数值参数的绝对值c.execute(&quot;SELECT abs(5), abs(-15), abs(NULL), abs(0), abs(&apos;ABC&apos;);&quot;)print(c.fetchone())# 把字符串转换为大写字母c.execute(&quot;SELECT upper(name) FROM COMPANY;&quot;)print(c.fetchone())# 把字符串转换为小写字母c.execute(&quot;SELECT lower(name) FROM COMPANY;&quot;)print(c.fetchone())# 返回字符串的长度c.execute(&quot;SELECT name, length(name) FROM COMPANY;&quot;)print(c.fetchone())# 返回 SQLite 库的版本c.execute(&quot;SELECT sqlite_version() AS &apos;SQLite Version&apos;;&quot;)print(c.fetchone())# c.execute(&quot;SELECT CURRENT_TIMESTAMP;&quot;)print(c.fetchone())]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sqlite3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium元素操作封装]]></title>
    <url>%2F2019%2F05%2F28%2Fselenium%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[selenium 常用的元素定位操作Selenium提供了8种定位方式。 id name class name tag name link text partial link text xpath css selector 这8种定位方式在Python selenium中所对应的方法为： find_element_by_id() find_element_by_name() find_element_by_class_name() find_element_by_tag_name() find_element_by_link_text() find_element_by_partial_link_text() find_element_by_xpath() find_element_by_css_selector() 常用元素定位封装12345678910111213141516171819202122232425262728293031323334def _locate_element(self, selector): """ to locate element by selector :arg selector should be passed by an example with "i,xxx" "x,//*[@id='langs']/button" :returns DOM element """ if self.by_char not in selector: return self.base_driver.find_element_by_id(selector) selector_by = selector.split(self.by_char)[0].strip() selector_value = selector.split(self.by_char)[1].strip() if selector_by == "i" or selector_by == 'id': element = self.base_driver.find_element_by_id(selector_value) elif selector_by == "n" or selector_by == 'name': element = self.base_driver.find_element_by_name(selector_value) elif selector_by == "c" or selector_by == 'class_name': element = self.base_driver.find_element_by_class_name(selector_value) elif selector_by == "l" or selector_by == 'link_text': element = self.base_driver.find_element_by_link_text(selector_value) elif selector_by == "p" or selector_by == 'partial_link_text': element = self.base_driver.find_element_by_partial_link_text(selector_value) elif selector_by == "t" or selector_by == 'tag_name': element = self.base_driver.find_element_by_tag_name(selector_value) elif selector_by == "x" or selector_by == 'xpath': element = self.base_driver.find_element_by_xpath(selector_value) elif selector_by == "s" or selector_by == 'css_selector': element = self.base_driver.find_element_by_css_selector(selector_value) else: raise NameError("Please enter a valid type of targeting elements.") return element]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>web test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用selenium访问爱奇艺网站]]></title>
    <url>%2F2019%2F05%2F28%2Fusing-selenium-visit-iqiyi-website%2F</url>
    <content type="text"><![CDATA[使用selenium访问爱奇艺网站 selenium 是一种常用的自动化测试工具。它支持各种浏览器，包括 Chrome，Safari，Firefox 等主流界面式浏览器，如果你在这些浏览器里面安装一个 Selenium 的插件，还可以通过录制，快速生成脚本。 selenium 支持多种主流的开发语言，比如Ruby，java，python，javascript。 环境搭建python3.7.3 运行 pip install selenium 就可以直接下载最新的selenium版本 准备浏览器:chrome 70.0.3538.77 操作系统：win7 selenium版本: 3.14.1 chromedriver: https://npm.taobao.org/mirrors/chromedriver/70.0.3538.97/ 使用selenium 打开和关闭浏览器1234from selenium import webdriverdriver = webdriver.Chrome()driver.get("http://www.iqiyi.com/")driver.quit() 定位搜索框12search_xpath=r"//*[@id='nav_searchboxIn']/input"driver.find_element_by_xpath(search_xpath).send_keys("复仇者联盟") 点击搜索图片12search_button=r"//*[@id='nav_searchboxOut']/span"driver.find_element_by_xpath(search_button).click() 切换tab页123456789101112131415#导入键盘操作--20190528更新from selenium.webdriver.common.keys import Keys#此处通过键盘操作切换tab页driver.find_element_by_tag_name("body").send_keys(Keys.CONTROL + "t")#all_handles 保存所有已经打开的tab窗体all_handles = driver.window_handlesprint(driver.window_handles)index_handle=driver.current_window_handleprint(index_handle)#用switch_to方法切换到tab窗体for handle in all_handles: if handle!=index_handle: print('now is search window') search_handle = handledriver.switch_to.window(search_handle) 打印页面的title，并截图12print(driver.title)driver.get_screenshot_as_file("aqiyi.png") 总结本文主要介绍了自动化工具selenium的基本使用，如何对页面元素进行基本操作，实现自动抓取关键字图片功能。]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>web test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[copy maven dependencies to a folder]]></title>
    <url>%2F2016%2F09%2F30%2Fcopy-maven-dependencies-to-a-folder%2F</url>
    <content type="text"><![CDATA[copy maven dependencies to a folderbackground一个简单的需求,当你的同事需要调试代码的时候,他并不想建立maven环境,这时候依赖的jar包 该如何导出呢? no code say nothing这时候你需要的是maven-dependency-plugin。 添加依赖配置123456789101112131415161718192021222324252627282930313233&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.m2e&lt;/groupId&gt; &lt;artifactId&gt;lifecycle-mapping&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;configuration&gt; &lt;lifecycleMappingMetadata&gt; &lt;pluginExecutions&gt; &lt;!-- copy-dependency plugin --&gt; &lt;pluginExecution&gt; &lt;pluginExecutionFilter&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;versionRange&gt;[1.0.0,)&lt;/versionRange&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/alternateLocation&lt;/outputDirectory&gt; &lt;overWriteReleases&gt;false&lt;/overWriteReleases&gt; &lt;overWriteSnapshots&gt;false&lt;/overWriteSnapshots&gt; &lt;overWriteIfNewer&gt;true&lt;/overWriteIfNewer&gt; &lt;/configuration&gt; &lt;/pluginExecutionFilter&gt; &lt;action&gt; &lt;ignore /&gt; &lt;/action&gt; &lt;/pluginExecution&gt; &lt;/pluginExecutions&gt; &lt;/lifecycleMappingMetadata&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; 此处的&lt;outputDirectory&gt; 指定了你导出jar包的路径. 执行命令 mvn dependency:copy-dependencies查看项目多了一个/alternateLocation目录,并且依赖的jar包都下载到这个目录下了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how to use nginx on windows]]></title>
    <url>%2F2016%2F09%2F27%2Fhow-to-use-nginx-on-windows%2F</url>
    <content type="text"><![CDATA[how to use nginx on windows1. Download nginx lastest release from here.2. unzip to your local driver. eg: c:/apps/nginx3. start nginx12cd c:/apps/nginxstart nginx 4. monitoring nginx process12345tasklist /fi &quot;imagename eq nginx.exe&quot;Image Name PID Session Name Session# Mem Usage========================= ======== ================ =========== ============nginx.exe 11700 Console 1 10,696 Knginx.exe 1160 Console 1 11,180 K notice一个是主进程(main process),另一个是工作进程(work process).如果启动失败,请查看错误日志logs\error.log 5. visit http://localhost:80806. configuration file nginx.confreference config123456789101112131415161718error_log logs/error.log;http &#123; include mime.types; default_type application/octet-stream; server &#123; listen 8080; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; ...&#125; 7. the command list of nginx：1234nginx -s stop 快速退出nginx -s quit 优雅退出nginx -s reload 更换配置，启动新的工作进程，优雅的关闭以往的工作进程nginx -s reopen 重新打开日志文件]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how git changing author info]]></title>
    <url>%2F2016%2F09%2F22%2Fhow-git-changing-author-info%2F</url>
    <content type="text"><![CDATA[how git changing author info背景 gitlab中的统计视图是根据用户的信息统计工作量 迁移git repo中经常会遇到用户和邮箱不一致的情况 解决思路那么如何修改已经推送到远程的author信息呢? github 官方提供的建议如何变更用户信息 同时也有类似的项托管在github上，git-tips-blame-someone-else 思路基本一致,就是替换提交记录、分支、标签里的author信息。 方案1.打开终端或命令行(git bash)2.创建一个你项目的全新裸库12git clone --bare https://github.com/user/repo.gitcd repo.git 3.复制粘贴脚本,并根据你的信息修改下面的变量:123OLD_EMAILCORRECT_NAMECORRECT_EMAIL 脚本replace.sh12345678910111213141516171819#!/bin/shgit filter-branch --env-filter &apos;OLD_EMAIL=&quot;your-old-email@example.com&quot;CORRECT_NAME=&quot;Your Correct Name&quot;CORRECT_EMAIL=&quot;your-correct-email@example.com&quot;if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot; export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;fiif [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot; export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;fi&apos; --tag-name-filter cat -- --branches --tags 4.执行这个脚本sh replace.sh 5.察看Git历史有没有错误git log 6.强制推送到远程git push --force --tags origin &#39;refs/heads/*&#39; 7.清除repo.git仓库12cd ..rm -rf repo.git]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how to understand git detached HEAD]]></title>
    <url>%2F2016%2F08%2F08%2Fhow-to-understand-git-detached-HEAD%2F</url>
    <content type="text"><![CDATA[场景远程有一个develop分支，我想获取到本地,但是clone该项目的时候这个远程分支还没有创建,于是执行 git checkout commit_id(develop) 提示如下 1234567891011121314$ git checkout f7c774bChecking out files: 100% (357/357), done.Note: checking out &apos;f7c774b&apos;.You are in &apos;detached HEAD&apos; state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example: git checkout -b new_branch_nameHEAD is now at f7c774b... update jeffsui.github.io 出现 detached from ...此时用git branch -av察看分支1234567$ git branch -av* (detached from f7c774b) f7c774b update jeffsui.github.io master 6ce1857 Site updated: 2016-08-07 22:09:10 remotes/origin/HEAD -&gt; origin/master remotes/origin/develop f7c774b update jeffsui.github.io remotes/origin/gh-pages 1eee93f Site updated: 2016-02-13 21:03:46 remotes/origin/master 6ce1857 Site updated: 2016-08-07 22:09:10 所谓的 detached HEAD 其实就是HEAD指向的是一个commit而不指向任何一个branch的临时分支,翻译过来就是游离. 众所周知,每一个分支都对应了一个commit,git checkout其实就是修改HEAD文件内容,让它指向不同的分支. 如何让detached HEAD所处分支指向远程分支此时的分支你可以执行commit操作,但是无法push到远程分支。那么我们如何把游离状态的分支指向我们指定的远程分支呢。123$ git fetch origin develop:developFrom https://github.com/jeffsui/jeffsui.github.io * [new branch] develop -&gt; develop 继续执行git branch -av 命令查看分支 12345678$ git branch -av* (detached from f7c774b) f7c774b update jeffsui.github.io develop f7c774b update jeffsui.github.io master 6ce1857 Site updated: 2016-08-07 22:09:10 remotes/origin/HEAD -&gt; origin/master remotes/origin/develop f7c774b update jeffsui.github.io remotes/origin/gh-pages 1eee93f Site updated: 2016-02-13 21:03:46 remotes/origin/master 6ce1857 Site updated: 2016-08-07 22:09:10 此时我们发现多了一个develop分支指向了远程develop 分支，这样我们就可以通过命令git push origin develop:develop到远程分支了。 更简洁的方法git fetch origin develop:develop or git checkount -b origin develop:develop 这样可以直接获取远程分支并创建一个本地分支。]]></content>
      <tags>
        <tag>git</tag>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my-angle]]></title>
    <url>%2F2016%2F02%2F15%2Fmy-angle%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>photo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows-mongodb-install]]></title>
    <url>%2F2016%2F02%2F13%2Fwindows-mongodb-install%2F</url>
    <content type="text"><![CDATA[#windows下mongodb安装 ##下载mongodb http://www.mongodb.org/downloads ##选择自定义安装 本机路径为:d:\tools\mongodb ##建立如下文件目录数据库路径:d:\tools\mongodb\db日志路径:d:\tools\mongodb\log配置文件目录d:\tools\mongodb\etc建立配置文件d:\tools\mongodb\etc\mongodb.conf 123456dbpath=d:\tools\mongodb\db #数据库路径logpath=d:\tools\mongodb\log\mongodb.log #日志输出文件路径logappend=true #错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件journal=true #启用日志文件，默认启用quiet=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falseport=27017 #端口号 默认为27017 ##启动服务 切换到d:\tools\mongodb\bin 目录下: 普通启动 mongod --config d:\tools\mongodb\etc\mongodb.conf 注册为windows服务 mongod --config d:\tools\mongodb\etc\mongodb.conf --install 补充 windows服务卸载 mongod --remove --serviceName &quot;MongoDB&quot; 启动服务net start mongodb 启动成功后,通过浏览器访问 http://localhost:27017 ,看到下面的文字,证明启动服务成功！ It looks like you are trying to access MongoDB over HTTP on the native driver port. 关闭服务net stop mongodb #图形化工具 官方提供的很全:https://docs.mongodb.org/ecosystem/tools/administration-interfaces/ mongo express –Nodejs MongoBooster UMongo MongoHub MongoVUE –.NET]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven3-jdk1.7-problem-fixed]]></title>
    <url>%2F2016%2F02%2F13%2Fmaven3-jdk1-7-problem-fixed%2F</url>
    <content type="text"><![CDATA[#maven3下jdk1.7编译错误解决 #环境12345678Apache Maven 3.3.3 (7994120775791599e205a5524ec3e0dfe41d4a06; 2015-04-22T19:57:37+08:00)Maven home: d:\tools\apache-maven-3.3.3Java version: 1.7.0_45, vendor: Oracle CorporationJava home: c:\Program Files\Java\jdk1.7.0_45\jreDefault locale: zh_CN, platform encoding: GBKOS name: &quot;windows 7&quot;, version: &quot;6.1&quot;, arch: &quot;amd64&quot;, family: &quot;windows&quot; #使用maven命令行创建java项目1mvn archetype:generate -DgroupId=org.linfeng -DartifactId=mavendemo -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false 创建成功 12$ cd mavendemo &amp;&amp; lspom.xml src pom.xml 123456789101112131415161718&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.linfeng&lt;/groupId&gt; &lt;artifactId&gt;mavendemo&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;mavendemo&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 执行maven命令 mvn test 错误信息 12[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project mavendemo: Compilation failure[ERROR] No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK? #解决方案 修改settings.xml,添加jdk1.7相关内容 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.7&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 缺点:修改所有项目的jre环境 修改当前项目的pom.xml 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 重新执行mvn build 成功！ #问题分析Maven官方文档有如下描述： 编译器插件用来编译项目的源文件.从3.0版本开始, 用来编译Java源文件的默认编译器是javax.tools.JavaCompiler (如果你是用的是java 1.6) . 如果你想强制性的让插件使用javac,你必须配置插件选项 forceJavacCompilerUse.同时需要注意的是目前source选项和target 选项的默认设置都是1.5, 与运行Maven时的JDK版本无关.如果你想要改变这些默认设置, 可以参考 Setting the -source and -target of the Java Compiler中的描述来设置 source 和target 选项. #参考资料 http://stackoverflow.com/questions/15220392/maven-package-compilation-error http://www.cnblogs.com/leo100w/p/4017647.html]]></content>
      <categories>
        <category>ci</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>jdk</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how make cygwin multi-color]]></title>
    <url>%2F2015%2F08%2F12%2Fhow-make-cygwin-multi-color%2F</url>
    <content type="text"><![CDATA[打开.bashrc 123456789101112131415161718# Default to human readable figures# alias df=&apos;df -h&apos;# alias du=&apos;du -h&apos;## Misc # alias less=&apos;less -r&apos; # raw control characters# alias whence=&apos;type -a&apos; # where, of a sort# alias grep=&apos;grep --color&apos; # show differences in colour# alias egrep=&apos;egrep --color=auto&apos; # show differences in colour# alias fgrep=&apos;fgrep --color=auto&apos; # show differences in colour## Some shortcuts for different directory listings# alias ls=&apos;ls -hF --color=tty&apos; # classify files in colour# alias dir=&apos;ls --color=auto --format=vertical&apos;# alias vdir=&apos;ls --color=auto --format=long&apos;# alias ll=&apos;ls -l&apos; # long list# alias la=&apos;ls -A&apos; # all but . and ..# alias l=&apos;ls -CF&apos; # 而我们要做的只是去掉#，启动即可： 123456789101112131415161718# Default to human readable figuresalias df=&apos;df -h&apos;alias du=&apos;du -h&apos;## Misc alias less=&apos;less -r&apos; # raw control charactersalias whence=&apos;type -a&apos; # where, of a sortalias grep=&apos;grep --color&apos; # show differences in colouralias egrep=&apos;egrep --color=auto&apos; # show differences in colouralias fgrep=&apos;fgrep --color=auto&apos; # show differences in colour## Some shortcuts for different directory listingsalias ls=&apos;ls -hF --color=tty&apos; # classify files in colouralias dir=&apos;ls --color=auto --format=vertical&apos;alias vdir=&apos;ls --color=auto --format=long&apos;alias ll=&apos;ls -l&apos; # long listalias la=&apos;ls -A&apos; # all but . and ..alias l=&apos;ls -CF&apos; # 然后保存一下，再重启cygwin（或者直接用：source ~/.bashrc]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>cygwin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how to build a private docker registry]]></title>
    <url>%2F2015%2F07%2F21%2Fhow-to-build-a-private-docker-registry%2F</url>
    <content type="text"><![CDATA[如何搭建docker私服##环境准备 软件包： centos6.5_x86_64 docker-engine-1.7.0-1.el6.x86_64.rpm docker环境搭建,请参照官方说明，本文采用的是官方的rpm包 ##何谓私服 官方的image镜像站位dockerhub,因为伟大的墙的缘故,所以下载镜像是很痛苦的一件事。当然你可以采用其他科学上网或者镜像加速的方法来获取image。docker官方也提供了一个私服镜像,大家可以通过docker search registry来查找该镜像。 12345NAME DESCRIPTION STARS OFFICIAL AUTOMATEDregistry Containerized docker registry 320 [OK] atcol/docker-registry-ui A web UI for easy private/local Docker Reg... 55 [OK]konradkleine/docker-registry-frontend Browse and modify your Docker registry in ... 40 [OK]samalba/docker-registry 35 ##下载官方registry镜像 下载镜像 使用命令docker pull registry执行下载镜像。 查看镜像 下载完毕后,通过docker images 查看该镜像。 给镜像打标签 执行这个命令docker tag registry:latest localhost:5000/registry:latest ##启动镜像 docker run -d -e SETTINGS_FLAVOR=dev -e STORAGE_PATH=/tmp/registry -v /opt/data/registry:/tmp/registry -p 5000:5000 registry 这里有几个参数说明下: 1.-e STORAGE_PATH=/tmp/registry :强制使用存储路径 2.-v /opt/data/registry:/tmp/registry :绑定本地镜像存储路径 3.-p 5000:5000:映射容器5000端口到本地5000端口 ##查看镜像状态 docker ps ##查看私服状态 curl http://localhost:5000 显示如下信息,证明registry启动成功: &quot;\&quot;docker-registry server\&quot;&quot; ##推送本地镜像库到registry私服 ###1. 第一步 给本地镜像 打tag例如给官方的nginx镜像打tag,执行下面的命令行docker pull nginxdocker tag nginx:latest localhost:5000/nginx:latest查看镜像库,发现localhost:5000/nginx的镜像已经有了。 ###2. 第二步 推送tag到registry私服 docker push localhost:5000/nginx:latest ###3. 第三步 查看私服镜像列表 curl http://localhost：5000/V1/search 看到类似这样的信息 12&#123;&quot;num_results&quot;: 5, &quot;query&quot;: &quot;&quot;, &quot;results&quot;: [&#123;&quot;description&quot;: null, &quot;name&quot;: &quot;correl/erlang&quot;&#125;, &#123;&quot;description&quot;: null, &quot;name&quot;: &quot;linfeng/cmd&quot;&#125;, &#123;&quot;description&quot;: null, &quot;name&quot;: &quot;library/my_nodejs_image&quot;&#125;, &#123;&quot;description&quot;: null, &quot;name&quot;: &quot;library/centos&quot;&#125;, &#123;&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/nginx&quot;&#125;]&#125; ##拉取私服镜像 docker pull 192.168.20.85:5000/library/centos:7 ##结论 这只是演示如何搭建一个简单的registry私服。因为只有通过命令行方式才能查看私服信息,所以不是很便于操作。下面的博文将演示如何给registry添加web界面。]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>registry</tag>
        <tag>registry-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how git version rollback]]></title>
    <url>%2F2015%2F05%2F16%2Fhow-git-version-rollback%2F</url>
    <content type="text"><![CDATA[如何进行远程版本回退…… #引言 一切都要从一个蛋疼的需求开始,老板说,能给远程仓库的版本回退吗？我说为毛？他说我就是试试看git好使不,我…… #咋搞 背景 gitcafe 国内知名的源码托管平台 分析 12345678910111213141、git checkout the_branch2、git pull3、git branch the_branch_backup //备份一下这个分支当前的情况4、git reset --hard the_commit_id //把the_branch本地回滚到the_commit_id5、git push origin :the_branch //删除远程 the_branch6、git push origin the_branch //用回滚后的本地分支重新建立远程分支7、git push origin :the_branch_backup //如果前面都成功了，删除这个备份分支 删除远程分支 首先,任何一个git源码托管平台都会告诉你,别删除远程master分支,因为它是默认的分支……,请移步这里 操作步骤 如果远程只有一个master分支,请你创建一个非master分支,然后推送到远程。有人会问我为什么？打个比方,你见过上旱厕的时候,给自己脚下站着的板子抽走吗？ 脚本类似下面这样 1234git branch the_master_backupgit push origin the_master_backup 此时你查看远程分支应该有两个:master和the_master_backup 设置默认的分支为 the_master_backup 1234git branch -D branch_name //删除本地master分支git push :master //推送一个空分支,相当于删除远程master分支 然后你在the_master_backup分支上 回滚到你要回滚的commit_id,然后重建master分支并推送到远程,顺便删除the_master_backup分支(包括远程the_master_backup分支)。 123456789101112git checkout the_master_backupgit reset --hard commit_idgit branch master //重新创建master分支git push origin master //重新推送master分支git branch -D the_master_backup //删除本地the_master_backup分支git push origin :the_master_backup//删除远程the_master_backup分支 #遇到的问题 忘记设置默认分支为非master分支 1234567891011121314remote: error: By default, deleting the current branch is denied, because the nextremote: error: &apos;git clone&apos; won&apos;t result in any file checked out, causing confusion.remote: error:remote: error: You can set &apos;receive.denyDeleteCurrent&apos; configuration variable toremote: error: &apos;warn&apos; or &apos;ignore&apos; in the remote repository to allow deleting theremote: error: current branch, with or without a warning message.remote: error:remote: error: To squelch this message, you can set it to &apos;refuse&apos;.... #总结 如果你遇到的是所有提交只有master分支,那么希望我这个博文能帮到你。当然git强大的分支功能你基本也用不到了。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitcafe</tag>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript oop 15 min programming]]></title>
    <url>%2F2015%2F04%2F23%2Fjavascript-oop-15-min-programming%2F</url>
    <content type="text"><![CDATA[#javascript的面向对象15分钟教程 第一种面向对象的写法##创建空对象 12var bill =&#123;&#125;;//创建一个空对象 ##给对象添加属性和方法 12345bill.name = &quot;Bill Goat&quot;;bill.work = function ()&#123; console.log(&quot;programming....&quot;);&#125;; ##一步完成上面的两件事 1234567var bill =&#123; name : &quot;Bill Goat&quot;; work : function()&#123; console.log(&quot;programming....&quot;);&#125;&#125;; ##访问对象和属性 123console.log(bill.name);bill.work(); ##方法重写 12345bill.name = &quot;Bill Goat&quot;;bill.work =function(who)&#123; console.log(&quot;programming for &quot;+who);&#125;; ##通过this关键字访问内部属性 1234bill.say = function ()&#123; console.log(&quot;bill&apos;s name is&quot;+this.name);&#125;; ##对象引用123456var silly = bill;console.log(silly.name);sally.name = &quot;Silly&quot;;console.log(silly.name);console.log(bill.name); ##另一个方式引用1234567bill.name = &quot;Bill Goat&quot;;bill.say();var sayName = bill.say();sayName;sayName(); ##有意思的地方 ：全局属性123var name = &quot;Global&quot;;bill.say(); 发现此时输出的是bill&#39;s name is Global 另一种面向对象的写法##定义对象及属性 12function Game()&#123;&#125;; ##创建对象 1var DF = new Game(); ##对象属性 1DF.title = &quot;星际争霸2&quot;; ##构造方法 12345678function Game (title)&#123; this.title = typeof title !== &apos;undifined&apos; ? title :&quot;&quot;;&#125;;var d3 = new Game(&quot;d3&quot;);d3.title;d3.title =&quot;starcraft2&quot;; this.title = typeof title !== &#39;undifined&#39; ? title :&quot;&quot;;相当于 123456if(typeof title !== &quot;undifined&quot;）&#123; this.title = title;&#125;else&#123; this.title = &quot;&quot;;&#125; ##创建一个方法来访问这个属性1234d3.loveTitle = function ()&#123; console.log(&quot;I love &quot;+this.title);&#125; ##更好的写法 12345Game.prototype.heartIt = function ()&#123; console.log(&quot;I love &quot;+this.title);&#125;d3.heartIt(); 下次详解javascript的原生对象模型 to be continued~~~~]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>oop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[talk about software engineering]]></title>
    <url>%2F2015%2F04%2F22%2Ftalk-about-software-engineering%2F</url>
    <content type="text"><![CDATA[#关于软件工程的讨论–质量篇 那为什么软件系统的质量不容易高呢？我觉得主要原因是流程不完善。那为什么不完善？需求容易变。为什么容易变？是因为不论程序员自己，还是需求方，其实潜意识都认为自己做的东西是变更成本较低的。 试想一下，为什么没人在盖高楼盖一半变更需求？为什么没人修大桥修一半变更需求？甚至做衣服做一半的时候变更需求，理发到一半变更需求，都会被人认为是不讲理。但是在软件领域，好像这倒成了普遍现象。 因为整个软件系统的实现，都是虚拟的，看不见摸不着，并不消耗什么物料，所以从这个角度想，变起来当然是容易的。但软件系统的架构，其实也跟实体的没本质区别，变更时候要考虑很多关联因素，并不是就那么孤立的看一小块地方，当然，也会有一些不影响全局的变更。打个比方说，如果你在盖房子盖到一半，那变更外墙颜色肯定是要比变更窗户大小容易的。要是想变得太多，估计只好拆了重来。 下面的讨论更加精彩: A:其实不是流程问题，老板和甲方问题 A:甲方尤其关键 A:尼玛，要8层楼房，付2层费用 ……]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript asynchronous programming learning :event]]></title>
    <url>%2F2015%2F04%2F20%2Fjavascript-asynchronous-programming-learning-event%2F</url>
    <content type="text"><![CDATA[#javascript异步编程读书笔记之事件机制 ##事件的调度 异步执行 setTimeout函数的解释:给定一个回调及n毫秒的延迟,setTimeout会在n毫秒后运行该回调。 代码清单1:12345for (var i = 1; i &lt;= 3; i++) &#123; setTimeout(function()&#123; console.log(i); &#125;, 0);&#125;; 输出结果: 123444 线程阻塞代码清单2: 123456var start = new Date;setTimeout(function()&#123;var end = new Date;console.log(&apos;Time elapsed:&apos;, end - start, &apos;ms&apos;);&#125;, 500);while (new Date - start &lt; 1000) &#123;&#125;; 队列 javascript使用队列的方式来循环处理请求,这种机制被称为事件循环。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[use-shorturl and two-dimensional-barcodes to beautify blog]]></title>
    <url>%2F2015%2F04%2F20%2Fuse-shorturl-and-two-dimensional-barcodes-to-beautify-blog%2F</url>
    <content type="text"><![CDATA[#如何使用短网址和二维码简化网站访问 短网址(shorturl) web2.0时代的潮流,借助短网址您可以用简短的网址替代原来冗长的网址，让使用者可以更容易的分享链接。这里我使用的是百度的短网址服务:http://dwz.cn/ 访问http://dwz.cn/主页 输入你的博客地址我输入http://jeffsui.github.io/pinghailinfeng_blog/ 复制短网址 二维码(two-dimensional-barcodes)微信时代,不知道二维码的基本都属于外星球人了。这里我选择的是草料二维码:http://cli.im/ 输入二维码地址 进行一些基本设置包括前景色、背景色、渐变色等等。 嵌入图片 选用你喜欢的模板 保存二维码 在线存储这里我选择国内知名的七牛云存储。 4.在博客中引用图片地址就可以了]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>美化</tag>
        <tag>短网址</tag>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的新文章]]></title>
    <url>%2F2015%2F04%2F17%2Fmy-new-post%2F</url>
    <content type="text"><![CDATA[#我的新文章 这是我的第一篇在github上的博客。记录下我的工作和生活,慢慢给其他的文章都更新到这里。嬉笑怒骂也好,喜怒哀乐也罢,我就是一个俗人罢了。]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>博客</tag>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[push-hexo-to-github]]></title>
    <url>%2F2015%2F04%2F17%2Fpush-hexo-to-github%2F</url>
    <content type="text"><![CDATA[#如何使用hexo在github上建立静态博客 ##环境搭建 hexo环境搭建 请参考 hexo.io 官方站点, 强烈建议给基本操作下的内容快速浏览一遍,下面的操作是我一个一个命令敲出来的,遇到的坑也会记录下来,希望大家能少走弯路。 github上建立静态博客 github账号申请（略） 建立一个github项目 git clone 项目地址 到本地 项目初始化cd 项目名echo # hexo 实例站点 &gt;&gt; README.mdgit initgit add README.mdgit commit -m “first blood”git remote add origin 项目地址git push -u origin master github免费站点建立规则,请仔细阅读这个规则https://help.github.com/articles/user-organization-and-project-pages/ 默认github域名 默认github 分配了 一个name.github.io的域名,还有一个name.github.io/project_name的二级域名,请参照github的提示设置URL。 华丽的分割线 站点配置流程 建立站点文件夹,并站点初始化 安装hexo依赖 修改node_module/hexo-server/index.js,用于本地调试 安装hexo-git-deployer插件 修改全局配置文件_config.yml,配置deploy# Site 站点配置title: 凭海临风的测试江湖subtitle:description: 凭海临风的博客author: Jeff Suilanguage: zh-CNtimezone # URL 站点链接## If your site is put in a subdirectory, set url as ‘http://yoursite.com/child&#39; and root as ‘/child/‘url: http://jeffsui.github.ioroot: /pinghailinfeng_blog/permalink: :year/:month/:day/:title/permalink_defaults: # Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy:type: gitrepo: https://github.com/jeffsui/pinghailinfeng_blog.gitbranch : mastermessage : 以上配置仅供参考 创建文章 执行hexo new 命令 例如:hexo new post my-first-blog 将会自动在source/_posts下创建一个my-first-blog.md的文件,使用的是scaffolds下的post.md模板 修改并保存my-first-blog.md文件 站点生成hexo g 站点部署 hexo d 如果没有报错,恭喜你已经成功推送到 项目的master分支。 创建gh-pages分支并推送到远程 git fetch origin master git checkout gh-pages git merge master git push origin gh-pages 访问http://jeffsui.github.io/pinghailinfeng_blog/ ##遇到的问题 github站点的规则不熟悉,url配置浪费我2个小时。项目建立的是二级域名,所以必须要按照我说的那样配置。 本地预览有可能不加载样式,重新删除node_module下所有,执行npm install,再hexo g,hexo server -i 127.0.0.1 -s -o即可。 hexo3.0版本的git插件必须要独立安装。 其他坑,自己填吧。 ##总结 大坑各种有,github特别多,还有伟大的墙,兄弟们,github好上,填坑需谨慎！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>搭建</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime run slow problem]]></title>
    <url>%2F2015%2F04%2F17%2Fsublime-run-slow-problem%2F</url>
    <content type="text"><![CDATA[#解决sublime Text2运行缓慢的方法 今天打开sublime想写博客发现整个页面打开很慢,切换tab要等好几秒。发现了一个帖子,说GitGutter这个插件在st2下会影响切换tab速度。 于是 ctrl+shift+p调出命令,remove package,选择GitGutter,回车。重启sublime,世界都变得清静了。]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>sublime</tag>
        <tag>GitGutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first-blog]]></title>
    <url>%2F2015%2F04%2F17%2Ffirst-blog%2F</url>
    <content type="text"><![CDATA[#第一个博客 ##记录使用hexo的各种填坑。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
</search>
