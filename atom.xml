<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凭海临风的IT江湖</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pinghailinfeng.gitee.io/"/>
  <updated>2020-12-26T21:49:45.337Z</updated>
  <id>https://pinghailinfeng.gitee.io/</id>
  
  <author>
    <name>Jeff Sui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>node14.4 run hexo TypeError [ERR_INVALID_ARG_TYPE]</title>
    <link href="https://pinghailinfeng.gitee.io/2020/12/27/node14-4-run-hexo-TypeError-ERR-INVALID-ARG-TYPE/"/>
    <id>https://pinghailinfeng.gitee.io/2020/12/27/node14-4-run-hexo-TypeError-ERR-INVALID-ARG-TYPE/</id>
    <published>2020-12-26T21:35:28.000Z</published>
    <updated>2020-12-26T21:49:45.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node升级到14-4-hexo-运行失败"><a href="#Node升级到14-4-hexo-运行失败" class="headerlink" title="Node升级到14.4 hexo 运行失败"></a>Node升级到14.4 hexo 运行失败</h1><p><img src="https://www.prajwaldesai.com/wp-content/uploads/2014/01/error-code.jpeg" alt></p><a id="more"></a><p>node刚升级到14.4,结果发现使用<code>hexo d</code>命令部署到<code>gitee</code>上发现如下错误</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; typeError [ERR_INVALID_ARG_TYPE]: The <span class="string">"mode"</span> argument must be <span class="built_in">integer</span>. Received an instance of Object</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>查阅相关资料发现是node版本太高导致,最终将node降级到12.14.0后,重新部署就成功了。</p><p>当然你也可以使用nvm来切换node版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Node升级到14-4-hexo-运行失败&quot;&gt;&lt;a href=&quot;#Node升级到14-4-hexo-运行失败&quot; class=&quot;headerlink&quot; title=&quot;Node升级到14.4 hexo 运行失败&quot;&gt;&lt;/a&gt;Node升级到14.4 hexo 运行失败&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://www.prajwaldesai.com/wp-content/uploads/2014/01/error-code.jpeg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://pinghailinfeng.gitee.io/categories/hexo/"/>
    
      <category term="博客搭建" scheme="https://pinghailinfeng.gitee.io/categories/hexo/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="hexo" scheme="https://pinghailinfeng.gitee.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Farewell, 2020</title>
    <link href="https://pinghailinfeng.gitee.io/2020/12/26/Farewell-2020/"/>
    <id>https://pinghailinfeng.gitee.io/2020/12/26/Farewell-2020/</id>
    <published>2020-12-26T08:22:08.000Z</published>
    <updated>2020-12-26T08:50:08.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Farewell-2020"><a href="#Farewell-2020" class="headerlink" title="Farewell, 2020"></a>Farewell, 2020</h1><p><img src="https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/7acb0a46f21fbe09cd42640566600c338744ad87.jpg" alt></p><a id="more"></a><p>2020年还有不到五天就要过去了,时光如梭,这一年一眨眼就过去了。</p><p>大连又一次迎来了第三次新冠疫情,大街上冷冷清清。商场里也没有往日的喧闹。这个城市又一次变得安静了下来。</p><p>2020年,大家说得最多的一个字就是”难”。大家好不容易挺过来,来势汹汹的疫情打乱了节奏。很多人心情跌落谷底。</p><p>昨天回到家,媳妇说孩子网课表现很优秀,一边跟着老师听讲,一边和老师互动,还知道静音,非常投入，孩子这是长大了。我心里却不是滋味,和去年疫情相比,网课一天不上,天天就是看平板电脑形成了强烈的反差。孩子不是长大了,是社会让她不得不遵守规则。</p><p>学生问我,你白天上课,晚上还上晚课,收入一定很高,我笑了笑说,还可以吧,他接着又问,你肯定是学校股东,要不谁能这么拼命。我回答,成年人的世界里哪有什么不容易。师生相视一笑。大家都明白,个中滋味自己体会吧。</p><p>疫情让我们明白一些道理,什么都没有活着和生存更重要。只要活着,就有希望。</p><p>2020让我们体会到生命的伟大,致敬那些工作在一线的医护工作者们,他们是最美的逆行者。</p><p>致敬那些为了后勤保障,辛勤工作的各行各业的人们,他们社会能正常运转。</p><p>为人父,为人母,体会到了父母的艰辛。</p><p>就像奥特曼经常说的一样,相信光，会守护世界。每个人心中都有奥特曼。我也会守护我的家人,守护我身边的一切。</p><p>希望在新的一年,一切都会变好。</p><p>祝愿大家都身体健康,因为有光,就有希望。</p><p>未来可期,再见2020!</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Farewell-2020&quot;&gt;&lt;a href=&quot;#Farewell-2020&quot; class=&quot;headerlink&quot; title=&quot;Farewell, 2020&quot;&gt;&lt;/a&gt;Farewell, 2020&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/7acb0a46f21fbe09cd42640566600c338744ad87.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://pinghailinfeng.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="2020" scheme="https://pinghailinfeng.gitee.io/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>how to export django project dependency</title>
    <link href="https://pinghailinfeng.gitee.io/2020/09/15/how-to-export-django-project-dependency/"/>
    <id>https://pinghailinfeng.gitee.io/2020/09/15/how-to-export-django-project-dependency/</id>
    <published>2020-09-15T01:19:55.000Z</published>
    <updated>2020-09-15T01:57:36.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何导出django项目依赖第三方库"><a href="#如何导出django项目依赖第三方库" class="headerlink" title="如何导出django项目依赖第三方库"></a>如何导出<code>django</code>项目依赖第三方库</h1><p><img src="https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=f979fd647b8da9774e7a8e2d8061d421/d000baa1cd11728bf4f9b275c0fcc3cec2fd2c94.jpg" alt></p><a id="more"></a><h2 id="使用pip-freeze-导出"><a href="#使用pip-freeze-导出" class="headerlink" title="使用pip freeze 导出"></a>使用<code>pip freeze</code> 导出</h2><p>针对大部分使用<code>virtualenv</code> 或<code>venv</code>，<code>pipenv</code> 虚拟环境的项目而言,导出第三方依赖很容易,运行下面的命令即可</p><p><code>pip freeze &gt; requirements.txt</code></p><h2 id="非虚拟环境如何导出项目依赖"><a href="#非虚拟环境如何导出项目依赖" class="headerlink" title="非虚拟环境如何导出项目依赖"></a>非虚拟环境如何导出项目依赖</h2><h3 id="安装-pipreqs库"><a href="#安装-pipreqs库" class="headerlink" title="安装 pipreqs库"></a>安装 <code>pipreqs</code>库</h3><p><code>pip install pipreqs</code></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>进入项目根目录,使用下面的指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipreqs ./</span><br></pre></td></tr></table></figure><h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">D:\code\django_blog\mysite&gt;pipreqs ./</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "c:\python38\lib\runpy.py", line 194, in _run_module_as_main</span><br><span class="line">    return _run_code(code, main_globals, None,</span><br><span class="line">  File "c:\python38\lib\runpy.py", line 87, in _run_code</span><br><span class="line">    exec(code, run_globals)</span><br><span class="line">  File "C:\Python38\Scripts\pipreqs.exe\__main__.py", line 9, in &lt;module&gt;</span><br><span class="line">  File "c:\python38\lib\site-packages\pipreqs\pipreqs.py", line 470, in main</span><br><span class="line">    init(args)</span><br><span class="line">  File "c:\python38\lib\site-packages\pipreqs\pipreqs.py", line 406, in init</span><br><span class="line">    candidates = get_all_imports(input_path,</span><br><span class="line">  File "c:\python38\lib\site-packages\pipreqs\pipreqs.py", line 122, in get_all_imports</span><br><span class="line">    contents = f.read()</span><br><span class="line">UnicodeDecodeError: 'gbk' codec can't decode byte 0xae in position 403: illegal multibyte sequence</span><br></pre></td></tr></table></figure><h3 id="添加命令行参数-encoding-utf-8"><a href="#添加命令行参数-encoding-utf-8" class="headerlink" title="添加命令行参数 encoding=utf-8"></a>添加命令行参数 <code>encoding=utf-8</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipreqs ./ --encoding=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何导出django项目依赖第三方库&quot;&gt;&lt;a href=&quot;#如何导出django项目依赖第三方库&quot; class=&quot;headerlink&quot; title=&quot;如何导出django项目依赖第三方库&quot;&gt;&lt;/a&gt;如何导出&lt;code&gt;django&lt;/code&gt;项目依赖第三方库&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=f979fd647b8da9774e7a8e2d8061d421/d000baa1cd11728bf4f9b275c0fcc3cec2fd2c94.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="django" scheme="https://pinghailinfeng.gitee.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>make django3.1 backend markdown support</title>
    <link href="https://pinghailinfeng.gitee.io/2020/09/14/make_django3.1_backend_markdown_support/"/>
    <id>https://pinghailinfeng.gitee.io/2020/09/14/make_django3.1_backend_markdown_support/</id>
    <published>2020-09-14T08:57:20.000Z</published>
    <updated>2020-09-15T01:58:08.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="django3-1-后台添加markdown支持"><a href="#django3-1-后台添加markdown支持" class="headerlink" title="django3.1 后台添加markdown支持"></a>django3.1 后台添加markdown支持</h1><p><img src="https://media.vanityfair.com/photos/54caaa85b8f23e3a0314d5ae/master/w_768,c_limit/image.png" alt></p><a id="more"></a><h2 id="首先安装-django-mdeditor"><a href="#首先安装-django-mdeditor" class="headerlink" title="首先安装 django-mdeditor"></a>首先安装 <code>django-mdeditor</code></h2><p><code>python pip install django-mdeditor</code></p><h2 id="settings-py-中添加"><a href="#settings-py-中添加" class="headerlink" title="settings.py 中添加"></a>settings.py 中添加</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="string">'blog'</span>,</span><br><span class="line">    <span class="string">'mdeditor'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment"># add uploads文件夹</span></span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">'uploads'</span>)  <span class="comment">#uploads必须存在，且在项目目录下</span></span><br><span class="line">MEDIA_URL = <span class="string">'/media/'</span></span><br></pre></td></tr></table></figure><h2 id="添加站点路由-mysite-urls-py"><a href="#添加站点路由-mysite-urls-py" class="headerlink" title="添加站点路由 mysite/urls.py"></a>添加站点路由 <code>mysite/urls.py</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"><span class="keyword">from</span> django.conf.urls.static <span class="keyword">import</span>  static</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'blog/'</span>, include((<span class="string">'blog.urls'</span>,<span class="string">'blog'</span>),namespace=<span class="string">'blog'</span>)),</span><br><span class="line">    path(<span class="string">'mdeditor/'</span>,include(<span class="string">'mdeditor.urls'</span>)),</span><br><span class="line">]</span><br><span class="line"><span class="keyword">if</span> settings.DEBUG:</span><br><span class="line">    <span class="comment"># static files (images, css, javascript, etc.)</span></span><br><span class="line">    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</span><br></pre></td></tr></table></figure><h2 id="修改blog下models-py中内容类型"><a href="#修改blog下models-py中内容类型" class="headerlink" title="修改blog下models.py中内容类型"></a>修改blog下<code>models.py</code>中内容类型</h2><p><code>导入MDTextField</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> mdeditor.fields <span class="keyword">import</span> MDTextField</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogPost</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length= <span class="number">150</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># body = models.TextField()</span></span><br><span class="line">    body = MDTextField()</span><br><span class="line"></span><br><span class="line">    create_time = models.DateTimeField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"&lt;BlogPost <span class="subst">&#123;self.title&#125;</span>&gt;"</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name =<span class="string">"文章"</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure></p><h2 id="blog应用views-py"><a href="#blog应用views-py" class="headerlink" title="blog应用views.py"></a>blog应用views.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">details</span><span class="params">(request, blog_id)</span>:</span></span><br><span class="line">    blog = get_object_or_404 (BlogPost, pk=blog_id)</span><br><span class="line">    blog.body = markdown(blog.body, extensions=[</span><br><span class="line">        <span class="comment"># 包含 缩写、表格等常用扩展</span></span><br><span class="line">        <span class="string">'markdown.extensions.extra'</span>,</span><br><span class="line">        <span class="comment"># 语法高亮扩展</span></span><br><span class="line">        <span class="string">'markdown.extensions.codehilite'</span>,</span><br><span class="line">        <span class="comment">#允许我们自动生成目录</span></span><br><span class="line">         <span class="string">'markdown.extensions.toc'</span>,</span><br><span class="line">        ])</span><br><span class="line">    <span class="keyword">return</span> render (request, <span class="string">'blog_detail.html'</span>, &#123;<span class="string">'blog'</span>: blog&#125;)</span><br></pre></td></tr></table></figure><h2 id="前台页面添加markdown-css支持"><a href="#前台页面添加markdown-css支持" class="headerlink" title="前台页面添加markdown css支持"></a>前台页面添加markdown css支持</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.bootcss.com/github-markdown-css/3.0.1/github-markdown.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="前台页面添加-safe渲染"><a href="#前台页面添加-safe渲染" class="headerlink" title="前台页面添加 safe渲染"></a>前台页面添加 safe渲染</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; blog.title &#125;&#125;</span><br><span class="line">&#123;&#123; blog.body | safe &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="重新启动服务"><a href="#重新启动服务" class="headerlink" title="重新启动服务"></a>重新启动服务</h2><p><code>python manage.py runserver 127.0.0.1:8000</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;django3-1-后台添加markdown支持&quot;&gt;&lt;a href=&quot;#django3-1-后台添加markdown支持&quot; class=&quot;headerlink&quot; title=&quot;django3.1 后台添加markdown支持&quot;&gt;&lt;/a&gt;django3.1 后台添加markdown支持&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://media.vanityfair.com/photos/54caaa85b8f23e3a0314d5ae/master/w_768,c_limit/image.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="django" scheme="https://pinghailinfeng.gitee.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>from beginning to setup a typescript develop environment</title>
    <link href="https://pinghailinfeng.gitee.io/2020/04/13/from-beginning-to-setup-a-typescript-develop-environment/"/>
    <id>https://pinghailinfeng.gitee.io/2020/04/13/from-beginning-to-setup-a-typescript-develop-environment/</id>
    <published>2020-04-13T09:22:58.000Z</published>
    <updated>2020-04-13T09:24:58.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从零开始搭建typescript开发环境"><a href="#从零开始搭建typescript开发环境" class="headerlink" title="从零开始搭建typescript开发环境"></a>从零开始搭建typescript开发环境</h1><p><img src="https://pic3.zhimg.com/v2-7ae2e2942fa8ae187a24cae8afe9547e_1200x500.jpg" alt></p><a id="more"></a><h2 id="【背景】"><a href="#【背景】" class="headerlink" title="【背景】"></a>【背景】</h2><p>从零开始搭建一个typescript项目中使用了lite-server 模块,备忘一下</p><h2 id="【解决方案】"><a href="#【解决方案】" class="headerlink" title="【解决方案】"></a>【解决方案】</h2><h3 id="项目下-创建一个-bs-config-json文件"><a href="#项目下-创建一个-bs-config-json文件" class="headerlink" title="项目下 创建一个 bs-config.json文件"></a>项目下 创建一个 <code>bs-config.json</code>文件</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"port"</span> : <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">"files"</span>: [<span class="string">"../dist/**/*.&#123;html,htm,css,js&#125;"</span>],</span><br><span class="line">    <span class="attr">"server"</span>: &#123;<span class="attr">"baseDir"</span> : <span class="string">"./dist"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>port 参数指定端口</li><li>files 指定包含的文件类型</li><li>server 中 baseDir参数指定 静态文件所在目录,根据自己项目目录结构调整</li></ul><h3 id="添加-lite-server-到-package-json-的-script"><a href="#添加-lite-server-到-package-json-的-script" class="headerlink" title="添加 lite-server 到 package.json 的 script"></a>添加 lite-server 到 package.json 的 script</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "start": "lite-server",</span><br><span class="line">    "tsc-build": "tsc -w",</span><br><span class="line">    "tsc-watch": "nodemon dist/hello.js"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="命令行运行"><a href="#命令行运行" class="headerlink" title="命令行运行"></a>命令行运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h2 id="【参考文档】"><a href="#【参考文档】" class="headerlink" title="【参考文档】"></a>【参考文档】</h2><p><a href="https://github.com/johnpapa/lite-server" target="_blank" rel="noopener">lite-server官方github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;从零开始搭建typescript开发环境&quot;&gt;&lt;a href=&quot;#从零开始搭建typescript开发环境&quot; class=&quot;headerlink&quot; title=&quot;从零开始搭建typescript开发环境&quot;&gt;&lt;/a&gt;从零开始搭建typescript开发环境&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7ae2e2942fa8ae187a24cae8afe9547e_1200x500.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="typescript" scheme="https://pinghailinfeng.gitee.io/categories/typescript/"/>
    
      <category term="basic" scheme="https://pinghailinfeng.gitee.io/categories/typescript/basic/"/>
    
    
      <category term="typescript" scheme="https://pinghailinfeng.gitee.io/tags/typescript/"/>
    
      <category term="lite-server" scheme="https://pinghailinfeng.gitee.io/tags/lite-server/"/>
    
  </entry>
  
  <entry>
    <title>using selenium execute JavaScript controll browser scroll</title>
    <link href="https://pinghailinfeng.gitee.io/2020/04/10/using-selenium-execute-JavaScript-controll-browser-scroll/"/>
    <id>https://pinghailinfeng.gitee.io/2020/04/10/using-selenium-execute-JavaScript-controll-browser-scroll/</id>
    <published>2020-04-10T09:18:09.000Z</published>
    <updated>2020-04-16T08:49:48.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="selenium中使用JavaScript控制浏览器"><a href="#selenium中使用JavaScript控制浏览器" class="headerlink" title="selenium中使用JavaScript控制浏览器"></a>selenium中使用JavaScript控制浏览器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移动到元素element对象的“顶端”与当前窗口的“顶部”对齐</span></span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"arguments[0].scrollIntoView();"</span>, element);</span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"arguments[0].scrollIntoView(true);"</span>, element);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//移动到元素element对象的“底端”与当前窗口的“底部”对齐</span></span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"arguments[0].scrollIntoView(false);"</span>, element);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//移动到页面最底部</span></span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"window.scrollTo(0, document.body.scrollHeight)"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//移动到指定的坐标(相对当前的坐标移动)</span></span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"window.scrollBy(0, 700)"</span>);</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//结合上面的scrollBy语句，相当于移动到700+800=1600像素位置</span></span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"window.scrollBy(0, 800)"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//移动到窗口绝对位置坐标，如下移动到纵坐标1600像素位置</span></span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"window.scrollTo(0, 1600)"</span>);</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//结合上面的scrollTo语句，仍然移动到纵坐标1200像素位置</span></span><br><span class="line">((JavascriptExecutor) driver).executeScript(<span class="string">"window.scrollTo(0, 1200)"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;selenium中使用JavaScript控制浏览器&quot;&gt;&lt;a href=&quot;#selenium中使用JavaScript控制浏览器&quot; class=&quot;headerlink&quot; title=&quot;selenium中使用JavaScript控制浏览器&quot;&gt;&lt;/a&gt;selenium
      
    
    </summary>
    
      <category term="selenium" scheme="https://pinghailinfeng.gitee.io/categories/selenium/"/>
    
      <category term="java" scheme="https://pinghailinfeng.gitee.io/categories/selenium/java/"/>
    
    
      <category term="selenium" scheme="https://pinghailinfeng.gitee.io/tags/selenium/"/>
    
      <category term="自动化测试" scheme="https://pinghailinfeng.gitee.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="java" scheme="https://pinghailinfeng.gitee.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Still a teenager</title>
    <link href="https://pinghailinfeng.gitee.io/2020/04/05/Still-a-teenager/"/>
    <id>https://pinghailinfeng.gitee.io/2020/04/05/Still-a-teenager/</id>
    <published>2020-04-05T14:11:31.000Z</published>
    <updated>2020-09-15T02:03:56.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归来仍是少年"><a href="#归来仍是少年" class="headerlink" title="归来仍是少年"></a>归来仍是少年</h1><p><img src="http://a3.att.hudong.com/36/19/01300000660677127669194340150.jpg" alt></p><a id="more"></a><p>很久没有更新博客了,一来是需要自己整理下思路,二来是自己也要学习,不想因为这样降低博客的质量。<br>坚持了70多天中断了,感觉有点可惜，但是想来也对自己有个交代。</p><p>停下也是为了更好的往下走。</p><p>一年前的今天,我父亲还健在。</p><p>清明时节雨纷纷的季节，一年前的事情仍旧历历在目。</p><p>阴历三月初一是父亲的生日,寻思给父亲过个生日,3月底才出的院。父亲明显感觉比以前气色差了很多。</p><p>老人有讲究,不到80大寿,不宜大操大办。因此我给父亲订了蛋糕,俺娘准备了父亲喜欢吃的蚬子长寿面,就一家人简简单单过了一个生日。</p><p>父亲的那天胃口格外的好，吃了两大碗面条。我和母亲对视了一眼,心里感觉好了一点。</p><p>席间和闺女还做起了游戏,闺女想骑大马,但是考虑到父亲身体还很虚弱,就让媳妇领到一边去玩。</p><p>去厨房刷碗,母亲小声告诉我。你爸好几天都难受的睡不着觉了。我心里咯噔一下,只能提醒母亲注意,随时给我打电话。</p><p>聊起了很多小时候的事。</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200405_father_and_mother.jpg?raw=true" alt></p><p>印象中爸爸年轻时候喜欢各种运动,足篮排乒乓没有不会的,会吹笛子,会画画,照片看是个俊美的男子。</p><p>后来遇到了母亲,有了我和姐姐,足球也踢不动了,担任了厂队的领队,那段风风火火的日子,我经常去球场看球。</p><p>想起下雨天,我在水坑打闹,弄得一身白衣服变成了灰色,父亲回家用毛巾狠狠抽了我。</p><p>其实抽完,父亲就觉得后悔,谁都有调皮的时候。</p><p>回到大连,房子正在装修,我接到一个女同学电话。我父亲问起来,大学有没有要好的女同学,有合适的可以处处看。我那时候还是懵懂的年纪,只知道傻乎乎的笑。</p><p>年龄越来越大了,父亲表面没说什么,其实心里着实着急。</p><p>我也装傻充愣,在以找对象名义,又玩了好几年。</p><p>终于婚了,父亲拉着我媳妇的手,就说一句话,好好过啊,有啥需要就找我们。我偷偷看到,老爷子眼角有了泪花。</p><p>婚房房子装修的日子,爸妈全程建工,登梯子爬高,为了一个门帘从金三角老两口硬是走了回来。我姐夫调侃说,看出来了,这是儿啊。</p><p>老爷子私下问我,啥时候准备要孩子啊。我说不着急,反问俺爸: 您着急了。俺爸说,能不着急吗,我和你妈都多大年纪了,趁腿脚好,还能帮你带带。</p><p>孩子啼哭的那一刻,我突然意识到这个小生命的诞生,让我从一个黄花少年,也当了爹。</p><p>媳妇怀孕期间一直反应很大,从开始怀孕一直吐到产床。父亲一直担心,孩子会有影响。</p><p>当护士把孩子报过来的时候,老爷子乐的合不拢嘴,一个劲的念叨,挺好挺好。</p><p>因为母亲过来带孩子,忽视了父亲的身体,老爷子自己不想给我们添麻烦,终于2016年的冬天,老爷子突然因病入院。</p><p>进手术室前,父亲就说了一句话,我还想活着看孙女上小学呢！期间母亲一直在哭,我们只能祈祷手术能成功。</p><p>事后,主治医生说,这个手术风险很高,正常人基本上下不了手术台,更何况我父亲有20年的糖尿病,并发症一来,谁也没招。正常40分钟的手术做了2个半小时,老爷子硬是挺了过来。</p><p>不到一个月的时间,又因为大面积静脉渗血导致心肌炎,又一次去了手术室……..</p><p>我急急忙忙跑去医院,看到俺爸浑身插着十几个管子的时候,我控制不住自己,眼泪止不住流。</p><p>老爷子慢慢恢复了过来,看着他那神采奕奕的眼睛慢慢失去了光,我意识到,这场病对于俺爸意味着什么。</p><p>2017年十月一,我记得很清楚,我开车领着俺爸去看了东港的喷泉。老爷子走路都费劲了,不到200米的路,歇了十几趟。我搀扶着父亲,手上就剩下骨头了。我扭过头,强忍着泪水。那是父亲最后一次出远门。</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200405_father.jpg?raw=true" alt></p><p>2018年春节,家人都聚在一起,那时父亲的头发已经全白了。</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200405_father_and_famliy.jpg?raw=true" alt></p><p>19年,刚过完春节,父亲觉得心脏不舒服,就去住院了。凌晨2点,我给父亲送去医院住院。没来得及告诉俺姐。等到住院手续办理完。我才给俺姐打电话,谁知道俺姐也来同一个医院住院了。老爷子一听到俺姐也住院了,眼泪就流下来了,那时候还没有床位,就一个劲念叨,我要等着俺老闺女来。俺姐来了,父亲就抱着俺姐哭了起来。</p><p>晚上需要有人陪护,怕我睡不好,故意说我打呼噜影响他睡眠,就让我回家睡。</p><p>医生也把我们家属叫到一起,详细说明了父亲现在的病情,距离上次手术过去了三年,现在最重要的不是糖尿病,也不是静脉栓塞,而是心脏。老爷子现在的身体已经不能再做手术了。建议回家静养。我们听了感觉心里很难受。不停追问医生还有没有更好的办法。医生虽然没明着说没有,其实也间接说明病情已经很严重了。</p><p>父亲是一个很聪明的人,从医生的只言片语里也清楚自己时日无多。</p><p>3月底了,有一天我去医院陪护,父亲拉着我的手说,去走廊溜达溜达。他背靠在护士站的台子前,和我说了一段意味深长的话，他说,我知道我现在心脏是大问题,一旦出问题,3分钟人就没了,我的银行卡都在你妈那,房子你和你姐一人一半,房产证都在你妈那,有事找你妈。我以为父亲是开玩笑,说道,咋的,你这是交代后事啊。父亲突然严肃了起来,说,对,就是交代下。我心里一沉。</p><p>4月7号,我正好陪孩子去上英语课,突然接到了母亲的电话,快来,你爸不行了。</p><p>当我打车冲过去的时候,父亲已经永远离开了我们。120又急救了将近20分钟,脉搏一直都是一条直线。领队说,老爷子心脏病突发,走了,没遭罪，子女看看是否还需要送医院,否则就在死亡确认书上签字吧。听到这个的时候,我整个大脑都一片空白了。</p><p>姐夫赶紧联系了殡葬的人,过了不到十分钟，办事的人说,来孝子来给老爷子净身。我用毛巾给父亲擦脸,感受到父亲的温度。我到现在都不相信,父亲永远的离开了我们。就像睡着了一样。</p><p>我实在写不下去了……..</p><p>想想对父亲的承诺,说出了院,还能带着父亲去趟澡堂子,这辈子再也不可能实现了。</p><p>归来还是少年吗？体会到为人父,为人夫的责任,你就不会再是孩子了。</p><p>如今一周年了,我只想对我父亲说,<strong>儿子想你了,你还能回来不？</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;归来仍是少年&quot;&gt;&lt;a href=&quot;#归来仍是少年&quot; class=&quot;headerlink&quot; title=&quot;归来仍是少年&quot;&gt;&lt;/a&gt;归来仍是少年&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://a3.att.hudong.com/36/19/01300000660677127669194340150.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="杂记" scheme="https://pinghailinfeng.gitee.io/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="https://pinghailinfeng.gitee.io/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="感悟" scheme="https://pinghailinfeng.gitee.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>esp32 micropython 03 webrepl</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/27/esp32-micropython-03-webrepl/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/27/esp32-micropython-03-webrepl/</id>
    <published>2020-03-27T14:46:44.000Z</published>
    <updated>2020-04-09T13:36:01.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp32-micropython-之旅-03-webrepl"><a href="#esp32-micropython-之旅-03-webrepl" class="headerlink" title="esp32  micropython 之旅 03 webrepl"></a>esp32  micropython 之旅 03 webrepl</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200327_dianlu.jpg?raw=true" alt></p><a id="more"></a><h2 id="使用network模块连接WIFI"><a href="#使用network模块连接WIFI" class="headerlink" title="使用network模块连接WIFI"></a>使用network模块连接WIFI</h2><p><code>network</code>模块是和网络相关的模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> network <span class="comment"># 导入network模块</span></span><br><span class="line">wifi = network.WLAN(network.STA_IF)  <span class="comment"># 设置为STA_IF模式，即接入wifi路由器的模式AP_IF为作为热点</span></span><br></pre></td></tr></table></figure><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200327_wifi.png?raw=true" alt></p><p>接下来我们需要激活wifi，并进行连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wifi.active(<span class="literal">True</span>) <span class="comment"># 将wifi激活</span></span><br><span class="line">wifi.connect(<span class="string">'&lt;essid&gt;'</span>,<span class="string">'&lt;password&gt;'</span>) <span class="comment">#连接至wifi</span></span><br></pre></td></tr></table></figure><h3 id="查看wifi连接状态"><a href="#查看wifi连接状态" class="headerlink" title="查看wifi连接状态"></a>查看wifi连接状态</h3><p>使用<code>ifconfig</code>查看网络状态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wifi.ifconfig()</span><br></pre></td></tr></table></figure><h2 id="WebREPL"><a href="#WebREPL" class="headerlink" title="WebREPL"></a>WebREPL</h2><p>WebREPL是一个使用Web前端技术栈构建的单页应用。</p><p><strong>WebREPL允许你通过WiFi使用MicroPython的REPL，通过浏览器连接，使用了WebSockt通信协议</strong>。</p><p>在MicroPython的网站上托管了WebREPL的单页应用，点击如下链接即可访问：</p><p><a href="http://micropython.org/webrepl" target="_blank" rel="noopener">http://micropython.org/webrepl</a></p><p>两个步骤</p><ul><li>初始化WebREPL</li><li>开启WebREPL</li></ul><h3 id="初始化WebREPL"><a href="#初始化WebREPL" class="headerlink" title="初始化WebREPL"></a>初始化WebREPL</h3><p>初次使用WebREPL，我们先要使用<code>webrepl_setup</code>模块来进行初始化设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> webrepl_setup</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200327_repl_confirm_password.png?raw=true" alt></p><p>当你看到亲切的<code>&gt;&gt;&gt;</code>提示符时，则表明你已成功的连接到了WebREPL</p><h3 id="开启WebREPL"><a href="#开启WebREPL" class="headerlink" title="开启WebREPL"></a>开启WebREPL</h3><p>接下来，我们直接开启webrepl的服务:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> webrepl</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>webrepl.start()</span><br></pre></td></tr></table></figure><p>如上两句指令执行后，如下图所示：</p><h3 id="连接WebREPL"><a href="#连接WebREPL" class="headerlink" title="连接WebREPL"></a>连接WebREPL</h3><p>访问<a href="http://micropython.org/webrepl" target="_blank" rel="noopener">http://micropython.org/webrepl</a></p><p>输入正确的URL,然后点击Connet按钮</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200327_repl_connection_success.png?raw=true" alt></p><h3 id="试试WebREPL"><a href="#试试WebREPL" class="headerlink" title="试试WebREPL"></a>试试WebREPL</h3><p>现在，你可以在这个Web页面上欢快的玩耍了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;esp32-micropython-之旅-03-webrepl&quot;&gt;&lt;a href=&quot;#esp32-micropython-之旅-03-webrepl&quot; class=&quot;headerlink&quot; title=&quot;esp32  micropython 之旅 03 webrepl&quot;&gt;&lt;/a&gt;esp32  micropython 之旅 03 webrepl&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200327_dianlu.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="micropython" scheme="https://pinghailinfeng.gitee.io/categories/python/micropython/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="esp32" scheme="https://pinghailinfeng.gitee.io/tags/esp32/"/>
    
      <category term="micorpython" scheme="https://pinghailinfeng.gitee.io/tags/micorpython/"/>
    
      <category term="webrepl" scheme="https://pinghailinfeng.gitee.io/tags/webrepl/"/>
    
  </entry>
  
  <entry>
    <title>esp32 micropython using uPycraft IDE</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/24/esp32-micropython-using-uPyCraft/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/24/esp32-micropython-using-uPyCraft/</id>
    <published>2020-03-24T15:51:00.000Z</published>
    <updated>2020-04-09T13:36:01.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp32-micropython-之旅-02-使用uPycraft-IDE"><a href="#esp32-micropython-之旅-02-使用uPycraft-IDE" class="headerlink" title="esp32 micropython 之旅 02 使用uPycraft IDE"></a>esp32 micropython 之旅 02 使用uPycraft IDE</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326getting-started-esp32.jpg?raw=true" alt></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次使用命令方式推送代码烧录到固件,今天介绍下micropython的几个著名的IDE。</p><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><ul><li>Thonny IDE </li><li>uPyCraft IDE.</li></ul><h3 id="使用uPyCraft"><a href="#使用uPyCraft" class="headerlink" title="使用uPyCraft"></a>使用<strong>uPyCraft</strong></h3><h4 id="Step-1-点击这个链接下载uPyCraft-的-exe文件"><a href="#Step-1-点击这个链接下载uPyCraft-的-exe文件" class="headerlink" title="Step 1.  点击这个链接下载uPyCraft 的.exe文件"></a><strong>Step 1.</strong>  点击这个<a href="https://github.com/DFRobot/uPyCraft" target="_blank" rel="noopener">链接</a>下载<strong>uPyCraft</strong> 的.exe文件</h4><h4 id="Step-2-双击安装包-打开安装后偶uPyCraft-可能是这个样子"><a href="#Step-2-双击安装包-打开安装后偶uPyCraft-可能是这个样子" class="headerlink" title="Step 2.   双击安装包,打开安装后偶uPyCraft 可能是这个样子"></a><strong>Step 2.</strong>   双击安装包,打开安装后偶uPyCraft 可能是这个样子</h4><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326-Installing-uPyCraft-IDE-on-Windows-to-Program-ESP32.png?raw=true" alt></p><h4 id="uPyCraft-核心组件"><a href="#uPyCraft-核心组件" class="headerlink" title="uPyCraft 核心组件"></a>uPyCraft 核心组件</h4><h5 id="1-Folder-and-Files"><a href="#1-Folder-and-Files" class="headerlink" title="1. Folder and Files"></a>1. Folder and Files</h5><ul><li><p>Device ：设备 是esp32还是esp8266 还是microbit</p></li><li><p>SD : 包含文件存储的 SD 卡。很多不开发版都支持SD </p></li><li><p>uPy_lib:  包含micropython 内置模块</p></li><li><p>workSpace : 将保结果存到本地</p></li></ul><h5 id="2-Editor-：编写python代码。"><a href="#2-Editor-：编写python代码。" class="headerlink" title="2. Editor ：编写python代码。"></a>2. Editor ：编写python代码。</h5><p><strong>3. Shell/Terminal:</strong>  终端</p><h5 id="4-Tools-创建新文件，保存和上传文件到开发板上，关闭连接等功能。"><a href="#4-Tools-创建新文件，保存和上传文件到开发板上，关闭连接等功能。" class="headerlink" title="4. Tools:   创建新文件，保存和上传文件到开发板上，关闭连接等功能。"></a><strong>4. Tools:</strong>   创建新文件，保存和上传文件到开发板上，关闭连接等功能。</h5><h3 id="开始烧录最新的-esp32-micropython-固件"><a href="#开始烧录最新的-esp32-micropython-固件" class="headerlink" title="开始烧录最新的 esp32 micropython 固件"></a>开始烧录最新的 esp32 micropython 固件</h3><p>首先,从<a href="https://micropython.org/download#esp32" target="_blank" rel="noopener">这个</a>站点,下载最新的esp32 micropython固件</p><p><strong>Step 2.</strong>,打开 <strong>uPyCraft</strong> ，点击 <strong>*Tools-&gt; Serial**</strong> 选择映射端口. </p><p>  <img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326Flashing-MicroPython-Firmware-on-ESP32-Board.png?raw=true" alt></p><p> <strong>Step 2.</strong> 选择<strong>*Tools-&gt;board*</strong>.这里我们选择esp32</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326-using-uPyCrfaft-burn-micropython.png?raw=true" alt></p><p> <strong>Step 3.</strong> 开始烧录</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326Flashing-MicroPython-Firmware-on-ESP32.png?raw=true" alt></p><h3 id="使用-uPyCraft-IDE-上传代码到esp32"><a href="#使用-uPyCraft-IDE-上传代码到esp32" class="headerlink" title="使用  uPyCraft IDE 上传代码到esp32"></a>使用  <strong>uPyCraft IDE</strong> 上传代码到esp32</h3><p><strong>Step 1.</strong> 打开 uPyCraft IDE 和 <strong>Tools-&gt;boards</strong>，选择你的主板</p><p><strong>Step 2.</strong> 直接点击 <strong><em>tools-&gt; Serial\</em></strong> 选择COM口.</p><p><strong>Step 3.</strong> 点击Connect 连接IDE和esp主板</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326Uploading-the-Code%20into-ESP32.png?raw=true" alt></p><p> <strong>Step 4.</strong> 如果连接正常,则下面的终端区会显示  <strong>&gt;&gt;&gt;</strong> 符号,此时可以执行micropython的命令。</p><p>  <strong>Step 5.</strong>现在点击iNew File,并保存到本地。</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326Programming-and-uploading-the-code-into-ESP32-using-uPyCraft-IDE.png?raw=true" alt></p><p><strong>Step 6.</strong> 点击新创建的文件,开始编写小灯程序的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line">led = Pin(<span class="number">2</span>, Pin.OUT)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    led.value(<span class="keyword">not</span> led.value())</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​    </p><p> <strong>Step 7.</strong> 点击 <strong><em>Download and run\</em></strong> 按钮</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200326uPyCraft-IDE-blink-script-to-board.png?raw=true" alt></p><p> <strong>Step 8.</strong> 重新测试代码是否正确,点击 <strong><em>En/Reset\</em></strong> 按钮。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>不知道什么原因,win7操作系统 uPycraft 就是识别不了 我的板子,换成win10 一次性搞定。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;esp32-micropython-之旅-02-使用uPycraft-IDE&quot;&gt;&lt;a href=&quot;#esp32-micropython-之旅-02-使用uPycraft-IDE&quot; class=&quot;headerlink&quot; title=&quot;esp32 micropython 之旅 02 使用uPycraft IDE&quot;&gt;&lt;/a&gt;esp32 micropython 之旅 02 使用uPycraft IDE&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200326getting-started-esp32.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="micropython" scheme="https://pinghailinfeng.gitee.io/categories/python/micropython/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="micropython" scheme="https://pinghailinfeng.gitee.io/tags/micropython/"/>
    
      <category term="esp32" scheme="https://pinghailinfeng.gitee.io/tags/esp32/"/>
    
      <category term="uPycraft" scheme="https://pinghailinfeng.gitee.io/tags/uPycraft/"/>
    
  </entry>
  
  <entry>
    <title>esp32 micropython tutorial 01 environment setup</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/23/esp32-micropython-tutorial-01-environment-setup/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/23/esp32-micropython-tutorial-01-environment-setup/</id>
    <published>2020-03-23T15:27:29.000Z</published>
    <updated>2020-03-23T16:00:45.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp32-micropython-之旅-01-环境搭建"><a href="#esp32-micropython-之旅-01-环境搭建" class="headerlink" title="esp32  micropython 之旅 01 环境搭建"></a>esp32  micropython 之旅 01 环境搭建</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/ardunio_logo.jpg?raw=true" alt></p><a id="more"></a><p>今天开始另一个系列的文章,有关嵌入式的专题,希望大家能支持我！</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><table><thead><tr><th>环境</th><th>版本</th></tr></thead><tbody><tr><td>操作系统</td><td>win7 64位 旗舰版</td></tr><tr><td>micropython</td><td>v1.12</td></tr><tr><td>esp32</td><td>uno D1 R32</td></tr><tr><td>ardunio ide</td><td>v1.8.12</td></tr></tbody></table><h2 id="开箱时刻"><a href="#开箱时刻" class="headerlink" title="开箱时刻"></a>开箱时刻</h2><p>某宝买了一个不到30块钱的板子,支持蓝牙、WIFI,4m缓存,直接开搞</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/b3c9d52def57969321ed5dad73c169a.jpg?raw=true" alt></p><p>开箱通电</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/6fd65f0e334bf5b843ec2a3367e0b7c.jpg?raw=true" alt></p><p>安装驱动部分我一篇再说,下面是具体刷<code>micropython</code>固件过程</p><h2 id="安装-esptool"><a href="#安装-esptool" class="headerlink" title="安装 esptool"></a>安装 esptool</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install esptool</span><br></pre></td></tr></table></figure><h2 id="擦除固件"><a href="#擦除固件" class="headerlink" title="擦除固件"></a>擦除固件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esptool.py --chip esp32 --port /dev/ttyUSB0 erase_flash</span><br></pre></td></tr></table></figure><h2 id="刷micropython固件"><a href="#刷micropython固件" class="headerlink" title="刷micropython固件"></a>刷micropython固件</h2><p><a href="https://micropython.org/download#esp32" target="_blank" rel="noopener">固件下载地址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">esptool.py --port COM13 write_flash 0x1000 esp32-idf3-20200323-v1.12-270-g38ccb4c64.bin</span><br></pre></td></tr></table></figure><h2 id="编写小灯闪亮程序"><a href="#编写小灯闪亮程序" class="headerlink" title="编写小灯闪亮程序"></a>编写小灯闪亮程序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line">p0 = Pin(<span class="number">2</span>,Pin.OUT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p0.value(<span class="number">0</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    p0.value(<span class="number">1</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><h2 id="通过ampy命令推送到uno中"><a href="#通过ampy命令推送到uno中" class="headerlink" title="通过ampy命令推送到uno中"></a>通过ampy命令推送到uno中</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install adafruit-ampy</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ampy --port COM13 put blink.py</span><br></pre></td></tr></table></figure><h2 id="查看固件中的文件"><a href="#查看固件中的文件" class="headerlink" title="查看固件中的文件"></a>查看固件中的文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type "help()" for more information.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import os</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; os.listdir()</span></span><br><span class="line">['boot.py', 'blink.py']</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.remove('blink.py')</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>引脚问题还没解决,小灯正常应该可以点亮,以后有得玩了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;esp32-micropython-之旅-01-环境搭建&quot;&gt;&lt;a href=&quot;#esp32-micropython-之旅-01-环境搭建&quot; class=&quot;headerlink&quot; title=&quot;esp32  micropython 之旅 01 环境搭建&quot;&gt;&lt;/a&gt;esp32  micropython 之旅 01 环境搭建&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/ardunio_logo.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="micropython" scheme="https://pinghailinfeng.gitee.io/categories/micropython/"/>
    
      <category term="esp32" scheme="https://pinghailinfeng.gitee.io/categories/micropython/esp32/"/>
    
    
      <category term="micropython" scheme="https://pinghailinfeng.gitee.io/tags/micropython/"/>
    
      <category term="esp32" scheme="https://pinghailinfeng.gitee.io/tags/esp32/"/>
    
      <category term="esptool" scheme="https://pinghailinfeng.gitee.io/tags/esptool/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library fileinput</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/22/python-standard-library-fileinput/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/22/python-standard-library-fileinput/</id>
    <published>2020-03-22T15:55:23.000Z</published>
    <updated>2020-03-22T16:06:24.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-标准库-fileinput"><a href="#Python-标准库-fileinput" class="headerlink" title="Python 标准库 fileinput"></a>Python 标准库 fileinput</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200323_input-output.jpg?raw=true" alt></p><a id="more"></a><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/fileinput.py" target="_blank" rel="noopener">Lib/fileinput.py</a></p><hr><p>此模块实现了一个辅助类和一些函数用来快速编写访问标准输入或文件列表的循环。 如果你只想要读写一个文件请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>。</p><p>典型用法为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fileinput</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input():</span><br><span class="line">    process(line)</span><br></pre></td></tr></table></figure><p>此程序会迭代 <code>sys.argv[1:]</code> 中列出的所有文件内的行，如果列表为空则会使用 <code>sys.stdin</code>。 如果有一个文件名为 <code>&#39;-&#39;</code>，它也会被替换为 <code>sys.stdin</code> 并且可选参数 <em>mode</em> 和 <em>openhook</em> 会被忽略。 要指定替代文件列表，请将其作为第一个参数传给 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.input" target="_blank" rel="noopener"><code>input()</code></a>。 也允许使用单个文件。</p><p>所有文件都默认以文本模式打开，但你可以通过在调用 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.input" target="_blank" rel="noopener"><code>input()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput</code></a> 时指定 <em>mode</em> 形参来重载此行为。 如果在打开或读取文件时发生了 I/O 错误，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>。</p><p><em>在 3.3 版更改:</em> 原来会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IOError" target="_blank" rel="noopener"><code>IOError</code></a>；现在它是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的别名。</p><p>如果 <code>sys.stdin</code> 被使用超过一次，则第二次之后的使用将不返回任何行，除非是被交互式的使用，或都是被显式地重置 (例如使用 <code>sys.stdin.seek(0)</code>)。</p><p>空文件打开后将立即被关闭；它们在文件列表中会被注意到的唯一情况只有当最后打开的文件为空的时候。</p><p>反回的行不会对换行符做任何处理，这意味着文件中的最后一行可能不带换行符。</p><p>想要控制文件的打开方式，你可以通过将 <em>openhook</em> 形参传给 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.input" target="_blank" rel="noopener"><code>fileinput.input()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput()</code></a> 来提供一个打开钩子。 此钩子必须为一个函数，它接受两个参数，<em>filename</em> 和 <em>mode</em>，并返回一个以相应模式打开的文件类对象。 此模块已经提供了两个有用的钩子。</p><p>以下函数是此模块的初始接口：</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p><code>fileinput.input</code>(<em>files=None</em>, <em>inplace=False</em>, <em>backup=’’</em>, <em>**, </em>mode=’r’<em>, </em>openhook=None*)</p><p>创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput</code></a> 类的实例。 该实例将被用作此模块中函数的全局状态，并且还将在迭代期间被返回使用。 此函数的形参将被继续传递给 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput</code></a> 类的构造器。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput</code></a> 实例可以在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中被用作上下文管理器。 在这个例子中，<em>input</em> 在 <code>with</code> 语句结束后将会被关闭，即使发生了异常也是如此:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with fileinput.input(files=(&apos;spam.txt&apos;, &apos;eggs.txt&apos;)) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        process(line)</span><br></pre></td></tr></table></figure><p><em>在 3.2 版更改:</em> 可以被用作上下文管理器。</p><p><em>在 3.8 版更改:</em> 关键字形参 <em>mode</em> 和 <em>openhook</em> 现在是仅限关键字形参。</p></li></ul><p>下列函数会使用 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.input" target="_blank" rel="noopener"><code>fileinput.input()</code></a> 所创建的全局状态；如果没有活动的状态，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p><ul><li><p><code>fileinput.filename</code>()</p><p>返回当前被读取的文件名。 在第一行被读取之前，返回 <code>None</code>。</p></li><li><p><code>fileinput.fileno</code>()</p><p>返回以整数表示的当前文件“文件描述符”。 当未打开文件时（处在第一行和文件之间），返回 <code>-1</code>。</p></li><li><p><code>fileinput.lineno</code>()</p><p>返回已被读取的累计行号。 在第一行被读取之前，返回 <code>0</code>。 在最后一个文件的最后一行被读取之后，返回该行的行号。</p></li><li><p><code>fileinput.filelineno</code>()</p><p>返回当前文件中的行号。 在第一行被读取之前，返回 <code>0</code>。 在最后一个文件的最后一行被读取之后，返回此文件中该行的行号。</p></li><li><p><code>fileinput.isfirstline</code>()</p><p>如果刚读取的行是其所在文件的第一行则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p><code>fileinput.isstdin</code>()</p><p>如果最后读取的行来自 <code>sys.stdin</code> 则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p><code>fileinput.nextfile</code>()</p><p>关闭当前文件以使下次迭代将从下一个文件（如果存在）读取第一行；不是从该文件读取的行将不会被计入累计行数。 直到下一个文件的第一行被读取之后文件名才会改变。 在第一行被读取之前，此函数将不会生效；它不能被用来跳过第一个文件。 在最后一个文件的最后一行被读取之后，此函数将不再生效。</p></li><li><p><code>fileinput.close</code>()</p><p>关闭序列。</p></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>此模块所提供的实现了序列行为的类同样也可用于子类化：</p><ul><li><p><em>class</em> <code>fileinput.FileInput</code>(<em>files=None</em>, <em>inplace=False</em>, <em>backup=’’</em>, <em>**, </em>mode=’r’<em>, </em>openhook=None*)</p><p>类 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput</code></a> 是一个实现；它的方法 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.filename" target="_blank" rel="noopener"><code>filename()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.fileno" target="_blank" rel="noopener"><code>fileno()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.lineno" target="_blank" rel="noopener"><code>lineno()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.filelineno" target="_blank" rel="noopener"><code>filelineno()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.isfirstline" target="_blank" rel="noopener"><code>isfirstline()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.isstdin" target="_blank" rel="noopener"><code>isstdin()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.nextfile" target="_blank" rel="noopener"><code>nextfile()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.close" target="_blank" rel="noopener"><code>close()</code></a> 对应于此模块中具有相同名称的函数。 此外它还有一个 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.TextIOBase.readline" target="_blank" rel="noopener"><code>readline()</code></a> 方法可返回下一个输入行，以及一个 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法，该方法实现了序列行为。 这种序列必须以严格的序列顺序来读写；随机读写和 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.TextIOBase.readline" target="_blank" rel="noopener"><code>readline()</code></a> 不可以被混用。</p><p>通过 <em>mode</em> 你可以指定要传给 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 的文件模式。 它必须为 <code>&#39;r&#39;</code>, <code>&#39;rU&#39;</code>, <code>&#39;U&#39;</code> 和 <code>&#39;rb&#39;</code> 中的一个。</p><p><em>openhook</em> 如果给出则必须为一个函数，它接受两个参数 <em>filename</em> 和 <em>mode</em>，并相应地返回一个打开的文件类对象。 你不能同时使用 <em>inplace</em> 和 <em>openhook</em>。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput</code></a> 实例可以在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中被用作上下文管理器。 在这个例子中，<em>input</em> 在 <code>with</code> 语句结束后将会被关闭，即使发生了异常也是如此:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> FileInput(files=(<span class="string">'spam.txt'</span>, <span class="string">'eggs.txt'</span>)) <span class="keyword">as</span> input:</span><br><span class="line">    process(input)</span><br></pre></td></tr></table></figure><p><em>在 3.2 版更改:</em> 可以被用作上下文管理器。</p><p><em>3.4 版后已移除:</em> <code>&#39;rU&#39;</code> 和 <code>&#39;U&#39;</code> 模式。</p><p><em>3.8 版后已移除:</em> 对 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法的支持已弃用。</p><p><em>在 3.8 版更改:</em> 关键字形参 <em>mode</em> 和 <em>openhook</em> 现在是仅限关键字形参。</p></li></ul><p><strong>可选的原地过滤:</strong> 如果传递了关键字参数 <code>inplace=True</code> 给 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.input" target="_blank" rel="noopener"><code>fileinput.input()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#fileinput.FileInput" target="_blank" rel="noopener"><code>FileInput</code></a> 构造器，则文件会被移至备份文件并将标准输出定向到输入文件（如果已存在与备份文件同名的文件，它将被静默地替换）。 这使得编写一个能够原地重写其输入文件的过滤器成为可能。 如果给出了 <em>backup</em> 形参 (通常形式为 <code>backup=&#39;.&lt;some extension&gt;&#39;</code>)，它将指定备份文件的扩展名，并且备份文件会被保留；默认情况下扩展名为 <code>&#39;.bak&#39;</code> 并且它会在输出文件关闭时被删除。 在读取标准输入时原地过滤会被禁用。</p><p>此模块提供了以下两种打开文件钩子：</p><ul><li><p><code>fileinput.hook_compressed</code>(<em>filename</em>, <em>mode</em>)</p><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/gzip.html#module-gzip" target="_blank" rel="noopener"><code>gzip</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块透明地打开 gzip 和 bzip2 压缩的文件（通过扩展名 <code>&#39;.gz&#39;</code> 和 <code>&#39;.bz2&#39;</code> 来识别）。 如果文件扩展名不是 <code>&#39;.gz&#39;</code> 或 <code>&#39;.bz2&#39;</code>，文件会以正常方式打开（即使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 并且不带任何解压操作）。使用示例: <code>fi = fileinput.FileInput(openhook=fileinput.hook_compressed)</code></p></li><li><p><code>fileinput.hook_encoded</code>(<em>encoding</em>, <em>errors=None</em>)</p><p>返回一个通过 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 打开每个文件的钩子，使用给定的 <em>encoding</em> 和 <em>errors</em> 来读取文件。使用示例: <code>fi = fileinput.FileInput(openhook=fileinput.hook_encoded(&quot;utf-8&quot;, &quot;surrogateescape&quot;))</code><em>在 3.6 版更改:</em> 添加了可选的 <em>errors</em> 形参。</p></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><em>利用fileinput及re做日志分析: 提取所有含日期的行</em></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--样本文件--</span></span><br><span class="line">aaa</span><br><span class="line"><span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">13</span>:<span class="number">45</span>:<span class="number">30</span>  Error: **** Due to System Disk spacke <span class="keyword">not</span> enough...</span><br><span class="line">bbb</span><br><span class="line"><span class="number">1970</span><span class="number">-01</span><span class="number">-02</span> <span class="number">10</span>:<span class="number">20</span>:<span class="number">30</span>  Error: **** Due to System Out of Memory...</span><br><span class="line">ccc</span><br><span class="line"> </span><br><span class="line"><span class="comment">#---测试脚本---</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> fileinput</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line">pattern = <span class="string">'d&#123;4&#125;-d&#123;2&#125;-d&#123;2&#125; d&#123;2&#125;:d&#123;2&#125;:d&#123;2&#125;'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fileinput.input(<span class="string">'error.log'</span>,backup=<span class="string">'.bak'</span>,inplace=<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> re.search(pattern,line):</span><br><span class="line">        sys.stdout.write(=&gt; )</span><br><span class="line">        sys.stdout.write(line)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#---测试结果---</span></span><br><span class="line">=&gt; 1970-01-01 13:45:30  Error: **** Due to System Disk spacke not enough...</span><br><span class="line">=&gt; 1970-01-02 10:20:30  Error: **** Due to System Out of Memory...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-标准库-fileinput&quot;&gt;&lt;a href=&quot;#Python-标准库-fileinput&quot; class=&quot;headerlink&quot; title=&quot;Python 标准库 fileinput&quot;&gt;&lt;/a&gt;Python 标准库 fileinput&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200323_input-output.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="fileinput" scheme="https://pinghailinfeng.gitee.io/tags/fileinput/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library Built-in Exception</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/21/python-standard-library-Built-in-Exception/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/21/python-standard-library-Built-in-Exception/</id>
    <published>2020-03-21T14:36:13.000Z</published>
    <updated>2020-03-22T15:54:04.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-内置异常"><a href="#python-标准库-内置异常" class="headerlink" title="python 标准库 内置异常"></a>python 标准库 内置异常</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200321_exception.jpg?raw=true" alt></p><a id="more"></a><p>在 Python 中，所有异常必须为一个派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 的类的实例。 在带有提及一个特定类的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 子句的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句中，该子句也会处理任何派生自该类的异常类（但不处理 <em>它</em> 所派生出的异常类）。 通过子类化创建的两个不相关异常类永远是不等效的，既使它们具有相同的名称。</p><p>下面列出的内置异常可通过解释器或内置函数来生成。除非另有说明，它们都会具有一个提示导致错误详细原因的“关联值”。 这可以是一个字符串或由多个信息项（例如一个错误码和一个解释错误的字符串）组成的元组。 关联值通常会作为参数被传递给异常类的构造器。</p><p>用户代码可以引发内置异常。 这可被用于测试异常处理程序或报告错误条件，“就像” 在解释器引发了相同异常的情况时一样；但是请注意，没有任何机制能防止用户代码引发不适当的错误。</p><p>内置异常类可以被子类化以定义新的异常；鼓励程序员从 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 类或它的某个子类而不是从 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 来派生新的异常。 关于定义异常的更多信息可以在 Python 教程的 <a href="https://docs.python.org/zh-cn/3.8/tutorial/errors.html#tut-userexceptions" target="_blank" rel="noopener">用户自定义异常</a> 部分查看。</p><p>当在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句中引发（或重新引发）异常时，<code>__context__</code> 会被自动设为所捕获的最后一个异常；如果新的异常未被处理，则最终显示的回溯信息将包括原始的异常和最后的异常。</p><p>当引发一个新的异常（而不是简单地使用 <code>raise</code> 来重新引发当前在处理的异常）时，隐式的异常上下文可以通过使用带有 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#raise" target="_blank" rel="noopener"><code>raise</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 来补充一个显式的原因:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> new_exc <span class="keyword">from</span> original_exc</span><br></pre></td></tr></table></figure><p>跟在 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 之后的表达式必须为一个异常或 <code>None</code>。 它将在所引发的异常上被设置为 <code>__cause__</code>。 设置 <code>__cause__</code> 还会隐式地将 <code>__suppress_context__</code> 属性设为 <code>True</code>，这样使用 <code>raise new_exc from None</code> 可以有效地将旧异常替换为新异常来显示其目的 (例如将 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>)，同时让旧异常在 <code>__context__</code> 中保持可用状态以便在调试时进行内省。</p><p>除了异常本身的回溯以外，默认的回溯还会显示这些串连的异常。 <code>__cause__</code> 中的显式串连异常如果存在将总是显示。 <code>__context__</code> 中的隐式串连异常仅在 <code>__cause__</code> 为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 并且 <code>__suppress_context__</code> 为假值时显示。</p><p>不论在哪种情况下，异常本身总会在任何串连异常之后显示，以便回溯的最后一行总是显示所引发的最后一个异常。</p><h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><p>下列异常主要被用作其他异常的基类。</p><ul><li><p><em>exception</em> <code>BaseException</code></p><p>所有内置异常的基类。 它不应该被用户自定义类直接继承 (这种情况请使用 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a>)。 如果在此类的实例上调用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a>，则会返回实例的参数表示，或者当没有参数时返回空字符串。<code>args</code>传给异常构造器的参数元组。 某些内置异常 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>) 接受特定数量的参数并赋予此元组中的元素特殊的含义，而其他异常通常只接受一个给出错误信息的单独字符串。<code>with_traceback</code>(<em>tb</em>)此方法将 <em>tb</em> 设为异常的新回溯信息并返回该异常对象。 它通常以如下的形式在异常处理程序中使用:<code>try:    ... except SomeException:    tb = sys.exc_info()[2]    raise OtherException(...).with_traceback(tb)</code></p></li><li><p><em>exception</em> <code>Exception</code></p><p>所有内置的非系统退出类异常都派生自此类。 所有用户自定义异常也应当派生自此类。</p></li><li><p><em>exception</em> <code>ArithmeticError</code></p><p>此基类用于派生针对各种算术类错误而引发的内置异常: <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ZeroDivisionError" target="_blank" rel="noopener"><code>ZeroDivisionError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FloatingPointError" target="_blank" rel="noopener"><code>FloatingPointError</code></a>。</p></li><li><p><em>exception</em> <code>BufferError</code></p><p>当与 <a href="https://docs.python.org/zh-cn/3.8/c-api/buffer.html#bufferobjects" target="_blank" rel="noopener">缓冲区</a> 相关的操作无法执行时将被引发。</p></li><li><p><em>exception</em> <code>LookupError</code></p><p>此基类用于派生当映射或序列所使用的键或索引无效时引发的异常: <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。 这可以通过 <a href="https://docs.python.org/zh-cn/3.8/library/codecs.html#codecs.lookup" target="_blank" rel="noopener"><code>codecs.lookup()</code></a> 来直接引发。</p></li></ul><h2 id="具体异常"><a href="#具体异常" class="headerlink" title="具体异常"></a>具体异常</h2><p>以下异常属于经常被引发的异常。</p><ul><li><p><em>exception</em> <code>AssertionError</code></p><p>当 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#assert" target="_blank" rel="noopener"><code>assert</code></a> 语句失败时将被引发。</p></li><li><p><em>exception</em> <code>AttributeError</code></p><p>当属性引用 (参见 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#attribute-references" target="_blank" rel="noopener">属性引用</a>) 或赋值失败时将被引发。 （当一个对象根本不支持属性引用或属性赋值时则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。）</p></li><li><p><em>exception</em> <code>EOFError</code></p><p>当 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#input" target="_blank" rel="noopener"><code>input()</code></a> 函数未读取任何数据即达到文件结束条件 (EOF) 时将被引发。 （另外，<code>io.IOBase.read()</code> 和 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.readline" target="_blank" rel="noopener"><code>io.IOBase.readline()</code></a> 方法在遇到 EOF 则将返回一个空字符串。）</p></li><li><p><em>exception</em> <code>FloatingPointError</code></p><p>目前未被使用。</p></li><li><p><em>exception</em> <code>GeneratorExit</code></p><p>当一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 或 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 被关闭时将被引发；参见 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.close" target="_blank" rel="noopener"><code>generator.close()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine.close" target="_blank" rel="noopener"><code>coroutine.close()</code></a>。 它直接继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a>，因为从技术上来说它并不是一个错误。</p></li><li><p><em>exception</em> <code>ImportError</code></p><p>当 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句尝试加载模块遇到麻烦时将被引发。 并且当 <code>from ... import</code> 中的 “from list” 存在无法找到的名称时也会被引发。<code>name</code> 与 <code>path</code> 属性可通过对构造器使用仅关键字参数来设定。 设定后它们将分别表示被尝试导入的模块名称与触发异常的任意文件所在路径。<em>在 3.3 版更改:</em> 添加了 <code>name</code> 与 <code>path</code> 属性。</p></li><li><p><em>exception</em> <code>ModuleNotFoundError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a> 的子类，当一个模块无法被定位时将由 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 引发。 当在 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中找到 <code>None</code> 时也会被引发。<em>3.6 新版功能.</em></p></li><li><p><em>exception</em> <code>IndexError</code></p><p>当序列抽取超出范围时将被引发。 （切片索引会被静默截短到允许的范围；如果指定索引不是整数则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 会被引发。）</p></li><li><p><em>exception</em> <code>KeyError</code></p><p>当在现有键集合中找不到指定的映射（字典）键时将被引发。</p></li><li><p><em>exception</em> <code>KeyboardInterrupt</code></p><p>当用户按下中断键 (通常为 Control-C 或 Delete) 时将被引发。 在执行期间，会定期检测中断信号。 该异常继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 以确保不会被处理 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的代码意外捕获，这样可以避免退出解释器。</p></li><li><p><em>exception</em> <code>MemoryError</code></p><p>当一个操作耗尽内存但情况仍可（通过删除一些对象）进行挽救时将被引发。 关联的值是一个字符串，指明是哪种（内部）操作耗尽了内存。 请注意由于底层的内存管理架构（C 的 <code>malloc()</code> 函数），解释器也许并不总是能够从这种情况下完全恢复；但它毕竟可以引发一个异常，这样就能打印出栈回溯信息，以便找出导致问题的失控程序。</p></li><li><p><em>exception</em> <code>NameError</code></p><p>当某个局部或全局名称未找到时将被引发。 此异常仅用于非限定名称。 关联的值是一条错误信息，其中包含未找到的名称。</p></li><li><p><em>exception</em> <code>NotImplementedError</code></p><p>此异常派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 在用户自定义的基类中，抽象方法应当在其要求所派生类重载该方法，或是在其要求所开发的类提示具体实现尚待添加时引发此异常。注解 它不应当用来表示一个运算符或方法根本不能被支持 – 在此情况下应当让特定运算符 / 方法保持未定义，或者在子类中将其设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。注解 <code>NotImplementedError</code> 和 <code>NotImplemented</code> 不可互换，即使它们有相似的名称和用途。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#NotImplemented" target="_blank" rel="noopener"><code>NotImplemented</code></a> 了解有关何时使用它们的详细说明。</p></li><li><p><em>exception</em> <code>OSError</code>([<em>arg</em>])</p></li><li><p><em>exception</em> <code>OSError</code>(<em>errno</em>, <em>strerror</em>[, <em>filename</em>[, <em>winerror</em>[, <em>filename2</em>]]])</p><p>此异常在一个系统函数返回系统相关的错误时将被引发，此类错误包括 I/O 操作失败例如 “文件未找到” 或 “磁盘已满” 等（不包括非法参数类型或其他偶然性错误）。</p><p>构造器的第二种形式可设置如下所述的相应属性。 如果未指定这些属性则默认为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。 为了能向下兼容，如果传入了三个参数，则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException.args" target="_blank" rel="noopener"><code>args</code></a> 属性将仅包含由前两个构造器参数组成的 2 元组。</p><p>构造器实际返回的往往是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的某个子类，如下文 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#os-exceptions" target="_blank" rel="noopener">OS exceptions</a> 中所描述的。 具体的子类取决于最终的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 值。 此行为仅在直接或通过别名来构造 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 时发生，并且在子类化时不会被继承。</p><ul><li><p><code>errno</code></p><p>来自于 C 变量 <code>errno</code> 的数字错误码。</p></li><li><p><code>winerror</code></p><p>在 Windows 下，此参数将给出原生的 Windows 错误码。 而 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 属性将是该原生错误码在 POSIX 平台下的近似转换形式。在 Windows 下，如果 <em>winerror</em> 构造器参数是一个整数，则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 属性会根据 Windows 错误码来确定，而 <em>errno</em> 参数会被忽略。 在其他平台上，<em>winerror</em> 参数会被忽略，并且 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.winerror" target="_blank" rel="noopener"><code>winerror</code></a> 属性将不存在。</p></li><li><p><code>strerror</code></p><p>操作系统所提供的相应错误信息。 它在 POSIX 平台中由 C 函数 <code>perror()</code> 来格式化，在 Windows 中则是由 <code>FormatMessage()</code>。</p></li><li><p><code>filename</code></p></li><li><p><code>filename2</code></p><p>对于与文件系统路径有关 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unlink" target="_blank" rel="noopener"><code>os.unlink()</code></a>) 的异常，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename" target="_blank" rel="noopener"><code>filename</code></a> 是传给函数的文件名。 对于涉及两个文件系统路径的函数 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a>)，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename2" target="_blank" rel="noopener"><code>filename2</code></a> 将是传给函数的第二个文件名。</p></li></ul><p><em>在 3.3 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EnvironmentError" target="_blank" rel="noopener"><code>EnvironmentError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IOError" target="_blank" rel="noopener"><code>IOError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#WindowsError" target="_blank" rel="noopener"><code>WindowsError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.error" target="_blank" rel="noopener"><code>socket.error</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.error" target="_blank" rel="noopener"><code>select.error</code></a> 与 <code>mmap.error</code> 已被合并到 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>，构造器可能返回其中一个子类。</p><p><em>在 3.4 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename" target="_blank" rel="noopener"><code>filename</code></a> 属性现在将是传给函数的原始文件名，而不是经过编码或基于文件系统编码进行解码之后的名称。 此外还添加了 <em>filename2</em> 构造器参数和属性。</p></li><li><p><em>exception</em> <code>OverflowError</code></p><p>当算术运算的结果大到无法表示时将被引发。 这对整数来说不可能发生（宁可引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#MemoryError" target="_blank" rel="noopener"><code>MemoryError</code></a> 也不会放弃尝试）。 但是出于历史原因，有时也会在整数超出要求范围的情况下引发 OverflowError。 因为在 C 中缺少对浮点异常处理的标准化，大多数浮点运算都不会做检查。</p></li><li><p><em>exception</em> <code>RecursionError</code></p><p>此异常派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 它会在解释器检测发现超过最大递归深度 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getrecursionlimit" target="_blank" rel="noopener"><code>sys.getrecursionlimit()</code></a>) 时被引发。<em>3.5 新版功能:</em> 在此之前将只引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p></li><li><p><em>exception</em> <code>ReferenceError</code></p><p>此异常将在使用 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.proxy" target="_blank" rel="noopener"><code>weakref.proxy()</code></a> 函数所创建的弱引用来访问该引用的某个已被作为垃圾回收的属性时被引发。 有关弱引用的更多信息请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块。</p></li><li><p><em>exception</em> <code>RuntimeError</code></p><p>当检测到一个不归属于任何其他类别的错误时将被引发。 关联的值是一个指明究竟发生了什么问题的字符串。</p></li><li><p><em>exception</em> <code>StopIteration</code></p><p>由内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法所引发，用来表示该迭代器不能产生下一项。</p><p>该异常对象只有一个属性 <code>value</code>，它在构造该异常时作为参数给出，默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p><p>当一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 或 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 函数返回时，将引发一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 实例，函数返回的值将被用作异常构造器的 <code>value</code> 形参。</p><p>如果某个生成器代码直接或间接地引发了 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a>，它会被转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> (并将 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 保留为导致新异常的原因)。</p><p><em>在 3.3 版更改:</em> 添加了 <code>value</code> 属性及其被生成器函数用作返回值的功能。</p><p><em>在 3.5 版更改:</em> 引入了通过 <code>from __future__ import generator_stop</code> 来实现 RuntimeError 转换，参见 <a href="https://www.python.org/dev/peps/pep-0479" target="_blank" rel="noopener"><strong>PEP 479</strong></a>。</p><p><em>在 3.7 版更改:</em> 默认对所有代码启用 <a href="https://www.python.org/dev/peps/pep-0479" target="_blank" rel="noopener"><strong>PEP 479</strong></a>: 在生成器中引发的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 错误将被转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p></li><li><p><em>exception</em> <code>StopAsyncIteration</code></p><p>必须由一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterator" target="_blank" rel="noopener">asynchronous iterator</a> 对象的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__" target="_blank" rel="noopener"><code>__anext__()</code></a> 方法来引发以停止迭代操作。<em>3.5 新版功能.</em></p></li><li><p><em>exception</em> <code>SyntaxError</code></p><p>当解析器遇到语法错误时将被引发。 这可以发生在 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句，对内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 的调用，或者读取原始脚本或标准输入（也包括交互模式）的时候。该类的实例包含有属性 <code>filename</code>, <code>lineno</code>, <code>offset</code> 和 <code>text</code> 用于方便地访问相应的详细信息。 异常实例的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a> 仅返回消息文本。</p></li><li><p><em>exception</em> <code>IndentationError</code></p><p>与不正确的缩进相关的语法错误的基类。 这是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>TabError</code></p><p>当缩进包含对制表符和空格符不一致的使用时将被引发。 这是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndentationError" target="_blank" rel="noopener"><code>IndentationError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>SystemError</code></p><p>当解释器发现内部错误，但情况看起来尚未严重到要放弃所有希望时将被引发。 关联的值是一个指明发生了什么问题的字符串（表示为低层级的符号）。你应当将此问题报告给你所用 Python 解释器的作者或维护人员。 请确认报告 Python 解释器的版本号 (<code>sys.version</code>; 它也会在交互式 Python 会话开始时被打印出来)，具体的错误消息（异常所关联的值）以及可能触发该错误的程序源码。</p></li><li><p><em>exception</em> <code>SystemExit</code></p><p>此异常由 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 函数引发。 它继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 以确保不会被处理 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的代码意外捕获。 这允许此异常正确地向上传播并导致解释器退出。 如果它未被处理，则 Python 解释器就将退出；不会打印任何栈回溯信息。 构造器接受的可选参数与传递给 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 的相同。 如果该值为一个整数，则它指明系统退出状态码（会传递给 C 的 <code>exit()</code> 函数）；如果该值为 <code>None</code>，则退出状态码为零；如果该值为其他类型（例如字符串），则会打印对象的值并将退出状态码设为一。</p><p>对 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 的调用会被转换为一个异常以便能执行清理处理程序 (<a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句)，并且使得调试器可以执行一段脚本而不必冒失去控制的风险。 如果绝对确实地需要立即退出（例如在调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>os.fork()</code></a> 之后的子进程中）则可使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os._exit" target="_blank" rel="noopener"><code>os._exit()</code></a>.</p><ul><li><p><code>code</code></p><p>传给构造器的退出状态码或错误信息（默认为 <code>None</code>。）</p></li></ul></li><li><p><em>exception</em> <code>TypeError</code></p><p>当一个操作或函数被应用于类型不适当的对象时将被引发。 关联的值是一个字符串，给出有关类型不匹配的详情。此异常可以由用户代码引发，以表明尝试对某个对象进行的操作不受支持也不应当受支持。 如果某个对象应当支持给定的操作但尚未提供相应的实现，所要引发的适当异常应为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a>。传入参数的类型错误 (例如在要求 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 时却传入了 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a>) 应当导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>，但传入参数的值错误 (例如传入要求范围之外的数值) 则应当导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。</p></li><li><p><em>exception</em> <code>UnboundLocalError</code></p><p>当在函数或方法中对某个局部变量进行引用，但该变量并未绑定任何值时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NameError" target="_blank" rel="noopener"><code>NameError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>UnicodeError</code></p><p>当发生与 Unicode 相关的编码或解码错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 的一个子类。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 具有一些描述编码或解码错误的属性。 例如 <code>err.object[err.start:err.end]</code> 会给出导致编解码器失败的特定无效输入。</p><ul><li><p><code>encoding</code></p><p>引发错误的编码名称。</p></li><li><p><code>reason</code></p><p>描述特定编解码器错误的字符串。</p></li><li><p><code>object</code></p><p>编解码器试图要编码或解码的对象。</p></li><li><p><code>start</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 中无效数据的开始位置索引。</p></li><li><p><code>end</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 中无效数据的末尾位置索引（不含）。</p></li></ul></li><li><p><em>exception</em> <code>UnicodeEncodeError</code></p><p>当在编码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>UnicodeDecodeError</code></p><p>当在解码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>UnicodeTranslateError</code></p><p>在转写过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>ValueError</code></p><p>当操作或函数接收到具有正确类型但值不适合的参数，并且情况不能用更精确的异常例如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 来描述时将被引发。</p></li><li><p><em>exception</em> <code>ZeroDivisionError</code></p><p>当除法或取余运算的第二个参数为零时将被引发。 关联的值是一个字符串，指明操作数和运算的类型。</p></li></ul><p>下列异常被保留以与之前的版本相兼容；从 Python 3.3 开始，它们都是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的别名。</p><ul><li><em>exception</em> <code>EnvironmentError</code></li></ul><ul><li><em>exception</em> <code>IOError</code></li></ul><ul><li><p><em>exception</em> <code>WindowsError</code></p><p>限在 Windows 中可用。</p></li></ul><h3 id="OS-异常"><a href="#OS-异常" class="headerlink" title="OS 异常"></a>OS 异常</h3><p>下列异常均为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的子类，它们将根据系统错误代码被引发。</p><ul><li><p><em>exception</em> <code>BlockingIOError</code></p><p>当一个操作会被某个设置为非阻塞操作的对象（例如套接字）所阻塞时将被引发。 对应于 <code>errno</code> <code>EAGAIN</code>, <code>EALREADY</code>, <code>EWOULDBLOCK</code> 和 <code>EINPROGRESS</code>。除了 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 已有的属性，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BlockingIOError" target="_blank" rel="noopener"><code>BlockingIOError</code></a> 还有一个额外属性：<code>characters_written</code>一个整数，表示在被阻塞前已写入到流的字符数。 当使用来自 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#module-io" target="_blank" rel="noopener"><code>io</code></a> 模块的带缓冲 I/O 类时此属性可用。</p></li><li><p><em>exception</em> <code>ChildProcessError</code></p><p>当一个子进程上的操作失败时将被引发。 对应于 <code>errno</code> <code>ECHILD</code>。</p></li><li><p><em>exception</em> <code>ConnectionError</code></p><p>与连接相关问题的基类。其子类有 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BrokenPipeError" target="_blank" rel="noopener"><code>BrokenPipeError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionAbortedError" target="_blank" rel="noopener"><code>ConnectionAbortedError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionRefusedError" target="_blank" rel="noopener"><code>ConnectionRefusedError</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionResetError" target="_blank" rel="noopener"><code>ConnectionResetError</code></a>。</p></li><li><p><em>exception</em> <code>BrokenPipeError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当试图写入另一端已被关闭的管道，或是试图写入已关闭写入的套接字时将被引发。 对应于 <code>errno</code> <code>EPIPE</code> 和 <code>ESHUTDOWN</code>。</p></li><li><p><em>exception</em> <code>ConnectionAbortedError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接尝试被对端中止时将被引发。 对应于 <code>errno</code> <code>ECONNABORTED</code>。</p></li><li><p><em>exception</em> <code>ConnectionRefusedError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接尝试被对端拒绝时将被引发。 对应于 <code>errno</code> <code>ECONNREFUSED</code>。</p></li><li><p><em>exception</em> <code>ConnectionResetError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接被对端重置时将被引发。 对应于 <code>errno</code> <code>ECONNRESET</code>。</p></li><li><p><em>exception</em> <code>FileExistsError</code></p><p>当试图创建一个已存在的文件或目录时将被引发。 对应于 <code>errno</code> <code>EEXIST</code>。</p></li><li><p><em>exception</em> <code>FileNotFoundError</code></p><p>当所请求的文件或目录不存在时将被引发。 对应于 <code>errno</code> <code>ENOENT</code>。</p></li><li><p><em>exception</em> <code>InterruptedError</code></p><p>当系统调用被输入信号中断时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EINTR" target="_blank" rel="noopener"><code>EINTR</code></a>。<em>在 3.5 版更改:</em> 当系统调用被某个信号中断时，Python 现在会重试系统调用，除非该信号的处理程序引发了其它异常 (原理参见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>) 而不是引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a>。</p></li><li><p><em>exception</em> <code>IsADirectoryError</code></p><p>当请求对一个目录执行文件操作 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.remove" target="_blank" rel="noopener"><code>os.remove()</code></a>) 将被引发。 对应于 <code>errno</code> <code>EISDIR</code>。</p></li><li><p><em>exception</em> <code>NotADirectoryError</code></p><p>当请求对一个非目录对象执行目录操作 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>os.listdir()</code></a>) 时将被引发。 对应于 <code>errno</code> <code>ENOTDIR</code>。</p></li><li><p><em>exception</em> <code>PermissionError</code></p><p>当在没有足够操作权限的情况下试图执行某个操作时将被引发 —— 例如缺少文件系统权限。 对应于 <code>errno</code> <code>EACCES</code> 和 <code>EPERM</code>。</p></li><li><p><em>exception</em> <code>ProcessLookupError</code></p><p>当给定的进程不存在时将被引发。 对应于 <code>errno</code> <code>ESRCH</code>。</p></li><li><p><em>exception</em> <code>TimeoutError</code></p><p>当一个系统函数发生系统级超时的情况下将被引发。 对应于 <code>errno</code> <code>ETIMEDOUT</code>。</p></li></ul><p><em>3.3 新版功能:</em> 添加了以上所有 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的子类。</p><p>参见: </p><p><a href="https://www.python.org/dev/peps/pep-3151" target="_blank" rel="noopener"><strong>PEP 3151</strong></a> - 重写 OS 和 IO 异常的层次结构</p><h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>下列异常被用作警告类别；请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/warnings.html#warning-categories" target="_blank" rel="noopener">警告类别</a> 文档了解详情。</p><ul><li><p><em>exception</em> <code>Warning</code></p><p>警告类别的基类。</p></li><li><p><em>exception</em> <code>UserWarning</code></p><p>用户代码所产生警告的基类。</p></li><li><p><em>exception</em> <code>DeprecationWarning</code></p><p>如果所发出的警告是针对其他 Python 开发者的，则以此作为与已弃用特性相关警告的基类。</p></li><li><p><em>exception</em> <code>PendingDeprecationWarning</code></p><p>对于已过时并预计在未来弃用，但目前尚未弃用的特性相关警告的基类。这个类很少被使用，因为针对未来可能的弃用发出警告的做法并不常见，而针对当前已有的弃用则推荐使用 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#DeprecationWarning" target="_blank" rel="noopener"><code>DeprecationWarning</code></a>。</p></li><li><p><em>exception</em> <code>SyntaxWarning</code></p><p>与模糊的语法相关的警告的基类。</p></li><li><p><em>exception</em> <code>RuntimeWarning</code></p><p>与模糊的运行时行为相关的警告的基类。</p></li><li><p><em>exception</em> <code>FutureWarning</code></p><p>如果所发出的警告是针对以 Python 所编写应用的最终用户的，则以此作为与已弃用特性相关警告的基类。</p></li><li><p><em>exception</em> <code>ImportWarning</code></p><p>与在模块导入中可能的错误相关的警告的基类。</p></li><li><p><em>exception</em> <code>UnicodeWarning</code></p><p>与 Unicode 相关的警告的基类。</p></li><li><p><em>exception</em> <code>BytesWarning</code></p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 相关的警告的基类。</p></li><li><p><em>exception</em> <code>ResourceWarning</code></p><p>与资源使用相关的警告的基类。 会被默认的警告过滤器忽略。<em>3.2 新版功能.</em></p></li></ul><h2 id="异常层次结构"><a href="#异常层次结构" class="headerlink" title="异常层次结构"></a>异常层次结构</h2><p> 内置异常的类层级结构如下： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- StopAsyncIteration</span><br><span class="line">      +-- ArithmeticError</span><br><span class="line">      |    +-- FloatingPointError</span><br><span class="line">      |    +-- OverflowError</span><br><span class="line">      |    +-- ZeroDivisionError</span><br><span class="line">      +-- AssertionError</span><br><span class="line">      +-- AttributeError</span><br><span class="line">      +-- BufferError</span><br><span class="line">      +-- EOFError</span><br><span class="line">      +-- ImportError</span><br><span class="line">      |    +-- ModuleNotFoundError</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br><span class="line">      +-- MemoryError</span><br><span class="line">      +-- NameError</span><br><span class="line">      |    +-- UnboundLocalError</span><br><span class="line">      +-- **OSError**</span><br><span class="line">      |    +-- BlockingIOError</span><br><span class="line">      |    +-- ChildProcessError</span><br><span class="line">      |    +-- ConnectionError</span><br><span class="line">      |    |    +-- BrokenPipeError</span><br><span class="line">      |    |    +-- ConnectionAbortedError</span><br><span class="line">      |    |    +-- ConnectionRefusedError</span><br><span class="line">      |    |    +-- ConnectionResetError</span><br><span class="line">      |    +-- FileExistsError</span><br><span class="line">      |    +-- FileNotFoundError</span><br><span class="line">      |    +-- InterruptedError</span><br><span class="line">      |    +-- IsADirectoryError</span><br><span class="line">      |    +-- NotADirectoryError</span><br><span class="line">      |    +-- PermissionError</span><br><span class="line">      |    +-- ProcessLookupError</span><br><span class="line">      |    +-- TimeoutError</span><br><span class="line">      +-- ReferenceError</span><br><span class="line">      +-- RuntimeError</span><br><span class="line">      |    +-- NotImplementedError</span><br><span class="line">      |    +-- RecursionError</span><br><span class="line">      +-- SyntaxError</span><br><span class="line">      |    +-- IndentationError</span><br><span class="line">      |         +-- TabError</span><br><span class="line">      +-- SystemError</span><br><span class="line">      +-- TypeError</span><br><span class="line">      +-- ValueError</span><br><span class="line">      |    +-- UnicodeError</span><br><span class="line">      |         +-- UnicodeDecodeError</span><br><span class="line">      |         +-- UnicodeEncodeError</span><br><span class="line">      |         +-- UnicodeTranslateError</span><br><span class="line">      +-- Warning</span><br><span class="line">           +-- DeprecationWarning</span><br><span class="line">           +-- PendingDeprecationWarning</span><br><span class="line">           +-- RuntimeWarning</span><br><span class="line">           +-- SyntaxWarning</span><br><span class="line">           +-- UserWarning</span><br><span class="line">           +-- FutureWarning</span><br><span class="line">           +-- ImportWarning</span><br><span class="line">           +-- UnicodeWarning</span><br><span class="line">           +-- BytesWarning</span><br><span class="line">           +-- ResourceWarning</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-内置异常&quot;&gt;&lt;a href=&quot;#python-标准库-内置异常&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 内置异常&quot;&gt;&lt;/a&gt;python 标准库 内置异常&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200321_exception.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python standard_library pwd</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/20/python-standard-library-pwd/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/20/python-standard-library-pwd/</id>
    <published>2020-03-20T15:31:48.000Z</published>
    <updated>2020-03-22T15:54:04.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-pwd-用户密码数据库"><a href="#python-标准库-pwd-用户密码数据库" class="headerlink" title="python 标准库 pwd 用户密码数据库"></a>python 标准库 pwd 用户密码数据库</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200320_pwd.png?raw=true" alt></p><a id="more"></a><ul><li><p>此模块可以访问 Unix 用户账户名及密码数据库，在所有 Unix 版本上均可使用。</p><p>密码数据库中的条目以元组对象返回，属性对应 <code>passwd</code> 中的结构（属性如下所示，可参考 ）：</p><p>| 索引 | 属性        | 意义               |<br>| :— | :———- | :—————– |<br>| 0    | <code>pw_name</code>   | 登录名             |<br>| 1    | <code>pw_passwd</code> | 密码，可能已经加密 |<br>| 2    | <code>pw_uid</code>    | 用户 ID 数值       |<br>| 3    | <code>pw_gid</code>    | 组 ID 数值         |<br>| 4    | <code>pw_gecos</code>  | 用户名或备注       |<br>| 5    | <code>pw_dir</code>    | 用户主目录         |<br>| 6    | <code>pw_shell</code>  | 用户的命令解释器   |</p><p>其中 uid 和 gid 是整数，其他是字符串，如果找不到对应的项目，抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 异常。</p><p>注解:</p><p> 传统的 Unix 系统中，<code>pw_passwd</code> 的值通常使用 DES 导出的算法加密（参阅 <a href="https://docs.python.org/zh-cn/3.8/library/crypt.html#module-crypt" target="_blank" rel="noopener"><code>crypt</code></a> 模块）。不过现在的 unix 系统使用 <em>影子密码</em> 系统。在这些 unix 上，<em>pw_passwd</em> 只包含星号（<code>&#39;*&#39;</code>）或字母（<code>&#39;x&#39;</code>），而加密的密码存储在文件 <code>/etc/shadow</code> 中，此文件不是全局可读的。在 <em>pw_passwd</em> 中是否包含有用信息是系统相关的。如果可以访问到加密的密码，就需要使用 <a href="https://docs.python.org/zh-cn/3.8/library/spwd.html#module-spwd" target="_blank" rel="noopener"><code>spwd</code></a> 模块了。</p><p>本模块定义如下内容：</p><ul><li><p><code>pwd.getpwuid</code>(<em>uid</em>)</p><p>给定用户的数值 ID，返回密码数据库的对应项目。</p></li><li><p><code>pwd.getpwnam</code>(<em>name</em>)</p><p>给定用户名，返回密码数据库的对应项目。</p></li><li><p><code>pwd.getpwall</code>()</p><p>返回密码数据库中所有项目的列表，顺序不是固定的。</p></li></ul><p>参见:</p><ul><li><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/grp.html#module-grp" target="_blank" rel="noopener"><code>grp</code></a></p><p>针对用户组数据库的接口，与本模块类似。</p></li><li><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/spwd.html#module-spwd" target="_blank" rel="noopener"><code>spwd</code></a></p><p>针对影子密码数据库的接口，与本模块类似。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-pwd-用户密码数据库&quot;&gt;&lt;a href=&quot;#python-标准库-pwd-用户密码数据库&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 pwd 用户密码数据库&quot;&gt;&lt;/a&gt;python 标准库 pwd 用户密码数据库&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200320_pwd.png?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="pwd" scheme="https://pinghailinfeng.gitee.io/tags/pwd/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library dis</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/19/python-standard-library-dis/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/19/python-standard-library-dis/</id>
    <published>2020-03-19T13:40:45.000Z</published>
    <updated>2020-03-22T15:54:04.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-dis"><a href="#python-标准库-dis" class="headerlink" title="python 标准库 dis"></a>python 标准库 dis</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200319_boring.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词</p><p>boring  英 [bɔːd] 美 [bɔrd]  </p><p>n.钻孔；镗削；地质钻探；钻屑</p><p>adj.没趣的；令人厌倦（或厌烦）的</p><p>v.“bore”的现在分词</p><p>网络无聊的；令人厌烦的；乏味的</p></blockquote><p><strong>Source code:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dis.py" target="_blank" rel="noopener">Lib/dis.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/dis.html#module-dis" target="_blank" rel="noopener"><code>dis</code></a> 模块通过反汇编支持CPython的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytecode" target="_blank" rel="noopener">bytecode</a> 分析。该模块作为输入的 CPython 字节码在文件 <code>Include/opcode.h</code> 中定义，并由编译器和解释器使用。</p><p><strong>CPython implementation detail:</strong> 字节码是 CPython 解释器的实现细节。不保证不会在Python版本之间添加、删除或更改字节码。不应考虑将此模块的跨 Python VM 或 Python 版本的使用。</p><p><em>在 3.6 版更改:</em> 每条指令使用2个字节。以前字节数因指令而异。</p><p>示例：给出函数 <code>myfunc()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(alist)</span><br></pre></td></tr></table></figure><p>可以使用以下命令显示 <code>myfunc()</code> 的反汇编</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(myfunc)</span><br><span class="line">  <span class="number">2</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (len)</span><br><span class="line">              <span class="number">2</span> LOAD_FAST                <span class="number">0</span> (alist)</span><br><span class="line">              <span class="number">4</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">              <span class="number">6</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><p>(“2” 是行号)。</p><h2 id="字节码分析"><a href="#字节码分析" class="headerlink" title="字节码分析"></a>字节码分析</h2><p><em>3.4 新版功能.</em></p><p>字节码分析 API 允许将 Python 代码片段包装在 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Bytecode" target="_blank" rel="noopener"><code>Bytecode</code></a> 对象中，以便轻松访问已编译代码的详细信息。</p><ul><li><p><em>class</em> <code>dis.Bytecode</code>(<em>x</em>, <em>**, </em>first_line=None<em>, </em>current_offset=None*)</p><p>分析的字节码对应于函数、生成器、异步生成器、协程、方法、源代码字符串或代码对象（由 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#compile" target="_blank" rel="noopener"><code>compile()</code></a> 返回）。这是下面列出的许多函数的便利包装，最值得注意的是 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.get_instructions" target="_blank" rel="noopener"><code>get_instructions()</code></a> ，迭代于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Bytecode" target="_blank" rel="noopener"><code>Bytecode</code></a> 的实例产生字节码操作 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Instruction" target="_blank" rel="noopener"><code>Instruction</code></a> 的实例。如果 <em>first_line</em> 不是 <code>None</code> ，则表示应该为反汇编代码中的第一个源代码行报告的行号。否则，源行信息（如果有的话）直接来自反汇编的代码对象。如果 <em>current_offset</em> 不是 <code>None</code> ，则它指的是反汇编代码中的指令偏移量。设置它意味着 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Bytecode.dis" target="_blank" rel="noopener"><code>dis()</code></a> 将针对指定的操作码显示“当前指令”标记。<em>classmethod</em> <code>from_traceback</code>(<em>tb</em>)从给定回溯构造一个 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Bytecode" target="_blank" rel="noopener"><code>Bytecode</code></a> 实例，将设置 <em>current_offset</em> 为异常负责的指令。<code>codeobj</code>已编译的代码对象。<code>first_line</code>代码对象的第一个源代码行（如果可用）<code>dis</code>()返回字节码操作的格式化视图（与 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.dis" target="_blank" rel="noopener"><code>dis.dis()</code></a> 打印相同，但作为多行字符串返回）。<code>info</code>()返回带有关于代码对象的详细信息的格式化多行字符串，如 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.code_info" target="_blank" rel="noopener"><code>code_info()</code></a> 。<em>在 3.7 版更改:</em> 现在可以处理协程和异步生成器对象。</p></li></ul><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bytecode = dis.Bytecode(myfunc)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> instr <span class="keyword">in</span> bytecode:</span><br><span class="line"><span class="meta">... </span>    print(instr.opname)</span><br><span class="line">...</span><br><span class="line">LOAD_GLOBAL</span><br><span class="line">LOAD_FAST</span><br><span class="line">CALL_FUNCTION</span><br><span class="line">RETURN_VALUE</span><br></pre></td></tr></table></figure><h2 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/dis.html#module-dis" target="_blank" rel="noopener"><code>dis</code></a> 模块还定义了以下分析函数，它们将输入直接转换为所需的输出。如果只执行单个操作，它们可能很有用，因此中间分析对象没用：</p><ul><li><p><code>dis.code_info</code>(<em>x</em>)</p><p>返回格式化的多行字符串，其包含详细代码对象信息的用于被提供的函数、生成器、异步生成器、协程、方法、源代码字符串或代码对象。请注意，代码信息字符串的确切内容是高度依赖于实现的，它们可能会在Python VM或Python版本中任意更改。<em>3.2 新版功能.**在 3.7 版更改:</em> 现在可以处理协程和异步生成器对象。</p></li><li><p><code>dis.show_code</code>(<em>x</em>, <em>**, </em>file=None*)</p><p>将提供的函数、方法。源代码字符串或代码对象的详细代码对象信息打印到 <em>file</em> （如果未指定 <em>file</em> ，则为 <code>sys.stdout</code> ）。这是 <code>print(code_info(x), file=file)</code> 的便捷简写，用于在解释器提示符下进行交互式探索。<em>3.2 新版功能.**在 3.4 版更改:</em> 添加 <em>file</em> 形参。</p></li><li><p><code>dis.dis</code>(<em>x=None</em>, <em>**, </em>file=None<em>, </em>depth=None*)</p><p>反汇编 <em>x</em> 对象。 <em>x</em> 可以表示模块、类、方法、函数、生成器、异步生成器、协程、代码对象、源代码字符串或原始字节码的字节序列。对于模块，它会反汇编所有功能。对于一个类，它反汇编所有方法（包括类和静态方法）。对于代码对象或原始字节码序列，它每字节码指令打印一行。它还递归地反汇编嵌套代码对象（推导式代码，生成器表达式和嵌套函数，以及用于构建嵌套类的代码）。在被反汇编之前，首先使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#compile" target="_blank" rel="noopener"><code>compile()</code></a> 内置函数将字符串编译为代码对象。如果未提供任何对象，则此函数会反汇编最后一次回溯。如果提供的话，反汇编将作为文本写入提供的 <em>file</em> 参数，否则写入 <code>sys.stdout</code> 。递归的最大深度受 <em>depth</em> 限制，除非它是 <code>None</code> 。 <code>depth=0</code> 表示没有递归。<em>在 3.4 版更改:</em> 添加 <em>file</em> 形参。<em>在 3.7 版更改:</em> 实现了递归反汇编并添加了 <em>depth</em> 参数。<em>在 3.7 版更改:</em> 现在可以处理协程和异步生成器对象。</p></li><li><p><code>dis.distb</code>(<em>tb=None</em>, <em>**, </em>file=None*)</p><p>如果没有传递，则使用最后一个回溯来反汇编回溯的堆栈顶部函数。 指示了导致异常的指令。如果提供的话，反汇编将作为文本写入提供的 <em>file</em> 参数，否则写入 <code>sys.stdout</code> 。<em>在 3.4 版更改:</em> 添加 <em>file</em> 形参。</p></li><li><p><code>dis.disassemble</code>(<em>code</em>, <em>lasti=-1</em>, <em>**, </em>file=None*)</p></li><li><p><code>dis.disco</code>(<em>code</em>, <em>lasti=-1</em>, <em>**, </em>file=None*)</p><p>反汇编代码对象，如果提供了 <em>lasti</em> ，则指示最后一条指令。输出分为以下几列：行号，用于每行的第一条指令当前指令，表示为 <code>--&gt;</code> ，一个标记的指令，用 <code>&gt;&gt;</code> 表示，指令的地址，操作码名称，操作参数，和括号中参数的解释。参数解释识别本地和全局变量名称、常量值、分支目标和比较运算符。如果提供的话，反汇编将作为文本写入提供的 <em>file</em> 参数，否则写入 <code>sys.stdout</code> 。<em>在 3.4 版更改:</em> 添加 <em>file</em> 形参。</p></li><li><p><code>dis.get_instructions</code>(<em>x</em>, <em>**, </em>first_line=None*)</p><p>在所提供的函数、方法、源代码字符串或代码对象中的指令上返回一个迭代器。迭代器生成一系列 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Instruction" target="_blank" rel="noopener"><code>Instruction</code></a> ，命名为元组，提供所提供代码中每个操作的详细信息。如果 <em>first_line</em> 不是 <code>None</code> ，则表示应该为反汇编代码中的第一个源代码行报告的行号。否则，源行信息（如果有的话）直接来自反汇编的代码对象。<em>3.4 新版功能.</em></p></li><li><p><code>dis.findlinestarts</code>(<em>code</em>)</p><p>此生成器函数使用代码对象 <em>code</em> 的 <code>co_firstlineno</code> 和 <code>co_lnotab</code> 属性来查找源代码中行开头的偏移量。它们生成为 <code>(offset, lineno)</code> 对。请参阅 <a href="https://github.com/python/cpython/tree/3.8/objects/lnotab_notes.txt" target="_blank" rel="noopener">objects/lnotab_notes.txt</a> ，了解 <code>co_lnotab</code> 格式以及如何解码它。<em>在 3.6 版更改:</em> 行号可能会减少。 以前，他们总是在增加。</p></li><li><p><code>dis.findlabels</code>(<em>code</em>)</p><p>检测作为跳转目标的代码对象 <em>code</em> 中的所有偏移量，并返回这些偏移量的列表。</p></li><li><p><code>dis.stack_effect</code>(<em>opcode</em>, <em>oparg=None</em>, <em>**, </em>jump=None*)</p><p>使用参数 <em>oparg</em> 计算 <em>opcode</em> 的堆栈效果。如果代码有一个跳转目标并且 <em>jump</em> 是 <code>True</code> ，则 <code>drag_effect()</code> 将返回跳转的堆栈效果。如果 <em>jump</em> 是 <code>False</code> ，它将返回不跳跃的堆栈效果。如果 <em>jump</em> 是 <code>None</code> （默认值），它将返回两种情况的最大堆栈效果。<em>3.4 新版功能.**在 3.8 版更改:</em> 添加 <em>jump</em> 参数。</p></li></ul><h2 id="Python字节码说明"><a href="#Python字节码说明" class="headerlink" title="Python字节码说明"></a>Python字节码说明</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.get_instructions" target="_blank" rel="noopener"><code>get_instructions()</code></a> 函数和 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Bytecode" target="_blank" rel="noopener"><code>Bytecode</code></a> 类提供字节码指令的详细信息的 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#dis.Instruction" target="_blank" rel="noopener"><code>Instruction</code></a> 实例：</p><ul><li><p><em>class</em> <code>dis.Instruction</code></p><p>字节码操作的详细信息<code>opcode</code>操作的数字代码，对应于下面列出的操作码值和 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-collections" target="_blank" rel="noopener">操作码集合</a> 中的字节码值。<code>opname</code>人类可读的操作名称<code>arg</code>操作的数字参数（如果有的话），否则为 <code>Noneargval</code>已解析的 arg 值（如果已知），否则与 arg 相同<code>argrepr</code>人类可读的操作参数描述<code>offset</code>在字节码序列中启动操作索引<code>starts_line</code>行由此操作码（如果有）启动，否则为 <code>Noneis_jump_target</code>如果其他代码跳到这里，则为 <code>True</code> ，否则为 <code>False</code><em>3.4 新版功能.</em></p></li></ul><p>Python编译器当前生成以下字节码指令。</p><p><strong>一般指令</strong></p><ul><li><p><code>NOP</code></p><p>什么都不做。 用作字节码优化器的占位符。</p></li><li><p><code>POP_TOP</code></p><p>删除堆栈顶部（TOS）项。</p></li><li><p><code>ROT_TWO</code></p><p>交换两个最顶层的堆栈项。</p></li><li><p><code>ROT_THREE</code></p><p>将第二个和第三个堆栈项向上提升一个位置，顶项移动到位置三。</p></li><li><p><code>ROT_FOUR</code></p><p>将第二个，第三个和第四个堆栈项向上提升一个位置，将顶项移动到第四个位置。<em>3.8 新版功能.</em></p></li><li><p><code>DUP_TOP</code></p><p>复制堆栈顶部的引用。<em>3.2 新版功能.</em></p></li><li><p><code>DUP_TOP_TWO</code></p><p>复制堆栈顶部的两个引用，使它们保持相同的顺序。<em>3.2 新版功能.</em></p></li></ul><p><strong>一元操作</strong></p><p>一元操作获取堆栈顶部元素，应用操作，并将结果推回堆栈。</p><ul><li><p><code>UNARY_POSITIVE</code></p><p>实现 <code>TOS = +TOS</code> 。</p></li><li><p><code>UNARY_NEGATIVE</code></p><p>实现 <code>TOS = -TOS</code> 。</p></li><li><p><code>UNARY_NOT</code></p><p>实现 <code>TOS = not TOS</code> 。</p></li><li><p><code>UNARY_INVERT</code></p><p>实现 <code>TOS = ~TOS</code> 。</p></li><li><p><code>GET_ITER</code></p><p>实现 <code>TOS = iter(TOS)</code> 。</p></li><li><p><code>GET_YIELD_FROM_ITER</code></p><p>如果 <code>TOS</code> 是一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator-iterator" target="_blank" rel="noopener">generator iterator</a> 或 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 对象则保持原样。否则实现 <code>TOS = iter(TOS)</code> 。<em>3.5 新版功能.</em></p></li></ul><p><strong>二元操作</strong></p><p>二元操作从堆栈中删除堆栈顶部（TOS）和第二个最顶层堆栈项（TOS1）。 它们执行操作，并将结果放回堆栈。</p><ul><li><p><code>BINARY_POWER</code></p><p>实现 <code>TOS = TOS1 ** TOS</code> 。</p></li><li><p><code>BINARY_MULTIPLY</code></p><p>实现 <code>TOS = TOS1 * TOS</code> 。</p></li><li><p><code>BINARY_MATRIX_MULTIPLY</code></p><p>实现 <code>TOS = TOS1 @ TOS</code> 。<em>3.5 新版功能.</em></p></li><li><p><code>BINARY_FLOOR_DIVIDE</code></p><p>实现 <code>TOS = TOS1 // TOS</code>。</p></li><li><p><code>BINARY_TRUE_DIVIDE</code></p><p>实现 <code>TOS = TOS1 / TOS</code> 。</p></li><li><p><code>BINARY_MODULO</code></p><p>实现 <code>TOS = TOS1 % TOS</code> 。</p></li><li><p><code>BINARY_ADD</code></p><p>实现 <code>TOS = TOS1 + TOS</code> 。</p></li><li><p><code>BINARY_SUBTRACT</code></p><p>实现 <code>TOS = TOS1 - TOS</code> 。</p></li><li><p><code>BINARY_SUBSCR</code></p><p>实现 <code>TOS = TOS1[TOS]</code> 。</p></li><li><p><code>BINARY_LSHIFT</code></p><p>实现 <code>TOS = TOS1 &lt;&lt; TOS</code> 。</p></li><li><p><code>BINARY_RSHIFT</code></p><p>实现 <code>TOS = TOS1 &gt;&gt; TOS</code> 。</p></li><li><p><code>BINARY_AND</code></p><p>实现 <code>TOS = TOS1 &amp; TOS</code> 。</p></li><li><p><code>BINARY_XOR</code></p><p>实现 <code>TOS = TOS1 ^ TOS</code> 。</p></li><li><p><code>BINARY_OR</code></p><p>实现 <code>TOS = TOS1 | TOS</code> 。</p></li></ul><p><strong>就地操作</strong></p><p>就地操作就像二元操作，因为它们删除了TOS和TOS1，并将结果推回到堆栈上，但是当TOS1支持它时，操作就地完成，并且产生的TOS可能是（但不一定） 原来的TOS1。</p><ul><li><p><code>INPLACE_POWER</code></p><p>就地实现 <code>TOS = TOS1 ** TOS</code> 。</p></li><li><p><code>INPLACE_MULTIPLY</code></p><p>就地实现 <code>TOS = TOS1 * TOS</code> 。</p></li><li><p><code>INPLACE_MATRIX_MULTIPLY</code></p><p>就地实现 <code>TOS = TOS1 @ TOS</code> 。<em>3.5 新版功能.</em></p></li><li><p><code>INPLACE_FLOOR_DIVIDE</code></p><p>就地实现 <code>TOS = TOS1 // TOS</code> 。</p></li><li><p><code>INPLACE_TRUE_DIVIDE</code></p><p>就地实现 <code>TOS = TOS1 / TOS</code> 。</p></li><li><p><code>INPLACE_MODULO</code></p><p>就地实现 <code>TOS = TOS1 % TOS</code> 。</p></li><li><p><code>INPLACE_ADD</code></p><p>就地实现 <code>TOS = TOS1 + TOS</code> 。</p></li><li><p><code>INPLACE_SUBTRACT</code></p><p>就地实现 <code>TOS = TOS1 - TOS</code> 。</p></li><li><p><code>INPLACE_LSHIFT</code></p><p>就地实现 <code>TOS = TOS1 &lt;&lt; TOS</code> 。</p></li><li><p><code>INPLACE_RSHIFT</code></p><p>就地实现 <code>TOS = TOS1 &gt;&gt; TOS</code> 。</p></li><li><p><code>INPLACE_AND</code></p><p>就地实现 <code>TOS = TOS1 &amp; TOS</code> 。</p></li><li><p><code>INPLACE_XOR</code></p><p>就地实现 <code>TOS = TOS1 ^ TOS</code> 。</p></li><li><p><code>INPLACE_OR</code></p><p>就地实现 <code>TOS = TOS1 | TOS</code> 。</p></li><li><p><code>STORE_SUBSCR</code></p><p>实现 <code>TOS1[TOS] = TOS2</code> 。</p></li><li><p><code>DELETE_SUBSCR</code></p><p>实现 <code>del TOS1[TOS]</code> 。</p></li></ul><p><strong>协程操作码</strong></p><ul><li><p><code>GET_AWAITABLE</code></p><p>实现 <code>TOS = get_awaitable(TOS)</code> ，其中 <code>get_awaitable(o)</code> 返回 <code>o</code> 如果 <code>o</code> 是一个有 CO_ITERABLE_COROUTINE 标志的协程对象或生成器对象，否则解析 <code>o.__await__</code> 。<em>3.5 新版功能.</em></p></li><li><p><code>GET_AITER</code></p><p>实现 <code>TOS = TOS.__aiter__()</code> 。<em>3.5 新版功能.**在 3.7 版更改:</em> 已经不再支持从 <code>__aiter__</code> 返回可等待对象。</p></li><li><p><code>GET_ANEXT</code></p><p>实现 <code>PUSH(get_awaitable(TOS.__anext__()))</code> 。参见 <code>GET_AWAITABLE</code> 获取更多 <code>get_awaitable</code> 的细节<em>3.5 新版功能.</em></p></li><li><p><code>END_ASYNC_FOR</code></p><p>终止一个 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-for" target="_blank" rel="noopener"><code>async for</code></a> 循环。处理等待下一个项目时引发的异常。如果 TOS 是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopAsyncIteration" target="_blank" rel="noopener"><code>StopAsyncIteration</code></a>， 从堆栈弹出7个值，并使用后三个恢复异常状态。否则，使用堆栈中的三个值重新引发异常。从块堆栈中删除异常处理程序块。<em>3.8 新版功能.</em></p></li><li><p><code>BEFORE_ASYNC_WITH</code></p><p>从栈顶对象解析 <code>__aenter__</code> 和 <code>__aexit__</code> 。将 <code>__aexit__</code> 和 <code>__aenter__()</code> 的结果推入堆栈。<em>3.5 新版功能.</em></p></li><li><p><code>SETUP_ASYNC_WITH</code></p><p>创建一个新的帧对象。<em>3.5 新版功能.</em></p></li></ul><p><strong>其他操作码</strong></p><ul><li><p><code>PRINT_EXPR</code></p><p>实现交互模式的表达式语句。TOS从堆栈中被移除并打印。在非交互模式下，表达式语句以 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-POP_TOP" target="_blank" rel="noopener"><code>POP_TOP</code></a> 终止。</p></li><li><p><code>SET_ADD</code>(<em>i</em>)</p><p>调用 <code>set.add(TOS1[-i], TOS)</code> 。 用于实现集合推导。</p></li><li><p><code>LIST_APPEND</code>(<em>i</em>)</p><p>调用 <code>list.append(TOS[-i], TOS)</code> 。 用于实现列表推导。</p></li><li><p><code>MAP_ADD</code>(<em>i</em>)</p><p>调用 <code>dict.__setitem__(TOS1[-i], TOS1, TOS)</code> 。 用于实现字典推导。<em>3.1 新版功能.**在 3.8 版更改:</em> 映射值为 TOS ，映射键为 TOS1 。之前，它们被颠倒了。</p></li></ul><p>对于所有 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-SET_ADD" target="_blank" rel="noopener"><code>SET_ADD</code></a> 、 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-LIST_APPEND" target="_blank" rel="noopener"><code>LIST_APPEND</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-MAP_ADD" target="_blank" rel="noopener"><code>MAP_ADD</code></a> 指令，当弹出添加的值或键值对时，容器对象保留在堆栈上，以便它可用于循环的进一步迭代。</p><ul><li><p><code>RETURN_VALUE</code></p><p>返回 TOS 到函数的调用者。</p></li><li><p><code>YIELD_VALUE</code></p><p>弹出 TOS 并从一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 生成它。</p></li><li><p><code>YIELD_FROM</code></p><p>弹出 TOS 并将其委托给它作为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 的子迭代器。<em>3.3 新版功能.</em></p></li><li><p><code>SETUP_ANNOTATIONS</code></p><p>检查 <code>__annotations__</code> 是否在 <code>locals()</code> 中定义，如果没有，它被设置为空 <code>dict</code> 。只有在类或模块体静态地包含 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-variable-annotation" target="_blank" rel="noopener">variable annotations</a> 时才会发出此操作码。<em>3.6 新版功能.</em></p></li><li><p><code>IMPORT_STAR</code></p><p>将所有不以 <code>&#39;_&#39;</code> 开头的符号直接从模块 TOS 加载到局部命名空间。加载所有名称后弹出该模块。这个操作码实现了 <code>from module import *</code> 。</p></li><li><p><code>POP_BLOCK</code></p><p>从块堆栈中删除一个块。有一块堆栈，每帧用于表示 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句等。</p></li><li><p><code>POP_EXCEPT</code></p><p>从块堆栈中删除一个块。 弹出的块必须是异常处理程序块，在进入 except 处理程序时隐式创建。除了从帧堆栈弹出无关值之外，最后三个弹出值还用于恢复异常状态。</p></li><li><p><code>POP_FINALLY</code>(<em>preserve_tos</em>)</p><p>清除值堆栈和块堆栈。如果 <em>preserve_tos</em> 不是 <code>0</code> ，则在执行其他堆栈操作后，首先从堆栈中弹出 TOS 并将其推入堆栈：如果TOS是 <code>NULL</code> 或整数（由 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BEGIN_FINALLY" target="_blank" rel="noopener"><code>BEGIN_FINALLY</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-CALL_FINALLY" target="_blank" rel="noopener"><code>CALL_FINALLY</code></a> 推入），它将从堆栈中弹出。如果TOS是异常类型（在引发异常时被推入），则从堆栈中弹出6个值，最后三个弹出值用于恢复异常状态。从块堆栈中删除异常处理程序块。它类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-END_FINALLY" target="_blank" rel="noopener"><code>END_FINALLY</code></a> ，但不会更改字节码计数器也不会引发异常。用于在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 块中实现 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#break" target="_blank" rel="noopener"><code>break</code></a> 、 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#continue" target="_blank" rel="noopener"><code>continue</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#return" target="_blank" rel="noopener"><code>return</code></a> 。<em>3.8 新版功能.</em></p></li><li><p><code>BEGIN_FINALLY</code></p><p>将 <code>NULL</code> 推入堆栈以便在以下操作中使用 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-END_FINALLY" target="_blank" rel="noopener"><code>END_FINALLY</code></a> 、 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-POP_FINALLY" target="_blank" rel="noopener"><code>POP_FINALLY</code></a> 、 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-WITH_CLEANUP_START" target="_blank" rel="noopener"><code>WITH_CLEANUP_START</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-WITH_CLEANUP_FINISH" target="_blank" rel="noopener"><code>WITH_CLEANUP_FINISH</code></a> 。开始 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 块。<em>3.8 新版功能.</em></p></li><li><p><code>END_FINALLY</code></p><p>终止 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句。解释器回溯是否有必须重新抛出异常的情况或根据 TOS 的值继续执行。如果 TOS 是 <code>NULL</code> （由 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BEGIN_FINALLY" target="_blank" rel="noopener"><code>BEGIN_FINALLY</code></a> 推入）继续下一条指令。 TOS 被弹出。如果 TO S是一个整数（由 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-CALL_FINALLY" target="_blank" rel="noopener"><code>CALL_FINALLY</code></a> 推入），则将字节码计数器设置为 TOS 。 TOS 被弹出。如果TOS是异常类型（在引发异常时被推送），则从堆栈中弹出 6 个值，前三个弹出值用于重新引发异常，最后三个弹出值用于恢复异常状态。从块堆栈中删除异常处理程序块。</p></li><li><p><code>LOAD_BUILD_CLASS</code></p><p>将 <code>builtins .__ build_class__()</code> 推到堆栈上。它之后被 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-CALL_FUNCTION" target="_blank" rel="noopener"><code>CALL_FUNCTION</code></a> 调用来构造一个类。</p></li><li><p><code>SETUP_WITH</code>(<em>delta</em>)</p><p>此操作码在 with 块开始之前执行多个操作。首先，它从上下文管理器加载 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 并将其推入到堆栈以供以后被 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-WITH_CLEANUP_START" target="_blank" rel="noopener"><code>WITH_CLEANUP_START</code></a> 使用。然后，调用 <code>__enter__()</code> ，并推入指向 <em>delta</em> 的 finally 块。最后，调用 <code>__enter__()</code> 方法的结果被压入堆栈。一个操作码将忽略它（ <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-POP_TOP" target="_blank" rel="noopener"><code>POP_TOP</code></a> ），或将其存储在一个或多个变量（ <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-STORE_FAST" target="_blank" rel="noopener"><code>STORE_FAST</code></a> 、 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-STORE_NAME" target="_blank" rel="noopener"><code>STORE_NAME</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-UNPACK_SEQUENCE" target="_blank" rel="noopener"><code>UNPACK_SEQUENCE</code></a> ）中。<em>3.2 新版功能.</em></p></li><li><p><code>WITH_CLEANUP_START</code></p><p>当 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句块退出时，开始清理堆栈。在堆栈的顶部是 <code>NULL</code> （由 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BEGIN_FINALLY" target="_blank" rel="noopener"><code>BEGIN_FINALLY</code></a> 推送）或者如果在 with 块中引发了异常，则推送 6 个值。下面是上下文管理器 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__aexit__" target="_blank" rel="noopener"><code>__aexit__()</code></a> 绑定方法。如果TOS是 <code>NULL</code> ，则调用 <code>SECOND(None, None, None)</code> ，从堆栈中删除函数，离开 TOS ，并将 <code>None</code> 推送到堆栈。 否则调用 <code>SEVENTH(TOP, SECOND, THIRD)</code> ，将堆栈的底部3值向下移动，用 <code>NULL</code> 替换空位并推入 TOS 。最后拖入调用的结果。</p></li><li><p><code>WITH_CLEANUP_FINISH</code></p><p>当 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句块退出时，完成清理堆栈。TOS 是 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-WITH_CLEANUP_START" target="_blank" rel="noopener"><code>WITH_CLEANUP_START</code></a> 推送的 <code>__exit__()</code> 或 <code>__aexit__()</code> 函数的结果。 SECOND是 <code>None</code> 或异常类型（引发异常时推入的）。从堆栈中弹出两个值。如果 SECOND 不为 None 并且 TOS 为 true ，则展开 EXCEPT_HANDLER 块，该块是在捕获异常时创建的，并将 <code>NULL</code> 推入堆栈。</p></li></ul><p>以下所有操作码均使用其参数。</p><ul><li><p><code>STORE_NAME</code>(<em>namei</em>)</p><p>实现 <code>name = TOS</code>。 <em>namei</em> 是 <em>name</em> 在代码对象的 <code>co_names</code> 属性中的索引。 在可能的情况下，编译器会尝试使用 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-STORE_FAST" target="_blank" rel="noopener"><code>STORE_FAST</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-STORE_GLOBAL" target="_blank" rel="noopener"><code>STORE_GLOBAL</code></a>。</p></li><li><p><code>DELETE_NAME</code>(<em>namei</em>)</p><p>实现 <code>del name</code> ，其中 <em>namei</em> 是代码对象的 <code>co_names</code> 属性的索引。</p></li><li><p><code>UNPACK_SEQUENCE</code>(<em>count</em>)</p><p>将 TOS 解包为 <em>count</em> 个单独的值，它们将按从右至左的顺序被放入堆栈。</p></li><li><p><code>UNPACK_EX</code>(<em>counts</em>)</p><p>实现使用带星号的目标进行赋值：将 TOS 中的可迭代对象解包为单独的值，其中值的总数可以小于可迭代对象中的项数：新值之一将是由所有剩余项构成的列表。<em>counts</em> 的低字节是列表值之前的值的数量，<em>counts</em> 中的高字节则是之后的值的数量。 结果值会按从右至左的顺序入栈。</p></li><li><p><code>STORE_ATTR</code>(<em>namei</em>)</p><p>实现 <code>TOS.name = TOS1</code>，其中 <em>namei</em> 是 name 在 <code>co_names</code> 中的索引号。</p></li><li><p><code>DELETE_ATTR</code>(<em>namei</em>)</p><p>实现 <code>del TOS.name</code>，使用 <em>namei</em> 作为 <code>co_names</code> 中的索引号。</p></li><li><p><code>STORE_GLOBAL</code>(<em>namei</em>)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-STORE_NAME" target="_blank" rel="noopener"><code>STORE_NAME</code></a> 但会将 name 存储为全局变量。</p></li><li><p><code>DELETE_GLOBAL</code>(<em>namei</em>)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-DELETE_NAME" target="_blank" rel="noopener"><code>DELETE_NAME</code></a> 但会删除一个全局变量。</p></li><li><p><code>LOAD_CONST</code>(<em>consti</em>)</p><p>将 <code>co_consts[consti]</code> 推入栈顶。</p></li><li><p><code>LOAD_NAME</code>(<em>namei</em>)</p><p>将与 <code>co_names[namei]</code> 相关联的值推入栈顶。</p></li><li><p><code>BUILD_TUPLE</code>(<em>count</em>)</p><p>创建一个使用了来自栈的 <em>count</em> 个项的元组，并将结果元组推入栈顶。</p></li><li><p><code>BUILD_LIST</code>(<em>count</em>)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_TUPLE" target="_blank" rel="noopener"><code>BUILD_TUPLE</code></a> 但会创建一个列表。</p></li><li><p><code>BUILD_SET</code>(<em>count</em>)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_TUPLE" target="_blank" rel="noopener"><code>BUILD_TUPLE</code></a> 但会创建一个集合。</p></li><li><p><code>BUILD_MAP</code>(<em>count</em>)</p><p>将一个新字典对象推入栈顶。 弹出 <code>2 * count</code> 项使得字典包含 <em>count</em> 个条目: <code>{..., TOS3: TOS2, TOS1: TOS}</code>。<em>在 3.5 版更改:</em> 字典是根据栈中的项创建而不是创建一个预设大小包含 <em>count</em> 项的空字典。</p></li><li><p><code>BUILD_CONST_KEY_MAP</code>(<em>count</em>)</p><p>专用于常量键的 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_MAP" target="_blank" rel="noopener"><code>BUILD_MAP</code></a> 版本。 <em>count</em> 值是从栈中提取的。 栈顶的元素包含一个由键构成的元组。<em>3.6 新版功能.</em></p></li><li><p><code>BUILD_STRING</code>(<em>count</em>)</p><p>拼接 <em>count</em> 个来自栈的字符串并将结果字符串推入栈顶。<em>3.6 新版功能.</em></p></li><li><p><code>BUILD_TUPLE_UNPACK</code>(<em>count</em>)</p><p>从栈中弹出 <em>count</em> 个可迭代对象，将它们合并为单个元组，并将结果推入栈顶。 实现可迭代对象解包为元组形式 <code>(*x, *y, *z)</code>。<em>3.5 新版功能.</em></p></li><li><p><code>BUILD_TUPLE_UNPACK_WITH_CALL</code>(<em>count</em>)</p><p>这类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_TUPLE_UNPACK" target="_blank" rel="noopener"><code>BUILD_TUPLE_UNPACK</code></a> 但专用于 <code>f(*x, *y, *z)</code> 调用语法。 栈中 <code>count + 1</code> 位置上的项应当是相应的可调用对象 <code>f</code>。<em>3.6 新版功能.</em></p></li><li><p><code>BUILD_LIST_UNPACK</code>(<em>count</em>)</p><p>这类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_TUPLE_UNPACK" target="_blank" rel="noopener"><code>BUILD_TUPLE_UNPACK</code></a> 但会将一个列表而非元组推入栈顶。 实现可迭代对象解包为列表形式 <code>[*x, *y, *z]</code>。<em>3.5 新版功能.</em></p></li><li><p><code>BUILD_SET_UNPACK</code>(<em>count</em>)</p><p>这类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_TUPLE_UNPACK" target="_blank" rel="noopener"><code>BUILD_TUPLE_UNPACK</code></a> 但会将一个集合而非元组推入栈顶。 实现可迭代对象解包为集合形式 <code>{*x, *y, *z}</code>。<em>3.5 新版功能.</em></p></li><li><p><code>BUILD_MAP_UNPACK</code>(<em>count</em>)</p><p>从栈中弹出 <em>count</em> 个映射对象，将它们合并为单个字典，并将结果推入栈顶。 实现字典解包为字典形式 <code>{**x, **y, **z}</code>。<em>3.5 新版功能.</em></p></li><li><p><code>BUILD_MAP_UNPACK_WITH_CALL</code>(<em>count</em>)</p><p>这类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_MAP_UNPACK" target="_blank" rel="noopener"><code>BUILD_MAP_UNPACK</code></a> 但专用于 <code>f(**x, **y, **z)</code> 调用语法。 栈中 <code>count + 2</code> 位置上的项应当是相应的可调用对象 <code>f</code>。<em>3.5 新版功能.**在 3.6 版更改:</em> 可迭代对象的位置的确定方式是将操作码参数加 2 而不是将其编码到参数的第二个字节。</p></li><li><p><code>LOAD_ATTR</code>(<em>namei</em>)</p><p>将 TOS 替换为 <code>getattr(TOS, co_names[namei])</code>。</p></li><li><p><code>COMPARE_OP</code>(<em>opname</em>)</p><p>执行布尔运算操作。 操作名称可在 <code>cmp_op[opname]</code> 中找到。</p></li><li><p><code>IMPORT_NAME</code>(<em>namei</em>)</p><p>导入模块 <code>co_names[namei]</code>。 会弹出 TOS 和 TOS1 以提供 <em>fromlist</em> 和 <em>level</em> 参数给 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a>。 模块对象会被推入栈顶。 当前命名空间不受影响：对于一条标准 import 语句，会执行后续的 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-STORE_FAST" target="_blank" rel="noopener"><code>STORE_FAST</code></a> 指令来修改命名空间。</p></li><li><p><code>IMPORT_FROM</code>(<em>namei</em>)</p><p>从在 TOS 内找到的模块中加载属性 <code>co_names[namei]</code>。 结果对象会被推入栈顶，以便由后续的 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-STORE_FAST" target="_blank" rel="noopener"><code>STORE_FAST</code></a> 指令来保存。</p></li><li><p><code>JUMP_FORWARD</code>(<em>delta</em>)</p><p>将字节码计数器的值增加 <em>delta</em>。</p></li><li><p><code>POP_JUMP_IF_TRUE</code>(<em>target</em>)</p><p>如果 TOS 为真值，则将字节码计数器的值设为 <em>target</em>。 TOS 会被弹出。<em>3.1 新版功能.</em></p></li><li><p><code>POP_JUMP_IF_FALSE</code>(<em>target</em>)</p><p>如果 TOS 为假值，则将字节码计数器的值设为 <em>target</em>。 TOS 会被弹出。<em>3.1 新版功能.</em></p></li><li><p><code>JUMP_IF_TRUE_OR_POP</code>(<em>target</em>)</p><p>如果 TOS 为真值，则将字节码计数器的值设为 <em>target</em> 并将 TOS 留在栈顶。 否则（如 TOS 为假值），TOS 会被弹出。<em>3.1 新版功能.</em></p></li><li><p><code>JUMP_IF_FALSE_OR_POP</code>(<em>target</em>)</p><p>如果 TOS 为假值，则将字节码计数器的值设为 <em>target</em> 并将 TOS 留在栈顶。 否则（如 TOS 为假值），TOS 会被弹出。<em>3.1 新版功能.</em></p></li><li><p><code>JUMP_ABSOLUTE</code>(<em>target</em>)</p><p>将字节码计数器的值设为 <em>target</em>。</p></li><li><p><code>FOR_ITER</code>(<em>delta</em>)</p><p>TOS 是一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a>。 可调用它的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法。 如果产生了一个新值，则将其推入栈顶（将迭代器留在其下方）。 如果迭代器提示已耗尽则 TOS 会被弹出，并将字节码计数器的值增加 <em>delta</em>。</p></li><li><p><code>LOAD_GLOBAL</code>(<em>namei</em>)</p><p>加载名称为 <code>co_names[namei]</code> 的全局对象推入栈顶。</p></li><li><p><code>SETUP_FINALLY</code>(<em>delta</em>)</p><p>将一个来自 try-finally 或 try-except 子句的 try 代码块推入代码块栈顶。 相对 finally 代码块或第一个 except 代码块 <em>delta</em> 个点数。</p></li><li><p><code>CALL_FINALLY</code>(<em>delta</em>)</p><p>将下一条指令的地址推入栈顶并将字节码计数器的值增加 <em>delta</em>。 用于将 finally 代码块作为一个“子例程”调用。<em>3.8 新版功能.</em></p></li><li><p><code>LOAD_FAST</code>(<em>var_num</em>)</p><p>将指向局部对象 <code>co_varnames[var_num]</code> 的引用推入栈顶。</p></li><li><p><code>STORE_FAST</code>(<em>var_num</em>)</p><p>将 TOS 存放到局部对象 <code>co_varnames[var_num]</code>。</p></li><li><p><code>DELETE_FAST</code>(<em>var_num</em>)</p><p>移除局部对象 <code>co_varnames[var_num]</code>。</p></li><li><p><code>LOAD_CLOSURE</code>(<em>i</em>)</p><p>将一个包含在单元的第 <em>i</em> 个空位中的对单元的引用推入栈顶并释放可用的存储空间。 如果 <em>i</em> 小于 <em>co_cellvars</em> 的长度则变量的名称为 <code>co_cellvars[i]</code>。 否则为 <code>co_freevars[i - len(co_cellvars)]</code>。</p></li><li><p><code>LOAD_DEREF</code>(<em>i</em>)</p><p>加载包含在单元的第 <em>i</em> 个空位中的单元并释放可用的存储空间。 将一个对单元所包含对象的引用推入栈顶。</p></li><li><p><code>LOAD_CLASSDEREF</code>(<em>i</em>)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-LOAD_DEREF" target="_blank" rel="noopener"><code>LOAD_DEREF</code></a> 但在查询单元之前会首先检查局部对象字典。 这被用于加载类语句体中的自由变量。<em>3.4 新版功能.</em></p></li><li><p><code>STORE_DEREF</code>(<em>i</em>)</p><p>将 TOS 存放到包含在单元的第 <em>i</em> 个空位中的单元内并释放可用存储空间。</p></li><li><p><code>DELETE_DEREF</code>(<em>i</em>)</p><p>清空包含在单元的第 <em>i</em> 个空位中的单元并释放可用存储空间。 被用于 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#del" target="_blank" rel="noopener"><code>del</code></a> 语句。<em>3.2 新版功能.</em></p></li><li><p><code>RAISE_VARARGS</code>(<em>argc</em>)</p><p>使用 <code>raise</code> 语句的 3 种形式之一引发异常，具体形式取决于 <em>argc</em> 的值：0: <code>raise</code> (重新引发之前的异常)1: <code>raise TOS</code> (在 <code>TOS</code> 上引发异常实例或类型)2: <code>raise TOS1 from TOS</code> (在 <code>TOS1</code> 上引发异常实例或类型并将 <code>__cause__</code> 设为 <code>TOS</code>)</p></li><li><p><code>CALL_FUNCTION</code>(<em>argc</em>)</p><p>调用一个可调用对象并传入位置参数。 <em>argc</em> 指明位置参数的数量。 栈顶包含位置参数，其中最右边的参数在最顶端。 在参数之下是一个待调用的可调用对象。 <code>CALL_FUNCTION</code> 会从栈中弹出所有参数以及可调用对象，附带这些参数调用该可调用对象，并将可调用对象所返回的返回值推入栈顶。<em>在 3.6 版更改:</em> 此操作码仅用于附带位置参数的调用。</p></li><li><p><code>CALL_FUNCTION_KW</code>(<em>argc</em>)</p><p>调用一个可调用对象并传入位置参数（如果有的话）和关键字参数。 <em>argc</em> 指明位置参数和关键字参数的总数量。 栈顶元素包含一个关键字参数名称的元组。 在元组之下是根据元组排序的关键字参数。 在关键字参数之下是位置参数，其中最右边的参数在最顶端。 在参数之下是一个待调用的可调用对象。 <code>CALL_FUNCTION_KW</code> 会从栈中弹出所有参数以及可调用对象，附带这些参数调用该可调用对象，并将可调用对象所返回的返回值推入栈顶。<em>在 3.6 版更改:</em> 关键字参数会被打包为一个元组而非字典，<em>argc</em> 指明参数的总数量。</p></li><li><p><code>CALL_FUNCTION_EX</code>(<em>flags</em>)</p><p>调用一个可调用对象并附带位置参数和关键字参数变量集合。 如果设置了 <em>flags</em> 的最低位，则栈顶包含一个由额外关键字参数组成的映射对象。 在该对象之下是一个包含位置参数的可迭代对象和一个待调用的可调用对象。 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_MAP_UNPACK_WITH_CALL" target="_blank" rel="noopener"><code>BUILD_MAP_UNPACK_WITH_CALL</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-BUILD_TUPLE_UNPACK_WITH_CALL" target="_blank" rel="noopener"><code>BUILD_TUPLE_UNPACK_WITH_CALL</code></a> 可用于合并多个映射对象和包含参数的可迭代对象。 在该可调用对象被调用之前，映射对象和可迭代对象会被分别“解包”并将它们的内容分别作为关键字参数和位置参数传入。 <code>CALL_FUNCTION_EX</code> 会从栈中弹出所有参数以及可调用对象，附带这些参数调用该可调用对象，并将可调用对象所返回的返回值推入栈顶。<em>3.6 新版功能.</em></p></li><li><p><code>LOAD_METHOD</code>(<em>namei</em>)</p><p>从 TOS 对象加载一个名为 <code>co_names[namei]</code> 的方法。 TOS 将被弹出。 此字节码可区分两种情况：如果 TOS 有一个名称正确的方法，字节码会将未绑定方法和 TOS 推入栈顶。 TOS 将在调用未绑定方法时被用作 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-CALL_METHOD" target="_blank" rel="noopener"><code>CALL_METHOD</code></a> 的第一个参数 (<code>self</code>)。 否则会将 <code>NULL</code> 和属性查找所返回的对象推入栈顶。<em>3.7 新版功能.</em></p></li><li><p><code>CALL_METHOD</code>(<em>argc</em>)</p><p>调用一个方法。 <em>argc</em> 是位置参数的数量。 关键字参数不受支持。 此操作码被设计用于配合 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-LOAD_METHOD" target="_blank" rel="noopener"><code>LOAD_METHOD</code></a> 使用。 位置参数放在栈顶。 在它们之下放在栈中的是由 <a href="https://docs.python.org/zh-cn/3.8/library/dis.html#opcode-LOAD_METHOD" target="_blank" rel="noopener"><code>LOAD_METHOD</code></a> 所描述的两个条目（或者是 <code>self</code> 和一个未绑定方法对象，或者是 <code>NULL</code> 和一个任意可调用对象）。 它们会被全部弹出并将返回值推入栈顶。<em>3.7 新版功能.</em></p></li><li><p><code>MAKE_FUNCTION</code>(<em>flags</em>)</p><p>将一个新函数对象推入栈顶。 从底端到顶端，如果参数带有指定的旗标值则所使用的栈必须由这些值组成。<code>0x01</code> 一个默认值的元组，用于按位置排序的仅限位置形参以及位置或关键字形参<code>0x02</code> 一个仅限关键字形参的默认值的字典<code>0x04</code> 是一个标注字典<code>0x08</code> 一个包含用于自由变量的单元的元组，生成一个闭包与函数相关联的代码 (在 TOS1)函数的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-qualified-name" target="_blank" rel="noopener">qualified name</a> (在 TOS)</p></li><li><p><code>BUILD_SLICE</code>(<em>argc</em>)</p><p>将一个切片对象推入栈顶。 <em>argc</em> 必须为 2 或 3。 如果为 2，则推入 <code>slice(TOS1, TOS)</code>；如果为 3，则推入 <code>slice(TOS2, TOS1, TOS)</code>。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#slice" target="_blank" rel="noopener"><code>slice()</code></a> 内置函数了解详细信息。</p></li><li><p><code>EXTENDED_ARG</code>(<em>ext</em>)</p><p>为任意带有大到无法放入默认的单字节的参数的操作码添加前缀。 <em>ext</em> 存放一个附加字节作为参数中的高比特位。 对于每个操作码，最多允许三个 <code>EXTENDED_ARG</code> 前缀，构成两字节到三字节的参数。</p></li><li><p><code>FORMAT_VALUE</code>(<em>flags</em>)</p><p>用于实现格式化字面值字符串（f-字符串）。 从栈中弹出一个可选的 <em>fmt_spec</em>，然后是一个必须的 <em>value</em>。 <em>flags</em> 的解读方式如下：<code>(flags &amp; 0x03) == 0x00</code>: <em>value</em> 按原样格式化。<code>(flags &amp; 0x03) == 0x01</code>: 在格式化 <em>value</em> 之前调用其 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a>。<code>(flags &amp; 0x03) == 0x02</code>: 在格式化 <em>value</em> 之前调用其 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a>。<code>(flags &amp; 0x03) == 0x03</code>: 在格式化 <em>value</em> 之前调用其 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#ascii" target="_blank" rel="noopener"><code>ascii()</code></a>。<code>(flags &amp; 0x04) == 0x04</code>: 从栈中弹出 <em>fmt_spec</em> 并使用它，否则使用空的 <em>fmt_spec</em>。使用 <code>PyObject_Format()</code> 执行格式化。 结果会被推入栈顶。<em>3.6 新版功能.</em></p></li><li><p><code>HAVE_ARGUMENT</code></p><p>这不是一个真正的操作码。 它用于标明使用参数和不使用参数的操作码 (分别为 <code>&lt; HAVE_ARGUMENT</code> 和 <code>&gt;= HAVE_ARGUMENT</code>) 之间的分隔线。<em>在 3.6 版更改:</em> 现在每条指令都带有参数，但操作码 <code>&lt; HAVE_ARGUMENT</code> 会忽略它。 之前仅限操作码 <code>&gt;= HAVE_ARGUMENT</code> 带有参数。</p></li></ul><h2 id="操作码集合"><a href="#操作码集合" class="headerlink" title="操作码集合"></a>操作码集合</h2><p>提供这些集合用于字节码指令的自动内省：</p><ul><li><p><code>dis.opname</code></p><p>操作名称的序列，可使用字节码来索引。</p></li><li><p><code>dis.opmap</code></p><p>映射操作名称到字节码的字典</p></li><li><p><code>dis.cmp_op</code></p><p>所有比较操作名称的序列。</p></li><li><p><code>dis.hasconst</code></p><p>访问常量的字节码序列。</p></li><li><p><code>dis.hasfree</code></p><p>访问自由变量的字节码序列（请注意这里所说的‘自由’是指在当前作用域中被内部作用域所引用的名称，或在外部作用域中被此作用域所引用的名称。 它 <em>并不</em> 包括对全局或内置作用域的引用）。</p></li><li><p><code>dis.hasname</code></p><p>按名称访问属性的字节码序列。</p></li><li><p><code>dis.hasjrel</code></p><p>具有相对跳转目标的字节码序列。</p></li><li><p><code>dis.hasjabs</code></p><p>具有绝对跳转目标的字节码序列。</p></li><li><p><code>dis.haslocal</code></p><p>访问局部变量的字节码序列。</p></li><li><p><code>dis.hascompare</code></p><p>布尔运算的字节码序列。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-dis&quot;&gt;&lt;a href=&quot;#python-标准库-dis&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 dis&quot;&gt;&lt;/a&gt;python 标准库 dis&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200319_boring.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="dis" scheme="https://pinghailinfeng.gitee.io/tags/dis/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library re</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/18/python-standard-library-re/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/18/python-standard-library-re/</id>
    <published>2020-03-18T13:30:04.000Z</published>
    <updated>2020-03-22T15:54:04.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-re-正则表达式"><a href="#python-标准库-re-正则表达式" class="headerlink" title="python 标准库 re 正则表达式"></a>python 标准库 re 正则表达式</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200318_china.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>此生无悔入华夏,来世愿在种花家。</p></blockquote><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/re.py" target="_blank" rel="noopener">Lib/re.py</a></p><hr><p>这个模块提供了与 Perl 语言类似的正则表达式匹配操作。</p><p>模式和被搜索的字符串既可以是 Unicode 字符串 (<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>) ，也可以是8位字节串 (<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>)。 但是，Unicode 字符串与8位字节串不能混用：也就是说，你不能用一个字节串模式去匹配 Unicode 字符串，反之亦然；类似地，当进行替换操作时，替换字符串的类型也必须与所用的模式和搜索字符串的类型一致。</p><p>正则表达式使用反斜杠字符 (<code>&#39;\&#39;</code>) 来表示特殊形式或是允许在使用特殊字符时不引发它们的特殊含义。 这会与 Python 的字符串字面值中对相同字符出于相同目的的用法产生冲突；例如，要匹配一个反斜杠字面值，用户可能必须写成 <code>&#39;\\\\&#39;</code> 来作为模式字符串，因为正则表达式必须为 <code>\\</code>，而每个反斜杠在普通 Python 字符串字面值中又必须表示为 <code>\\</code>。 而且还要注意，在 Python 的字符串字面值中使用的反斜杠如果有任何无效的转义序列，现在将会产生 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#DeprecationWarning" target="_blank" rel="noopener"><code>DeprecationWarning</code></a> 并将在未来改为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a>。 此行为即使对于正则表达式来说有效的转义字符同样会发生。</p><p>解决办法是对于正则表达式样式使用 Python 的原始字符串表示法；在带有 <code>&#39;r&#39;</code> 前缀的字符串字面值中，反斜杠不必做任何特殊处理。 因此 <code>r&quot;\n&quot;</code> 表示包含 <code>&#39;\&#39;</code> 和 <code>&#39;n&#39;</code> 两个字符的字符串，而 <code>&quot;\n&quot;</code> 则表示只包含一个换行符的字符串。 样式在 Python 代码中通常都会使用这种原始字符串表示法来表示。</p><p>绝大部分正则表达式操作都提供为模块函数和方法，在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re-objects" target="_blank" rel="noopener">编译正则表达式</a>. 这些函数是一个捷径，不需要先编译一个正则对象，但是损失了一些优化参数。</p><p>参见:</p><p>第三方模块 <a href="https://pypi.org/project/regex/" target="_blank" rel="noopener">regex</a> , 提供了与标准库 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#module-re" target="_blank" rel="noopener"><code>re</code></a> 模块兼容的API接口, 同时还提供了额外的功能和更全面的Unicode支持。</p><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><p>一个正则表达式（或RE）指定了一集与之匹配的字符串；模块内的函数可以让你检查某个字符串是否跟给定的正则表达式匹配（或者一个正则表达式是否匹配到一个字符串，这两种说法含义相同）。</p><p>正则表达式可以拼接； 如果 <em>A</em> 和 <em>B</em> 都是正则表达式， 那么 <em>AB</em> 也是正则表达式。 通常， 如果字符串 <em>p</em> 匹配 <em>A</em> 并且另一个字符串 <em>q</em> 匹配 <em>B</em>, 那么 <em>pq</em> 可以匹配 AB。除非 <em>A</em> 或者 <em>B</em> 包含低优先级操作，<em>A</em> 和 <em>B</em> 存在边界条件；或者命名组引用。所以，复杂表达式可以很容易的从这里描述的简单源语表达式构建。 了解更多正则表达式理论和实现，参考the Friedl book <a href="https://docs.python.org/zh-cn/3.8/library/re.html#frie09" target="_blank" rel="noopener">[Frie09]</a> ，或者其他编译器构建的书籍。</p><p>以下是正则表达式格式的简要说明。更详细的信息和演示，参考 <a href="https://docs.python.org/zh-cn/3.8/howto/regex.html#regex-howto" target="_blank" rel="noopener">正则表达式HOWTO</a>。</p><p>正则表达式可以包含普通或者特殊字符。绝大部分普通字符，比如 <code>&#39;A&#39;</code>, <code>&#39;a&#39;</code>, 或者 <code>&#39;0&#39;</code>，都是最简单的正则表达式。它们就匹配自身。你可以拼接普通字符，所以 <code>last</code> 匹配字符串 <code>&#39;last&#39;</code>. （在这一节的其他部分，我们将用 <code>this special style</code> 这种方式表示正则表达式，通常不带引号，要匹配的字符串用 <code>&#39;in single quotes&#39;</code> ，单引号形式。）</p><p>有些字符，比如 <code>&#39;|&#39;</code> 或者 <code>&#39;(&#39;</code>，属于特殊字符。 特殊字符既可以表示它的普通含义， 也可以影响它旁边的正则表达式的解释。</p><p>重复修饰符 (<code>*</code>, <code>+</code>, <code>?</code>, <code>{m,n}</code>, 等) 不能直接嵌套。这样避免了非贪婪后缀 <code>?</code> 修饰符，和其他实现中的修饰符产生的多义性。要应用一个内层重复嵌套，可以使用括号。 比如，表达式 <code>(?:a{6})*</code> 匹配6个 <code>&#39;a&#39;</code> 字符重复任意次数。</p><p>特殊字符是：</p><ul><li><p><code>.</code></p><p>(点) 在默认模式，匹配除了换行的任意字符。如果指定了标签 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.DOTALL" target="_blank" rel="noopener"><code>DOTALL</code></a> ，它将匹配包括换行符的任意字符。</p></li><li><p><code>^</code></p><p>(插入符号) 匹配字符串的开头， 并且在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.MULTILINE" target="_blank" rel="noopener"><code>MULTILINE</code></a> 模式也匹配换行后的首个符号。</p></li><li><p><code>$</code></p><p>匹配字符串尾或者换行符的前一个字符，在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.MULTILINE" target="_blank" rel="noopener"><code>MULTILINE</code></a> 模式匹配换行符的前一个字符。 <code>foo</code> 匹配 <code>&#39;foo&#39;</code> 和 <code>&#39;foobar&#39;</code> , 但正则 <code>foo$</code> 只匹配 <code>&#39;foo&#39;</code>。更有趣的是， 在 <code>&#39;foo1\nfoo2\n&#39;</code> 搜索 <code>foo.$</code> ，通常匹配 <code>&#39;foo2&#39;</code> ，但在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.MULTILINE" target="_blank" rel="noopener"><code>MULTILINE</code></a> 模式 ，可以匹配到 <code>&#39;foo1&#39;</code> ；在 <code>&#39;foo\n&#39;</code> 搜索 <code>$</code> 会找到两个空串：一个在换行前，一个在字符串最后。</p></li><li><p><code>*</code></p><p>对它前面的正则式匹配0到任意次重复， 尽量多的匹配字符串。 <code>ab*</code> 会匹配 <code>&#39;a&#39;</code>， <code>&#39;ab&#39;</code>， 或者 <code>&#39;a&#39;后面跟随任意个 &#39;b&#39;</code>。</p></li><li><p><code>+</code></p><p>对它前面的正则式匹配1到任意次重复。 <code>ab+</code> 会匹配 <code>&#39;a&#39;</code> 后面跟随1个以上到任意个 <code>&#39;b&#39;</code>，它不会匹配 <code>&#39;a&#39;</code>。</p></li><li><p><code>?</code></p><p>对它前面的正则式匹配0到1次重复。 <code>ab?</code> 会匹配 <code>&#39;a&#39;</code> 或者 <code>&#39;ab&#39;</code>。</p></li><li><p><code>*?</code>, <code>+?</code>, <code>??</code></p><p><code>&#39;*&#39;</code>, <code>&#39;+&#39;</code>，和 <code>&#39;?&#39;</code> 修饰符都是 <em>贪婪的</em>；它们在字符串进行尽可能多的匹配。有时候并不需要这种行为。如果正则式 <code>&lt;.*&gt;</code> 希望找到 <code>&#39; b &#39;</code>，它将会匹配整个字符串，而不仅是 <code>&#39;&#39;</code>。在修饰符之后添加 <code>?</code> 将使样式以 <em>非贪婪<code>方式或者 :dfn:</code>最小</em> 方式进行匹配； 尽量 <em>少</em> 的字符将会被匹配。 使用正则式 <code>&lt;.*?&gt;</code> 将会仅仅匹配 <code>&#39;&#39;</code>。</p></li><li><p><code>{m}</code></p><p>对其之前的正则式指定匹配 <em>m</em> 个重复；少于 <em>m</em> 的话就会导致匹配失败。比如， <code>a{6}</code> 将匹配6个 <code>&#39;a&#39;</code> , 但是不能是5个。</p></li><li><p><code>{m,n}</code></p><p>对正则式进行 <em>m</em> 到 <em>n</em> 次匹配，在 <em>m</em> 和 <em>n</em> 之间取尽量多。 比如，<code>a{3,5}</code> 将匹配 3 到 5个 <code>&#39;a&#39;</code>。忽略 <em>m</em> 意为指定下界为0，忽略 <em>n</em> 指定上界为无限次。 比如 <code>a{4,}b</code> 将匹配 <code>&#39;aaaab&#39;</code> 或者1000个 <code>&#39;a&#39;</code> 尾随一个 <code>&#39;b&#39;</code>，但不能匹配 <code>&#39;aaab&#39;</code>。逗号不能省略，否则无法辨别修饰符应该忽略哪个边界。</p></li><li><p><code>{m,n}?</code></p><p>前一个修饰符的非贪婪模式，只匹配尽量少的字符次数。比如，对于 <code>&#39;aaaaaa&#39;</code>， <code>a{3,5}</code> 匹配 5个 <code>&#39;a&#39;</code> ，而 <code>a{3,5}?</code> 只匹配3个 <code>&#39;a&#39;</code>。</p></li><li><p><code>\</code></p><p>转义特殊字符（允许你匹配 <code>&#39;*&#39;</code>, <code>&#39;?&#39;</code>, 或者此类其他），或者表示一个特殊序列；特殊序列之后进行讨论。如果你没有使用原始字符串（ <code>r&#39;raw&#39;</code> ）来表达样式，要牢记Python也使用反斜杠作为转义序列；如果转义序列不被Python的分析器识别，反斜杠和字符才能出现在字符串中。如果Python可以识别这个序列，那么反斜杠就应该重复两次。这将导致理解障碍，所以高度推荐，就算是最简单的表达式，也要使用原始字符串。</p></li><li><p><code>[]</code></p><p>用于表示一个字符集合。在一个集合中：字符可以单独列出，比如 <code>[amk]</code> 匹配 <code>&#39;a&#39;</code>， <code>&#39;m&#39;</code>， 或者 <code>&#39;k&#39;</code>。可以表示字符范围，通过用 <code>&#39;-&#39;</code> 将两个字符连起来。比如 <code>[a-z]</code> 将匹配任何小写ASCII字符， <code>[0-5][0-9]</code> 将匹配从 <code>00</code> 到 <code>59</code> 的两位数字， <code>[0-9A-Fa-f]</code> 将匹配任何十六进制数位。 如果 <code>-</code> 进行了转义 （比如 <code>[a\-z]</code>）或者它的位置在首位或者末尾（如 <code>[-a]</code> 或 <code>[a-]</code>），它就只表示普通字符 <code>&#39;-&#39;</code>。特殊字符在集合中，失去它的特殊含义。比如 <code>[(+*)]</code> 只会匹配这几个文法字符 <code>&#39;(&#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;*&#39;</code>, or <code>&#39;)&#39;</code>。字符类如 <code>\w</code> 或者 <code>\S</code> (如下定义) 在集合内可以接受，它们可以匹配的字符由 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 或者 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>LOCALE</code></a> 模式决定。不在集合范围内的字符可以通过 <em>取反</em> 来进行匹配。如果集合首字符是 <code>&#39;^&#39;</code> ，所有 <em>不</em> 在集合内的字符将会被匹配，比如 <code>[^5]</code> 将匹配所有字符，除了 <code>&#39;5&#39;</code>， <code>[^^]</code> 将匹配所有字符，除了 <code>&#39;^&#39;</code>. <code>^</code> 如果不在集合首位，就没有特殊含义。在集合内要匹配一个字符 <code>&#39;]&#39;</code>，有两种方法，要么就在它之前加上反斜杠，要么就把它放到集合首位。比如， <code>[()[\]{}]</code> 和 <code>[]()[{}]</code> 都可以匹配括号。<a href="https://unicode.org/reports/tr18/" target="_blank" rel="noopener">Unicode Technical Standard #18</a> 里的嵌套集合和集合操作支持可能在未来添加。这将会改变语法，所以为了帮助这个改变，一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FutureWarning" target="_blank" rel="noopener"><code>FutureWarning</code></a> 将会在有多义的情况里被 <code>raise</code>，包含以下几种情况，集合由 <code>&#39;[&#39;</code> 开始，或者包含下列字符序列 <code>&#39;--&#39;</code>, <code>&#39;&amp;&amp;&#39;</code>, <code>&#39;~~&#39;</code>, 和 <code>&#39;||&#39;</code>。为了避免警告，需要将它们用反斜杠转义。<em>在 3.7 版更改:</em> 如果一个字符串构建的语义在未来会改变的话，一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FutureWarning" target="_blank" rel="noopener"><code>FutureWarning</code></a> 会 <code>raise</code> 。</p></li><li><p><code>|</code></p><p><code>A|B</code>， <em>A</em> 和 <em>B</em> 可以是任意正则表达式，创建一个正则表达式，匹配 <em>A</em> 或者 <em>B</em>. 任意个正则表达式可以用 <code>&#39;|&#39;</code> 连接。它也可以在组合（见下列）内使用。扫描目标字符串时， <code>&#39;|&#39;</code> 分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。意思就是，一旦 <em>A</em> 匹配成功， <em>B</em> 就不再进行匹配，即便它能产生一个更好的匹配。或者说，<code>&#39;|&#39;</code> 操作符绝不贪婪。 如果要匹配 <code>&#39;|&#39;</code> 字符，使用 <code>\|</code>， 或者把它包含在字符集里，比如 <code>[|]</code>.</p></li><li><p><code>(...)</code></p><p>（组合），匹配括号内的任意正则表达式，并标识出组合的开始和结尾。匹配完成后，组合的内容可以被获取，并可以在之后用 <code>\number</code> 转义序列进行再次匹配，之后进行详细说明。要匹配字符 <code>&#39;(&#39;</code> 或者 <code>&#39;)&#39;</code>, 用 <code>\(</code> 或 <code>\)</code>, 或者把它们包含在字符集合里: <code>[(]</code>, <code>[)]</code>.</p></li><li><p><code>(?…)</code></p><p>这是个扩展标记法 （一个 <code>&#39;?&#39;</code> 跟随 <code>&#39;(&#39;</code> 并无含义）。 <code>&#39;?&#39;</code> 后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合； <code>(?P...)</code> 是唯一的例外。 以下是目前支持的扩展。</p></li><li><p><code>(?aiLmsux)</code></p><p>( <code>&#39;a&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;L&#39;</code>, <code>&#39;m&#39;</code>, <code>&#39;s&#39;</code>, <code>&#39;u&#39;</code>, <code>&#39;x&#39;</code> 中的一个或多个) 这个组合匹配一个空字符串；这些字符对正则表达式设置以下标记 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.A" target="_blank" rel="noopener"><code>re.A</code></a> (只匹配ASCII字符), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.I" target="_blank" rel="noopener"><code>re.I</code></a> (忽略大小写), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.L" target="_blank" rel="noopener"><code>re.L</code></a> (语言依赖), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.M" target="_blank" rel="noopener"><code>re.M</code></a> (多行模式), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.S" target="_blank" rel="noopener"><code>re.S</code></a> (点dot匹配全部字符), <code>re.U</code> (Unicode匹配), and <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.X" target="_blank" rel="noopener"><code>re.X</code></a> (冗长模式)。 (这些标记在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#contents-of-module-re" target="_blank" rel="noopener">模块内容</a> 中描述) 如果你想将这些标记包含在正则表达式中，这个方法就很有用，免去了在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.compile" target="_blank" rel="noopener"><code>re.compile()</code></a> 中传递 <em>flag</em> 参数。标记应该在表达式字符串首位表示。</p></li><li><p><code>(?:…)</code></p><p>正则括号的非捕获版本。 匹配在括号内的任何正则表达式，但该分组所匹配的子字符串 <em>不能</em> 在执行匹配后被获取或是之后在模式中被引用。</p></li><li><p><code>(?aiLmsux-imsx:…)</code></p><p>(<code>&#39;a&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;L&#39;</code>, <code>&#39;m&#39;</code>, <code>&#39;s&#39;</code>, <code>&#39;u&#39;</code>, <code>&#39;x&#39;</code> 中的0或者多个， 之后可选跟随 <code>&#39;-&#39;</code> 在后面跟随 <code>&#39;i&#39;</code> , <code>&#39;m&#39;</code> , <code>&#39;s&#39;</code> , <code>&#39;x&#39;</code> 中的一到多个 .) 这些字符为表达式的其中一部分 <em>设置</em> 或者 <em>去除</em> 相应标记 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.A" target="_blank" rel="noopener"><code>re.A</code></a> (只匹配ASCII), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.I" target="_blank" rel="noopener"><code>re.I</code></a> (忽略大小写), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.L" target="_blank" rel="noopener"><code>re.L</code></a> (语言依赖), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.M" target="_blank" rel="noopener"><code>re.M</code></a> (多行), <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.S" target="_blank" rel="noopener"><code>re.S</code></a> (点匹配所有字符), <code>re.U</code> (Unicode匹配), and <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.X" target="_blank" rel="noopener"><code>re.X</code></a> (冗长模式)。(标记描述在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#contents-of-module-re" target="_blank" rel="noopener">模块内容</a> .)<code>&#39;a&#39;</code>, <code>&#39;L&#39;</code> and <code>&#39;u&#39;</code> 作为内联标记是相互排斥的， 所以它们不能结合在一起，或者跟随 <code>&#39;-&#39;</code> 。 当他们中的某个出现在内联组中，它就覆盖了括号组内的匹配模式。在Unicode样式中， <code>(?a:...)</code> 切换为 只匹配ASCII， <code>(?u:...)</code> 切换为Unicode匹配 (默认). 在byte样式中 <code>(?L:...)</code> 切换为语言依赖模式， <code>(?a:...)</code> 切换为 只匹配ASCII (默认)。这种方式只覆盖组合内匹配，括号外的匹配模式不受影响。<em>3.6 新版功能.**在 3.7 版更改:</em> 符号 <code>&#39;a&#39;</code>, <code>&#39;L&#39;</code> 和 <code>&#39;u&#39;</code> 同样可以用在一个组合内。</p></li><li><p><code>(?P…)</code></p><p>（命名组合）类似正则组合，但是匹配到的子串组在外部是通过定义的 <em>name</em> 来获取的。组合名必须是有效的Python标识符，并且每个组合名只能用一个正则表达式定义，只能定义一次。一个符号组合同样是一个数字组合，就像这个组合没有被命名一样。命名组合可以在三种上下文中引用。如果样式是 <code>(?P[&#39;&quot;]).*?(?P=quote)</code> （也就是说，匹配单引号或者双引号括起来的字符串)：引用组合 “quote” 的上下文引用方法在正则式自身内<code>(?P=quote)</code> (如示)<code>\1</code>处理匹配对象 <em>m</em><code>m.group(&#39;quote&#39;)m.end(&#39;quote&#39;)</code> (等)传递到 <code>re.sub()</code> 里的 <em>repl</em> 参数中<code>\g\g&lt;1&gt;\1</code></p></li><li><p><code>(?P=name)</code></p><p>反向引用一个命名组合；它匹配前面那个叫 <em>name</em> 的命名组中匹配到的串同样的字串。</p></li><li><p><code>(?#…)</code></p><p>注释；里面的内容会被忽略。</p></li><li><p><code>(?=…)</code></p><p>匹配 <code>…</code> 的内容，但是并不消费样式的内容。这个叫做 <em>lookahead assertion</em>。比如， <code>Isaac (?=Asimov)</code> 匹配 <code>&#39;Isaac &#39;</code> 只有在后面是 <code>&#39;Asimov&#39;</code> 的时候。</p></li><li><p><code>(?!…)</code></p><p>匹配 <code>…</code> 不符合的情况。这个叫 <em>negative lookahead assertion</em> （前视取反）。比如说， <code>Isaac (?!Asimov)</code> 只有后面 <em>不</em> 是 <code>&#39;Asimov&#39;</code> 的时候才匹配 <code>&#39;Isaac &#39;</code> 。</p></li><li><p><code>(?&lt;=…)</code></p><p>匹配字符串的当前位置，它的前面匹配 <code>…</code> 的内容到当前位置。这叫:dfn:positive lookbehind assertion （正向后视断定）。 <code>(?&lt;=abc)def</code> 会在 <code>&#39;abcdef&#39;</code> 中找到一个匹配，因为后视会往后看3个字符并检查是否包含匹配的样式。包含的匹配样式必须是定长的，意思就是 <code>abc</code> 或 <code>a|b</code> 是允许的，但是 <code>a*</code> 和 <code>a{3,4}</code> 不可以。注意以 positive lookbehind assertions 开始的样式，如 <code>(?&lt;=abc)def</code> ，并不是从 a 开始搜索，而是从 d 往回看的。你可能更加愿意使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>search()</code></a> 函数，而不是 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.match" target="_blank" rel="noopener"><code>match()</code></a> 函数：&gt;&gt;&gt;<code>&gt;&gt;&gt; import re &gt;&gt;&gt; m = re.search(&#39;(?&lt;=abc)def&#39;, &#39;abcdef&#39;) &gt;&gt;&gt; m.group(0) &#39;def&#39;</code>这个例子搜索一个跟随在连字符后的单词：&gt;&gt;&gt;<code>&gt;&gt;&gt; m = re.search(r&#39;(?&lt;=-)\w+&#39;, &#39;spam-egg&#39;) &gt;&gt;&gt; m.group(0) &#39;egg&#39;</code><em>在 3.5 版更改:</em> 添加定长组合引用的支持。</p></li><li><p>`(?</p><p>匹配当前位置之前不是 <code>...</code> 的样式。这个叫 <em>negative lookbehind assertion</em> （后视断定取非）。类似正向后视断定，包含的样式匹配必须是定长的。由 negative lookbehind assertion 开始的样式可以从字符串搜索开始的位置进行匹配。</p></li><li><p><code>(?(id/name)yes-pattern|no-pattern)</code></p><p>如果给定的 <em>id</em> 或 <em>name</em> 存在，将会尝试匹配 <code>yes-pattern</code> ，否则就尝试匹配 <code>no-pattern</code>，<code>no-pattern</code> 可选，也可以被忽略。比如， <code>(&lt;)?(\w+@\w+(?:\.\w+)+)(?(1)&gt;|$)</code> 是一个email样式匹配，将匹配 <code>&#39;&#39;</code> 或 <a href="mailto:`&#39;user@host.com" target="_blank" rel="noopener">`&#39;user@host.com</a>‘<code>，但不会匹配</code>‘ ，也不会匹配 <a href="mailto:`&#39;user@host.com" target="_blank" rel="noopener">`&#39;user@host.com</a>&gt;’`。</p></li></ul><p>由 <code>&#39;\&#39;</code> 和一个字符组成的特殊序列在以下列出。 如果普通字符不是ASCII数位或者ASCII字母，那么正则样式将匹配第二个字符。比如，<code>\$</code> 匹配字符 <code>&#39;$&#39;</code>.</p><ul><li><p><code>\number</code></p><p>匹配数字代表的组合。每个括号是一个组合，组合从1开始编号。比如 <code>(.+) \1</code> 匹配 <code>&#39;the the&#39;</code> 或者 <code>&#39;55 55&#39;</code>, 但不会匹配 <code>&#39;thethe&#39;</code> (注意组合后面的空格)。这个特殊序列只能用于匹配前面99个组合。如果 <em>number</em> 的第一个数位是0， 或者 <em>number</em> 是三个八进制数，它将不会被看作是一个组合，而是八进制的数字值。在 <code>&#39;[&#39;</code> 和 <code>&#39;]&#39;</code> 字符集合内，任何数字转义都被看作是字符。</p></li><li><p><code>\A</code></p><p>只匹配字符串开始。</p></li><li><p><code>\b</code></p><p>匹配空字符串，但只在单词开始或结尾的位置。一个单词被定义为一个单词字符的序列。注意，通常 <code>\b</code> 定义为 <code>\w</code> 和 <code>\W</code> 字符之间，或者 <code>\w</code> 和字符串开始/结尾的边界， 意思就是 <code>r&#39;\bfoo\b&#39;</code> 匹配 <code>&#39;foo&#39;</code>, <code>&#39;foo.&#39;</code>, <code>&#39;(foo)&#39;</code>, <code>&#39;bar foo baz&#39;</code> 但不匹配 <code>&#39;foobar&#39;</code> 或者 <code>&#39;foo3&#39;</code>。默认情况下，Unicode字母和数字是在Unicode样式中使用的，但是可以用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 标记来更改。如果 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>LOCALE</code></a> 标记被设置的话，词的边界是由当前语言区域设置决定的，<code>\b</code> 表示退格字符，以便与Python字符串文本兼容。</p></li><li><p><code>\B</code></p><p>匹配空字符串，但 <em>不</em> 能在词的开头或者结尾。意思就是 <code>r&#39;py\B&#39;</code> 匹配 <code>&#39;python&#39;</code>, <code>&#39;py3&#39;</code>, <code>&#39;py2&#39;</code>, 但不匹配 <code>&#39;py&#39;</code>, <code>&#39;py.&#39;</code>, 或者 <code>&#39;py!&#39;</code>. <code>\B</code> 是 <code>\b</code> 的取非，所以Unicode样式的词语是由Unicode字母，数字或下划线构成的，虽然可以用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 标志来改变。如果使用了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>LOCALE</code></a> 标志，则词的边界由当前语言区域设置。</p></li><li><p><code>\d</code></p><p>对于 Unicode (str) 样式：匹配任何Unicode十进制数（就是在Unicode字符目录[Nd]里的字符）。这包括了 <code>[0-9]</code> ，和很多其他的数字字符。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 标志，就只匹配 <code>[0-9]</code> 。对于8位(bytes)样式：匹配任何十进制数，就是 <code>[0-9]</code>。</p></li><li><p><code>\D</code></p><p>匹配任何非十进制数字的字符。就是 <code>\d</code> 取非。 如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 标志，就相当于 <code>[^0-9]</code> 。</p></li><li><p><code>\s</code></p><p>对于 Unicode (str) 样式：匹配任何Unicode空白字符（包括 <code>[ \t\n\r\f\v]</code> ，还有很多其他字符，比如不同语言排版规则约定的不换行空格）。如果 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 被设置，就只匹配 <code>[ \t\n\r\f\v]</code> 。对于8位(bytes)样式：匹配ASCII中的空白字符，就是 <code>[ \t\n\r\f\v]</code> 。</p></li><li><p><code>\S</code></p><p>匹配任何非空白字符。就是 <code>\s</code> 取非。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 标志，就相当于 <code>[^ \t\n\r\f\v]</code> 。</p></li><li><p><code>\w</code></p><p>对于 Unicode (str) 样式：匹配Unicode词语的字符，包含了可以构成词语的绝大部分字符，也包括数字和下划线。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 标志，就只匹配 <code>[a-zA-Z0-9_]</code> 。对于8位(bytes)样式：匹配ASCII字符中的数字和字母和下划线，就是 <code>[a-zA-Z0-9_]</code> 。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>LOCALE</code></a> 标记，就匹配当前语言区域的数字和字母和下划线。</p></li><li><p><code>\W</code></p><p>匹配任何不是单词字符的字符。 这与 <code>\w</code> 正相反。 如果使用了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 旗标，这就等价于 <code>[^a-zA-Z0-9_]</code>。 如果使用了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>LOCALE</code></a> 旗标，则会匹配在当前区域设置中不是字母数字又不是下划线的字符。</p></li><li><p><code>\Z</code></p><p>只匹配字符串尾。</p></li></ul><p>绝大部分Python的标准转义字符也被正则表达式分析器支持。:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\a      \b      \f      \n</span><br><span class="line">\N      \r      \t      \u</span><br><span class="line">\U      \v      \x      \\</span><br></pre></td></tr></table></figure><p>（注意 <code>\b</code> 被用于表示词语的边界，它只在字符集合内表示退格，比如 <code>[\b]</code> 。）</p><p><code>&#39;\u&#39;</code>, <code>&#39;\U&#39;</code> 和 <code>&#39;\N&#39;</code> 转义序列只在 Unicode 模式中可被识别。 在 bytes 模式中它们会导致错误。 未知的 ASCII 字母转义序列保留在未来使用，会被当作错误来处理。</p><p>八进制转义包含为一个有限形式。如果首位数字是 0， 或者有三个八进制数位，那么就认为它是八进制转义。其他的情况，就看作是组引用。对于字符串文本，八进制转义最多有三个数位长。</p><p><em>在 3.3 版更改:</em> 增加了 <code>&#39;\u&#39;</code> 和 <code>&#39;\U&#39;</code> 转义序列。</p><p><em>在 3.6 版更改:</em> 由 <code>&#39;\&#39;</code> 和一个ASCII字符组成的未知转义会被看成错误。</p><p><em>在 3.8 版更改:</em> 添加了 <code>&#39;\N{name}&#39;</code> 转义序列。 与在字符串字面值中一样，它扩展了命名 Unicode 字符 (例如 <code>&#39;\N{EM DASH}&#39;</code>)。</p><h2 id="模块内容"><a href="#模块内容" class="headerlink" title="模块内容"></a>模块内容</h2><p>模块定义了几个函数，常量，和一个例外。有些函数是编译后的正则表达式方法的简化版本（少了一些特性）。绝大部分重要的应用，总是会先将正则表达式编译，之后在进行操作。</p><p><em>在 3.6 版更改:</em> 标志常量现在是 <code>RegexFlag</code> 类的实例，这个类是 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>enum.IntFlag</code></a> 的子类。</p><ul><li><p><code>re.compile</code>(<em>pattern</em>, <em>flags=0</em>)</p><p>将正则表达式的样式编译为一个 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re-objects" target="_blank" rel="noopener">正则表达式对象</a> （正则对象），可以用于匹配，通过这个对象的方法 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.match" target="_blank" rel="noopener"><code>match()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 以及其他如下描述。这个表达式的行为可以通过指定 <em>标记</em> 的值来改变。值可以是以下任意变量，可以通过位的OR操作来结合（ <code>|</code> 操作符）。</p><p>序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prog = re.compile(pattern)</span><br><span class="line">result = prog.match(string)</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = re.match(pattern, string)</span><br></pre></td></tr></table></figure><p>如果需要多次使用这个正则表达式的话，使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.compile" target="_blank" rel="noopener"><code>re.compile()</code></a> 和保存这个正则对象以便复用，可以让程序更加高效。</p><p>注解：通过 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.compile" target="_blank" rel="noopener"><code>re.compile()</code></a> 编译后的样式，和模块级的函数会被缓存， 所以少数的正则表达式使用无需考虑编译的问题。</p></li><li><p><code>re.A</code></p></li><li><p><code>re.ASCII</code></p><p>让 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code>, <code>\d</code>, <code>\D</code>, <code>\s</code> 和 <code>\S</code> 只匹配ASCII，而不是Unicode。这只对Unicode样式有效，会被byte样式忽略。相当于前面语法中的内联标志 <code>(?a)</code> 。注意，为了保持向后兼容， <code>re.U</code> 标记依然存在（还有他的同义 <code>re.UNICODE</code> 和嵌入形式 <code>(?u)</code> ) ， 但是这些在 Python 3 是冗余的，因为默认字符串已经是Unicode了（并且Unicode匹配不允许byte出现)。</p></li><li><p><code>re.DEBUG</code></p><p>显示编译时的debug信息，没有内联标记。</p></li><li><p><code>re.I</code></p></li><li><p><code>re.IGNORECASE</code></p><p>进行忽略大小写匹配；表达式如 <code>[A-Z]</code> 也会匹配小写字符。Unicode匹配（比如 <code>Ü</code> 匹配 <code>ü</code>）同样有用，除非设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>re.ASCII</code></a> 标记来禁用非ASCII匹配。当前语言区域不会改变这个标记，除非设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>re.LOCALE</code></a> 标记。这个相当于内联标记 <code>(?i)</code> 。注意，当设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.IGNORECASE" target="_blank" rel="noopener"><code>IGNORECASE</code></a> 标记，搜索Unicode样式 <code>[a-z]</code> 或 <code>[A-Z]</code> 的结合时，它将会匹配52个ASCII字符和4个额外的非ASCII字符： ‘İ’ (U+0130, 拉丁大写的 I 带个点在上面), ‘ı’ (U+0131, 拉丁小写没有点的 I ), ‘ſ’ (U+017F, 拉丁小写长 s) and ‘K’ (U+212A, 开尔文符号).如果使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>ASCII</code></a> 标记，就只匹配 ‘a’ 到 ‘z’ 和 ‘A’ 到 ‘Z’ 。</p></li><li><p><code>re.L</code></p></li><li><p><code>re.LOCALE</code></p><p>由当前语言区域决定 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code> 和大小写敏感匹配。这个标记只能对byte样式有效。这个标记不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个 “习惯”，而且只对8位字节有效。Unicode匹配在Python 3 里默认启用，并可以处理不同语言。 这个对应内联标记 <code>(?L)</code> 。</p><p><em>在 3.6 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>re.LOCALE</code></a> 只能用于byte样式，而且不能和 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.ASCII" target="_blank" rel="noopener"><code>re.ASCII</code></a> 一起用。</p><p><em>在 3.7 版更改:</em> 设置了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.LOCALE" target="_blank" rel="noopener"><code>re.LOCALE</code></a> 标记的编译正则对象不再在编译时依赖语言区域设置。语言区域设置只在匹配的时候影响其结果。</p></li><li><p><code>re.M</code></p></li><li><p><code>re.MULTILINE</code></p><p>设置以后，样式字符 <code>&#39;^&#39;</code> 匹配字符串的开始，和每一行的开始（换行符后面紧跟的符号）；样式字符 <code>&#39;$&#39;</code> 匹配字符串尾，和每一行的结尾（换行符前面那个符号）。默认情况下，<code>’^’</code> 匹配字符串头，<code>&#39;$&#39;</code> 匹配字符串尾。对应内联标记 <code>(?m)</code> 。</p></li><li><p><code>re.S</code></p></li><li><p><code>re.DOTALL</code></p><p>让 <code>&#39;.&#39;</code> 特殊字符匹配任何字符，包括换行符；如果没有这个标记，<code>&#39;.&#39;</code> 就匹配 <em>除了</em> 换行符的其他任意字符。对应内联标记 <code>(?s)</code> 。</p></li><li><p><code>re.X</code></p></li><li><p><code>re.VERBOSE</code></p><p>这个标记允许你编写更具可读性更友好的正则表达式。通过分段和添加注释。空白符号会被忽略，除非在一个字符集合当中或者由反斜杠转义，或者在 <code>*?</code>, <code>(?:</code> or <code>(?P&lt;…&gt;</code> 分组之内。当一个行内有 <code>#</code> 不在字符集和转义序列，那么它之后的所有字符都是注释。意思就是下面两个正则表达式等价地匹配一个十进制数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = re.compile(<span class="string">r"""\d +  # the integral part</span></span><br><span class="line"><span class="string">                   \.    # the decimal point</span></span><br><span class="line"><span class="string">                   \d *  # some fractional digits"""</span>, re.X)</span><br><span class="line">b = re.compile(<span class="string">r"\d+\.\d*"</span>)</span><br></pre></td></tr></table></figure><p>对应内联标记 <code>(?x)</code> 。</p></li><li><p><code>re.search</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p><p>扫描整个 <em>字符串</em> 找到匹配样式的第一个位置，并返回一个相应的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a>。如果没有匹配，就返回一个 <code>None</code> ； 注意这和找到一个零长度匹配是不同的。</p></li><li><p><code>re.match</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p><p>如果 <em>string</em> 开始的0或者多个字符匹配到了正则表达式样式，就返回一个相应的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a> 。 如果没有匹配，就返回 <code>None</code> ；注意它跟零长度匹配是不同的。注意即便是 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.MULTILINE" target="_blank" rel="noopener"><code>MULTILINE</code></a> 多行模式， <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.match" target="_blank" rel="noopener"><code>re.match()</code></a> 也只匹配字符串的开始位置，而不匹配每行开始。如果你想定位 <em>string</em> 的任何位置，使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>search()</code></a> 来替代（也可参考 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#search-vs-match" target="_blank" rel="noopener">search() vs. match()</a> ）</p></li><li><p><code>re.fullmatch</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p><p>如果整个 <em>string</em> 匹配到正则表达式样式，就返回一个相应的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a> 。 否则就返回一个 <code>None</code> ；注意这跟零长度匹配是不同的。<em>3.4 新版功能.</em></p></li><li><p><code>re.split</code>(<em>pattern</em>, <em>string</em>, <em>maxsplit=0</em>, <em>flags=0</em>)</p><p>用 <em>pattern</em> 分开 <em>string</em> 。 如果在 <em>pattern</em> 中捕获到括号，那么所有的组里的文字也会包含在列表里。如果 <em>maxsplit</em> 非零， 最多进行 <em>maxsplit</em> 次分隔， 剩下的字符全部返回到列表的最后一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\W+'</span>, <span class="string">'Words, words, words.'</span>)</span><br><span class="line">[<span class="string">'Words'</span>, <span class="string">'words'</span>, <span class="string">'words'</span>, <span class="string">''</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'(\W+)'</span>, <span class="string">'Words, words, words.'</span>)</span><br><span class="line">[<span class="string">'Words'</span>, <span class="string">', '</span>, <span class="string">'words'</span>, <span class="string">', '</span>, <span class="string">'words'</span>, <span class="string">'.'</span>, <span class="string">''</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\W+'</span>, <span class="string">'Words, words, words.'</span>, <span class="number">1</span>)</span><br><span class="line">[<span class="string">'Words'</span>, <span class="string">'words, words.'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">'[a-f]+'</span>, <span class="string">'0a3B9'</span>, flags=re.IGNORECASE)</span><br><span class="line">[<span class="string">'0'</span>, <span class="string">'3'</span>, <span class="string">'9'</span>]</span><br></pre></td></tr></table></figure><p>如果分隔符里有捕获组合，并且匹配到字符串的开始，那么结果将会以一个空字符串开始。对于结尾也是一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'(\W+)'</span>, <span class="string">'...words, words...'</span>)</span><br><span class="line">[<span class="string">''</span>, <span class="string">'...'</span>, <span class="string">'words'</span>, <span class="string">', '</span>, <span class="string">'words'</span>, <span class="string">'...'</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure><p>这样的话，分隔组将会出现在结果列表中同样的位置。</p><p>样式的空匹配将分开字符串，但只在不相临的状况生效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">r'\b'</span>, <span class="string">'Words, words, words.'</span>)</span><br><span class="line">  [<span class="string">''</span>, <span class="string">'Words'</span>, <span class="string">', '</span>, <span class="string">'words'</span>, <span class="string">', '</span>, <span class="string">'words'</span>, <span class="string">'.'</span>]</span><br><span class="line">  &gt;&gt;&gt; re.split(<span class="string">r'\W*'</span>, <span class="string">'...words...'</span>)</span><br><span class="line">  [<span class="string">''</span>, <span class="string">''</span>, <span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'s'</span>, <span class="string">''</span>, <span class="string">''</span>]</span><br><span class="line">  &gt;&gt;&gt; re.split(<span class="string">r'(\W*)'</span>, <span class="string">'...words...'</span>)</span><br><span class="line">  [<span class="string">''</span>, <span class="string">'...'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'w'</span>, <span class="string">''</span>, <span class="string">'o'</span>, <span class="string">''</span>, <span class="string">'r'</span>, <span class="string">''</span>, <span class="string">'d'</span>, <span class="string">''</span>, <span class="string">'s'</span>, <span class="string">'...'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure></li></ul><p>  <em>在 3.1 版更改:</em> 增加了可选标记参数。</p><p>  <em>在 3.7 版更改:</em> 增加了空字符串的样式分隔。</p><ul><li><p><code>re.findall</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p><p>对 <em>string</em> 返回一个不重复的 <em>pattern</em> 的匹配列表， <em>string</em> 从左到右进行扫描，匹配按找到的顺序返回。如果样式里存在一到多个组，就返回一个组合列表；就是一个元组的列表（如果样式里有超过一个组合的话）。空匹配也会包含在结果里。</p><p><em>在 3.7 版更改:</em> 非空匹配现在可以在前一个空匹配之后出现了。</p></li><li><p><code>re.finditer</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p><p><em>pattern</em> 在 <em>string</em> 里所有的非重复匹配，返回为一个迭代器 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a> 保存了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a> 。 <em>string</em> 从左到右扫描，匹配按顺序排列。空匹配也包含在结果里。<em>在 3.7 版更改:</em> 非空匹配现在可以在前一个空匹配之后出现了。</p></li><li><p><code>re.sub</code>(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count=0</em>, <em>flags=0</em>)</p><p>返回通过使用 <em>repl</em> 替换在 <em>string</em> 最左边非重叠出现的 <em>pattern</em> 而获得的字符串。 如果样式没有找到，则不加改变地返回 <em>string</em>。 <em>repl</em> 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理。 也就是说，<code>\n</code> 会被转换为一个换行符，<code>\r</code> 会被转换为一个回车附，依此类推。 未知的 ASCII 字符转义序列保留在未来使用，会被当作错误来处理。 其他未知转义序列例如 <code>\&amp;</code> 会保持原样。 向后引用像是 <code>\6</code> 会用样式中第 6 组所匹配到的子字符串来替换。 例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):'</span>,</span><br><span class="line"><span class="meta">... </span>       <span class="string">r'static PyObject*\npy_\1(void)\n&#123;'</span>,</span><br><span class="line"><span class="meta">... </span>       <span class="string">'def myfunc():'</span>)</span><br><span class="line"><span class="string">'static PyObject*\npy_myfunc(void)\n&#123;'</span></span><br></pre></td></tr></table></figure><p>如果 <em>repl</em> 是一个函数，那它会对每个非重复的 <em>pattern</em> 的情况调用。这个函数只能有一个 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a> 参数，并返回一个替换后的字符串。比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">dashrepl</span><span class="params">(matchobj)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> matchobj.group(<span class="number">0</span>) == <span class="string">'-'</span>: <span class="keyword">return</span> <span class="string">' '</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="string">'-'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">'-&#123;1,2&#125;'</span>, dashrepl, <span class="string">'pro----gram-files'</span>)</span><br><span class="line"><span class="string">'pro--gram files'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(<span class="string">r'\sAND\s'</span>, <span class="string">' &amp; '</span>, <span class="string">'Baked Beans And Spam'</span>, flags=re.IGNORECASE)</span><br><span class="line"><span class="string">'Baked Beans &amp; Spam'</span></span><br></pre></td></tr></table></figure><p> 样式可以是一个字符串或者一个<a href="https://docs.python.org/zh-cn/3.8/library/re.html#re-objects" target="_blank" rel="noopener">样式对象</a>。可选参数 <em>count</em> 是要替换的最大次数；<em>count</em> 必须是非负整数。如果忽略这个参数，或者设置为0，所有的匹配都会被替换。空匹配只在不相临连续的情况被更替，所以 <code>sub(&#39;x*&#39;, &#39;-&#39;, &#39;abxd&#39;)</code> 返回 <code>&#39;-a-b--d-&#39;</code> 。</p><p>在字符串类型的 <em>repl</em> 参数里，如上所述的转义和向后引用中，<code>\g</code> 会使用命名组合 <code>name</code>，（在 <code>(?P…)</code> 语法中定义） <code>\g</code> 会使用数字组；<code>\g&lt;2&gt;</code> 就是 <code>\2</code>，但它避免了二义性，如 <code>\g&lt;2&gt;0</code>。 <code>\20</code> 就会被解释为组20，而不是组2后面跟随一个字符 <code>&#39;0&#39;</code>。向后引用 <code>\g&lt;0&gt;</code> 把 <em>pattern</em> 作为一整个组进行引用。</p><p><em>在 3.1 版更改:</em> 增加了可选标记参数。</p><p><em>在 3.5 版更改:</em> 不匹配的组合替换为空字符串。<em>在 3.6 版更改:</em> <em>pattern</em> 中的未知转义（由 <code>&#39;\&#39;</code> 和一个 ASCII 字符组成）被视为错误。<em>在 3.7 版更改:</em> <em>repl</em> 中的未知转义（由 <code>&#39;\&#39;</code> 和一个 ASCII 字符组成）被视为错误。<em>在 3.7 版更改:</em> 样式中的空匹配相邻接时会被替换。</p></li><li><p><code>re.subn</code>(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count=0</em>, <em>flags=0</em>)</p><p>行为与 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.sub" target="_blank" rel="noopener"><code>sub()</code></a> 相同，但是返回一个元组 <code>(字符串, 替换次数)</code>.<em>在 3.1 版更改:</em> 增加了可选标记参数。<em>在 3.5 版更改:</em> 不匹配的组合替换为空字符串。</p></li><li><p><code>re.escape</code>(<em>pattern</em>)</p><p>转义 <em>pattern</em> 中的特殊字符。如果你想对任意可能包含正则表达式元字符的文本字符串进行匹配，它就是有用的。比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(re.escape(<span class="string">'http://www.python.org'</span>))</span><br><span class="line">http://www\.python\.org</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>legal_chars = string.ascii_lowercase + string.digits + <span class="string">"!#$%&amp;'*+-.^_`|~:"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'[%s]+'</span> % re.escape(legal_chars))</span><br><span class="line">[abcdefghijklmnopqrstuvwxyz0123456789!\<span class="comment">#\$%\&amp;'\*\+\-\.\^_`\|\~:]+</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>operators = [<span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>, <span class="string">'/'</span>, <span class="string">'**'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'|'</span>.join(map(re.escape, sorted(operators, reverse=<span class="literal">True</span>))))</span><br><span class="line">/|\-|\+|\*\*|\*</span><br></pre></td></tr></table></figure></li></ul><p>  这个函数不能被用于 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.sub" target="_blank" rel="noopener"><code>sub()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.subn" target="_blank" rel="noopener"><code>subn()</code></a> 的替换字符串，只有反斜杠应该被转义。 例如:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>digits_re = <span class="string">r'\d+'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sample = <span class="string">'/usr/sbin/sendmail - 0 errors, 12 warnings'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(re.sub(digits_re, digits_re.replace(<span class="string">'\\'</span>, <span class="string">r'\\'</span>), sample))</span><br><span class="line">/usr/sbin/sendmail - \d+ errors, \d+ warnings</span><br></pre></td></tr></table></figure><p>  <em>在 3.3 版更改:</em> <code>&#39;_&#39;</code> 不再被转义。<em>在 3.7 版更改:</em> 只有在正则表达式中具有特殊含义的字符才会被转义。 因此， <code>&#39;!&#39;</code>, <code>&#39;&quot;&#39;</code>, <code>&#39;%&#39;</code>, <code>&quot;&#39;&quot;</code>, <code>&#39;,&#39;</code>, <code>&#39;/&#39;</code>, <code>&#39;:&#39;</code>, <code>&#39;;&#39;</code>, <code>&#39;&lt;&#39;</code>, <code>&#39;=&#39;</code>, <code>&#39;&gt;&#39;</code>, <code>&#39;@&#39;</code> 和 <code>&quot;</code>“` 将不再会被转义。</p><ul><li><p><code>re.purge</code>()</p><p>清除正则表达式缓存。</p></li><li><p><em>exception</em> <code>re.error</code>(<em>msg</em>, <em>pattern=None</em>, <em>pos=None</em>)</p><p><code>raise</code> 一个例外。当传递到函数的字符串不是一个有效正则表达式的时候（比如，包含一个不匹配的括号）或者其他错误在编译时或匹配时产生。如果字符串不包含样式匹配，是不会被视为错误的。错误实例有以下附加属性：</p><ul><li><p><code>msg</code>未格式化的错误消息。</p></li><li><p><code>pattern</code>正则表达式样式。</p></li><li><p><code>pos</code>编译失败的 <em>pattern</em> 的位置索引（可以是 <code>None</code> ）。</p></li><li><p><code>lineno</code>对应 <em>pos</em> (可以是 <code>None</code>) 的行号。</p></li><li><p><code>colno</code>对应 <em>pos</em> (可以是 <code>None</code>) 的列号。</p><p><em>在 3.5 版更改:</em> 添加了附加属性。</p></li></ul></li></ul><h2 id="正则表达式对象-（正则对象）"><a href="#正则表达式对象-（正则对象）" class="headerlink" title="正则表达式对象 （正则对象）"></a>正则表达式对象 （正则对象）</h2><p>编译后的正则表达式对象支持一下方法和属性：</p><ul><li><p><code>Pattern.search</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p><p>扫描整个 <em>string</em> 寻找第一个匹配的位置， 并返回一个相应的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a>。如果没有匹配，就返回 <code>None</code> ；注意它和零长度匹配是不同的。可选的第二个参数 <em>pos</em> 给出了字符串中开始搜索的位置索引；默认为 <code>0</code>，它不完全等价于字符串切片； <code>&#39;^&#39;</code> 样式字符匹配字符串真正的开头，和换行符后面的第一个字符，但不会匹配索引规定开始的位置。可选参数 <em>endpos</em> 限定了字符串搜索的结束；它假定字符串长度到 <em>endpos</em> ， 所以只有从 <code>pos</code> 到 <code>endpos - 1</code> 的字符会被匹配。如果 <em>endpos</em> 小于 <em>pos</em>，就不会有匹配产生；另外，如果 <em>rx</em> 是一个编译后的正则对象， <code>rx.search(string, 0, 50)</code> 等价于 <code>rx.search(string[:50], 0)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = re.compile(<span class="string">"d"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern.search(<span class="string">"dog"</span>)     <span class="comment"># Match at index 0</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">1</span>), match=<span class="string">'d'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern.search(<span class="string">"dog"</span>, <span class="number">1</span>)  <span class="comment"># No match; search doesn't include the "d"</span></span><br></pre></td></tr></table></figure></li><li><p><code>Pattern.match</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p><p>如果 <em>string</em> 的 <em>开始位置</em> 能够找到这个正则样式的任意个匹配，就返回一个相应的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a>。如果不匹配，就返回 <code>None</code> ；注意它与零长度匹配是不同的。可选参数 <em>pos</em> 和 <em>endpos</em> 与 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 含义相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = re.compile(<span class="string">"o"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern.match(<span class="string">"dog"</span>)      <span class="comment"># No match as "o" is not at the start of "dog".</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern.match(<span class="string">"dog"</span>, <span class="number">1</span>)   <span class="comment"># Match as "o" is the 2nd character of "dog".</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">1</span>, <span class="number">2</span>), match=<span class="string">'o'</span>&gt;</span><br></pre></td></tr></table></figure><p>如果你想定位匹配在 <em>string</em> 中的位置，使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 来替代（另参考 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#search-vs-match" target="_blank" rel="noopener">search() vs. match()</a>）。</p></li><li><p><code>Pattern.fullmatch</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p><p>如果整个 <em>string</em> 匹配这个正则表达式，就返回一个相应的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a> 。 否则就返回 <code>None</code> ； 注意跟零长度匹配是不同的。可选参数 <em>pos</em> 和 <em>endpos</em> 与 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 含义相同.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = re.compile(<span class="string">"o[gh]"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern.fullmatch(<span class="string">"dog"</span>)      <span class="comment"># No match as "o" is not at the start of "dog".</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern.fullmatch(<span class="string">"ogre"</span>)     <span class="comment"># No match as not the full string matches.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern.fullmatch(<span class="string">"doggie"</span>, <span class="number">1</span>, <span class="number">3</span>)   <span class="comment"># Matches within given limits.</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">1</span>, <span class="number">3</span>), match=<span class="string">'og'</span>&gt;</span><br></pre></td></tr></table></figure><p><em>3.4 新版功能.</em></p></li><li><p><code>Pattern.split</code>(<em>string</em>, <em>maxsplit=0</em>)</p><p>等价于 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.split" target="_blank" rel="noopener"><code>split()</code></a> 函数，使用了编译后的样式。</p></li><li><p><code>Pattern.findall</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p><p>类似函数 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.findall" target="_blank" rel="noopener"><code>findall()</code></a> ， 使用了编译后样式，但也可以接收可选参数 <em>pos</em> 和 <em>endpos</em> ，限制搜索范围，就像 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>search()</code></a>。</p></li><li><p><code>Pattern.finditer</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p><p>类似函数 <code>finiter()</code> ， 使用了编译后样式，但也可以接收可选参数 <em>pos</em> 和 <em>endpos</em> ，限制搜索范围，就像 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>search()</code></a>。</p></li><li><p><code>Pattern.sub</code>(<em>repl</em>, <em>string</em>, <em>count=0</em>)</p><p>等价于 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.sub" target="_blank" rel="noopener"><code>sub()</code></a> 函数，使用了编译后的样式。</p></li><li><p><code>Pattern.subn</code>(<em>repl</em>, <em>string</em>, <em>count=0</em>)</p><p>等价于 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.subn" target="_blank" rel="noopener"><code>subn()</code></a> 函数，使用了编译后的样式。</p></li><li><p><code>Pattern.flags</code></p><p>正则匹配标记。这是可以传递给 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.compile" target="_blank" rel="noopener"><code>compile()</code></a> 的参数，任何 <code>(?…)</code> 内联标记，隐性标记比如 <code>UNICODE</code> 的结合。</p></li><li><p><code>Pattern.groups</code></p><p>捕获组合的数量。</p></li><li><p><code>Pattern.groupindex</code></p><p>映射由 <code>(?P)</code> 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的。</p></li><li><p><code>Pattern.pattern</code></p><p>编译对象的原始样式字符串。</p></li></ul><p><em>在 3.7 版更改:</em> 添加 <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#copy.copy" target="_blank" rel="noopener"><code>copy.copy()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#copy.deepcopy" target="_blank" rel="noopener"><code>copy.deepcopy()</code></a> 函数的支持。编译后的正则表达式对象被认为是原子性的。</p><h2 id="匹配对象"><a href="#匹配对象" class="headerlink" title="匹配对象"></a>匹配对象</h2><p>匹配对象总是有一个布尔值 <code>True</code>。如果没有匹配的话 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.match" target="_blank" rel="noopener"><code>match()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 返回 <code>None</code> 所以你可以简单的用 <code>if</code> 语句来判断是否匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">match = re.search(pattern, string)</span><br><span class="line">if match:</span><br><span class="line">    process(match)</span><br></pre></td></tr></table></figure><p>匹配对象支持以下方法和属性：</p><ul><li><p><code>Match.expand</code>(<em>template</em>)</p><p>对 <em>template</em> 进行反斜杠转义替换并且返回，就像 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.sub" target="_blank" rel="noopener"><code>sub()</code></a> 方法中一样。转义如同 <code>\n</code> 被转换成合适的字符，数字引用(<code>\1</code>, <code>\2</code>)和命名组合(<code>\g&lt;1&gt;</code>, <code>\g</code>) 替换为相应组合的内容。<em>在 3.5 版更改:</em> 不匹配的组合替换为空字符串。</p></li><li><p><code>Match.group</code>([<em>group1</em>, <em>…</em>])</p><p>返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，组1默认到0（整个匹配都被返回）。 如果一个组N 参数值为 0，相应的返回值就是整个匹配字符串；如果它是一个范围 [1..99]，结果就是相应的括号组字符串。如果一个组号是负数，或者大于样式中定义的组数，一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 索引错误就 <code>raise</code>。如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(\w+) (\w+)"</span>, <span class="string">"Isaac Newton, physicist"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)       <span class="comment"># The entire match</span></span><br><span class="line"><span class="string">'Isaac Newton'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)       <span class="comment"># The first parenthesized subgroup.</span></span><br><span class="line"><span class="string">'Isaac'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)       <span class="comment"># The second parenthesized subgroup.</span></span><br><span class="line"><span class="string">'Newton'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>, <span class="number">2</span>)    <span class="comment"># Multiple arguments give us a tuple.</span></span><br><span class="line">(<span class="string">'Isaac'</span>, <span class="string">'Newton'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>  <code>如果正则表达式使用了</code>(?P…)<code>语法， *groupN* 参数就也可能是命名组合的名字。如果一个字符串参数在样式中未定义为组合名，一个 [</code>IndexError<code>](https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError) 就</code>raise<code>。</code></p><p>  `一个相对复杂的例子</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)"</span>, <span class="string">"Malcolm Reynolds"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="string">'first_name'</span>)</span><br><span class="line"><span class="string">'Malcolm'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="string">'last_name'</span>)</span><br><span class="line"><span class="string">'Reynolds'</span></span><br></pre></td></tr></table></figure><p>  如果一个组匹配成功多次，就只返回最后一个匹配</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(..)+"</span>, <span class="string">"a1b2c3"</span>)  <span class="comment"># Matches 3 times.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)                        <span class="comment"># Returns only the last match.</span></span><br><span class="line"><span class="string">'c3'</span></span><br></pre></td></tr></table></figure><ul><li><p><code>Match.__getitem__</code>(<em>g</em>)</p><p>这个等价于 <code>m.group(g)</code>。这允许更方便的引用一个匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(\w+) (\w+)"</span>, <span class="string">"Isaac Newton, physicist"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="number">0</span>]       <span class="comment"># The entire match</span></span><br><span class="line"><span class="string">'Isaac Newton'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="number">1</span>]       <span class="comment"># The first parenthesized subgroup.</span></span><br><span class="line"><span class="string">'Isaac'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m[<span class="number">2</span>]       <span class="comment"># The second parenthesized subgroup.</span></span><br><span class="line"><span class="string">'Newton'</span></span><br></pre></td></tr></table></figure><p> ‘Newton’ `<em>3.6 新版功能.</em></p></li><li><p><code>Match.groups</code>(<em>default=None</em>)</p><p>返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合。 <em>default</em> 参数用于不参与匹配的情况，默认为 <code>None</code>。例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(\d+)\.(\d+)"</span>, <span class="string">"24.1632"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()</span><br><span class="line">(<span class="string">'24'</span>, <span class="string">'1632'</span>)</span><br></pre></td></tr></table></figure><p>如果我们使小数点可选，那么不是所有的组都会参与到匹配当中。这些组合默认会返回一个 <code>None</code> ，除非指定了 <em>default</em> 参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(\d+)\.?(\d+)?"</span>, <span class="string">"24"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()      <span class="comment"># Second group defaults to None.</span></span><br><span class="line">(<span class="string">'24'</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups(<span class="string">'0'</span>)   <span class="comment"># Now, the second group defaults to '0'.</span></span><br><span class="line">(<span class="string">'24'</span>, <span class="string">'0'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>Match.groupdict</code>(<em>default=None</em>)</p><p>返回一个字典，包含了所有的 <em>命名</em> 子组。key就是组名。 <em>default</em> 参数用于不参与匹配的组合；默认为 <code>None</code>。 例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r"(?P&lt;first_name&gt;\w+) (?P&lt;last_name&gt;\w+)"</span>, <span class="string">"Malcolm Reynolds"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groupdict()</span><br><span class="line">&#123;<span class="string">'first_name'</span>: <span class="string">'Malcolm'</span>, <span class="string">'last_name'</span>: <span class="string">'Reynolds'</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Match.start</code>([<em>group</em>])</p></li><li><p><code>Match.end</code>([<em>group</em>])</p><p>返回 <em>group</em> 匹配到的字串的开始和结束标号。<em>group</em> 默认为0（意思是整个匹配的子串）。如果 <em>group</em> 存在，但未产生匹配，就返回 <code>-1</code> 。对于一个匹配对象 <em>m</em>， 和一个未参与匹配的组 <em>g</em> ，组 <em>g</em> (等价于 <code>m.group(g)</code>)产生的匹配是</p><p><code>m.string[m.start(g):m.end(g)]</code></p><p>注意 <code>m.start(group)</code> 将会等于 <code>m.end(group)</code> ，如果 <em>group</em> 匹配一个空字符串的话。比如，在 <code>m = re.search(&#39;b(c?)&#39;, &#39;cba&#39;)</code> 之后，<code>m.start(0)</code> 为 1, <code>m.end(0)</code> 为 2, <code>m.start(1)</code> 和 <code>m.end(1)</code> 都是 2, <code>m.start(2)</code> raise 一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 例外。这个例子会从email地址中移除掉 <em>remove_this</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>email = <span class="string">"tony@tiremove_thisger.net"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.search(<span class="string">"remove_this"</span>, email)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>email[:m.start()] + email[m.end():]</span><br><span class="line"><span class="string">'tony@tiger.net'</span></span><br></pre></td></tr></table></figure></li><li><p><code>Match.span</code>([<em>group</em>])</p><p>对于一个匹配 <em>m</em> ， 返回一个二元组 <code>(m.start(group), m.end(group))</code> 。 注意如果 <em>group</em> 没有在这个匹配中，就返回 <code>(-1, -1)</code> 。<em>group</em> 默认为0，就是整个匹配。</p></li><li><p><code>Match.pos</code></p><p><em>pos</em> 的值，会传递给 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.match" target="_blank" rel="noopener"><code>match()</code></a> 的方法 a <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re-objects" target="_blank" rel="noopener">正则对象</a> 。这个是正则引擎开始在字符串搜索一个匹配的索引位置。</p></li><li><p><code>Match.endpos</code></p><p><em>endpos</em> 的值，会传递给 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.match" target="_blank" rel="noopener"><code>match()</code></a> 的方法 a <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re-objects" target="_blank" rel="noopener">正则对象</a> 。这个是正则引擎停止在字符串搜索一个匹配的索引位置。</p></li><li><p><code>Match.lastindex</code></p><p>捕获组的最后一个匹配的整数索引值，或者 <code>None</code> 如果没有匹配产生的话。比如，对于字符串 <code>&#39;ab&#39;</code>，表达式 <code>(a)b</code>, <code>((a)(b))</code>, 和 <code>((ab))</code> 将得到 <code>lastindex == 1</code> ， 而 <code>(a)(b)</code> 会得到 <code>lastindex == 2</code> 。</p></li><li><p><code>Match.lastgroup</code></p><p>最后一个匹配的命名组名字，或者 <code>None</code> 如果没有产生匹配的话。</p></li><li><p><code>Match.re</code></p><p>返回产生这个实例的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re-objects" target="_blank" rel="noopener">正则对象</a> ， 这个实例是由 正则对象的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.match" target="_blank" rel="noopener"><code>match()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 方法产生的。</p></li><li><p><code>Match.string</code></p><p>传递到 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.match" target="_blank" rel="noopener"><code>match()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Pattern.search" target="_blank" rel="noopener"><code>search()</code></a> 的字符串。</p></li></ul><p><em>在 3.7 版更改:</em> 添加了对 <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#copy.copy" target="_blank" rel="noopener"><code>copy.copy()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#copy.deepcopy" target="_blank" rel="noopener"><code>copy.deepcopy()</code></a> 的支持。匹配对象被看作是原子性的。</p><h2 id="正则表达式例子"><a href="#正则表达式例子" class="headerlink" title="正则表达式例子"></a>正则表达式例子</h2><h3 id="检查对子"><a href="#检查对子" class="headerlink" title="检查对子"></a>检查对子</h3><p>在这个例子里，我们使用以下辅助函数来更好地显示匹配对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def displaymatch(match):</span><br><span class="line">    if match is None:</span><br><span class="line">        return None</span><br><span class="line">    return &apos;&lt;Match: %r, groups=%r&gt;&apos; % (match.group(), match.groups())</span><br></pre></td></tr></table></figure><p>假设你在写一个扑克程序，一个玩家的一手牌为五个字符的串，每个字符表示一张牌，”a” 就是 A, “k” K， “q” Q, “j” J, “t” 为 10, “2” 到 “9” 表示2 到 9。</p><p>要看给定的字符串是否有效，我们可以按照以下步骤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>valid = re.compile(<span class="string">r"^[a2-9tjqk]&#123;5&#125;$"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>displaymatch(valid.match(<span class="string">"akt5q"</span>))  <span class="comment"># Valid.</span></span><br><span class="line"><span class="string">"&lt;Match: 'akt5q', groups=()&gt;"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>displaymatch(valid.match(<span class="string">"akt5e"</span>))  <span class="comment"># Invalid.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>displaymatch(valid.match(<span class="string">"akt"</span>))    <span class="comment"># Invalid.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>displaymatch(valid.match(<span class="string">"727ak"</span>))  <span class="comment"># Valid.</span></span><br><span class="line"><span class="string">"&lt;Match: '727ak', groups=()&gt;"</span></span><br></pre></td></tr></table></figure><p>最后一手牌，<code>&quot;727ak&quot;</code> ，包含了一个对子，或者两张同样数值的牌。要用正则表达式匹配它，应该使用向后引用如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair = re.compile(<span class="string">r".*(.).*\1"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>displaymatch(pair.match(<span class="string">"717ak"</span>))     <span class="comment"># Pair of 7s.</span></span><br><span class="line"><span class="string">"&lt;Match: '717', groups=('7',)&gt;"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>displaymatch(pair.match(<span class="string">"718ak"</span>))     <span class="comment"># No pairs.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>displaymatch(pair.match(<span class="string">"354aa"</span>))     <span class="comment"># Pair of aces.</span></span><br><span class="line"><span class="string">"&lt;Match: '354aa', groups=('a',)&gt;"</span></span><br></pre></td></tr></table></figure><p>要找出对子由什么牌组成，开发者可以按照下面的方式来使用匹配对象的 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.Match.group" target="_blank" rel="noopener"><code>group()</code></a> 方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair = re.compile(<span class="string">r".*(.).*\1"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair.match(<span class="string">"717ak"</span>).group(<span class="number">1</span>)</span><br><span class="line"><span class="string">'7'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Error because re.match() returns None, which doesn't have a group() method:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair.match(<span class="string">"718ak"</span>).group(<span class="number">1</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#23&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    re.match(<span class="string">r".*(.).*\1"</span>, <span class="string">"718ak"</span>).group(<span class="number">1</span>)</span><br><span class="line">AttributeError: <span class="string">'NoneType'</span> object has no attribute <span class="string">'group'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pair.match(<span class="string">"354aa"</span>).group(<span class="number">1</span>)</span><br><span class="line"><span class="string">'a'</span></span><br></pre></td></tr></table></figure><h3 id="模拟-scanf"><a href="#模拟-scanf" class="headerlink" title="模拟 scanf()"></a>模拟 scanf()</h3><p>Python 目前没有一个类似c函数 <code>scanf()</code> 的替代品。正则表达式通常比 <code>scanf()</code> 格式字符串要更强大一些，但也带来更多复杂性。下面的表格提供了 <code>scanf()</code> 格式符和正则表达式大致相同的映射。</p><table><thead><tr><th style="text-align:left"><code>scanf()</code> 格式符</th><th style="text-align:left">正则表达式</th></tr></thead><tbody><tr><td style="text-align:left"><code>%c</code></td><td style="text-align:left"><code>.</code></td></tr><tr><td style="text-align:left"><code>%5c</code></td><td style="text-align:left"><code>.{5}</code></td></tr><tr><td style="text-align:left"><code>%d</code></td><td style="text-align:left"><code>[-+]?\d+</code></td></tr><tr><td style="text-align:left"><code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%g</code></td><td style="text-align:left">`[-+]?(\d+(.\d*)?</td><td>.\d+)([eE][-+]?\d+)?`</td></tr><tr><td style="text-align:left"><code>%i</code></td><td style="text-align:left">`[-+]?(0[xX][\dA-Fa-f]+</td><td>0[0-7]*</td><td>\d+)`</td></tr><tr><td style="text-align:left"><code>%o</code></td><td style="text-align:left"><code>[-+]?[0-7]+</code></td></tr><tr><td style="text-align:left"><code>%s</code></td><td style="text-align:left"><code>\S+</code></td></tr><tr><td style="text-align:left"><code>%u</code></td><td style="text-align:left"><code>\d+</code></td></tr><tr><td style="text-align:left"><code>%x</code>, <code>%X</code></td><td style="text-align:left"><code>[-+]?(0[xX])?[\dA-Fa-f]+</code></td></tr></tbody></table><p>从文件名和数字提取字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/sendmail - <span class="number">0</span> errors, <span class="number">4</span> warnings</span><br></pre></td></tr></table></figure><p>你可以使用 <code>scanf()</code> 格式化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s - %d errors, %d warnings</span><br></pre></td></tr></table></figure><p>等价的正则表达式是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\S+) - (\d+) errors, (\d+) warnings</span><br></pre></td></tr></table></figure><h3 id="search-vs-match"><a href="#search-vs-match" class="headerlink" title="search() vs. match()"></a>search() vs. match()</h3><p>Python 提供了两种不同的操作：基于 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.match" target="_blank" rel="noopener"><code>re.match()</code></a> 检查字符串开头，或者 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>re.search()</code></a> 检查字符串的任意位置（默认Perl中的行为）。</p><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">"c"</span>, <span class="string">"abcdef"</span>)    <span class="comment"># No match</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">"c"</span>, <span class="string">"abcdef"</span>)   <span class="comment"># Match</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">2</span>, <span class="number">3</span>), match=<span class="string">'c'</span>&gt;</span><br></pre></td></tr></table></figure><p>在 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>search()</code></a> 中，可以用 <code>&#39;^&#39;</code> 作为开始来限制匹配到字符串的首位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">"c"</span>, <span class="string">"abcdef"</span>)    <span class="comment"># No match</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">"^c"</span>, <span class="string">"abcdef"</span>)  <span class="comment"># No match</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">"^a"</span>, <span class="string">"abcdef"</span>)  <span class="comment"># Match</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">1</span>), match=<span class="string">'a'</span>&gt;</span><br></pre></td></tr></table></figure><p>注意 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.MULTILINE" target="_blank" rel="noopener"><code>MULTILINE</code></a> 多行模式中函数 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.match" target="_blank" rel="noopener"><code>match()</code></a> 只匹配字符串的开始，但使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>search()</code></a> 和以 <code>&#39;^&#39;</code> 开始的正则表达式会匹配每行的开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(&apos;X&apos;, &apos;A\nB\nX&apos;, re.MULTILINE)  # No match</span><br><span class="line">&gt;&gt;&gt; re.search(&apos;^X&apos;, &apos;A\nB\nX&apos;, re.MULTILINE)  # Match</span><br><span class="line">&lt;re.Match object; span=(4, 5), match=&apos;X&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="建立一个电话本"><a href="#建立一个电话本" class="headerlink" title="建立一个电话本"></a>建立一个电话本</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.split" target="_blank" rel="noopener"><code>split()</code></a> 将字符串用参数传递的样式分隔开。这个方法对于转换文本数据到易读而且容易修改的数据结构，是很有用的，如下面的例子证明。</p><p>首先，这里是输入。 它通常来自一个文件，这里我们使用三重引号字符串语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">"""Ross McFluff: 834.345.1254 155 Elm Street</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>Ronald Heathmore: 892.345.3428 436 Finley Avenue</span></span><br><span class="line"><span class="string"><span class="meta">... </span>Frank Burger: 925.541.7625 662 South Dogwood Way</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"><span class="meta">... </span>Heather Albrecht: 548.326.4584 919 Park Place"""</span></span><br></pre></td></tr></table></figure><p>条目用一个或者多个换行符分开。现在我们将字符串转换为一个列表，每个非空行都有一个条目:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>entries = re.split(<span class="string">"\n+"</span>, text)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>entries</span><br><span class="line">[<span class="string">'Ross McFluff: 834.345.1254 155 Elm Street'</span>,</span><br><span class="line"><span class="string">'Ronald Heathmore: 892.345.3428 436 Finley Avenue'</span>,</span><br><span class="line"><span class="string">'Frank Burger: 925.541.7625 662 South Dogwood Way'</span>,</span><br><span class="line"><span class="string">'Heather Albrecht: 548.326.4584 919 Park Place'</span>]</span><br></pre></td></tr></table></figure><p>最终，将每个条目分割为一个由名字、姓氏、电话号码和地址组成的列表。我们为 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.split" target="_blank" rel="noopener"><code>split()</code></a> 使用了 <code>maxsplit</code> 形参，因为地址中包含有被我们作为分割模式的空格符:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[re.split(<span class="string">":? "</span>, entry, <span class="number">3</span>) <span class="keyword">for</span> entry <span class="keyword">in</span> entries]</span><br><span class="line">[[<span class="string">'Ross'</span>, <span class="string">'McFluff'</span>, <span class="string">'834.345.1254'</span>, <span class="string">'155 Elm Street'</span>],</span><br><span class="line">[<span class="string">'Ronald'</span>, <span class="string">'Heathmore'</span>, <span class="string">'892.345.3428'</span>, <span class="string">'436 Finley Avenue'</span>],</span><br><span class="line">[<span class="string">'Frank'</span>, <span class="string">'Burger'</span>, <span class="string">'925.541.7625'</span>, <span class="string">'662 South Dogwood Way'</span>],</span><br><span class="line">[<span class="string">'Heather'</span>, <span class="string">'Albrecht'</span>, <span class="string">'548.326.4584'</span>, <span class="string">'919 Park Place'</span>]]</span><br></pre></td></tr></table></figure><p><code>:?</code> 样式匹配姓后面的冒号，因此它不出现在结果列表中。如果 <code>maxsplit</code> 设置为 <code>4</code> ，我们还可以从地址中获取到房间号:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[re.split(<span class="string">":? "</span>, entry, <span class="number">4</span>) <span class="keyword">for</span> entry <span class="keyword">in</span> entries]</span><br><span class="line">[[<span class="string">'Ross'</span>, <span class="string">'McFluff'</span>, <span class="string">'834.345.1254'</span>, <span class="string">'155'</span>, <span class="string">'Elm Street'</span>],</span><br><span class="line">[<span class="string">'Ronald'</span>, <span class="string">'Heathmore'</span>, <span class="string">'892.345.3428'</span>, <span class="string">'436'</span>, <span class="string">'Finley Avenue'</span>],</span><br><span class="line">[<span class="string">'Frank'</span>, <span class="string">'Burger'</span>, <span class="string">'925.541.7625'</span>, <span class="string">'662'</span>, <span class="string">'South Dogwood Way'</span>],</span><br><span class="line">[<span class="string">'Heather'</span>, <span class="string">'Albrecht'</span>, <span class="string">'548.326.4584'</span>, <span class="string">'919'</span>, <span class="string">'Park Place'</span>]]</span><br></pre></td></tr></table></figure><h3 id="文字整理"><a href="#文字整理" class="headerlink" title="文字整理"></a>文字整理</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.sub" target="_blank" rel="noopener"><code>sub()</code></a> 替换字符串中出现的样式的每一个实例。这个例子证明了使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.sub" target="_blank" rel="noopener"><code>sub()</code></a> 来整理文字，或者随机化每个字符的位置，除了首位和末尾字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def repl(m):</span><br><span class="line">...     inner_word = list(m.group(2))</span><br><span class="line">...     random.shuffle(inner_word)</span><br><span class="line">...     return m.group(1) + &quot;&quot;.join(inner_word) + m.group(3)</span><br><span class="line">&gt;&gt;&gt; text = &quot;Professor Abdolmalek, please report your absences promptly.&quot;</span><br><span class="line">&gt;&gt;&gt; re.sub(r&quot;(\w)(\w+)(\w)&quot;, repl, text)</span><br><span class="line">&apos;Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.&apos;</span><br><span class="line">&gt;&gt;&gt; re.sub(r&quot;(\w)(\w+)(\w)&quot;, repl, text)</span><br><span class="line">&apos;Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.&apos;</span><br></pre></td></tr></table></figure><h3 id="找到所有副词"><a href="#找到所有副词" class="headerlink" title="找到所有副词"></a>找到所有副词</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.findall" target="_blank" rel="noopener"><code>findall()</code></a> 匹配样式 <em>所有</em> 的出现，不仅是像 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.search" target="_blank" rel="noopener"><code>search()</code></a> 中的第一个匹配。比如，如果一个作者希望找到文字中的所有副词，他可能会按照以下方法用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.findall" target="_blank" rel="noopener"><code>findall()</code></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; text = &quot;He was carefully disguised but captured quickly by police.&quot;</span><br><span class="line">&gt;&gt;&gt; re.findall(r&quot;\w+ly&quot;, text)</span><br><span class="line">[&apos;carefully&apos;, &apos;quickly&apos;]</span><br></pre></td></tr></table></figure><h3 id="找到所有副词和位置"><a href="#找到所有副词和位置" class="headerlink" title="找到所有副词和位置"></a>找到所有副词和位置</h3><p>如果需要匹配样式的更多信息， <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.finditer" target="_blank" rel="noopener"><code>finditer()</code></a> 可以起到作用，它提供了 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#match-objects" target="_blank" rel="noopener">匹配对象</a> 作为返回值，而不是字符串。继续上面的例子，如果一个作者希望找到所有副词和它的位置，可以按照下面方法使用 <a href="https://docs.python.org/zh-cn/3.8/library/re.html#re.finditer" target="_blank" rel="noopener"><code>finditer()</code></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; text = &quot;He was carefully disguised but captured quickly by police.&quot;</span><br><span class="line">&gt;&gt;&gt; for m in re.finditer(r&quot;\w+ly&quot;, text):</span><br><span class="line">...     print(&apos;%02d-%02d: %s&apos; % (m.start(), m.end(), m.group(0)))</span><br><span class="line">07-16: carefully</span><br><span class="line">40-47: quickly</span><br></pre></td></tr></table></figure><h3 id="原始字符记法"><a href="#原始字符记法" class="headerlink" title="原始字符记法"></a>原始字符记法</h3><p>原始字符串记法 (<code>r&quot;text&quot;</code>) 保持正则表达式正常。否则，每个正则式里的反斜杠(<code>&#39;\&#39;</code>) 都必须前缀一个反斜杠来转义。比如，下面两行代码功能就是完全一致的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&quot;\W(.)\1\W&quot;, &quot; ff &quot;)</span><br><span class="line">&lt;re.Match object; span=(0, 4), match=&apos; ff &apos;&gt;</span><br><span class="line">&gt;&gt;&gt; re.match(&quot;\\W(.)\\1\\W&quot;, &quot; ff &quot;)</span><br><span class="line">&lt;re.Match object; span=(0, 4), match=&apos; ff &apos;&gt;</span><br></pre></td></tr></table></figure><p>当需要匹配一个字符反斜杠，它必须在正则表达式中转义。在原始字符串记法，就是 <code>r&quot;\\&quot;</code>。否则就必须用 <code>&quot;\\\\&quot;</code>，来表示同样的意思</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&quot;\\&quot;, r&quot;\\&quot;)</span><br><span class="line">&lt;re.Match object; span=(0, 1), match=&apos;\\&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; re.match(&quot;\\\\&quot;, r&quot;\\&quot;)</span><br><span class="line">&lt;re.Match object; span=(0, 1), match=&apos;\\&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="写一个词法分析器"><a href="#写一个词法分析器" class="headerlink" title="写一个词法分析器"></a>写一个词法分析器</h3><p>一个 <a href="https://en.wikipedia.org/wiki/Lexical_analysis" target="_blank" rel="noopener">词法器或词法分析器</a> 分析字符串，并分类成目录组。 这是写一个编译器或解释器的第一步。</p><p>文字目录是由正则表达式指定的。这个技术是通过将这些样式合并为一个主正则式，并且循环匹配来实现的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">Token = collections.namedtuple(<span class="string">'Token'</span>, [<span class="string">'type'</span>, <span class="string">'value'</span>, <span class="string">'line'</span>, <span class="string">'column'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tokenize</span><span class="params">(code)</span>:</span></span><br><span class="line">    keywords = &#123;<span class="string">'IF'</span>, <span class="string">'THEN'</span>, <span class="string">'ENDIF'</span>, <span class="string">'FOR'</span>, <span class="string">'NEXT'</span>, <span class="string">'GOSUB'</span>, <span class="string">'RETURN'</span>&#125;</span><br><span class="line">    token_specification = [</span><br><span class="line">        (<span class="string">'NUMBER'</span>,   <span class="string">r'\d+(\.\d*)?'</span>),  <span class="comment"># Integer or decimal number</span></span><br><span class="line">        (<span class="string">'ASSIGN'</span>,   <span class="string">r':='</span>),           <span class="comment"># Assignment operator</span></span><br><span class="line">        (<span class="string">'END'</span>,      <span class="string">r';'</span>),            <span class="comment"># Statement terminator</span></span><br><span class="line">        (<span class="string">'ID'</span>,       <span class="string">r'[A-Za-z]+'</span>),    <span class="comment"># Identifiers</span></span><br><span class="line">        (<span class="string">'OP'</span>,       <span class="string">r'[+\-*/]'</span>),      <span class="comment"># Arithmetic operators</span></span><br><span class="line">        (<span class="string">'NEWLINE'</span>,  <span class="string">r'\n'</span>),           <span class="comment"># Line endings</span></span><br><span class="line">        (<span class="string">'SKIP'</span>,     <span class="string">r'[ \t]+'</span>),       <span class="comment"># Skip over spaces and tabs</span></span><br><span class="line">        (<span class="string">'MISMATCH'</span>, <span class="string">r'.'</span>),            <span class="comment"># Any other character</span></span><br><span class="line">    ]</span><br><span class="line">    tok_regex = <span class="string">'|'</span>.join(<span class="string">'(?P&lt;%s&gt;%s)'</span> % pair <span class="keyword">for</span> pair <span class="keyword">in</span> token_specification)</span><br><span class="line">    line_num = <span class="number">1</span></span><br><span class="line">    line_start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> mo <span class="keyword">in</span> re.finditer(tok_regex, code):</span><br><span class="line">        kind = mo.lastgroup</span><br><span class="line">        value = mo.group()</span><br><span class="line">        column = mo.start() - line_start</span><br><span class="line">        <span class="keyword">if</span> kind == <span class="string">'NUMBER'</span>:</span><br><span class="line">            value = float(value) <span class="keyword">if</span> <span class="string">'.'</span> <span class="keyword">in</span> value <span class="keyword">else</span> int(value)</span><br><span class="line">        <span class="keyword">elif</span> kind == <span class="string">'ID'</span> <span class="keyword">and</span> value <span class="keyword">in</span> keywords:</span><br><span class="line">            kind = value</span><br><span class="line">        <span class="keyword">elif</span> kind == <span class="string">'NEWLINE'</span>:</span><br><span class="line">            line_start = mo.end()</span><br><span class="line">            line_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> kind == <span class="string">'SKIP'</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> kind == <span class="string">'MISMATCH'</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">f'<span class="subst">&#123;value!r&#125;</span> unexpected on line <span class="subst">&#123;line_num&#125;</span>'</span>)</span><br><span class="line">        <span class="keyword">yield</span> Token(kind, value, line_num, column)</span><br><span class="line"></span><br><span class="line">statements = <span class="string">'''</span></span><br><span class="line"><span class="string">    IF quantity THEN</span></span><br><span class="line"><span class="string">        total := total + price * quantity;</span></span><br><span class="line"><span class="string">        tax := price * 0.05;</span></span><br><span class="line"><span class="string">    ENDIF;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> tokenize(statements):</span><br><span class="line">    print(token)</span><br></pre></td></tr></table></figure><p>这个词法器产生以下输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Token(type=<span class="string">'IF'</span>, value=<span class="string">'IF'</span>, line=<span class="number">2</span>, column=<span class="number">4</span>)</span><br><span class="line">Token(type=<span class="string">'ID'</span>, value=<span class="string">'quantity'</span>, line=<span class="number">2</span>, column=<span class="number">7</span>)</span><br><span class="line">Token(type=<span class="string">'THEN'</span>, value=<span class="string">'THEN'</span>, line=<span class="number">2</span>, column=<span class="number">16</span>)</span><br><span class="line">Token(type=<span class="string">'ID'</span>, value=<span class="string">'total'</span>, line=<span class="number">3</span>, column=<span class="number">8</span>)</span><br><span class="line">Token(type=<span class="string">'ASSIGN'</span>, value=<span class="string">':='</span>, line=<span class="number">3</span>, column=<span class="number">14</span>)</span><br><span class="line">Token(type=<span class="string">'ID'</span>, value=<span class="string">'total'</span>, line=<span class="number">3</span>, column=<span class="number">17</span>)</span><br><span class="line">Token(type=<span class="string">'OP'</span>, value=<span class="string">'+'</span>, line=<span class="number">3</span>, column=<span class="number">23</span>)</span><br><span class="line">Token(type=<span class="string">'ID'</span>, value=<span class="string">'price'</span>, line=<span class="number">3</span>, column=<span class="number">25</span>)</span><br><span class="line">Token(type=<span class="string">'OP'</span>, value=<span class="string">'*'</span>, line=<span class="number">3</span>, column=<span class="number">31</span>)</span><br><span class="line">Token(type=<span class="string">'ID'</span>, value=<span class="string">'quantity'</span>, line=<span class="number">3</span>, column=<span class="number">33</span>)</span><br><span class="line">Token(type=<span class="string">'END'</span>, value=<span class="string">';'</span>, line=<span class="number">3</span>, column=<span class="number">41</span>)</span><br><span class="line">Token(type=<span class="string">'ID'</span>, value=<span class="string">'tax'</span>, line=<span class="number">4</span>, column=<span class="number">8</span>)</span><br><span class="line">Token(type=<span class="string">'ASSIGN'</span>, value=<span class="string">':='</span>, line=<span class="number">4</span>, column=<span class="number">12</span>)</span><br><span class="line">Token(type=<span class="string">'ID'</span>, value=<span class="string">'price'</span>, line=<span class="number">4</span>, column=<span class="number">15</span>)</span><br><span class="line">Token(type=<span class="string">'OP'</span>, value=<span class="string">'*'</span>, line=<span class="number">4</span>, column=<span class="number">21</span>)</span><br><span class="line">Token(type=<span class="string">'NUMBER'</span>, value=<span class="number">0.05</span>, line=<span class="number">4</span>, column=<span class="number">23</span>)</span><br><span class="line">Token(type=<span class="string">'END'</span>, value=<span class="string">';'</span>, line=<span class="number">4</span>, column=<span class="number">27</span>)</span><br><span class="line">Token(type=<span class="string">'ENDIF'</span>, value=<span class="string">'ENDIF'</span>, line=<span class="number">5</span>, column=<span class="number">4</span>)</span><br><span class="line">Token(type=<span class="string">'END'</span>, value=<span class="string">';'</span>, line=<span class="number">5</span>, column=<span class="number">9</span>)</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://docs.python.org/zh-cn/3.8/library/re.html#id1" target="_blank" rel="noopener">Frie09</a></p><p>Friedl, Jeffrey. Mastering Regular Expressions. 第三版, O’Reilly Media, 2009. 第三版不再使用Python, 但第一版提供了编写正则表达式的良好细节。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-re-正则表达式&quot;&gt;&lt;a href=&quot;#python-标准库-re-正则表达式&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 re 正则表达式&quot;&gt;&lt;/a&gt;python 标准库 re 正则表达式&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200318_china.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="re" scheme="https://pinghailinfeng.gitee.io/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library modulefinder</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/17/python-standard-library-modulefinder/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/17/python-standard-library-modulefinder/</id>
    <published>2020-03-17T14:57:37.000Z</published>
    <updated>2020-03-22T15:54:04.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-modulefinder"><a href="#python-标准库-modulefinder" class="headerlink" title="python 标准库 modulefinder"></a>python 标准库 modulefinder</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200317_finder.jpg?raw=true" alt></p><a id="more"></a><p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/modulefinder.py" target="_blank" rel="noopener">Lib/modulefinder.py</a></p><hr><p>该模块提供了一个 <a href="https://docs.python.org/zh-cn/3.8/library/modulefinder.html#modulefinder.ModuleFinder" target="_blank" rel="noopener"><code>ModuleFinder</code></a> 类，可用于确定脚本导入的模块集。 <code>modulefinder.py</code> 也可以作为脚本运行，给出 Python 脚本的文件名作为参数，之后将打印导入模块的报告。</p><ul><li><p><code>modulefinder.`</code>AddPackagePath`(<em>pkg_name</em>, <em>path</em>)</p><p>记录名为 <em>pkg_name</em> 的包可以在指定的 <em>path</em> 中找到。</p></li><li><p><code>modulefinder.`</code>ReplacePackage`(<em>oldname</em>, <em>newname</em>)</p><p>允许指定名为 <em>oldname</em> 的模块实际上是名为 <em>newname</em> 的包。</p></li><li><p><em>class</em> <code>modulefinder.`</code>ModuleFinder`(<em>path=None</em>, <em>debug=0</em>, <em>excludes=[]</em>, <em>replace_paths=[]</em>)</p><p>该类提供 <a href="https://docs.python.org/zh-cn/3.8/library/modulefinder.html#modulefinder.ModuleFinder.run_script" target="_blank" rel="noopener"><code>run_script()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/modulefinder.html#modulefinder.ModuleFinder.report" target="_blank" rel="noopener"><code>report()</code></a> 方法，用于确定脚本导入的模块集。 <em>path</em> 可以是搜索模块的目录列表；如果没有指定，则使用 <code>sys.path</code> 。 <em>debug</em> 设置调试级别；更高的值使类打印调试消息，关于它正在做什么。 <em>excludes</em> 是要从分析中排除的模块名称列表。 <em>replace_paths</em> 是将在模块路径中替换的 <code>(oldpath, newpath)</code> 元组的列表。<code>report</code>()将报告打印到标准输出，列出脚本导入的模块及其路径，以及缺少或似乎缺失的模块。<code>run_script</code>(<em>pathname</em>)分析 <em>pathname</em> 文件的内容，该文件必须包含 Python 代码。<code>modules</code>一个将模块名称映射到模块的字典。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/modulefinder.html#modulefinder-example" target="_blank" rel="noopener">ModuleFinder 的示例用法</a>。</p></li></ul><h2 id="ModuleFinder-的示例用法"><a href="#ModuleFinder-的示例用法" class="headerlink" title="ModuleFinder 的示例用法"></a><a href="https://docs.python.org/zh-cn/3.8/library/modulefinder.html#modulefinder.ModuleFinder" target="_blank" rel="noopener"><code>ModuleFinder</code></a> 的示例用法</h2><p>稍后将分析的脚本（bacon.py）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re, itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> baconhameggs</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> guido.python.ham</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>将输出 bacon.py 报告的脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> modulefinder <span class="keyword">import</span> ModuleFinder</span><br><span class="line"></span><br><span class="line">finder = ModuleFinder()</span><br><span class="line">finder.run_script(<span class="string">'bacon.py'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Loaded modules:'</span>)</span><br><span class="line"><span class="keyword">for</span> name, mod <span class="keyword">in</span> finder.modules.items():</span><br><span class="line">    print(<span class="string">'%s: '</span> % name, end=<span class="string">''</span>)</span><br><span class="line">    print(<span class="string">','</span>.join(list(mod.globalnames.keys())[:<span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-'</span>*<span class="number">50</span>)</span><br><span class="line">print(<span class="string">'Modules not imported:'</span>)</span><br><span class="line">print(<span class="string">'\n'</span>.join(finder.badmodules.keys()))</span><br></pre></td></tr></table></figure><p>输出样例（可能因架构而异）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Loaded modules:</span><br><span class="line">_types:</span><br><span class="line">copyreg:  _inverted_registry,_slotnames,__all__</span><br><span class="line">sre_compile:  isstring,_sre,_optimize_unicode</span><br><span class="line">_sre:</span><br><span class="line">sre_constants:  REPEAT_ONE,makedict,AT_END_LINE</span><br><span class="line">sys:</span><br><span class="line">re:  __module__,finditer,_expand</span><br><span class="line">itertools:</span><br><span class="line">__main__:  re,itertools,baconhameggs</span><br><span class="line">sre_parse:  _PATTERNENDERS,SRE_FLAG_UNICODE</span><br><span class="line">array:</span><br><span class="line">types:  __module__,IntType,TypeType</span><br><span class="line">---------------------------------------------------</span><br><span class="line">Modules <span class="keyword">not</span> imported:</span><br><span class="line">guido.python.ham</span><br><span class="line">baconhameggs</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-modulefinder&quot;&gt;&lt;a href=&quot;#python-标准库-modulefinder&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 modulefinder&quot;&gt;&lt;/a&gt;python 标准库 modulefinder&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200317_finder.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="modulefinder" scheme="https://pinghailinfeng.gitee.io/tags/modulefinder/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library _thread</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/16/python-standard-library-thread/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/16/python-standard-library-thread/</id>
    <published>2020-03-16T13:35:06.000Z</published>
    <updated>2020-03-16T13:47:23.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-thread"><a href="#python-标准库-thread" class="headerlink" title="python 标准库 _thread"></a>python 标准库 _thread</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200316_multiplethreading.jpg?raw=true" alt></p><a id="more"></a><p><code>python2</code> 中的<code>thread</code> 在 <code>python3</code>中叫<code>_thread</code>。相对于 <code>threading</code>来说更偏底层实现。</p><p>该模块提供了操作多个线程（也被称为 <em>轻量级进程</em> 或 <em>任务</em>）的底层原语 —— 多个控制线程共享全局数据空间。为了处理同步问题，也提供了简单的锁机制（也称为 <em>互斥锁</em> 或 <em>二进制信号</em>）。<a href="https://docs.python.org/zh-cn/3.8/library/threading.html#module-threading" target="_blank" rel="noopener"><code>threading</code></a> 模块基于该模块提供了更易用的高级多线程 API。</p><p><em>在 3.7 版更改:</em> 这个模块曾经是可选的，但现在总是可用的。</p><h2 id="常量和函数"><a href="#常量和函数" class="headerlink" title="常量和函数"></a>常量和函数</h2><p>这个模块定义了以下常量和函数：</p><ul><li><p><em>exception</em> <code>_thread.error</code></p><p>发生线程相关错误时抛出。<em>在 3.3 版更改:</em> 现在是内建异常 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 的别名。</p></li><li><p><code>_thread.LockType</code></p><p>锁对象的类型。</p></li><li><p><code>_thread.start_new_thread</code>(<em>function</em>, <em>args</em>[, <em>kwargs</em>])</p><p>开启一个新线程并返回其标识。 线程执行函数 <em>function</em> 并附带参数列表 <em>args</em> (必须是元组)。 可选的 <em>kwargs</em> 参数指定一个关键字参数字典。当函数返回时，线程会静默地退出。当函数因某个未处理异常而终结时，<a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.unraisablehook" target="_blank" rel="noopener"><code>sys.unraisablehook()</code></a> 会被调用以处理异常。 钩子参数的 <em>object</em> 属性为 <em>function</em>。 在默认情况下，会打印堆栈回溯然后该线程将退出（但其他线程会继续运行）。当函数引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a> 异常时，它会被静默地忽略。<em>在 3.8 版更改:</em> 现在会使用 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.unraisablehook" target="_blank" rel="noopener"><code>sys.unraisablehook()</code></a> 来处理未处理的异常。</p></li><li><p><code>_thread.interrupt_main</code>()</p><p>模拟一个 <code>signal.SIGINT</code> 信号到达主线程的效果。 线程可以使用这个函数来中断主线程。如果 Python 没有处理 <code>signal.SIGINT</code> (将它设为 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.SIG_DFL" target="_blank" rel="noopener"><code>signal.SIG_DFL</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.SIG_IGN" target="_blank" rel="noopener"><code>signal.SIG_IGN</code></a>)，此函数将不做任何事。</p></li><li><p><code>_thread.exit</code>()</p><p>抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a> 异常。如果没有捕获的话，这个异常会使线程退出。</p></li><li><p><code>_thread.allocate_lock</code>()</p><p>返回一个新的锁对象。锁中的方法在后面描述。初始情况下锁处于解锁状态。</p></li><li><p><code>_thread.get_ident</code>()</p><p>返回当前线程的 “线程描述符”。它是一个非零的整型数。它的值没有什么含义，主要是作为 magic cookie 使用，比如作为含有线程相关数据的字典的索引。线程描述符可能会在线程退出，新线程创建时复用。</p></li><li><p><code>_thread.get_native_id</code>()</p><p>返回内核分配给当前线程的原生集成线程 ID。 这是一个非负整数。 它的值可被用来在整个系统中唯一地标识这个特定线程（直到线程终结，在那之后该值可能会被 OS 回收再利用）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows, FreeBSD, Linux, macOS, OpenBSD, NetBSD, AIX。<em>3.8 新版功能.</em></p></li><li><p><code>_thread.stack_size</code>([<em>size</em>])</p><p>返回新建线程时使用的堆栈大小。可选参数 <em>size</em> 指定之后新建的线程的堆栈大小，而且一定要是0（根据平台或者默认配置）或者最小是32,768(32KiB)的一个正整数。如果<em>size</em>没有指定，默认是0。如果不支持改变线程堆栈大小，会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 错误。如果指定的堆栈大小不合法，会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 错误并且不会修改堆栈大小。32KiB是当前最小的能保证解释器足够堆栈空间的堆栈大小。需要注意的是部分平台对于堆栈大小会有特定的限制，例如要求大于32KiB的堆栈大小或者需要根据系统内存页面的整数倍进行分配 - 应当查阅平台文档有关详细信息（4KiB页面比较普遍，在没有更具体信息的情况下，建议的方法是使用4096的倍数作为堆栈大小）<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows，具有 POSIX 线程的系统。</p></li><li><p><code>_thread.TIMEOUT_MAX</code></p><p><code>Lock.acquire()</code> 方法中 <em>timeout</em> 参数允许的最大值。传入超过这个值的 timeout 会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a> 异常。<em>3.2 新版功能.</em></p></li></ul><h2 id="锁对象方法"><a href="#锁对象方法" class="headerlink" title="锁对象方法"></a>锁对象方法</h2><p>锁对象有以下方法：</p><ul><li><p><code>lock.acquire</code>(<em>waitflag=1</em>, <em>timeout=-1</em>)</p><p>没有任何可选参数时，该方法无条件申请获得锁，有必要的话会等待其他线程释放锁（同时只有一个线程能获得锁 —— 这正是锁存在的原因）。如果传入了整型参数 <em>waitflag</em>，具体的行为取决于传入的值：如果是 0 的话，只会在能够立刻获取到锁时才获取，不会等待，如果是非零的话，会像之前提到的一样，无条件获取锁。如果传入正浮点数参数 <em>timeout</em>，相当于指定了返回之前等待得最大秒数。如果传入负的 <em>timeout</em>，相当于无限期等待。如果 <em>waitflag</em> 是 0 的话，不能指定 <em>timeout</em>。如果成功获取到所会返回 <code>True</code>，否则返回 <code>False</code>。<em>在 3.2 版更改:</em> <em>timeout</em> 形参是新增的。<em>在 3.2 版更改:</em> 现在获取锁的操作可以被 POSIX 信号中断。</p></li><li><p><code>lock.release</code>()</p><p>释放锁。锁必须已经被获取过，但不一定是同一个线程获取的。</p></li><li><p><code>lock.locked</code>()</p><p>返回锁的状态：如果已被某个线程获取，返回 <code>True</code>，否则返回 <code>False</code>。</p></li></ul><p>除了这些方法之外，锁对象也可以通过 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句使用，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"></span><br><span class="line">a_lock = _thread.allocate_lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> a_lock:</span><br><span class="line">    print(<span class="string">"a_lock is locked while this executes"</span>)</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>线程与中断奇怪地交互：<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyboardInterrupt" target="_blank" rel="noopener"><code>KeyboardInterrupt</code></a> 异常可能会被任意一个线程捕获。（如果 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#module-signal" target="_blank" rel="noopener"><code>signal</code></a> 模块可用的话，中断总是会进入主线程。）</li><li>调用 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 或是抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a> 异常等效于调用 <a href="https://docs.python.org/zh-cn/3.8/library/_thread.html#_thread.exit" target="_blank" rel="noopener"><code>_thread.exit()</code></a>。</li><li>不可能中断锁的 <code>acquire()</code> 方法 —— <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyboardInterrupt" target="_blank" rel="noopener"><code>KeyboardInterrupt</code></a> 一场会在锁获取到之后发生。</li><li>当主线程退出时，由系统决定其他线程是否存活。在大多数系统中，这些线程会直接被杀掉，不会执行 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> … <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 语句，也不会执行对象析构函数。</li><li>当主线程退出时，不会进行正常的清理工作（除非使用了 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> … <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 语句），标准 I/O 文件也不会刷新。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-thread&quot;&gt;&lt;a href=&quot;#python-标准库-thread&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 _thread&quot;&gt;&lt;/a&gt;python 标准库 _thread&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200316_multiplethreading.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="_thread" scheme="https://pinghailinfeng.gitee.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library doctest</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/15/python-standard-library-doctest/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/15/python-standard-library-doctest/</id>
    <published>2020-03-15T03:50:31.000Z</published>
    <updated>2020-03-16T13:23:04.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-doctest"><a href="#python-标准库-doctest" class="headerlink" title="python  标准库 doctest"></a>python  标准库 doctest</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200316_westworld_3.jpg?raw=true" alt></p><a id="more"></a><p><code>doctest</code>模块搜索看起来像交互式Python会话的文本片段，然后执行这些会话以验证它们完全按照所示方式工作。有几种常用的方法可以使用doctest：</p><ul><li><p>通过验证所有交互式示例仍按记录工作来检查模块的文档是否是最新的。</p></li><li><p>通过验证测试文件或测试对象中的交互式示例如预期工作来执行回归测试。</p></li><li><p>为包编写教程文档，用输入输出示例大量地说明。根据实例或说明文本是否被强调，这具有“识字测试”或“可执行文档”的味道。</p></li></ul><p>这是一个完整但很小的示例模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">This is the "example" module.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The example module supplies one function, factorial().  For example,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>factorial(5)</span></span><br><span class="line"><span class="string">120</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""Return the factorial of n, an exact integer &gt;= 0.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the result is small enough to fit in an int, return an int.</span></span><br><span class="line"><span class="string">    Else return a long.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; [factorial(n) for n in range(6)]</span></span><br><span class="line"><span class="string">    [1, 1, 2, 6, 24, 120]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; [factorial(long(n)) for n in range(6)]</span></span><br><span class="line"><span class="string">    [1, 1, 2, 6, 24, 120]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30)</span></span><br><span class="line"><span class="string">    265252859812191058636308480000000L</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30L)</span></span><br><span class="line"><span class="string">    265252859812191058636308480000000L</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(-1)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    ValueError: n must be &gt;= 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Factorials of floats are OK, but the float must be an exact integer:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30.1)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    ValueError: n must be exact integer</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30.0)</span></span><br><span class="line"><span class="string">    265252859812191058636308480000000L</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    It must also not be ridiculously large:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(1e100)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    OverflowError: n too large</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"n must be &gt;= 0"</span>)</span><br><span class="line">    <span class="keyword">if</span> math.floor(n) != n:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"n must be exact integer"</span>)</span><br><span class="line">    <span class="keyword">if</span> n+<span class="number">1</span> == n:  <span class="comment"># catch a value like 1e300</span></span><br><span class="line">        <span class="keyword">raise</span> OverflowError(<span class="string">"n too large"</span>)</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    factor = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> factor &lt;= n:</span><br><span class="line">        result *= factor</span><br><span class="line">        factor += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure><p>如果您直接从命令行运行<code>example.py</code>，那么<code>doctest</code>可以发挥它的魔力：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python example.py</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>没有输出！这很正常，而且这意味着所有的例子都有效。传递<code>-v</code>给脚本，并<code>doctest</code>打印它正在尝试的详细日志，并在最后打印摘要：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ python example.py -v</span><br><span class="line">Trying:</span><br><span class="line">    factorial(<span class="number">5</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    <span class="number">120</span></span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    [factorial(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">Expecting:</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    [factorial(long(n)) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">Expecting:</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>以此类推，最终结局如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Trying:</span><br><span class="line">    factorial(<span class="number">1e100</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">        ...</span><br><span class="line">    OverflowError: n too large</span><br><span class="line">ok</span><br><span class="line"><span class="number">2</span> items passed all tests:</span><br><span class="line">   <span class="number">1</span> tests <span class="keyword">in</span> __main__</span><br><span class="line">   <span class="number">8</span> tests <span class="keyword">in</span> __main__.factorial</span><br><span class="line"><span class="number">9</span> tests <span class="keyword">in</span> <span class="number">2</span> items.</span><br><span class="line"><span class="number">9</span> passed <span class="keyword">and</span> <span class="number">0</span> failed.</span><br><span class="line">Test passed.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>这就是你需要知道的开始有效使用<code>doctest</code>！跳入。以下部分提供完整的详细信息。请注意，标准Python测试套件和库中有很多文档测试的例子。在标准测试文件中可以找到特别有用的示例<code>Lib/test/test_doctest.py</code>。</p><h2 id="1-简单用法：检查Docstrings中的示例"><a href="#1-简单用法：检查Docstrings中的示例" class="headerlink" title="1.简单用法：检查Docstrings中的示例"></a>1.简单用法：检查Docstrings中的示例</h2><p>开始使用doctest的最简单的方法（但不一定是您继续这样做的方式）是结束每个模块<code>M</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure><p>然后<code>doctest</code>在模块中检查文档字符串<code>M</code>。</p><p>将模块作为脚本运行会导致文档字符串中的示例得到执行和验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python M.py</span><br></pre></td></tr></table></figure><p>这将不会显示任何东西，除非一个例子失败，在这种情况下，失败的例子和失败的原因被打印到标准输出，并且输出的最后一行是<code>***Test Failed*** N failures.</code>，其中<em>N</em>是数字失败的例子。</p><p>改为使用开关运行<code>-v</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python M.py -v</span><br></pre></td></tr></table></figure><p>并且所有尝试过的示例的详细报告都会打印到标准输出，并在最后列出各种摘要。</p><p>您可以通过传递<code>verbose=True</code>来强制详细模式<code>testmod()</code>，或通过传递来禁止它<code>verbose=False</code>。在任何一种情况下，<code>sys.argv</code>都不会被检查<code>testmod()</code>（如此通过<code>-v</code>或没有影响）。</p><p>自Python 2.6以来，还有一个用于运行的命令行快捷方式<code>testmod()</code>。您可以指示Python解释器直接从标准库运行doctest模块，并在命令行上传递模块名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m doctest -v example.py</span><br></pre></td></tr></table></figure><p>这将<code>example.py</code>作为独立模块导入并<code>testmod()</code>在其上运行。请注意，如果文件是软件包的一部分并从该软件包导入其他子模块，则可能无法正常工作。</p><p>有关更多信息<code>testmod()</code>，请参阅基本API一节。</p><h2 id="2-简单的用法：检查文本文件中的示例"><a href="#2-简单的用法：检查文本文件中的示例" class="headerlink" title="2.简单的用法：检查文本文件中的示例"></a>2.简单的用法：检查文本文件中的示例</h2><p>doctest的另一个简单应用是在文本文件中测试交互式示例。这可以通过以下<code>testfile()</code>功能完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line">doctest.testfile(<span class="string">"example.txt"</span>)</span><br></pre></td></tr></table></figure><p>该短脚本执行并验证文件中包含的任何交互式Python示例<code>example.txt</code>。文件内容被视为一个巨大的文档字符串; 该文件不需要包含Python程序！例如，也许<code>example.txt</code>包含这个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">The ``example`` module</span><br><span class="line">======================</span><br><span class="line"></span><br><span class="line">Using ``factorial``</span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line">This <span class="keyword">is</span> an example text file <span class="keyword">in</span> reStructuredText format.  First <span class="keyword">import</span></span><br><span class="line">``factorial`` <span class="keyword">from</span> the ``example`` module:</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">from</span> example <span class="keyword">import</span> factorial</span><br><span class="line"></span><br><span class="line">Now use it:</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; factorial(<span class="number">6</span>)</span><br><span class="line">    <span class="number">120</span></span><br></pre></td></tr></table></figure><p>运行<code>doctest.testfile(&quot;example.txt&quot;)</code>然后在这个文档中找到错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File <span class="string">"./example.txt"</span>, line <span class="number">14</span>, <span class="keyword">in</span> example.txt</span><br><span class="line">Failed example:</span><br><span class="line">    factorial(<span class="number">6</span>)</span><br><span class="line">Expected:</span><br><span class="line">    <span class="number">120</span></span><br><span class="line">Got:</span><br><span class="line">    <span class="number">720</span></span><br></pre></td></tr></table></figure><p>与<code>testmod()</code>一样，<code>testfile()</code>除非例子失败，否则不会显示任何内容。如果一个例子失败了，那么失败的例子和失败的原因将被打印到标准输出中，格式为<code>testmod()</code>。</p><p>默认情况下，<code>testfile()</code>查找调用模块目录中的文件。有关可用于指示其在其他位置查找文件的可选参数的说明，请参见Basic API一节。</p><p>就像<code>testmod()</code>，<code>testfile()</code>可以通过<code>-v</code>命令行开关或可选的关键字参数<em>verbose</em>来设置详细程度。</p><p>自Python 2.6以来，还有一个用于运行的命令行快捷方式<code>testfile()</code>。您可以指示Python解释器直接从标准库运行doctest模块，并在命令行上传递文件名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m doctest -v example.txt</span><br></pre></td></tr></table></figure><p>因为文件名并不以此结束<code>.py</code>，因此<code>doctest</code>推断它必须与其一起运行<code>testfile()</code>，而不是<code>testmod()</code>。</p><p>有关更多信息<code>testfile()</code>，请参阅基本API一节。</p><h2 id="3-它是如何工作的"><a href="#3-它是如何工作的" class="headerlink" title="3.它是如何工作的"></a>3.它是如何工作的</h2><p>本节将详细介绍doctest如何工作：查看它的文档字符串，它如何查找交互式示例，它使用的执行上下文，它如何处理异常以及如何使用选项标志来控制其行为。这是编写doctest示例时需要了解的信息; 有关在这些示例上实际运行doctest的信息，请参阅以下各节。</p><h3 id="3-1-哪些Docstrings被检查？"><a href="#3-1-哪些Docstrings被检查？" class="headerlink" title="3.1. 哪些Docstrings被检查？"></a>3.1. 哪些Docstrings被检查？</h3><p>模块docstring，以及所有函数，类和方法文档字符串被搜索。导入到模块中的对象不被搜索。</p><p>另外，如果<code>M.__test__</code>存在且“为真”，则它必须是字典，并且每个条目将（字符串）名称映射到函数对象，类对象或字符串。从中找到的函数和类对象文档字符串<code>M.__test__</code>被搜索，字符串被视为文档字符串。在输出，一键<code>K</code>在<code>M.__test__</code>出现与名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;name of M&gt;.__test__.K</span><br></pre></td></tr></table></figure><p>找到的任何类都以相似的方式递归搜索，以测试其包含的方法和嵌套类中的文档字符串。</p><p>在版本2.4中进行了更改：“专用名称”概念已被弃用且不再有记录。</p><h3 id="3-2-Docstring示例如何被认可？"><a href="#3-2-Docstring示例如何被认可？" class="headerlink" title="3.2. Docstring示例如何被认可？"></a>3.2. Docstring示例如何被认可？</h3><p>在大多数情况下，交互式控制台会话的复制和粘贴工作正常，但doctest并不试图精确模拟任何特定的Python shell。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># comments are ignored</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> x == <span class="number">13</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"yes"</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"no"</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"NO"</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"NO!!!"</span></span><br><span class="line">...</span><br><span class="line">no</span><br><span class="line">NO</span><br><span class="line">NO!!!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>任何期望的输出必须紧跟在包含代码的最后一行<code>&#39;&gt;&gt;&gt; &#39;</code>或<code>&#39;... &#39;</code>一行之后，并且预期的输出（如果有的话）扩展到下一行<code>&#39;&gt;&gt;&gt; &#39;</code>或全空白行。</p><p>细则：</p><ul><li><p>预期的输出不能包含全空白行，因为这样的行被用来表示预期输出的结束。如果预期的输出包含空白行，请<code>&lt;BLANKLINE&gt;</code>在doctest示例中输入空行。新的2.4版本：<code>&lt;BLANKLINE&gt;</code>加入; 没有办法在以前的版本中使用包含空行的预期输出。</p></li><li><p>所有硬标签字符都被扩展为空格，使用8列制表位。测试代码生成的输出中的选项卡不会被修改。由于示例输出<em>中的</em>任何硬标签<em>都是</em>展开的，这意味着如果代码输出包含硬标签，则doctest可以通过的唯一方式是如果<code>NORMALIZE_WHITESPACE</code>选项或指令有效。或者，可以重写测试以捕获输出并将其作为测试的一部分与预期值进行比较。源代码中对制表符的处理是通过反复试验得出的，并且已被证明是处理它们的最不容易出错的方式。通过编写自定义<code>DocTestParser</code>类，可以使用不同的算法来处理选项卡。</p></li><li><p>输出到标准输出被捕获，但不输出到标准错误（异常追溯通过不同的方式捕获）。 </p></li><li><p>如果在交互式会话中通过反斜线继续行，或者出于任何其他原因使用反斜杠，则应该使用原始文档字符串，该字符串将按照键入时的方式保存反斜杠：</p></li></ul><blockquote><p>def f(x): …     r’’’Backslashes in a raw docstring: m\n’’’ &gt;&gt;&gt; print f.<strong>doc</strong> Backslashes in a raw docstring: m\n </p></blockquote><p>否则，反斜杠将被解释为字符串的一部分。例如，<code>\n</code>以上将被解释为一个换行符。或者，您可以在doctest版本中将每个反斜杠加倍（并且不使用原始字符串）：</p><blockquote><p>def f(x): …     ‘’’Backslashes in a raw docstring: m\n’’’ &gt;&gt;&gt; print f.<strong>doc</strong> Backslashes in a raw docstring: m\n </p></blockquote><ul><li>起始栏无关紧要：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="string">"Easy!"</span></span><br><span class="line">      &gt;&gt;&gt; <span class="keyword">import</span> math</span><br><span class="line">          &gt;&gt;&gt; math.floor(<span class="number">1.9</span>)</span><br><span class="line">          <span class="number">1</span></span><br></pre></td></tr></table></figure><p>并且从开始示例的初始行中出现的预期输出中删除了许多主要的空白字符<code>&#39;&gt;&gt;&gt;&#39;</code>。</p><h3 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h3><p>默认情况下，每次<a href="https://docs.python.org/3/library/doctest.html#module-doctest" target="_blank" rel="noopener"><code>doctest</code></a>发现一个文档字符串进行测试，它采用的是 <em>浅拷贝</em>的<code>M</code>的全局，使运行测试不会改变模块真实的全局，因此，在一个测试<code>M</code>不能离开屑不小心让另外一个背后测试工作。这意味着示例可以自由使用任何在顶层定义的<code>M</code>名称，以及在运行的文档字符串中定义的名称。示例无法看到其他文档中定义的名称。</p><p>你可以通过强制使用自己的字典作为执行上下文 <code>globs=your_dict</code>来<a href="https://docs.python.org/3/library/doctest.html#doctest.testmod" target="_blank" rel="noopener"><code>testmod()</code></a>或<a href="https://docs.python.org/3/library/doctest.html#doctest.testfile" target="_blank" rel="noopener"><code>testfile()</code></a>替代。</p><h3 id="什么是例外？"><a href="#什么是例外？" class="headerlink" title="什么是例外？"></a>什么是例外？</h3><p>没问题，只要回溯是该示例生成的唯一输出：只需粘贴回溯。<a href="https://docs.python.org/3/library/doctest.html#id2" target="_blank" rel="noopener">[1]</a>由于回溯包含可能快速变化的细节（例如，确切的文件路径和行号），所以这是doctest很难灵活接受的一种情况。</p><p>简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].remove(<span class="number">42</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: list.remove(x): x <span class="keyword">not</span> <span class="keyword">in</span> list</span><br></pre></td></tr></table></figure><p>该文档测试成功，如果<a href="https://docs.python.org/3/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>提出，详情如图所示。<code>list.remove(x):</code> <code>x</code> <code>not</code> <code>in</code> <code>list</code></p><p>预期的异常输出必须以追溯标题开头，该标题可以是以下两行中的任一行，缩写与示例的第一行相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">Traceback (innermost last):</span><br></pre></td></tr></table></figure><p>traceback头后面跟着一个可选的traceback堆栈，其内容被doctest忽略。回溯堆栈通常被忽略，或者从交互式会话逐字复制。</p><p>跟踪堆栈后面是最有趣的部分：包含异常类型和细节的行。这通常是追溯的最后一行，但如果异常具有多行详细信息，则可以跨越多行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> ValueError(<span class="string">'multi\n    line\ndetail'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: multi</span><br><span class="line">    line</span><br><span class="line">detail</span><br></pre></td></tr></table></figure><p>最后三行（以开始<a href="https://docs.python.org/3/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>）与异常的类型和细节进行比较，其余部分将被忽略。</p><p>最佳做法是省略追溯堆栈，除非它为示例增加了重要的文档值。所以最后一个例子可能更好，因为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> ValueError(<span class="string">'multi\n    line\ndetail'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    ...</span><br><span class="line">ValueError: multi</span><br><span class="line">    line</span><br><span class="line">detail</span><br></pre></td></tr></table></figure><p>请注意，回溯处理非常特别。特别是，在改写的例子中，使用<code>...</code>独立于doctest的 <a href="https://docs.python.org/3/library/doctest.html#doctest.ELLIPSIS" target="_blank" rel="noopener"><code>ELLIPSIS</code></a>选项。这个例子中的省略号可以省略，或者可以是三个（或三百个）逗号或数字，或者Monty Python skit的缩进记录。</p><p>一些细节你应该阅读一次，但不需要记住：</p><ul><li><p>Doctest无法猜测您的预期输出是来自异常追溯还是来自普通打印。因此，例如，预计<code>ValueError: 42 is prime</code>会传递一个示例，无论是否<code>ValueError</code>实际提出，或者该示例仅打印该追溯文本。实际上，普通输出很少以追溯标题行开始，所以这不会产生实际问题。</p></li><li><p>回溯堆栈的每一行（如果存在）必须比示例的第一行缩进得更远，<em>或者</em>以非字母数字字符开始。追溯标题后面的第一行缩写相同，并以字母数字开头，作为异常详细信息的开始。当然这对于真正的回溯来说是正确的。</p></li><li><p>当<code>IGNORE_EXCEPTION_DETAIL</code>指定doctest选项时，将忽略最左侧冒号后面的所有内容以及异常名称中的所有模块信息。</p></li><li><p>交互式shell省略了一些<code>SyntaxError</code>s 的追溯标题行。但doctest使用traceback标题行来区分异常和非异常。因此，在极少数情况下，如果您需要测试一个<code>SyntaxError</code>省略traceback头的测试，则需要手动将traceback头行添加到测试示例中。</p></li><li><p>对于某些<code>SyntaxError</code>s，Python使用<code>^</code>标记来显示语法错误的字符位置：</p></li></ul><blockquote><p>1 1   File “<stdin>“, line 1     1 1       ^ SyntaxError: invalid syntax </stdin></p></blockquote><p>由于显示错误位置的行出现在异常类型和细节之前，因此它们不会被doctest检查。例如，即使将<code>^</code>标记放在错误的位置，也会通过以下测试：</p><blockquote><p>1 1   File “<stdin>“, line 1     1 1     ^ SyntaxError: invalid syntax </stdin></p></blockquote><h3 id="3-5-Option-Flags"><a href="#3-5-Option-Flags" class="headerlink" title="3.5. Option Flags"></a>3.5. Option Flags</h3><p>许多选项标志控制着doctest行为的各个方面。这些标志的符号名称作为模块常量提供，可以<a href="https://docs.python.org/2.7/reference/expressions.html#bitwise" target="_blank" rel="noopener">按位或运算</a>并传递给各种函数。这些名称也可以在doctest指令中使用。</p><p>第一组选项定义测试语义，控制doctest如何确定实际输出是否与示例预期输出相匹配的方面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.DONT_ACCEPT_TRUE_FOR_1</span><br></pre></td></tr></table></figure><p>默认情况下，如果预期的输出块只包含<code>1</code>，只是含有实际输出块<code>1</code>或仅<code>True</code>被认为是一个匹配，并类似地用于<code>0</code>对<code>False</code>。当<code>DONT_ACCEPT_TRUE_FOR_1</code>指定时，不允许替换。缺省行为迎合了Python将许多函数的返回类型从整数更改为布尔值; 希望“小整数”输出的doctests在这些情况下仍然有效。这个选项可能会消失，但不会持续数年。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.DONT_ACCEPT_BLANKLINE</span><br></pre></td></tr></table></figure><p>默认情况下，如果预期的输出块包含仅包含字符串的行<code>&lt;BLANKLINE&gt;</code>，则该行将匹配实际输出中的空行。由于真正的空行界定了预期的输出，因此这是沟通预期空行的唯一方式。什么时候<code>DONT_ACCEPT_BLANKLINE</code>被指定，这个替代是不允许的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.NORMALIZE_WHITESPACE</span><br></pre></td></tr></table></figure><p>指定时，所有空白（空格和换行符）都被视为相等。预期输出中的任何空白序列都将与实际输出中的任何空白序列相匹配。默认情况下，空白必须完全匹配。<code>NORMALIZE_WHITESPACE</code>当预期输出的行很长时，并且您想要在源代码中的多行中包装它时，它特别有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.ELLIPSIS</span><br></pre></td></tr></table></figure><p>指定时，<code>...</code>预期输出中的省略号标记（）可以匹配实际输出中的任何子字符串。这包括跨越行边界的子字符串和空的子字符串，所以最好保持简单的使用。复杂的用途可能会导致相同类型的“oops，它匹配得太多了！” <code>.*</code>在正则表达式中很容易出现意外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.IGNORE_EXCEPTION_DETAIL</span><br></pre></td></tr></table></figure><p>指定时，即使异常详细信息不匹配，如果引发了期望类型的异常，那么期望异常的示例也会通过。例如，<code>ValueError: 42</code>如果引发的实际异常是预期的例子<code>ValueError: 3*14</code>，但会失败，例如，如果<code>TypeError</code>引发。</p><p>它也会忽略Python 3 doctest报告中使用的模块名称。因此，无论测试是在Python 2.7还是Python 3.2（或更高版本）下运行，这两种变体都可以与指定的标志一起使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raise CustomError(<span class="string">'message'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">CustomError: message</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; raise CustomError(<span class="string">'message'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">my_module.CustomError: message</span><br></pre></td></tr></table></figure><p>请注意，<code>ELLIPSIS</code>也可以用于忽略异常消息的详细信息，但根据是否将模块详细信息作为异常名称的一部分进行打印，此类测试可能仍会失败。使用<code>IGNORE_EXCEPTION_DETAIL</code>和来自Python 2.3的细节也是编写文档测试的唯一明确方式，它不关心异常细节，但仍然在Python 2.3或更低版本中继续传递（这些版本不支持doctest指令并将它们忽略为不相关的注释） 。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (<span class="number">1</span>, <span class="number">2</span>)[<span class="number">3</span>] = <span class="string">'moo'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line"><span class="built_in">TypeError</span>: object doesn<span class="string">'t support item assignment</span></span><br></pre></td></tr></table></figure><p>虽然Python 2.4中的细节更改为“不”而不是“不”，但在Python 2.3以及更高版本的Python版本中通过了指定的标志。</p><p>在 3.2 版更改:：<code>IGNORE_EXCEPTION_DETAIL</code>现在也忽略了与包含被测异常的模块有关的任何信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.SKIP</span><br></pre></td></tr></table></figure><p>指定时，请不要运行该示例。这在doctest示例既可用作文档也可用作测试用例的情况下非常有用，应将其用于文档目的，但不应进行检查。例如，该示例的输出可能是随机的; 或者该示例可能依赖于测试驱动程序无法使用的资源。</p><p>SKIP标志也可用于临时“注释”示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.COMPARISON_FLAGS</span><br></pre></td></tr></table></figure><p>将上面的所有比较标志掩盖起来。</p><p>第二组选项控制如何报告测试失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.REPORT_UDIFF</span><br></pre></td></tr></table></figure><p>指定时，涉及多行预期和实际输出的故障将使用统一差异显示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.REPORT_CDIFF</span><br></pre></td></tr></table></figure><p>指定时，涉及多行预期输出和实际输出的故障将使用上下文差异显示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.REPORT_NDIFF</span><br></pre></td></tr></table></figure><p>指定时，<code>difflib.Differ</code>使用与常用<code>ndiff.py</code>实用程序相同的算法计算差异。这是标记线内和线间差异的唯一方法。例如，如果预期输出的一行包含数字<code>1</code>，其中实际输出包含字母<code>l</code>，则会插入一行，并在其中插入用于标记不匹配列位置的插入符号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.REPORT_ONLY_FIRST_FAILURE</span><br></pre></td></tr></table></figure><p>指定时，显示每个doctest中的第一个失败示例，但禁止所有其他示例的输出。这将防止doctest报告因早期故障而中断的正确示例; 但它也可能隐藏不正确的例子，不依靠第一次失败而失败。当<code>REPORT_ONLY_FIRST_FAILURE</code>指定时，剩余的示例仍在运行，并仍然计入报告的故障总数; 只有输出被抑制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.FAIL_FAST</span><br></pre></td></tr></table></figure><p>指定时，在第一个失败示例后退出，不要尝试运行其余示例。因此，报告的故障数最多为 1。此标志在调试期间可能很有用，因为第一次失败后的示例不会生成调试输出。</p><p>3.4版新功能</p><p>还有一种方法可以注册新的选项标志名称，但除非您打算<code>doctest</code>通过子类扩展内部函数，否则这种方法并不有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.register_optionflag(name)</span><br></pre></td></tr></table></figure><p>用给定名称创建一个新选项标志，并返回新标志的整数值。<code>register_optionflag()</code>可用于子类化<code>OutputChecker</code>或<code>DocTestRunner</code>创建您的子类支持的新选项。<code>register_optionflag()</code>应该总是使用以下习惯用法来调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MY_FLAG = register_optionflag(<span class="string">'MY_FLAG'</span>)</span><br></pre></td></tr></table></figure><p>New in version 2.4.</p><h3 id="3-6-Directives"><a href="#3-6-Directives" class="headerlink" title="3.6. Directives"></a>3.6. Directives</h3><p>Doctest指令可用于修改单个示例的选项标志。Doctest指令是遵循示例源代码的特殊Python注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">directive             ::=  <span class="string">"#"</span> <span class="string">"doctest:"</span> directive_options</span><br><span class="line">directive_options     ::=  directive_option (<span class="string">","</span> directive_option)\*</span><br><span class="line">directive_option      ::=  on_or_off directive_option_name</span><br><span class="line">on_or_off             ::=  <span class="string">"+"</span> \| <span class="string">"-"</span></span><br><span class="line">directive_option_name ::=  <span class="string">"DONT_ACCEPT_BLANKLINE"</span> \| <span class="string">"NORMALIZE_WHITESPACE"</span> \| ...</span><br></pre></td></tr></table></figure><p><code>+</code>or <code>-</code>和指令选项名称之间不允许有空格。指令选项名称可以是上面解释的任何选项标志名称。</p><p>一个例子的doctest指令修改了doctest的这个例子的行为。使用<code>+</code>启用这个名字的行为，或<code>-</code>将其禁用。</p><p>例如，这个测试通过：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> range(<span class="number">20</span>) <span class="comment"># doctest: +NORMALIZE_WHITESPACE</span></span><br><span class="line">[<span class="number">0</span>,   <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,</span><br><span class="line"><span class="number">10</span>,  <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>如果没有指令，它会失败，这是因为实际输出在单个数字列表元素之前没有两个空格，并且因为实际输出在单行上。这个测试也通过了，并且还需要一个指令来做到这一点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> range(<span class="number">20</span>) <span class="comment"># doctest: +ELLIPSIS</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, ..., <span class="number">18</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>多条指令可用于单条物理线路，用逗号分隔：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> range(<span class="number">20</span>) <span class="comment"># doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span></span><br><span class="line">[<span class="number">0</span>,    <span class="number">1</span>, ...,   <span class="number">18</span>,    <span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>如果单个示例使用多个指令注释，则将它们合并：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print range(20) # doctest: +ELLIPSIS</span><br><span class="line">...                 # doctest: +NORMALIZE_WHITESPACE</span><br><span class="line">[<span class="number">0</span>,    <span class="number">1</span>, ...,   <span class="number">18</span>,    <span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>如前例所示，您可以将<code>...</code>行添加到仅包含指令的示例中。当一个例子对于指令很容易适合同一行时太长了，这会很有用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print range(<span class="number">5</span>) + range(<span class="number">10</span>,<span class="number">20</span>) + range(<span class="number">30</span>,<span class="number">40</span>) + range(<span class="number">50</span>,<span class="number">60</span>)</span><br><span class="line">... # doctest: +ELLIPSIS</span><br><span class="line">[<span class="number">0</span>, ..., <span class="number">4</span>, <span class="number">10</span>, ..., <span class="number">19</span>, <span class="number">30</span>, ..., <span class="number">39</span>, <span class="number">50</span>, ..., <span class="number">59</span>]</span><br></pre></td></tr></table></figure><p>请注意，由于默认情况下所有选项都被禁用，并且指令仅适用于它们出现的示例，因此启用选项（通过<code>+</code>指令）通常是唯一有意义的选择。但是，选项标志也可以传递给运行doctests的函数，建立不同的默认值。在这种情况下，通过<code>-</code>指令禁用选项可能很有用。</p><p>2.4版新增功能：增加了对doctest指令的支持。</p><h3 id="3-7-警告"><a href="#3-7-警告" class="headerlink" title="3.7. 警告"></a>3.7. 警告</h3><p><code>doctest</code>严格要求在预期产出中要求完全匹配。如果即使单个字符不匹配，测试也会失败。这可能会让你感到惊讶，因为你确切地知道Python做了什么，并且不能保证输出。例如，在打印字典时，Python不保证键值对将以任何特定的顺序打印，因此像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line">&#123;<span class="string">"Hermione"</span>: <span class="string">"hippogryph"</span>, <span class="string">"Harry"</span>: <span class="string">"broomstick"</span>&#125;</span><br></pre></td></tr></table></figure><p>很脆弱！一种解决方法是做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo() == &#123;<span class="string">"Hermione"</span>: <span class="string">"hippogryph"</span>, <span class="string">"Harry"</span>: <span class="string">"broomstick"</span>&#125;</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>代替。另一个是要做的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = foo().items()</span><br><span class="line">&gt;&gt;&gt; d.sort()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">[(<span class="string">'Harry'</span>, <span class="string">'broomstick'</span>), (<span class="string">'Hermione'</span>, <span class="string">'hippogryph'</span>)]</span><br></pre></td></tr></table></figure><p>还有其他的，但你明白了。</p><p>另一个不好的想法是打印嵌入对象地址的东西，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="number">1.0</span>) <span class="comment"># certain to fail some of the time</span></span><br><span class="line"><span class="number">7948648</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C()   <span class="comment"># the default repr() for instances embeds an address</span></span><br><span class="line">&lt;__main__.C instance at <span class="number">0x00AC18F0</span>&gt;</span><br></pre></td></tr></table></figure><p><code>ELLIPSIS</code>指令为最后一个示例提供了一个很好的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C() <span class="comment">#doctest: +ELLIPSIS</span></span><br><span class="line">&lt;__main__.C instance at <span class="number">0</span>x...&gt;</span><br></pre></td></tr></table></figure><p>浮点数也受到跨平台的小输出变化的影响，因为Python遵循平台C库进行浮点格式化，而C库在质量上差别很大。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1./7  # risky</span><br><span class="line"><span class="number">0.14285714285714285</span></span><br><span class="line">&gt;&gt;&gt; print 1./7 # safer</span><br><span class="line"><span class="number">0.142857142857</span></span><br><span class="line">&gt;&gt;&gt; print round(1./7, 6) # much safer</span><br><span class="line"><span class="number">0.142857</span></span><br></pre></td></tr></table></figure><p>表格<code>I/2.**J</code>中的数字在所有平台上都是安全的，而且我通常会编写一些doctest的例子来生成这种格式的数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3.</span>/<span class="number">4</span>  <span class="comment"># utterly safe</span></span><br><span class="line"><span class="number">0.75</span></span><br></pre></td></tr></table></figure><p>简单的分数对于人们来说也更容易理解，并且这使得更好的文档。</p><h2 id="4-基本API"><a href="#4-基本API" class="headerlink" title="4.基本API"></a>4.基本API</h2><p>函数<code>testmod()</code>和<code>testfile()</code>提供了一个简单的界面，文档测试，应该是足够了最基本的用途。有关这两个函数的不太正式的介绍，请参见简单用法：检查文档字符串和简单用法中的示例：检查文本文件中的示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.testfile(filename[, module_relative][, name][, package][, globs][, verbose][, report][, optionflags][, extraglobs][, raise_on_error][, parser][, encoding])</span><br></pre></td></tr></table></figure><p>除<em>文件名</em>以外的所有参数都是可选的，并应以关键字形式指定。</p><p>在名为<em>filename</em>的文件中测试示例。返回<code>(failure_count, test_count)</code>。</p><p>可选参数<em>module_relative</em>指定应如何解释文件名：</p><ul><li><p>如果<em>module_relative</em>是<code>True</code>（缺省值），则<em>filename</em>指定一个与操作系统无关的模块相对路径。默认情况下，这个路径是相对于调用模块的目录；但是如果指定了<em>package</em>参数，那么它与该包相关。为了确保OS独立性，<em>文件名</em>应该使用<code>/</code>字符来分隔路径段，并且可能不是绝对路径（即它可能不以开头<code>/</code>）。</p></li><li><p>如果<em>module_relative</em>是<code>False</code>，则<em>filename</em>指定一个OS特定的路径。路径可以是绝对的或相对的; 相对路径相对于当前工作目录被解析。</p></li></ul><p>可选参数<em>名称</em>给出测试的名称; 默认情况下，或者<code>None</code>，<code>os.path.basename(filename)</code>被使用。</p><p>可选参数<em>包</em>是一个Python包或一个Python包的名称，其目录应该用作模块相关文件名的基本目录。如果未指定包，则调用模块的目录将用作模块相关文件名的基本目录。如果<em>module_relative</em>是指定<em>包，</em>那是错误的。<code>False</code></p><p>可选参数<em>globs</em>在执行示例时给出了一个用作全局变量的字典。这个词典的一个新的浅拷贝是为doctest创建的，所以它的例子从一个干净的石板开始。默认情况下，或者如果<code>None</code>使用新的空字典。</p><p>可选参数<em>extraglobs</em>给出了一个合并到用于执行示例的全局变量中的字典。这适用于<code>dict.update()</code>：如果<em>globs</em>和<em>extraglobs</em>具有共同的键，则<em>extraglobs</em>中的关联值出现在组合字典中。默认情况下，或者如果<code>None</code>，不使用额外的全局变量。这是一个允许doctests参数化的高级功能。例如，可以为基类编写一个doctest，使用该类的通用名称，然后通过传递将泛型名称映射到要测试的子类的<em>extraglobs</em>字典来测试任意数量的子类。</p><p>可选参数<em>详细信息</em>如果为true，则会打印大量内容，如果为false，则仅打印失败; 默认情况下，或者如果<code>None</code>，当且仅当<code>&#39;-v&#39;</code>在时才是<code>sys.argv</code>。</p><p>可选的参数<em>报告</em>在最后打印摘要时为真，否则在最后不打印任何内容。在详细模式下，摘要是详细的，否则摘要非常简短（实际上，如果所有测试都通过，则为空）。</p><p>可选参数<em>optionflags</em>或一起选项标志。请参见选项标志部分。</p><p>可选参数<em>raise_on_error</em>默认为false。如果为true，则在例子中发生第一次失败或意外异常时引发异常。这样可以对故障进行事后调试。默认行为是继续运行示例。</p><p>可选参数<em>解析器</em>指定<code>DocTestParser</code>应该用于从文件中提取测试的一个（或子类）。它默认为一个普通的解析器（即，<code>DocTestParser()</code>）。</p><p>可选的参数<em>编码</em>指定应该用于将文件转换为unicode的编码。</p><p>2.4版本中的新功能。</p><p>在版本2.5中更改：添加了参数<em>编码</em>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.testmod([m][, name][, globs][, verbose][, report][, optionflags][, extraglobs][, raise_on_error][, exclude_empty])</span><br></pre></td></tr></table></figure><p>所有参数都是可选的，除<em>m</em>外的所有参数都应以关键字形式指定。</p><p>在从<em>m开始</em>可以访问的函数和类中的docstrings中的测试示例（或者<code>__main__</code>如果<em>m</em>没有提供或者是<code>None</code>，则为module ），以<code>m.__doc__</code>。开头。</p><p>还有可以从字典中获得的测试例子<code>m.__test__</code>，如果它存在与否<code>None</code>。<code>m.__test__</code>将名称（字符串）映射到函数，类和字符串; 函数和类docstrings搜索的例子; 字符串被直接搜索，就好像它们是docstrings一样。</p><p>仅搜索附加到属于模块<em>m的</em>对象的文档字符串。</p><p>返回<code>(failure_count, test_count)</code>。</p><p>可选参数<em>名称</em>给出模块的名称; 默认情况下，或者<code>None</code>，<code>m.__name__</code>被使用。</p><p>可选参数<em>exclude_empty</em>默认为false。如果属实，则没有找到doctests的对象将被排除在考虑之外。默认值是向后兼容的黑客，使代码仍然使用<code>doctest.master.summarize()</code>连同<code>testmod()</code>继续得到输出，没有测试对象。新构造函数的<em>exclude_empty</em>参数<code>DocTestFinder</code>默认为true。</p><p>可选参数<em>extraglobs</em>，<em>verbose</em>，<em>report</em>，<em>optionflags</em>，<em>raise_on_error</em>和<em>globs</em>与<code>testfile()</code>上述函数相同，只是<em>globs</em>默认为<code>m.__dict__</code>。</p><p>在版本2.3中更改：添加了参数<em>optionflags</em>。</p><p>在版本2.4中更改：添加了参数<em>extraglobs</em>，<em>raise_on_error</em>和<em>exclude_empty</em>。</p><p>在版本2.5中更改：可选参数<em>isprivate</em>，在2.4中弃用，已被删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.run_docstring_examples(f, globs[, verbose][, name][, compileflags][, optionflags])</span><br></pre></td></tr></table></figure><p>与对象<em>f</em>相关的测试例子; 例如，<em>f</em>可以是字符串，模块，函数或类对象。</p><p>字典参数<em>glob的</em>浅拷贝用于执行上下文。</p><p>失败消息中使用可选参数<em>名称</em>，缺省值为<code>&quot;NoName&quot;</code>。</p><p>如果可选参数<em>verbose</em>为true，则即使没有失败，也会生成输出。默认情况下，仅在发生示例故障时才会生成输出。</p><p>可选参数<em>compileflags</em>给出了运行示例时应由Python编译器使用的一组标志。默认情况下，或者如果<code>None</code>，推导的标志对应于在<em>globs中</em>找到的一组未来特征。</p><p>可选参数<em>optionflags</em>与<code>testfile()</code>上面的函数一样。</p><h2 id="5-Unittest-API"><a href="#5-Unittest-API" class="headerlink" title="5. Unittest API"></a>5. Unittest API</h2><p>随着您的文档测试模块集合的增长，您需要一种系统地运行所有文档测试的方法。在Python 2.4之前，<code>doctest</code>有一个几乎没有文档记录的<code>Tester</code>类，它提供了一个基本方法来组合多个模块的doctests。<code>Tester</code>是虚弱的，实际上最严重的Python测试框架建立在<code>unittest</code>模块上，它提供了许多灵活的方法来结合多个来源的测试。所以，在Python 2.4，<code>doctest</code>的<code>Tester</code>类已被弃用，<code>doctest</code>提供了可用于创建两个函数<code>unittest</code>从模块和包含文档测试的文本文件的测试套件。要与<code>unittest</code>测试发现集成，<code>load_tests()</code>在您的测试模块中包含一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line"><span class="keyword">import</span> my_module_with_doctests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_tests</span><span class="params">(loader, tests, ignore)</span>:</span></span><br><span class="line">    tests.addTests(doctest.DocTestSuite(my_module_with_doctests))</span><br><span class="line">    <span class="keyword">return</span> tests</span><br></pre></td></tr></table></figure><p>有两个主要的功能可以用<code>unittest.TestSuite</code>文本文件和模块创建实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.DocFileSuite(*paths, [module_relative][, package][, setUp][, tearDown][, globs][, optionflags][, parser][, encoding])</span><br></pre></td></tr></table></figure><p>将doctest测试从一个或多个文本文件转换为<code>unittest.TestSuite</code>。</p><p>返回的<code>unittest.TestSuite</code>内容将由unittest框架运行并在每个文件中运行交互式示例。如果任何文件中的示例失败，则合成的单元测试将失败，并<code>failureException</code>引发异常，显示包含测试的文件的名称和一个（有时是近似的）行号。</p><p>将一个或多个路径（字符串）传递给要检查的文本文件。</p><p>选项可以作为关键字参数提供：</p><p>可选参数<em>module_relative</em>指定应如何解释<em>路径中</em>的文件名：</p><ul><li><p>如果<em>module_relative</em>是<code>True</code>（缺省值），则<em>路径</em>中的每个文件名指定与操作系统无关的模块相对路径。默认情况下，这个路径是相对于调用模块的目录; 但是如果指定了<em>package</em>参数，那么它与该包相关。为确保操作系统无关性，每个文件名应使用<code>/</code>字符来分隔路径段，并且可能不是绝对路径（即可能不以其开头<code>/</code>）。</p></li><li><p>如果<em>module_relative</em>是<code>False</code>，则<em>路径</em>中的每个文件名都指定一个OS特定的路径。路径可以是绝对的或相对的; 相对路径相对于当前工作目录被解析。</p></li></ul><p>可选参数<em>包</em>是Python包或Python包的名称，其目录应该用作<em>路径中</em>与模块相关的文件名的基本目录。如果未指定包，则调用模块的目录将用作模块相关文件名的基本目录。如果<em>module_relative</em>是指定<em>包，</em>那是<code>False</code>错误的。</p><p>可选参数<em>setUp</em>指定测试套件的设置函数。这在每个文件中运行测试之前被调用。该<em>的setUp</em>函数将被传递一个<code>DocTest</code>对象。setUp函数可以在测试的<em>globs</em>属性通过时访问测试全局变量。</p><p>可选参数<em>tearDown</em>指定测试套件的拆卸函数。这是在每个文件中运行测试后调用的。在<em>拆卸</em>会被传递给一个<code>DocTest</code>对象。setUp函数可以在测试的<em>globs</em>属性通过时访问测试全局变量。</p><p>可选参数<em>globs</em>是包含测试的初始全局变量的字典。每个测试都会创建一本新字典。默认情况下，<em>globs</em>是一个新的空字典。</p><p>可选参数<em>optionflags</em>指定测试的默认doctest选项，由各个选项标记组合或创建。请参见选项标志部分。请参阅<code>set_unittest_reportflags()</code>下面的功能以更好地设置报告选项。</p><p>可选参数<em>解析器</em>指定<code>DocTestParser</code>应该用于从文件中提取测试的一个（或子类）。它默认为一个普通的解析器（即，<code>DocTestParser()</code>）。</p><p>可选的参数<em>编码</em>指定应该用于将文件转换为unicode的编码。</p><p>2.4版本中的新功能。</p><p>在版本2.5中进行了更改：将全局<code>__file__</code>添加到提供给使用文本文件加载的文档测试的全局文件中<code>DocFileSuite()</code>。</p><p>在版本2.5中更改：添加了参数<em>编码</em>。</p><p>注意</p><p>不像<code>testmod()</code>和<code>DocTestFinder</code>，<code>ValueError</code>如果<em>模块不</em>包含文档字符串，该函数会引发一个问题。您可以通过传递一个<code>DocTestFinder</code>实例作为<em>test_finder</em>参数，并将其<em>exclude_empty</em>关键字参数设置为<code>False</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>finder = doctest.DocTestFinder(exclude_empty=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suite = doctest.DocTestSuite(test_finder=finder)</span><br><span class="line">doctest.DocTestSuite([module][, globs][, extraglobs][, test_finder][, setUp][, tearDown][, checker])</span><br></pre></td></tr></table></figure><p>将模块的doctest测试转换为一个模块<code>unittest.TestSuite</code>。</p><p>返回的<code>unittest.TestSuite</code>是由unittest框架运行并在模块中运行每个doctest。如果有任何文档测试失败，则合成的单元测试失败，并<code>failureException</code>引发异常，显示包含测试的文件的名称和一个（有时是近似的）行号。</p><p>可选参数<em>模块</em>提供要测试的模块。它可以是一个模块对象或一个（可能点缀的）模块名称。如果未指定，则使用调用此函数的模块。</p><p>可选参数<em>globs</em>是包含测试的初始全局变量的字典。每个测试都会创建一本新字典。默认情况下，<em>globs</em>是一个新的空字典。</p><p>可选参数<em>extraglobs</em>指定一组额外的全局变量，这是合并成的<em>水珠</em>。默认情况下，不使用额外的全局变量。</p><p>可选参数<em>test_finder</em>是<code>DocTestFinder</code>用于从模块中提取doctests 的对象（或插入替换）。</p><p>可选参数<em>setUp</em>，<em>tearDown</em>和<em>optionflags</em>与<code>DocFileSuite()</code>上面的函数相同。</p><p>2.3版本的新功能。</p><p>在版本2.4中更改：添加了参数<em>globs</em>，<em>extraglobs</em>，<em>test_finder</em>，<em>setUp</em>，<em>tearDown</em>和<em>optionflags</em> ; 这个功能现在使用和。一样的搜索技术<code>testmod()</code>。</p><p>在幕后，<code>DocTestSuite()</code>创建<code>unittest.TestSuite</code>出的<code>doctest.DocTestCase</code>实例，<code>DocTestCase</code>是的子类<code>unittest.TestCase</code>。<code>DocTestCase</code>这里没有记录（这是一个内部细节），但是研究它的代码可以回答关于<code>unittest</code>集成确切细节的问题。</p><p>同样，<code>DocFileSuite()</code>创建<code>unittest.TestSuite</code>出的<code>doctest.DocFileCase</code>实例，<code>DocFileCase</code>是的子类<code>DocTestCase</code>。</p><p>因此创建<code>unittest.TestSuite</code>运行实例的两种方式<code>DocTestCase</code>。这对于一个微妙的原因很重要：当你<code>doctest</code>自己运行函数时，可以<code>doctest</code>通过将选项标志传递给<code>doctest</code>函数来直接控制正在使用的选项。但是，如果你正在编写一个<code>unittest</code>框架，<code>unittest</code>最终控制何时以及如何运行测试。框架作者通常希望控制<code>doctest</code>报表选项（可能例如由命令行选项指定），但是没有办法将选项传递<code>unittest</code>给<code>doctest</code>测试运行者。</p><p>出于这个原因，<code>doctest</code>还支持通过此功能支持<code>doctest</code>特定于<code>unittest</code>支持的报告标志的概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.set_unittest_reportflags(flags)</span><br></pre></td></tr></table></figure><p>设置<code>doctest</code>要使用的报告标志。</p><p>参数<em>标志</em>或一起选项标志。请参见选项标志部分。只能使用“报告标志”。</p><p>这是一个模块全局设置，并影响模块运行的所有将来的doctests <code>unittest</code>：在<code>DocTestCase</code>实例构建时查看为测试用例指定的选项标记<code>DocTestCase</code>的<code>runTest()</code>方法。如果没有指定报告的标志（这是典型的和预期的情况下），<code>doctest</code>的<code>unittest</code>报告标志是<a href="https://docs.python.org/2.7/reference/expressions.html#bitwise" target="_blank" rel="noopener">按位或运算</a>进入选项标志，因此增强选项标志传递给创建运行文档测试<code>DocTestRunner</code>实例。如果时指定的任何报告的标志例如构建<code>DocTestCase</code>，<code>doctest</code>的<code>unittest</code>报告标志被忽略。</p><p>在函数被调用之前生效的报告标志的值由函数返回<code>unittest</code>。</p><p>New in version 2.4.</p><h2 id="6-Advanced-API"><a href="#6-Advanced-API" class="headerlink" title="6. Advanced API"></a>6. Advanced API</h2><p>基本的API是一个简单的包装，旨在使doctest易于使用。它相当灵活，应该满足大多数用户的需求; 但是，如果您需要对测试进行更精细的控制，或者希望扩展doctest的功能，那么您应该使用高级API。</p><p>高级API围绕两个容器类进行，这两个容器类用于存储从doctest案例中提取的交互式示例：</p><ul><li><p><code>Example</code>：一个Python <a href="https://docs.python.org/2.7/glossary.html#term-statement" target="_blank" rel="noopener">语句</a>，与它的预期输出配对。</p></li><li><p><code>DocTest</code>：<code>Example</code>s 的集合，通常从单个文档字符串或文本文件中提取。</p></li></ul><p>定义其他处理类来查找，分析和运行，并检查doctest示例：</p><ul><li><p><code>DocTestFinder</code>：查找给定模块中的所有文档字符串，并使用<code>DocTestParser</code>a <code>DocTest</code>从包含交互式示例的每个文档字符串中创建一个。</p></li><li><p><code>DocTestParser</code>：<code>DocTest</code>从字符串中创建一个对象（例如对象的文档字符串）。</p></li><li><p><code>DocTestRunner</code>：执行<code>DocTest</code>中的例子，并使用一个<code>OutputChecker</code>来验证它们的输出。</p></li><li><p><code>OutputChecker</code>：将doctest示例中的实际输出与预期输出进行比较，并确定它们是否匹配。</p></li></ul><p>下图总结了这些处理类之间的关系：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                            list <span class="keyword">of</span>:</span><br><span class="line">+------+                   +---------+</span><br><span class="line">|<span class="built_in">module</span>| --DocTestFinder-&gt; | DocTest | --DocTestRunner-&gt; results</span><br><span class="line">+------+    |        ^     +---------+     |       ^    (printed)</span><br><span class="line">            |        |     | Example |     |       |</span><br><span class="line">            v        |     |   ...   |     v       |</span><br><span class="line">           DocTestParser   | Example |   OutputChecker</span><br><span class="line">                           +---------+</span><br></pre></td></tr></table></figure><h3 id="6-1-DocTest-Objects"><a href="#6-1-DocTest-Objects" class="headerlink" title="6.1. DocTest Objects"></a>6.1. DocTest Objects</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class doctest.DocTest(examples, globs, name, filename, lineno, docstring)</span><br></pre></td></tr></table></figure><p>应该在单个命名空间中运行的doctest示例的集合。构造函数参数用于初始化相同名称的属性。</p><p>2.4版本中的新功能。</p><p><code>DocTest</code>定义了以下属性。它们由构造函数初始化，不应该直接修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">examples</span><br></pre></td></tr></table></figure><p><code>Example</code>编码应该由此测试运行的各个交互式Python示例的对象列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">globs</span><br></pre></td></tr></table></figure><p>应该运行示例的名称空间（又称全局变量）。这是一个将名称映射到值的字典。<code>globs</code>在测试运行之后，示例所做的任何对名称空间的更改（例如绑定新变量）都会反映出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name</span><br></pre></td></tr></table></figure><p>一个字符串名称标识<code>DocTest</code>。通常，这是测试从中提取的对象或文件的名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename</span><br></pre></td></tr></table></figure><p>这<code>DocTest</code>是从中提取的文件的名称; 或者<code>None</code>如果文件名是未知的，或者如果<code>DocTest</code>没有从文件中提取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lineno</span><br></pre></td></tr></table></figure><p>行号在<code>filename</code>哪里<code>DocTest</code>开始，或<code>None</code>行号是否不可用。该行号相对于文件的开头是从零开始的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docstring</span><br></pre></td></tr></table></figure><p>从中提取测试<code>None</code>的字符串，或者字符串不可用，或者测试未从字符串中提取。</p><h3 id="6-2-示例对象"><a href="#6-2-示例对象" class="headerlink" title="6.2. 示例对象"></a>6.2. 示例对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class doctest.Example(source, want[, exc_msg][, lineno][, indent][, options])</span><br></pre></td></tr></table></figure><p>一个交互式示例，由Python语句及其预期输出组成。构造函数参数用于初始化相同名称的属性。</p><p>2.4版本中的新功能。</p><p><code>Example</code>定义了以下属性。它们由构造函数初始化，不应该直接修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source</span><br></pre></td></tr></table></figure><p>包含示例源代码的字符串。这个源代码由一个Python语句组成，并且总是以换行符结尾; 构造函数在必要时添加一个换行符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">want</span><br></pre></td></tr></table></figure><p>运行示例源代码的预期输出（来自标准输出，或者异常情况下的回溯）。<code>want</code>除非没有输出，否则以换行符结束，在这种情况下，它是一个空字符串。构造函数在必要时添加一个换行符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exc_msg</span><br></pre></td></tr></table></figure><p>该示例生成的异常消息，如果该示例预计会生成异常; 或者<code>None</code>如果不希望产生异常。该异常消息与返回值进行比较<code>traceback.format_exception_only()</code>。<code>exc_msg</code>除非是换行符，否则以换行符结尾<code>None</code>。如果需要，构造函数会添加一个换行符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lineno</span><br></pre></td></tr></table></figure><p>包含示例开始处的示例的字符串中的行号。该行号相对于包含字符串的开头是从零开始的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indent</span><br></pre></td></tr></table></figure><p>包含字符串中的示例缩进，即示例第一个提示之前的空格字符数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options</span><br></pre></td></tr></table></figure><p>从选项标记到<code>True</code>or的字典映射<code>False</code>，用于覆盖此示例的默认选项。任何未包含在此字典中的选项标志都保留默认值（由<code>DocTestRunner</code>s 指定<code>optionflags</code>）。默认情况下，不设置任何选项。</p><h3 id="6-3-DocTestFinder对象"><a href="#6-3-DocTestFinder对象" class="headerlink" title="6.3. DocTestFinder对象"></a>6.3. DocTestFinder对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">doctest</span>.<span class="title">DocTestFinder</span><span class="params">([verbose][, parser][, recurse][, exclude_empty])</span></span></span><br></pre></td></tr></table></figure><p>一个处理类，用于<code>DocTest</code>从文档字符串及其包含对象的文档字符串中提取与给定对象相关的s。<code>DocTest</code>s可以从下列对象类型中提取：模块，函数，类，方法，静态方法，类方法和属性。</p><p>可选参数<em>verbose</em>可用于显示查找器搜索的对象。它默认为<code>False</code>（不输出）。</p><p>可选参数<em>解析器</em>指定<code>DocTestParser</code>用于从文档字符串中提取文档测试的对象（或插入替换）。</p><p>如果可选参数<em>recurse</em>为false，那么<code>DocTestFinder.find()</code>将只检查给定的对象，而不检查任何包含的对象。</p><p>如果可选参数<em>exclude_empty</em>为false，<code>DocTestFinder.find()</code>则将包含具有空文档字符串的对象的测试。</p><p>2.4版本中的新功能。</p><p><code>DocTestFinder</code> 定义了以下方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find(obj[, name][, module][, globs][, extraglobs])</span><br></pre></td></tr></table></figure><p>返回<code>DocTest</code>由<em>obj</em>的文档字符串或其包含的任何对象的文档字符串定义的s 的列表。</p><p>可选参数<em>名称</em>指定对象的名称; 这个名字将被用来为返回的<code>DocTest</code>s 构造名字。如果没有指定<em>名称</em>，则<code>obj.__name__</code>使用。</p><p>可选参数<em>模块</em>是包含给定对象的模块。如果模块没有被指定或者是<code>None</code>，则测试发现者将尝试自动确定正确的模块。使用该对象的模块：</p><ul><li><p>作为默认命名空间，如果没有指定<em>globs</em>。</p></li><li><p>阻止DocTestFinder从其他模块导入的对象中提取DocTests。（包含模块以外的<em>模块的</em>包含对象将被忽略。）</p></li><li><p>查找包含该对象的文件的名称。</p></li><li><p>帮助查找文件中对象的行号。</p></li></ul><p>如果<em>模块</em>是<code>False</code>，则不会尝试找到该模块。这是很晦涩的，主要用于测试doctest本身：如果<em>module</em>是<code>False</code>，或者是<code>None</code>但不能自动找到，那么所有对象都被认为属于（不存在的）模块，因此所有包含的对象将（递归地）被搜索为doctests。</p><p>对于每个全局<code>DocTest</code>通过组合形成<em>水珠</em>和<em>extraglobs</em>（在绑定<em>extraglobs</em>倍率绑定在<em>水珠</em>）。为每个字典创建一个新的globals字典的浅表副本<code>DocTest</code>。如果未指定<em>globs</em>，则默认为模块的<strong>_dict</strong> <em>（如果已指定）或</em><code>*{}*</code><em>以其他方式指定。如果_extraglobs</em>没有被指定，那么它默认为<code>{}</code>。</p><h3 id="6-4-DocTestParser对象"><a href="#6-4-DocTestParser对象" class="headerlink" title="6.4. DocTestParser对象"></a>6.4. DocTestParser对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">doctest</span>.<span class="title">DocTestParser</span></span></span><br></pre></td></tr></table></figure><p>一个处理类，用于从字符串中提取交互式示例，并使用它们创建<code>DocTest</code>对象。</p><p>2.4版本中的新功能。</p><p><code>DocTestParser</code> 定义了以下方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_doctest(string, globs, name, filename, lineno)</span><br></pre></td></tr></table></figure><p>从给定的字符串中提取所有doctest示例，并将它们收集到一个<code>DocTest</code>对象中。</p><p><em>globs</em>，<em>name</em>，<em>filename</em>和<em>lineno</em>是新<code>DocTest</code>对象的属性。请参阅文档以<code>DocTest</code>获取更多信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_examples(string[, name])</span><br></pre></td></tr></table></figure><p>从给定的字符串中提取所有doctest示例，并将它们作为<code>Example</code>对象列表返回。行号是从0开始的。可选参数<em>名称</em>是标识此字符串的名称，仅用于错误消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parse(string[, name])</span><br></pre></td></tr></table></figure><p>将给定的字符串分成示例和干预文本，并将它们作为交替<code>Example</code>s和字符串的列表返回。<code>Example</code>s的行号是基于0的。可选参数<em>名称</em>是标识此字符串的名称，仅用于错误消息。</p><h3 id="6-5-DocTestRunner对象"><a href="#6-5-DocTestRunner对象" class="headerlink" title="6.5. DocTestRunner对象"></a>6.5. DocTestRunner对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class doctest.DocTestRunner([checker][, verbose][, optionflags])</span><br></pre></td></tr></table></figure><p>处理类用于执行和验证<code>DocTest</code>中的交互式示例。</p><p>预期产出与实际产出之间的比较由<code>OutputChecker</code>。这种比较可以用许多选项标志来定制; 有关更多信息，请参阅选项标志部分。如果选项标志不足，则可以通过<code>OutputChecker</code>向构造函数传递一个子类来定制比较。</p><p>测试运行者的显示输出可以通过两种方式进行控制。首先，可以传递一个输出函数<code>TestRunner.run()</code>; 这个函数将会被显示的字符串调用。它默认为<code>sys.stdout.write</code>。如果捕获的输出不充分，则显示输出也可以通过继承DocTestRunner，并覆盖方法定制<code>report_start()</code>，<code>report_success()</code>，<code>report_unexpected_exception()</code>，和<code>report_failure()</code>。</p><p>可选的关键字参数<em>检查器</em>指定<code>OutputChecker</code>应该用于比较预期输出与doctest示例的实际输出的对象（或插入替换）。</p><p>可选的关键字参数<em>verbose</em>控制着<code>DocTestRunner</code>冗长。如果<em>详细</em>是<code>True</code>，则会在每个示例运行时打印信息。如果<em>详细</em>是<code>False</code>，则只打印故障。如果<em>verbose</em>未指定，或者<code>None</code>使用详细输出，则使用命令行开关<code>-v</code>。</p><p>可选的关键字参数<em>optionflags</em>可用于控制测试运行器如何将预期输出与实际输出进行比较，以及它如何显示故障。有关更多信息，请参见选项标志部分。</p><p>2.4版本中的新功能。</p><p><code>DocTestParser</code> 定义了以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">report_start(out, test, example)</span><br></pre></td></tr></table></figure><p>报告测试运行人员即将处理给出的示例。提供此方法以允许其子类<code>DocTestRunner</code>定制其输出；它不应该直接调用。</p><p><em>例子</em>就是要处理的例子。<em>测试</em>是<em>包含示例</em>的测试。<em>out</em>是传递给的输出函数<code>DocTestRunner.run()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">report_success(out, test, example, got)</span><br></pre></td></tr></table></figure><p>报告给出的示例已成功运行。提供此方法以允许其子类<code>DocTestRunner</code>定制其输出；它不应该直接调用。</p><p><em>例子</em>就是要处理的例子。<em>得到的</em>是实例的实际输出。<em>测试</em>是包含<em>示例</em>的测试。<em>out</em>是传递给的输出函数<code>DocTestRunner.run()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">report_failure(out, test, example, got)</span><br></pre></td></tr></table></figure><p>报告给出的例子失败。提供此方法以允许其子类<code>DocTestRunner</code>定制其输出; 它不应该直接调用。</p><p><em>例子</em>就是要处理的例子。<em>得到的</em>是实例的实际输出。<em>测试</em>是包含<em>示例</em>的测试。<em>out</em>是传递给的输出函数<code>DocTestRunner.run()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">report_unexpected_exception(out, test, example, exc_info)</span><br></pre></td></tr></table></figure><p>报告给出的示例引发了意外的异常。提供此方法以允许其子类<code>DocTestRunner</code>定制其输出; 它不应该直接调用。</p><p><em>例子</em>就是要处理的例子。<em>exc_info</em>是包含有关意外异常（由返回的<code>sys.exc_info()</code>）的信息的元组。<em>测试</em>是包含<em>示例</em>的测试。<em>out</em>是传递给的输出函数<code>DocTestRunner.run()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(test[, compileflags][, out][, clear_globs])</span><br></pre></td></tr></table></figure><p>运行在实施例中<em>测试</em>（一个<code>DocTest</code>对象），并使用写入器功能显示结果<em>出来</em>。</p><p>这些示例在命名空间中运行<code>test.globs</code>。如果<em>clear_globs</em>为true（缺省值），那么该名称空间将在测试运行后清除，以帮助进行垃圾回收。如果您想在测试完成后检查名称空间，请使用<em>clear_globs = False</em>。</p><p><em>compileflags</em>给出了运行示例时Python编译器应该使用的一组标志。如果未指定，则它将默认为适用于<em>globs</em>的future-import标志集。</p><p>每个示例的输出都使用<code>DocTestRunner</code>输出检查器进行检查，并且结果由这些<code>DocTestRunner.report_*()</code>方法进行格式化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">summarize([verbose])</span><br></pre></td></tr></table></figure><p>打印由此DocTestRunner运行的所有测试用例的摘要，并返回一个<a href="https://docs.python.org/2.7/glossary.html#term-named-tuple" target="_blank" rel="noopener">指定的元组</a> <code>TestResults(failed, attempted)</code>。</p><p>可选的<em>详细</em>参数控制摘要的详细程度。如果没有指定<code>DocTestRunner</code>详细程度，则使用冗长度。</p><p>在版本2.6中更改：使用命名的元组。</p><h3 id="6-6-OutputChecker对象"><a href="#6-6-OutputChecker对象" class="headerlink" title="6.6. OutputChecker对象"></a>6.6. OutputChecker对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class doctest.OutputChecker</span><br></pre></td></tr></table></figure><p>用于检查doctest示例的实际输出是否与预期输出匹配的类。<code>OutputChecker</code>定义了两种方法：<code>check_output()</code>，它比较给定的一对输出，如果匹配则返回真; 并<code>output_difference()</code>返回一个描述两个输出之间差异的字符串。</p><p>2.4版本中的新功能。</p><p><code>OutputChecker</code> 定义了以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_output(want, got, optionflags)</span><br></pre></td></tr></table></figure><p><code>True</code>如果示例（<em>got</em>）的实际输出与预期输出（<em>想要</em>）匹配，则返回。如果这些字符串相同，则始终认为它们匹配；但取决于测试运行器使用的选项标志，还可以使用几种非精确匹配类型。有关选项标志的更多信息，请参见选项标志部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output_difference(example, got, optionflags)</span><br></pre></td></tr></table></figure><p>返回一个字符串，描述给定示例（<em>示例</em>）的预期输出与实际输出（<em>获得</em>）之间的差异。<em>optionflags</em>是用来比较<em>想要</em>和<em>得到</em>的选项标志的集合。</p><h2 id="7-调试"><a href="#7-调试" class="headerlink" title="7.调试"></a>7.调试</h2><p>Doctest提供了几种调试doctest示例的机制：</p><ul><li><p>几个函数将doctests转换为可执行的Python程序，可以在Python调试器下运行<code>pdb</code>。</p></li><li><p><code>DebugRunner</code>类是的一个子类<code>DocTestRunner</code>的是提高用于第一故障的例子的异常，包含有关实施例的信息。该信息可用于对示例执行事后调试。</p></li><li><p><code>unittest</code>通过<code>DocTestSuite()</code>支持由<code>debug()</code>所定义的方法生成的案例<code>unittest.TestCase</code>。</p></li><li><p>您可以<code>pdb.set_trace()</code>在doctest示例中添加调用，并在执行该行时放入Python调试器。然后你可以检查变量的当前值，等等。例如，假设<code>a.py</code>只包含这个模块docstring：</p></li></ul><blockquote><p> “”” &gt;&gt;&gt; def f(x): …     g(x*2) &gt;&gt;&gt; def g(x): …     print x+3 …     import pdb; pdb.set_trace() &gt;&gt;&gt; f(3) 9 “”” </p></blockquote><p> 然后，一个交互式Python会话可能如下所示：</p><blockquote><p>import a, doctest &gt;&gt;&gt; doctest.testmod(a) –Return– &gt; <doctest a1>(3)g()-&gt;None -&gt; import pdb; pdb.set_trace() (Pdb) list   1     def g(x):   2         print x+3   3  -&gt;     import pdb; pdb.set_trace() EOF print x 6 (Pdb) step –Return– &gt; <doctest a0>(2)f()-&gt;None -&gt; g(x<em>2) (Pdb) list   1     def f(x):   2  -&gt;     g(x</em>2) EOF print x 3 (Pdb) step –Return– &gt; <doctest a2>(1)?()-&gt;None -&gt; f(3) (Pdb) cont (0, 3) &gt;&gt;&gt; </doctest></doctest></doctest></p></blockquote><p>  在版本2.4中进行了更改：<code>pdb.set_trace()</code>添加了在文档测试中使用有用的功能。</p><p>将doctests转换为Python代码的函数，并可能在调试器下运行综合代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.script_from_examples(s)</span><br></pre></td></tr></table></figure><p>将带有示例的文本转换为脚本。</p><p>参数<em>s</em>是一个包含doctest示例的字符串。该字符串被转换为Python脚本，其中<em>s</em>中的doctest示例转换为常规代码，其他所有内容都转换为Python注释。生成的脚本作为字符串返回。例如，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line"><span class="keyword">print</span> doctest.script_from_examples(<span class="string">r"""</span></span><br><span class="line"><span class="string">    Set x and y to 1 and 2.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y = 1, 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Print their sum:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print x+y</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">"""</span>)</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set x and y to 1 and 2.</span></span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Print their sum:</span></span><br><span class="line"><span class="keyword">print</span> x+y</span><br><span class="line"><span class="comment"># Expected:</span></span><br><span class="line"><span class="comment">## 3</span></span><br></pre></td></tr></table></figure><p>该函数在其他函数的内部使用（请参见下文），但是当您想要将交互式Python会话转换为Python脚本时，该函数也很有用。</p><p>2.4版本中的新功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.testsource(module, name)</span><br></pre></td></tr></table></figure><p>将对象的doctest转换为脚本。</p><p>参数<em>模块</em>是一个模块对象，或者一个模块的虚线名称，包含其文档感兴趣的对象。参数<em>名称</em>是具有感兴趣的doctests的对象的名称（在模块内）。结果是一个字符串，包含对象的文档字符串转换为Python脚本，<code>script_from_examples()</code>如上所述。例如，如果模块<code>a.py</code>包含顶级函数<code>f()</code>，那么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> a, doctest</span><br><span class="line">print doctest.testsource(a, <span class="string">"a.f"</span>)</span><br></pre></td></tr></table></figure><p>打印函数<code>f()</code>的文档字符串的脚本版本，将文档转换为代码，其余部分放在注释中。</p><p>2.3版本的新功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.debug(module, name[, pm])</span><br></pre></td></tr></table></figure><p>调试对象的doctests。</p><p>该<em>模块</em>和<em>名称</em>参数是相同的功能<code>testsource()</code>之上。已命名对象的文档字符串的合成Python脚本被写入临时文件，然后该文件在Python调试器的控制下运行<code>pdb</code>。</p><p><code>module.__dict__</code>本地和全局执行上下文都使用浅表副本。</p><p>可选参数<em>pm</em>控制是否使用验尸调试。如果<em>pm</em>具有真值，则脚本文件将直接运行，并且仅当脚本通过引发未处理的异常终止时才会涉及调试器。如果确实如此，则通过<code>pdb.post_mortem()</code>从未处理的异常中传递回溯对象来调用验尸调试。如果<em>pm</em>没有被指定，或者是false，那么通过传递一个适当的<code>execfile()</code>调用来从脚本开始运行脚本<code>pdb.run()</code>。</p><p>2.3版本的新功能。</p><p>在版本2.4中更改：添加了<em>pm</em>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.debug_src(src[, pm][, globs])</span><br></pre></td></tr></table></figure><p>用字符串调试doctests。</p><p>这与<code>debug()</code>上面的函数类似，只是通过<em>src</em>参数直接指定了包含doctest示例的字符串。</p><p>可选参数<em>pm</em>与<code>debug()</code>上面的函数具有相同的含义。</p><p>可选的参数<em>globs</em>给出了一个字典，用作本地和全局执行上下文。如果未指定，或者<code>None</code>使用空字典。如果指定，则使用字典的浅表副本。</p><p>2.4版本中的新功能。</p><p><code>DebugRunner</code>级和特殊的例外可能提高，最感兴趣的测试框架的作者，并且只在这里勾勒。查看源代码，尤其<code>DebugRunner</code>是docstring（这是一个doctest！）以获取更多详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class doctest.DebugRunner([checker][, verbose][, optionflags])</span><br></pre></td></tr></table></figure><p>只要<code>DocTestRunner</code>遇到故障，它的一个子类就会引发异常。如果发生意外异常，则会引发<code>UnexpectedException</code>异常，包含测试，示例和原始异常。如果输出不匹配，则会<code>DocTestFailure</code>引发异常，包含测试，示例和实际输出。</p><p>有关构造函数参数和方法的信息，请参阅<code>DocTestRunner</code>高级API一节中的文档。</p><p><code>DebugRunner</code>实例可能会引发两个例外情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception doctest.DocTestFailure(test, example, got)</span><br></pre></td></tr></table></figure><p><code>DocTestRunner</code>表示doctest示例的实际输出与预期输出不符的异常。构造函数参数用于初始化相同名称的属性。</p><p><code>DocTestFailure</code> 定义了以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocTestFailure.test</span><br></pre></td></tr></table></figure><p><code>DocTest</code>示例失败时正在运行的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocTestFailure.example</span><br></pre></td></tr></table></figure><p><code>Example</code>失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocTestFailure.got</span><br></pre></td></tr></table></figure><p>示例的实际输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception doctest.UnexpectedException(test, example, exc_info)</span><br></pre></td></tr></table></figure><p>一个异常<code>DocTestRunner</code>提示表示doctest示例引发了意外异常。构造函数参数用于初始化相同名称的属性。</p><p><code>UnexpectedException</code> 定义了以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnexpectedException.test</span><br></pre></td></tr></table></figure><p><code>DocTest</code>示例失败时正在运行的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnexpectedException.example</span><br></pre></td></tr></table></figure><p><code>Example</code>失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnexpectedException.exc_info</span><br></pre></td></tr></table></figure><p>包含有关意外异常的信息的元组，返回的是<code>sys.exc_info()</code>。</p><h2 id="8-Soapbox"><a href="#8-Soapbox" class="headerlink" title="8. Soapbox"></a>8. Soapbox</h2><p>正如引言中提到的，<code>doctest</code>已经发展到三个主要用途：</p><ol><li>检查文档字符串中的示例。</li></ol><p>\2. 回归测试。</p><p>\3. 可执行文档/文字测试。</p><p>这些用途具有不同的要求，区分它们很重要。特别是，用不明确的测试用例填充文档字符串会导致错误的文档。</p><p>在编写文档字符串时，请小心选择文档字符串示例。有一个学问需要学习 - 起初可能并不自然。示例应该为文档增加真正的价值。一个很好的例子往往可以说很多话。如果谨慎处理，这些示例对您的用户来说将是非常宝贵的，并且会随着时间的推移和事情的变化而回报多次收集它们所需的时间。我仍然惊讶于我的一个<code>doctest</code>示例在“无害”更改后停止工作的频率。</p><p>Doctest也是回归测试的绝佳工具，特别是如果你不吝啬解释性文本。通过插入散文和例子，跟踪实际正在测试的内容以及为什么更容易。当一个测试失败时，好的散文可以使得更容易找出问题所在，以及应该如何解决问题。的确，您可以在基于代码的测试中编写大量的评论，但很少有程序员会这样做。许多人已经发现使用doctest方法会导致更清晰的测试。也许这只是因为doctest使编写散文比编写代码容易一些，而在代码中编写注释有点困难。我认为它比以上更深刻：编写基于doctest的测试时的自然态度是您想解释软件的优点，并用示例来说明它们。这反过来自然会导致以最简单的功能开始的测试文件，并在逻辑上进展到复杂性和边缘情况。一个连贯的叙述是结果，而不是一组孤立的函数，它们似乎随机地测试孤立的功能位。这是一种不同的态度，产生不同的结果，模糊了测试和解释之间的区别。</p><p>回归测试最好局限于专用对象或文件。有几种组织测试的选项：</p><ul><li><p>将包含测试用例的文本文件编写为交互式示例，并使用<code>testfile()</code>或测试这些文件<code>DocFileSuite()</code>。这是推荐的，尽管对于从一开始就使用doctest设计的新项目来说，这是最容易做到的。</p></li><li><p>定义名为<code>_regrtest_topic</code>包含单个文档字符串的函数，其中包含指定主题的测试用例。这些功能可以包含在与模块相同的文件中，或者分离到单独的测试文件中。</p></li><li><p>定义<code>__test__</code>从回归测试主题到包含测试用例的文档字符串的字典映射。</p></li></ul><p>当您将测试放入模块中时，模块本身可以成为测试运行者。当测试失败时，您可以安排测试运行者在调试问题时仅重新运行失败的doctest。这是一个这样的测试运行者的最小例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    flags = doctest.REPORT_NDIFF|doctest.REPORT_ONLY_FIRST_FAILURE</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">        name = sys.argv[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> globals():</span><br><span class="line">            obj = globals()[name]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            obj = __test__[name]</span><br><span class="line">        doctest.run_docstring_examples(obj, globals(), name=name,</span><br><span class="line">                                       optionflags=flags)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fail, total = doctest.testmod(optionflags=flags)</span><br><span class="line">        print(<span class="string">"&#123;&#125; failures out of &#123;&#125; tests"</span>.format(fail, total))</span><br></pre></td></tr></table></figure><h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><p>不支持包含预期输出和异常的示例。试图猜测一个结束和另一个开始的地方太容易出错，这也会导致一个令人困惑的测试。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-doctest&quot;&gt;&lt;a href=&quot;#python-标准库-doctest&quot; class=&quot;headerlink&quot; title=&quot;python  标准库 doctest&quot;&gt;&lt;/a&gt;python  标准库 doctest&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200316_westworld_3.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="doctest" scheme="https://pinghailinfeng.gitee.io/tags/doctest/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library Tkinter</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/14/python-standard-library-Tkinter/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/14/python-standard-library-Tkinter/</id>
    <published>2020-03-14T13:17:11.000Z</published>
    <updated>2020-03-15T03:49:19.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-Tkinter"><a href="#python-标准库-Tkinter" class="headerlink" title="python 标准库 Tkinter"></a>python 标准库 Tkinter</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200314_what_is_friends_mean_to_u.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>what life should mean to you ?</p><p>推荐这本书 中文版 翻译为：自卑与超越</p></blockquote><p>该<code>Tkinter</code>模块（“Tk接口”）是Tk GUI工具包的标准Python接口。Tk和<code>Tkinter</code>在大多数Unix平台以及Windows系统上均可用。（Tk本身不是Python的一部分;它保存在ActiveState中。）</p><p>注意</p><p><code>Tkinter</code>已被重新命名为<code>tkinter</code>Python 3. 当将源代码转换为Python 3时，<a href="https://docs.python.org/2.7/glossary.html#term-2to3" target="_blank" rel="noopener">2to3</a>工具将自动适应导入。</p><p>扩展内容</p><p> <a href="https://wiki.python.org/moin/TkInter" target="_blank" rel="noopener">Python Tkinter资源</a> Python Tkinter主题指南提供了大量关于从Python使用Tk和链接到Tk上的其他信息源的信息。<a href="http://www.tkdocs.com/" target="_blank" rel="noopener">TKDocs</a>广泛的教程和一些小部件的更友好的小部件页面。<a href="https://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html" target="_blank" rel="noopener">Tkinter参考：用于Python的GUI</a>在线参考资料。<a href="http://effbot.org/tkinterbook/" target="_blank" rel="noopener">来自effbot的Tkinter文档由effbot.org</a>支持的tkinter的在线参考。<a href="https://www.tcl.tk/man/tcl8.5/" target="_blank" rel="noopener">Tcl / Tk手册</a>最新tcl / tk版本的官方手册。由Mark Lutz <a href="http://learning-python.com/books/about-pp4e.html" target="_blank" rel="noopener">编写的Python</a>书籍，对Tkinter有很好的报道。<a href="http://www.amazon.com/Modern-Tkinter-Python-Developers-ebook/dp/B0071QDNLO/" target="_blank" rel="noopener">繁忙Python开发人员的现代Tkinter</a>由Mark Rozerman撰写关于用Python和Tkinter构建具有吸引力和现代化图形用户界面的内容。<a href="https://www.manning.com/books/python-and-tkinter-programming" target="_blank" rel="noopener">Python和Tkinter编程</a> John Grayson的书（ISBN 1-884777-81-3）。  </p><h2 id="1-Tkinter模块"><a href="#1-Tkinter模块" class="headerlink" title="1. Tkinter模块"></a>1. Tkinter模块</h2><p>大多数情况下，<code>Tkinter</code>模块都是您真正需要的，但也有一些额外的模块可供选择。Tk接口位于名为的二进制模块中<code>_tkinter</code>。该模块包含Tk的底层接口，不应直接由应用程序员使用。它通常是共享库（或DLL），但在某些情况下可能会与Python解释器静态链接。</p><p>除了Tk接口模块外，<code>Tkinter</code>还包括许多Python模块。两个最重要的模块是<code>Tkinter</code>模块本身，还有一个模块叫做<code>Tkconstants</code>。前者自动导入后者，所以要使用Tkinter，你只需要导入一个模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Tkinter</span><br></pre></td></tr></table></figure><p>或者更经常地：</p><figure class="highlight plain"><figcaption><span>Tkinter import *</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Tkinter.Tk(screenName=None, baseName=None, className=&apos;Tk&apos;, useTk=1)</span><br></pre></td></tr></table></figure><p>将<code>Tk</code>类实例化没有参数。这会创建一个Tk的顶层小部件，它通常是应用程序的主窗口。每个实例都有自己关联的Tcl解释器。</p><p>在版本2.4中更改：添加了<em>useTk</em>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tkinter.Tcl(screenName=None, baseName=None, className=&apos;Tk&apos;, useTk=0)</span><br></pre></td></tr></table></figure><p>该<code>Tcl()</code>函数是一个工厂函数<code>Tk</code>，除了不初始化Tk子系统外，它创建的对象非常类似于该类创建的对象。在不希望创建无关的顶层窗口的环境中，或者在无法（如没有X服务器的Unix / Linux系统）环境中驱动Tcl解释器时，这通常很有用。由对象创建的<code>Tcl()</code>对象可以通过调用其<code>loadtk()</code>方法创建Toplevel窗口（并初始化Tk子系统）。</p><p>2.4版本中的新功能。</p><p>其他提供Tk支持的模块包括：</p><p>ScrolledTextText小部件，内置一个垂直滚动条in.tkColorChooserDialog，让用户选择一个color.tkCommonDialogBase类，用于在这里列出的其他模块中定义的对话框。tkFileDialogCommon对话框允许用户指定要打开的文件或save.tkFontUtilities以帮助 使用fonts.tkMessageBoxAccess来标准Tk对话框boxes.tkSimpleDialogBasic对话框和便捷函数.Tkdnd拖放支持Tkinter。 这是实验性的，当它在Tk窗口中用Tk DND.turtleTurtle图形取代时应该被弃用。</p><p>这些已经在Python 3中重新命名了; 他们都是新<code>tkinter</code>包装的子模块。</p><h2 id="2-Tkinter救生员系统"><a href="#2-Tkinter救生员系统" class="headerlink" title="2. Tkinter救生员系统"></a>2. Tkinter救生员系统</h2><p>本节不是为Tk或Tkinter的详尽教程而设计的。相反，它旨在作为一个制止差距，为系统提供一些入门指导。</p><p>Credits:</p><ul><li><p>Tkinter由Steen Lumholt和Guido van Rossum撰写。</p></li><li><p>Tk由John Ousterhout在伯克利书写。</p></li><li><p>这个Life Preserver 是由弗吉尼亚大学的马特康威编写的。</p></li><li><p>HTML渲染和一些自由编辑是由Ken Manheimer的FrameMaker版本生成的。</p></li><li><p>Fredrik Lundh详细阐述并修改了类接口描述，以使它们与Tk 4.2一致。</p></li><li><p>Mike Clarkson将文档转换为LaTeX，并编译了参考手册的用户界面章节。</p></li></ul><h3 id="2-1-如何使用本节"><a href="#2-1-如何使用本节" class="headerlink" title="2.1 如何使用本节"></a>2.1 如何使用本节</h3><p>本部分分为两部分：前半部分（大致）包含背景材料，后半部分可作为便于参考的键盘。</p><p>当试图回答“我该怎么做”这个形式的问题时，通常最好找出如何在直接Tk中做“无用”，然后将其转换回相应的<code>Tkinter</code>呼叫。Python程序员通常可以通过查看Tk文档来猜测正确的Python命令。这意味着为了使用Tkinter，你必须知道一些关于Tk的知识。这个文件不能完成这个角色，所以我们能做的最好的事情就是向您提供最好的文档。以下是一些提示：</p><ul><li><p>作者强烈建议获取Tk手册页的副本。具体来说，<code>mann</code>目录中的手册页是最有用的。该<code>man3</code>手册页介绍了C接口Tk库，因此不为脚本编写者特别有用。</p></li><li><p>Addison-Wesley出版了一本名为Tcl的书和John Ousterhout的Tk Toolkit（ISBN 0-201-63337-X），这是对新手Tcl和Tk的一个很好的介绍。这本书并非详尽无遗，对于许多细节，它都遵循手册页。</p></li><li><p><code>Tkinter.py</code> 对大多数人来说是最后的选择，但如果没有其他任何意义的话，它可能是一个很好的去处。</p></li></ul><p>扩展内容</p><p> <a href="http://tcl.activestate.com/" target="_blank" rel="noopener">ActiveState Tcl主页</a> Tk / Tcl开发主要发生在ActiveState上。<a href="http://www.amazon.com/exec/obidos/ASIN/020163337X" target="_blank" rel="noopener">Tcl和Tk工具包</a> Tcl的发明人John Ousterhout的书。<a href="http://www.beedub.com/book/" target="_blank" rel="noopener">Tcl和Tk中的实用编程</a> Brent Welch的百科全书。  </p><h3 id="2-2-一个简单的Hello-World程序"><a href="#2-2-一个简单的Hello-World程序" class="headerlink" title="2.2  一个简单的Hello World程序"></a>2.2  一个简单的Hello World程序</h3><figure class="highlight plain"><figcaption><span>import *</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Application(Frame):</span><br><span class="line">    def say_hi(self):</span><br><span class="line">        print &quot;hi there, everyone!&quot;</span><br><span class="line"></span><br><span class="line">    def createWidgets(self):</span><br><span class="line">        self.QUIT = Button(self)</span><br><span class="line">        self.QUIT[&quot;text&quot;] = &quot;QUIT&quot;</span><br><span class="line">        self.QUIT[&quot;fg&quot;]   = &quot;red&quot;</span><br><span class="line">        self.QUIT[&quot;command&quot;] =  self.quit</span><br><span class="line"></span><br><span class="line">        self.QUIT.pack(&#123;&quot;side&quot;: &quot;left&quot;&#125;)</span><br><span class="line"></span><br><span class="line">        self.hi_there = Button(self)</span><br><span class="line">        self.hi_there[&quot;text&quot;] = &quot;Hello&quot;,</span><br><span class="line">        self.hi_there[&quot;command&quot;] = self.say_hi</span><br><span class="line"></span><br><span class="line">        self.hi_there.pack(&#123;&quot;side&quot;: &quot;left&quot;&#125;)</span><br><span class="line"></span><br><span class="line">    def __init__(self, master=None):</span><br><span class="line">        Frame.__init__(self, master)</span><br><span class="line">        self.pack()</span><br><span class="line">        self.createWidgets()</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">app = Application(master=root)</span><br><span class="line">app.mainloop()</span><br><span class="line">root.destroy()</span><br></pre></td></tr></table></figure><h2 id="3-（非常）快速浏览Tcl-Tk"><a href="#3-（非常）快速浏览Tcl-Tk" class="headerlink" title="3. （非常）快速浏览Tcl / Tk"></a>3. （非常）快速浏览Tcl / Tk</h2><p>类层次结构看起来很复杂，但实际上，应用程序员几乎总是引用层次结构底部的类。</p><p>注意：</p><ul><li><p>提供这些类是为了在一个命名空间下组织某些功能。它们不是要独立实例化的。</p></li><li><p>该<code>Tk</code>类，就是要在应用程序中只有一次实例化。应用程序员不需要明确地实例化一个实例，只要有任何其他类实例化，系统就会创建一个。</p></li><li><p>这个<code>Widget</code>类不意味着被实例化，它只是意味着子类化才能生成“真实”的小部件（在C ++中，这被称为“抽象类”）。</p></li></ul><p>为了使用这个参考资料，有时候您需要知道如何阅读Tk的简短段落以及如何识别Tk命令的各个部分。（请参阅将Tk的基本Tk映射到Tkinter中，<code>Tkinter</code>以了解下面的内容。）</p><p>Tk脚本是Tcl程序。像所有的Tcl程序一样，Tk脚本只是由空格分隔的令牌列表。传统知识小部件就是它的<em>类</em>的<em>选项</em>，帮助配置，和<em>行动</em>，使人们做有用的事情。</p><p>要在Tk中创建一个小部件，该命令始终是以下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpythond newPathname options</span><br></pre></td></tr></table></figure><p>classCommand_表示要制作哪种小部件（按钮，标签，菜单…）_ newPathname_是此小部件的新名称。 Tk中的所有名称都必须是唯一的。 为了帮助执行此操作，Tk中的窗口小部件以_pathnames命名，就像文件系统中的文件一样。 调用顶级小部件root。 （期间）和孩子被更多的时期划定界限。 例如，.myApp.controlPanel.okButton可能是一个窗口小部件的名称._options_configure窗口小部件的外观，在某些情况下，它的行为。 选项以标志和值列表的形式出现。 标志前面有一个’ - ‘，就像Unix shell命令标志一样，并且如果值超过一个单词，则会将值放在引号中。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buttopython  -fg red -text <span class="string">"hi there"</span></span><br><span class="line">   ^       ^     \_____________________/</span><br><span class="line">   |       |                |</span><br><span class="line"> <span class="class"><span class="keyword">class</span>    <span class="title">new</span>            <span class="title">options</span></span></span><br><span class="line"><span class="class"><span class="title">command</span>  <span class="title">widget</span>  <span class="params">(-opt val -opt val ...)</span></span></span><br></pre></td></tr></table></figure><p>一旦创建，小部件的路径名变成新命令。这个新的<em>Widget命令</em>是程序员获取新Widget执行某些<em>操作</em>的句柄。在C语言中，你可以用C ++表示它为someAction（fred，someOptions），你可以将它表示为fred.someAction（someOptions），在Tk中，你会说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.fred sompythonmeOptions</span><br></pre></td></tr></table></figure><p>请注意，对象名称.fred以点开头。</p><p>正如你所期望的那样，someAction的合法值将取决于窗口部件的类：.fred禁用如果fred是一个按钮（fred变灰），但不起作用，但如果fred是标签，则不起作用（不支持禁用标签 在Tk）。</p><p>someOptions的合法价值取决于行动。 某些操作（如disable）不需要参数，其他操作（如文本输入框的delete命令）需要参数来指定要删除的文本范围。</p><h2 id="4-将Tk映射到Tkinter"><a href="#4-将Tk映射到Tkinter" class="headerlink" title="4.将Tk映射到Tkinter"></a>4.将Tk映射到Tkinter</h2><p>Tk中的类命令对应于Tkinter中的类构造函数。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button .fred python     =====&gt;  fred = Button()</span><br></pre></td></tr></table></figure><p>对象的主对象隐含在创建时给它的新名称中。在Tkinter中，明确指定了主人。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button .panel.frepython =====&gt;  fred = Button(panel)</span><br></pre></td></tr></table></figure><p>Tk中的配置选项在带有数值的紧跟标签列表中给出。在Tkinter中，选项在实例构造函数中被指定为关键字参数，在配置调用中被指定为keyword-args，或者在字典样式中被指定为已建立实例的实例索引。请参见设置选项中的设置选项部分。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button .fred -fg red python==&gt;  fred = Button(panel, fg = "red")</span><br><span class="line">.fred configure -fg red     =====&gt;  fred["fg"] = red</span><br><span class="line">                            OR ==&gt;  fred.config(fg = "red")</span><br></pre></td></tr></table></figure><p>在Tk中，要在小部件上执行操作，请使用小部件名称作为命令，然后使用操作名称，可能带有参数（选项）。在Tkinter中，您可以调用类实例上的方法来调用窗口小部件上的操作。Tkinter.py模块中列出了给定小部件可以执行的动作（方法）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.fred invoke             python fred.invoke()</span><br></pre></td></tr></table></figure><p>要给封装器（几何管理器）提供一个小部件，可以使用可选参数调用封装。在Tkinter中，Pack类拥有所有这些功能，并且各种形式的pack命令都作为方法实现。所有的小部件<code>Tkinter</code>都是从Packer中分类出来的，因此继承了所有的打包方法。有关<code>Tix</code>表格几何管理器的其他信息，请参阅模块文档。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pack .fred -side left       =pythond.pack(side = <span class="string">"left"</span>)</span><br></pre></td></tr></table></figure><h2 id="5-Tk和Tkinter是如何相关的"><a href="#5-Tk和Tkinter是如何相关的" class="headerlink" title="5. Tk和Tkinter是如何相关的"></a>5. Tk和Tkinter是如何相关的</h2><p>从上到下：</p><p>你的应用程序在这里（Python）一个Python应用程序进行<code>Tkinter</code>调用.Tkinter（Python模块）这个调用（例如，创建一个按钮控件）在<em>Tkinter</em>模块中实现，该模块是用Python编写的。这个Python函数将解析命令和参数并将它们转换为一种形式，使它们看起来好像它们来自Tk脚本而不是Python脚本.tkinter（C）这些命令及其参数将传递给C在<em>tkinter</em>中的<em>功能</em> - 注意小写 - 扩展模块.Tk Widgets（C和Tcl）这个C函数可以调用其他C模块，包括组成Tk库的C函数。Tk在C和一些Tcl中实现。Tk小部件的Tcl部分用于将某些默认行为绑定到小部件，并且在<code>Tkinter</code>导入Python 模块的位置执行一次。（用户从不会看到这个阶段）.Tk（C）Tk Widgets的Tk部分实现了最终映射到… Xlib（C）Xlib库在屏幕上绘制图形。</p><h2 id="6-方便的参考"><a href="#6-方便的参考" class="headerlink" title="6.方便的参考"></a>6.方便的参考</h2><h3 id="6-1-设置选项"><a href="#6-1-设置选项" class="headerlink" title="6.1  设置选项"></a>6.1  设置选项</h3><p>选项控制一些东西，比如一个小部件的颜色和边框宽度。选项可以通过三种方式设置：</p><p>在创建对象时，使用关键字参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fred = Button(self, fg = <span class="string">"red"</span>, bpython)</span><br></pre></td></tr></table></figure><p>创建对象后，将选项名称视为字典索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fred[<span class="string">"fg"</span>] = <span class="string">"red"</span></span><br><span class="line">fred[<span class="string">"bg"</span>] = <span class="string">"bluepythononfig（）方法更新对象创建后的多个attrs</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">​```python</span></span><br><span class="line"><span class="string">fred.config(fg = "</span>red<span class="string">", bg = "</span>blue<span class="string">")</span></span><br></pre></td></tr></table></figure><p>python为的完整说明，请参阅相关Widget的Tk手册页。</p><p>请注意，手册页列出了每个窗口小部件的“标准选项”和“小部件特定选项”。前者是许多小部件通用的选项列表，后者是特定小部件特有的选项。标准选项记录在<em>选项（3）</em>手册页上。</p><p>本文档没有区分标准和特定于窗口小部件的选项。有些选项不适用于某些类型的小部件。给定小部件是否响应特定选项取决于小部件的类别; 按钮有一个<code>command</code>选项，标签没有。</p><p>给定小部件支持的选项列在该小部件的手册页中，或者可以在运行时通过调用<code>config()</code>没有参数的方法或通过调用该<code>keys()</code>小部件上的方法来查询。这些调用的返回值是一个字典，其中的键是作为字符串（例如，<code>&#39;relief&#39;</code>）的选项的名称，其值是5元组。</p><p>一些选项，如bg是长名称的常见选项的同义词（bg是“背景”的简写）。 传递config（）方法的简写选项的名称将返回一个2元组，而不是5元组。 传回的2元组将包含同义词的名称和“真实”选项（例如（’bg’，’background’））。</p><table><thead><tr><th style="text-align:left">指数</th><th style="text-align:left">含义</th><th style="text-align:left">例</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">选项名称</td><td style="text-align:left">‘relief’</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">数据库查找的选项名称</td><td style="text-align:left">‘relief’</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">选项类用于数据库查找</td><td style="text-align:left">‘relief’</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">默认值</td><td style="text-align:left">‘raised’</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">当前值</td><td style="text-align:left">‘groove’</td></tr></tbody></table><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> fred.config()</span><br><span class="line">&#123;<span class="string">'relief'</span>: (<span class="string">'relief'</span>,python <span class="string">'Relief'</span>, <span class="string">'raised'</span>, <span class="string">'groove'</span>)&#125;</span><br></pre></td></tr></table></figure><p>当然，打印的字典将包括所有可用选项及其值。这只是作为一个例子。</p><h3 id="6-2-包装工"><a href="#6-2-包装工" class="headerlink" title="6.2 包装工"></a>6.2 包装工</h3><p>封隔器是Tk的几何管理机制之一。几何管理器用于指定小部件在其容器中的定位的相对位置 - 它们是相互的<em>主人</em>。相较于较为繁琐<em>placer</em>（用于不常用，我们在这里不介绍），封隔器采用定性关系规范- <em>above</em>, <em>to the left of</em>, <em>filling</em>等等-和工作的一切，以确定确切位置坐标为你。</p><p>任何<em>主</em>控件的大小由内部“从控件”的大小决定。打包器用于控制从站窗口小部件在其打包的主站内出现的位置。您可以将窗口小部件封装到框架中，并将框架封装到其他框架中，以实现您所需的布局。此外，这种安排是动态调整的，以适应配置的增量变化，一旦打包完成。</p><p>请注意，窗口小部件在用几何管理器指定几何图形之前不会显示。忽略几何规格是一个常见的早期错误，然后在创建小部件时会感到惊讶，但没有任何内容出现。例如，小部件只有在<code>pack()</code>应用打包器的方法后才会出现。</p><p>可以使用关键字选项/值对调用pack（）方法，该对控制了窗口小部件出现在其容器中的位置，以及在主应用程序窗口调整大小时的行为方式。这里有些例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fred.pack()                     <span class="comment"># defaults to sidpythonfred.pack(side = "left")</span></span><br><span class="line">fred.pack(expand = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="6-3-封装选项"><a href="#6-3-封装选项" class="headerlink" title="6.3  封装选项"></a>6.3  封装选项</h3><p>有关打包机的更多信息及其可以选择的选项，请参阅John Ousterhout书中的手册页和第183页。</p><p>anchorAnchor类型。 表示封装器将每个从器件放置在parcel.expandBoolean，0或1.fillLegal值中的位置：’x’，’y’，’both’，’none’.ipadx和ipadyA distance - 指定每个从器件的内部填充 从属widget.padx和padyA距离 - 指定从属widget的每边的外部填充。sideLegal值为：’left’，’right’，’top’，’bottom’。</p><h3 id="6-4-耦合小部件变量"><a href="#6-4-耦合小部件变量" class="headerlink" title="6.4  耦合小部件变量"></a>6.4  耦合小部件变量</h3><p>某些小部件（如文本输入小部件）的当前值设置可以通过使用特殊选项直接连接到应用程序变量。 这些选项是可变的，文本变量，onvalue，offvalue和值。 这种连接可以两种方式工作：如果变量因任何原因而变化，它所连接的小部件将被更新以反映新值。</p><p>不幸的是，在Tkinter的当前实现中，不可能通过变量或文本变量选项将任意Python变量移交给小部件。 这个变量的唯一类型是从Tkinter模块中定义的类变量中分类的变量。</p><p>已经定义了许多有用的变量的子类：StringVar，IntVar，DoubleVar和BooleanVar。 要读取此变量的当前值，请调用get（）方法，并更改其值，您可以调用set（）方法。 如果你遵循这个协议，那么这个小部件将总是跟踪这个变量的值，而不需要你做进一步的干预。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span><span class="params">(Frame)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, master=None)</span><span class="title">pythonFrame</span>.<span class="title">__init__</span><span class="params">(self, master)</span></span></span><br><span class="line"><span class="function">        <span class="title">self</span>.<span class="title">pack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">        self.entrythingy = Entry()</span><br><span class="line">        self.entrythingy.pack()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># here is the application variable</span></span><br><span class="line">        self.contents = StringVar()</span><br><span class="line">        <span class="comment"># set it to some value</span></span><br><span class="line">        self.contents.set(<span class="string">"this is a variable"</span>)</span><br><span class="line">        <span class="comment"># tell the entry widget to watch this variable</span></span><br><span class="line">        self.entrythingy[<span class="string">"textvariable"</span>] = self.contents</span><br><span class="line"></span><br><span class="line">        <span class="comment"># and here we get a callback when the user hits return.</span></span><br><span class="line">        <span class="comment"># we will have the program print out the value of the</span></span><br><span class="line">        <span class="comment"># application variable when the user hits return</span></span><br><span class="line">        self.entrythingy.bind(<span class="string">'&lt;Key-Return&gt;'</span>,</span><br><span class="line">                              self.print_contents)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_contents</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"hi. contents of entry is now ----&gt;"</span>, \</span><br><span class="line">              self.contents.get()</span><br></pre></td></tr></table></figure><h3 id="6-5-窗口管理器"><a href="#6-5-窗口管理器" class="headerlink" title="6.5  窗口管理器"></a>6.5  窗口管理器</h3><p>在Tk中，有一个实用程序命令wm用于与窗口管理器交互。 wm命令的选项允许您控制标题，位置，图标位图等。 在Tkinter中，这些命令已经作为Wm类的方法实现。 Toplevel小部件从Wm类中继承，因此可以直接调用Wm方法。</p><p>要查看包含给定窗口小部件的顶层窗口，通常可以引用窗口小部件的主窗口。当然，如果这个小部件已经被封装在一个框架内，那么这个主框架将不会代表一个顶层窗口。要访问包含任意小部件的顶级窗口，可以调用该<code>_root()</code>方法。该方法以下划线开头，表示这个函数是实现的一部分，而不是Tk功能的接口。</p><p>以下是一些典型用法的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span><span class="params">(Frame)</span>:</span></span><br><span class="line">    def __inipythonmaster=None):</span><br><span class="line">        Frame.__init__(self, master)</span><br><span class="line">        self.pack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># create the application</span></span><br><span class="line">myapp = App()</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># here are method calls to the window manager class</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">myapp.master.title(<span class="string">"My Do-Nothing Application"</span>)</span><br><span class="line">myapp.master.maxsize(<span class="number">1000</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># start the program</span></span><br><span class="line">myapp.mainloop()</span><br></pre></td></tr></table></figure><h3 id="6-6-Tk选项数据类型"><a href="#6-6-Tk选项数据类型" class="headerlink" title="6.6 Tk选项数据类型"></a>6.6 Tk选项数据类型</h3><p>anchorLegal值是指南针的点：“n”，“ne”，“e”，“se”，“s”，“sw”，“w”，“nw”以及“center”.bitmap有八个 -in，命名位图：<code>&#39;error&#39;</code>, <code>&#39;gray25&#39;</code>, <code>&#39;gray50&#39;</code>, <code>&#39;hourglass&#39;</code>, <code>&#39;info&#39;</code>, <code>&#39;questhead&#39;</code>, <code>&#39;question&#39;</code>, <code>&#39;warning&#39;</code>。 要指定一个X位图文件名，给出该文件的完整路径，前面带@，如“@ / usr / contrib / bitmap / gumby.bit”.boolean您可以传递整数0或1或字符串“yes”或“不”.callback</p><p>这是任何不带参数的Python函数。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_it</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"hi there"</span></span><br><span class="line">fred[<span class="string">"command"</span>] = print_it</span><br></pre></td></tr></table></figure><p>colorColors可以作为rgb.txt文件中X颜色的名称，或以4位表示RGB值的字符串形式给出：“#RGB”，8位：“#RRGGBB”，12位“#RRRGGGBBB”或16位位“#RRRRGGGGBBBB”范围，其中R，G，B在这里表示任何合法的十六进制数字。有关详细信息，请参阅Ousterhout书籍的第160页.cursor可以使用cursorfont.h中的标准X光标名称，而不使用XC_前缀。例如，要获得手形光标（XC_hand2），请使用字符串“hand2”。你也可以指定你自己的位图和掩码文件。请参阅Ousterhout书的第179页。距离可以在像素或绝对距离中指定屏幕距离。像素以数字和绝对距离作为字符串给出，尾部字符表示单位：c表示厘米，i表示英寸，m表示毫米，p表示打印机的点数。例如，3.5英寸表示为“3.5i”.fontTk使用列表字体名称格式，例如{courier 10 bold}。正数的字体大小以点为单位;尺寸为负数的尺寸以pixels.geometry度量。这是一个widthxheight形式的字符串，其中宽度和高度以像素为单位测量大多数小部件（显示文本的小部件的字符数）。例如：fred [“geometry”] =“200x100”.justifyLegal 值是字符串：“left”，“center”，“right”和“fill”.region这是一个带有四个空格分隔元素的字符串，这是一个合法的距离（见上文）。例如：“2 3 4 5”和“3i 2i 4.5i 2i”和“3c 2c 4c 10.4c”都是合法的区域.relief确定小部件的边框样式。合法值是：<code>&quot;raised&quot;</code>, <code>&quot;sunken&quot;</code>, <code>&quot;flat&quot;</code>, <code>&quot;groove&quot;</code>与 <code>&quot;ridge&quot;</code>.scrollcommand这几乎总是某个滚动条小部件的set（）方法，但可以是任何只有一个参数的小部件方法。例如，请参阅Python源代码分发中的Demo / tkinter / matt / canvas-with-scrollbars.py文件.wrap：必须是“none”，“char”或“word”中的一个。</p><h3 id="6-7-绑定和事件"><a href="#6-7-绑定和事件" class="headerlink" title="6.7 绑定和事件"></a>6.7 绑定和事件</h3><p>通过widget命令的绑定方法，您可以监视某些事件并在发生该事件类型时触发回调函数。绑定方法的形式是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bind</span><span class="params">(self, sequence, func, add=<span class="string">''</span>)</span>:</span></span><br></pre></td></tr></table></figure><p>如下：</p><p>sequence是一个表示事件目标类型的字符串。 （有关详细信息，请参阅John Ousterhout书中的绑定手册页和第201页）。当事件发生时，调用一个带有一个参数的Python函数。 一个Event实例将作为参数传递。 （以这种方式部署的函数通常称为回调。）addis可选，可以是’’或’+’。 传递一个空字符串表示这个绑定是要替换这个事件关联的任何其他绑定。 传递’+’意味着此函数将被添加到绑定到此事件类型的函数列表中。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def turnRed(self, event):</span><br><span class="line">    event.widget[<span class="string">"activeforeground"</span>] = <span class="string">"red"</span></span><br><span class="line"></span><br><span class="line">self.button.bind(<span class="string">"&lt;Enter&gt;"</span>, self.turnRed)</span><br></pre></td></tr></table></figure><p>注意事件的widget字段在turnRed（）回调中被访问。 该字段包含捕获X事件的小部件。 下表列出了您可以访问的其他事件字段以及它们在Tk中的表示方式，这在引用Tk手册页时非常有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Tk      Tkinter Event Field             Tk      Tkinter Event Field</span><br><span class="line">--      -------------------             --      -------------------</span><br><span class="line">%f      focus                           %A      char</span><br><span class="line">%h      height                          %E      send_event</span><br><span class="line">%k      keycode                         %K      keysym</span><br><span class="line">%s      state                           %N      keysym_num</span><br><span class="line">%t      time                            %T      type</span><br><span class="line">%w      width                           %W      widget</span><br><span class="line">%x      x                               %X      x_root</span><br><span class="line">%y      y                               %Y      y_root</span><br></pre></td></tr></table></figure><h3 id="6-8-索引参数"><a href="#6-8-索引参数" class="headerlink" title="6.8 索引参数"></a>6.8 索引参数</h3><p>许多小部件需要传递“索引”参数。它们用于指向Text小部件中的特定位置，或指向Entry小部件中的特定字符或指向Menu小部件中的特定菜单项。</p><p>Entry widget indexes (index, view index, etc.)</p><p>条目窗口小部件具有涉及正在显示的文本中的字符位置的选项。您可以使用这些<code>Tkinter</code>函数来访问文本小部件中的这些特殊点：</p><p>AtEnd（）指的是textAtInsert（）中的最后一个位置，指的是文本光标isAtSelFirst（）指示选定文本的开始点的点.AtSelLast（）表示所选文本的最后一个点，finallyAt（x，y）指向到像素位置<em>x</em>，<em>y</em>处的字符（对于包含单行文本的文本输入小部件，<em>y</em>不使用<em>y</em>）。文本小部件索引文本小部件的索引符号非常丰富，最好在Tk中进行描述man pages.Menu索引（menu.invoke（），menu.entryconfig（）等）</p><p>一些菜单选项和方法可以操作特定的菜单条目。无论何时，对于选项或参数都需要菜单索引，您可以通过：</p><ul><li><p>一个整数，它指向窗口小部件中的条目的数字位置，从顶部开始计数，从0开始;</p></li><li><p>字符串<code>&#39;active&#39;</code>，它是指当前在光标下的菜单位置;</p></li><li><p><code>&quot;last&quot;</code>引用最后一个菜单项的字符串;</p></li><li><p>通过前面的整数<code>@</code>，如在<code>@6</code>，其中整数被解释为y像素菜单的坐标系统中的坐标;</p></li><li><p>该字符串<code>&quot;none&quot;</code>表示根本没有菜单条目，通常与menu.activate（）一起使用来停用所有条目，最后，</p></li><li><p>一个与菜单条目标签相匹配的文本字符串，从菜单顶部扫描到底部。 请注意，此索引类型在所有其他索引类型之后被考虑，这意味着标记为last，active或none的菜单项的匹配可能会被解释为上述文字。</p></li></ul><h3 id="6-9-图片"><a href="#6-9-图片" class="headerlink" title="6.9 图片"></a>6.9 图片</h3><p>位图/像素图像可以通过以下子类创建<code>Tkinter.Image</code>：</p><ul><li><p><code>BitmapImage</code> 可用于X11位图数据。</p></li><li><p><code>PhotoImage</code> 可用于GIF和PPM / PGM颜色位图。</p></li></ul><p>任何类型的图像都是通过<code>file</code>或<code>data</code>选项创建的（其他选项也可用）。</p><p>这个图像对象可以用于任何一个<code>image</code>小部件支持的选项（例如标签，按钮，菜单）。在这些情况下，Tk将不会保留对图像的引用。当删除对图像对象的最后一个Python引用时，图像数据也会被删除，并且无论图像在哪里使用，Tk都会显示一个空框。</p><h2 id="7-文件处理程序"><a href="#7-文件处理程序" class="headerlink" title="7.文件处理程序"></a>7.文件处理程序</h2><p>Tk允许你注册和取消注册一个回调函数，当一个文件描述符可能有I / O时，这个回调函数将从Tk mainloop调用。每个文件描述符只能注册一个处理程序。示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Tkinter</span><br><span class="line">widget = Tkinter.Tk()</span><br><span class="line">mask = Tkinter.READABLE | Tkinter.WRITABLE</span><br><span class="line">widget.tk.createfilehandler(file, mask, callback)</span><br><span class="line">...</span><br><span class="line">widget.tk.deletefilehandler(file)</span><br></pre></td></tr></table></figure><p>此功能在Windows上不可用。</p><p>由于您不知道有多少字节可供读取，因此您可能不想使用<code>BufferedIOBase</code>or <code>TextIOBase</code> <code>read()</code>或<code>readline()</code>方法，因为这些字节会坚持读取预定义的字节数。对于套接字，<code>recv()</code>or <code>recvfrom()</code>方法可以正常工作; 对于其他文件，请使用原始读取或<code>os.read(file.fileno(), maxbytecount)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget.tk.createfilehandler(file, mask, func)</span><br></pre></td></tr></table></figure><p>注册文件处理程序回调函数<em>func</em>。该<em>文件</em>的参数可以是与一个对象<code>fileno()</code>的方法（例如，文件或套接字对象），或一个整数文件描述符。的<em>掩模</em>参数是任何以下三个常量的或运算组合。回调被调用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">callback(file, mask)</span><br><span class="line">Widget.tk.deletefilehandler(file)</span><br></pre></td></tr></table></figure><p>取消注册文件处理程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tkinter.READABLETkinter.WRITABLETkinter.EXCEPTION</span><br></pre></td></tr></table></figure><p><em>掩码</em>参数中使用的常量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-Tkinter&quot;&gt;&lt;a href=&quot;#python-标准库-Tkinter&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 Tkinter&quot;&gt;&lt;/a&gt;python 标准库 Tkinter&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200314_what_is_friends_mean_to_u.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="Tkinter" scheme="https://pinghailinfeng.gitee.io/tags/Tkinter/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library xml dom</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/13/python-standard-library-xml-dom/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/13/python-standard-library-xml-dom/</id>
    <published>2020-03-13T13:55:43.000Z</published>
    <updated>2020-03-15T03:49:19.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-XML-dom-对象API"><a href="#python-标准库-XML-dom-对象API" class="headerlink" title="python 标准库 XML dom 对象API"></a>python 标准库 XML dom 对象API</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200313_bravo.gif?raw=true" alt></p><a id="more"></a><blockquote><p>bravo英音：[‘brɑ:’vəu]美音：[‘brɑ’vo]</p><p>名词 n.</p><ol><li><p>喝彩声</p></li><li><p>暴徒</p></li></ol><p>感叹词 int.</p><ol><li>好极了</li></ol><p>这个词必然来自拉丁语，所以法语意大利语西班牙语都有，英语也有了</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/python/cpython/tree/3.8/Lib/xml/dom/__init__.py" target="_blank" rel="noopener">Lib/xml/dom/<strong>init</strong>.py</a> </p><p>本节介绍 python 中DOM 模块。</p><p>文档对象模型或“DOM”是万维网联盟（W3C）的跨语言API，用于访问和修改XML文档。DOM实现将XML文档呈现为树结构，或者允许客户端代码从头构建这样的结构。然后通过提供众所周知的接口的一组对象来访问该结构。</p><p>DOM对随机访问应用程序非常有用。SAX只允许您一次查看文档的一个位。如果您正在查看一个SAX元素，则无法访问其他元素。如果您正在查看文本节点，则无法访问包含元素。当你编写一个SAX应用程序时，你需要跟踪自己代码中某个地方的程序在文档中的位置。SAX不会为你做。另外，如果你需要在XML文档中向前看，你只是运气不好。</p><p>某些应用程序在事件驱动模型中无法访问树是根本不可能的。当然，你可以在SAX事件中自己构建某种树，但是DOM允许你避免编写代码。DOM是XML数据的标准树表示。</p><p>文档对象模型由W3C分阶段定义，或者在其术语中定义为“级别”。API的Python映射基本上基于DOM Level 2推荐。</p><p>通常，DOM应用程序首先将一些XML解析为DOM。 如何实现这一点完全没有被DOM Level 1覆盖，而Level 2只提供了有限的改进：有一个DOMImplementation对象类，它提供了对文档创建方法的访问，但没有办法访问XML读取器/解析器/文档构建器 独立于实现的方式。 在没有现有Document对象的情况下，也没有明确定义的方式来访问这些方法。 在Python中，每个DOM实现将提供一个函数 <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.html#xml.dom.getDOMImplementation" target="_blank" rel="noopener"><code>getDOMImplementation()</code></a>。 DOM Level 3添加了一个Load / Store规范，该规范为读者定义了一个接口，但是这在Python标准库中尚不可用。</p><p>一旦有了DOM文档对象，就可以通过其属性和方法访问XML文档的各个部分。这些属性在DOM规范中定义; 这部分参考手册描述了Python中规范的解释。</p><p>W3C提供的规范定义了用于Java，ECMAScript和OMG IDL的DOM API。这里定义的Python映射很大程度上基于IDL版本的规范，但不需要严格的遵从（尽管实现可以自由支持来自IDL的严格映射）。有关映射要求的详细讨论，请参阅一致性部分。</p><p>扩展内容</p><p> <a href="https://www.w3.org/TR/DOM-Level-2-Core/" target="_blank" rel="noopener">文档对象模型（DOM）Level 2规范</a> </p><p>Python DOM API所基于的W3C推荐标准。</p><p><a href="https://www.w3.org/TR/REC-DOM-Level-1/" target="_blank" rel="noopener">文档对象模型（DOM）1级规范</a> </p><p>W3C推荐的DOM支持<code>xml.dom.minidom</code>。</p><p><a href="http://www.omg.org/spec/PYTH/1.2/PDF" target="_blank" rel="noopener">Python语言映射规范</a></p><p>这指定了从OMG IDL到Python的映射。  </p><h2 id="模块内容"><a href="#模块内容" class="headerlink" title="模块内容"></a>模块内容</h2><p>将<code>xml.dom</code>包含以下功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.dom.registerDOMImplementation(name, factory)</span><br></pre></td></tr></table></figure><p>注册<em>工厂</em>名称为功能<em>名称</em>。工厂函数应该返回一个实现<code>DOMImplementation</code>接口的对象。工厂函数可以每次都返回相同的对象，或者针对每次调用返回一个新对象，以适合特定的实现（例如，如果该实现支持一些定制）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.dom.getDOMImplementation([name[, features]])</span><br></pre></td></tr></table></figure><p>返回一个合适的DOM实现。 该名称是众所周知的，DOM实现的模块名称或None。 如果不是None，则导入相应的模块，并在导入成功时返回<code>DOMImplementation</code>对象。 如果未给出名称，并且已设置环境变量PYTHON_DOM，则使用此变量查找实现。</p><p>如果没有给出名称，这将检查可用实现以找到具有所需功能集的实现。如果没有找到实现，请举一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a> 。<code>(feature, version)</code>要素列表必须是<code>hasFeature()</code>在可用<code>DOMImplementation</code>对象上传递给方法的一系列对。</p><p>还提供了一些常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.dom.EMPTY_NAMESPACE</span><br></pre></td></tr></table></figure><p>用于指示没有名称空间与DOM中的节点关联的值。 这通常可以作为节点的<code>namespaceURI</code>找到，或者用作名称空间特定方法的<code>namespaceURI</code>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.dom.XML_NAMESPACE</span><br></pre></td></tr></table></figure><p>与保留前缀关联的名称空间URI <code>xml</code>，由<a href="https://www.w3.org/TR/REC-xml-names/" target="_blank" rel="noopener">XML中</a>的<a href="https://www.w3.org/TR/REC-xml-names/" target="_blank" rel="noopener">Namespaces</a>定义（第4节）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.dom.XMLNS_NAMESPACE</span><br></pre></td></tr></table></figure><p>由<a href="https://www.w3.org/TR/DOM-Level-2-Core/core.html" target="_blank" rel="noopener">文档对象模型（DOM）Level 2 Core Specification</a>（第1.1.8节）定义的名称空间声明的名称空间URI 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.dom.XHTML_NAMESPACE</span><br></pre></td></tr></table></figure><p>由<a href="https://www.w3.org/TR/xhtml1/" target="_blank" rel="noopener">XHTML 1.0</a>定义的XHTML名称空间的URI <a href="https://www.w3.org/TR/xhtml1/" target="_blank" rel="noopener">：可扩展超文本标记语言</a>（3.1.1节）。</p><p>另外，xml.dom包含一个基本的Node类和DOM异常类。 这个模块提供的Node类没有实现DOM规范定义的任何方法或属性; 具体的DOM实现必须提供这些。 作为此模块一部分提供的Node类确实提供了用于具体Node对象上的nodeType属性的常量; 它们位于类内而不是模块级，以符合DOM规范。</p><h2 id="DOM中的对象"><a href="#DOM中的对象" class="headerlink" title="DOM中的对象"></a>DOM中的对象</h2><p>DOM的权威性文档是W3C的DOM规范。</p><p>请注意，DOM属性也可以作为节点来操作，而不是简单的字符串。然而，你必须这样做是非常罕见的，所以这种用法还没有记录。</p><table><thead><tr><th style="text-align:left">接口</th><th style="text-align:left">分块</th><th style="text-align:left">目的</th></tr></thead><tbody><tr><td style="text-align:left">DOMImplementation</td><td style="text-align:left">DOMImplementation对象</td><td style="text-align:left">接口的底层实现。</td></tr><tr><td style="text-align:left">Node</td><td style="text-align:left">节点对象</td><td style="text-align:left">文档中大多数对象的基本接口。</td></tr><tr><td style="text-align:left">NodeList</td><td style="text-align:left">NodeList对象</td><td style="text-align:left">一系列节点的接口。</td></tr><tr><td style="text-align:left">DocumentType</td><td style="text-align:left">DocumentType对象</td><td style="text-align:left">关于处理文档所需声明的信息。</td></tr><tr><td style="text-align:left">Document</td><td style="text-align:left">文档对象</td><td style="text-align:left">表示整个文档的对象。</td></tr><tr><td style="text-align:left">Element</td><td style="text-align:left">元素对象</td><td style="text-align:left">文档层次结构中的元素节点。</td></tr><tr><td style="text-align:left">ATTR</td><td style="text-align:left">属性对象</td><td style="text-align:left">元素节点上的属性值节点。</td></tr><tr><td style="text-align:left">Comment</td><td style="text-align:left">注释对象</td><td style="text-align:left">在源文档中注释的表示形式。</td></tr><tr><td style="text-align:left">Text</td><td style="text-align:left">文本和CDATASection对象</td><td style="text-align:left">包含文档中文本内容的节点。</td></tr><tr><td style="text-align:left">ProcessingInstruction</td><td style="text-align:left">ProcessingInstruction对象</td><td style="text-align:left">处理指令表示。</td></tr></tbody></table><p>附加部分描述了在Python中使用DOM定义的异常。</p><h3 id="DOMImplementation对象"><a href="#DOMImplementation对象" class="headerlink" title="DOMImplementation对象"></a>DOMImplementation对象</h3><p><code>DOMImplementation</code>接口为应用程序提供了一种方法来确定他们正在使用的DOM中特定功能的可用性。 DOM Level 2增加了使用<code>DOMImplementation</code>创建新的<code>Document</code>和<code>DocumentType</code>对象的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMImplementation.hasFeature(feature, version)</span><br></pre></td></tr></table></figure><p>如果实现了一对字符串<em>功能</em>和<em>版本</em>标识的功能，则返回true 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMImplementation.createDocument(namespaceUri, qualifiedName, doctype)</span><br></pre></td></tr></table></figure><p>使用具有给定<code>namespaceUri</code>和<code>qualifiedName</code>的子元素对象返回一个新的Document对象（DOM的根）。 doctype必须是由 <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.html#xml.dom.DOMImplementation.createDocumentType" target="_blank" rel="noopener"><code>createDocumentType()</code></a> 或None创建的DocumentType对象。 在Python DOM API中，前两个参数也可以是None，以表示不要创建Element子元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMImplementation.createDocumentType(qualifiedName, publicId, systemId)</span><br></pre></td></tr></table></figure><p>返回一个<code>DocumentType</code>封装给定的<em>qualifiedName</em>，<em>publicId</em>和<em>systemId</em>字符串的新对象，表示包含在XML文档类型声明中的信息。</p><h3 id="节点对象"><a href="#节点对象" class="headerlink" title="节点对象"></a>节点对象</h3><p>XML文档的所有组件都是Node的子类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.nodeType</span><br></pre></td></tr></table></figure><p>表示节点类型的整数。 这些类型的符号常量位于Node对象上：ELEMENT_NODE，ATTRIBUTE_NODE，TEXT_NODE，CDATA_SECTION_NODE，ENTITY_NODE，PROCESSING_INSTRUCTION_NODE，COMMENT_NODE，DOCUMENT_NODE，DOCUMENT_TYPE_NODE，NOTATION_NODE。 这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.parentNode</span><br></pre></td></tr></table></figure><p>当前节点的父节点，或文档节点的None。 该值始终是一个Node对象或None。 对于元素节点，这将是父元素，除了根元素，在这种情况下它将是Document对象。 对于Attr节点，这总是无。 这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.attributes</span><br></pre></td></tr></table></figure><p>一个<code>NamedNodeMap</code>属性对象。只有元素才具有实际的价值; 其他人提供<code>None</code>这个属性。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.previousSibling</span><br></pre></td></tr></table></figure><p>紧跟在同一父节点之前的节点。例如，在<em>自身</em>元素的开始标记之前有一个结束标记的元素。当然，XML文档不仅仅包含元素，所以以前的兄弟可以是文本，评论或其他东西。如果此节点是父项的第一个子项，则此属性将为<code>None</code>。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.nextSibling</span><br></pre></td></tr></table></figure><p>紧跟在这个父节点之后的节点。另见<code>previousSibling</code>。如果这是父项的最后一个子项，则此属性将为<code>None</code>。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.childNodes</span><br></pre></td></tr></table></figure><p>此节点中包含的节点列表。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.firstChild</span><br></pre></td></tr></table></figure><p>节点的第一个孩子，如果有的话，或者<code>None</code>。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.lastChild</span><br></pre></td></tr></table></figure><p>节点的最后一个子节点，如果有的话，或者<code>None</code>。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.localName</span><br></pre></td></tr></table></figure><p>如果有冒号，冒号后面的部分是冒号，否则整个tagName。 该值是一个字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.prefix</span><br></pre></td></tr></table></figure><p>tagName在冒号前面的部分（如果有），否则为空字符串。 该值是一个字符串，或None。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.namespaceURI</span><br></pre></td></tr></table></figure><p>与元素名称关联的名称空间。这将是一个字符串或<code>None</code>。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.nodeName</span><br></pre></td></tr></table></figure><p>这对每种节点类型都有不同的含义; 有关详细信息，请参阅DOM规范。 您始终可以从另一个属性获取您在此处获得的信息，例如元素的tagName属性或属性的name属性。 对于所有节点类型，此属性的值将是一个字符串或None。 这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.nodeValue</span><br></pre></td></tr></table></figure><p>这对每种节点类型都有不同的含义; 有关详细信息，请参阅DOM规范。情况类似于<code>nodeName</code>。该值是一个字符串或<code>None</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.hasAttributes()</span><br></pre></td></tr></table></figure><p>如果节点具有任何属性，则返回true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.hasChildNodes()</span><br></pre></td></tr></table></figure><p>如果节点有任何子节点，则返回true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.isSameNode(other)</span><br></pre></td></tr></table></figure><p>如果<em>other</em> 引用与此节点相同的节点，则返回true 。这对于使用任何类型的代理体系结构的DOM实现特别有用（因为多个对象可以引用同一个节点）。</p><p>注意</p><p>这是基于建议的DOM Level 3 API，它仍处于“工作草案”阶段，但这个特定的界面似乎没有争议。来自W3C的改变不一定会影响Python DOM接口中的这种方法（尽管任何新的W3C API也会被支持）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.appendChild(newChild)</span><br></pre></td></tr></table></figure><p>将新的子节点添加到子节点列表末尾的此节点，并返回<em>newChild</em>。如果节点已经在树中，它将首先被移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.insertBefore(newChild, refChild)</span><br></pre></td></tr></table></figure><p>在现有的子节点之前插入一个新的孩子节点。 它必须是refChild是这个节点的子节点的情况; 如果不是，则引发ValueError。 返回newChild返回。 如果refChild为None，它将在子列表的末尾插入newChild。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.removeChild(oldChild)</span><br></pre></td></tr></table></figure><p>删除一个子节点。 oldChild必须是该节点的子节点; 如果不是，则引发ValueError。 oldChild成功返回。 如果oldChild不会进一步使用，则应调用其unlink（）方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.replaceChild(newChild, oldChild)</span><br></pre></td></tr></table></figure><p>用新节点替换现有节点。<em>oldChild</em>必须是这个节点的子节点; 如果没有，则会提出<code>ValueError</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.normalize()</span><br></pre></td></tr></table></figure><p>加入相邻的文本节点，以便所有文本段都作为单个<code>Text</code>实例存储。这为许多应用程序简化了从DOM树处理文本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.cloneNode(deep)</span><br></pre></td></tr></table></figure><p>克隆这个节点。设置<em>deep</em> 意味着克隆所有子节点。这将返回克隆。</p><h3 id="NodeList对象"><a href="#NodeList对象" class="headerlink" title="NodeList对象"></a>NodeList对象</h3><p>NodeList表示一系列节点。 这些对象在DOM核心推荐中以两种方式使用：一个Element对象提供一个作为其子节点列表，Node的getElementsByTagName（）和getElementsByTagNameNS（）方法返回具有此接口的对象以表示查询结果。</p><p>DOM Level 2建议为这些对象定义了一个方法和一个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NodeList.item(i)</span><br></pre></td></tr></table></figure><p>如果还有一个，则返回序列中的第<em>i</em> 项<code>None</code>。指数<em>i</em> 不得小于零或大于或等于序列的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NodeList.length</span><br></pre></td></tr></table></figure><p>序列中的节点数量。</p><p>另外，Python DOM接口要求提供一些额外的支持，以允许NodeList对象用作Python序列。 所有的NodeList实现都必须包含对<strong>len </strong>（）和<strong>getitem </strong>（）的支持; 这允许迭代NodeList中的for语句并正确支持len（）内置函数。</p><p>如果一个DOM实现支持文档的修改，那么<code>NodeList</code>实现也必须支持<a href="https://docs.python.org/2.7/reference/datamodel.html#object.__setitem__" target="_blank" rel="noopener"><code>__setitem__()</code></a>和<a href="https://docs.python.org/2.7/reference/datamodel.html#object.__delitem__" target="_blank" rel="noopener"><code>__delitem__()</code></a>方法。</p><h3 id="DocumentType对象"><a href="#DocumentType对象" class="headerlink" title="DocumentType对象"></a>DocumentType对象</h3><p>有关由文档声明的符号和实体的信息（包括解析器使用它并可以提供信息的外部子集）可从DocumentType对象中获得。 文档的DocumentType可以从Document对象的doctype属性中获得; 如果文档没有DOCTYPE声明，则文档的doctype属性将设置为None，而不是此接口的实例。</p><p><code>DocumentType</code>是专业化的<code>Node</code>，并增加了以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentType.publicId</span><br></pre></td></tr></table></figure><p>文档类型定义的外部子集的公共标识符。这将是一个字符串或<code>None</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentType.systemId</span><br></pre></td></tr></table></figure><p>文档类型定义的外部子集的系统标识符。这将作为一个字符串的URI，或<code>None</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentType.internalSubset</span><br></pre></td></tr></table></figure><p>从文档中提供完整内部子集的字符串。这不包括包含子集的括号。如果文档没有内部子集，应该是<code>None</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentType.name</span><br></pre></td></tr></table></figure><p><code>DOCTYPE</code>声明中给出的根元素的名称（如果存在）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentType.entities</span><br></pre></td></tr></table></figure><p>这是一个给出外部实体定义的NamedNodeMap。 对于不止一次定义的实体名称，只提供第一个定义（其他则根据XML建议的要求被忽略）。 如果信息不是由解析器提供的，或者没有定义实体，则这可能是None。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentType.notations</span><br></pre></td></tr></table></figure><p>这是一个NamedNodeMap，给出了符号的定义。 对于不止一次定义的记法名称，只提供第一个定义（其他则根据XML建议的要求而被忽略）。 如果信息不是由解析器提供的，或者没有定义符号，则这可能是None。</p><h3 id="文档对象"><a href="#文档对象" class="headerlink" title="文档对象"></a>文档对象</h3><p> <code>Document</code>表示整个XML文档，包括其组成元素，属性，处理指令，注释等。请记住它从中继承属性<code>Node</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.documentElement</span><br></pre></td></tr></table></figure><p>文档的唯一根元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.createElement(tagName)</span><br></pre></td></tr></table></figure><p>创建并返回一个新的元素节点。 元素在创建时未插入到文档中。 您需要使用其他方法之一（如insertBefore（）或appendChild（））来显式插入它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.createElementNS(namespaceURI, tagName)</span><br></pre></td></tr></table></figure><p>用命名空间创建并返回一个新元素。 tagName可能有一个前缀。 元素在创建时未插入到文档中。 您需要使用其他方法之一（如insertBefore（）或appendChild（））来显式插入它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.createTextNode(data)</span><br></pre></td></tr></table></figure><p>创建并返回包含作为参数传递的数据的文本节点。与其他创建方法一样，这个方法不会将节点插入树中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.createComment(data)</span><br></pre></td></tr></table></figure><p>创建并返回包含作为参数传递的数据的注释节点。与其他创建方法一样，这个方法不会将节点插入树中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.createProcessingInstruction(target, data)</span><br></pre></td></tr></table></figure><p>创建并返回包含作为参数传递的<em>目标</em>和<em>数据</em>的处理指令节点。与其他创建方法一样，这个方法不会将节点插入树中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.createAttribute(name)</span><br></pre></td></tr></table></figure><p>创建并返回一个属性节点。 此方法不会将属性节点与任何特定元素相关联。 您必须在适当的Element对象上使用setAttributeNode（）来使用新创建的属性实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.createAttributeNS(namespaceURI, qualifiedName)</span><br></pre></td></tr></table></figure><p>用命名空间创建并返回一个属性节点。 tagName可能有一个前缀。 此方法不会将属性节点与任何特定元素相关联。 您必须在适当的Element对象上使用setAttributeNode（）来使用新创建的属性实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.getElementsByTagName(tagName)</span><br></pre></td></tr></table></figure><p>搜索所有具有特定元素类型名称的后代（直接子代，子代孩子等）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.getElementsByTagNameNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure><p>使用特定的命名空间URI和本地名搜索所有后代（直接的子节点，子节点的子节点等）。localname是前缀后的名称空间的一部分。</p><h3 id="元素对象"><a href="#元素对象" class="headerlink" title="元素对象"></a>元素对象</h3><p><code>Element</code>是node的一个子类，所以继承了该类的所有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.tagName</span><br></pre></td></tr></table></figure><p>元素类型名称。在使用命名空间的文档中，它可能有冒号。该值是一个字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getElementsByTagName(tagName)</span><br></pre></td></tr></table></figure><p>与<code>Document</code>类中的等同方法类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getElementsByTagNameNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure><p>与<code>Document</code>类中的等同方法相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.hasAttribute(name)</span><br></pre></td></tr></table></figure><p>如果元素具有按<em>名称</em> 命名的属性，则返回true 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.hasAttributeNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure><p>如果元素具有由<em>namespaceURI</em>和<em>localName</em>命名的属性，则返回true 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getAttribute(name)</span><br></pre></td></tr></table></figure><p>以字符串形式返回按<em>名称</em> 命名的属性的值。如果不存在这样的属性，则返回空字符串，就好像该属性没有值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getAttributeNode(attrname)</span><br></pre></td></tr></table></figure><p>返回<code>Attr</code>由<em>attrname</em>命名的属性的节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getAttributeNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure><p>以字符串形式返回由<em>namespaceURI</em>和<em>localName</em>命名的属性的值。如果不存在这样的属性，则返回空字符串，就好像该属性没有值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getAttributeNodeNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure><p>在给定<em>namespaceURI</em>和<em>localName的情况下</em>，将属性值作为节点返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.removeAttribute(name)</span><br></pre></td></tr></table></figure><p>按名称删除属性。如果没有匹配的属性，则引发<code>NotFoundErr</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.removeAttributeNode(oldAttr)</span><br></pre></td></tr></table></figure><p>如果存在，请从属性列表中删除并返回<em>oldAttr</em>。如果<em>oldAttr</em>不存在，则提出<code>NotFoundErr</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.removeAttributeNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure><p>按名称删除属性。请注意，它使用localName而不是qname。如果没有匹配属性，则不会引发异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.setAttribute(name, value)</span><br></pre></td></tr></table></figure><p>从字符串中设置一个属性值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.setAttributeNode(newAttr)</span><br></pre></td></tr></table></figure><p>将新的属性节点添加到元素，如果<code>name</code>属性匹配，则在必要时替换现有的属性。如果发生替换，则将返回旧的属性节点。如果<em>newAttr</em>已被使用，<code>InuseAttributeErr</code>将会被提出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.setAttributeNodeNS(newAttr)</span><br></pre></td></tr></table></figure><p>添加一个新的属性节点到元素中，如果<code>namespaceURI</code>和<code>localName</code>属性匹配，则在必要时替换现有的属性。如果发生替换，则将返回旧的属性节点。如果<em>newAttr</em>已被使用，<code>InuseAttributeErr</code>将会被提出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.setAttributeNS(namespaceURI, qname, value)</span><br></pre></td></tr></table></figure><p>给定一个<em>namespaceURI</em> 和一个<em>qname</em>，从一个字符串中设置一个属性值。请注意，qname是整个属性名称。这与以上不同。</p><h3 id="属性对象"><a href="#属性对象" class="headerlink" title="属性对象"></a>属性对象</h3><p><code>Attr</code>从<code>Node</code>中继承，所以继承了它的所有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Attr.name</span><br></pre></td></tr></table></figure><p>属性名称。在使用命名空间的文档中，它可能包含冒号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Attr.localName</span><br></pre></td></tr></table></figure><p>如果有冒号，冒号后面的部分名称，否则为整个名称。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Attr.prefix</span><br></pre></td></tr></table></figure><p>冒号前面的部分名称，如果有的话，否则为空字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Attr.value</span><br></pre></td></tr></table></figure><p>属性的文本值。这是该<code>nodeValue</code>属性的同义词。</p><h3 id="命名的节点映射对象"><a href="#命名的节点映射对象" class="headerlink" title="命名的节点映射对象"></a>命名的节点映射对象</h3><p><code>NamedNodeMap</code>并<em>没有</em>继承<code>Node</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NamedNodeMap.length</span><br></pre></td></tr></table></figure><p>属性列表的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NamedNodeMap.item(index)</span><br></pre></td></tr></table></figure><p>返回具有特定索引的属性。您获取属性的顺序是任意的，但对于DOM的生命周期将保持一致。每个项目是一个属性节点。通过<code>value</code>属性获取它的值。</p><p>也有实验方法给这个类更多的映射行为。您可以使用它们，也可以<code>getAttribute*()</code>在<code>Element</code>对象上使用标准化的方法族。</p><h3 id="注释对象"><a href="#注释对象" class="headerlink" title="注释对象"></a>注释对象</h3><p><code>Comment</code>代表XML文档中的评论。它是子类<code>Node</code>，但不能有子节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comment.data</span><br></pre></td></tr></table></figure><p>注释的内容为一个字符串。该属性包含前导<code>和尾随之间的所有字符</code>–&gt;`，但不包括它们。</p><h3 id="文本和CDATASection对象"><a href="#文本和CDATASection对象" class="headerlink" title="文本和CDATASection对象"></a>文本和<code>CDATASection</code>对象</h3><p>该<code>Text</code>接口表示在XML文档中的文本。如果解析器和DOM实现支持DOM的XML扩展，那么封装在CDATA标记节中的部分文本将存储在<code>CDATASection</code>对象中。这两个接口是相同的，但为<code>nodeType</code>属性提供不同的值。</p><p>这些接口扩展了<code>Node</code>接口。他们不能有子节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text.data</span><br></pre></td></tr></table></figure><p>文本节点的内容为字符串。</p><p>注意</p><p><code>CDATASection</code>节点的使用并不表示该节点表示一个完整的CDATA标记部分，只是该节点的内容是CDATA部分的一部分。 单个CDATA部分可以由文档树中的多个节点表示。 无法确定两个相邻的CDATASection节点是否代表不同的CDATA标记节。</p><h3 id="ProcessingInstruction对象"><a href="#ProcessingInstruction对象" class="headerlink" title="ProcessingInstruction对象"></a><code>ProcessingInstruction</code>对象</h3><p>表示XML文档中的处理指令; 这从<code>Node</code>接口继承并且不能有子节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProcessingInstruction.target</span><br></pre></td></tr></table></figure><p>处理指令的内容直至第一个空白字符。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProcessingInstruction.data</span><br></pre></td></tr></table></figure><p>处理指令的内容跟在第一个空白字符之后。</p><h3 id="Exceptions-异常"><a href="#Exceptions-异常" class="headerlink" title="Exceptions 异常"></a><strong>Exceptions</strong> 异常</h3><p>DOM Level 2建议定义了一个单例，DOMException和一些允许应用程序确定发生的错误的常量。 DOMException实例携带一个代码属性，为特定的异常提供适当的值。</p><p>Python DOM接口提供了常量，但也扩展了一组异常，以便DOM中定义的每个异常代码都存在特定的异常。这些实现必须引发适当的特定异常，每个异常都带有相应的<code>code</code>属性值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.DOMException</span><br></pre></td></tr></table></figure><p>用于所有特定DOM异常的基本异常类。这个异常类不能直接实例化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.DomstringSizeErr</span><br></pre></td></tr></table></figure><p>当指定范围的文本不适合字符串时引发。这不是已知用于Python DOM实现，但可能从未使用Python编写的DOM实现中获得。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.HierarchyRequestErr</span><br></pre></td></tr></table></figure><p>当尝试插入不允许节点类型的节点时引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.IndexSizeErr</span><br></pre></td></tr></table></figure><p>当方法的索引或大小参数为负值或超出允许值时引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.InuseAttributeErr</span><br></pre></td></tr></table></figure><p>当尝试插入已存在于文档中其他位置的Attr节点时引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.InvalidAccessErr</span><br></pre></td></tr></table></figure><p>如果基础对象不支持参数或操作，则引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.InvalidCharacterErr</span><br></pre></td></tr></table></figure><p>如果字符串参数包含在XML 1.0建议中使用的上下文中不允许的字符，则会引发此异常。例如，尝试<code>Element</code>在元素类型名称中创建具有空格的节点会导致此错误的发生。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.InvalidModificationErr</span><br></pre></td></tr></table></figure><p>当尝试修改节点的类型时引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.InvalidStateErr</span><br></pre></td></tr></table></figure><p>当尝试使用未定义或不再可用的对象时引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.NamespaceErr</span><br></pre></td></tr></table></figure><p>如果尝试<a href="https://www.w3.org/TR/REC-xml-names/" target="_blank" rel="noopener">以XML</a>建议中的<a href="https://www.w3.org/TR/REC-xml-names/" target="_blank" rel="noopener">名称空间</a>不允许的方式更改任何对象，则会引发此异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.NotFoundErr</span><br></pre></td></tr></table></figure><p>在引用的上下文中不存在节点时异常。 例如，如果传入的节点在地图中不存在，NamedNodeMap.removeNamedItem（）将引发此操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.NotSupportedErr</span><br></pre></td></tr></table></figure><p>当实现不支持请求类型的对象或操作时引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.NoDataAllowedErr</span><br></pre></td></tr></table></figure><p>如果为不支持数据的节点指定了数据，则会引发此问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.NoModificationAllowedErr</span><br></pre></td></tr></table></figure><p>引发尝试修改不允许修改的对象（例如对于只读节点）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.SyntaxErr</span><br></pre></td></tr></table></figure><p>当指定了无效或非法字符串时引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.WrongDocumentErr</span><br></pre></td></tr></table></figure><p>当节点插入到与当前所属不同的文档中时引发，并且实现不支持将节点从一个文档迁移到另一个文档。</p><p>DOM建议中定义的异常代码根据此表映射到上述异常：</p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">例外</th></tr></thead><tbody><tr><td style="text-align:left">DOMSTRING_SIZE_ERR</td><td style="text-align:left">DomstringSizeErr</td></tr><tr><td style="text-align:left">HIERARCHY_REQUEST_ERR</td><td style="text-align:left">HierarchyRequestErr</td></tr><tr><td style="text-align:left">INDEX_SIZE_ERR</td><td style="text-align:left">IndexSizeErr</td></tr><tr><td style="text-align:left">INUSE_ATTRIBUTE_ERR</td><td style="text-align:left">InuseAttributeErr</td></tr><tr><td style="text-align:left">INVALID_ACCESS_ERR</td><td style="text-align:left">InvalidAccessErr</td></tr><tr><td style="text-align:left">INVALID_CHARACTER_ERR</td><td style="text-align:left">InvalidCharacterErr</td></tr><tr><td style="text-align:left">INVALID_MODIFICATION_ERR</td><td style="text-align:left">InvalidModificationErr</td></tr><tr><td style="text-align:left">INVALID_STATE_ERR</td><td style="text-align:left">InvalidStateErr</td></tr><tr><td style="text-align:left">NAMESPACE_ERR</td><td style="text-align:left">NamespaceErr</td></tr><tr><td style="text-align:left">NOT_FOUND_ERR</td><td style="text-align:left">NotFoundErr</td></tr><tr><td style="text-align:left">NOT_SUPPORTED_ERR</td><td style="text-align:left">NotSupportedErr</td></tr><tr><td style="text-align:left">NO_DATA_ALLOWED_ERR</td><td style="text-align:left">NoDataAllowedErr</td></tr><tr><td style="text-align:left">NO_MODIFICATION_ALLOWED_ERR</td><td style="text-align:left">NoModificationAllowedErr</td></tr><tr><td style="text-align:left">SYNTAX_ERR</td><td style="text-align:left">SyntaxErr</td></tr><tr><td style="text-align:left">WRONG_DOCUMENT_ERR</td><td style="text-align:left">WrongDocumentErr</td></tr></tbody></table><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>本节介绍Python DOM API，W3C DOM推荐和Python的OMG IDL映射之间的一致性要求和关系。</p><h3 id="类型映射"><a href="#类型映射" class="headerlink" title="类型映射"></a>类型映射</h3><p>根据下表将DOM规范中使用的原始IDL类型映射到Python类型。</p><table><thead><tr><th style="text-align:left">IDL类型</th><th style="text-align:left">Python类型</th></tr></thead><tbody><tr><td style="text-align:left">布尔</td><td style="text-align:left">IntegerType（值为0或1）</td></tr><tr><td style="text-align:left">INT</td><td style="text-align:left">IntegerType</td></tr><tr><td style="text-align:left">长整型</td><td style="text-align:left">IntegerType</td></tr><tr><td style="text-align:left">无符号整数</td><td style="text-align:left">IntegerType</td></tr></tbody></table><p>此外，<code>DOMString</code>建议中定义的内容将映射到Python字符串或Unicode字符串。每当从DOM返回字符串时，应用程序应该能够处理Unicode。</p><p>IDL <code>null</code>值被映射到<code>None</code>，只要<code>null</code>API允许，该值可以被实现接受或提供。</p><h3 id="访问器方法"><a href="#访问器方法" class="headerlink" title="访问器方法"></a>访问器方法</h3><p>从OMG IDL到Python <code>attribute</code>的映射以Java映射的方式为IDL 声明定义访问器函数。映射IDL声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readonly attribute string someValue;</span><br><span class="line">         attribute string anotherValue;</span><br></pre></td></tr></table></figure><p>产生三种存取器函数：一个“获取”方法<code>someValue</code>（<code>_get_someValue()</code>），和“获取”和“设置”为方法<code>anotherValue</code>（<code>_get_anotherValue()</code>和<code>_set_anotherValue()</code>）。映射，尤其是不需要的IDL属性是访问正常的Python属性：<code>object.someValue</code>是<em>不是</em>工作需要，并且可能引发<code>AttributeError</code>。</p><p>但是，Python DOM API <em>确实</em>需要正常的属性访问。这意味着由Python IDL编译器生成的典型代理不可能工作，并且如果通过CORBA访问DOM对象，则可能需要在客户端上包装对象。虽然这确实需要对CORBA DOM客户端进行一些额外的考虑，但具有从Python使用DOM到CORBA的经验的实施者并不认为这是一个问题。所声明的属性<code>readonly</code>可能不会限制所有DOM实现中的写入访问。</p><p>在Python DOM API中，访问函数不是必需的。如果提供，它们应该采用由Python IDL映射定义的形式，但这些方法被认为是不必要的，因为可以直接从Python访问这些属性。不应该为<code>readonly</code>属性提供“设置”访问器。</p><p>IDL定义并未完全体现W3C DOM API的要求，例如某些对象的概念，如返回值为<code>getElementsByTagName()</code>“live”。Python DOM API不需要实现来执行这些需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-XML-dom-对象API&quot;&gt;&lt;a href=&quot;#python-标准库-XML-dom-对象API&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 XML dom 对象API&quot;&gt;&lt;/a&gt;python 标准库 XML dom 对象API&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200313_bravo.gif?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="xml" scheme="https://pinghailinfeng.gitee.io/tags/xml/"/>
    
      <category term="dom" scheme="https://pinghailinfeng.gitee.io/tags/dom/"/>
    
  </entry>
  
</feed>
