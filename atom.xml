<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凭海临风的IT江湖</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pinghailinfeng.gitee.io/"/>
  <updated>2020-01-20T06:29:02.081Z</updated>
  <id>https://pinghailinfeng.gitee.io/</id>
  
  <author>
    <name>Jeff Sui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python standard library sqlite3</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/20/python-standard-library-sqlite3/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/20/python-standard-library-sqlite3/</id>
    <published>2020-01-20T00:51:23.000Z</published>
    <updated>2020-01-20T06:29:02.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-sqlite3"><a href="#python-标准库-sqlite3" class="headerlink" title="python 标准库 sqlite3"></a>python 标准库 sqlite3</h1><p>今天是二十四节气的大寒</p><blockquote><p>大寒，是<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8D%81%E5%9B%9B%E8%8A%82%E6%B0%94/191597" target="_blank" rel="noopener">二十四节气</a>中的最后一个节气。斗指丑；太阳<a href="https://baike.baidu.com/item/%E9%BB%84%E7%BB%8F/8303112" target="_blank" rel="noopener">黄经</a>为300°；公历1月20－21日交节。同小寒一样，大寒也是表示天气寒冷程度的节气。在我国部分地区，大寒不如小寒冷，但在某些年份和沿海少数地方，全年最低气温仍然会出现在大寒节气内。小寒、大寒是一年中雨水最少的时段。</p><p>兹大寒一过，新一年的节气就又轮回来了，正所谓冬去春来。大寒虽然寒冷，但因为已近春天，所以不会像大雪到冬至期间那样酷寒。这时节，人们开始忙着除旧饰新、腌制年肴、准备年货和各种祭祀供品、扫尘洁物，因为中国人最重要的节日——春节就要到了。</p><p>每日一词：</p><p>Cold </p><p>adj 冷,寒冷</p><p>例句：</p><p>  It is the last one in January 20th of each year twenty-four solar term solar term, before and after the sun reaches 300 degrees for it”. It is cold weather, meaning extreme.</p><p> 大寒是二十四节气中最后一个节气，每年1月20日前后太阳到达黄经300°时为”大寒”。大寒，是天气寒冷到极点的意思。</p></blockquote><p><img src="http://photos.tuchong.com/350832/f/4959845.jpg" alt></p><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/sqlite3/" target="_blank" rel="noopener">Lib/sqlite3/</a></p><p>SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL 查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再迁移到更大的数据库，比如 PostgreSQL 或 Oracle。</p><p>sqlite3 模块由 Gerhard Häring 编写。它提供了符合 DB-API 2.0 规范的接口，这个规范是 <a href="https://www.python.org/dev/peps/pep-0249" target="_blank" rel="noopener"><strong>PEP 249</strong></a>。</p><p>要使用这个模块，必须先创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象，它代表数据库。下面例子中，数据将存储在 <code>example.db</code> 文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line">conn = sqlite3.connect(<span class="string">'example.db'</span>)</span><br></pre></td></tr></table></figure><p>你也可以使用 <code>:memory:</code> 来创建一个内存中的数据库</p><p>当有了 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象后，你可以创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 游标对象，然后调用它的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> 方法来执行 SQL 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">c = conn.cursor()</span><br><span class="line"></span><br><span class="line"># Create table</span><br><span class="line">c.execute(&apos;&apos;&apos;CREATE TABLE stocks</span><br><span class="line">             (date text, trans text, symbol text, qty real, price real)&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line"># Insert a row of data</span><br><span class="line">c.execute(&quot;INSERT INTO stocks VALUES (&apos;2006-01-05&apos;,&apos;BUY&apos;,&apos;RHAT&apos;,100,35.14)&quot;)</span><br><span class="line"></span><br><span class="line"># Save (commit) the changes</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"># We can also close the connection if we are done with it.</span><br><span class="line"># Just be sure any changes have been committed or they will be lost.</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><p>这些数据被持久化保存了，而且可以在之后的会话中使用它们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line">conn = sqlite3.connect(<span class="string">'example.db'</span>)</span><br><span class="line">c = conn.cursor()</span><br></pre></td></tr></table></figure><p>通常你的 SQL 操作需要使用一些 Python 变量的值。你不应该使用 Python 的字符串操作来创建你的查询语句，因为那样做不安全；它会使你的程序容易受到 SQL 注入攻击（在 <a href="https://xkcd.com/327/" target="_blank" rel="noopener">https://xkcd.com/327/</a> 上有一个搞笑的例子，看看有什么后果）</p><p>推荐另外一种方法：使用 DB-API 的参数替换。在你的 SQL 语句中，使用 <code>?</code> 占位符来代替值，然后把对应的值组成的元组做为 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> 方法的第二个参数。（其他数据库可能会使用不同的占位符，比如 <code>%s</code> 或者 <code>:1</code>）例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Never do this -- insecure!</span></span><br><span class="line">symbol = <span class="string">'RHAT'</span></span><br><span class="line">c.execute(<span class="string">"SELECT * FROM stocks WHERE symbol = '%s'"</span> % symbol)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Do this instead</span></span><br><span class="line">t = (<span class="string">'RHAT'</span>,)</span><br><span class="line">c.execute(<span class="string">'SELECT * FROM stocks WHERE symbol=?'</span>, t)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Larger example that inserts many records at a time</span></span><br><span class="line">purchases = [(<span class="string">'2006-03-28'</span>, <span class="string">'BUY'</span>, <span class="string">'IBM'</span>, <span class="number">1000</span>, <span class="number">45.00</span>),</span><br><span class="line">             (<span class="string">'2006-04-05'</span>, <span class="string">'BUY'</span>, <span class="string">'MSFT'</span>, <span class="number">1000</span>, <span class="number">72.00</span>),</span><br><span class="line">             (<span class="string">'2006-04-06'</span>, <span class="string">'SELL'</span>, <span class="string">'IBM'</span>, <span class="number">500</span>, <span class="number">53.00</span>),</span><br><span class="line">            ]</span><br><span class="line">c.executemany(<span class="string">'INSERT INTO stocks VALUES (?,?,?,?,?)'</span>, purchases)</span><br></pre></td></tr></table></figure><p>要在执行 SELECT 语句后获取数据，你可以把游标作为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a>，然后调用它的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.fetchone" target="_blank" rel="noopener"><code>fetchone()</code></a> 方法来获取一条匹配的行，也可以调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.fetchall" target="_blank" rel="noopener"><code>fetchall()</code></a> 来得到包含多个匹配行的列表。</p><p>下面是一个使用迭代器形式的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> c.execute(<span class="string">'SELECT * FROM stocks ORDER BY price'</span>):</span><br><span class="line">        print(row)</span><br><span class="line"></span><br><span class="line">(<span class="string">'2006-01-05'</span>, <span class="string">'BUY'</span>, <span class="string">'RHAT'</span>, <span class="number">100</span>, <span class="number">35.14</span>)</span><br><span class="line">(<span class="string">'2006-03-28'</span>, <span class="string">'BUY'</span>, <span class="string">'IBM'</span>, <span class="number">1000</span>, <span class="number">45.0</span>)</span><br><span class="line">(<span class="string">'2006-04-06'</span>, <span class="string">'SELL'</span>, <span class="string">'IBM'</span>, <span class="number">500</span>, <span class="number">53.0</span>)</span><br><span class="line">(<span class="string">'2006-04-05'</span>, <span class="string">'BUY'</span>, <span class="string">'MSFT'</span>, <span class="number">1000</span>, <span class="number">72.0</span>)</span><br></pre></td></tr></table></figure><h2 id="模块函数和常量"><a href="#模块函数和常量" class="headerlink" title="模块函数和常量"></a>模块函数和常量</h2><ul><li><code>sqlite3.version</code></li></ul><p>​       这个模块的版本号，是一个字符串。不是 SQLite 库的版本号。</p><ul><li><p><code>sqlite3.version_info</code></p><p>这个模块的版本号，是一个由整数组成的元组。不是 SQLite 库的版本号。</p></li><li><p><code>sqlite3.sqlite_version</code></p><p>使用中的 SQLite 库的版本号，是一个字符串。</p></li><li><p><code>sqlite3.sqlite_version_info</code></p><p>使用中的 SQLite 库的版本号，是一个整数组成的元组。</p></li><li><p><code>sqlite3.PARSE_DECLTYPES</code></p><p>这个常量可以作为 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.connect" target="_blank" rel="noopener"><code>connect()</code></a> 函数的 <em>detect_types</em> 参数。</p><p>设置这个参数后，<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块将解析它返回的每一列申明的类型。它会申明的类型的第一个单词，比如“integer primary key”，它会解析出“integer”，再比如“number(10)”，它会解析出“number”。然后，它会在转换器字典里查找那个类型注册的转换器函数，并调用它。</p></li><li><p><code>sqlite3.PARSE_COLNAMES</code></p></li><li><p><code>sqlite3.connect</code>(<em>database</em>[, <em>timeout</em>, <em>detect_types</em>, <em>isolation_level</em>, <em>check_same_thread</em>, <em>factory</em>, <em>cached_statements</em>, <em>uri</em>])</p></li></ul><p>连接 SQLite 数据库 <em>database</em>。默认返回 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象，除非使用了自定义的 <em>factory</em> 参数。</p><p><em>database</em> 是准备打开的数据库文件的路径（绝对路径或相对于当前目录的相对路径），它是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a>。你也可以用 <code>&quot;:memory:&quot;</code> 在内存中打开一个数据库。</p><p>当一个数据库被多个连接访问的时候，如果其中一个进程修改这个数据库，在这个事务提交之前，这个 SQLite 数据库将会被一直锁定。<em>timeout</em> 参数指定了这个连接等待锁释放的超时时间，超时之后会引发一个异常。这个超时时间默认是 5.0（5秒）。</p><p><em>isolation_level</em> 参数，请查看 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.isolation_level" target="_blank" rel="noopener"><code>isolation_level</code></a> 属性。</p><p>SQLite 原生只支持5种类型：TEXT，INTEGER，REAL，BLOB 和 NULL。如果你想用其它类型，你必须自己添加相应的支持。使用 <em>detect_types</em> 参数和模块级别的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.register_converter" target="_blank" rel="noopener"><code>register_converter()</code></a> 函数注册<strong>转换器</strong> 可以简单的实现。</p><p><em>detect_types</em> 默认为0（即关闭，没有类型检测）。你也可以组合 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.PARSE_DECLTYPES" target="_blank" rel="noopener"><code>PARSE_DECLTYPES</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.PARSE_COLNAMES" target="_blank" rel="noopener"><code>PARSE_COLNAMES</code></a> 来开启类型检测。</p><p>默认情况下，<em>check_same_thread</em> 为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>，只有当前的线程可以使用该连接。 如果设置为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>，则多个线程可以共享返回的连接。 当多个线程使用同一个连接的时候，用户应该把写操作进行序列化，以避免数据损坏。</p><p>默认情况下，当调用 connect 方法的时候，<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块使用了它的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 类。当然，你也可以创建 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 类的子类，然后创建提供了 <em>factory</em> 参数的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.connect" target="_blank" rel="noopener"><code>connect()</code></a> 方法。</p><p>详情请查阅当前手册的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3-types" target="_blank" rel="noopener">SQLite 与 Python 类型</a> 部分。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块在内部使用语句缓存来避免 SQL 解析开销。 如果要显式设置当前连接可以缓存的语句数，可以设置 <em>cached_statements</em> 参数。 当前实现的默认值是缓存100条语句。</p><p>如果 <em>uri</em> 为真，则 <em>database</em> 被解释为 URI。 它允许您指定选项。 例如，以只读模式打开数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db = sqlite3.connect(<span class="string">'file:path/to/database?mode=ro'</span>, uri=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>有关此功能的更多信息，包括已知选项的列表，可以在 <code>SQLite URI 文档 &lt;&lt;https://www.sqlite.org/uri.html&gt;&gt;</code>_ 中找到。</p><ul><li><p><code>sqlite3.register_converter</code>(<em>typename</em>, <em>callable</em>)</p><p>注册一个回调对象 <em>callable</em>, 用来转换数据库中的字节串为自定的 Python 类型。所有类型为 <em>typename</em> 的数据库的值在转换时，都会调用这个回调对象。通过指定 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.connect" target="_blank" rel="noopener"><code>connect()</code></a> 函数的 <em>detect-types</em> 参数来设置类型检测的方式。注意，<em>typename</em> 与查询语句中的类型名进行匹配时不区分大小写。</p></li><li><p><code>sqlite3.register_adapter</code>(<em>type</em>, <em>callable</em>)</p><p>注册一个回调对象 <em>callable</em>，用来转换自定义Python类型为一个 SQLite 支持的类型。 这个回调对象 <em>callable</em> 仅接受一个 Python 值作为参数，而且必须返回以下某个类型的值：int，float，str 或 bytes。</p></li><li><p><code>sqlite3.complete_statement</code>(<em>sql</em>)</p><p>如果字符串 <em>sql</em> 包含一个或多个完整的 SQL 语句（以分号结束）则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>。它不会验证 SQL 语法是否正确，仅会验证字符串字面上是否完整，以及是否以分号结束。</p><p>它可以用来构建一个 SQLite shell，下面是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A minimal SQLite shell for experiments</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.isolation_level = <span class="literal">None</span></span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">buffer = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Enter your SQL commands to execute in sqlite3."</span>)</span><br><span class="line">print(<span class="string">"Enter a blank line to exit."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = input()</span><br><span class="line">    <span class="keyword">if</span> line == <span class="string">""</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    buffer += line</span><br><span class="line">    <span class="keyword">if</span> sqlite3.complete_statement(buffer):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            buffer = buffer.strip()</span><br><span class="line">            cur.execute(buffer)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> buffer.lstrip().upper().startswith(<span class="string">"SELECT"</span>):</span><br><span class="line">                print(cur.fetchall())</span><br><span class="line">        <span class="keyword">except</span> sqlite3.Error <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">"An error occurred:"</span>, e.args[<span class="number">0</span>])</span><br><span class="line">        buffer = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p><code>sqlite3.enable_callback_tracebacks</code>(<em>flag</em>)</p><p>默认情况下，您不会获得任何用户定义函数中的回溯消息，比如聚合，转换器，授权器回调等。如果要调试它们，可以设置 <em>flag</em> 参数为 <code>True</code> 并调用此函数。 之后，回调中的回溯信息将会输出到 <code>sys.stderr</code>。 再次使用 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a> 来禁用该功能。</p><h2 id="连接对象（Connection）"><a href="#连接对象（Connection）" class="headerlink" title="连接对象（Connection）"></a>连接对象（Connection）</h2></li></ul><p><em>class</em> <code>sqlite3.Connection</code></p><p>SQLite 数据库连接对象有如下的属性和方法：</p><ul><li><p><code>isolation_level</code></p><p>获取或设置当前默认的隔离级别。 表示自动提交模式的 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 以及 “DEFERRED”, “IMMEDIATE” 或 “EXCLUSIVE” 其中之一。 详细描述请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3-controlling-transactions" target="_blank" rel="noopener">控制事务</a>。</p></li><li><p><code>in_transaction</code></p><p>如果是在活动事务中（还没有提交改变），返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>，否则，返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>。它是一个只读属性。<em>3.2 新版功能.</em></p></li><li><p><code>cursor</code>(<em>factory=Cursor</em>)</p><p>这个方法接受一个可选参数 <em>factory</em>，如果要指定这个参数，它必须是一个可调用对象，而且必须返回 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 类的一个实例或者子类。</p></li><li><p><code>commit</code>()</p><p>这个方法提交当前事务。如果没有调用这个方法，那么从上一次提交 <code>commit()</code> 以来所有的变化在其他数据库连接上都是不可见的。如果你往数据库里写了数据，但是又查询不到，请检查是否忘记了调用这个方法。</p></li><li><p><code>rollback</code>()</p><p>这个方法回滚从上一次调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.commit" target="_blank" rel="noopener"><code>commit()</code></a> 以来所有数据库的改变。</p></li><li><p><code>close</code>()</p><p>关闭数据库连接。注意，它不会自动调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.commit" target="_blank" rel="noopener"><code>commit()</code></a> 方法。如果在关闭数据库连接之前没有调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.commit" target="_blank" rel="noopener"><code>commit()</code></a>，那么你的修改将会丢失！</p></li><li><p><code>execute</code>(<em>sql</em>[, <em>parameters</em>])</p><p>这是一个非标准的快捷方法，它会调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.cursor" target="_blank" rel="noopener"><code>cursor()</code></a> 方法来创建一个游标对象，并使用给定的 <em>parameters</em> 参数来调用游标对象的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> 方法，最后返回这个游标对象。</p></li><li><p><code>executemany</code>(<em>sql</em>[, <em>parameters</em>])</p><p>这是一个非标准的快捷方法，它会调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.cursor" target="_blank" rel="noopener"><code>cursor()</code></a> 方法来创建一个游标对象，并使用给定的 <em>parameters</em> 参数来调用游标对象的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executemany" target="_blank" rel="noopener"><code>executemany()</code></a> 方法，最后返回这个游标对象。</p></li><li><p><code>executescript</code>(<em>sql_script</em>)</p><p>这是一个非标准的快捷方法，它会调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.cursor" target="_blank" rel="noopener"><code>cursor()</code></a> 方法来创建一个游标对象，并使用给定的 <em>sql_script</em> 参数来调用游标对象的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executescript" target="_blank" rel="noopener"><code>executescript()</code></a> 方法，最后返回这个游标对象。</p></li><li><p><code>create_function</code>(<em>name</em>, <em>num_params</em>, <em>func</em>, <em>**, </em>deterministic=False*)</p><p>创建一个可以在 SQL 语句中使用的用户自定义函数，函数名为 <em>name</em>。 <em>num_params</em> 为该函数所接受的形参个数（如果 <em>num_params</em> 为 -1，则该函数可接受任意数量的参数）， <em>func</em> 是一个 Python 可调用对象，它将作为 SQL 函数被调用。 如果 <em>deterministic</em> 为真值，则所创建的函数将被标记为 <a href="https://sqlite.org/deterministic.html" target="_blank" rel="noopener">deterministic</a>，这允许 SQLite 执行额外的优化。 此旗标在 SQLite 3.8.3 或更高版本中受到支持，如果在旧版本中使用将引发 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.NotSupportedError" target="_blank" rel="noopener"><code>NotSupportedError</code></a>。此函数可返回任何 SQLite 所支持的类型: bytes, str, int, float 和 <code>None</code>。<em>在 3.8 版更改:</em> 增加了 <em>deterministic</em> 形参。示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5sum</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(t).hexdigest()</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.create_function(<span class="string">"md5"</span>, <span class="number">1</span>, md5sum)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"select md5(?)"</span>, (<span class="string">b"foo"</span>,))</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p><code>create_aggregate</code>(<em>name</em>, <em>num_params</em>, <em>aggregate_class</em>)</p><p>创建一个自定义的聚合函数。</p><p>参数中 <em>aggregate_class</em> 类必须实现两个方法：<code>step</code> 和 <code>finalize</code>。<code>step</code> 方法接受 <em>num_params</em> 个参数（如果 <em>num_params</em> 为 -1，那么这个函数可以接受任意数量的参数）；<code>finalize</code> 方法返回最终的聚合结果。</p><p><code>finalize</code> 方法可以返回任何 SQLite 支持的类型：bytes，str，int，float 和 <code>None</code>。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySum</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.count += value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finalize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.create_aggregate(<span class="string">"mysum"</span>, <span class="number">1</span>, MySum)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(i)"</span>)</span><br><span class="line">cur.execute(<span class="string">"insert into test(i) values (1)"</span>)</span><br><span class="line">cur.execute(<span class="string">"insert into test(i) values (2)"</span>)</span><br><span class="line">cur.execute(<span class="string">"select mysum(i) from test"</span>)</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p><code>create_collation</code>(<em>name</em>, <em>callable</em>)</p><p>使用 <em>name</em> 和 <em>callable</em> 创建排序规则。这个 <em>callable</em> 接受两个字符串对象，如果第一个小于第二个则返回 -1， 如果两个相等则返回 0，如果第一个大于第二个则返回 1。注意，这是用来控制排序的（SQL 中的 ORDER BY），所以它不会影响其它的 SQL 操作。</p><p>注意，这个 <em>callable</em> 可调用对象会把它的参数作为 Python 字节串，通常会以 UTF-8 编码格式对它进行编码。</p><p>以下示例显示了使用“错误方式”进行排序的自定义排序规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collate_reverse</span><span class="params">(string1, string2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> string1 == string2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> string1 &lt; string2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.create_collation(<span class="string">"reverse"</span>, collate_reverse)</span><br><span class="line"></span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(x)"</span>)</span><br><span class="line">cur.executemany(<span class="string">"insert into test(x) values (?)"</span>, [(<span class="string">"a"</span>,), (<span class="string">"b"</span>,)])</span><br><span class="line">cur.execute(<span class="string">"select x from test order by x collate reverse"</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cur:</span><br><span class="line">    print(row)</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><p>要移除一个排序规则，需要调用 <code>create_collation</code> 并设置 callable 参数为 <code>None</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.create_collation(<span class="string">"reverse"</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><ul><li><p><code>interrupt</code>()</p><p>可以从不同的线程调用这个方法来终止所有查询操作，这些查询操作可能正在连接上执行。此方法调用之后， 查询将会终止，而且查询的调用者会获得一个异常。</p></li><li><p><code>set_authorizer</code>(<em>authorizer_callback</em>)</p><p>此方法注册一个授权回调对象。每次在访问数据库中某个表的某一列的时候，这个回调对象将会被调用。如果要允许访问，则返回 <code>SQLITE_OK</code>，如果要终止整个 SQL 语句，则返回 <code>SQLITE_DENY</code>，如果这一列需要当做 NULL 值处理，则返回 <code>SQLITE_IGNORE</code>。这些常量可以在 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块中找到。回调的第一个参数表示要授权的操作类型。 第二个和第三个参数将是参数或 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>，具体取决于第一个参数的值。 第 4 个参数是数据库的名称（“main”，“temp”等），如果需要的话。 第 5 个参数是负责访问尝试的最内层触发器或视图的名称，或者如果此访问尝试直接来自输入 SQL 代码，则为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。请参阅 SQLite 文档，了解第一个参数的可能值以及第二个和第三个参数的含义，具体取决于第一个参数。 所有必需的常量都可以在 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块中找到。</p></li><li><p><code>set_progress_handler</code>(<em>handler</em>, <em>n</em>)</p><p>此例程注册回调。 对SQLite虚拟机的每个多指令调用回调。 如果要在长时间运行的操作期间从SQLite调用（例如更新用户界面），这非常有用。如果要清除以前安装的任何进度处理程序，调用该方法时请将 <em>handler</em> 参数设置为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。从处理函数返回非零值将终止当前正在执行的查询并导致它引发 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.OperationalError" target="_blank" rel="noopener"><code>OperationalError</code></a> 异常。</p></li><li><p><code>set_trace_callback</code>(<em>trace_callback</em>)</p><p>为每个 SQLite 后端实际执行的 SQL 语句注册要调用的 <em>trace_callback</em>。传递给回调的唯一参数是正在执行的语句（作为字符串）。 回调的返回值将被忽略。 请注意，后端不仅运行传递给 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>Cursor.execute()</code></a> 方法的语句。 其他来源包括 Python 模块的事务管理和当前数据库中定义的触发器的执行。将传入的 <em>trace_callback</em> 设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 将禁用跟踪回调。</p></li><li><p><code>enable_load_extension</code>(<em>enabled</em>)</p><p>此例程允许/禁止SQLite引擎从共享库加载SQLite扩展。 SQLite扩展可以定义新功能，聚合或全新的虚拟表实现。 一个众所周知的扩展是与SQLite一起分发的全文搜索扩展。</p><p>默认情况下禁用可加载扩展。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable extension loading</span></span><br><span class="line">con.enable_load_extension(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the fulltext search extension</span></span><br><span class="line">con.execute(<span class="string">"select load_extension('./fts3.so')"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># alternatively you can load the extension using an API call:</span></span><br><span class="line"><span class="comment"># con.load_extension("./fts3.so")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># disable extension loading again</span></span><br><span class="line">con.enable_load_extension(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># example from SQLite wiki</span></span><br><span class="line">con.execute(<span class="string">"create virtual table recipe using fts3(name, ingredients)"</span>)</span><br><span class="line">con.executescript(<span class="string">"""</span></span><br><span class="line"><span class="string">    insert into recipe (name, ingredients) values ('broccoli stew', 'broccoli peppers cheese tomatoes');</span></span><br><span class="line"><span class="string">    insert into recipe (name, ingredients) values ('pumpkin stew', 'pumpkin onions garlic celery');</span></span><br><span class="line"><span class="string">    insert into recipe (name, ingredients) values ('broccoli pie', 'broccoli cheese onions flour');</span></span><br><span class="line"><span class="string">    insert into recipe (name, ingredients) values ('pumpkin pie', 'pumpkin sugar flour butter');</span></span><br><span class="line"><span class="string">    """</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> con.execute(<span class="string">"select rowid, name, ingredients from recipe where name match 'pie'"</span>):</span><br><span class="line">    print(row)</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p><code>load_extension</code>(<em>path</em>)</p><p>此例程从共享库加载SQLite扩展。 在使用此例程之前，必须使用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.enable_load_extension" target="_blank" rel="noopener"><code>enable_load_extension()</code></a> 启用扩展加载。</p><p>默认情况下禁用可加载扩展。</p></li><li><p>row_factory<br>您可以将此属性更改为可接受游标和原始行作为元组的可调用对象，并将返回实际结果行。 这样，您可以实现更高级的返回结果的方法，例如返回一个可以按名称访问列的对象。<br>示例:   </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict_factory</span><span class="params">(cursor, row)</span>:</span></span><br><span class="line">   d = &#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> idx, col <span class="keyword">in</span> enumerate(cursor.description):</span><br><span class="line">       d[col[<span class="number">0</span>]] = row[idx]</span><br><span class="line">   <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.row_factory = dict_factory</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"select 1 as a"</span>)</span><br><span class="line">print(cur.fetchone()[<span class="string">"a"</span>])</span><br><span class="line"></span><br><span class="line">  con.close()</span><br></pre></td></tr></table></figure><p>如果返回一个元组是不够的，并且你想要对列进行基于名称的访问，你应该考虑将 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.row_factory" target="_blank" rel="noopener"><code>row_factory</code></a> 设置为高度优化的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Row" target="_blank" rel="noopener"><code>sqlite3.Row</code></a> 类型。 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Row" target="_blank" rel="noopener"><code>Row</code></a> 提供基于索引和不区分大小写的基于名称的访问，几乎没有内存开销。 它可能比您自己的基于字典的自定义方法甚至基于 db_row 的解决方案更好。</p><ul><li><p><strong>text_factory</strong></p><p>使用此属性可以控制为 <code>TEXT</code> 数据类型返回的对象。 默认情况下，此属性设置为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块将返回 <code>TEXT</code> 的 Unicode 对象。 如果要返回字节串，可以将其设置为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>。</p><p>您还可以将其设置为接受单个 bytestring 参数的任何其他可调用对象，并返回结果对象。</p><p>请参阅以下示例代码以进行说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">AUSTRIA = <span class="string">"\xd6sterreich"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># by default, rows are returned as Unicode</span></span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (AUSTRIA,))</span><br><span class="line">row = cur.fetchone()</span><br><span class="line"><span class="keyword">assert</span> row[<span class="number">0</span>] == AUSTRIA</span><br><span class="line"></span><br><span class="line"><span class="comment"># but we can make sqlite3 always return bytestrings ...</span></span><br><span class="line">con.text_factory = bytes</span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (AUSTRIA,))</span><br><span class="line">row = cur.fetchone()</span><br><span class="line"><span class="keyword">assert</span> type(row[<span class="number">0</span>]) <span class="keyword">is</span> bytes</span><br><span class="line"><span class="comment"># the bytestrings will be encoded in UTF-8, unless you stored garbage in the</span></span><br><span class="line"><span class="comment"># database ...</span></span><br><span class="line"><span class="keyword">assert</span> row[<span class="number">0</span>] == AUSTRIA.encode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we can also implement a custom text_factory ...</span></span><br><span class="line"><span class="comment"># here we implement one that appends "foo" to all strings</span></span><br><span class="line">con.text_factory = <span class="keyword">lambda</span> x: x.decode(<span class="string">"utf-8"</span>) + <span class="string">"foo"</span></span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (<span class="string">"bar"</span>,))</span><br><span class="line">row = cur.fetchone()</span><br><span class="line"><span class="keyword">assert</span> row[<span class="number">0</span>] == <span class="string">"barfoo"</span></span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p>total_changes</p><p>返回自打开数据库连接以来已修改，插入或删除的数据库行的总数。</p></li><li><p><code>iterdump</code>()</p><p>返回以SQL文本格式转储数据库的迭代器。 保存内存数据库以便以后恢复时很有用。 此函数提供与 <strong>sqlite3</strong> shell 中的 .dump 命令相同的功能。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Convert file existing_db.db to SQL dump file dump.sql</span></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">'existing_db.db'</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dump.sql'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> con.iterdump():</span><br><span class="line">        f.write(<span class="string">'%s\n'</span> % line)</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>backup</code>(<em>target</em>, <em>**, </em>pages=0<em>, </em>progress=None<em>, </em>name=”main”<em>, </em>sleep=0.250*)</p><p>即使在 SQLite 数据库被其他客户端访问时，或者同时由同一连接访问，该方法也会对其进行备份。 该副本将写入强制参数 <em>target</em>，该参数必须是另一个 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 实例。</p><p>默认情况下，或者当 <em>pages</em> 为 <code>0</code> 或负整数时，整个数据库将在一个步骤中复制；否则该方法一次循环复制 <em>pages</em> 规定数量的页面。</p><p>示例一，将现有数据库复制到另一个数据库中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">progress</span><span class="params">(status, remaining, total)</span>:</span></span><br><span class="line">    print(<span class="string">f'Copied <span class="subst">&#123;total-remaining&#125;</span> of <span class="subst">&#123;total&#125;</span> pages...'</span>)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">'existing_db.db'</span>)</span><br><span class="line">bck = sqlite3.connect(<span class="string">'backup.db'</span>)</span><br><span class="line"><span class="keyword">with</span> bck:</span><br><span class="line">    con.backup(bck, pages=<span class="number">1</span>, progress=progress)</span><br><span class="line">bck.close()</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p>示例二，将现有数据库复制到临时副本中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">source = sqlite3.connect(<span class="string">'existing_db.db'</span>)</span><br><span class="line">dest = sqlite3.connect(<span class="string">':memory:'</span>)</span><br><span class="line">source.backup(dest)</span><br></pre></td></tr></table></figure><p>可用性：SQLite 3.6.11 或以上版本</p></li></ul><h2 id="Cursor-对象"><a href="#Cursor-对象" class="headerlink" title="Cursor 对象"></a>Cursor 对象</h2><ul><li><p><em>class</em> <code>sqlite3.Cursor</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 游标实例具有以下属性和方法。</p><ul><li><p><code>execute</code>(<em>sql</em>[, <em>parameters</em>])</p><p>执行SQL语句。 可以是参数化 SQL 语句（即，在 SQL 语句中使用占位符）。<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块支持两种占位符：问号（qmark风格）和命名占位符（命名风格）。以下是两种风格的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table people (name_last, age)"</span>)</span><br><span class="line"></span><br><span class="line">who = <span class="string">"Yeltsin"</span></span><br><span class="line">age = <span class="number">72</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is the qmark style:</span></span><br><span class="line">cur.execute(<span class="string">"insert into people values (?, ?)"</span>, (who, age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># And this is the named style:</span></span><br><span class="line">cur.execute(<span class="string">"select * from people where name_last=:who and age=:age"</span>, &#123;<span class="string">"who"</span>: who, <span class="string">"age"</span>: age&#125;)</span><br><span class="line"></span><br><span class="line">print(cur.fetchone())</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> will only execute a single SQL statement. If you try to execute more than one statement with it, it will raise a <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Warning" target="_blank" rel="noopener"><code>Warning</code></a>. Use <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executescript" target="_blank" rel="noopener"><code>executescript()</code></a> if you want to execute multiple SQL statements with one call.</p></li></ul></li><li><p><code>executemany</code>(<em>sql</em>, <em>seq_of_parameters</em>)</p><p>通过所有参数序列或者映射参数 执行SQL 命令,同时支持使用<code>iterator</code>(可迭代对象) yield类型生成参数代替序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IterChars</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = ord(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.count &gt; ord(<span class="string">'z'</span>):</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (chr(self.count - <span class="number">1</span>),) <span class="comment"># this is a 1-tuple</span></span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table characters(c)"</span>)</span><br><span class="line"></span><br><span class="line">theIter = IterChars()</span><br><span class="line">cur.executemany(<span class="string">"insert into characters(c) values (?)"</span>, theIter)</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"select c from characters"</span>)</span><br><span class="line">print(cur.fetchall())</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><p>这是一个使用生成器 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 的简短示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">char_generator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> string.ascii_lowercase:</span><br><span class="line">        <span class="keyword">yield</span> (c,)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table characters(c)"</span>)</span><br><span class="line"></span><br><span class="line">cur.executemany(<span class="string">"insert into characters(c) values (?)"</span>, char_generator())</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"select c from characters"</span>)</span><br><span class="line">print(cur.fetchall())</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p><code>executescript</code>(<em>sql_script</em>)</p><p>这是一个非标准方式执行sql语句的方法,它首先执行<code>COMMIT</code>语句,然后执行作为参数传递而来的SQL语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.executescript(<span class="string">"""</span></span><br><span class="line"><span class="string">    create table person(</span></span><br><span class="line"><span class="string">        firstname,</span></span><br><span class="line"><span class="string">        lastname,</span></span><br><span class="line"><span class="string">        age</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    create table book(</span></span><br><span class="line"><span class="string">        title,</span></span><br><span class="line"><span class="string">        author,</span></span><br><span class="line"><span class="string">        published</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    insert into book(title, author, published)</span></span><br><span class="line"><span class="string">    values (</span></span><br><span class="line"><span class="string">        'Dirk Gently''s Holistic Detective Agency',</span></span><br><span class="line"><span class="string">        'Douglas Adams',</span></span><br><span class="line"><span class="string">        1987</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">    """</span>)</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p><code>fetchone</code>()</p><p>获取查询语句结果中的一条记录集,返回一个单独的序列,当没有数据时返回<code>None</code>。</p></li><li><p><code>fetchmany</code>(<em>size=cursor.arraysize</em>)</p><p>提取查询结果的下一组行，返回列表。当没有更多行可用时，将返回一个空列表。每个调用要提取的行数由 [size] 参数指定。如果未提供，则游标的数组大小确定要提取的行数。该方法应尝试提取大小参数指示的行数。如果由于指定的行数不可用而无法这样做，则返回的行数可能更少。请注意，[size] 参数涉及性能注意事项。为了获得最佳性能，通常最好使用数组大小属性。如果使用 [size] 参数，则最好将其保留从<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.fetchmany" target="_blank" rel="noopener"><code>fetchmany()</code></a> 方法调用到下一个相同的值。</p></li></ul><p>​        返回list类型存储的所有结果的行。如果没有记录返回,返回一个空的list。</p><ul><li><p><code>close</code>()</p><p>立即关闭游标(无论<code>__del__</code>方法是否被调用)。当前游标无法再获取上下文对象,如果尝试访问该游标,则会引发<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.ProgrammingError" target="_blank" rel="noopener"><code>ProgrammingError</code></a> 异常。</p></li><li><p><code>rowcount</code></p><p>对于  <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executemany" target="_blank" rel="noopener"><code>executemany()</code></a> 语句，修改次数汇总为 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.rowcount" target="_blank" rel="noopener"><code>rowcount</code></a>.根据 Python DB API 规范的要求，<code>rowcount</code> 属性在游标上未执行<code>executeXX()</code>或最后一个操作的行计数无法由接口决定的情况下为 -1。这包括<code>SELECT</code>语句，因为我们无法确定在提取所有行之前生成的查询的行数。</p></li><li><p><code>lastrowid</code></p><p>这是一个只读属性取得最后一条修改记录的rowid。仅当使用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> 方法执行<code>INSERT</code> or a <code>REPLACE</code> 语句时设置该属性。或者 当执行<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executemany" target="_blank" rel="noopener"><code>executemany()</code></a> 方法时,该属性设置为<code>None</code>。如果<code>INSERT</code> 或 <code>REPLACE</code> 语句执行失败时,则返回最近一次成功执行的rowid。</p></li><li><p><code>arraysize</code></p><p>该属性可读写,主要控制 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.fetchmany" target="_blank" rel="noopener"><code>fetchmany()</code></a>方法返回的记录数量。默认值是1意味着返回一行结果。</p></li><li><p><code>description</code></p><p>此只读属性提供最后一次查询的列名称。为了保持与 Python DB API 的兼容，它为每个列返回一个 7 元组，其中每个元组的最后六个项为 <code>None</code>.</p></li><li><p><code>connection</code></p><p>此只读属性提供SQLite数据库的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 使用的游标对象。</p></li></ul><h2 id="行对象"><a href="#行对象" class="headerlink" title="行对象"></a>行对象</h2><p><em>class</em> <code>sqlite3.Row</code></p><ul><li><p><code>keys</code>()</p><p>该方法返回列名构成的列表。查询后,在 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.description" target="_blank" rel="noopener"><code>Cursor.description</code></a> 中元组数据的第一个元素.</p></li></ul><p>接下来我们在上面的例子中初始化一个table：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">conn = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">c = conn.cursor()</span><br><span class="line">c.execute(<span class="string">'''create table stocks</span></span><br><span class="line"><span class="string">(date text, trans text, symbol text,</span></span><br><span class="line"><span class="string"> qty real, price real)'''</span>)</span><br><span class="line">c.execute(<span class="string">"""insert into stocks</span></span><br><span class="line"><span class="string">          values ('2006-01-05','BUY','RHAT',100,35.14)"""</span>)</span><br><span class="line">conn.commit()</span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure><p>我们使用<code>Row</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.row_factory = sqlite3.Row</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = conn.cursor()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.execute(<span class="string">'select * from stocks'</span>)</span><br><span class="line">&lt;sqlite3.Cursor object at <span class="number">0x7f4e7dd8fa80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = c.fetchone()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(r)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">sqlite3</span>.<span class="title">Row</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">tuple</span><span class="params">(r)</span></span></span><br><span class="line"><span class="class"><span class="params">(<span class="string">'2006-01-05'</span>, <span class="string">'BUY'</span>, <span class="string">'RHAT'</span>, <span class="number">100.0</span>, <span class="number">35.14</span>)</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">len</span><span class="params">(r)</span></span></span><br><span class="line"><span class="class">5</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">r</span>[2]</span></span><br><span class="line"><span class="class">'<span class="title">RHAT</span>'</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">r</span>.<span class="title">keys</span><span class="params">()</span></span></span><br><span class="line">['date', 'trans', 'symbol', 'qty', 'price']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r[<span class="string">'qty'</span>]</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> member <span class="keyword">in</span> r:</span><br><span class="line"><span class="meta">... </span>    print(member)</span><br><span class="line">...</span><br><span class="line"><span class="number">2006</span><span class="number">-01</span><span class="number">-05</span></span><br><span class="line">BUY</span><br><span class="line">RHAT</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="number">35.14</span></span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><p><em>exception</em> <code>sqlite3.Warning</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>sqlite3.Error</code></p><p>此模块中其他异常的基类。 它是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>sqlite3.DatabaseError</code></p><p>抛出和数据库有关异常。</p></li><li><p><em>exception</em> <code>sqlite3.IntegrityError</code></p><p>抛出和关联标识符有关异常,例如外键检查失败,是<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.DatabaseError" target="_blank" rel="noopener"><code>DatabaseError</code></a>的一个子类。</p></li><li><p><em>exception</em> <code>sqlite3.ProgrammingError</code></p><p>抛出和程序有关的异常,例如：table未找到,或已经存在,SQL 语句异常,参数不正确, 是<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.DatabaseError" target="_blank" rel="noopener"><code>DatabaseError</code></a>的一个子类。</p></li><li><p><em>exception</em> <code>sqlite3.OperationalError</code></p><p>抛出和程序无法控制的数据库操作的异常,例如: 不可预料的数据库连接错误,数据源名字未找到,事务没有被执行,是<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.DatabaseError" target="_blank" rel="noopener"><code>DatabaseError</code></a>的一个子类。</p></li><li><p><em>exception</em> <code>sqlite3.NotSupportedError</code></p><p>抛出当一个方法对当前数据库不支持的异常,例如:调用 <code>rollback()</code>时,数据库事务不支持或者事务被关闭。是<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.DatabaseError" target="_blank" rel="noopener"><code>DatabaseError</code></a>的一个子类</p></li></ul><h2 id="SQLite-与-Python-类型"><a href="#SQLite-与-Python-类型" class="headerlink" title="SQLite 与 Python 类型"></a>SQLite 与 Python 类型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>SQLite 原生支持如下的类型： <code>NULL</code>，<code>INTEGER</code>，<code>REAL</code>，<code>TEXT</code>，<code>BLOB</code>。</p><table><thead><tr><th>Python 类型</th><th>SQLite 类型</th></tr></thead><tbody><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a></td><td><code>NULL</code></td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a></td><td><code>INTEGER</code></td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a></td><td><code>REAL</code></td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a></td><td><code>TEXT</code></td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a></td><td><code>BLOB</code></td></tr></tbody></table><p>这是SQLite类型默认转换为Python类型的方式：</p><table><thead><tr><th>SQLite 类型</th><th>Python 类型</th></tr></thead><tbody><tr><td><code>NULL</code></td><td><a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a></td></tr><tr><td><code>INTEGER</code></td><td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a></td></tr><tr><td><code>REAL</code></td><td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a></td></tr><tr><td><code>TEXT</code></td><td>取决于 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.text_factory" target="_blank" rel="noopener"><code>text_factory</code></a> , 默认为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a></td></tr><tr><td><code>BLOB</code></td><td><a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a></td></tr></tbody></table><p> <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 中数据类型的扩展有两种途径: 一种是使用SQLite对象适配器扩展附加的Python数据类型；另一种是使用Python类型转换函数转换SQLite类型。</p><h3 id="使用适配器在SQLite中存储附加的python数据类型"><a href="#使用适配器在SQLite中存储附加的python数据类型" class="headerlink" title="使用适配器在SQLite中存储附加的python数据类型"></a>使用适配器在SQLite中存储附加的python数据类型</h3><p>正如之前描述的转换方法中说明的,SQLite只支持有限的几种数据类型。如果想在SQLite中使用Python的相关数据类型,你必须通过适配器,让SQLite的模块让SQLite支持诸如:  one of NoneType, int, float, str, bytes等类型。请看下面的例子:</p><h4 id="让对象自行调整"><a href="#让对象自行调整" class="headerlink" title="让对象自行调整"></a>让对象自行调整</h4><p>如果自己编写类，这是一种很好的方法。假设有这样的类：：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x, self.y = x, y</span><br></pre></td></tr></table></figure><p>我们想在SQLite中存储,首先选择何种数据类型存储这个<code>Point</code>类。</p><p>接下来使用类方法 <code>__conform__</code>返回转换后的值, 参数是 <code>PrepareProtocol</code>类型的<code>protocol</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__conform__</span><span class="params">(self, protocol)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> protocol <span class="keyword">is</span> sqlite3.PrepareProtocol:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"%f;%f"</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">4.0</span>, <span class="number">-3.2</span>)</span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (p,))</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><h4 id="注册可调用的适配器"><a href="#注册可调用的适配器" class="headerlink" title="注册可调用的适配器"></a>注册可调用的适配器</h4><p>另一个可行的方法时创建一个可以转换string和其他类型的函数,使用<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.register_adapter" target="_blank" rel="noopener"><code>register_adapter()</code></a>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adapt_point</span><span class="params">(point)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"%f;%f"</span> % (point.x, point.y)</span><br><span class="line"></span><br><span class="line">sqlite3.register_adapter(Point, adapt_point)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">4.0</span>, <span class="number">-3.2</span>)</span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (p,))</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><p>对于Python中的内置数据类型 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.datetime" target="_blank" rel="noopener"><code>datetime.datetime</code></a> ,我们可以存储 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.datetime" target="_blank" rel="noopener"><code>datetime.datetime</code></a> 使用ISO 实现而非 Unix 时间戳。请参考下面的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adapt_datetime</span><span class="params">(ts)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> time.mktime(ts.timetuple())</span><br><span class="line"></span><br><span class="line">sqlite3.register_adapter(datetime.datetime, adapt_datetime)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (now,))</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><h3 id="将SQLite-值转换为自定义Python-类型"><a href="#将SQLite-值转换为自定义Python-类型" class="headerlink" title="将SQLite 值转换为自定义Python 类型"></a>将SQLite 值转换为自定义Python 类型</h3><p>让我们回到刚才定义的<code>Point</code> 类,在SQLite中存储<code>x</code>,<code>y</code>字符串类型参数。</p><p>首先我们定义一个转换函数,接收字符串类型的参数,转换为<code>Point</code>类的对象。</p><blockquote><p>转换函数通常处理的是<code>byte</code>类型对象,无论你传入的是什么类型 数据。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_point</span><span class="params">(s)</span>:</span></span><br><span class="line">    x, y = map(float, s.split(<span class="string">b";"</span>))</span><br><span class="line">    <span class="keyword">return</span> Point(x, y)</span><br></pre></td></tr></table></figure><p>现在我们需要让 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块知道你查询的是一个<code>point</code>对象，有两种方式实现:</p><ul><li>隐式的声明类型</li><li>显式的通过列名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"(%f;%f)"</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adapt_point</span><span class="params">(point)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"%f;%f"</span> % (point.x, point.y)).encode(<span class="string">'ascii'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_point</span><span class="params">(s)</span>:</span></span><br><span class="line">    x, y = list(map(float, s.split(<span class="string">b";"</span>)))</span><br><span class="line">    <span class="keyword">return</span> Point(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register the adapter</span></span><br><span class="line">sqlite3.register_adapter(Point, adapt_point)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register the converter</span></span><br><span class="line">sqlite3.register_converter(<span class="string">"point"</span>, convert_point)</span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">4.0</span>, <span class="number">-3.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#########################</span></span><br><span class="line"><span class="comment"># 1) Using declared types</span></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>, detect_types=sqlite3.PARSE_DECLTYPES)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(p point)"</span>)</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"insert into test(p) values (?)"</span>, (p,))</span><br><span class="line">cur.execute(<span class="string">"select p from test"</span>)</span><br><span class="line">print(<span class="string">"with declared types:"</span>, cur.fetchone()[<span class="number">0</span>])</span><br><span class="line">cur.close()</span><br><span class="line">con.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################</span></span><br><span class="line"><span class="comment"># 1) Using column names</span></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>, detect_types=sqlite3.PARSE_COLNAMES)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(p)"</span>)</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"insert into test(p) values (?)"</span>, (p,))</span><br><span class="line">cur.execute(<span class="string">'select p as "p [point]" from test'</span>)</span><br><span class="line">print(<span class="string">"with column names:"</span>, cur.fetchone()[<span class="number">0</span>])</span><br><span class="line">cur.close()</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><h3 id="默认适配器和转换器"><a href="#默认适配器和转换器" class="headerlink" title="默认适配器和转换器"></a>默认适配器和转换器</h3><p>对于时间和 日期时间类型, sqlite模块已经做了自动转换。</p><p>下面的示例演示了这一点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>, detect_types=sqlite3.PARSE_DECLTYPES|sqlite3.PARSE_COLNAMES)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(d date, ts timestamp)"</span>)</span><br><span class="line"></span><br><span class="line">today = datetime.date.today()</span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"insert into test(d, ts) values (?, ?)"</span>, (today, now))</span><br><span class="line">cur.execute(<span class="string">"select d, ts from test"</span>)</span><br><span class="line">row = cur.fetchone()</span><br><span class="line">print(today, <span class="string">"=&gt;"</span>, row[<span class="number">0</span>], type(row[<span class="number">0</span>]))</span><br><span class="line">print(now, <span class="string">"=&gt;"</span>, row[<span class="number">1</span>], type(row[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">'select current_date as "d [date]", current_timestamp as "ts [timestamp]"'</span>)</span><br><span class="line">row = cur.fetchone()</span><br><span class="line">print(<span class="string">"current_date"</span>, row[<span class="number">0</span>], type(row[<span class="number">0</span>]))</span><br><span class="line">print(<span class="string">"current_timestamp"</span>, row[<span class="number">1</span>], type(row[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><h2 id="控制事务"><a href="#控制事务" class="headerlink" title="控制事务"></a>控制事务</h2><p>默认<code>sqlite3</code>中对于<code>autocommit</code> 默认是开启的,但是Python中的<code>sqlite3</code>模块默认并没有开启。</p><p><code>autocommit</code> 模式意味着当修改数据库时对数据库影响立即生效。一个<code>BEGIN</code> 和 <code>SAVEPOINT</code>的语句禁止<code>automode</code>,如果是<code>COMMIT</code>，<code>ROLLBACK</code> 或<code>RELASE</code> 语句执行后,<code>autocommit</code>模式才设置成启用。</p><p>Python  <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a>  默认在DDL 语句( (例如: <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>/<code>REPLACE</code>).)执行前执行<code>BEGIN</code> 语句。</p><p>你可以通过控制 <code>BEGIN</code> 语句,隐式执行<code>connect()</code>方法的 <em>isolation_level</em> 参数,或是connections的 <em>isolation_level</em> 属性来实现。如果你没有声明 isolation_level,那么使用的就是普通的<code>BEGIN</code>使用,和<code>DEFERRED</code>是一样的。其他可能的值还有<code>IMMEDIATE</code> 和 <code>EXCLUSIVE</code>。</p><p>你可以在代码中通过禁止 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块中设定 control the transaction state 的值为<code>BEGIN</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code>, and <code>RELEASE</code> 语句实现事务处理。</p><h2 id="有效使用-sqlite3"><a href="#有效使用-sqlite3" class="headerlink" title="有效使用 sqlite3"></a>有效使用 <code>sqlite3</code></h2><h3 id="使用快捷方式"><a href="#使用快捷方式" class="headerlink" title="使用快捷方式"></a>使用快捷方式</h3><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象的非标准 <code>execute()</code>, <code>executemany()</code> 和 <code>executescript()</code> 方法，可以更简洁地编写代码，因为不必显式创建（通常是多余的） <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 对象。相反， <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 对象是隐式创建的，这些快捷方法返回游标对象。这样，只需对 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象调用一次，就能直接执行 <code>SELECT</code> 语句并遍历对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">persons = [</span><br><span class="line">    (<span class="string">"Hugo"</span>, <span class="string">"Boss"</span>),</span><br><span class="line">    (<span class="string">"Calvin"</span>, <span class="string">"Klein"</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the table</span></span><br><span class="line">con.execute(<span class="string">"create table person(firstname, lastname)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the table</span></span><br><span class="line">con.executemany(<span class="string">"insert into person(firstname, lastname) values (?, ?)"</span>, persons)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the table contents</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> con.execute(<span class="string">"select firstname, lastname from person"</span>):</span><br><span class="line">    print(row)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"I just deleted"</span>, con.execute(<span class="string">"delete from person"</span>).rowcount, <span class="string">"rows"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># close is not a shortcut method and it's not called automatically,</span></span><br><span class="line"><span class="comment"># so the connection object should be closed manually</span></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><h3 id="通过名称而不是索引访问索引"><a href="#通过名称而不是索引访问索引" class="headerlink" title="通过名称而不是索引访问索引"></a>通过名称而不是索引访问索引</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块的一个有用功能是内置的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Row" target="_blank" rel="noopener"><code>sqlite3.Row</code></a> 类，该类旨在用作行工厂。</p><p>该类的行装饰器可以用索引（如元组）和不区分大小写的名称访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.row_factory = sqlite3.Row</span><br><span class="line"></span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"select 'John' as name, 42 as age"</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cur:</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="number">0</span>] == row[<span class="string">"name"</span>]</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="string">"name"</span>] == row[<span class="string">"nAmE"</span>]</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="number">1</span>] == row[<span class="string">"age"</span>]</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="number">1</span>] == row[<span class="string">"AgE"</span>]</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><h3 id="使用连接作为上下文管理器"><a href="#使用连接作为上下文管理器" class="headerlink" title="使用连接作为上下文管理器"></a>使用连接作为上下文管理器</h3><p>连接对象可以用来作为上下文管理器，它可以自动提交或者回滚事务。如果出现异常，事务会被回滚；否则，事务会被提交。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.execute(<span class="string">"create table person (id integer primary key, firstname varchar unique)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Successful, con.commit() is called automatically afterwards</span></span><br><span class="line"><span class="keyword">with</span> con:</span><br><span class="line">    con.execute(<span class="string">"insert into person(firstname) values (?)"</span>, (<span class="string">"Joe"</span>,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># con.rollback() is called after the with block finishes with an exception, the</span></span><br><span class="line"><span class="comment"># exception is still raised and must be caught</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> con:</span><br><span class="line">        con.execute(<span class="string">"insert into person(firstname) values (?)"</span>, (<span class="string">"Joe"</span>,))</span><br><span class="line"><span class="keyword">except</span> sqlite3.IntegrityError:</span><br><span class="line">    print(<span class="string">"couldn't add Joe twice"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connection object used as context manager only commits or rollbacks transactions,</span></span><br><span class="line"><span class="comment"># so the connection object should be closed manually</span></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>较老版本的 SQLite 在共享线程之间存在连接问题。这就是Python模块不允许线程之间共享连接和游标的原因。如果仍然尝试这样做，则在运行时会出现异常。</p><p>唯一的例外是调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.interrupt" target="_blank" rel="noopener"><code>interrupt()</code></a> 方法，该方法仅在从其他线程进行调用时才有意义。</p><h2 id="关于事务的补充说明"><a href="#关于事务的补充说明" class="headerlink" title="关于事务的补充说明"></a>关于事务的补充说明</h2><p><code>isolation_level</code> 到底控制的是什么,下图摘自SQLite官网。</p><p><img src="http://static.oschina.net/uploads/img/201607/27151258_jtqf.gif" alt></p><p>下面是一个在connect()中不传入 isolation_level的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">'''sqlite3事务总结:</span></span><br><span class="line"><span class="string">在connect()中不传入 isolation_level</span></span><br><span class="line"><span class="string">事务处理:</span></span><br><span class="line"><span class="string">    使用connection.commit()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">分析:</span></span><br><span class="line"><span class="string">    智能commit状态:</span></span><br><span class="line"><span class="string">        生成方式: 在connect()中不传入 isolation_level, 此时isolation_level==''</span></span><br><span class="line"><span class="string">            在进行 执行Data Modification Language (DML) 操作(INSERT/UPDATE/DELETE/REPLACE)时, 会自动打开一个事务,</span></span><br><span class="line"><span class="string">            在执行 非DML, 非query (非 SELECT 和上面提到的)语句时, 会隐式执行commit</span></span><br><span class="line"><span class="string">            可以使用 connection.commit()方法来进行提交</span></span><br><span class="line"><span class="string">        注意:</span></span><br><span class="line"><span class="string">            不能和cur.execute("COMMIT")共用</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    自动commit状态:</span></span><br><span class="line"><span class="string">        生成方式: 在connect()中传入 isolation_level=None</span></span><br><span class="line"><span class="string">            这样,在任何DML操作时,都会自动提交</span></span><br><span class="line"><span class="string">        事务处理</span></span><br><span class="line"><span class="string">            connection.execute("BEGIN TRANSACTION")</span></span><br><span class="line"><span class="string">            connection.execute("COMMIT")</span></span><br><span class="line"><span class="string">        如果不使用事务, 批量添加数据非常缓慢</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数据对比:</span></span><br><span class="line"><span class="string">    两种方式, 事务耗时差别不大</span></span><br><span class="line"><span class="string">    count = 100000</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.621</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.601</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.588</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.581</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.598</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.588</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.589</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.602</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.588</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.622</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elapse_time</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''耗时统计工具'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, prompt=<span class="string">''</span>)</span>:</span></span><br><span class="line">        self.prompt = prompt</span><br><span class="line">        self.start = time.time()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s耗时: %.3f'</span> % (self.prompt, time.time() - self.start))</span><br><span class="line">CElapseTime = Elapse_time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">'e:/temp/a.db'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepare</span><span class="params">(isolation_level = <span class="string">''</span>)</span>:</span></span><br><span class="line">    connection = sqlite3.connect(filename, isolation_level = isolation_level)</span><br><span class="line">    connection.execute(<span class="string">"create table IF NOT EXISTS  people (num, age)"</span>)</span><br><span class="line">    connection.execute(<span class="string">'delete from people'</span>)</span><br><span class="line">    connection.commit()</span><br><span class="line">    <span class="keyword">return</span> connection, connection.cursor()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db_insert_values</span><span class="params">(cursor, count)</span>:</span></span><br><span class="line">    num = <span class="number">1</span> </span><br><span class="line">    age = <span class="number">2</span> * num </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> num &lt;= count:</span><br><span class="line">        cursor.execute(<span class="string">"insert into people values (?, ?)"</span>, (num, age))</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        age = <span class="number">2</span> * num </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">study_case1_intelligent_commit</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    在智能commit状态下, 不能和cur.execute("COMMIT")共用</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    connection, cursor = prepare()</span><br><span class="line">    </span><br><span class="line">    elapse_time = Elapse_time(<span class="string">'  智能commit'</span>)</span><br><span class="line">    db_insert_values(cursor, count)</span><br><span class="line">    <span class="comment">#cursor.execute("COMMIT")  #产生异常</span></span><br><span class="line">    </span><br><span class="line">    cursor.execute(<span class="string">"select count(*) from people"</span>)</span><br><span class="line">    <span class="keyword">print</span> (cursor.fetchone())</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">study_case2_autocommit</span><span class="params">(count)</span>:</span></span><br><span class="line">    connection, cursor = prepare(isolation_level = <span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    elapse_time = Elapse_time(<span class="string">'  自动commit'</span>)</span><br><span class="line">    db_insert_values(cursor, count)</span><br><span class="line">    </span><br><span class="line">    cursor.execute(<span class="string">"select count(*) from people"</span>)    </span><br><span class="line">    <span class="keyword">print</span> (cursor.fetchone())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">study_case3_intelligent_commit_manual</span><span class="params">(count)</span>:</span></span><br><span class="line">    connection, cursor = prepare()</span><br><span class="line">    </span><br><span class="line">    elapse_time = Elapse_time(<span class="string">'  智能commit即时提交'</span>)</span><br><span class="line">    db_insert_values(cursor, count)</span><br><span class="line">    connection.commit()</span><br><span class="line">    </span><br><span class="line">    cursor.execute(<span class="string">"select count(*) from people"</span>)</span><br><span class="line">    <span class="keyword">print</span> (cursor.fetchone())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">study_case4_autocommit_transaction</span><span class="params">(count)</span>:</span></span><br><span class="line">    connection, cursor = prepare(isolation_level = <span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    elapse_time = Elapse_time(<span class="string">'  自动commit'</span>)</span><br><span class="line">    connection.execute(<span class="string">"BEGIN TRANSACTION;"</span>) <span class="comment"># 关键点</span></span><br><span class="line">    db_insert_values(cursor, count)</span><br><span class="line">    connection.execute(<span class="string">"COMMIT;"</span>)  <span class="comment">#关键点</span></span><br><span class="line">    </span><br><span class="line">    cursor.execute(<span class="string">"select count(*) from people;"</span>)</span><br><span class="line">    <span class="keyword">print</span> (cursor.fetchone())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    count = <span class="number">10000</span></span><br><span class="line">    prepare()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="comment">#study_case1_intelligent_commit(count) #不提交数据</span></span><br><span class="line">        <span class="comment">#study_case2_autocommit(count)  #非常缓慢</span></span><br><span class="line">        study_case3_intelligent_commit_manual(count)</span><br><span class="line">        study_case4_autocommit_transaction(count)</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://my.oschina.net/tinyhare/blog/719039" target="_blank" rel="noopener">python sqlite3 事务控制</a></p><p><a href="https://www.cnblogs.com/yaoyu126/p/6413423.html" target="_blank" rel="noopener">python sqlite3 事务总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-sqlite3&quot;&gt;&lt;a href=&quot;#python-标准库-sqlite3&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 sqlite3&quot;&gt;&lt;/a&gt;python 标准库 sqlite3&lt;/h1&gt;&lt;p&gt;今天是二十四节气的大寒&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大寒，是&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%8C%E5%8D%81%E5%9B%9B%E8%8A%82%E6%B0%94/191597&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二十四节气&lt;/a&gt;中的最后一个节气。斗指丑；太阳&lt;a href=&quot;https://baike.baidu.com/item/%E9%BB%84%E7%BB%8F/8303112&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;黄经&lt;/a&gt;为300°；公历1月20－21日交节。同小寒一样，大寒也是表示天气寒冷程度的节气。在我国部分地区，大寒不如小寒冷，但在某些年份和沿海少数地方，全年最低气温仍然会出现在大寒节气内。小寒、大寒是一年中雨水最少的时段。&lt;/p&gt;
&lt;p&gt;兹大寒一过，新一年的节气就又轮回来了，正所谓冬去春来。大寒虽然寒冷，但因为已近春天，所以不会像大雪到冬至期间那样酷寒。这时节，人们开始忙着除旧饰新、腌制年肴、准备年货和各种祭祀供品、扫尘洁物，因为中国人最重要的节日——春节就要到了。&lt;/p&gt;
&lt;p&gt;每日一词：&lt;/p&gt;
&lt;p&gt;Cold &lt;/p&gt;
&lt;p&gt;adj 冷,寒冷&lt;/p&gt;
&lt;p&gt;例句：&lt;/p&gt;
&lt;p&gt;  It is the last one in January 20th of each year twenty-four solar term solar term, before and after the sun reaches 300 degrees for it”. It is cold weather, meaning extreme.&lt;/p&gt;
&lt;p&gt; 大寒是二十四节气中最后一个节气，每年1月20日前后太阳到达黄经300°时为”大寒”。大寒，是天气寒冷到极点的意思。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://photos.tuchong.com/350832/f/4959845.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="sqlite3" scheme="https://pinghailinfeng.gitee.io/tags/sqlite3/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
  </entry>
  
  <entry>
    <title>Understand Python GIL</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/19/Understand-Python-GIL/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/19/Understand-Python-GIL/</id>
    <published>2020-01-19T01:32:12.000Z</published>
    <updated>2020-01-19T07:30:24.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-threading"><a href="#python-标准库-threading" class="headerlink" title="python 标准库 threading"></a>python 标准库 threading</h1><p>每日一词:</p><blockquote><p>US[‘weðər]  UK[‘weðə(r)]</p><p>n.天气；气象；气象预<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br><span class="line">&gt; v.变形；经受住</span><br><span class="line">&gt;</span><br><span class="line">&gt; 网络:`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````气候；天气预报；风化</span><br><span class="line">&gt;</span><br><span class="line">&gt; 给大家推荐一部电影: 气象先生</span><br><span class="line"></span><br><span class="line">![](&lt;https://github.com/jeffsui/app_image_resource/blob/master/20200119_weather_man.jpg?raw=tru&gt;)</span><br><span class="line"></span><br><span class="line">&gt; This shit life,we must chuck some things</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 源代码</span><br><span class="line"></span><br><span class="line">**源代码:** [Lib/threading.py](https://github.com/python/cpython/tree/3.8/Lib/threading.py)</span><br><span class="line"></span><br><span class="line">## 核心函数</span><br><span class="line"></span><br><span class="line">- `threading.active_count`()</span><br><span class="line"></span><br><span class="line">  返回当前存活的线程类 [`Thread`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread) 对象。返回的计数等于 [`enumerate()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.enumerate) 返回的列表长度。</span><br><span class="line"></span><br><span class="line">- `threading.current_thread`()</span><br><span class="line"></span><br><span class="line">  返回当前对应调用者的控制线程的 [`Thread`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread) 对象。如果调用者的控制线程不是利用 [`threading`](https://docs.python.org/zh-cn/3.8/library/threading.html#module-threading) 创建，会返回一个功能受限的虚拟线程对象。</span><br><span class="line"></span><br><span class="line">- `threading.excepthook`(*args*, */*)</span><br><span class="line"></span><br><span class="line">  参数可以是下面任意一种类型</span><br><span class="line"></span><br><span class="line">  - *exc_type*: 异常类型</span><br><span class="line">  - *exc_value*: 异常值，可以是 `None`.</span><br><span class="line">  - *exc_traceback*: 异常回溯，可以是 `None`.</span><br><span class="line">  - *thread*: 线程跑出的异常 可以是`None`.</span><br><span class="line"></span><br><span class="line">- `threading.get_ident`()</span><br><span class="line"></span><br><span class="line">  返回当前线程的 “线程标识符”。它是一个非零的整数。它的值没有直接含义，主要是用作 magic cookie，比如作为含有线程相关数据的字典的索引。线程标识符可能会在线程退出，新线程创建时被复用。*3.3 新版功能.*</span><br><span class="line"></span><br><span class="line">- `threading.get_native_id`()</span><br><span class="line"></span><br><span class="line">  返回内核分配给当前线程的原生集成线程 ID。 这是一个非负整数。 它的值可被用来在整个系统中唯一地标识这个特定线程（直到线程终结，在那之后该值可能会被 OS 回收再利用）。[可用性](https://docs.python.org/zh-cn/3.8/library/intro.html#availability): Windows, FreeBSD, Linux, macOS, OpenBSD, NetBSD, AIX。*3.8 新版功能.*</span><br><span class="line"></span><br><span class="line">- `threading.enumerate`()</span><br><span class="line"></span><br><span class="line">  以列表形式返回当前所有存活的 [`Thread`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread) 对象。 该列表包含守护线程，[`current_thread()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.current_thread) 创建的虚拟线程对象和主线程。它不包含已终结的线程和尚未开始的线程。</span><br><span class="line"></span><br><span class="line">- `threading.main_thread`()</span><br><span class="line"></span><br><span class="line">  返回主 [`Thread`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread) 对象。一般情况下，主线程是Python解释器开始时创建的线程。*3.4 新版功能.*</span><br><span class="line"></span><br><span class="line">- `threading.settrace`(*func*)</span><br><span class="line"></span><br><span class="line">  为所有 [`threading`](https://docs.python.org/zh-cn/3.8/library/threading.html#module-threading) 模块开始的线程设置追踪函数。在每个线程的 [`run()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run) 方法被调用前，*func* 会被传递给 [`sys.settrace()`](https://docs.python.org/zh-cn/3.8/library/sys.html#sys.settrace) 。</span><br><span class="line"></span><br><span class="line">- `threading.setprofile`(*func*)</span><br><span class="line"></span><br><span class="line">  为所有 [`threading`](https://docs.python.org/zh-cn/3.8/library/threading.html#module-threading) 模块开始的线程设置性能测试函数。在每个线程的 [`run()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run) 方法被调用前，*func* 会被传递给 [`sys.setprofile()`](https://docs.python.org/zh-cn/3.8/library/sys.html#sys.setprofile) 。</span><br><span class="line"></span><br><span class="line">- `threading.stack_size`([*size*])</span><br><span class="line"></span><br><span class="line">  返回创建线程时用的堆栈大小。可选参数 *size* 指定之后新建的线程的堆栈大小，而且一定要是0（根据平台或者默认配置）或者最小是32,768(32KiB)的一个正整数。如果 *size* 没有指定，默认是0。如果不支持改变线程堆栈大小，会抛出 [`RuntimeError`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError) 错误。如果指定的堆栈大小不合法，会抛出 [`ValueError`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError) 错误并且不会修改堆栈大小。32KiB是当前最小的能保证解释器有足够堆栈空间的堆栈大小。需要注意的是部分平台对于堆栈大小会有特定的限制，例如要求大于32KiB的堆栈大小或者需要根据系统内存页面的整数倍进行分配 - 应当查阅平台文档有关详细信息（4KiB页面比较普遍，在没有更具体信息的情况下，建议的方法是使用4096的倍数作为堆栈大小）。[适用于](https://docs.python.org/zh-cn/3.8/library/intro.html#availability): Windows，具有 POSIX 线程的系统。</span><br><span class="line"></span><br><span class="line">## 常量</span><br><span class="line"></span><br><span class="line">`threading.TIMEOUT_MAX`[¶](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.TIMEOUT_MAX)</span><br><span class="line"></span><br><span class="line">  阻塞函数（ [`Lock.acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire), [`RLock.acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock.acquire), [`Condition.wait()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait), ...）中形参 *timeout* 允许的最大值。传入超过这个值的 timeout 会抛出 [`OverflowError`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError) 异常。</span><br><span class="line"></span><br><span class="line">## 常用函数</span><br><span class="line"></span><br><span class="line">### 线程本地数据</span><br><span class="line"></span><br><span class="line">线程本地数据是特定线程的数据。管理线程本地数据，只需要创建一个 [`local`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.local) （或者一个子类型）的实例并在实例中储存属性：</span><br><span class="line"></span><br><span class="line">~~~python</span><br><span class="line">mydata = threading.local()</span><br><span class="line">mydata.x = 1</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">在不同的线程中，实例的值会不同。</span><br><span class="line"></span><br><span class="line">- *class* `threading.local`</span><br><span class="line"></span><br><span class="line">  一个代表线程本地数据的类。更多相关细节和大量示例，参见 `_threading_local` 模块的文档。</span><br><span class="line"></span><br><span class="line">### 线程对象</span><br><span class="line"></span><br><span class="line">当线程对象一但被创建，其活动一定会因调用线程的 [`start()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.start) 方法开始。这会在独立的控制线程调用 [`run()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run) 方法。</span><br><span class="line"></span><br><span class="line">一旦线程活动开始，该线程会被认为是 &apos;存活的&apos; 。当它的 [`run()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run) 方法终结了（不管是正常的还是抛出未被处理的异常），就不是&apos;存活的&apos;。 [`is_alive()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.is_alive) 方法用于检查线程是否存活。</span><br><span class="line"></span><br><span class="line">其他线程可以调用一个线程的 [`join()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join) 方法。这会阻塞调用该方法的线程，直到被调用 [`join()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join) 方法的线程终结。</span><br><span class="line"></span><br><span class="line">线程有名字。名字可以传递给构造函数，也可以通过 [`name`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.name) 属性读取或者修改。</span><br><span class="line"></span><br><span class="line">如果运行线程中的 `run()`抛出了异常, [threading.excepthook()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.excepthook) 方法就会被调用,默认情况下,忽略 [`SystemExit`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit).</span><br><span class="line"></span><br><span class="line">一个线程可以被标记成一个“守护线程”。 这个标志的意义是，当剩下的线程都是守护线程时，整个 Python 程序将会退出。 初始值继承于创建线程。 这个标志可以通过 [`daemon`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.daemon) 特征属性或者 *daemon* 构造器参数来设置。</span><br><span class="line"></span><br><span class="line">&gt; 守护线程在程序关闭时会突然关闭。他们的资源（例如已经打开的文档，数据库事务等等）可能没有被正确释放。如果你想你的线程正常停止，设置他们成为非守护模式并且使用合适的信号机制，例如： [`Event`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event)。</span><br><span class="line"></span><br><span class="line">有个 &quot;主线程&quot; 对象；这对应Python程序里面初始的控制线程。它不是一个守护线程。</span><br><span class="line"></span><br><span class="line">&quot;虚拟线程对象&quot; 是可以被创建的。这些是对应于“外部线程”的线程对象，它们是在线程模块外部启动的控制线程，例如直接来自C代码。虚拟线程对象功能受限；他们总是被认为是存活的和守护模式，不能被 [`join()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join) 。因为无法检测外来线程的终结，它们永远不会被删除。</span><br><span class="line"></span><br><span class="line">*class* `threading.Thread`(*group=None*, *target=None*, *name=None*, *args=()*, *kwargs=&#123;&#125;*, ***, *daemon=None*)</span><br><span class="line"></span><br><span class="line">调用这个构造函数时，必需带有关键字参数。参数如下：</span><br><span class="line"></span><br><span class="line">*group* 应该为 `None`；为了日后扩展 `ThreadGroup` 类实现而保留。</span><br><span class="line"></span><br><span class="line">*target* 是用于 [`run()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run) 方法调用的可调用对象。默认是 `None`，表示不需要调用任何方法。</span><br><span class="line"></span><br><span class="line">*name* 是线程名称。默认情况下，由 &quot;Thread-*N*&quot; 格式构成一个唯一的名称，其中 *N* 是小的十进制数。</span><br><span class="line"></span><br><span class="line">*args* 是用于调用目标函数的参数元组。默认是 `()`。</span><br><span class="line"></span><br><span class="line">*kwargs* 是用于调用目标函数的关键字参数字典。默认是 `&#123;&#125;`。</span><br><span class="line"></span><br><span class="line">- `start`()</span><br><span class="line"></span><br><span class="line">  开始线程活动。它在一个线程里最多只能被调用一次。它安排对象的 [`run()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run) 方法在一个独立的控制进程中调用。如果同一个线程对象中调用这个方法的次数大于一次，会抛出 [`RuntimeError`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError) 。</span><br><span class="line"></span><br><span class="line">- `run`()</span><br><span class="line"></span><br><span class="line">  代表线程活动的方法。你可以在子类型里重载这个方法。 标准的 [`run()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run) 方法会对作为 *target* 参数传递给该对象构造器的可调用对象（如果存在）发起调用，并附带从 *args* 和 *kwargs* 参数分别获取的位置和关键字参数。</span><br><span class="line"></span><br><span class="line">- `join`(*timeout=None*)</span><br><span class="line"></span><br><span class="line">  等待，直到线程终结。这会阻塞调用这个方法的线程，直到被调用 [`join()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join) 的线程终结 -- 不管是正常终结还是抛出未处理异常 -- 或者直到发生超时，超时选项是可选的。当 *timeout* 参数存在而且不是 `None` 时，它应该是一个用于指定操作超时的以秒为单位的浮点数（或者分数）。因为 [`join()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join) 总是返回 `None` ，所以你一定要在 [`join()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join) 后调用 [`is_alive()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.is_alive) 才能判断是否发生超时 -- 如果线程仍然存货，则 [`join()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join) 超时。当 *timeout* 参数不存在或者是 `None` ，这个操作会阻塞直到线程终结。一个线程可以被 [`join()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join) 很多次。如果尝试加入当前线程会导致死锁， [`join()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join) 会引起 [`RuntimeError`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError) 异常。如果尝试 [`join()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join) 一个尚未开始的线程，也会抛出相同的异常。</span><br><span class="line"></span><br><span class="line">- `name`</span><br><span class="line"></span><br><span class="line">  只用于识别的字符串。它没有语义。多个线程可以赋予相同的名称。 初始名称由构造函数设置。</span><br><span class="line"></span><br><span class="line">- `getName`()</span><br><span class="line"></span><br><span class="line">- `setName`()</span><br><span class="line"></span><br><span class="line">  旧的 [`name`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.name) 取值/设值 API；直接当做特征属性使用它。</span><br><span class="line"></span><br><span class="line">- `ident`</span><br><span class="line"></span><br><span class="line">  这个线程的 &apos;线程标识符&apos;，如果线程尚未开始则为 `None` 。这是个非零整数。参见 [`get_ident()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.get_ident) 函数。当一个线程退出而另外一个线程被创建，线程标识符会被复用。即使线程退出后，仍可得到标识符。</span><br><span class="line"></span><br><span class="line">- **native_id**</span><br><span class="line"></span><br><span class="line">  内部生成的线程id,一个非负的整数,如果为`None`意味着线程还没有启动。</span><br><span class="line"></span><br><span class="line">- `is_alive`()</span><br><span class="line"></span><br><span class="line">  返回线程是否存活。当 [`run()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run) 方法刚开始直到 [`run()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run) 方法刚结束，这个方法返回 `True` 。模块函数 [`enumerate()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.enumerate) 返回包含所有存活线程的列表。</span><br><span class="line"></span><br><span class="line">- `daemon`</span><br><span class="line"></span><br><span class="line">  一个表示这个线程是（True）否（False）守护线程的布尔值。一定要在调用 [`start()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.start) 前设置好，不然会抛出 [`RuntimeError`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError) 。初始值继承于创建线程；主线程不是守护线程，因此主线程创建的所有线程默认都是 [`daemon`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.daemon) = `False`。当没有存活的非守护线程时，整个Python程序才会退出。</span><br><span class="line"></span><br><span class="line">- `isDaemon`()</span><br><span class="line"></span><br><span class="line">- `setDaemon`()</span><br><span class="line"></span><br><span class="line">  旧的 [`name`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.name) 取值/设值 API；建议直接当做特征属性使用它。</span><br><span class="line"></span><br><span class="line">**CPython implementation detail:** CPython下，因为 [Global Interpreter Lock](https://docs.python.org/zh-cn/3.8/glossary.html#term-global-interpreter-lock)，一个时刻只有一个线程可以执行Python代码（尽管如此，某些性能导向的库可能会克服这个限制）。如果你想让你的应用更好的利用多核计算机的计算性能，推荐你使用 [`multiprocessing`](https://docs.python.org/zh-cn/3.8/library/multiprocessing.html#module-multiprocessing) 或者 [`concurrent.futures.ProcessPoolExecutor`](https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor) 。但是如果你想同时运行多个I/O绑定任务，线程仍然是一个合适的模型。</span><br><span class="line"></span><br><span class="line">### 锁对象</span><br><span class="line"></span><br><span class="line">原始锁是一个在锁定时不属于特定线程的同步基元组件。在Python中，它是能用的最低级的同步基元组件，由 [`_thread`](https://docs.python.org/zh-cn/3.8/library/_thread.html#module-_thread) 扩展模块直接实现。</span><br><span class="line"></span><br><span class="line">原始锁处于 &quot;锁定&quot; 或者 &quot;非锁定&quot; 两种状态之一。它被创建时为非锁定状态。它有两个基本方法， [`acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire) 和 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release) 。当状态为非锁定时， [`acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire) 将状态改为 锁定 并立即返回。当状态是锁定时， [`acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire) 将阻塞至其他线程调用 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release) 将其改为非锁定状态，然后 [`acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire) 调用重置其为锁定状态并返回。 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release) 只在锁定状态下调用； 它将状态改为非锁定并立即返回。如果尝试释放一个非锁定的锁，则会引发 [`RuntimeError`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError)  异常。</span><br><span class="line"></span><br><span class="line">锁同样支持 [上下文管理协议](https://docs.python.org/zh-cn/3.8/library/threading.html#with-locks)。</span><br><span class="line"></span><br><span class="line">当多个线程在 [`acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire) 等待状态转变为未锁定被阻塞，然后 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release) 重置状态为未锁定时，只有一个线程能继续执行；至于哪个等待线程继续执行没有定义，并且会根据实现而不同。</span><br><span class="line"></span><br><span class="line">所有方法的执行都是原子性的。</span><br><span class="line"></span><br><span class="line">*class* `threading.Lock`</span><br><span class="line"></span><br><span class="line">实现原始锁对象的类。一旦一个线程获得一个锁，会阻塞随后尝试获得锁的线程，直到它被释放；任何线程都可以释放它。</span><br><span class="line"></span><br><span class="line">需要注意的是 `Lock` 其实是一个工厂函数，返回平台支持的具体锁类中最有效的版本的实例。</span><br><span class="line"></span><br><span class="line">- `acquire`(*blocking=True*, *timeout=-1*)</span><br><span class="line"></span><br><span class="line">  可以阻塞或非阻塞地获得锁。当调用时参数 *blocking* 设置为 `True` （缺省值），阻塞直到锁被释放，然后将锁锁定并返回 `True` 。在参数 *blocking* 被设置为 `False` 的情况下调用，将不会发生阻塞。如果调用时 *blocking* 设为 `True` 会阻塞，并立即返回 `False` ；否则，将锁锁定并返回 `True`。当浮点型 *timeout* 参数被设置为正值调用时，只要无法获得锁，将最多阻塞 *timeout* 设定的秒数。*timeout* 参数被设置为 `-1` 时将无限等待。当 *blocking* 为 false 时，*timeout* 指定的值将被忽略。如果成功获得锁，则返回 `True`，否则返回 `False` (例如发生 *超时* 的时候)。*在 3.2 版更改:* 新的 *timeout* 形参。*在 3.2 版更改:* 现在如果底层线程实现支持，则可以通过POSIX上的信号中断锁的获取。</span><br><span class="line"></span><br><span class="line">- `release`()</span><br><span class="line"></span><br><span class="line">  释放一个锁。这个方法可以在任何线程中调用，不单指获得锁的线程。当锁被锁定，将它重置为未锁定，并返回。如果其他线程正在等待这个锁解锁而被阻塞，只允许其中一个允许。在未锁定的锁调用时，会引发 [`RuntimeError`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError) 异常。没有返回值。</span><br><span class="line"></span><br><span class="line">- `locked`()</span><br><span class="line"></span><br><span class="line">  Return true if the lock is acquired.</span><br><span class="line"></span><br><span class="line">### 递归锁</span><br><span class="line"></span><br><span class="line">重入锁是一个可以被同一个线程多次获取的同步基元组件。在内部，它在基元锁的锁定/非锁定状态上附加了 &quot;所属线程&quot; 和 &quot;递归等级&quot; 的概念。在锁定状态下，某些线程拥有锁 ； 在非锁定状态下， 没有线程拥有它。</span><br><span class="line"></span><br><span class="line">若要锁定锁，线程调用其 [`acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock.acquire) 方法；一旦线程拥有了锁，方法将返回。若要解锁，线程调用 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release) 方法。 [`acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire)/[`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release) 对可以嵌套；只有最终 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release) (最外面一对的 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release) ) 将锁解开，才能让其他线程继续处理 [`acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire) 阻塞。</span><br><span class="line"></span><br><span class="line">递归锁也支持 [上下文管理协议](https://docs.python.org/zh-cn/3.8/library/threading.html#with-locks)。</span><br><span class="line"></span><br><span class="line">*class* `threading.RLock`</span><br><span class="line"></span><br><span class="line">此类实现了重入锁对象。重入锁必须由获取它的线程释放。一旦线程获得了重入锁，同一个线程再次获取它将不阻塞；线程必须在每次获取它时释放一次。需要注意的是 `RLock` 其实是一个工厂函数，返回平台支持的具体递归锁类中最有效的版本的实例。</span><br><span class="line"></span><br><span class="line">- `acquire`(*blocking=True*, *timeout=-1*)</span><br><span class="line"></span><br><span class="line">  可以阻塞或非阻塞地获得锁。</span><br><span class="line"></span><br><span class="line">  当无参数调用时： 如果这个线程已经拥有锁，递归级别增加一，并立即返回。否则，如果其他线程拥有该锁，则阻塞至该锁解锁。一旦锁被解锁(不属于任何线程)，则抢夺所有权，设置递归等级为一，并返回。如果多个线程被阻塞，等待锁被解锁，一次只有一个线程能抢到锁的所有权。在这种情况下，没有返回值。</span><br><span class="line"></span><br><span class="line">  当发起调用时将 *blocking* 参数设为真值，则执行与无参数调用时一样的操作，然后返回 `True`。</span><br><span class="line"></span><br><span class="line">  当发起调用时将 *blocking* 参数设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 `False`；在其他情况下，执行与无参数调用时一样的操作，然后返回 `True`。</span><br><span class="line"></span><br><span class="line">  当发起调用时将浮点数的 *timeout* 参数设为正值时，只要无法获得锁，将最多阻塞 *timeout* 所指定的秒数。 如果已经获得锁则返回 `True`，如果超时则返回假值。</span><br><span class="line"></span><br><span class="line">- `release`()</span><br><span class="line"></span><br><span class="line">  释放锁，自减递归等级。如果减到零，则将锁重置为非锁定状态(不被任何线程拥有)，并且，如果其他线程正被阻塞着等待锁被解锁，则仅允许其中一个线程继续。如果自减后，递归等级仍然不是零，则锁保持锁定，仍由调用线程拥有。</span><br><span class="line"></span><br><span class="line">  只有当前线程拥有锁才能调用这个方法。如果锁被释放后调用这个方法，会引起 [`RuntimeError`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError) 异常。</span><br><span class="line"></span><br><span class="line">  没有返回值。</span><br><span class="line"></span><br><span class="line">### 条件对象</span><br><span class="line"></span><br><span class="line">条件变量总是与某种类型的锁对象相关联，锁对象可以通过传入获得，或者在缺省的情况下自动创建。当多个条件变量需要共享同一个锁时，传入一个锁很有用。锁是条件对象的一部分，你不必单独地跟踪它。</span><br><span class="line"></span><br><span class="line">条件变量服从 [上下文管理协议](https://docs.python.org/zh-cn/3.8/library/threading.html#with-locks)：使用 `with` 语句会在它包围的代码块内获取关联的锁。 [`acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.acquire) 和 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.release) 方法也能调用关联锁的相关方法。</span><br><span class="line"></span><br><span class="line">其它方法必须在持有关联的锁的情况下调用。 [`wait()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait) 方法释放锁，然后阻塞直到其它线程调用 [`notify()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify) 方法或 [`notify_all()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all) 方法唤醒它。一旦被唤醒， [`wait()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait) 方法重新获取锁并返回。它也可以指定超时时间。</span><br><span class="line"></span><br><span class="line">The [`notify()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify) method wakes up one of the threads waiting for the condition variable, if any are waiting. The [`notify_all()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all) method wakes up all threads waiting for the condition variable.</span><br><span class="line"></span><br><span class="line">注意： [`notify()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify) 方法和 [`notify_all()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all) 方法并不会释放锁，这意味着被唤醒的线程不会立即从它们的 [`wait()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait) 方法调用中返回，而是会在调用了 [`notify()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify) 方法或 [`notify_all()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all) 方法的线程最终放弃了锁的所有权后返回。</span><br><span class="line"></span><br><span class="line">使用条件变量的典型编程风格是将锁用于同步某些共享状态的权限，那些对状态的某些特定改变感兴趣的线程，它们重复调用 [`wait()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait) 方法，直到看到所期望的改变发生；而对于修改状态的线程，它们将当前状态改变为可能是等待者所期待的新状态后，调用 [`notify()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify) 方法或者 [`notify_all()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all) 方法。例如，下面的代码是一个通用的无限缓冲区容量的生产者-消费者情形：</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="Consume-one-item"><a href="#Consume-one-item" class="headerlink" title="Consume one item"></a>Consume one item</h1><p>with cv:<br>    while not an_item_is_available():<br>        cv.wait()<br>    get_an_available_item()</p><h1 id="Produce-one-item"><a href="#Produce-one-item" class="headerlink" title="Produce one item"></a>Produce one item</h1><p>with cv:<br>    make_an_item_available()<br>    cv.notify()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用 `while` 循环检查所要求的条件成立与否是有必要的，因为 [`wait()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait) 方法可能要经过不确定长度的时间后才会返回，而此时导致 [`notify()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify) 方法调用的那个条件可能已经不再成立。这是多线程编程所固有的问题。 [`wait_for()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait_for) 方法可自动化条件检查，并简化超时计算。</span><br><span class="line"></span><br><span class="line">~~~python</span><br><span class="line"># Consume an item</span><br><span class="line">with cv:</span><br><span class="line">    cv.wait_for(an_item_is_available)</span><br><span class="line">    get_an_available_item()</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">选择 [`notify()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify) 还是 [`notify_all()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all) ，取决于一次状态改变是只能被一个还是能被多个等待线程所用。例如在一个典型的生产者-消费者情形中，添加一个项目到缓冲区只需唤醒一个消费者线程。</span><br><span class="line"></span><br><span class="line">*class* `threading.Condition`(*lock=None*)</span><br><span class="line"></span><br><span class="line">实现条件变量对象的类。一个条件变量对象允许一个或多个线程在被其它线程所通知之前进行等待。</span><br><span class="line"></span><br><span class="line">如果给出了非 `None` 的 *lock* 参数，则它必须为 [`Lock`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock) 或者 [`RLock`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock) 对象，并且它将被用作底层锁。否则，将会创建新的 [`RLock`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock) 对象，并将其用作底层锁。</span><br><span class="line"></span><br><span class="line">*在 3.3 版更改:* 从工厂函数变为类。</span><br><span class="line"></span><br><span class="line">- `acquire`(**args*)</span><br><span class="line"></span><br><span class="line">  请求底层锁。此方法调用底层锁的相应方法，返回值是底层锁相应方法的返回值。</span><br><span class="line"></span><br><span class="line">- `release`()</span><br><span class="line"></span><br><span class="line">  释放底层锁。此方法调用底层锁的相应方法。没有返回值。</span><br><span class="line"></span><br><span class="line">- `wait`(*timeout=None*)</span><br><span class="line"></span><br><span class="line">  等待直到被通知或发生超时。如果线程在调用此方法时没有获得锁，将会引发 [`RuntimeError`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError) 异常。这个方法释放底层锁，然后阻塞，直到在另外一个线程中调用同一个条件变量的 [`notify()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify) 或 [`notify_all()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all) 唤醒它，或者直到可选的超时发生。一旦被唤醒或者超时，它重新获得锁并返回。当提供了 *timeout* 参数且不是 `None` 时，它应该是一个浮点数，代表操作的超时时间，以秒为单位（可以为小数）。当底层锁是个 [`RLock`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock) ，不会使用它的 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.release) 方法释放锁，因为当它被递归多次获取时，实际上可能无法解锁。相反，使用了 [`RLock`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock) 类的内部接口，即使多次递归获取它也能解锁它。 然后，在重新获取锁时，使用另一个内部接口来恢复递归级别。返回 `True` ，除非提供的 *timeout* 过期，这种情况下返回 `False`。*在 3.2 版更改:* 很明显，方法总是返回 `None`。</span><br><span class="line"></span><br><span class="line">- `wait_for`(*predicate*, *timeout=None*)</span><br><span class="line"></span><br><span class="line">  等待，直到条件计算为真。 *predicate* 应该是一个可调用对象而且它的返回值可被解释为一个布尔值。可以提供 *timeout* 参数给出最大等待时间。这个实用方法会重复地调用 [`wait()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait) 直到满足判断式或者发生超时。返回值是判断式最后一个返回值，而且如果方法发生超时会返回 `False` 。忽略超时功能，调用此方法大致相当于编写:`while not predicate():     cv.wait() `因此，规则同样适用于 [`wait()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait) ：锁必须在被调用时保持获取，并在返回时重新获取。 随着锁定执行判断式。*3.2 新版功能.*</span><br><span class="line"></span><br><span class="line">- `notify`(*n=1*)</span><br><span class="line"></span><br><span class="line">  默认唤醒一个等待这个条件的线程。如果调用线程在没有获得锁的情况下调用这个方法，会引发 [`RuntimeError`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError) 异常。这个方法唤醒最多 *n* 个正在等待这个条件变量的线程；如果没有线程在等待，这是一个空操作。当前实现中，如果至少有 *n* 个线程正在等待，准确唤醒 *n* 个线程。但是依赖这个行为并不安全。未来，优化的实现有时会唤醒超过 *n* 个线程。注意：被唤醒的线程实际上不会返回它调用的 [`wait()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait) ，直到它可以重新获得锁。因为 [`notify()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify) 不会释放锁，只有它的调用者应该这样做。</span><br><span class="line"></span><br><span class="line">- `notify_all`()</span><br><span class="line"></span><br><span class="line">  唤醒所有正在等待这个条件的线程。这个方法行为与 [`notify()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify) 相似，但并不只唤醒单一线程，而是唤醒所有等待线程。如果调用线程在调用这个方法时没有获得锁，会引发 [`RuntimeError`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError) 异常。</span><br><span class="line"></span><br><span class="line">### 信号量对象</span><br><span class="line"></span><br><span class="line">这是计算机科学史上最古老的同步原语之一，早期的荷兰科学家 Edsger W. Dijkstra 发明了它。（他使用名称 `P()` 和 `V()` 而不是 [`acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire) 和 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release) ）。</span><br><span class="line"></span><br><span class="line">一个信号量管理一个内部计数器，该计数器因 [`acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire) 方法的调用而递减，因 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release) 方法的调用而递增。 计数器的值永远不会小于零；当 [`acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire) 方法发现计数器为零时，将会阻塞，直到其它线程调用 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release) 方法。</span><br><span class="line"></span><br><span class="line">信号量对象也支持 [上下文管理协议](https://docs.python.org/zh-cn/3.8/library/threading.html#with-locks) 。</span><br><span class="line"></span><br><span class="line">- *class* `threading.Semaphore`(*value=1*)</span><br><span class="line"></span><br><span class="line">  该类实现信号量对象。信号量对象管理一个原子性的计数器，代表 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release) 方法的调用次数减去 [`acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire) 的调用次数再加上一个初始值。如果需要， [`acquire()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire) 方法将会阻塞直到可以返回而不会使得计数器变成负数。在没有显式给出 *value* 的值时，默认为1。</span><br><span class="line"></span><br><span class="line">  可选参数 *value* 赋予内部计数器初始值，默认值为 `1` 。如果 *value* 被赋予小于0的值，将会引发 [`ValueError`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError) 异常。</span><br><span class="line"></span><br><span class="line">  - `acquire`(*blocking=True*, *timeout=None*)</span><br><span class="line"></span><br><span class="line">    获取一个信号量。在不带参数的情况下调用时：如果在进入时内部计数器的值大于零，则将其减一并立即返回 `True`.如果在进入时内部计数器的值为零，则将会阻塞直到被对 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release) 的调用唤醒。 一旦被唤醒（并且计数器的值大于 0），则将计数器减 1 并返回 `True`。 每次对 [`release()`](https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release) 的调用将只唤醒一个线程。 线程被唤醒的次序是不可确定的。当发起调用时将 *blocking* 设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 `False`；在其他情况下，执行与无参数调用时一样的操作，然后返回 `True`。当发起调用时如果 *timeout* 不为 `None`，则它将阻塞最多 *timeout* 秒。 请求在此时段时未能成功完成获取则将返回 `False`。 在其他情况下返回 `True`。*在 3.2 版更改:* 新的 *timeout* 形参。</span><br><span class="line"></span><br><span class="line">  - `release`()</span><br><span class="line"></span><br><span class="line">    释放一个信号量，将内部计数器的值增加1。当计数器原先的值为0且有其它线程正在等待它再次大于0时，唤醒正在等待的线程。</span><br><span class="line"></span><br><span class="line">- *class* `threading.BoundedSemaphore`(*value=1*)</span><br><span class="line"></span><br><span class="line">  该类实现有界信号量。有界信号量通过检查以确保它当前的值不会超过初始值。如果超过了初始值，将会引发 [`ValueError`](https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError) 异常。在大多情况下，信号量用于保护数量有限的资源。如果信号量被释放的次数过多，则表明出现了错误。没有指定时， *value* 的值默认为1。*在 3.3 版更改:* 从工厂函数变为类。</span><br><span class="line"></span><br><span class="line">#### `Semaphore`例子</span><br><span class="line"></span><br><span class="line">信号量通常用于保护数量有限的资源，例如数据库服务器。在资源数量固定的任何情况下，都应该使用有界信号量。在生成任何工作线程前，应该在主线程中初始化信号量。</span><br><span class="line"></span><br><span class="line">~~~python</span><br><span class="line">maxconnections = 5</span><br><span class="line"># ...</span><br><span class="line">pool_sema = BoundedSemaphore(value=maxconnections)</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">工作线程生成后，当需要连接服务器时，这些线程将调用信号量的 acquire 和 release 方法：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">    conn = connectdb()</span><br><span class="line">    try:</span><br><span class="line">        # ... use connection ...</span><br><span class="line">    finally:</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure></p><p>使用有界信号量能减少这种编程错误：信号量的释放次数多于其请求次数。</p><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>这是线程之间通信的最简单机制之一：一个线程发出事件信号，而其他线程等待该信号。</p><p>一个事件对象管理一个内部标志，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.set" target="_blank" rel="noopener"><code>set()</code></a> 方法可将其设置为true，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.clear" target="_blank" rel="noopener"><code>clear()</code></a> 方法可将其设置为false，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法将进入阻塞直到标志为true。</p><ul><li><p><em>class</em> <code>threading.Event</code></p><p>实现事件对象的类。事件对象管理一个内部标志，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.set" target="_blank" rel="noopener"><code>set()</code></a> 方法可将其设置为true。调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.clear" target="_blank" rel="noopener"><code>clear()</code></a> 方法可将其设置为false。调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法将进入阻塞直到标志为true。这个标志初始时为false。<em>在 3.3 版更改:</em> 从工厂函数变为类。<code>is_set</code>()当且仅当内部旗标为时返回 <code>True</code>。<code>set</code>()将内部标志设置为true。所有正在等待这个事件的线程将被唤醒。当标志为true时，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法的线程不会被被阻塞。<code>clear</code>()将内部标志设置为false。之后调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法的线程将会被阻塞，直到调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.set" target="_blank" rel="noopener"><code>set()</code></a> 方法将内部标志再次设置为true。<code>wait</code>(<em>timeout=None</em>)阻塞线程直到内部变量为true。如果调用时内部标志为true，将立即返回。否则将阻塞线程，直到调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.set" target="_blank" rel="noopener"><code>set()</code></a> 方法将标志设置为true或者发生可选的超时。当提供了timeout参数且不是 <code>None</code> 时，它应该是一个浮点数，代表操作的超时时间，以秒为单位（可以为小数）。当且仅当内部旗标在等待调用之前或者等待开始之后被设为真值时此方法将返回 <code>True</code>，也就是说，它将总是返回 <code>True</code> 除非设定了超时且操作发生了超时。</p></li></ul><h3 id="定时器对象"><a href="#定时器对象" class="headerlink" title="定时器对象"></a>定时器对象</h3><p>此类表示一个操作应该在等待一定的时间之后运行 — 相当于一个定时器。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Timer" target="_blank" rel="noopener"><code>Timer</code></a> 类是 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>Thread</code></a> 类的子类，因此可以像一个自定义线程一样工作。</p><p>与线程一样，通过调用 <code>start()</code> 方法启动定时器。而 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Timer.cancel" target="_blank" rel="noopener"><code>cancel()</code></a> 方法可以停止计时器（在计时结束前）， 定时器在执行其操作之前等待的时间间隔可能与用户指定的时间间隔不完全相同。</p><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello, world"</span>)</span><br><span class="line"></span><br><span class="line">t = Timer(<span class="number">30.0</span>, hello)</span><br><span class="line">t.start()  <span class="comment"># after 30 seconds, "hello, world" will be printed</span></span><br></pre></td></tr></table></figure><p><em>class</em> <code>threading.Timer</code>(<em>interval</em>, <em>function</em>, <em>args=None</em>, <em>kwargs=None</em>)</p><p>创建一个定时器，在经过 <em>interval</em> 秒的间隔事件后，将会用参数 <em>args</em> 和关键字参数 <em>kwargs</em> 调用 <em>function</em>。如果 <em>args</em> 为 <code>None</code> （默认值），则会使用一个空列表。如果 <em>kwargs</em> 为 <code>None</code> （默认值），则会使用一个空字典。</p><ul><li><code>cancel</code>()<a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Timer.cancel" target="_blank" rel="noopener">¶</a></li></ul><p>停止定时器并取消执行计时器将要执行的操作。仅当计时器仍处于等待状态时有效。</p><h3 id="栅栏对象"><a href="#栅栏对象" class="headerlink" title="栅栏对象"></a>栅栏对象</h3><p>栅栏类提供一个简单的同步原语，用于应对固定数量的线程需要彼此相互等待的情况。线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法后将阻塞，直到所有线程都调用了 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法。此时所有线程将被同时释放。</p><p>栅栏对象可以被多次使用，但进程的数量不能改变。</p><p>这是一个使用简便的方法实现客户端进程与服务端进程同步的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">b = Barrier(<span class="number">2</span>, timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">()</span>:</span></span><br><span class="line">    start_server()</span><br><span class="line">    b.wait()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        connection = accept_connection()</span><br><span class="line">        process_server_connection(connection)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">()</span>:</span></span><br><span class="line">    b.wait()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        connection = make_connection()</span><br><span class="line">        process_client_connection(connection)</span><br></pre></td></tr></table></figure><p><em>class</em> <code>threading.Barrier</code>(<em>parties</em>, <em>action=None</em>, <em>timeout=None</em>)</p><p>创建一个需要 <em>parties</em> 个线程的栅栏对象。如果提供了可调用的 <em>action</em> 参数，它会在所有线程被释放时在其中一个线程中自动调用。 <em>timeout</em> 是默认的超时时间，如果没有在 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法中指定超时时间的话。</p><ul><li><p><code>wait</code>(<em>timeout=None</em>)</p><p>冲出栅栏。当栅栏中所有线程都已经调用了这个函数，它们将同时被释放。如果提供了 <em>timeout</em> 参数，这里的 <em>timeout</em> 参数优先于创建栅栏对象时提供的 <em>timeout</em> 参数。函数返回值是一个整数，取值范围在0到 <em>parties</em> – 1，在每个线程中的返回值不相同。可用于从所有线程中选择唯一的一个线程执行一些特别的工作。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = barrier.wait()</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># Only one thread needs to print this</span></span><br><span class="line">    print(<span class="string">"passed the barrier"</span>)</span><br></pre></td></tr></table></figure><p>如果创建栅栏对象时在构造函数中提供了 <em>action</em> 参数，它将在其中一个线程释放前被调用。如果此调用引发了异常，栅栏对象将进入损坏态。</p><p>如果发生了超时，栅栏对象将进入破损态。</p><p>如果栅栏对象进入破损态，或重置栅栏时仍有线程等待释放，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.BrokenBarrierError" target="_blank" rel="noopener"><code>BrokenBarrierError</code></a> 异常。</p></li><li><p><code>reset</code>()</p><p>重置栅栏为默认的初始态。如果栅栏中仍有线程等待释放，这些线程将会收到 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.BrokenBarrierError" target="_blank" rel="noopener"><code>BrokenBarrierError</code></a> 异常。</p></li><li><p><code>abort</code>()</p><p>Put the barrier into a broken state. This causes any active or future calls to <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier.wait" target="_blank" rel="noopener"><code>wait()</code></a> to fail with the <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.BrokenBarrierError" target="_blank" rel="noopener"><code>BrokenBarrierError</code></a>. Use this for example if one of the threads needs to abort, to avoid deadlocking the application.更好的方式是：创建栅栏时提供一个合理的超时时间，来自动避免某个线程出错。</p></li><li><p><code>parties</code></p><p>冲出栅栏所需要的线程数量。</p></li><li><p><code>n_waiting</code></p><p>当前时刻正在栅栏中阻塞的线程数量。</p></li><li><p><code>broken</code></p><p>一个布尔值，值为 <code>True</code> 表明栅栏为破损态。</p></li></ul><p><em>exception</em> <code>threading.BrokenBarrierError</code></p><p>异常类，是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常的子类，在 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier" target="_blank" rel="noopener"><code>Barrier</code></a> 对象重置时仍有线程阻塞时和对象进入破损态时被引发。</p><h3 id="在-with-语句中使用锁、条件和信号量"><a href="#在-with-语句中使用锁、条件和信号量" class="headerlink" title="在 with 语句中使用锁、条件和信号量"></a>在 <code>with</code> 语句中使用锁、条件和信号量</h3><p>这个模块提供的带有 <code>acquire()</code> 和 <code>release()</code> 方法的对象，可以被用作 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的上下文管理器。当进入语句块时 <code>acquire()</code> 方法会被调用，退出语句块时 <code>release()</code> 会被调用。因此，以下片段:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> some_lock:</span><br><span class="line">    <span class="comment"># do something...</span></span><br></pre></td></tr></table></figure><p>相当于:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">some_lock.acquire()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># do something...</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    some_lock.release()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="GIL-原理"><a href="#GIL-原理" class="headerlink" title="GIL 原理"></a>GIL 原理</h3><p>参考 <a href="https://stackoverflow.com/questions/1294382/what-is-the-global-interpreter-lock-gil-in-cpython" target="_blank" rel="noopener">stackoverflow</a>上 大神的解释</p><blockquote><p>Python’s GIL is intended to serialize access to interpreter internals from different threads. On multi-core systems, it means that multiple threads can’t effectively make use of multiple cores. (If the GIL didn’t lead to this problem, most people wouldn’t care about the GIL - it’s only being raised as an issue because of the increasing prevalence of multi-core systems.) If you want to understand it in detail, you can view <a href="https://www.youtube.com/watch?v=ph374fJqFPE" target="_blank" rel="noopener">this video</a> or look at <a href="http://www.dabeaz.com/python/GIL.pdf" target="_blank" rel="noopener">this set of slides</a>. It might be too much information, but then you did ask for details :-)</p><p>Note that Python’s GIL is only really an issue for CPython, the reference implementation. Jython and IronPython don’t have a GIL. As a Python developer, you don’t generally come across the GIL unless you’re writing a C extension. C extension writers need to release the GIL when their extensions do blocking I/O, so that other threads in the Python process get a chance to run.</p></blockquote><p>简单说 所谓的全局线程锁,就是同步线程间信号的一种处理方式。</p><p>在多线程系统中,并不能充分利用多线程,来提高整体的性能。所以才有了 GIL。</p><p>根据我的理解,GIL的一个应用场景是<strong>在同一时刻只能跑一个线程，这样在跑多线程的情况下，只有当线程获取到全局解释器锁后才能运行，而全局解释器锁只有一个，因此即使在多核的情况下也只能发挥出单核的功能。</strong></p><p>如下图所示:</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200119_cpu_bound_tasks.png?raw=tru" alt></p><p><code>GIL</code>仅仅对cpython实现和扩展的模块起作用,jython或者ironpython没有GIL的概念。</p><p>到底是并行还是多线程,在很多场景中都有争论。</p><h3 id="GIL-对线程执行的影响："><a href="#GIL-对线程执行的影响：" class="headerlink" title="GIL 对线程执行的影响："></a>GIL 对线程执行的影响：</h3><p>首先理解什么是interval时间,和操作系统绑定:</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># The interval is set to 100 instructions:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getcheckinterval()</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>多线程环境中，python虚拟机按照以下方式执行：</p><ul><li>设置GIL</li><li>切换到一个线程去执行</li><li>运行代码，这里有两种机制： q<ul><li>指定数量的字节码指令（100个）</li><li>固定时间15ms线程主动让出控制</li></ul></li><li>把线程设置为睡眠状态</li><li>解锁GIL</li><li>再次重复以上步骤</li></ul><h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><p><strong>Code 1: CPU bound program that perform simple countdown</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread </span><br><span class="line">  </span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span> </span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>: </span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">start = time.time() </span><br><span class="line">countdown(COUNT) </span><br><span class="line">end = time.time() </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'Time taken in seconds -'</span>, end - start) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Time taken <span class="keyword">in</span> seconds - <span class="number">2.5236213207244873</span></span><br></pre></td></tr></table></figure><p><strong>Code 2: Two threads running parallel</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread </span><br><span class="line">  </span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span> </span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>: </span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">t1 = Thread(target = countdown, args =(COUNT//<span class="number">2</span>, )) </span><br><span class="line">t2 = Thread(target = countdown, args =(COUNT//<span class="number">2</span>, )) </span><br><span class="line">  </span><br><span class="line">start = time.time() </span><br><span class="line">t1.start() </span><br><span class="line">t2.start() </span><br><span class="line">t1.join() </span><br><span class="line">t2.join() </span><br><span class="line">end = time.time() </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'Time taken in seconds -'</span>, end - start) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Time taken <span class="keyword">in</span> seconds - <span class="number">2.183610439300537</span></span><br></pre></td></tr></table></figure><p><strong>python的解决方案</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing  </span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line">  </span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span> </span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>: </span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: </span><br><span class="line">    <span class="comment"># creating processes  </span></span><br><span class="line">    start = time.time() </span><br><span class="line">    p1 = multiprocessing.Process(target = countdown, args =(COUNT//<span class="number">2</span>, )) </span><br><span class="line">    p2 = multiprocessing.Process(target = countdown, args =(COUNT//<span class="number">2</span>, )) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># starting process 1  </span></span><br><span class="line">    p1.start() </span><br><span class="line">    <span class="comment"># starting process 2  </span></span><br><span class="line">    p2.start()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># wait until process 1 is finished  </span></span><br><span class="line">    p1.join()  </span><br><span class="line">    <span class="comment"># wait until process 2 is finished  </span></span><br><span class="line">    p2.join() </span><br><span class="line">    end = time.time() </span><br><span class="line">    print(<span class="string">'Time taken in seconds -'</span>, end - start) </span><br><span class="line">    &gt;&gt;&gt; Time taken <span class="keyword">in</span> seconds - <span class="number">2.5148496627807617</span></span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.dabeaz.com/python/UnderstandingGIL.pdf" target="_blank" rel="noopener">UnderstandingGIL</a></p><p><a href="https://callhub.io/understanding-python-gil/" target="_blank" rel="noopener">understanding-python-gil</a></p><p><a href="https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/" target="_blank" rel="noopener">what is the python interpreter lock gil</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python-标准库-threading&quot;&gt;&lt;a href=&quot;#python-标准库-threading&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 threading&quot;&gt;&lt;/a&gt;python 标准库 threading&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="thread" scheme="https://pinghailinfeng.gitee.io/tags/thread/"/>
    
      <category term="GIL" scheme="https://pinghailinfeng.gitee.io/tags/GIL/"/>
    
  </entry>
  
  <entry>
    <title>python standard library numbers</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/18/python-standard-library-numbers/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/18/python-standard-library-numbers/</id>
    <published>2020-01-18T01:02:31.000Z</published>
    <updated>2020-01-18T02:19:26.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库数字的抽象基类-numbers"><a href="#python-标准库数字的抽象基类-numbers" class="headerlink" title="python 标准库数字的抽象基类 numbers"></a>python 标准库数字的抽象基类 numbers</h1><p>昨天深夜 红薯 一篇博文 <a href="https://my.oschina.net/javayou/blog/3159653" target="_blank" rel="noopener">悼 @宏哥</a> ,让我久久不能平静。</p><p>时间定格在了2020年1月16号。</p><p>还依稀记得几年前和宏哥聊天,听说他去创业了。</p><p>还记得那时意气风发,舌战群儒,没想到如今阴阳两隔。</p><p>创业这条路,真的不好走。</p><p>愿天堂没有代码。</p><p>大家都好好活着吧。</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200118_hongge_blog.PNG?raw=true" alt></p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200118_sad.jpg?raw=tru" alt></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1398821876&auto=0&height=66"></iframe><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/numbers.py" target="_blank" rel="noopener">Lib/numbers.py</a></p><p><a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#module-numbers" target="_blank" rel="noopener"><code>numbers</code></a> 模块 (<a href="https://www.python.org/dev/peps/pep-3141" target="_blank" rel="noopener"><strong>PEP 3141</strong></a>) 定义了数字 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class" target="_blank" rel="noopener">抽象基类</a> 的层次结构，其中逐级定义了更多操作。 此模块中所定义的类型都不可被实例化。</p><h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><p><em>class</em> <code>numbers.Number</code></p><blockquote><p>数字的层次结构的基础。如果你只想确认参数 <em>x</em> 是不是数字而不关心其类型，则使用isinstance(x, Number)。</p></blockquote><a id="more"></a><h2 id="数字的层次"><a href="#数字的层次" class="headerlink" title="数字的层次"></a>数字的层次</h2><ul><li><p><em>class</em> <code>numbers.Complex</code></p><p>内置在类型 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#complex" target="_blank" rel="noopener"><code>complex</code></a> 里的子类描述了复数和它的运算操作。这些操作有：转化至 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#complex" target="_blank" rel="noopener"><code>complex</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#bool" target="_blank" rel="noopener"><code>bool</code></a>， <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.real" target="_blank" rel="noopener"><code>real</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.imag" target="_blank" rel="noopener"><code>imag</code></a>、<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#abs" target="_blank" rel="noopener"><code>abs()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.conjugate" target="_blank" rel="noopener"><code>conjugate()</code></a>、 <code>==</code> 和 <code>!=</code>。 所有的异常，<code>-</code> 和 <code>!=</code> ，都是抽象的。<code>real</code>抽象的。得到该数字的实数部分。<code>imag</code>抽象的。得到该数字的虚数部分。<em>abstractmethod</em> <code>conjugate</code>()抽象的。返回共轭复数。例如 <code>(1+3j).conjugate() == (1-3j)</code>。</p></li><li><p><em>class</em> <code>numbers.Real</code></p><p>相对于 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex" target="_blank" rel="noopener"><code>Complex</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Real" target="_blank" rel="noopener"><code>Real</code></a> 加入了只有实数才能进行的操作。简单的说，它们是：转化至 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.trunc" target="_blank" rel="noopener"><code>math.trunc()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#round" target="_blank" rel="noopener"><code>round()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.floor" target="_blank" rel="noopener"><code>math.floor()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.ceil" target="_blank" rel="noopener"><code>math.ceil()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#divmod" target="_blank" rel="noopener"><code>divmod()</code></a>、 <code>//</code>、 <code>%</code>、 <code>&lt;</code>、 <code>&lt;=</code>、 <code>&gt;</code>、 和 <code>&gt;=</code>。实数同样默认支持 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#complex" target="_blank" rel="noopener"><code>complex()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.real" target="_blank" rel="noopener"><code>real</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.imag" target="_blank" rel="noopener"><code>imag</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.conjugate" target="_blank" rel="noopener"><code>conjugate()</code></a>。</p></li><li><p><em>class</em> <code>numbers.Rational</code></p><p>子类型 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Real" target="_blank" rel="noopener"><code>Real</code></a> 并加入 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational.numerator" target="_blank" rel="noopener"><code>numerator</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational.denominator" target="_blank" rel="noopener"><code>denominator</code></a> 两种属性，这两种属性应该属于最低的级别。加入后，这默认支持 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float()</code></a>。<code>numerator</code>摘要。<code>denominator</code>摘要。</p></li><li><p><em>class</em> <code>numbers.Integral</code></p><p>子类型 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational" target="_blank" rel="noopener"><code>Rational</code></a> 加上转化至 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>。 默认支持 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational.numerator" target="_blank" rel="noopener"><code>numerator</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational.denominator" target="_blank" rel="noopener"><code>denominator</code></a>。 在 <code>**</code> 中加入抽象方法和比特字符串的操作： <code>&lt;&lt;</code>、 <code>&gt;&gt;</code>、 <code>&amp;</code>、 <code>^</code>、 <code>|</code>、 <code>~</code>。</p></li></ul><h2 id="类型接口注解"><a href="#类型接口注解" class="headerlink" title="类型接口注解"></a>类型接口注解</h2><p>实现者需要注意使相等的数字相等并拥有同样的值。当这两个数使用不同的扩展模块时，这其中的差异是很微妙的。例如，用 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>fractions.Fraction</code></a> 实现 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#hash" target="_blank" rel="noopener"><code>hash()</code></a> 如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.denominator == <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># Get integers right.</span></span><br><span class="line">        <span class="keyword">return</span> hash(self.numerator)</span><br><span class="line">    <span class="comment"># Expensive check, but definitely correct.</span></span><br><span class="line">    <span class="keyword">if</span> self == float(self):</span><br><span class="line">        <span class="keyword">return</span> hash(float(self))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Use tuple's hash to avoid a high collision rate on</span></span><br><span class="line">        <span class="comment"># simple fractions.</span></span><br><span class="line">        <span class="keyword">return</span> hash((self.numerator, self.denominator))</span><br></pre></td></tr></table></figure><h3 id="添加更多数字的ABC-创造自定义的数字子类"><a href="#添加更多数字的ABC-创造自定义的数字子类" class="headerlink" title="添加更多数字的ABC(创造自定义的数字子类)"></a>添加更多数字的ABC(创造自定义的数字子类)</h3><p>当然，这里有更多支持数字的ABC，如果不加入这些，就将缺少层次感。你可以用如下方法在 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex" target="_blank" rel="noopener"><code>Complex</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Real" target="_blank" rel="noopener"><code>Real</code></a> 中加入MyFoo：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFoo</span><span class="params">(Complex)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">MyFoo.register(Real)</span><br></pre></td></tr></table></figure><h3 id="实现算数运算"><a href="#实现算数运算" class="headerlink" title="实现算数运算"></a>实现算数运算</h3><p>我们希望实现计算，因此，混合模式操作要么调用一个作者知道参数类型的实现，要么转变成为最接近的内置类型并对这个执行操作。对于子类 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Integral" target="_blank" rel="noopener"><code>Integral</code></a>，这意味着 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__radd__" target="_blank" rel="noopener"><code>__radd__()</code></a> 必须用如下方式定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIntegral</span><span class="params">(Integral)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(other, MyIntegral):</span><br><span class="line">            <span class="keyword">return</span> do_my_adding_stuff(self, other)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, OtherTypeIKnowAbout):</span><br><span class="line">            <span class="keyword">return</span> do_my_other_adding_stuff(self, other)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(other, MyIntegral):</span><br><span class="line">            <span class="keyword">return</span> do_my_adding_stuff(other, self)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, OtherTypeIKnowAbout):</span><br><span class="line">            <span class="keyword">return</span> do_my_other_adding_stuff(other, self)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, Integral):</span><br><span class="line">            <span class="keyword">return</span> int(other) + int(self)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, Real):</span><br><span class="line">            <span class="keyword">return</span> float(other) + float(self)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, Complex):</span><br><span class="line">            <span class="keyword">return</span> complex(other) + complex(self)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure><p>复数的子类上的混合操作有五种情况。前述的代码中除去MyIntegral和OtherTypeIKnow的文本将作为下面描述的样板。a是A的实例，并且使复数的子类（a：A&lt;：Complex），b是B的实例，也是复数的子类。我们以a+b做如下讨论：</p><ol><li>如果 <code>A</code> 被定义成一个承认b 的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a>，一切都没有问题。</li><li>如果 <code>A</code> 转回成“模板”失败，它将返回一个属于 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 的值，我们需要避免 <code>B</code> 定义了一个更加智能的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__radd__" target="_blank" rel="noopener"><code>__radd__()</code></a>，因此模板需要返回一个属于 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#NotImplemented" target="_blank" rel="noopener"><code>NotImplemented</code></a> 。（或者 <code>A</code> 可能完全不实现 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 。）</li><li>接着看 <code>B</code> 的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__radd__" target="_blank" rel="noopener"><code>__radd__()</code></a> 。如果它接受<code>a</code> ，一切都将完美。</li><li>如果没有成功回退到模板，就没有更多的方法可以去尝试，因此这里将使用默认的实现。</li><li>如果 <code>B &lt;: A</code> ， Python 在 <code>A.__add__</code> 之前尝试 <code>B.__radd__</code> 。 这是可行的，是通过对 <code>A</code> 的认识实现的，因此这可以在交给 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex" target="_blank" rel="noopener"><code>Complex</code></a> 处理之前处理这些实例。</li></ol><p>如果 <code>A &lt;: Complex</code> 和 <code>B &lt;: Real</code> 没有共享任何资源，那么适当的共享操作涉及内置的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#complex" target="_blank" rel="noopener"><code>complex</code></a> ，并且分别获得 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__radd__" target="_blank" rel="noopener"><code>__radd__()</code></a> ，因此 <code>a+b == b+a</code>。</p><p>由于对任何一直类型的大部分操作是十分相似的，可以定义一个帮助函数，即一个生成后续或相反的实例的生成器。例如，使用 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>fractions.Fraction</code></a> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_operator_fallbacks</span><span class="params">(monomorphic_operator, fallback_operator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(b, (int, Fraction)):</span><br><span class="line">            <span class="keyword">return</span> monomorphic_operator(a, b)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(b, float):</span><br><span class="line">            <span class="keyword">return</span> fallback_operator(float(a), b)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(b, complex):</span><br><span class="line">            <span class="keyword">return</span> fallback_operator(complex(a), b)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    forward.__name__ = <span class="string">'__'</span> + fallback_operator.__name__ + <span class="string">'__'</span></span><br><span class="line">    forward.__doc__ = monomorphic_operator.__doc__</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(b, a)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(a, Rational):</span><br><span class="line">            <span class="comment"># Includes ints.</span></span><br><span class="line">            <span class="keyword">return</span> monomorphic_operator(a, b)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(a, numbers.Real):</span><br><span class="line">            <span class="keyword">return</span> fallback_operator(float(a), float(b))</span><br><span class="line">        <span class="keyword">elif</span> isinstance(a, numbers.Complex):</span><br><span class="line">            <span class="keyword">return</span> fallback_operator(complex(a), complex(b))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    reverse.__name__ = <span class="string">'__r'</span> + fallback_operator.__name__ + <span class="string">'__'</span></span><br><span class="line">    reverse.__doc__ = monomorphic_operator.__doc__</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> forward, reverse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""a + b"""</span></span><br><span class="line">    <span class="keyword">return</span> Fraction(a.numerator * b.denominator +</span><br><span class="line">                    b.numerator * a.denominator,</span><br><span class="line">                    a.denominator * b.denominator)</span><br><span class="line"></span><br><span class="line">__add__, __radd__ = _operator_fallbacks(_add, operator.add)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库数字的抽象基类-numbers&quot;&gt;&lt;a href=&quot;#python-标准库数字的抽象基类-numbers&quot; class=&quot;headerlink&quot; title=&quot;python 标准库数字的抽象基类 numbers&quot;&gt;&lt;/a&gt;python 标准库数字的抽象基类 numbers&lt;/h1&gt;&lt;p&gt;昨天深夜 红薯 一篇博文 &lt;a href=&quot;https://my.oschina.net/javayou/blog/3159653&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;悼 @宏哥&lt;/a&gt; ,让我久久不能平静。&lt;/p&gt;
&lt;p&gt;时间定格在了2020年1月16号。&lt;/p&gt;
&lt;p&gt;还依稀记得几年前和宏哥聊天,听说他去创业了。&lt;/p&gt;
&lt;p&gt;还记得那时意气风发,舌战群儒,没想到如今阴阳两隔。&lt;/p&gt;
&lt;p&gt;创业这条路,真的不好走。&lt;/p&gt;
&lt;p&gt;愿天堂没有代码。&lt;/p&gt;
&lt;p&gt;大家都好好活着吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200118_hongge_blog.PNG?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200118_sad.jpg?raw=tru&quot; alt&gt;&lt;/p&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=1398821876&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;源代码&quot;&gt;&lt;a href=&quot;#源代码&quot; class=&quot;headerlink&quot; title=&quot;源代码&quot;&gt;&lt;/a&gt;源代码&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;源代码：&lt;/strong&gt; &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/numbers.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lib/numbers.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/numbers.html#module-numbers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;numbers&lt;/code&gt;&lt;/a&gt; 模块 (&lt;a href=&quot;https://www.python.org/dev/peps/pep-3141&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;PEP 3141&lt;/strong&gt;&lt;/a&gt;) 定义了数字 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;抽象基类&lt;/a&gt; 的层次结构，其中逐级定义了更多操作。 此模块中所定义的类型都不可被实例化。&lt;/p&gt;
&lt;h2 id=&quot;核心类&quot;&gt;&lt;a href=&quot;#核心类&quot; class=&quot;headerlink&quot; title=&quot;核心类&quot;&gt;&lt;/a&gt;核心类&lt;/h2&gt;&lt;p&gt;&lt;em&gt;class&lt;/em&gt; &lt;code&gt;numbers.Number&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数字的层次结构的基础。如果你只想确认参数 &lt;em&gt;x&lt;/em&gt; 是不是数字而不关心其类型，则使用isinstance(x, Number)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
  </entry>
  
  <entry>
    <title>python standard libary heapq</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/17/python-standard-library-heapq/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/17/python-standard-library-heapq/</id>
    <published>2020-01-17T01:10:06.000Z</published>
    <updated>2020-01-17T02:18:48.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python-标准库-堆队列算法-heapq"><a href="#python-标准库-堆队列算法-heapq" class="headerlink" title="python 标准库  堆队列算法 heapq"></a>python 标准库  堆队列算法 heapq</h2><p>每日一词:</p><blockquote><p>Pollen </p><p>n 花粉</p><p>例句:</p><p>Good news for all you hay fever and asthma sufferers<br>对于花粉症和哮喘病患者是个好消息</p></blockquote><p>今天是小年,祝大家心想事成</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200117_happiness.jpg?raw=true" alt></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><strong>源码：</strong><a href="https://github.com/python/cpython/tree/3.8/Lib/heapq.py" target="_blank" rel="noopener">Lib/heapq.py</a></p><p>主要模块和方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">'heappush'</span>, <span class="string">'heappop'</span>, <span class="string">'heapify'</span>, <span class="string">'heapreplace'</span>, <span class="string">'merge'</span>,</span><br><span class="line">           <span class="string">'nlargest'</span>, <span class="string">'nsmallest'</span>, <span class="string">'heappushpop'</span>]</span><br></pre></td></tr></table></figure><p>这个模块提供了堆队列算法的实现，也称为优先队列算法。</p><p>堆是一个二叉树，它的每个父节点的值都只会小于或大于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的 <em>k</em> ，都有 <code>heap[k] &lt;= heap[2*k+1]</code> 和 <code>heap[k] &lt;= heap[2*k+2]</code>。 为了便于比较，不存在的元素被认为是无限大。 堆最有趣的特性在于最小的元素总是在根结点：<code>heap[0]</code>。</p><a id="more"></a><p>这个API与教材的堆算法实现有所不同，具体区别有两方面：（a）我们使用了从零开始的索引。这使得节点和其孩子节点索引之间的关系不太直观但更加适合，因为 Python 使用从零开始的索引。 （b）我们的 pop 方法返回最小的项而不是最大的项（这在教材中称为“最小堆”；而“最大堆”在教材中更为常见，因为它更适用于原地排序）。</p><p>基于这两方面，把堆看作原生的Python list也没什么奇怪的： <code>heap[0]</code> 表示最小的元素，同时 <code>heap.sort()</code> 维护了堆的不变性！</p><p>要创建一个堆，可以使用list来初始化为 <code>[]</code> ，或者你可以通过一个函数 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heapify" target="_blank" rel="noopener"><code>heapify()</code></a> ，来把一个list转换成堆。</p><p>定义了以下函数：</p><ul><li><p><code>heapq.heappush</code>(<em>heap</em>, <em>item</em>)</p><p>将 <em>item</em> 的值加入 <em>heap</em> 中，保持堆的不变性。</p></li><li><p><code>heapq.heappop</code>(<em>heap</em>)</p><p>弹出并返回 <em>heap</em> 的最小的元素，保持堆的不变性。如果堆为空，抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 。使用 <code>heap[0]</code> ，可以只访问最小的元素而不弹出它。</p></li><li><p><code>heapq.heappushpop</code>(<em>heap</em>, <em>item</em>)</p><p>将 <em>item</em> 放入堆中，然后弹出并返回 <em>heap</em> 的最小元素。该组合操作比先调用  <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappush" target="_blank" rel="noopener"><code>heappush()</code></a> 再调用 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappop" target="_blank" rel="noopener"><code>heappop()</code></a> 运行起来更有效率。</p></li><li><p><code>heapq.heapify</code>(<em>x</em>)</p><p>将list <em>x</em> 转换成堆，原地，线性时间内。</p></li><li><p><code>heapq.heapreplace</code>(<em>heap</em>, <em>item</em>)</p><p>弹出并返回 <em>heap</em> 中最小的一项，同时推入新的 <em>item</em>。 堆的大小不变。 如果堆为空则引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a>。这个单步骤操作比 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappop" target="_blank" rel="noopener"><code>heappop()</code></a> 加 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappush" target="_blank" rel="noopener"><code>heappush()</code></a> 更高效，并且在使用固定大小的堆时更为适宜。 pop/push 组合总是会从堆中返回一个元素并将其替换为 <em>item</em>。返回的值可能会比添加的 <em>item</em> 更大。 如果不希望如此，可考虑改用 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappushpop" target="_blank" rel="noopener"><code>heappushpop()</code></a>。 它的 push/pop 组合会返回两个值中较小的一个，将较大的值留在堆中。</p></li></ul><p>该模块还提供了三个基于堆的通用功能函数。</p><ul><li><p><code>heapq.merge</code>(*<em>iterables</em>, <em>key=None</em>, <em>reverse=False</em>)</p><p>将多个已排序的输入合并为一个已排序的输出（例如，合并来自多个日志文件的带时间戳的条目）。 返回已排序值的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a>。类似于 <code>sorted(itertools.chain(*iterables))</code> 但返回一个可迭代对象，不会一次性地将数据全部放入内存，并假定每个输入流都是已排序的（从小到大）。具有两个可选参数，它们都必须指定为关键字参数。<em>key</em> 指定带有单个参数的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-key-function" target="_blank" rel="noopener">key function</a>，用于从每个输入元素中提取比较键。 默认值为 <code>None</code> (直接比较元素)。<em>reverse</em> 为一个布尔值。 如果设为 <code>True</code>，则输入元素将按比较结果逆序进行合并。 要达成与 <code>sorted(itertools.chain(*iterables), reverse=True)</code> 类似的行为，所有可迭代对象必须是已从大到小排序的。<em>在 3.5 版更改:</em> 添加了可选的 <em>key</em> 和 <em>reverse</em> 形参。</p></li><li><p><code>heapq.nlargest</code>(<em>n</em>, <em>iterable</em>, <em>key=None</em>)</p><p>从 <em>iterable</em> 所定义的数据集中返回前 <em>n</em> 个最大元素组成的列表。 如果提供了 <em>key</em> 则其应指定一个单参数的函数，用于从 <em>iterable</em> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key, reverse=True)[:n]</code>。</p></li><li><p><code>heapq.nsmallest</code>(<em>n</em>, <em>iterable</em>, <em>key=None</em>)</p><p>从 <em>iterable</em> 所定义的数据集中返回前 <em>n</em> 个最小元素组成的列表。 如果提供了 <em>key</em> 则其应指定一个单参数的函数，用于从 <em>iterable</em> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key)[:n]</code>。</p></li></ul><p>后两个函数在 <em>n</em> 值较小时性能最好。 对于更大的值，使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> 函数会更有效率。 此外，当 <code>n==1</code> 时，使用内置的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#min" target="_blank" rel="noopener"><code>min()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#max" target="_blank" rel="noopener"><code>max()</code></a> 函数会更有效率。 如果需要重复使用这些函数，请考虑将可迭代对象转为真正的堆。</p><h3 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h3><p><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">堆排序</a> 可以通过将所有值推入堆中然后每次弹出一个最小值项来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span><span class="params">(iterable)</span>:</span></span><br><span class="line"><span class="meta">... </span>    h = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line"><span class="meta">... </span>        heappush(h, value)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> [heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(h))]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapsort([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>])</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>这类似于 <code>sorted(iterable)</code>，但与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> 不同的是这个实现是不稳定的。</p><p>堆元素可以为元组。</p><p> 这适用于将比较值（例如任务优先级）与跟踪的主记录进行赋值的场合:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">5</span>, <span class="string">'write code'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">7</span>, <span class="string">'release product'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">1</span>, <span class="string">'write spec'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">3</span>, <span class="string">'create tests'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappop(h)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'write spec'</span>)</span><br></pre></td></tr></table></figure><h3 id="优先队列实现说明"><a href="#优先队列实现说明" class="headerlink" title="优先队列实现说明"></a>优先队列实现说明</h3><p><a href="https://en.wikipedia.org/wiki/Priority_queue" target="_blank" rel="noopener">优先队列</a> 是堆的常用场合，并且它的实现包含了多个挑战：</p><ul><li>排序稳定性：你该如何令相同优先级的两个任务按它们最初被加入时的顺序返回？</li><li>如果优先级相同且任务没有默认比较顺序，则 (priority, task) 对的元组比较将会中断。</li><li>如果任务优先级发生改变，你该如何将其移至堆中的新位置？</li><li>或者如果一个挂起的任务需要被删除，你该如何找到它并将其移出队列？</li></ul><p>针对前两项挑战的一种解决方案是将条目保存为包含优先级、条目计数和任务对象 3 个元素的列表。 条目计数可用来打破平局，这样具有相同优先级的任务将按它们的添加顺序返回。 并且由于没有哪两个条目计数是相同的，元组比较将永远不会直接比较两个任务。</p><p>不可比较任务问题的另一种解决方案是创建一个忽略任务条目并且只比较优先级字段的包装器类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Any</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass(order=True)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedItem</span>:</span></span><br><span class="line">    priority: int</span><br><span class="line">    item: Any=field(compare=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>其余的挑战主要包括找到挂起的任务并修改其优先级或将其完全移除。 找到一个任务可使用一个指向队列中条目的字典来实现。</p><p>移除条目或改变其优先级的操作实现起来更为困难，因为它会破坏堆结构不变量。 因此，一种可能的解决方案是将条目标记为已移除，再添加一个改变了优先级的新条目:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pq = []                         <span class="comment"># list of entries arranged in a heap</span></span><br><span class="line">entry_finder = &#123;&#125;               <span class="comment"># mapping of tasks to entries</span></span><br><span class="line">REMOVED = <span class="string">'&lt;removed-task&gt;'</span>      <span class="comment"># placeholder for a removed task</span></span><br><span class="line">counter = itertools.count()     <span class="comment"># unique sequence count</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_task</span><span class="params">(task, priority=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'Add a new task or update the priority of an existing task'</span></span><br><span class="line">    <span class="keyword">if</span> task <span class="keyword">in</span> entry_finder:</span><br><span class="line">        remove_task(task)</span><br><span class="line">    count = next(counter)</span><br><span class="line">    entry = [priority, count, task]</span><br><span class="line">    entry_finder[task] = entry</span><br><span class="line">    heappush(pq, entry)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_task</span><span class="params">(task)</span>:</span></span><br><span class="line">    <span class="string">'Mark an existing task as REMOVED.  Raise KeyError if not found.'</span></span><br><span class="line">    entry = entry_finder.pop(task)</span><br><span class="line">    entry[<span class="number">-1</span>] = REMOVED</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pop_task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'Remove and return the lowest priority task. Raise KeyError if empty.'</span></span><br><span class="line">    <span class="keyword">while</span> pq:</span><br><span class="line">        priority, count, task = heappop(pq)</span><br><span class="line">        <span class="keyword">if</span> task <span class="keyword">is</span> <span class="keyword">not</span> REMOVED:</span><br><span class="line">            <span class="keyword">del</span> entry_finder[task]</span><br><span class="line">            <span class="keyword">return</span> task</span><br><span class="line">    <span class="keyword">raise</span> KeyError(<span class="string">'pop from an empty priority queue'</span>)</span><br></pre></td></tr></table></figure><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>堆是通过数组来实现的，其中的元素从 0 开始计数，对于所有的 <em>k</em> 都有 <code>a[k] &lt;= a[2*k+1]</code> 且 <code>a[k] &lt;= a[2*k+2]</code>。 为了便于比较，不存在的元素被视为无穷大。 堆最有趣的特性在于 <code>a[0]</code> 总是其中最小的元素。</p><p>上面的特殊不变量是用来作为一场锦标赛的高效内存表示。 下面的数字是 <em>k</em> 而不是 <code>a[k]</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">              <span class="number">1</span>                               <span class="number">2</span></span><br><span class="line"></span><br><span class="line">      <span class="number">3</span>               <span class="number">4</span>                <span class="number">5</span>               <span class="number">6</span></span><br><span class="line"></span><br><span class="line">  <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span>      <span class="number">11</span>      <span class="number">12</span>      <span class="number">13</span>      <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span> <span class="number">16</span>   <span class="number">17</span> <span class="number">18</span>   <span class="number">19</span> <span class="number">20</span>   <span class="number">21</span> <span class="number">22</span>   <span class="number">23</span> <span class="number">24</span>   <span class="number">25</span> <span class="number">26</span>   <span class="number">27</span> <span class="number">28</span>   <span class="number">29</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>在上面的树中，每个 <em>k</em> 单元都位于 <code>2*k+1</code> 和 <code>2*k+2</code> 之上。 体育运动中我们经常见到二元锦标赛模式，每个胜者单元都位于另两个单元之上，并且我们可以沿着树形图向下追溯胜者所遇到的所有对手。 但是，在许多采用这种锦标赛模式的计算机应用程序中，我们并不需要追溯胜者的历史。 为了获得更高的内存利用效率，当一个胜者晋级时，我们会用较低层级的另一条目来替代它，因此规则变为一个单元和它之下的两个单元包含三个不同条目，上方单元“胜过”了两个下方单元。</p><p>如果此堆的不变量始终受到保护，则序号 0 显然是最后的赢家。 删除它并找出“下一个”赢家的最简单算法方式是家某个输家（让我们假定是上图中的 30 号单元）移至 0 号位置，然后将这个新的 0 号沿树下行，不断进行值的交换，直到不变量重新建立。 这显然会是树中条目总数的对数。 通过迭代所有条目，你将得到一个 O(n log n) 复杂度的排序。</p><p>此排序有一个很好的特性就是你可以在排序进行期间高效地插入新条目，前提是插入的条目不比你最近取出的 0 号元素“更好”。 这在模拟上下文时特别有用，在这种情况下树保存的是所有传入事件，“胜出”条件是最小调度时间。 当一个事件将其他事件排入执行计划时，它们的调试时间向未来方向延长，这样它们可方便地入堆。 因此，堆结构很适宜用来实现调度器，我的 MIDI 音序器就是用的这个 :-)。</p><p>用于实现调度器的各种结构都得到了充分的研究，堆是非常适宜的一种，因为它们的速度相当快，并且几乎是恒定的，最坏的情况与平均情况没有太大差别。 虽然还存在其他总体而言更高效的实现方式，但其最坏的情况却可能非常糟糕。</p><p>堆在大磁盘排序中也非常有用。 你应该已经了解大规模排序会有多个“运行轮次”（即预排序的序列，其大小通常与 CPU 内存容量相关），随后这些轮次会进入合并通道，轮次合并的组织往往非常巧妙 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#id2" target="_blank" rel="noopener">1</a>。 非常重要的一点是初始排序应产生尽可能长的运行轮次。 锦标赛模式是达成此目标的好办法。 如果你使用全部有用内存来进行锦标赛，替换和安排恰好适合当前运行轮次的条目，你将可以对于随机输入生成两倍于内存大小的运行轮次，对于模糊排序的输入还会有更好的效果。</p><p>另外，如果你输出磁盘上的第 0 个条目并获得一个可能不适合当前锦标赛的输入（因为其值要“胜过”上一个输出值），它无法被放入堆中，因此堆的尺寸将缩小。 被释放的内存可以被巧妙地立即重用以逐步构建第二个堆，其增长速度与第一个堆的缩减速度正好相同。 当第一个堆完全消失时，你可以切换新堆并启动新的运行轮次。 这样做既聪明又高效！</p><p>总之，堆是值得了解的有用内存结构。 我在一些应用中用到了它们，并且认为保留一个 ‘heap’ 模块是很有意义的。 :-)</p><h3 id="堆排序图例"><a href="#堆排序图例" class="headerlink" title="堆排序图例"></a>堆排序图例</h3><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200117_heapq.gif?raw=true" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;python-标准库-堆队列算法-heapq&quot;&gt;&lt;a href=&quot;#python-标准库-堆队列算法-heapq&quot; class=&quot;headerlink&quot; title=&quot;python 标准库  堆队列算法 heapq&quot;&gt;&lt;/a&gt;python 标准库  堆队列算法 heapq&lt;/h2&gt;&lt;p&gt;每日一词:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pollen &lt;/p&gt;
&lt;p&gt;n 花粉&lt;/p&gt;
&lt;p&gt;例句:&lt;/p&gt;
&lt;p&gt;Good news for all you hay fever and asthma sufferers&lt;br&gt;对于花粉症和哮喘病患者是个好消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天是小年,祝大家心想事成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200117_happiness.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;源码：&lt;/strong&gt;&lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/heapq.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lib/heapq.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要模块和方法：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__all__ = [&lt;span class=&quot;string&quot;&gt;&#39;heappush&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;heappop&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;heapify&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;heapreplace&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;merge&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&#39;nlargest&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;nsmallest&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;heappushpop&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模块提供了堆队列算法的实现，也称为优先队列算法。&lt;/p&gt;
&lt;p&gt;堆是一个二叉树，它的每个父节点的值都只会小于或大于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的 &lt;em&gt;k&lt;/em&gt; ，都有 &lt;code&gt;heap[k] &amp;lt;= heap[2*k+1]&lt;/code&gt; 和 &lt;code&gt;heap[k] &amp;lt;= heap[2*k+2]&lt;/code&gt;。 为了便于比较，不存在的元素被认为是无限大。 堆最有趣的特性在于最小的元素总是在根结点：&lt;code&gt;heap[0]&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="heapq" scheme="https://pinghailinfeng.gitee.io/tags/heapq/"/>
    
  </entry>
  
  <entry>
    <title>python standard library calendar</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/16/python-standard-library-calendar/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/16/python-standard-library-calendar/</id>
    <published>2020-01-16T00:50:37.000Z</published>
    <updated>2020-01-19T00:52:18.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-calendar"><a href="#python-标准库-calendar" class="headerlink" title="python 标准库 calendar"></a>python 标准库 calendar</h1><p>每日一词:</p><blockquote><p>calendar</p><p> <strong>英</strong> [ˈkælɪndə(r)]    <strong>美</strong> [ˈkælɪndər] </p><ul><li>n. 日历；[天] 历法；日程表</li><li>vt. 将…列入表中；将…排入日程表</li></ul><p>短语</p><p><strong><a href="http://dict.youdao.com/w/eng/chinese_calendar/#keyfrom=dict.phrase.wordgroup" target="_blank" rel="noopener">chinese calendar</a></strong> 中国传统历法 ; 阴历 ; 中国农历</p><p><strong><a href="http://dict.youdao.com/w/eng/lunar_calendar/#keyfrom=dict.phrase.wordgroup" target="_blank" rel="noopener">lunar calendar</a></strong> 阴历 ; 夏历 ; 来自日月星辰的力量 ; 太阴历</p><p><strong><a href="http://dict.youdao.com/w/eng/solar_calendar/#keyfrom=dict.phrase.wordgroup" target="_blank" rel="noopener">solar calendar</a></strong> 太阳历 ; 公历 ; 阳历与阴历</p></blockquote><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200116_canlendar_3.png?raw=true" alt></p><p>还有几天就过年了,2020年充满了期待,你呢？</p><p>今天我们学习python 标准库 calendar 。</p><blockquote><p>输出像 Unix <strong>cal</strong> 那样的日历，它还提供了其它与日历相关的实用函数。 默认情况下，这些日历把星期一当作一周的第一天，星期天为一周的最后一天（按照欧洲惯例）。 可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.setfirstweekday" target="_blank" rel="noopener"><code>setfirstweekday()</code></a> 方法设置一周的第一天为星期天 (6) 或者其它任意一天。 使用整数作为指定日期的参数。 更多相关的函数，参见 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#module-datetime" target="_blank" rel="noopener"><code>datetime</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块。 </p></blockquote><p> 在这个模块中定义的函数和类都基于一个理想化的日历，现行公历向过去和未来两个方向无限扩展。这与 Dershowitz 和 Reingold 的书 “历法计算” 中所有计算的基本日历 – “proleptic Gregorian” 日历的定义相符合。 ISO 8601标准还规定了 0 和 负数年份。0年指公元前1年， -1年指公元前2年，依此类推 .</p><a id="more"></a><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p> <strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/calendar.py" target="_blank" rel="noopener">Lib/calendar.py</a> </p><p>主要类和方法,节选自源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">"IllegalMonthError"</span>, <span class="string">"IllegalWeekdayError"</span>, <span class="string">"setfirstweekday"</span>,</span><br><span class="line">           <span class="string">"firstweekday"</span>, <span class="string">"isleap"</span>, <span class="string">"leapdays"</span>, <span class="string">"weekday"</span>, <span class="string">"monthrange"</span>,</span><br><span class="line">           <span class="string">"monthcalendar"</span>, <span class="string">"prmonth"</span>, <span class="string">"month"</span>, <span class="string">"prcal"</span>, <span class="string">"calendar"</span>,</span><br><span class="line">           <span class="string">"timegm"</span>, <span class="string">"month_name"</span>, <span class="string">"month_abbr"</span>, <span class="string">"day_name"</span>, <span class="string">"day_abbr"</span>,</span><br><span class="line">           <span class="string">"Calendar"</span>, <span class="string">"TextCalendar"</span>, <span class="string">"HTMLCalendar"</span>, <span class="string">"LocaleTextCalendar"</span>,</span><br><span class="line">           <span class="string">"LocaleHTMLCalendar"</span>, <span class="string">"weekheader"</span>]</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="class-calendar-Calendar-firstweekday-0-¶"><a href="#class-calendar-Calendar-firstweekday-0-¶" class="headerlink" title="class calendar.Calendar(firstweekday=0)¶"></a><em>class</em> <code>calendar.Calendar</code>(<em>firstweekday=0</em>)<a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar" target="_blank" rel="noopener">¶</a></h3><p>创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar" target="_blank" rel="noopener"><code>Calendar</code></a> 对象。 <em>firstweekday</em> 是一个整数，用于指定一周的第一天。 <code>0</code> 是星期一（默认值），<code>6</code> 是星期天。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar" target="_blank" rel="noopener"><code>Calendar</code></a> 对象提供了一些可被用于准备日历数据格式化的方法。 这个类本身不执行任何格式化操作。 这部分任务应由子类来完成。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar" target="_blank" rel="noopener"><code>Calendar</code></a> 类的实例有下列方法：</p><ul><li><p><code>iterweekdays</code>()</p><p>返回一个迭代器，迭代器的内容为一星期的数字。迭代器的第一个值与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.firstweekday" target="_blank" rel="noopener"><code>firstweekday</code></a> 属性的值一至。</p></li><li><p><code>itermonthdates</code>(<em>year</em>, <em>month</em>)</p><p>返回一个迭代器，迭代器的内容为 <em>year</em> 年 <em>month</em> 月(1-12)的日期。这个迭代器返回当月的所有日期 ( <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 对象)，日期包含了本月头尾用于组成完整一周的日期。</p></li><li><p><code>itermonthdays</code>(<em>year</em>, <em>month</em>)</p><p>返回一个迭代器，迭代器的内容与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.itermonthdates" target="_blank" rel="noopener"><code>itermonthdates()</code></a> 类似，为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 范围限制。返回的日期为当月每一天的日期对应的天数。对于不在当月的日期，显示为 <code>0</code>。</p></li><li><p><code>itermonthdays2</code>(<em>year</em>, <em>month</em>)</p><p>返回一个迭代器，迭代器的内容与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.itermonthdates" target="_blank" rel="noopener"><code>itermonthdates()</code></a> 类似为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 范围的限制。迭代器中的元素为一个由日期和代表星期几的数字组成的的元组。</p></li><li><p><code>itermonthdays3</code>(<em>year</em>, <em>month</em>)</p><p>返回一个迭代器，迭代器的内容与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.itermonthdates" target="_blank" rel="noopener"><code>itermonthdates()</code></a> 类似为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 范围的限制。迭代器的元素为一个由年，月，日组成的元组。<em>3.7 新版功能.</em></p></li><li><p><code>itermonthdays4</code>(<em>year</em>, <em>month</em>)</p><p>返回一个迭代器，迭代器的内容与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.itermonthdates" target="_blank" rel="noopener"><code>itermonthdates()</code></a> 类似为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 范围的限制。迭代器的元素为一个由年，月，日和代表星期几的数字组成的元组。<em>3.7 新版功能.</em></p></li><li><p><code>monthdatescalendar</code>(<em>year</em>, <em>month</em>)</p><p>返回一个表示指定年月的周列表。周列表由七个 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 对象组成。</p></li><li><p><code>monthdays2calendar</code>(<em>year</em>, <em>month</em>)</p><p>返回一个表示指定年月的周列表。周列表由七个代表日期的数字和代表周几的数字组成的二元元组。</p></li><li><p><code>monthdayscalendar</code>(<em>year</em>, <em>month</em>)</p><p>返回一个表示指定年月的周列表。周列表由七个代表日期的数字组成。</p></li><li><p><code>yeardatescalendar</code>(<em>year</em>, <em>width=3</em>)</p><p>返回可以用来格式化的指定年月的数据。返回的值是一个列表，列表是月份组成的行。每一行包含了最多 <em>width</em> 个月(默认为3)。每个月包含了4到6周，每周包含1–7天。每一天使用 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 对象。</p></li><li><p><code>yeardays2calendar</code>(<em>year</em>, <em>width=3</em>)</p><p>返回可以用来模式化的指定年月的数据(与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.yeardatescalendar" target="_blank" rel="noopener"><code>yeardatescalendar()</code></a> 类似)。周列表的元素是由表示日期的数字和表示星期几的数字组成的元组。不在这个月的日子为0。</p></li><li><p><code>yeardayscalendar</code>(<em>year</em>, <em>width=3</em>)</p><p>返回可以用来模式化的指定年月的数据(与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.yeardatescalendar" target="_blank" rel="noopener"><code>yeardatescalendar()</code></a> 类似)。周列表的元素是表示日期的数字。不在这个月的日子为0。</p></li></ul><h3 id="class-calendar-TextCalendar-firstweekday-0"><a href="#class-calendar-TextCalendar-firstweekday-0" class="headerlink" title="class calendar.TextCalendar(firstweekday=0)"></a><em>class</em> <code>calendar.TextCalendar</code>(<em>firstweekday=0</em>)</h3><p>可以使用这个类生成纯文本日历。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar" target="_blank" rel="noopener"><code>TextCalendar</code></a> 实例有以下方法：</p><ul><li><p><code>formatmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p><p>返回一个多行字符串来表示指定年月的日历。<em>w</em> 为日期的宽度，但始终保持日期居中。<em>l</em> 指定了每星期占用的行数。以上这些还依赖于构造器或者 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.setfirstweekday" target="_blank" rel="noopener"><code>setfirstweekday()</code></a> 方法指定的周的第一天是哪一天。</p></li><li><p><code>prmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar.formatmonth" target="_blank" rel="noopener"><code>formatmonth()</code></a> 方法一样，返回一个月的日历。</p></li><li><p><code>formatyear</code>(<em>theyear</em>, <em>w=2</em>, <em>l=1</em>, <em>c=6</em>, <em>m=3</em>)</p><p>返回一个多行字符串，这个字符串为一个 <em>m</em> 列日历。可选参数 <em>w</em>, <em>l</em>, 和 <em>c</em> 分别表示日期列数， 周的行数， 和月之间的间隔。同样，以上这些还依赖于构造器或者 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.setfirstweekday" target="_blank" rel="noopener"><code>setfirstweekday()</code></a> 指定哪一天为一周的第一天。日历的第一年由平台依赖于使用的平台。</p></li><li><p><code>pryear</code>(<em>theyear</em>, <em>w=2</em>, <em>l=1</em>, <em>c=6</em>, <em>m=3</em>)</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar.formatyear" target="_blank" rel="noopener"><code>formatyear()</code></a> 方法一样，返回一整年的日历。</p></li></ul><h3 id="class-calendar-HTMLCalendar-firstweekday-0"><a href="#class-calendar-HTMLCalendar-firstweekday-0" class="headerlink" title="class calendar.HTMLCalendar(firstweekday=0)"></a><em>class</em> <code>calendar.HTMLCalendar</code>(<em>firstweekday=0</em>)</h3><p>可以使用这个类生成 HTML 日历。<code>HTMLCalendar</code> 实例有以下方法：<code>formatmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>withyear=True</em>)返回一个 HTML 表格作为指定年月的日历。 <em>withyear</em> 为真，则年份将会包含在表头，否则只显示月份。<code>formatyear</code>(<em>theyear</em>, <em>width=3</em>)返回一个 HTML 表格作为指定年份的日历。 <em>width</em> (默认为3) 用于规定每一行显示月份的数量。<code>formatyearpage</code>(<em>theyear</em>, <em>width=3</em>, <em>css=’calendar.css’</em>, <em>encoding=None</em>)返回一个完整的 HTML 页面作为指定年份的日历。 <em>width\</em>(默认为3) 用于规定每一行显示的月份数量。 *css<em> 为层叠样式表的名字。如果不使用任何层叠样式表，可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 。 </em>encoding* 为输出页面的编码 (默认为系统的默认编码)。<code>HTMLCalendar</code> 有以下属性，你可以重载它们来自定义应用日历的样式。</p><ul><li><strong><code>cssclasses</code></strong>一个对应星期一到星期天的 CSS class 列表。默认列表为</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cssclasses = [<span class="string">"mon"</span>, <span class="string">"tue"</span>, <span class="string">"wed"</span>, <span class="string">"thu"</span>, <span class="string">"fri"</span>, <span class="string">"sat"</span>, <span class="string">"sun"</span>]</span><br></pre></td></tr></table></figure><p> 可以向每天加入其它样式 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cssclasses = [<span class="string">"mon text-bold"</span>, <span class="string">"tue"</span>, <span class="string">"wed"</span>, <span class="string">"thu"</span>, <span class="string">"fri"</span>, <span class="string">"sat"</span>, <span class="string">"sun red"</span>]</span><br></pre></td></tr></table></figure><p> 需要注意的是，列表的长度必须为7。 </p><ul><li><p><strong>cssclass_noday</strong> </p><p>工作日的 CSS 类在上个月或下个月发生。 </p></li><li><p><code>cssclasses_weekday_head</code></p><p>用于标题行中的工作日名称的 CSS 类 列表。默认值与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.HTMLCalendar.cssclasses" target="_blank" rel="noopener"><code>cssclasses</code></a> 相同。<em>3.7 新版功能.</em></p></li><li><p><code>cssclass_month_head</code></p><p>月份的头 CSS 类（由 <code>formatmonthname()</code> 使用）。默认值为 <code>&quot;month&quot;</code> 。<em>3.7 新版功能.</em></p></li><li><p><code>cssclass_month</code></p><p>某个月的月历的 CSS 类（由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.HTMLCalendar.formatmonth" target="_blank" rel="noopener"><code>formatmonth()</code></a> 使用）。默认值为 <code>&quot;month&quot;</code> 。<em>3.7 新版功能.</em></p></li><li><p><code>cssclass_year</code></p><p>某年的年历的 CSS 类（由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.HTMLCalendar.formatyear" target="_blank" rel="noopener"><code>formatyear()</code></a> 使用）。默认值为 <code>&quot;year&quot;</code> 。<em>3.7 新版功能.</em></p></li><li><p><code>cssclass_year_head</code></p><p>年历的·表头 CSS 类（由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.HTMLCalendar.formatyear" target="_blank" rel="noopener"><code>formatyear()</code></a> 使用）。默认值为 <code>&quot;year&quot;</code> 。<em>3.7 新版功能.</em></p></li></ul><p>需要注意的是，尽管上面命名的样式类都是单独出现的(如： <code>cssclass_month</code> <code>cssclass_noday</code>), 但我们可以使用空格将样式类列表中的多个元素分隔开，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"text-bold text-red"</span></span><br></pre></td></tr></table></figure><p> 下面是一个如何自定义 <code>HTMLCalendar</code> 的示例 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLCal</span><span class="params">(calendar.HTMLCalendar)</span>:</span></span><br><span class="line">    cssclasses = [style + <span class="string">" text-nowrap"</span> <span class="keyword">for</span> style <span class="keyword">in</span></span><br><span class="line">                  calendar.HTMLCalendar.cssclasses]</span><br><span class="line">    cssclass_month_head = <span class="string">"text-center month-head"</span></span><br><span class="line">    cssclass_month = <span class="string">"text-center month"</span></span><br><span class="line">    cssclass_year = <span class="string">"text-italic lead"</span></span><br></pre></td></tr></table></figure><h3 id="class-calendar-LocaleTextCalendar-firstweekday-0-locale-None"><a href="#class-calendar-LocaleTextCalendar-firstweekday-0-locale-None" class="headerlink" title="class calendar.LocaleTextCalendar(firstweekday=0, locale=None)"></a><em>class</em> <code>calendar.LocaleTextCalendar</code>(<em>firstweekday=0</em>, <em>locale=None</em>)</h3><p>这个子类 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar" target="_blank" rel="noopener"><code>TextCalendar</code></a> 可以在构造函数中传递一个语言环境名称，并且返回月份和星期几的名称在特定语言环境中。如果此语言环境包含编码，则包含月份和工作日名称的所有字符串将作为 unicode 返回。</p><h3 id="class-calendar-LocaleHTMLCalendar-firstweekday-0-locale-None"><a href="#class-calendar-LocaleHTMLCalendar-firstweekday-0-locale-None" class="headerlink" title="class calendar.LocaleHTMLCalendar(firstweekday=0, locale=None)"></a><em>class</em> <code>calendar.LocaleHTMLCalendar</code>(<em>firstweekday=0</em>, <em>locale=None</em>)</h3><ul><li><p><code>calendar.setfirstweekday</code>(<em>weekday</em>)</p><p>设置每一周的开始(<code>0</code> 表示星期一，<code>6</code> 表示星期天)。calendar还提供了 <code>MONDAY</code>, <code>TUESDAY</code>, <code>WEDNESDAY</code>, <code>THURSDAY</code>, <code>FRIDAY</code>, <code>SATURDAY</code> 和 <code>SUNDAY</code> 几个常量方便使用。例如，设置每周的第一天为星期天</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line">calendar.setfirstweekday(calendar.SUNDAY)</span><br></pre></td></tr></table></figure></li><li><p><code>calendar.firstweekday</code>()</p><p>返回当前设置的每星期的第一天的数值。</p></li><li><p><code>calendar.isleap</code>(<em>year</em>)</p><p>如果 <em>year</em> 是闰年则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a> ,否则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>。</p></li><li><p><code>calendar.leapdays</code>(<em>y1</em>, <em>y2</em>)</p><p>返回在范围 <em>y1</em> 至 <em>y2</em> （包含 y1 和 y2 ）之间的闰年的年数，其中 <em>y1</em> 和 <em>y2</em> 是年份。此函数适用于跨越一个世纪变化的范围。</p></li><li><p><code>calendar.weekday</code>(<em>year</em>, <em>month</em>, <em>day</em>)</p><p>返回某年（ <code>1970</code> – …），某月（ <code>1</code> – <code>12</code> ），某日（ <code>1</code> – <code>31</code> ）是星期几（ <code>0</code> 是星期一）。</p></li><li><p><code>calendar.weekheader</code>(<em>n</em>)</p><p>返回一个包含星期几的缩写名的头。 <em>n</em> 指定星期几缩写的字符宽度。</p></li><li><p><code>calendar.monthrange</code>(<em>year</em>, <em>month</em>)</p><p>返回指定 <em>年份</em> 的指定 <em>月份</em> 的第一天是星期几和这个月的天数。</p></li><li><p><code>calendar.monthcalendar</code>(<em>year</em>, <em>month</em>)</p><p>返回表示一个月的日历的矩阵。每一行代表一周；此月份外的日子由零表示。除非由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.setfirstweekday" target="_blank" rel="noopener"><code>setfirstweekday()</code></a> 设置，否则每周以周一为始。</p></li><li><p><code>calendar.prmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p><p>打印由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.month" target="_blank" rel="noopener"><code>month()</code></a> 返回的一个月的日历。</p></li><li><p><code>calendar.month</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar" target="_blank" rel="noopener"><code>TextCalendar</code></a> 类的 <code>formatmonth()</code> 以多行字符串形式返回月份日历。</p></li><li><p><code>calendar.prcal</code>(<em>year</em>, <em>w=0</em>, <em>l=0</em>, <em>c=6</em>, <em>m=3</em>)</p><p>打印由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#module-calendar" target="_blank" rel="noopener"><code>calendar()</code></a> 返回的整年的日历。</p></li><li><p><code>calendar.calendar</code>(<em>year</em>, <em>w=2</em>, <em>l=1</em>, <em>c=6</em>, <em>m=3</em>)</p><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar" target="_blank" rel="noopener"><code>TextCalendar</code></a> 类的 <code>formatyear()</code> 返回整年的3列的日历以多行字符串的形式。</p></li><li><p><code>calendar.timegm</code>(<em>tuple</em>)</p><p>一个不相关但很好用的函数，它接受一个时间元组例如 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块中的 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#time.gmtime" target="_blank" rel="noopener"><code>gmtime()</code></a> 函数的返回并返回相应的 Unix 时间戳值，假定 1970 年开始计数， POSIX 编码。实际上， <a href="https://docs.python.org/zh-cn/3.8/library/time.html#time.gmtime" target="_blank" rel="noopener"><code>time.gmtime()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.timegm" target="_blank" rel="noopener"><code>timegm()</code></a> 是彼此相反的。</p></li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li><p><code>calendar.day_name</code></p><p>在当前语言环境下表示星期几的数组。</p></li><li><p><code>calendar.day_abbr</code></p><p>在当前语言环境下表示星期几缩写的数组。</p></li><li><p><code>calendar.month_name</code></p><p>在当前语言环境下表示一年中月份的数组。这遵循一月的月号为 1 的通常惯例，所以它的长度为 13 且 <code>month_name[0]</code> 是空字符串。</p></li><li><p><code>calendar.month_abbr</code></p><p>在当前语言环境下表示月份简写的数组。这遵循一月的月号为 1 的通常惯例，所以它的长度为 13 且 <code>month_abbr[0]</code> 是空字符串。</p></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200116_canlendar_4.png?raw=true" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> 默认情况下，这些日历将星期一作为一周的第一天，将星期日作为一周的最后一天(欧洲惯例)。不过，我们可以使用<code>setfirstweekday()</code>方法来设置一周的第一天为星期日或h者其他工作日，指定的日期以整数形式给出。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-calendar&quot;&gt;&lt;a href=&quot;#python-标准库-calendar&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 calendar&quot;&gt;&lt;/a&gt;python 标准库 calendar&lt;/h1&gt;&lt;p&gt;每日一词:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;calendar&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;英&lt;/strong&gt; [ˈkælɪndə(r)]    &lt;strong&gt;美&lt;/strong&gt; [ˈkælɪndər] &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n. 日历；[天] 历法；日程表&lt;/li&gt;
&lt;li&gt;vt. 将…列入表中；将…排入日程表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;短语&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://dict.youdao.com/w/eng/chinese_calendar/#keyfrom=dict.phrase.wordgroup&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;chinese calendar&lt;/a&gt;&lt;/strong&gt; 中国传统历法 ; 阴历 ; 中国农历&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://dict.youdao.com/w/eng/lunar_calendar/#keyfrom=dict.phrase.wordgroup&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lunar calendar&lt;/a&gt;&lt;/strong&gt; 阴历 ; 夏历 ; 来自日月星辰的力量 ; 太阴历&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://dict.youdao.com/w/eng/solar_calendar/#keyfrom=dict.phrase.wordgroup&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;solar calendar&lt;/a&gt;&lt;/strong&gt; 太阳历 ; 公历 ; 阳历与阴历&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200116_canlendar_3.png?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;还有几天就过年了,2020年充满了期待,你呢？&lt;/p&gt;
&lt;p&gt;今天我们学习python 标准库 calendar 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输出像 Unix &lt;strong&gt;cal&lt;/strong&gt; 那样的日历，它还提供了其它与日历相关的实用函数。 默认情况下，这些日历把星期一当作一周的第一天，星期天为一周的最后一天（按照欧洲惯例）。 可以使用 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.setfirstweekday&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;setfirstweekday()&lt;/code&gt;&lt;/a&gt; 方法设置一周的第一天为星期天 (6) 或者其它任意一天。 使用整数作为指定日期的参数。 更多相关的函数，参见 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/datetime.html#module-datetime&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/time.html#module-time&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; 模块。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 在这个模块中定义的函数和类都基于一个理想化的日历，现行公历向过去和未来两个方向无限扩展。这与 Dershowitz 和 Reingold 的书 “历法计算” 中所有计算的基本日历 – “proleptic Gregorian” 日历的定义相符合。 ISO 8601标准还规定了 0 和 负数年份。0年指公元前1年， -1年指公元前2年，依此类推 .&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="calendar" scheme="https://pinghailinfeng.gitee.io/tags/calendar/"/>
    
  </entry>
  
  <entry>
    <title>python standard library iterator and generator</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/15/python-standard-library-iterator-and-generator/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/15/python-standard-library-iterator-and-generator/</id>
    <published>2020-01-14T22:30:45.000Z</published>
    <updated>2020-01-17T01:00:01.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-类型：-迭代器-和-生成器"><a href="#python-标准库-类型：-迭代器-和-生成器" class="headerlink" title="python 标准库 类型： 迭代器 和 生成器"></a>python 标准库 类型： 迭代器 和 生成器</h1><p>每日英语:</p><blockquote><p> miracle n </p><p> [英]   <strong>[</strong>ˈmɪrəkl<strong>]</strong>   [美] [ <strong>ˈmɪrəkəl</strong> ]</p><p> 奇迹，圣迹，神迹； 令人惊奇的人（或事） </p></blockquote><p>推荐一个老电影：</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200115_miracle.jpg?raw=true" alt></p><p>每个人终将都会踏上自己的绿色旅程,善恶就在一念之间。愿世界美好,温情以待。</p><p>先看一张图:</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200115_python_iterator_generator.jpg?raw=true" alt></p><blockquote><p>1，迭代器协议：对象需要提供next()方法，它要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代。</p><p>2，可迭代对象：实现了迭代器协议对象。list、tuple、dict都是Iterable（可迭代对象），但不是Iterator（迭代器对象）。但可以使用内建函数iter()，把这些都变成Iterable（可迭代器对象）。</p><p>3，for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束</p></blockquote><a id="more"></a><h2 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h2><p>Python 支持在容器中进行迭代的概念。 这是通过使用两个单独方法来实现的；它们被用于允许用户自定义类对迭代的支持。 将在下文中详细描述的序列总是支持迭代方法。</p><p>容器对象要提供迭代支持，必须定义一个方法:</p><ul><li><p><code>container.__iter__</code>()</p><p>返回一个迭代器对象。 该对象需要支持下文所述的迭代器协议。 如果容器支持不同的迭代类型，则可以提供额外的方法来专门地请求不同迭代类型的迭代器。 （支持多种迭代形式的对象的例子有同时支持广度优先和深度优先遍历的树结构。） 此方法对应于 Python/C API 中 Python 对象类型结构体的 <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_iter" target="_blank" rel="noopener"><code>tp_iter</code></a> 槽位。</p></li></ul><p>迭代器对象自身需要支持以下两个方法，它们共同组成了 <em>迭代器协议</em>:</p><ul><li><p><code>iterator.__iter__</code>()</p><p>返回迭代器对象本身。 这是同时允许容器和迭代器配合 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a> 语句使用所必须的。 此方法对应于 Python/C API 中 Python 对象类型结构体的 <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_iter" target="_blank" rel="noopener"><code>tp_iter</code></a> 槽位。</p></li><li><p><code>iterator.__next__</code>()</p><p>从容器中返回下一项。 如果已经没有项可返回，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 异常。 此方法对应于 Python/C API 中 Python 对象类型结构体的 <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_iternext" target="_blank" rel="noopener"><code>tp_iternext</code></a> 槽位。</p></li></ul><p>Python 定义了几种迭代器对象以支持对一般和特定序列类型、字典和其他更特别的形式进行迭代。 除了迭代器协议的实现，特定类型的其他性质对迭代操作来说都不重要。</p><p>一旦迭代器的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法引发了 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a>，它必须一直对后续调用引发同样的异常。 不遵循此行为特性的实现将无法正常使用。</p><p>迭代器使用实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随便定义一个list</span></span><br><span class="line">listArray=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 使用iter()函数</span></span><br><span class="line">iterName=iter(listArray)</span><br><span class="line">print(iterName)</span><br><span class="line"><span class="comment"># 结果如下：是一个列表list的迭代器</span></span><br><span class="line"><span class="comment"># &lt;list_iterator object at 0x0000017B0D984278&gt;</span></span><br><span class="line"></span><br><span class="line">print(next(iterName))</span><br><span class="line">print(next(iterName))</span><br><span class="line">print(next(iterName))</span><br><span class="line">print(next(iterName))<span class="comment">#没有迭代到下一个元素，直接抛出异常</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File "python_iterator.py", line 32, in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure><p>自定义迭代器实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span></span><br><span class="line">        super(Fib, self).__init__()</span><br><span class="line">        self.max = max</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fib = self.a</span><br><span class="line">        <span class="keyword">if</span> fib &gt; self.max:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">return</span> fib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个main函数，循环遍历每一个菲波那切数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 20以内的数</span></span><br><span class="line">    fib = Fib(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fib:</span><br><span class="line">        print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="生成器类型"><a href="#生成器类型" class="headerlink" title="生成器类型"></a>生成器类型</h3><p>Python 的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 提供了一种实现迭代器协议的便捷方式。 如果容器对象 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 方法被实现为一个生成器，它将自动返回一个迭代器对象（从技术上说是一个生成器对象），该对象提供 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法。 有关生成器的更多信息可以参阅 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#yieldexpr" target="_blank" rel="noopener">yield 表达式的文档</a>。</p><h4 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 菲波那切数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'亲！没有数据了...'</span></span><br><span class="line"><span class="comment"># 调用方法，生成出10个数来</span></span><br><span class="line">f=Fib(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 使用一个循环捕获最后return 返回的值，保存在异常StopIteration的value中</span></span><br><span class="line"><span class="keyword">while</span>  <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x=next(f)</span><br><span class="line">        print(<span class="string">"f:"</span>,x)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"生成器最后的返回值是："</span>,e.value)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个列表</span></span><br><span class="line">xiaoke=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 生成器generator，类似于list，但是是把[]改为()</span></span><br><span class="line">gen=(a <span class="keyword">for</span> a  <span class="keyword">in</span> xiaoke)</span><br><span class="line"><span class="keyword">for</span>  i  <span class="keyword">in</span> gen:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment">#结果是：</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么要使用生成器？因为效率。</span></span><br><span class="line"><span class="comment"># 使用生成器表达式取代列表推导式可以同时节省 cpu 和 内存(RAM)。</span></span><br><span class="line"><span class="comment"># 如果你构造一个列表(list)的目的仅仅是传递给别的函数,</span></span><br><span class="line"><span class="comment"># 比如 传递给tuple()或者set(), 那就用生成器表达式替代吧!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本案例是直接把列表转化为元组</span></span><br><span class="line">kk=tuple(a <span class="keyword">for</span> a <span class="keyword">in</span> xiaoke)</span><br><span class="line">print(kk)</span><br><span class="line"><span class="comment">#结果是：</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python内置的一些函数，可以识别这是生成器表达式，外面有一对小括号，就是生成器</span></span><br><span class="line">result1=sum(a <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line">print(result1)</span><br><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">result2=sum([a <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">3</span>)])</span><br><span class="line">print(result2)</span><br></pre></td></tr></table></figure><h4 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h4><p>使用yield关键字实现生成器函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span>  </span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">while</span> a &lt; max:  </span><br><span class="line">        <span class="keyword">yield</span> a <span class="comment">#这时a,b值分别为1,1，当然，程序也在执行到这时，返回  </span></span><br><span class="line">        a, b = b, a+b</span><br></pre></td></tr></table></figure><p>使用yield关键字实现自定义生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span>  </span><br><span class="line">        self.max = max  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.a = <span class="number">0</span>  </span><br><span class="line">        self.b = <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">return</span> self  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        fib = self.a  </span><br><span class="line">        <span class="keyword">if</span> fib &gt; self.max:  </span><br><span class="line">            <span class="keyword">raise</span> StopIteration  </span><br><span class="line">        self.a, self.b = self.b, self.a + self.b  </span><br><span class="line">        <span class="keyword">return</span> fib  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> Fib(<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">print</span> f</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-类型：-迭代器-和-生成器&quot;&gt;&lt;a href=&quot;#python-标准库-类型：-迭代器-和-生成器&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 类型： 迭代器 和 生成器&quot;&gt;&lt;/a&gt;python 标准库 类型： 迭代器 和 生成器&lt;/h1&gt;&lt;p&gt;每日英语:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; miracle n &lt;/p&gt;
&lt;p&gt; [英]   &lt;strong&gt;[&lt;/strong&gt;ˈmɪrəkl&lt;strong&gt;]&lt;/strong&gt;   [美] [ &lt;strong&gt;ˈmɪrəkəl&lt;/strong&gt; ]&lt;/p&gt;
&lt;p&gt; 奇迹，圣迹，神迹； 令人惊奇的人（或事） &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐一个老电影：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200115_miracle.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;每个人终将都会踏上自己的绿色旅程,善恶就在一念之间。愿世界美好,温情以待。&lt;/p&gt;
&lt;p&gt;先看一张图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200115_python_iterator_generator.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1，迭代器协议：对象需要提供next()方法，它要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代。&lt;/p&gt;
&lt;p&gt;2，可迭代对象：实现了迭代器协议对象。list、tuple、dict都是Iterable（可迭代对象），但不是Iterator（迭代器对象）。但可以使用内建函数iter()，把这些都变成Iterable（可迭代器对象）。&lt;/p&gt;
&lt;p&gt;3，for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="iterator" scheme="https://pinghailinfeng.gitee.io/tags/iterator/"/>
    
      <category term="generator" scheme="https://pinghailinfeng.gitee.io/tags/generator/"/>
    
  </entry>
  
  <entry>
    <title>python standard library pickle</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/14/python-standard-library-pickle/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/14/python-standard-library-pickle/</id>
    <published>2020-01-14T02:48:51.000Z</published>
    <updated>2020-01-14T03:44:09.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-pickle"><a href="#python-标准库-pickle" class="headerlink" title="python 标准库 pickle"></a>python 标准库 pickle</h1><p>快过年了,准备了一些过节用的英语</p><blockquote><ol><li><p>传统中国节日：traditional Chinese festival</p></li><li><p>农历：lunar calendar</p></li><li><p>腊八节：Laba Festival</p></li><li><p>小年：Little New Year</p></li><li><p>除夕：Lunar New Year’s Eve</p></li><li><p>春节：the Spring Festival</p></li><li><p>正月初一：the lunar New Year’s Day</p></li><li><p>元宵节：the Lantern Festival</p></li><li><p>正月：the first month of the lunar year</p></li><li><p>二月二：Dragon Heads-raising Day</p></li></ol></blockquote><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200114_guonian1.jpg?raw=true" alt></p><p>时间过得好快,又是一年过去了。</p><h2 id="python-标准库学习之-pickle"><a href="#python-标准库学习之-pickle" class="headerlink" title="python 标准库学习之 pickle"></a>python 标准库学习之 pickle</h2><p>常用的文本处理 除了文件,数据库,json,xml 以外,python还提供了一种存储方案,这就是<code>pickle</code>。</p><blockquote><p>模块 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 实现了对一个 Python 对象结构的二进制序列化和反序列化。<em>“pickling”</em> 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 <em>“unpickling”</em> 是相反的操作，会将（来自一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a> 或者 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 的）字节流转化回一个对象层次结构。 pickling（和 unpickling）也被称为“序列化”, “编组” 或者 “平面化”。而为了避免混乱，此处采用术语 “封存 (pickling)” 和 “解封 (unpickling)”。</p></blockquote><blockquote><p><em>警告</em> :  <code>pickle</code> 模块<strong>并不安全</strong>。你只应该对你信任的数据进行unpickle操作。构建恶意的 pickle 数据来<strong>在解封时执行任意代码</strong>是可能的。绝对不要对不信任来源的数据和可能被篡改过的数据进行解封。请考虑使用 <a href="https://docs.python.org/zh-cn/3/library/hmac.html#module-hmac" target="_blank" rel="noopener"><code>hmac</code></a> 来对数据进行签名，确保数据没有被篡改。在你处理不信任数据时，更安全的序列化格式如 <a href="https://docs.python.org/zh-cn/3/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 可能更为适合。参见 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#comparison-with-json" target="_blank" rel="noopener">与 json 模块的比较</a> </p></blockquote><h3 id="源代码：-Lib-pickle-py"><a href="#源代码：-Lib-pickle-py" class="headerlink" title="源代码： Lib/pickle.py"></a><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/pickle.py" target="_blank" rel="noopener">Lib/pickle.py</a></h3><p>本节内容比较多,先看下类层次结构,有一个大体的概念(节选自源码)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Classes:</span><br><span class="line">    Pickler</span><br><span class="line">    Unpickler</span><br><span class="line">Functions:</span><br><span class="line">    dump(object, file)</span><br><span class="line">    dumps(object) -&gt; string</span><br><span class="line">    load(file) -&gt; object</span><br><span class="line">    loads(string) -&gt; object</span><br><span class="line">Misc variables:</span><br><span class="line">    __version__</span><br><span class="line">    format_version</span><br><span class="line">    compatible_formats</span><br><span class="line">    </span><br><span class="line">__all__ = [<span class="string">"PickleError"</span>, <span class="string">"PicklingError"</span>, <span class="string">"UnpicklingError"</span>, <span class="string">"Pickler"</span>,</span><br><span class="line">           <span class="string">"Unpickler"</span>, <span class="string">"dump"</span>, <span class="string">"dumps"</span>, <span class="string">"load"</span>, <span class="string">"loads"</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="数据流格式"><a href="#数据流格式" class="headerlink" title="数据流格式"></a>数据流格式</h3><p><a href="https://docs.python.org/zh-cn/3/library/pickletools.html#module-pickletools" target="_blank" rel="noopener"><code>pickletools</code></a> 模块包含了相应的工具用于分析 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 生成的数据流。<a href="https://docs.python.org/zh-cn/3/library/pickletools.html#module-pickletools" target="_blank" rel="noopener"><code>pickletools</code></a> 源码中包含了对 pickle 协议使用的操作码的大量注释。</p><p>当前共有 6 种不同的协议可用于封存操作。 使用的协议版本越高，读取所生成 pickle 对象所需的 Python 版本就要越新。</p><ul><li>v0 版协议是原始的“人类可读”协议，并且向后兼容早期版本的 Python。</li><li>v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容。</li><li>v2 版协议是在 Python 2.3 中引入的。它为存储 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-new-style-class" target="_blank" rel="noopener">new-style class</a> 提供了更高效的机制。欲了解有关第 2 版协议带来的改进，请参阅 <a href="https://www.python.org/dev/peps/pep-0307" target="_blank" rel="noopener"><strong>PEP 307</strong></a>。</li><li>v3 版协议是在 Python 3.0 中引入的。 它显式地支持 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 字节对象，不能使用 Python 2.x 解封。这是 Python 3.0-3.7 的默认协议。</li><li>v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化。它是Python 3.8使用的默认协议。有关第 4 版协议带来改进的信息，请参阅 <a href="https://www.python.org/dev/peps/pep-3154" target="_blank" rel="noopener"><strong>PEP 3154</strong></a>。</li><li>第 5 版协议是在 Python 3.8 中加入的。 它增加了对带外数据的支持，并可加速带内数据处理。 请参阅 <a href="https://www.python.org/dev/peps/pep-0574" target="_blank" rel="noopener"><strong>PEP 574</strong></a> 了解第 5 版协议所带来的改进的详情。</li></ul><h3 id="模块接口"><a href="#模块接口" class="headerlink" title="模块接口"></a>模块接口</h3><p>要序列化某个包含层次结构的对象，只需调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dumps" target="_blank" rel="noopener"><code>dumps()</code></a> 函数即可。同样，要反序列化数据流，可以调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.loads" target="_blank" rel="noopener"><code>loads()</code></a> 函数。但是，如果要对序列化和反序列化加以更多的控制，可以分别创建 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> 对象。</p><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块包含了以下常量：</p><ul><li><p><code>pickle.HIGHEST_PROTOCOL</code></p><p>整数，可用的最高 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-protocols" target="_blank" rel="noopener">协议版本</a>。此值可以作为 <em>协议</em> 值传递给 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dump" target="_blank" rel="noopener"><code>dump()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dumps" target="_blank" rel="noopener"><code>dumps()</code></a> 函数，以及 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的构造函数。</p></li><li><p><code>pickle.DEFAULT_PROTOCOL</code></p><p>整数，用于 pickle 数据的默认 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-protocols" target="_blank" rel="noopener">协议版本</a>。它可能小于 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.HIGHEST_PROTOCOL" target="_blank" rel="noopener"><code>HIGHEST_PROTOCOL</code></a>。当前默认协议是 v4，它在 Python 3.4 中首次引入，与之前的版本不兼容。<em>在 3.8 版更改:</em> 默认协议版本还是 4。</p></li></ul><h3 id="模块方法"><a href="#模块方法" class="headerlink" title="模块方法"></a>模块方法</h3><ul><li><p><code>pickle.dump</code>(<em>obj</em>, <em>file</em>, <em>protocol=None</em>, <em>**, </em>fix_imports=True<em>, </em>buffer_callback=None*)</p><p>将对象 <em>obj</em> 封存以后的对象写入已打开的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> <em>file</em>。它等同于 <code>Pickler(file, protocol).dump(obj)</code>。参数 <em>file</em>、<em>protocol</em>、<em>fix_imports</em> 和 <em>buffer_callback</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的构造函数中的含义相同。<em>在 3.8 版更改:</em> 加入了 <em>buffer_callback</em> 参数。</p></li><li><p><code>pickle.dumps</code>(<em>obj</em>, <em>protocol=None</em>, <em>**, </em>fix_imports=True<em>, </em>buffer_callback=None*)</p><p>将 <em>obj</em> 封存以后的对象作为 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型直接返回，而不是将其写入到文件。参数 <em>protocol</em>、<em>fix_imports</em> 和 <em>buffer_callback</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的构造函数中的含义相同。<em>在 3.8 版更改:</em> 加入了 <em>buffer_callback</em> 参数。</p></li><li><p><code>pickle.load</code>(<em>file</em>, <em>**, </em>fix_imports=True<em>, </em>encoding=”ASCII”<em>, </em>errors=”strict”<em>, </em>buffers=None*)</p><p>从已打开的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> <em>文件</em> 中读取封存后的对象，重建其中特定对象的层次结构并返回。它相当于 <code>Unpickler(file).load()</code>。Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。封存对象以外的其他字节将被忽略。参数 <em>file</em>、<em>fix_imports</em>、<em>encoding</em>、<em>errors</em>、<em>strict</em> 和 <em>buffers</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> 的构造函数中的含义相同。<em>在 3.8 版更改:</em> 加入了 <em>buffers</em> 参数。</p></li><li><p><code>pickle.loads</code>(<em>bytes_object</em>, <em>**, </em>fix_imports=True<em>, </em>encoding=”ASCII”<em>, </em>errors=”strict”<em>, </em>buffers=None*)</p><p>对于封存生成的对象 <em>bytes_object</em>，还原出原对象的结构并返回。Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。封存对象以外的其他字节将被忽略。参数 <em>file</em>、<em>fix_imports</em>、<em>encoding</em>、<em>errors</em>、<em>strict</em> 和 <em>buffers</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> 的构造函数中的含义相同。</p></li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块定义了以下 3 个异常：</p><ul><li><p><em>exception</em> <code>pickle.PickleError</code></p><p>其他 pickle 异常的基类。它是 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>pickle.PicklingError</code></p><p>当 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 遇到无法解封的对象时抛出此错误。它是 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleError" target="_blank" rel="noopener"><code>PickleError</code></a> 的子类。参考 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-picklable" target="_blank" rel="noopener">可以被封存/解封的对象</a> 来了解哪些对象可以被封存。</p></li><li><p><em>exception</em> <code>pickle.UnpicklingError</code></p><p>当解封出错时抛出此异常，例如数据损坏或对象不安全。它是 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleError" target="_blank" rel="noopener"><code>PickleError</code></a> 的子类。注意，解封时可能还会抛出其他异常，包括（但不限于） AttributeError、EOFError、ImportError 和 IndexError。</p></li></ul><h3 id="模块中的类"><a href="#模块中的类" class="headerlink" title="模块中的类"></a>模块中的类</h3><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块包含了 3 个类，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a>、<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a>：</p><h4 id="Pickler"><a href="#Pickler" class="headerlink" title="Pickler"></a>Pickler</h4><p><em>class</em> <code>pickle.Pickler</code>(<em>file</em>, <em>protocol=None</em>, <em>**, </em>fix_imports=True<em>, </em>buffer_callback=None*)</p><p>它接受一个二进制文件用于写入 pickle 数据流。</p><p>可选参数 <em>protocol</em> 是一个整数，告知 pickler 使用指定的协议，可选择的协议范围从 0 到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.HIGHEST_PROTOCOL" target="_blank" rel="noopener"><code>HIGHEST_PROTOCOL</code></a>。如果没有指定，这一参数默认值为 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.DEFAULT_PROTOCOL" target="_blank" rel="noopener"><code>DEFAULT_PROTOCOL</code></a>。指定一个负数就相当于指定 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.HIGHEST_PROTOCOL" target="_blank" rel="noopener"><code>HIGHEST_PROTOCOL</code></a>。</p><p>参数 <em>file</em> 必须有一个 write() 方法，该 write() 方法要能接收字节作为其唯一参数。因此，它可以是一个打开的磁盘文件（用于写入二进制内容），也可以是一个 <a href="https://docs.python.org/zh-cn/3/library/io.html#io.BytesIO" target="_blank" rel="noopener"><code>io.BytesIO</code></a> 实例，也可以是满足这一接口的其他任何自定义对象。</p><p>如果 <em>fix_imports</em> 为 True 且 <em>protocol</em> 小于 3，pickle 将尝试将 Python 3 中的新名称映射到 Python 2 中的旧模块名称，因此 Python 2 也可以读取封存的数据流。</p><p>如果 <em>buffer_callback</em> 为 None（默认情况），缓冲区视图（buffer view）将会作为 pickle 流的一部分被序列化到 <em>file</em> 中。</p><p>如果 <em>buffer_callback</em> 不为 None，那它可以用缓冲区视图调用任意次。如果某次调用返回了 False 值（例如 None），则给定的缓冲区是 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-oob" target="_blank" rel="noopener">带外的</a>，否则缓冲区是带内的（例如保存在了 pickle 流里面）。</p><p>如果 <em>buffer_callback</em> 不是 None 且 <em>protocol</em> 是 None 或小于 5，就会出错。</p><p><em>在 3.8 版更改:</em> 加入了 <em>buffer_callback</em> 参数。</p><ul><li><p><code>dump</code>(<em>obj</em>)</p><p>将 <em>obj</em> 封存后的内容写入已打开的文件对象，该文件对象已经在构造函数中指定。</p></li><li><p><code>persistent_id</code>(<em>obj</em>)</p><p>默认无动作，子类继承重载时使用。如果 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.persistent_id" target="_blank" rel="noopener"><code>persistent_id()</code></a> 返回 <code>None</code>，<em>obj</em> 会被照常 pickle。如果返回其他值，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 会将这个函数的返回值作为 <em>obj</em> 的持久化 ID（Pickler 本应得到序列化数据流并将其写入文件，若此函数有返回值，则得到此函数的返回值并写入文件）。这个持久化 ID 的解释应当定义在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.persistent_load" target="_blank" rel="noopener"><code>Unpickler.persistent_load()</code></a> 中（该方法定义还原对象的过程，并返回得到的对象）。注意，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.persistent_id" target="_blank" rel="noopener"><code>persistent_id()</code></a> 的返回值本身不能拥有持久化 ID。参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-persistent" target="_blank" rel="noopener">持久化外部对象</a> 获取详情和使用示例。</p></li><li><p><code>dispatch_table</code></p><p>Pickler 对象的 dispatch 表是 <a href="https://docs.python.org/zh-cn/3/library/copyreg.html#copyreg.pickle" target="_blank" rel="noopener"><code>copyreg.pickle()</code></a> 中用到的 <em>reduction 函数</em> 的注册。dispatch 表本身是一个 class 到其 reduction 函数的映射键值对。一个 reduction 函数只接受一个参数，就是其关联的 class，函数行为应当遵守 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 接口规范。Pickler 对象默认并没有 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 属性，该对象默认使用 <a href="https://docs.python.org/zh-cn/3/library/copyreg.html#module-copyreg" target="_blank" rel="noopener"><code>copyreg</code></a> 模块中定义的全局 dispatch 表。如果要为特定 Pickler 对象自定义序列化过程，可以将 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 属性设置为类字典对象（dict-like object）。另外，如果 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的子类设置了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 属性，则该子类的实例会使用这个表作为默认的 dispatch 表。参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-dispatch" target="_blank" rel="noopener">Dispatch 表</a> 获取使用示例。<em>3.3 新版功能.</em></p></li><li><p><code>reducer_override</code>(<em>self</em>, <em>obj</em>)</p><p>可以在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的子类中定义的特殊 reducer。此方法的优先级高于 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 中的任何 reducer。它应该与 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 方法遵循相同的接口，它也可以返回 <code>NotImplemented</code>，这将使用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 里注册的 reducer 来封存 <code>obj</code>。</p></li></ul><h4 id="Unpickler"><a href="#Unpickler" class="headerlink" title="Unpickler"></a>Unpickler</h4><p><em>class</em> <code>pickle.Unpickler</code>(<em>file</em>, <em>**, </em>fix_imports=True<em>, </em>encoding=”ASCII”<em>, </em>errors=”strict”<em>, </em>buffers=None*)</p><p>它接受一个二进制文件用于读取 pickle 数据流。</p><p>Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。</p><p>参数 <em>file</em> 必须有三个方法，read() 方法接受一个整数参数，readinto() 方法接受一个缓冲区作为参数，readline() 方法不需要参数，这与 <a href="https://docs.python.org/zh-cn/3/library/io.html#io.BufferedIOBase" target="_blank" rel="noopener"><code>io.BufferedIOBase</code></a> 里定义的接口是相同的。因此 <em>file</em> 可以是一个磁盘上用于二进制读取的文件，也可以是一个 <a href="https://docs.python.org/zh-cn/3/library/io.html#io.BytesIO" target="_blank" rel="noopener"><code>io.BytesIO</code></a> 实例，也可以是满足这一接口的其他任何自定义对象。</p><p>可选的参数是 <em>fix_imports</em>, <em>encoding</em> 和 <em>errors</em>，用于控制由Python 2 生成的 pickle 流的兼容性。如果 <em>fix_imports</em> 为 True，则 pickle 将尝试将旧的 Python 2 名称映射到 Python 3 中对应的新名称。<em>encoding</em> 和 <em>errors</em> 参数告诉 pickle 如何解码 Python 2 存储的 8 位字符串实例；这两个参数默认分别为 ‘ASCII’ 和 ‘strict’。<em>encoding</em> 参数可置为 ‘bytes’ 来将这些 8 位字符串实例读取为字节对象。读取 NumPy array 和 Python 2 存储的 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime" target="_blank" rel="noopener"><code>datetime</code></a>、<a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>date</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" target="_blank" rel="noopener"><code>time</code></a> 实例时，请使用 <code>encoding=&#39;latin1&#39;</code>。</p><p>如果 <em>buffers</em> 为 None（默认值），则反序列化所需的所有数据都必须包含在 pickle 流中。这意味着在实例化 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 时（或调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dump" target="_blank" rel="noopener"><code>dump()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dumps" target="_blank" rel="noopener"><code>dumps()</code></a> 时），参数 <em>buffer_callback</em> 为 None。</p><p>如果 <em>buffers</em> 不为 None，则每次 pickle 流引用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-oob" target="_blank" rel="noopener">带外</a> 缓冲区视图时，消耗的对象都应该是可迭代的启用缓冲区的对象。这样的缓冲区应该按顺序地提供给 Pickler 对象的 <em>buffer_callback</em> 方法。</p><p><em>在 3.8 版更改:</em> 加入了 <em>buffers</em> 参数。</p><ul><li><p><code>load</code>()</p><p>从构造函数中指定的文件对象里读取封存好的对象，重建其中特定对象的层次结构并返回。封存对象以外的其他字节将被忽略。</p></li><li><p><code>persistent_load</code>(<em>pid</em>)</p><p>默认抛出 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.UnpicklingError" target="_blank" rel="noopener"><code>UnpicklingError</code></a> 异常。如果定义了此方法，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.persistent_load" target="_blank" rel="noopener"><code>persistent_load()</code></a> 应当返回持久化 ID <em>pid</em> 所指定的对象。 如果遇到无效的持久化 ID，则应当引发 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.UnpicklingError" target="_blank" rel="noopener"><code>UnpicklingError</code></a>。参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-persistent" target="_blank" rel="noopener">持久化外部对象</a> 获取详情和使用示例。</p></li><li><p><code>find_class</code>(<em>module</em>, <em>name</em>)</p><p>如有必要，导入 <em>module</em> 模块并返回其中名叫 <em>name</em> 的对象，其中 <em>module</em> 和 <em>name</em> 参数都是 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 对象。注意，不要被这个函数的名字迷惑， <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.find_class" target="_blank" rel="noopener"><code>find_class()</code></a> 同样可以用来导入函数。子类可以重载此方法，来控制加载对象的类型和加载对象的方式，从而尽可能降低安全风险。参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-restrict" target="_blank" rel="noopener">限制全局变量</a> 获取更详细的信息。引发一个 <a href="https://docs.python.org/zh-cn/3/library/sys.html#auditing" target="_blank" rel="noopener">审核事件</a> <code>pickle.find_class</code> 附带参数 <code>module</code>、<code>name</code>。</p></li></ul><h4 id="PickleBuffer"><a href="#PickleBuffer" class="headerlink" title="PickleBuffer"></a>PickleBuffer</h4><p><em>class</em> <code>pickle.PickleBuffer</code>(<em>buffer</em>)</p><p>缓冲区的包装器 (wrapper)，缓冲区中包含着可封存的数据。<em>buffer</em> 必须是一个 <a href="https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects" target="_blank" rel="noopener">buffer-providing</a> 对象，比如 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 或多维数组。</p><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 本身就可以生成缓冲区对象，因此可以将其传递给需要缓冲区生成器的其他 API，比如 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview</code></a>。</p><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 对象只能用 pickle 版本 5 及以上协议进行序列化。它们符合 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-oob" target="_blank" rel="noopener">带外序列化</a> 的条件。</p><p><em>3.8 新版功能.</em></p><ul><li><p><code>raw</code>()</p><p>返回该缓冲区底层内存区域的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview</code></a>。 返回的对象是一维的、C 连续布局的 memoryview，格式为 <code>B</code> (无符号字节)。 如果缓冲区既不是 C 连续布局也不是 Fortran 连续布局的，则抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#BufferError" target="_blank" rel="noopener"><code>BufferError</code></a> 异常。</p></li><li><p><code>release</code>()</p><p>释放由 PickleBuffer 占用的底层缓冲区。</p></li></ul><h3 id="可以被封存-解封的对象"><a href="#可以被封存-解封的对象" class="headerlink" title="可以被封存/解封的对象"></a>可以被封存/解封的对象</h3><p>下列类型可以被封存：</p><ul><li><code>None</code>、<code>True</code> 和 <code>False</code></li><li>整数、浮点数、复数</li><li>str、byte、bytearray</li><li>只包含可封存对象的集合，包括 tuple、list、set 和 dict</li><li>定义在模块最外层的函数（使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#def" target="_blank" rel="noopener"><code>def</code></a> 定义，<a href="https://docs.python.org/zh-cn/3/reference/expressions.html#lambda" target="_blank" rel="noopener"><code>lambda</code></a> 函数则不可以）</li><li>定义在模块最外层的内置函数</li><li>定义在模块最外层的类</li><li>某些类实例，这些类的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 属性值或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a> 函数的返回值可以被封存（详情参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-inst" target="_blank" rel="noopener">封存类实例</a> 这一段）。</li></ul><p>尝试封存不能被封存的对象会抛出 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PicklingError" target="_blank" rel="noopener"><code>PicklingError</code></a> 异常，异常发生时，可能有部分字节已经被写入指定文件中。尝试封存递归层级很深的对象时，可能会超出最大递归层级限制，此时会抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RecursionError" target="_blank" rel="noopener"><code>RecursionError</code></a> 异常，可以通过 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.setrecursionlimit" target="_blank" rel="noopener"><code>sys.setrecursionlimit()</code></a> 调整递归层级，不过请谨慎使用这个函数，因为可能会导致解释器崩溃。</p><p><strong>注意</strong></p><ol><li><p>函数封存</p><blockquote><p>函数（内置函数或用户自定义函数）在被封存时，引用的是函数全名。<a href="https://docs.python.org/zh-cn/3/library/pickle.html#id8" target="_blank" rel="noopener">2</a> 这意味着只有函数所在的模块名，与函数名会被封存，函数体及其属性不会被封存。因此，在解封的环境中，函数所属的模块必须是可以被导入的，而且模块必须包含这个函数被封存时的名称，否则会抛出异常。</p></blockquote></li><li><p>类封存</p><blockquote><p>类也只封存名称，所以在解封环境中也有和函数相同的限制。注意，类体及其数据不会被封存，所以在下面的例子中类属性 <code>attr</code> 不会存在于解封后的环境中：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    attr = <span class="string">'A class attribute'</span></span><br><span class="line"></span><br><span class="line">picklestring = pickle.dumps(Foo)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>类的实例封存</p><blockquote><p>在封存类的实例时，其类体和类数据不会跟着实例一起被封存，只有实例数据会被封存。这样设计是有目的的，在将来修复类中的错误、给类增加方法之后，仍然可以载入原来版本类实例的封存数据来还原该实例。如果你准备长期使用一个对象，可能会同时存在较多版本的类体，可以为对象添加版本号，这样就可以通过类的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 方法将老版本转换成新版本</p></blockquote></li></ol><h3 id="封存类实例"><a href="#封存类实例" class="headerlink" title="封存类实例"></a>封存类实例</h3><blockquote><p>通常，使一个实例可被封存不需要附加任何代码。Pickle 默认会通过 Python 的内省机制获得实例的类及属性。而当实例解封时，它的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法通常 <em>不会</em> 被调用。其默认动作是：先创建一个未初始化的实例，然后还原其属性，下面的代码展示了这种行为的实现机制：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (obj.__class__, obj.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(cls, attributes)</span>:</span></span><br><span class="line">    obj = cls.__new__(cls)</span><br><span class="line">    obj.__dict__.update(attributes)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><p>类可以改变默认行为，只需定义以下一种或几种特殊方法：</p><ul><li><p><code>object.__getnewargs_ex__</code>()</p><p>对于使用第 2 版或更高版协议的 pickle，实现了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a> 方法的类可以控制在解封时传给 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 方法的参数。本方法必须返回一对 <code>(args, kwargs)</code> 用于构建对象，其中 <em>args</em> 是表示位置参数的 tuple，而 <em>kwargs</em> 是表示命名参数的 dict。它们会在解封时传递给 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 方法。如果类的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 方法只接受关键字参数，则应当实现这个方法。否则，为了兼容性，更推荐实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs__" target="_blank" rel="noopener"><code>__getnewargs__()</code></a> 方法。<em>在 3.6 版更改:</em> <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a> 现在可用于第 2 和第 3 版协议。</p></li><li><p><code>object.__getnewargs__</code>()</p><p>这个方法与上一个 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a> 方法类似，但仅支持位置参数。它要求返回一个 tuple 类型的 <code>args</code>，用于解封时传递给 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 方法。如果定义了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a>，那么 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs__" target="_blank" rel="noopener"><code>__getnewargs__()</code></a> 就不会被调用。<em>在 3.6 版更改:</em> 在 Python 3.6 前，第 2、3 版协议会调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs__" target="_blank" rel="noopener"><code>__getnewargs__()</code></a>，更高版本协议会调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a>。</p></li><li><p><code>object.__getstate__</code>()</p><p>类还可以进一步控制其实例的封存过程。如果类定义了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a>，它就会被调用，其返回的对象是被当做实例内容来封存的，否则封存的是实例的 <strong>dict</strong>。如果 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a> 未定义，实例的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 会被照常封存。</p></li><li><p><code>object.__setstate__</code>(<em>state</em>)</p><p>当解封时，如果类定义了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a>，就会在已解封状态下调用它。此时不要求实例的 state 对象必须是 dict。没有定义此方法的话，先前封存的 state 对象必须是 dict，且该 dict 内容会在解封时赋给新实例的 <strong>dict</strong>。</p><p>==备注==： 如果 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a> 返回 False，那么在解封时就不会调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 方法。 </p></li><li><p><code>object.__reduce__</code>()</p><p>该接口当前定义如下。<a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 方法不带任何参数，并且应返回字符串或最好返回一个元组（返回的对象通常称为“reduce 值”）。如果返回字符串，该字符串会被当做一个全局变量的名称。它应该是对象相对于其模块的本地名称，pickle 模块会搜索模块命名空间来确定对象所属的模块。这种行为常在单例模式使用。如果返回的是元组，则应当包含 2 到 6 个元素，可选元素可以省略或设置为 <code>None</code>。每个元素代表的意义如下：一个可调用对象，该对象会在创建对象的最初版本时调用。可调用对象的参数，是一个元组。如果可调用对象不接受参数，必须提供一个空元组。可选元素，用于表示对象的状态，将被传给前述的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 方法。 如果对象没有此方法，则这个元素必须是字典类型，并会被添加至 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 属性中。可选元素，一个返回连续项的迭代器（而不是序列）。这些项会被 <code>obj.append(item)</code> 逐个加入对象，或被 <code>obj.extend(list_of_items)</code> 批量加入对象。这个元素主要用于 list 的子类，也可以用于那些正确实现了 <code>append()</code> 和 <code>extend()</code> 方法的类。（具体是使用 <code>append()</code> 还是 <code>extend()</code> 取决于 pickle 协议版本以及待插入元素的项数，所以这两个方法必须同时被类支持。）可选元素，一个返回连续键值对的迭代器（而不是序列）。这些键值对将会以 <code>obj[key] = value</code> 的方式存储于对象中。该元素主要用于 dict 子类，也可以用于那些实现了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__setitem__" target="_blank" rel="noopener"><code>__setitem__()</code></a> 的类。可选元素，一个带有 <code>(obj, state)</code> 签名的可调用对象。该可调用对象允许用户以编程方式控制特定对象的状态更新行为，而不是使用 <code>obj</code> 的静态 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 方法。如果此处不是 <code>None</code>，则此可调用对象的优先级高于 <code>obj</code> 的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a>。<em>3.8 新版功能:</em> 新增了元组的第 6 项，可选元素 <code>(obj, state)</code>。</p></li><li><p><code>object.__reduce_ex__</code>(<em>protocol</em>)</p><p>作为替代选项，也可以实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce_ex__" target="_blank" rel="noopener"><code>__reduce_ex__()</code></a> 方法。 此方法的唯一不同之处在于它应接受一个整型参数用于指定协议版本。 如果定义了这个函数，则会覆盖 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 的行为。 此外，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 方法会自动成为扩展版方法的同义词。 这个函数主要用于为以前的 Python 版本提供向后兼容的 reduce 值。</p></li></ul><h3 id="持久化外部对象"><a href="#持久化外部对象" class="headerlink" title="持久化外部对象"></a>持久化外部对象</h3><p>为了获取对象持久化的利益， <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块支持引用已封存数据流之外的对象。 这样的对象是通过一个持久化 ID 来引用的，它应当是一个由字母数字类字符组成的字符串 (对于第 0 版协议) <a href="https://docs.python.org/zh-cn/3/library/pickle.html#id11" target="_blank" rel="noopener">5</a> 或是一个任意对象 (用于任意新版协议)。</p><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块不提供对持久化 ID 的解析工作，它将解析工作分配给用户定义的方法，分别是 pickler 中的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.persistent_id" target="_blank" rel="noopener"><code>persistent_id()</code></a> 方法和 unpickler 中的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.persistent_load" target="_blank" rel="noopener"><code>persistent_load()</code></a> 方法。</p><p>要通过持久化 ID 将外部对象封存，必须在 pickler 中实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.persistent_id" target="_blank" rel="noopener"><code>persistent_id()</code></a> 方法，该方法接受需要被封存的对象作为参数，返回一个 <code>None</code> 或返回该对象的持久化 ID。如果返回 <code>None</code>，该对象会被按照默认方式封存为数据流。如果返回字符串形式的持久化 ID，则会封存这个字符串并加上一个标记，这样 unpickler 才能将其识别为持久化 ID。</p><p>要解封外部对象，Unpickler 必须实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.persistent_load" target="_blank" rel="noopener"><code>persistent_load()</code></a> 方法，接受一个持久化 ID 对象作为参数并返回一个引用的对象。</p><p>下面是一个全面的例子，展示了如何使用持久化 ID 来封存外部对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Simple example presenting how persistent ID can be used to pickle</span></span><br><span class="line"><span class="comment"># external objects by reference.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># Simple class representing a record in our database.</span></span><br><span class="line">MemoRecord = namedtuple(<span class="string">"MemoRecord"</span>, <span class="string">"key, task"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBPickler</span><span class="params">(pickle.Pickler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">persistent_id</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="comment"># Instead of pickling MemoRecord as a regular class instance, we emit a</span></span><br><span class="line">        <span class="comment"># persistent ID.</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, MemoRecord):</span><br><span class="line">            <span class="comment"># Here, our persistent ID is simply a tuple, containing a tag and a</span></span><br><span class="line">            <span class="comment"># key, which refers to a specific record in the database.</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="string">"MemoRecord"</span>, obj.key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># If obj does not have a persistent ID, return None. This means obj</span></span><br><span class="line">            <span class="comment"># needs to be pickled as usual.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBUnpickler</span><span class="params">(pickle.Unpickler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, file, connection)</span>:</span></span><br><span class="line">        super().__init__(file)</span><br><span class="line">        self.connection = connection</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">persistent_load</span><span class="params">(self, pid)</span>:</span></span><br><span class="line">        <span class="comment"># This method is invoked whenever a persistent ID is encountered.</span></span><br><span class="line">        <span class="comment"># Here, pid is the tuple returned by DBPickler.</span></span><br><span class="line">        cursor = self.connection.cursor()</span><br><span class="line">        type_tag, key_id = pid</span><br><span class="line">        <span class="keyword">if</span> type_tag == <span class="string">"MemoRecord"</span>:</span><br><span class="line">            <span class="comment"># Fetch the referenced record from the database and return it.</span></span><br><span class="line">            cursor.execute(<span class="string">"SELECT * FROM memos WHERE key=?"</span>, (str(key_id),))</span><br><span class="line">            key, task = cursor.fetchone()</span><br><span class="line">            <span class="keyword">return</span> MemoRecord(key, task)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Always raises an error if you cannot return the correct object.</span></span><br><span class="line">            <span class="comment"># Otherwise, the unpickler will think None is the object referenced</span></span><br><span class="line">            <span class="comment"># by the persistent ID.</span></span><br><span class="line">            <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">"unsupported persistent object"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> io</span><br><span class="line">    <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize and populate our database.</span></span><br><span class="line">    conn = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(<span class="string">"CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)"</span>)</span><br><span class="line">    tasks = (</span><br><span class="line">        <span class="string">'give food to fish'</span>,</span><br><span class="line">        <span class="string">'prepare group meeting'</span>,</span><br><span class="line">        <span class="string">'fight with a zebra'</span>,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        cursor.execute(<span class="string">"INSERT INTO memos VALUES(NULL, ?)"</span>, (task,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Fetch the records to be pickled.</span></span><br><span class="line">    cursor.execute(<span class="string">"SELECT * FROM memos"</span>)</span><br><span class="line">    memos = [MemoRecord(key, task) <span class="keyword">for</span> key, task <span class="keyword">in</span> cursor]</span><br><span class="line">    <span class="comment"># Save the records using our custom DBPickler.</span></span><br><span class="line">    file = io.BytesIO()</span><br><span class="line">    DBPickler(file).dump(memos)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Pickled records:"</span>)</span><br><span class="line">    pprint.pprint(memos)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update a record, just for good measure.</span></span><br><span class="line">    cursor.execute(<span class="string">"UPDATE memos SET task='learn italian' WHERE key=1"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load the records from the pickle data stream.</span></span><br><span class="line">    file.seek(<span class="number">0</span>)</span><br><span class="line">    memos = DBUnpickler(file, conn).load()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Unpickled records:"</span>)</span><br><span class="line">    pprint.pprint(memos)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="自定义封存-Dispatch-表"><a href="#自定义封存-Dispatch-表" class="headerlink" title="自定义封存 Dispatch 表"></a>自定义封存 Dispatch 表</h3><p>如果想对某些类进行自定义封存，而又不想在类中增加用于封存的代码，就可以创建带有特殊 dispatch 表的 pickler。</p><p>在 <a href="https://docs.python.org/zh-cn/3/library/copyreg.html#module-copyreg" target="_blank" rel="noopener"><code>copyreg</code></a> 模块的 <code>copyreg.dispatch_table</code> 中定义了全局 dispatch 表。因此，可以使用 <code>copyreg.dispatch_table</code> 修改后的副本作为自有 dispatch 表。</p><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = io.BytesIO()</span><br><span class="line">p = pickle.Pickler(f)</span><br><span class="line">p.dispatch_table = copyreg.dispatch_table.copy()</span><br><span class="line">p.dispatch_table[SomeClass] = reduce_SomeClass</span><br></pre></td></tr></table></figure><p>创建了一个带有自有 dispatch 表的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>pickle.Pickler</code></a> 实例，它可以对 <code>SomeClass</code> 类进行特殊处理。另外，下列代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPickler</span><span class="params">(pickle.Pickler)</span>:</span></span><br><span class="line">    dispatch_table = copyreg.dispatch_table.copy()</span><br><span class="line">    dispatch_table[SomeClass] = reduce_SomeClass</span><br><span class="line">f = io.BytesIO()</span><br><span class="line">p = MyPickler(f)</span><br></pre></td></tr></table></figure><p>完成了相同的操作，但所有 <code>MyPickler</code> 的实例都会共用同一份 dispatch 表。使用 <a href="https://docs.python.org/zh-cn/3/library/copyreg.html#module-copyreg" target="_blank" rel="noopener"><code>copyreg</code></a> 模块实现的等效代码是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copyreg.pickle(SomeClass, reduce_SomeClass)</span><br><span class="line">f = io.BytesIO()</span><br><span class="line">p = pickle.Pickler(f)</span><br></pre></td></tr></table></figure><h3 id="处理有状态的对象"><a href="#处理有状态的对象" class="headerlink" title="处理有状态的对象"></a>处理有状态的对象</h3><blockquote><p>下面的示例展示了如何修改类在封存时的行为。其中 <code>TextReader</code> 类打开了一个文本文件，每次调用其 <code>readline()</code> 方法则返回行号和该行的字符。 在封存这个 <code>TextReader</code> 的实例时，<em>除了</em> 文件对象，其他属性都会被保存。 当解封实例时，需要重新打开文件，然后从上次的位置开始继续读取。实现这些功能需要实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a> 方法。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextReader</span>:</span></span><br><span class="line">    <span class="string">"""Print and number lines in a text file."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.file = open(filename)</span><br><span class="line">        self.lineno = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readline</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.lineno += <span class="number">1</span></span><br><span class="line">        line = self.file.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> line.endswith(<span class="string">'\n'</span>):</span><br><span class="line">            line = line[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"%i: %s"</span> % (self.lineno, line)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getstate__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Copy the object's state from self.__dict__ which contains</span></span><br><span class="line">        <span class="comment"># all our instance attributes. Always use the dict.copy()</span></span><br><span class="line">        <span class="comment"># method to avoid modifying the original state.</span></span><br><span class="line">        state = self.__dict__.copy()</span><br><span class="line">        <span class="comment"># Remove the unpicklable entries.</span></span><br><span class="line">        <span class="keyword">del</span> state[<span class="string">'file'</span>]</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setstate__</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        <span class="comment"># Restore instance attributes (i.e., filename and lineno).</span></span><br><span class="line">        self.__dict__.update(state)</span><br><span class="line">        <span class="comment"># Restore the previously opened file's state. To do so, we need to</span></span><br><span class="line">        <span class="comment"># reopen it and read from it until the line count is restored.</span></span><br><span class="line">        file = open(self.filename)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.lineno):</span><br><span class="line">            file.readline()</span><br><span class="line">        <span class="comment"># Finally, save the file.</span></span><br><span class="line">        self.file = file</span><br></pre></td></tr></table></figure><p>使用方法如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reader = TextReader(<span class="string">"hello.txt"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reader.readline()</span><br><span class="line"><span class="string">'1: Hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reader.readline()</span><br><span class="line"><span class="string">'2: I am line number two.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_reader = pickle.loads(pickle.dumps(reader))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_reader.readline()</span><br><span class="line"><span class="string">'3: Goodbye!'</span></span><br></pre></td></tr></table></figure><h3 id="除了Dispatcher-类型和函数及其他对象自定义规约"><a href="#除了Dispatcher-类型和函数及其他对象自定义规约" class="headerlink" title="除了Dispatcher,类型和函数及其他对象自定义规约"></a>除了Dispatcher,类型和函数及其他对象自定义规约</h3><blockquote><p>有时，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 可能不够灵活。 特别是当我们想要基于对象类型以外的其他规则来对封存进行定制，或是当我们想要对函数和类的封存进行定制的时候。</p><p>对于那些情况，可能要基于 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 类进行子类化并实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.reducer_override" target="_blank" rel="noopener"><code>reducer_override()</code></a> 方法。 此方法可返回任意的归约元组 (参见 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a>)。 它也可以选择返回 <code>NotImplemented</code> 来回退到传统行为。</p><p>如果同时定义了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.reducer_override" target="_blank" rel="noopener"><code>reducer_override()</code></a>，则 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.reducer_override" target="_blank" rel="noopener"><code>reducer_override()</code></a> 方法具有优先权。</p></blockquote><p><strong>注解</strong>：出于性能理由，可能不会为以下对象调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.reducer_override" target="_blank" rel="noopener"><code>reducer_override()</code></a>: <code>None</code>, <code>True</code>, <code>False</code>, 以及 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset" target="_blank" rel="noopener"><code>frozenset</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#tuple" target="_blank" rel="noopener"><code>tuple</code></a> 的具体实例。</p><p>以下是一个简单的例子，其中我们允许封存并重新构建一个给定的类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    my_attribute = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPickler</span><span class="params">(pickle.Pickler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer_override</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="string">"""Custom reducer for MyClass."""</span></span><br><span class="line">        <span class="keyword">if</span> getattr(obj, <span class="string">"__name__"</span>, <span class="literal">None</span>) == <span class="string">"MyClass"</span>:</span><br><span class="line">            <span class="keyword">return</span> type, (obj.__name__, obj.__bases__,</span><br><span class="line">                          &#123;<span class="string">'my_attribute'</span>: obj.my_attribute&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># For any other object, fallback to usual reduction</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line">f = io.BytesIO()</span><br><span class="line">p = MyPickler(f)</span><br><span class="line">p.dump(MyClass)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> MyClass</span><br><span class="line"></span><br><span class="line">unpickled_class = pickle.loads(f.getvalue())</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> isinstance(unpickled_class, type)</span><br><span class="line"><span class="keyword">assert</span> unpickled_class.__name__ == <span class="string">"MyClass"</span></span><br><span class="line"><span class="keyword">assert</span> unpickled_class.my_attribute == <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="外部缓冲区"><a href="#外部缓冲区" class="headerlink" title="外部缓冲区"></a>外部缓冲区</h3><p>在某些场景中，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块会被用来传输海量的数据。 因此，最小化内存复制次数以保证性能和节省资源是很重要的。 但是 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块的正常运作会将图类对象结构转换为字节序列流，因此在本质上就要从封存流中来回复制数据。</p><p>如果 <em>provider</em> (待传输对象类型的实现) 和 <em>consumer</em> (通信系统的实现) 都支持 pickle 第 5 版或更高版本所提供的外部传输功能，则此约束可以被撤销。</p><h3 id="提供方API"><a href="#提供方API" class="headerlink" title="提供方API"></a>提供方API</h3><p>大的待封存数据对象必须实现协议 5 及以上版本专属的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce_ex__" target="_blank" rel="noopener"><code>__reduce_ex__()</code></a> 方法，该方法将为任意大的数据返回一个 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 实例（而不是 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 对象等）。</p><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 对象会 <em>表明</em> 底层缓冲区可被用于外部数据传输。 那些对象仍将保持与 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块的正常用法兼容。 但是，使用方也可以选择告知 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 它们将自行处理那些缓冲区。</p><h3 id="使用方API"><a href="#使用方API" class="headerlink" title="使用方API"></a>使用方API</h3><p>当序列化一个对象图时，通信系统可以启用对所生成 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 对象的定制处理。</p><p>发送端需要传递 <em>buffer_callback</em> 参数到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> (或是到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dump" target="_blank" rel="noopener"><code>dump()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dumps" target="_blank" rel="noopener"><code>dumps()</code></a> 函数)，该回调函数将在封存对象图时附带每个所生成的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 被调用。 由 <em>buffer_callback</em> 所累积的缓冲区的数据将不会被拷贝到 pickle 流，而是仅插入一个简单的标记。</p><p>接收端需要传递 <em>buffers</em> 参数到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> (或是到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.load" target="_blank" rel="noopener"><code>load()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.loads" target="_blank" rel="noopener"><code>loads()</code></a> 函数)，其值是一个由缓冲区组成的可迭代对象，它会被传递给 <em>buffer_callback</em>。 该可迭代对象应当按其被传递给 <em>buffer_callback</em> 时的顺序产生缓冲区。 这些缓冲区将提供对象重构造器所期望的数据，对这些数据的封存产生了原本的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 对象。</p><p>在发送端和接受端之间，通信系统可以自由地实现它自己用于外部缓冲区的传输机制。 潜在的优化包括使用共享内存或基于特定数据类型的压缩等。</p><p>实例:下面是一个小例子，在其中我们实现了一个 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 的子类，能够用于外部缓冲区封存:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroCopyByteArray</span><span class="params">(bytearray)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce_ex__</span><span class="params">(self, protocol)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> protocol &gt;= <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> type(self)._reconstruct, (PickleBuffer(self),), <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># PickleBuffer is forbidden with pickle protocols &lt;= 4.</span></span><br><span class="line">            <span class="keyword">return</span> type(self)._reconstruct, (bytearray(self),)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_reconstruct</span><span class="params">(cls, obj)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> memoryview(obj) <span class="keyword">as</span> m:</span><br><span class="line">            <span class="comment"># Get a handle over the original buffer object</span></span><br><span class="line">            obj = m.obj</span><br><span class="line">            <span class="keyword">if</span> type(obj) <span class="keyword">is</span> cls:</span><br><span class="line">                <span class="comment"># Original buffer object is a ZeroCopyByteArray, return it</span></span><br><span class="line">                <span class="comment"># as-is.</span></span><br><span class="line">                <span class="keyword">return</span> obj</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> cls(obj)</span><br></pre></td></tr></table></figure><p>重构造器 (<code>_reconstruct</code> 类方法) 会在缓冲区的提供对象具有正确类型时返回该对象。 在此小示例中这是模拟零拷贝行为的便捷方式。</p><p>在使用方，我们可以按通常方式封存那些对象，它们在反序列化时将提供原始对象的一个副本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = ZeroCopyByteArray(<span class="string">b"abc"</span>)</span><br><span class="line">data = pickle.dumps(b, protocol=<span class="number">5</span>)</span><br><span class="line">new_b = pickle.loads(data)</span><br><span class="line">print(b == new_b)  <span class="comment"># True</span></span><br><span class="line">print(b <span class="keyword">is</span> new_b)  <span class="comment"># False: a copy was made</span></span><br></pre></td></tr></table></figure><p>但是如果我们传入 <em>buffer_callback</em> 然后在反序列化时给回累积的缓冲区，我们就能够取回原始对象:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b = ZeroCopyByteArray(<span class="string">b"abc"</span>)</span><br><span class="line">buffers = []</span><br><span class="line">data = pickle.dumps(b, protocol=<span class="number">5</span>, buffer_callback=buffers.append)</span><br><span class="line">new_b = pickle.loads(data, buffers=buffers)</span><br><span class="line">print(b == new_b)  <span class="comment"># True</span></span><br><span class="line">print(b <span class="keyword">is</span> new_b)  <span class="comment"># True: no copy was made</span></span><br></pre></td></tr></table></figure><p>这个例子受限于 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 会自行分配内存这一事实：你无法基于另一个对象的内存创建 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 的实例。 但是，第三方数据类型例如 NumPy 数组则没有这种限制，允许在单独进程或系统间传输时使用零拷贝的封存（或是尽可能少地拷贝） 。</p><blockquote><p>参见：<a href="https://www.python.org/dev/peps/pep-0574" target="_blank" rel="noopener"><strong>PEP 574</strong></a> – 带有外部数据缓冲区的 pickle 协议 5</p></blockquote><h3 id="限制全局变量"><a href="#限制全局变量" class="headerlink" title="限制全局变量"></a>限制全局变量</h3><p>默认情况下，解封将会导入在 pickle 数据中找到的任何类或函数。 对于许多应用来说，此行为是不可接受的，因为它会允许解封器导入并发起调用任意代码。 只须考虑当这个手工构建的 pickle 数据流被加载时会做什么:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.loads(<span class="string">b"cos\nsystem\n(S'echo hello world'\ntR."</span>)</span><br><span class="line">hello world</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>在这个例子里，解封器导入 <a href="https://docs.python.org/zh-cn/3/library/os.html#os.system" target="_blank" rel="noopener"><code>os.system()</code></a> 函数然后应用字符串参数 “echo hello world”。 虽然这个例子不具攻击性，但是不难想象别人能够通过此方式对你的系统造成损害。</p><p>出于这样的理由，你可能会希望通过定制 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.find_class" target="_blank" rel="noopener"><code>Unpickler.find_class()</code></a> 来控制要解封的对象。 与其名称所提示的不同，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.find_class" target="_blank" rel="noopener"><code>Unpickler.find_class()</code></a> 会在执行对任何全局对象（例如一个类或一个函数）的请求时被调用。 因此可以完全禁止全局对象或是将它们限制在一个安全的子集中。</p><p>下面的例子是一个解封器，它只允许某一些安全的来自 <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a> 模块的类被加载:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">safe_builtins = &#123;</span><br><span class="line">    <span class="string">'range'</span>,</span><br><span class="line">    <span class="string">'complex'</span>,</span><br><span class="line">    <span class="string">'set'</span>,</span><br><span class="line">    <span class="string">'frozenset'</span>,</span><br><span class="line">    <span class="string">'slice'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestrictedUnpickler</span><span class="params">(pickle.Unpickler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_class</span><span class="params">(self, module, name)</span>:</span></span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">"builtins"</span> <span class="keyword">and</span> name <span class="keyword">in</span> safe_builtins:</span><br><span class="line">            <span class="keyword">return</span> getattr(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">"global '%s.%s' is forbidden"</span> %</span><br><span class="line">                                     (module, name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restricted_loads</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""Helper function analogous to pickle.loads()."""</span></span><br><span class="line">    <span class="keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</span><br></pre></td></tr></table></figure><p>我们这个解封器的一个示例用法所达成的目标:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>restricted_loads(pickle.dumps([<span class="number">1</span>, <span class="number">2</span>, range(<span class="number">15</span>)]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, range(<span class="number">0</span>, <span class="number">15</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>restricted_loads(<span class="string">b"cos\nsystem\n(S'echo hello world'\ntR."</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">pickle.UnpicklingError: <span class="keyword">global</span> <span class="string">'os.system'</span> <span class="keyword">is</span> forbidden</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>restricted_loads(<span class="string">b'cbuiltins\neval\n'</span></span><br><span class="line"><span class="meta">... </span>                 <span class="string">b'(S\'getattr(__import__("os"), "system")'</span></span><br><span class="line"><span class="meta">... </span>                 <span class="string">b'("echo hello world")\'\ntR.'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">pickle.UnpicklingError: <span class="keyword">global</span> <span class="string">'builtins.eval'</span> <span class="keyword">is</span> forbidden</span><br></pre></td></tr></table></figure><p>正如我们这个例子所显示的，对于允许解封的对象你必须要保持谨慎。 因此如果要保证安全，你可以考虑其他选择例如 <a href="https://docs.python.org/zh-cn/3/library/xmlrpc.client.html#module-xmlrpc.client" target="_blank" rel="noopener"><code>xmlrpc.client</code></a> 中的编组 API 或是第三方解决方案。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>较新版本的 pickle 协议（第 2 版或更高）具有针对某些常见特性和内置类型的高效二进制编码格式。 此外，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块还拥有一个以 C 编写的透明优化器。</p><p>实例</p><p>对于最简单的代码，请使用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dump" target="_blank" rel="noopener"><code>dump()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.load" target="_blank" rel="noopener"><code>load()</code></a> 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="comment"># An arbitrary collection of objects supported by pickle.</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'a'</span>: [<span class="number">1</span>, <span class="number">2.0</span>, <span class="number">3</span>, <span class="number">4</span>+<span class="number">6j</span>],</span><br><span class="line">    <span class="string">'b'</span>: (<span class="string">"character string"</span>, <span class="string">b"byte string"</span>),</span><br><span class="line">    <span class="string">'c'</span>: &#123;<span class="literal">None</span>, <span class="literal">True</span>, <span class="literal">False</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data.pickle'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># Pickle the 'data' dictionary using the highest protocol available.</span></span><br><span class="line">    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)</span><br></pre></td></tr></table></figure><p>以下示例读取之前封存的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data.pickle'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># The protocol version used is detected automatically, so we do not</span></span><br><span class="line">    <span class="comment"># have to specify it.</span></span><br><span class="line">    data = pickle.load(f)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-pickle&quot;&gt;&lt;a href=&quot;#python-标准库-pickle&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 pickle&quot;&gt;&lt;/a&gt;python 标准库 pickle&lt;/h1&gt;&lt;p&gt;快过年了,准备了一些过节用的英语&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;传统中国节日：traditional Chinese festival&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;农历：lunar calendar&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;腊八节：Laba Festival&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;小年：Little New Year&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除夕：Lunar New Year’s Eve&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;春节：the Spring Festival&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正月初一：the lunar New Year’s Day&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;元宵节：the Lantern Festival&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正月：the first month of the lunar year&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;二月二：Dragon Heads-raising Day&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200114_guonian1.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;时间过得好快,又是一年过去了。&lt;/p&gt;
&lt;h2 id=&quot;python-标准库学习之-pickle&quot;&gt;&lt;a href=&quot;#python-标准库学习之-pickle&quot; class=&quot;headerlink&quot; title=&quot;python 标准库学习之 pickle&quot;&gt;&lt;/a&gt;python 标准库学习之 pickle&lt;/h2&gt;&lt;p&gt;常用的文本处理 除了文件,数据库,json,xml 以外,python还提供了一种存储方案,这就是&lt;code&gt;pickle&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模块 &lt;a href=&quot;https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; 实现了对一个 Python 对象结构的二进制序列化和反序列化。&lt;em&gt;“pickling”&lt;/em&gt; 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 &lt;em&gt;“unpickling”&lt;/em&gt; 是相反的操作，会将（来自一个 &lt;a href=&quot;https://docs.python.org/zh-cn/3/glossary.html#term-binary-file&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;binary file&lt;/a&gt; 或者 &lt;a href=&quot;https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bytes-like object&lt;/a&gt; 的）字节流转化回一个对象层次结构。 pickling（和 unpickling）也被称为“序列化”, “编组” 或者 “平面化”。而为了避免混乱，此处采用术语 “封存 (pickling)” 和 “解封 (unpickling)”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;警告&lt;/em&gt; :  &lt;code&gt;pickle&lt;/code&gt; 模块&lt;strong&gt;并不安全&lt;/strong&gt;。你只应该对你信任的数据进行unpickle操作。构建恶意的 pickle 数据来&lt;strong&gt;在解封时执行任意代码&lt;/strong&gt;是可能的。绝对不要对不信任来源的数据和可能被篡改过的数据进行解封。请考虑使用 &lt;a href=&quot;https://docs.python.org/zh-cn/3/library/hmac.html#module-hmac&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;hmac&lt;/code&gt;&lt;/a&gt; 来对数据进行签名，确保数据没有被篡改。在你处理不信任数据时，更安全的序列化格式如 &lt;a href=&quot;https://docs.python.org/zh-cn/3/library/json.html#module-json&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;json&lt;/code&gt;&lt;/a&gt; 可能更为适合。参见 &lt;a href=&quot;https://docs.python.org/zh-cn/3/library/pickle.html#comparison-with-json&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;与 json 模块的比较&lt;/a&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;源代码：-Lib-pickle-py&quot;&gt;&lt;a href=&quot;#源代码：-Lib-pickle-py&quot; class=&quot;headerlink&quot; title=&quot;源代码： Lib/pickle.py&quot;&gt;&lt;/a&gt;&lt;strong&gt;源代码：&lt;/strong&gt; &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/pickle.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lib/pickle.py&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;本节内容比较多,先看下类层次结构,有一个大体的概念(节选自源码)：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Classes:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Pickler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Unpickler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Functions:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dump(object, file)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dumps(object) -&amp;gt; string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    load(file) -&amp;gt; object&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    loads(string) -&amp;gt; object&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Misc variables:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __version__&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    format_version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compatible_formats&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__all__ = [&lt;span class=&quot;string&quot;&gt;&quot;PickleError&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;PicklingError&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;UnpicklingError&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Pickler&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;Unpickler&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;dump&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;dumps&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;load&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;loads&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="pickle" scheme="https://pinghailinfeng.gitee.io/tags/pickle/"/>
    
  </entry>
  
  <entry>
    <title>python standard library array type</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/13/python-standard-library-array-type/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/13/python-standard-library-array-type/</id>
    <published>2020-01-13T03:04:53.000Z</published>
    <updated>2020-01-13T04:11:02.663Z</updated>
    
    <content type="html"><![CDATA[<p>每日一词: underdog</p><blockquote><p>英 [ˈʌndədɒg]   美 [ˈʌndərdɔg]</p><p>n.失败者； 退居下风的人； 受压迫者； 打败了的选手</p><p>复数： <a href="http://www.iciba.com/underdogs" target="_blank" rel="noopener">underdogs</a></p></blockquote><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200113underdogs.webp?raw=true" alt></p><blockquote><p> 这个词来自1887年出现，原指在斗狗比赛中战败的狗。后来词义引申至人，指的是各类竞赛和对碰中不被看好的一方，或是指处在逆境中的人和团体。</p><p>被看好的一方，即Topdog，从来不缺喝彩和支持。而Underdog的路则注定孤独许多。不被人看好，较少人支持。</p><p>所幸的是，正如倪匡先生感言：太多的时候，孤独最好。  </p><p>若能与孤独为师,又何须担心underdog呢？</p></blockquote><h2 id="python-标准库学习-array"><a href="#python-标准库学习-array" class="headerlink" title="python 标准库学习 array"></a>python 标准库学习 array</h2><p>此模块定义了一种对象类型，可以紧凑地表示基本类型值的数组：字符、整数、浮点数等。 数组属于序列类型，其行为与列表非常相似，不同之处在于其中存储的对象类型是受限的。 类型在对象创建时使用单个字符的 <em>类型码</em> 来指定。 已定义的类型码如下：</p><table><thead><tr><th>类型码</th><th>C 类型</th><th>Python 类型</th><th>以字节表示的最小尺寸</th><th>注释</th></tr></thead><tbody><tr><td><code>&#39;b&#39;</code></td><td>signed char</td><td>int</td><td>1</td><td></td></tr><tr><td><code>&#39;B&#39;</code></td><td>unsigned char</td><td>int</td><td>1</td><td></td></tr><tr><td><code>&#39;u&#39;</code></td><td>Py_UNICODE</td><td>Unicode 字符</td><td>2</td><td>(1)</td></tr><tr><td><code>&#39;h&#39;</code></td><td>signed short</td><td>int</td><td>2</td><td></td></tr><tr><td><code>&#39;H&#39;</code></td><td>unsigned short</td><td>int</td><td>2</td><td></td></tr><tr><td><code>&#39;i&#39;</code></td><td>signed int</td><td>int</td><td>2</td><td></td></tr><tr><td><code>&#39;I&#39;</code></td><td>无符号整型</td><td>int</td><td>2</td><td></td></tr><tr><td><code>&#39;l&#39;</code></td><td>signed long</td><td>int</td><td>4</td><td></td></tr><tr><td><code>&#39;L&#39;</code></td><td>无符号长整型</td><td>int</td><td>4</td><td></td></tr><tr><td><code>&#39;q&#39;</code></td><td>signed long long</td><td>int</td><td>8</td><td></td></tr><tr><td><code>&#39;Q&#39;</code></td><td>无符号 long long</td><td>int</td><td>8</td><td></td></tr><tr><td><code>&#39;f&#39;</code></td><td>float</td><td>float</td><td>4</td><td></td></tr><tr><td><code>&#39;d&#39;</code></td><td>double</td><td>float</td><td>8</td></tr></tbody></table><p>==注释== </p><blockquote><p>‘u’类型码在<code>python3</code>已经被废除,默认python的字符串就是<code>unicode</code>字符</p></blockquote><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li><p><em>class</em> <code>array.array</code>(<em>typecode</em>[, <em>initializer</em>])</p><p>一个包含由 <em>typecode</em> 限制类型的条目的新数组，并由可选的 <em>initializer</em> 值进行初始化，该值必须为一个列表、<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 或包含正确类型元素的可迭代对象。如果给定一个列表或字符串，该 initializer 会被传给新数组的 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromlist" target="_blank" rel="noopener"><code>fromlist()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.frombytes" target="_blank" rel="noopener"><code>frombytes()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromunicode" target="_blank" rel="noopener"><code>fromunicode()</code></a> 方法（见下文）以将初始条目添加到数组中。 否则会将可迭代对象作为 initializer 传给 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.extend" target="_blank" rel="noopener"><code>extend()</code></a> 方法。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审核事件</a> <code>array.__new__</code> 附带参数 <code>typecode</code>, <code>initializer</code>。</p></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p><code>array.typecodes</code></p><p>包含所有可用类型码的字符串。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import array</span><br><span class="line">&gt;&gt;&gt; array.typecodes</span><br><span class="line">&apos;bBuhHiIlLqQfd&apos;</span><br></pre></td></tr></table></figure><p>数组对象支持普通的序列操作如索引、切片、拼接和重复等。 当使用切片赋值时，所赋的值必须为具有相同类型码的数组对象；所有其他情况都将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 数组对象也实现了缓冲区接口，可以用于所有支持 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 的场合。</p><a id="more"></a><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>以下数据项和方法也受到支持：</p><ul><li><p><code>array.typecode</code></p><p>用于创建数组的类型码字符。</p></li><li><p><code>array.itemsize</code></p><p>在内部表示中一个数组项的字节长度。</p></li><li><p><code>array.append</code>(<em>x</em>)</p><p>添加一个值为 <em>x</em> 的新项到数组末尾。</p></li><li><p><code>array.buffer_info</code>()</p><p>返回一个元组 <code>(address, length)</code> 以给出用于存放数组内容的缓冲区元素的当前内存地址和长度。 以字节表示的内存缓冲区大小可通过 <code>array.buffer_info()[1] * array.itemsize</code> 来计算。 这在使用需要内存地址的低层级（因此不够安全） I/O 接口时会很有用，例如某些 <code>ioctl()</code> 操作。 只要数组存在并且没有应用改变长度的操作，返回数值就是有效的。注解 当在 C 或 C++ 编写的代码中使用数组对象时（这是有效使用此类信息的唯一方式），使用数组对象所支持的缓冲区接口更为适宜。 此方法仅保留用作向下兼容，应避免在新代码中使用。 缓冲区接口的文档参见 <a href="https://docs.python.org/zh-cn/3.8/c-api/buffer.html#bufferobjects" target="_blank" rel="noopener">缓冲协议</a>。</p></li><li><p><code>array.byteswap</code>()</p><p>“字节对调”所有数组项。 此方法只支持大小为 1, 2, 4 或 8 字节的值；对于其他值类型将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 它适用于从不同字节序机器所生成的文件中读取数据的情况。</p></li><li><p><code>array.count</code>(<em>x</em>)</p><p>返回 <em>x</em> 在数组中的出现次数。</p></li><li><p><code>array.extend</code>(<em>iterable</em>)</p><p>将来自 <em>iterable</em> 的项添加到数组末尾。 如果 <em>iterable</em> 是另一个数组，它必须具有 <em>完全</em> 相同的类型码；否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 如果 <em>iterable</em> 不是一个数组，则它必须为可迭代对象并且其元素必须为可添加到数组的适当类型。</p></li><li><p><code>array.frombytes</code>(<em>s</em>)</p><p>添加来自字符串的项，将字符串解读为机器值的数组（相当于使用 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromfile" target="_blank" rel="noopener"><code>fromfile()</code></a> 方法从文件中读取数据）。<em>3.2 新版功能:</em> <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromstring" target="_blank" rel="noopener"><code>fromstring()</code></a> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.frombytes" target="_blank" rel="noopener"><code>frombytes()</code></a> 以使其含义更清晰。</p></li><li><p><code>array.fromfile</code>(<em>f</em>, <em>n</em>)</p><p>从 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> <em>f</em> 中读取 <em>n</em> 项（解读为机器值）并将它们添加到数组末尾。 如果可读取数据少于 <em>n</em> 项则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EOFError" target="_blank" rel="noopener"><code>EOFError</code></a>，但有效的项仍然会被插入数组。 <em>f</em> 必须为一个真实的内置文件对象；不支持带有 <code>read()</code> 方法的其它对象。</p></li><li><p><code>array.fromlist</code>(<em>list</em>)</p><p>添加来自 list 的项。 这等价于 <code>for x in list: a.append(x)</code>，区别在于如果发生类型错误，数组将不会被改变。</p></li><li><p><code>array.fromstring</code>()</p><p><a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.frombytes" target="_blank" rel="noopener"><code>frombytes()</code></a> 的已弃用别名。<em>Deprecated since version 3.2, will be removed in version 3.9.</em></p></li><li><p><code>array.fromunicode</code>(<em>s</em>)</p><p>使用来自给定 Unicode 字符串的数组扩展数组。 数组必须是类型为 <code>&#39;u&#39;</code> 的数组；否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。 请使用 <code>array.frombytes(unicodestring.encode(enc))</code> 来将 Unicode 数据添加到其他类型的数组。</p></li><li><p><code>array.index</code>(<em>x</em>)</p><p>返回最小的 <em>i</em> 使得 <em>i</em> 为 <em>x</em> 在数组中首次出现的序号。</p></li><li><p><code>array.insert</code>(<em>i</em>, <em>x</em>)</p><p>将值 <em>x</em> 作为新项插入数组的 <em>i</em> 位置之前。 负值将被视为相对于数组末尾的位置。</p></li><li><p><code>array.pop</code>([<em>i</em>])</p><p>从数组中移除序号为 <em>i</em> 的项并将其返回。 可选参数值默认为 <code>-1</code>，因此默认将移除并返回末尾项。</p></li><li><p><code>array.remove</code>(<em>x</em>)</p><p>从数组中移除首次出现的 <em>x</em>。</p></li><li><p><code>array.reverse</code>()</p><p>反转数组中各项的顺序。</p></li><li><p><code>array.tobytes</code>()</p><p>将数组转换为一个机器值数组并返回其字节表示（即相当与通过 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.tofile" target="_blank" rel="noopener"><code>tofile()</code></a> 方法写入到文件的字节序列。）<em>3.2 新版功能:</em> <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.tostring" target="_blank" rel="noopener"><code>tostring()</code></a> 被重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.tobytes" target="_blank" rel="noopener"><code>tobytes()</code></a> 以使其含义更清晰。</p></li><li><p><code>array.tofile</code>(<em>f</em>)</p><p>将所有项（作为机器值）写入到 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> <em>f</em>。</p></li><li><p><code>array.tolist</code>()</p><p>将数组转换为包含相同项的普通列表。</p></li><li><p><code>array.tostring</code>()</p><p><a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.tobytes" target="_blank" rel="noopener"><code>tobytes()</code></a> 的已弃用别名。<em>Deprecated since version 3.2, will be removed in version 3.9.</em></p></li><li><p><code>array.tounicode</code>()</p><p>将数组转换为一个 Unicode 字符串。 数组必须是类型为 <code>&#39;u&#39;</code> 的数组；否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。 请使用 <code>array.tobytes().decode(enc)</code> 来从其他类型的数组生成 Unicode 字符串。</p></li></ul><p>当一个数组对象被打印或转换为字符串时，它会表示为 <code>array(typecode, initializer)</code>。 如果数组为空则 <em>initializer</em> 会被省略，否则如果 <em>typecode</em> 为 <code>&#39;u&#39;</code> 则它是一个字符串，否则它是一个数字列表。 使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 保证能将字符串转换回具有相同类型和值的数组，只要 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array" target="_blank" rel="noopener"><code>array</code></a> 类已通过 <code>from array import array</code> 被引入。 例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line">array(<span class="string">'l'</span>)</span><br><span class="line">array(<span class="string">'u'</span>, <span class="string">'hello \u2641'</span>)</span><br><span class="line">array(<span class="string">'l'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">array(<span class="string">'d'</span>, [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.14</span>])</span><br></pre></td></tr></table></figure><p>更高效数组处理的可以详见 <a href="https://docs.scipy.org/doc/" target="_blank" rel="noopener">numpy</a> 库</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原来python标准库里就有专门操作array对象的方法,这里我理解array和list的区别在于,list里包含的元素可以是任意数据类型,处理数据的时候不是很方便,而array里的数据类型是一致的,这样处理数据效率更高。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每日一词: underdog&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;英 [ˈʌndədɒg]   美 [ˈʌndərdɔg]&lt;/p&gt;
&lt;p&gt;n.失败者； 退居下风的人； 受压迫者； 打败了的选手&lt;/p&gt;
&lt;p&gt;复数： &lt;a href=&quot;http://www.iciba.com/underdogs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;underdogs&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200113underdogs.webp?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 这个词来自1887年出现，原指在斗狗比赛中战败的狗。后来词义引申至人，指的是各类竞赛和对碰中不被看好的一方，或是指处在逆境中的人和团体。&lt;/p&gt;
&lt;p&gt;被看好的一方，即Topdog，从来不缺喝彩和支持。而Underdog的路则注定孤独许多。不被人看好，较少人支持。&lt;/p&gt;
&lt;p&gt;所幸的是，正如倪匡先生感言：太多的时候，孤独最好。  &lt;/p&gt;
&lt;p&gt;若能与孤独为师,又何须担心underdog呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;python-标准库学习-array&quot;&gt;&lt;a href=&quot;#python-标准库学习-array&quot; class=&quot;headerlink&quot; title=&quot;python 标准库学习 array&quot;&gt;&lt;/a&gt;python 标准库学习 array&lt;/h2&gt;&lt;p&gt;此模块定义了一种对象类型，可以紧凑地表示基本类型值的数组：字符、整数、浮点数等。 数组属于序列类型，其行为与列表非常相似，不同之处在于其中存储的对象类型是受限的。 类型在对象创建时使用单个字符的 &lt;em&gt;类型码&lt;/em&gt; 来指定。 已定义的类型码如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型码&lt;/th&gt;
&lt;th&gt;C 类型&lt;/th&gt;
&lt;th&gt;Python 类型&lt;/th&gt;
&lt;th&gt;以字节表示的最小尺寸&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;b&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;signed char&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;B&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;unsigned char&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;u&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Py_UNICODE&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;h&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;signed short&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;H&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;unsigned short&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;i&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;signed int&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;I&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号整型&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;l&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;signed long&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;L&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号长整型&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;q&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;signed long long&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;Q&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号 long long&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;f&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;d&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;==注释== &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;‘u’类型码在&lt;code&gt;python3&lt;/code&gt;已经被废除,默认python的字符串就是&lt;code&gt;unicode&lt;/code&gt;字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;class&lt;/em&gt; &lt;code&gt;array.array&lt;/code&gt;(&lt;em&gt;typecode&lt;/em&gt;[, &lt;em&gt;initializer&lt;/em&gt;])&lt;/p&gt;
&lt;p&gt;一个包含由 &lt;em&gt;typecode&lt;/em&gt; 限制类型的条目的新数组，并由可选的 &lt;em&gt;initializer&lt;/em&gt; 值进行初始化，该值必须为一个列表、&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bytes-like object&lt;/a&gt; 或包含正确类型元素的可迭代对象。如果给定一个列表或字符串，该 initializer 会被传给新数组的 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromlist&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;fromlist()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/array.html#array.array.frombytes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;frombytes()&lt;/code&gt;&lt;/a&gt; 或 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromunicode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;fromunicode()&lt;/code&gt;&lt;/a&gt; 方法（见下文）以将初始条目添加到数组中。 否则会将可迭代对象作为 initializer 传给 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/array.html#array.array.extend&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;extend()&lt;/code&gt;&lt;/a&gt; 方法。引发一个 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/sys.html#auditing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;审核事件&lt;/a&gt; &lt;code&gt;array.__new__&lt;/code&gt; 附带参数 &lt;code&gt;typecode&lt;/code&gt;, &lt;code&gt;initializer&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;array.typecodes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;包含所有可用类型码的字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; import array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; array.typecodes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;apos;bBuhHiIlLqQfd&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;数组对象支持普通的序列操作如索引、切片、拼接和重复等。 当使用切片赋值时，所赋的值必须为具有相同类型码的数组对象；所有其他情况都将引发 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;。 数组对象也实现了缓冲区接口，可以用于所有支持 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;字节类对象&lt;/a&gt; 的场合。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="array" scheme="https://pinghailinfeng.gitee.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>python standard library collections.abc</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/12/python-standard-library-collections-abc/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/12/python-standard-library-collections-abc/</id>
    <published>2020-01-12T00:49:16.000Z</published>
    <updated>2020-01-13T02:57:53.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-之-collections-abc"><a href="#python-标准库-之-collections-abc" class="headerlink" title="python 标准库 之 collections.abc"></a>python 标准库 之 collections.abc</h1><p>每日一词: wrong</p><blockquote><p><em>adj.</em> 不道德的, 不正当的, 不义的</p><p>不确实的, 不正确的, 错误的</p><p>不合要求的, 不适合的, 并非合意的</p><p>有故障, 有毛病</p><p><em>adv.</em> 方式或方向错误地; 错误地; 结果错误地</p><p><em>n.</em> 罪过, 过失, 罪恶</p><p>不义的行为, 不公正的事</p><p>时 态: wronged, wronging, wrongs<br>名 词: wronger<br>副 词: wrongly<br>名 词: wrongness</p><p> 词语：</p><p><em>confound right and wrong</em></p><p>混淆是非，黑白不分</p><p><em>get one wrong</em></p><p>误会某人；误会</p><p> <em>right or wrong</em><br><em>adv.</em> 不管如何 </p><p><em>something wrong with</em></p><p>…出了毛病；…有问题；…不对头</p></blockquote><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200112update1.jpg?raw=true" alt></p><h2 id="python-标准库学习之-抽象基类-collection-abc"><a href="#python-标准库学习之-抽象基类-collection-abc" class="headerlink" title="python 标准库学习之 抽象基类 collection.abc"></a>python 标准库学习之 抽象基类 collection.abc</h2><p>众所周知,python3中所有类默认继承自object类,意味着父类中所有的方法,子类都继承了。</p><p>我个人理解,抽象基类是无法被实例化的,只能子类实现</p><p> <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html" target="_blank" rel="noopener">参考文档</a></p><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/_collections_abc.py" target="_blank" rel="noopener">Lib/_collections_abc.py</a> </p><p> 该模块定义了一些 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class" target="_blank" rel="noopener">抽象基类</a>，它们可用于判断一个具体类是否具有某一特定的接口；例如，这个类是否可哈希，或其是否为映射类。 </p><p>模块里方法一览,摘自源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">"Awaitable"</span>, <span class="string">"Coroutine"</span>,</span><br><span class="line">           <span class="string">"AsyncIterable"</span>, <span class="string">"AsyncIterator"</span>, <span class="string">"AsyncGenerator"</span>,</span><br><span class="line">           <span class="string">"Hashable"</span>, <span class="string">"Iterable"</span>, <span class="string">"Iterator"</span>, <span class="string">"Generator"</span>, <span class="string">"Reversible"</span>,</span><br><span class="line">           <span class="string">"Sized"</span>, <span class="string">"Container"</span>, <span class="string">"Callable"</span>, <span class="string">"Collection"</span>,</span><br><span class="line">           <span class="string">"Set"</span>, <span class="string">"MutableSet"</span>,</span><br><span class="line">           <span class="string">"Mapping"</span>, <span class="string">"MutableMapping"</span>,</span><br><span class="line">           <span class="string">"MappingView"</span>, <span class="string">"KeysView"</span>, <span class="string">"ItemsView"</span>, <span class="string">"ValuesView"</span>,</span><br><span class="line">           <span class="string">"Sequence"</span>, <span class="string">"MutableSequence"</span>,</span><br><span class="line">           <span class="string">"ByteString"</span>,</span><br><span class="line">           ]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="容器抽象基类"><a href="#容器抽象基类" class="headerlink" title="容器抽象基类"></a>容器抽象基类</h2><p> 这个容器模块提供了以下 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class" target="_blank" rel="noopener">ABCs</a>: </p><table><thead><tr><th style="text-align:left">抽象基类</th><th style="text-align:left">继承自</th><th style="text-align:left">抽象方法</th><th style="text-align:left">Mixin 方法</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Container" target="_blank" rel="noopener"><code>Container</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__contains__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Hashable" target="_blank" rel="noopener"><code>Hashable</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__hash__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__iter__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterator" target="_blank" rel="noopener"><code>Iterator</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a></td><td style="text-align:left"><code>__next__</code></td><td style="text-align:left"><code>__iter__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Reversible" target="_blank" rel="noopener"><code>Reversible</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a></td><td style="text-align:left"><code>__reversed__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Generator" target="_blank" rel="noopener"><code>Generator</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterator" target="_blank" rel="noopener"><code>Iterator</code></a></td><td style="text-align:left"><code>send</code>, <code>throw</code></td><td style="text-align:left"><code>close</code>, <code>__iter__</code>, <code>__next__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sized" target="_blank" rel="noopener"><code>Sized</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__len__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Callable" target="_blank" rel="noopener"><code>Callable</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__call__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sized" target="_blank" rel="noopener"><code>Sized</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Container" target="_blank" rel="noopener"><code>Container</code></a></td><td style="text-align:left"><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Reversible" target="_blank" rel="noopener"><code>Reversible</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td><td style="text-align:left"><code>__getitem__</code>, <code>__len__</code></td><td style="text-align:left"><code>__contains__</code>, <code>__iter__</code>, <code>__reversed__</code>, <code>index</code>, and <code>count</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableSequence" target="_blank" rel="noopener"><code>MutableSequence</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a></td><td style="text-align:left"><code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__len__</code>, <code>insert</code></td><td style="text-align:left">继承自 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a> 的方法，以及 <code>append</code>, <code>reverse</code>, <code>extend</code>, <code>pop</code>, <code>remove</code>，和 <code>__iadd__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.ByteString" target="_blank" rel="noopener"><code>ByteString</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a></td><td style="text-align:left"><code>__getitem__</code>, <code>__len__</code></td><td style="text-align:left">继承自 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a> 的方法</td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td><td style="text-align:left"><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code></td><td style="text-align:left"><code>__le__</code>, <code>__lt__</code>, <code>__eq__</code>, <code>__ne__</code>, <code>__gt__</code>, <code>__ge__</code>, <code>__and__</code>, <code>__or__</code>, <code>__sub__</code>, <code>__xor__</code>, and <code>isdisjoint</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableSet" target="_blank" rel="noopener"><code>MutableSet</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a></td><td style="text-align:left"><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code>, <code>add</code>, <code>discard</code></td><td style="text-align:left">继承自 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> 的方法以及 <code>clear</code>, <code>pop</code>, <code>remove</code>, <code>__ior__</code>, <code>__iand__</code>, <code>__ixor__</code>，和 <code>__isub__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Mapping" target="_blank" rel="noopener"><code>Mapping</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td><td style="text-align:left"><code>__getitem__</code>, <code>__iter__</code>, <code>__len__</code></td><td style="text-align:left"><code>__contains__</code>, <code>keys</code>, <code>items</code>, <code>values</code>, <code>get</code>, <code>__eq__</code>, and <code>__ne__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableMapping" target="_blank" rel="noopener"><code>MutableMapping</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Mapping" target="_blank" rel="noopener"><code>Mapping</code></a></td><td style="text-align:left"><code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__iter__</code>, <code>__len__</code></td><td style="text-align:left">继承自 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Mapping" target="_blank" rel="noopener"><code>Mapping</code></a> 的方法以及 <code>pop</code>, <code>popitem</code>, <code>clear</code>, <code>update</code>，和 <code>setdefault</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MappingView" target="_blank" rel="noopener"><code>MappingView</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sized" target="_blank" rel="noopener"><code>Sized</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__len__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.ItemsView" target="_blank" rel="noopener"><code>ItemsView</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MappingView" target="_blank" rel="noopener"><code>MappingView</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__contains__</code>, <code>__iter__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.KeysView" target="_blank" rel="noopener"><code>KeysView</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MappingView" target="_blank" rel="noopener"><code>MappingView</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__contains__</code>, <code>__iter__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.ValuesView" target="_blank" rel="noopener"><code>ValuesView</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MappingView" target="_blank" rel="noopener"><code>MappingView</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__contains__</code>, <code>__iter__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Awaitable" target="_blank" rel="noopener"><code>Awaitable</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__await__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Coroutine" target="_blank" rel="noopener"><code>Coroutine</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Awaitable" target="_blank" rel="noopener"><code>Awaitable</code></a></td><td style="text-align:left"><code>send</code>, <code>throw</code></td><td style="text-align:left"><code>close</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncIterable" target="_blank" rel="noopener"><code>AsyncIterable</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__aiter__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncIterator" target="_blank" rel="noopener"><code>AsyncIterator</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncIterable" target="_blank" rel="noopener"><code>AsyncIterable</code></a></td><td style="text-align:left"><code>__anext__</code></td><td style="text-align:left"><code>__aiter__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncGenerator" target="_blank" rel="noopener"><code>AsyncGenerator</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncIterator" target="_blank" rel="noopener"><code>AsyncIterator</code></a></td><td style="text-align:left"><code>asend</code>, <code>athrow</code></td><td style="text-align:left"><code>aclose</code>, <code>__aiter__</code>, <code>__anext__</code></td></tr></tbody></table><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li><p><em>class</em> <code>collections.abc.Container</code></p></li><li><p><em>class</em> <code>collections.abc.Hashable</code></p></li><li><p><em>class</em> <code>collections.abc.Sized</code></p></li><li><p><em>class</em> <code>collections.abc.Callable</code></p><p>分别提供了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__contains__" target="_blank" rel="noopener"><code>__contains__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__len__" target="_blank" rel="noopener"><code>__len__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__call__" target="_blank" rel="noopener"><code>__call__()</code></a> 方法的抽象基类。</p></li><li><p><em>class</em> <code>collections.abc.Iterable</code></p><p>提供了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 方法的抽象基类。使用 <code>isinstance(obj, Iterable)</code> 可以检测一个类是否已经注册到了 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a> 或者实现了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 函数，但是无法检测这个类是否能够使用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法进行迭代。检测一个对象是否是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterable" target="_blank" rel="noopener">iterable</a> 的唯一可信赖的方法是调用 <code>iter(obj)</code>。</p></li><li><p><em>class</em> <code>collections.abc.Collection</code></p><p>集合了 Sized 和 Iterable 类的抽象基类。</p></li><li><p><em>class</em> <code>collections.abc.Iterator</code></p><p>提供了 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法的抽象基类。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a> 的定义。</p></li><li><p><em>class</em> <code>collections.abc.Reversible</code></p><p>为可迭代类提供了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__reversed__" target="_blank" rel="noopener"><code>__reversed__()</code></a> 方法的抽象基类。<em>3.6 新版功能.</em></p></li><li><p><em>class</em> <code>collections.abc.Generator</code></p><p>生成器类，实现了 <a href="https://www.python.org/dev/peps/pep-0342" target="_blank" rel="noopener"><strong>PEP 342</strong></a> 中定义的协议，继承并扩展了迭代器，提供了 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.send" target="_blank" rel="noopener"><code>send()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.throw" target="_blank" rel="noopener"><code>throw()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.close" target="_blank" rel="noopener"><code>close()</code></a> 方法。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 的定义。<em>3.5 新版功能.</em></p></li><li><p><em>class</em> <code>collections.abc.Sequence</code></p></li><li><p><em>class</em> <code>collections.abc.MutableSequence</code></p></li><li><p><em>class</em> <code>collections.abc.ByteString</code></p><p>只读且可变的序列 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-sequence" target="_blank" rel="noopener">sequences</a> 的抽象基类。实现笔记：一些混入（Maxin）方法比如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__reversed__" target="_blank" rel="noopener"><code>__reversed__()</code></a> 和 <code>index()</code> 会重复调用底层的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法。因此，如果实现的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 是常数级访问速度，那么相应的混入方法会有一个线性的表现；然而，如果底层方法是线性实现（例如链表），那么混入方法将会是平方级的表现，这也许就需要被重构了。<em>在 3.5 版更改:</em> index() 方法支持 <em>stop</em> 和 <em>start</em> 参数。</p></li><li><p><em>class</em> <code>collections.abc.Set</code></p></li><li><p><em>class</em> <code>collections.abc.MutableSet</code></p><p>只读且可变的集合的抽象基类。</p></li><li><p><em>class</em> <code>collections.abc.Mapping</code></p></li><li><p><em>class</em> <code>collections.abc.MutableMapping</code></p><p>只读且可变的映射 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-mapping" target="_blank" rel="noopener">mappings</a> 的抽象基类。</p></li><li><p><em>class</em> <code>collections.abc.MappingView</code></p></li><li><p><em>class</em> <code>collections.abc.ItemsView</code></p></li><li><p><em>class</em> <code>collections.abc.KeysView</code></p></li><li><p><em>class</em> <code>collections.abc.ValuesView</code></p><p>映射及其键和值的视图 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-dictionary-view" target="_blank" rel="noopener">views</a> 的抽象基类。</p></li><li><p><em>class</em> <code>collections.abc.Awaitable</code></p><p>为可等待对象 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a> 提供的类，可以被用于 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#await" target="_blank" rel="noopener"><code>await</code></a> 表达式中。习惯上必须实现 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 方法。协程对象 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">Coroutine</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Coroutine" target="_blank" rel="noopener"><code>Coroutine</code></a> 抽象基类的实例都是这个抽象基类的实例。</p></li><li><p><em>class</em> <code>collections.abc.Coroutine</code></p><p>用于协程兼容类的抽象基类。实现了如下定义在 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine-objects" target="_blank" rel="noopener">协程对象</a>: 里的方法： <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine.send" target="_blank" rel="noopener"><code>send()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine.throw" target="_blank" rel="noopener"><code>throw()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine.close" target="_blank" rel="noopener"><code>close()</code></a>。通常的实现里还需要实现 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 方法。所有的 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Coroutine" target="_blank" rel="noopener"><code>Coroutine</code></a> 实例都必须是 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Awaitable" target="_blank" rel="noopener"><code>Awaitable</code></a> 实例。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 的定义。注解 在 CPython 里，基于生成器的协程（使用 <a href="https://docs.python.org/zh-cn/3.8/library/types.html#types.coroutine" target="_blank" rel="noopener"><code>types.coroutine()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.coroutine" target="_blank" rel="noopener"><code>asyncio.coroutine()</code></a> 包装的生成器）都是 <em>可等待对象</em>，即使他们不含有 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 方法。使用 <code>isinstance(gencoro, Coroutine)</code> 来检测他们会返回 <code>False</code>。要使用 <a href="https://docs.python.org/zh-cn/3.8/library/inspect.html#inspect.isawaitable" target="_blank" rel="noopener"><code>inspect.isawaitable()</code></a> 来检测他们。</p></li><li><p><em>class</em> <code>collections.abc.AsyncIterable</code></p><p>提供了 <code>__aiter__</code> 方法的抽象基类。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterable" target="_blank" rel="noopener">asynchronous iterable</a> 的定义。<em>3.5 新版功能.</em></p></li><li><p><em>class</em> <code>collections.abc.AsyncIterator</code></p><p>提供了 <code>__aiter__</code> 和 <code>__anext__</code> 方法的抽象基类。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterator" target="_blank" rel="noopener">asynchronous iterator</a> 的定义。<em>3.5 新版功能.</em></p></li><li><p><em>class</em> <code>collections.abc.AsyncGenerator</code></p><p>为异步生成器类提供的抽象基类，这些类实现了定义在 <a href="https://www.python.org/dev/peps/pep-0525" target="_blank" rel="noopener"><strong>PEP 525</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 里的协议。</p><p>这些抽象基类让我们可以确定类和示例拥有某些特定的函数，例如： </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> isinstance(myvar, collections.abc.Sized):</span><br><span class="line">    size = len(myvar)</span><br></pre></td></tr></table></figure><p> 有些抽象基类也可以用作混入类（mixin），这可以更容易地开发支持容器 API 的类。例如，要写一个支持完整 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> API 的类，只需要提供下面这三个方法： <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__contains__" target="_blank" rel="noopener"><code>__contains__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__len__" target="_blank" rel="noopener"><code>__len__()</code></a>。抽象基类会补充上其余的方法，比如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__and__" target="_blank" rel="noopener"><code>__and__()</code></a> 和 <code>isdisjoint()</code>: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListBasedSet</span><span class="params">(collections.abc.Set)</span>:</span></span><br><span class="line">    <span class="string">''' Alternate set implementation favoring space over speed</span></span><br><span class="line"><span class="string">        and not requiring the set elements to be hashable. '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self.elements = lst = []</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line">            <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> lst:</span><br><span class="line">                lst.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.elements)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> value <span class="keyword">in</span> self.elements</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.elements)</span><br><span class="line"></span><br><span class="line">s1 = ListBasedSet(<span class="string">'abcdef'</span>)</span><br><span class="line">s2 = ListBasedSet(<span class="string">'defghi'</span>)</span><br><span class="line">overlap = s1 &amp; s2            <span class="comment"># The __and__() method is supported automatically</span></span><br></pre></td></tr></table></figure><p>当把 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableSet" target="_blank" rel="noopener"><code>MutableSet</code></a> 用作混入类时需注意：</p><ol><li>由于某些集合操作会创建新集合，默认的混入方法需要一种从可迭代对象里创建新实例的方法。假如其类构造函数签名形如 <code>ClassName(iterable)</code> ，则其会调用一个内部的类方法 <code>_from_iterable()</code>，其中调用了 <code>cls(iterable)</code> 来生成一个新集合。如果这个 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> 混入类在类中被使用，但其构造函数的签名却是不同的形式，那么你就需要重载 <code>_from_iterable()</code> 方法，将其编写成一个类方法，并且它能够从可迭代对象参数中构造一个新实例。</li><li>重载比较符时时（想必是为了速度，因为其语义都是固定的），只需要重定义 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__le__" target="_blank" rel="noopener"><code>__le__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__ge__" target="_blank" rel="noopener"><code>__ge__()</code></a> 函数，然后其他的操作会自动跟进。</li><li>混入集合类 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> 提供了一个 <code>_hash()</code> 方法为集合计算哈希值，然而， <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 函数却没有被定义，因为并不是所有集合都是可哈希并且不可变的。为了使用混入类为集合添加哈希能力，可以同时继承 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Hashable" target="_blank" rel="noopener"><code>Hashable()</code></a> 类，然后定义 <code>__hash__ = Set._hash</code>。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我看了官方文档的描述,一头雾水。下面就我个人理解谈谈这个模块。</p><p>abc模块应用的场景</p><h3 id="1-判定某个对象的类型"><a href="#1-判定某个对象的类型" class="headerlink" title="1. 判定某个对象的类型"></a>1. 判定某个对象的类型</h3><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200112_collection_abc1.png?raw=true" alt></p><h3 id="2-强制子类实现某些父类方法"><a href="#2-强制子类实现某些父类方法" class="headerlink" title="2. 强制子类实现某些父类方法"></a>2. 强制子类实现某些父类方法</h3><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200112_collection_abc1.png?raw=true" alt></p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200112_collection_abc2.png?raw=true" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-之-collections-abc&quot;&gt;&lt;a href=&quot;#python-标准库-之-collections-abc&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 之 collections.abc&quot;&gt;&lt;/a&gt;python 标准库 之 collections.abc&lt;/h1&gt;&lt;p&gt;每日一词: wrong&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;adj.&lt;/em&gt; 不道德的, 不正当的, 不义的&lt;/p&gt;
&lt;p&gt;不确实的, 不正确的, 错误的&lt;/p&gt;
&lt;p&gt;不合要求的, 不适合的, 并非合意的&lt;/p&gt;
&lt;p&gt;有故障, 有毛病&lt;/p&gt;
&lt;p&gt;&lt;em&gt;adv.&lt;/em&gt; 方式或方向错误地; 错误地; 结果错误地&lt;/p&gt;
&lt;p&gt;&lt;em&gt;n.&lt;/em&gt; 罪过, 过失, 罪恶&lt;/p&gt;
&lt;p&gt;不义的行为, 不公正的事&lt;/p&gt;
&lt;p&gt;时 态: wronged, wronging, wrongs&lt;br&gt;名 词: wronger&lt;br&gt;副 词: wrongly&lt;br&gt;名 词: wrongness&lt;/p&gt;
&lt;p&gt; 词语：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;confound right and wrong&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;混淆是非，黑白不分&lt;/p&gt;
&lt;p&gt;&lt;em&gt;get one wrong&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;误会某人；误会&lt;/p&gt;
&lt;p&gt; &lt;em&gt;right or wrong&lt;/em&gt;&lt;br&gt;&lt;em&gt;adv.&lt;/em&gt; 不管如何 &lt;/p&gt;
&lt;p&gt;&lt;em&gt;something wrong with&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;…出了毛病；…有问题；…不对头&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200112update1.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;python-标准库学习之-抽象基类-collection-abc&quot;&gt;&lt;a href=&quot;#python-标准库学习之-抽象基类-collection-abc&quot; class=&quot;headerlink&quot; title=&quot;python 标准库学习之 抽象基类 collection.abc&quot;&gt;&lt;/a&gt;python 标准库学习之 抽象基类 collection.abc&lt;/h2&gt;&lt;p&gt;众所周知,python3中所有类默认继承自object类,意味着父类中所有的方法,子类都继承了。&lt;/p&gt;
&lt;p&gt;我个人理解,抽象基类是无法被实例化的,只能子类实现&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/collections.abc.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源代码：&lt;/strong&gt; &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/_collections_abc.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lib/_collections_abc.py&lt;/a&gt; &lt;/p&gt;
&lt;p&gt; 该模块定义了一些 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;抽象基类&lt;/a&gt;，它们可用于判断一个具体类是否具有某一特定的接口；例如，这个类是否可哈希，或其是否为映射类。 &lt;/p&gt;
&lt;p&gt;模块里方法一览,摘自源码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__all__ = [&lt;span class=&quot;string&quot;&gt;&quot;Awaitable&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Coroutine&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;AsyncIterable&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;AsyncIterator&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;AsyncGenerator&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;Hashable&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Iterable&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Iterator&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Generator&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Reversible&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;Sized&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Container&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Callable&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Collection&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;Set&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;MutableSet&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;Mapping&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;MutableMapping&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;MappingView&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;KeysView&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;ItemsView&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;ValuesView&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;Sequence&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;MutableSequence&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;ByteString&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           ]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="collections.abc" scheme="https://pinghailinfeng.gitee.io/tags/collections-abc/"/>
    
  </entry>
  
  <entry>
    <title>python standard library context-manager-types</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/11/python-standard-library-context-manager-types/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/11/python-standard-library-context-manager-types/</id>
    <published>2020-01-11T01:37:04.000Z</published>
    <updated>2020-01-11T02:54:51.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-上下文管理类型"><a href="#python-标准库-上下文管理类型" class="headerlink" title="python 标准库 上下文管理类型"></a>python 标准库 上下文管理类型</h1><p>每日一词:</p><blockquote><p>intresting : </p><p>US [‘ɪntrəstɪŋ]  UK [‘ɪntrəstɪŋ]</p><ul><li><strong>adj.</strong>有趣的；有吸引力的</li><li><strong>v.</strong>“interest”的现在分词</li><li><strong>Web</strong>有意思的；令人感兴趣的；引人入胜的</li></ul><p>比较级：more interesting<br>最高级：most interesting</p></blockquote><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200111_heihei.jpg?raw=true" alt></p><blockquote><p> 大部分时候,你都是一个人在默默努力,这样,距离成功才会更进一步。</p><p>​                                                        – 凭海临风语录</p></blockquote><h2 id="python-标准库学习-上下文管理"><a href="#python-标准库学习-上下文管理" class="headerlink" title="python 标准库学习  上下文管理"></a>python 标准库学习  上下文管理</h2><p>什么是上下文管理器？上下文管理器就是一个用装饰器实现上下文协议管理的对象。主要用于保存和恢复各种全局状态,例如关闭文件等。下面我们来了解具体的内容。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p><code>contextmanager.__enter__()</code></p><p>进入运行时上下文并返回此对象或关联到该运行时上下文的其他对象。 此方法的返回值会绑定到使用此上下文管理器的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的 <code>as</code> 子句中的标识符。一个返回其自身的上下文管理器的例子是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a>。 文件对象会从 <strong>enter</strong>() 返回其自身，以允许 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 被用作 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中的上下文表达式。一个返回关联对象的上下文管理器的例子是 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.localcontext" target="_blank" rel="noopener"><code>decimal.localcontext()</code></a> 所返回的对象。 此种管理器会将活动的 decimal 上下文设为原始 decimal 上下文的一个副本并返回该副本。 这允许对 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的语句体中的当前 decimal 上下文进行更改，而不会影响 <code>with</code> 语句以外的代码。</p></li><li><p><code>contextmanager.__exit__(*exc_type*, *exc_val*, *exc_tb*)</code></p><p>退出运行时上下文并返回一个布尔值旗标来表明所发生的任何异常是否应当被屏蔽。 如果在执行 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的语句体期间发生了异常，则参数会包含异常的类型、值以及回溯信息。 在其他情况下三个参数均为 <code>None</code>。自此方法返回一个真值将导致 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句屏蔽异常并继续执行紧随在 <code>with</code> 语句之后的语句。 否则异常将在此方法结束执行后继续传播。 在此方法执行期间发生的异常将会取代 <code>with</code> 语句的语句体中发生的任何异常。传入的异常绝对不应当被显式地重新引发 —— 相反地，此方法应当返回一个假值以表明方法已成功完成并且不希望屏蔽被引发的异常。 这允许上下文管理代码方便地检测 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#contextmanager.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 方法是否确实已失败。</p></li></ul><h4 id="一个文件操作实例"><a href="#一个文件操作实例" class="headerlink" title="一个文件操作实例"></a>一个文件操作实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">"/etc/hosts"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> file:</span><br><span class="line"><span class="meta">... </span>    dir(file)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__enter__'</span>, <span class="string">'__exit__'</span>, <span class="string">'__format__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'close'</span>, <span class="string">'closed'</span>, <span class="string">'encoding'</span>, <span class="string">'errors'</span>, <span class="string">'fileno'</span>, <span class="string">'flush'</span>, <span class="string">'isatty'</span>, <span class="string">'mode'</span>, <span class="string">'name'</span>, <span class="string">'newlines'</span>, <span class="string">'next'</span>, <span class="string">'read'</span>, <span class="string">'readinto'</span>, <span class="string">'readline'</span>, <span class="string">'readlines'</span>, <span class="string">'seek'</span>, <span class="string">'softspace'</span>, <span class="string">'tell'</span>, <span class="string">'truncate'</span>, <span class="string">'write'</span>, <span class="string">'writelines'</span>, <span class="string">'xreadlines'</span>]</span><br></pre></td></tr></table></figure><p>此时的open返回的对象file,就实现了管理打开文件、关闭文件的上下文管理协议。</p><a id="more"></a><h3 id="with-语句上下文管理器"><a href="#with-语句上下文管理器" class="headerlink" title="with 语句上下文管理器"></a>with 语句上下文管理器</h3><p><em>上下文管理器</em> 是一个对象，它定义了在执行 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句时要建立的运行时上下文。 上下文管理器处理进入和退出所需运行时上下文以执行代码块。 通常使用 <code>with</code> 语句（在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener">with 语句</a> 中描述），但是也可以通过直接调用它们的方法来使用。</p><p>上下文管理器的典型用法包括保存和恢复各种全局状态，锁定和解锁资源，关闭打开的文件等等。</p><p>要了解上下文管理器的更多信息，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#typecontextmanager" target="_blank" rel="noopener">上下文管理器类型</a>。</p><ul><li><p><code>object.__enter__</code>(<em>self</em>)</p><p>进入与此对象相关的运行时上下文。 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句将会绑定这个方法的返回值到 <code>as</code> 子句中指定的目标，如果有的话。</p></li><li><p><code>object.__exit__</code>(<em>self</em>, <em>exc_type</em>, <em>exc_value</em>, <em>traceback</em>)</p><p>退出关联到此对象的运行时上下文。 各个参数描述了导致上下文退出的异常。 如果上下文是无异常地退出的，三个参数都将为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。如果提供了异常，并且希望方法屏蔽此异常（即避免其被传播），则应当返回真值。 否则的话，异常将在退出此方法时按正常流程处理。请注意 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 方法不应该重新引发被传入的异常，这是调用者的责任。</p></li></ul><blockquote><p>可以参考</p><ul><li><p><a href="https://www.python.org/dev/peps/pep-0343" target="_blank" rel="noopener"><strong>PEP 343</strong></a> - “with” 语句</p><p>Python <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的规范描述、背景和示例。</p></li></ul></blockquote><h3 id="自定义上下文管理"><a href="#自定义上下文管理" class="headerlink" title="自定义上下文管理"></a>自定义上下文管理</h3><p>实现<code>__enter__</code> 和 <code>__exit__</code> 方法就是一个实现了上下文管理的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'__init__()'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'__enter__()'</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"__exit__()"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ContextManager():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"OK, we can do something here~~"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">__init__()</span><br><span class="line">__enter__()</span><br><span class="line">OK, we can do something here~~</span><br><span class="line">__exit__()</span><br></pre></td></tr></table></figure><p>另一个不返回当前类的上下文管理器的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerContext</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'InnerContext.__init__(%s)'</span> % obj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'InnerContext.do_something()'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'InnerContext.__del__()'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__init__()'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__enter__()'</span></span><br><span class="line">        <span class="keyword">return</span> InnerContext(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"ContextManager.__exit__()"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ContextManager() <span class="keyword">as</span> obj:</span><br><span class="line">    obj.do_something()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"OK, we can do something here~~"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">ContextManager.__init__()</span><br><span class="line">ContextManager.__enter__()</span><br><span class="line">InnerContext.__init__(&lt;__main__.ContextManager object at <span class="number">0x1012f95d0</span>&gt;)</span><br><span class="line">InnerContext.do_something()</span><br><span class="line">OK, we can do something here~~</span><br><span class="line">ContextManager.__exit__()</span><br><span class="line">InnerContext.__del__()</span><br></pre></td></tr></table></figure><p>异常处理的例子 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, flag)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__init__(%s)'</span> % flag</span><br><span class="line">        self.flag = flag</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__enter__()'</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__exit__(%s, %s, %s)'</span> % (exc_type, exc_val, exc_tb)</span><br><span class="line">        <span class="keyword">return</span> self.flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ContextManager(<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">'error message handled'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">with</span> ContextManager(<span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">'error message propagated'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">ContextManager.__init__(<span class="literal">True</span>)</span><br><span class="line">ContextManager.__enter__()</span><br><span class="line">ContextManager.__exit__(&lt;type <span class="string">'exceptions.RuntimeError'</span>&gt;, error message handled, &lt;traceback object at <span class="number">0x10d69dbd8</span>&gt;)</span><br><span class="line"></span><br><span class="line">ContextManager.__init__(<span class="literal">False</span>)</span><br><span class="line">ContextManager.__enter__()</span><br><span class="line">ContextManager.__exit__(&lt;type <span class="string">'exceptions.RuntimeError'</span>&gt;, error message propagated, &lt;traceback object at <span class="number">0x109e0fbd8</span>&gt;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"ContextManager.py"</span>, line <span class="number">19</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">'error message propagated'</span>)</span><br><span class="line">RuntimeError: error message propagated</span><br></pre></td></tr></table></figure><h3 id="contextlib-模块"><a href="#contextlib-模块" class="headerlink" title="contextlib 模块"></a>contextlib 模块</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/contextlib.html#contextlib.contextmanager" target="_blank" rel="noopener">参考文档</a></p><p>源代码 <a href="https://github.com/python/cpython/tree/3.8/Lib/contextlib.py" target="_blank" rel="noopener">Lib/contextlib.py</a></p><p>这个内置模块实现了上下文管理,使用<code>with</code>关键字。</p><p>主要方法如下(节选自源码):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">"asynccontextmanager"</span>, <span class="string">"contextmanager"</span>, <span class="string">"closing"</span>, <span class="string">"nullcontext"</span>,</span><br><span class="line">           <span class="string">"AbstractContextManager"</span>, <span class="string">"AbstractAsyncContextManager"</span>,</span><br><span class="line">           <span class="string">"AsyncExitStack"</span>, <span class="string">"ContextDecorator"</span>, <span class="string">"ExitStack"</span>,</span><br><span class="line">           <span class="string">"redirect_stdout"</span>, <span class="string">"redirect_stderr"</span>, <span class="string">"suppress"</span>]</span><br></pre></td></tr></table></figure><h4 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h4><p><em>class</em> <code>contextlib.AbstractContextManager</code></p><blockquote><p>同步的上下文管理类</p></blockquote><p><em>class</em> <code>contextlib.AbstractAsyncContextManager</code></p><blockquote><p>异步的上下文管理类</p></blockquote><h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><ul><li><p><a href="mailto:`@contextlib.contextmanager" target="_blank" rel="noopener">`@contextlib.contextmanager</a>`</p><p>一个实现了上下文资源管理的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">managed_resource</span><span class="params">(*args, **kwds)</span>:</span></span><br><span class="line">    <span class="comment"># Code to acquire resource, e.g.:</span></span><br><span class="line">    resource = acquire_resource(*args, **kwds)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> resource</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># Code to release resource, e.g.:</span></span><br><span class="line">        release_resource(resource)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> managed_resource(timeout=<span class="number">3600</span>) <span class="keyword">as</span> resource:</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># Resource is released at the end of this block,</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># even if code in the block raises an exception</span></span><br></pre></td></tr></table></figure><p>==tips== : 注意这里 返回的是generator对象，每次迭代器只会yield一个对象出来,这个值会用在<code>with</code>语句中,绑定到<code>as</code> 后的对象上。 </p></li><li><p>@contextlib.asynccontextmanager`</p><p>下面是一个实现了异步上下文管理器的实例,关于操作数据库对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> asynccontextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_connection</span><span class="params">()</span>:</span></span><br><span class="line">    conn = <span class="keyword">await</span> acquire_db_connection()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> conn</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">await</span> release_db_connection(conn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_all_users</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> get_connection() <span class="keyword">as</span> conn:</span><br><span class="line">        <span class="keyword">return</span> conn.query(<span class="string">'SELECT ...'</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li><p><code>contextlib.closing</code>(<em>thing</em>)</p><p>返回一个上下文管理对象,在语句结束之前被调用</p><p>相当于下面的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closing</span><span class="params">(thing)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> thing</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        thing.close()</span><br></pre></td></tr></table></figure><p>也可以这样实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> closing</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> closing(urlopen(<span class="string">'http://www.python.org'</span>)) <span class="keyword">as</span> page:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> page:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>contextlib.nullcontext</code></p><blockquote><p>返回一个上下文管理对象( 实现了<code>__enter__</code>方法)</p></blockquote><p>一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunction</span><span class="params">(arg, ignore_exceptions=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> ignore_exceptions:</span><br><span class="line">        <span class="comment"># Use suppress to ignore all exceptions.</span></span><br><span class="line">        cm = contextlib.suppress(Exception)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Do not ignore any exceptions, cm has no effect.</span></span><br><span class="line">        cm = contextlib.nullcontext()</span><br><span class="line">    <span class="keyword">with</span> cm:</span><br><span class="line">        <span class="comment"># Do something</span></span><br></pre></td></tr></table></figure></li></ul><p>  另一个例子</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_file</span><span class="params">(file_or_path)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(file_or_path, str):</span><br><span class="line">        <span class="comment"># If string, open file</span></span><br><span class="line">        cm = open(file_or_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Caller is responsible for closing file</span></span><br><span class="line">        cm = nullcontext(file_or_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> cm <span class="keyword">as</span> file:</span><br><span class="line">        <span class="comment"># Perform processing on the file</span></span><br></pre></td></tr></table></figure><ul><li><p><code>contextlib.suppress</code></p><blockquote><p>返回一个声明的异常对象的上下文管理</p></blockquote><p>一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> suppress</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> suppress(FileNotFoundError):</span><br><span class="line">    os.remove(<span class="string">'somefile.tmp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> suppress(FileNotFoundError):</span><br><span class="line">    os.remove(<span class="string">'someotherfile.tmp'</span>)</span><br></pre></td></tr></table></figure><p>和下面的代码等价</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.remove(<span class="string">'somefile.tmp'</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.remove(<span class="string">'someotherfile.tmp'</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>contextlib.redirect_stdout</code></p><blockquote><p>临时输出标准输出的上下文管理器</p></blockquote></li><li><p><code>contextlib.redirect_stderr</code></p><blockquote><p>临时输出标准错误的上下文管理器</p></blockquote></li><li><p><em>class</em> <code>contextlib.ContextDecorator</code></p></li></ul><blockquote><p>允许一个类像装饰器那样使用,<code>ContextDecorator</code> 正好实现了<code>__enter__</code> and <code>__exit__</code> 方法。</p><p>使用contextlib就自动调用这个装饰器。</p></blockquote><p> 一个实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> ContextDecorator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontext</span><span class="params">(ContextDecorator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Starting'</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *exc)</span>:</span></span><br><span class="line">        print(<span class="string">'Finishing'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@mycontext()</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'The bit in the middle'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>function()</span><br><span class="line">Starting</span><br><span class="line">The bit <span class="keyword">in</span> the middle</span><br><span class="line">Finishing</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> mycontext():</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'The bit in the middle'</span>)</span><br><span class="line">...</span><br><span class="line">Starting</span><br><span class="line">The bit <span class="keyword">in</span> the middle</span><br><span class="line">Finishing</span><br></pre></td></tr></table></figure><p>其实本质上就是实现了语法糖</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> cm():</span><br><span class="line">        <span class="comment"># Do stuff</span></span><br></pre></td></tr></table></figure><p><code>ContextDecorator</code> 允许你这样使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@cm()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Do stuff</span></span><br></pre></td></tr></table></figure><p>允许你通过继承ContextBaseClass和ContextDecorator,实现Mixin class(我也不知道该如何翻译,姑且翻译成混合继承吧)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> ContextDecorator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontext</span><span class="params">(ContextBaseClass, ContextDecorator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *exc)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li><em>class</em> <code>contextlib.ExitStack</code></li></ul><blockquote><p>一个上下文管理器可以被设计成自动合并其他上下文管理器,清除方法(栈),尤其是那些需要输入数据的功能实现。</p><p>这里我看了源码,通过一个栈结构管理上下文管理， 其实就是实现了一个上下文管理器栈</p><p>下面是一个例子:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ExitStack() <span class="keyword">as</span> stack:</span><br><span class="line">    files = [stack.enter_context(open(fname)) <span class="keyword">for</span> fname <span class="keyword">in</span> filenames]</span><br><span class="line">    <span class="comment"># All opened files will automatically be closed at the end of</span></span><br><span class="line">    <span class="comment"># the with statement, even if attempts to open files later</span></span><br><span class="line">    <span class="comment"># in the list raise an exception</span></span><br></pre></td></tr></table></figure><blockquote><p>个人理解这是一个低级的api,内部实现了,你无需关心何时该调用该方法,由python内部去处理。</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p>最近恰好看flask的源码,flask的生命周期管理也是使用上下文管理装饰器实现。</p><p>等有空再更新一篇吧。</p><p>今天就到这里,祝大家周末愉快！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-上下文管理类型&quot;&gt;&lt;a href=&quot;#python-标准库-上下文管理类型&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 上下文管理类型&quot;&gt;&lt;/a&gt;python 标准库 上下文管理类型&lt;/h1&gt;&lt;p&gt;每日一词:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;intresting : &lt;/p&gt;
&lt;p&gt;US [‘ɪntrəstɪŋ]  UK [‘ɪntrəstɪŋ]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;adj.&lt;/strong&gt;有趣的；有吸引力的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;v.&lt;/strong&gt;“interest”的现在分词&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web&lt;/strong&gt;有意思的；令人感兴趣的；引人入胜的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较级：more interesting&lt;br&gt;最高级：most interesting&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200111_heihei.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 大部分时候,你都是一个人在默默努力,这样,距离成功才会更进一步。&lt;/p&gt;
&lt;p&gt;​                                                        – 凭海临风语录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;python-标准库学习-上下文管理&quot;&gt;&lt;a href=&quot;#python-标准库学习-上下文管理&quot; class=&quot;headerlink&quot; title=&quot;python 标准库学习  上下文管理&quot;&gt;&lt;/a&gt;python 标准库学习  上下文管理&lt;/h2&gt;&lt;p&gt;什么是上下文管理器？上下文管理器就是一个用装饰器实现上下文协议管理的对象。主要用于保存和恢复各种全局状态,例如关闭文件等。下面我们来了解具体的内容。&lt;/p&gt;
&lt;h3 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;contextmanager.__enter__()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进入运行时上下文并返回此对象或关联到该运行时上下文的其他对象。 此方法的返回值会绑定到使用此上下文管理器的 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; 语句的 &lt;code&gt;as&lt;/code&gt; 子句中的标识符。一个返回其自身的上下文管理器的例子是 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;file object&lt;/a&gt;。 文件对象会从 &lt;strong&gt;enter&lt;/strong&gt;() 返回其自身，以允许 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/functions.html#open&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; 被用作 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; 语句中的上下文表达式。一个返回关联对象的上下文管理器的例子是 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.localcontext&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;decimal.localcontext()&lt;/code&gt;&lt;/a&gt; 所返回的对象。 此种管理器会将活动的 decimal 上下文设为原始 decimal 上下文的一个副本并返回该副本。 这允许对 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; 语句的语句体中的当前 decimal 上下文进行更改，而不会影响 &lt;code&gt;with&lt;/code&gt; 语句以外的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;contextmanager.__exit__(*exc_type*, *exc_val*, *exc_tb*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;退出运行时上下文并返回一个布尔值旗标来表明所发生的任何异常是否应当被屏蔽。 如果在执行 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; 语句的语句体期间发生了异常，则参数会包含异常的类型、值以及回溯信息。 在其他情况下三个参数均为 &lt;code&gt;None&lt;/code&gt;。自此方法返回一个真值将导致 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; 语句屏蔽异常并继续执行紧随在 &lt;code&gt;with&lt;/code&gt; 语句之后的语句。 否则异常将在此方法结束执行后继续传播。 在此方法执行期间发生的异常将会取代 &lt;code&gt;with&lt;/code&gt; 语句的语句体中发生的任何异常。传入的异常绝对不应当被显式地重新引发 —— 相反地，此方法应当返回一个假值以表明方法已成功完成并且不希望屏蔽被引发的异常。 这允许上下文管理代码方便地检测 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/stdtypes.html#contextmanager.__exit__&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; 方法是否确实已失败。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;一个文件操作实例&quot;&gt;&lt;a href=&quot;#一个文件操作实例&quot; class=&quot;headerlink&quot; title=&quot;一个文件操作实例&quot;&gt;&lt;/a&gt;一个文件操作实例&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; open(&lt;span class=&quot;string&quot;&gt;&quot;/etc/hosts&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;r&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; file:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    dir(file)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&#39;__class__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__delattr__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__doc__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__enter__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__exit__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__format__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__getattribute__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__hash__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__init__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__iter__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__new__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__reduce__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__reduce_ex__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__repr__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__setattr__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__sizeof__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__str__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__subclasshook__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;close&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;closed&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;encoding&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;errors&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;fileno&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;flush&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;isatty&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;mode&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;newlines&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;next&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;read&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;readinto&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;readline&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;readlines&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;seek&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;softspace&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;tell&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;truncate&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;write&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;writelines&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;xreadlines&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此时的open返回的对象file,就实现了管理打开文件、关闭文件的上下文管理协议。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="context-manager-types" scheme="https://pinghailinfeng.gitee.io/tags/context-manager-types/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library operator</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/10/python-standard-library-operator/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/10/python-standard-library-operator/</id>
    <published>2020-01-10T01:21:50.000Z</published>
    <updated>2020-01-10T03:11:40.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-operator"><a href="#python-标准库-operator" class="headerlink" title="python 标准库 operator"></a>python 标准库 operator</h1><p>今天的关键词: trouble </p><blockquote><p>trouble</p><p>[英]  [ˈtrʌbl]</p><p>[美] [ˈtrʌbəl]</p><p>n.麻烦； 烦恼； 故障； 动乱；</p><p>vi.费心； 烦恼；</p><p>vt.麻烦； 使烦恼； 折磨；</p></blockquote><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200110_fan2.jpg?raw=true" alt></p><h2 id="python-标准库学习-operator"><a href="#python-标准库学习-operator" class="headerlink" title="python 标准库学习  operator"></a>python 标准库学习  operator</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/operator.html#module-operator" target="_blank" rel="noopener"><code>operator</code></a> 模块提供了一套与Python的内置运算符对应的高效率函数。例如，<code>operator.add(x, y)</code> 与表达式 <code>x+y</code> 相同。 许多函数名与特殊方法名相同，只是没有双下划线。为了向后兼容性，也保留了许多包含双下划线的函数。为了表述清楚，建议使用没有双下划线的函数。</p><p>函数包含的种类有：对象的比较运算、逻辑运算、数学运算以及序列运算。</p><p>对象比较函数适用于所有的对象，函数名根据它们对应的比较运算符命名。</p><h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><p><code>operator.lt(*a*, *b*)</code></p><p><code>operator.le(*a*, *b*)</code></p><p><code>operator.eq(*a*, *b*)</code></p><p><code>operator.ne*a*, *b*)</code></p><p><code>operator.ge*a*, *b*)</code></p><p><code>operator.gt*a*, *b*)</code></p><p><code>operator.__lt__*a*, *b*)</code></p><p><code>operator.__le__*a*, *b*)</code></p><p><code>operator.__eq__*a*, *b*)</code></p><p><code>operator.__ne__*a*, *b*)</code></p><p><code>operator.__ge__*a*, *b*)</code></p><p><code>operator.__gt__*a*, *b*)</code></p><a id="more"></a><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><ul><li><p><code>operator.not_(*obj*)`</code></p></li><li><p><code>operator.__not__(*obj*)</code></p><p>返回 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#not" target="_blank" rel="noopener"><code>not</code></a><code>*obj* 的结果。 （请注意对象实例并没有 [</code><strong>not</strong>()<code>](https://docs.python.org/zh-cn/3.8/library/operator.html#operator.__not__) 方法；只有解释器核心可定义此操作。 结果会受 [</code><strong>bool</strong>()<code>](https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__bool__) 和 [</code><strong>len</strong>()`](<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__len__" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__len__</a>) 方法影响。）</p></li><li><p>`operator.truth(<em>obj</em>)</p><p>如果 <em>obj</em> 为真值则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>，否则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>。 这等价于使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#bool" target="_blank" rel="noopener"><code>bool</code></a> 构造器。</p></li><li><p><code>operator.is_(*a*, *b*)</code></p><p>返回 <code>a is b</code>。 检测对象标识。</p></li><li><p><code>operator.is_not(*a*, *b*)</code></p><p>返回 <code>a is not b</code>。 检测对象标识。</p></li></ul><h3 id="数学运算和位运算"><a href="#数学运算和位运算" class="headerlink" title="数学运算和位运算"></a>数学运算和位运算</h3><ul><li><p><code>operator.abs(*obj*)</code></p></li><li><p><code>operator.__abs__(*obj*)</code></p><p>返回 <em>obj</em> 的绝对值。</p></li><li><p><code>operator.add(*a*, *b*)</code></p></li><li><p><code>operator.__add__(*a*, *b*)</code></p><p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a + b</code>。</p></li><li><p><code>operator.and_(*a*, *b*)</code></p></li><li><p><code>operator.__and__(*a*, *b*)</code></p><p>返回 <em>x</em> 和 <em>y</em> 按位与的结果。</p></li><li><p><code>operator.floordiv(*a*, *b*)</code></p></li><li><p><code>operator.__floordiv__(*a*, *b*)</code></p><p>返回 <code>a // b</code>。</p></li><li><p><code>operator.index(*a*)</code></p></li><li><p><code>operator.__index__(*a*)</code></p><p>返回 <em>a</em> 转换为整数的结果。 等价于 <code>a.__index__()`</code>。</p></li><li><p><code>operator.inv(*obj*)</code></p></li><li><p><code>operator.invert(*obj*)</code></p></li><li><p><code>operator.__inv__(*obj*)</code></p></li><li><p><code>operator.__invert__(*obj*)</code></p><p>返回数字 <em>obj</em> 按位取反的结果。 这等价于 <code>~obj</code>。</p></li><li><p><code>operator.lshift(*a*, *b*)</code></p></li><li><p><code>operator.__lshift__(*a*, *b*)</code></p><p>返回 <em>a</em> 左移 <em>b</em> 位的结果。</p></li><li><p><code>operator.mod(*a*, *b*)</code></p></li><li><p><code>operator.__mod__(*a*, *b*)</code></p><p>返回 <code>a % b</code>。</p></li><li><p><code>operator.mul(*a*, *b*)</code></p></li><li><p><code>operator.__mul__(*a*, *b*)</code></p><p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a * b</code>。</p></li><li><p><code>operator.matmul(*a*, *b*)</code></p></li><li><p><code>operator.__matmul__(*a*, *b*)</code></p><p>返回 <code>a @ b</code>。</p></li><li><p><code>operator.neg(*obj*)</code></p></li><li><p><code>operator.__neg__(*obj*)</code></p><p>返回 <em>obj</em> 取负的结果 (<code>-obj</code>)`。</p></li><li><p><code>operator.or_(*a*, *b*)</code></p></li><li><p><code>operator.__or__(*a*, *b*)</code></p><p>返回 <em>a</em> 和 <em>b</em> 按位或的结果。</p></li><li><p><code>operator.pos(*obj*)</code></p></li><li><p><code>operator.__pos__(*obj*)</code></p><p>返回 <em>obj</em> 取正的结果 (<code>+obj</code>)`。</p></li><li><p><code>operator.pow(*a*, *b*)</code></p></li><li><p><code>operator.__pow__(*a*, *b*)</code></p><p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a ** b</code>。</p></li><li><p><code>operator.rshift(*a*, *b*)</code></p></li><li><p><code>operator.__rshift__(*a*, *b*)</code></p><p>返回 <em>a</em> 右移 <em>b</em> 位的结果。</p></li><li><p><code>operator.sub(*a*, *b*)</code></p></li><li><p><code>operator.__sub__(*a*, *b*)</code></p><p>返回 <code>a - b</code>。</p></li><li><p><code>operator.truediv(*a*, *b*)</code></p></li><li><p><code>operator.__truediv__(*a*, *b*)</code></p><p>返回 <code>a / b</code> 例如 2/3 将等于 .66 而不是 0。 这也被称为“真”除法。</p></li><li><p><code>operator.xor(*a*, *b*)</code></p></li><li><p><code>operator.__xor__(*a*, *b*)</code></p><p>返回 <em>a</em> 和 <em>b</em> 按位异或的结果。</p></li></ul><p>适用于序列的操作（其中一些也适用于映射）包括：</p><ul><li><p><code>operator.concat(*a*, *b*)</code></p></li><li><p><code>operator.__concat__(*a*, *b*)</code></p><p>对于序列 <em>a</em> 和 <em>b</em>，返回 <code>a + b</code>。</p></li><li><p><code>operator.contains(*a*, *b*)</code></p></li><li><p><code>operator.__contains__(*a*, *b*)</code></p><p>返回 <code>b in a</code> 检测的结果。 请注意操作数是反序的。</p></li><li><p><code>operator.countOf(*a*, *b*)</code></p><p>返回 <em>b</em> 在 <em>a</em> 中的出现次数。</p></li><li><p><code>operator.delitem(*a*, *b*)</code></p></li><li><p><code>operator.__delitem__(*a*, *b*)</code></p><p>移除索引号 <em>b</em> 上的值 <em>a</em>。</p></li><li><p><code>operator.getitem(*a*, *b*)</code></p></li><li><p><code>operator.__getitem__(*a*, *b*)</code></p><p>返回索引号 <em>b</em> 上的值 <em>a</em>。</p></li><li><p><code>operator.indexOf(*a*, *b*)</code></p><p>返回 <em>b</em> 在 <em>a</em> 中首次出现所在的索引号。</p></li><li><p><code>operator.setitem(*a*, *b*, *c*)</code></p></li><li><p><code>operator.__setitem__(*a*, *b*, *c*)</code></p><p>将索引号 <em>b</em> 上的值 <em>a</em> 设为 <em>c</em>。</p></li><li><p><code>operator.length_hint(*obj*, *default=0*)</code></p><p>返回对象 <em>o</em> 的估计长度。 首先尝试返回其实际长度，再使用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__length_hint__" target="_blank" rel="noopener"><code>object.__length_hint__()</code></a> 得出估计值，最后返回默认值。</p></li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><code>operator.attrgetter(*attr*)</code></p><p><code>operator.attrgetter(**attrs*)</code></p><p>返回一个可从操作数中获取 <em>attr</em> 的可调用对象。 如果请求了一个以上的属性，则返回一个属性元组。 属性名称还可包含点号。 例如：</p><ul><li>在 <code>f = attrgetter(&#39;name&#39;)</code> 之后，调用 <code>f(b)</code> 将返回 <code>b.name</code>。</li><li>在 <code>f = attrgetter(&#39;name&#39;, &#39;date&#39;)</code> 之后，调用 <code>f(b)</code> 将返回 (b.name, b.date)`。</li><li>在 <code>f = attrgetter(&#39;name.first&#39;, &#39;name.last&#39;)</code> 之后，调用 <code>f(b)</code> 将返回 (b.name.first, b.name.last)`。</li></ul><p>`operator.itemgetter(<em>item</em>)</p><p>`operator.itemgetter(*<em>items</em>)</p><p>返回一个使用操作数的 <a href="https://docs.python.org/zh-cn/3.8/library/operator.html#operator.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法从操作数中获取 <em>item</em> 的可调用对象。 如果指定了多个条目，则返回一个查找值的元组。 例如：</p><ul><li>在 <code>f = itemgetter(2)</code> 之后，调用 <code>f(r)</code> 将返回 <code>r[2]</code>。</li><li>在 <code>g = itemgetter(2, 5, 3)</code> 之后，调用 <code>g(r)</code> 将返回 (r[2], r[5], r[3])`。</li></ul><h3 id="将运算符映射到函数"><a href="#将运算符映射到函数" class="headerlink" title="将运算符映射到函数"></a>将运算符映射到函数</h3><table><thead><tr><th>运算</th><th>语法</th><th>函数</th></tr></thead><tbody><tr><td>加法</td><td><code>a + b</code></td><td><code>add(a, b)</code></td></tr><tr><td>字符串拼接</td><td><code>seq1 + seq2</code></td><td><code>concat(seq1, seq2)</code></td></tr><tr><td>包含测试</td><td><code>obj in seq</code></td><td><code>contains(seq, obj)</code></td></tr><tr><td>除法</td><td><code>a / b</code></td><td><code>truediv(a, b)</code></td></tr><tr><td>除法</td><td><code>a // b</code></td><td><code>floordiv(a, b)</code></td></tr><tr><td>按位与</td><td><code>a &amp; b</code></td><td><code>and_(a, b)</code></td></tr><tr><td>按位异或</td><td><code>a ^ b</code></td><td><code>xor(a, b)</code></td></tr><tr><td>按位取反</td><td><code>~ a</code></td><td><code>invert(a)</code></td></tr><tr><td>按位或</td><td>`a</td><td>b`</td><td><code>or_(a, b)</code></td></tr><tr><td>取幂</td><td><code>a ** b</code></td><td><code>pow(a, b)</code></td></tr><tr><td>标识</td><td><code>a is b</code></td><td><code>is_(a, b)</code></td></tr><tr><td>标识</td><td><code>a is not b</code></td><td><code>is_not(a, b)</code></td></tr><tr><td>索引赋值</td><td><code>obj[k] = v</code></td><td><code>setitem(obj, k, v)</code></td></tr><tr><td>索引删除</td><td><code>del obj[k]</code></td><td><code>delitem(obj, k)</code></td></tr><tr><td>索引取值</td><td><code>obj[k]</code></td><td><code>getitem(obj, k)</code></td></tr><tr><td>左移</td><td><code>a &lt;&lt; b</code></td><td><code>lshift(a, b)</code></td></tr><tr><td>取模</td><td><code>a % b</code></td><td><code>mod(a, b)</code></td></tr><tr><td>乘法</td><td><code>a * b</code></td><td><code>mul(a, b)</code></td></tr><tr><td>矩阵乘法</td><td><code>a @ b</code></td><td><code>matmul(a, b)</code></td></tr><tr><td>取反（算术）</td><td><code>- a</code></td><td><code>neg(a)</code></td></tr><tr><td>取反（逻辑）</td><td><code>not a</code></td><td><code>not_(a)</code></td></tr><tr><td>正数</td><td><code>+ a</code></td><td><code>pos(a)</code></td></tr><tr><td>右移</td><td><code>a &gt;&gt; b</code></td><td><code>rshift(a, b)</code></td></tr><tr><td>切片赋值</td><td><code>seq[i:j] = values</code></td><td><code>setitem(seq, slice(i, j), values)</code></td></tr><tr><td>切片删除</td><td><code>del seq[i:j]</code></td><td><code>delitem(seq, slice(i, j))</code></td></tr><tr><td>切片取值</td><td><code>seq[i:j]</code></td><td><code>getitem(seq, slice(i, j))</code></td></tr><tr><td>字符串格式化</td><td><code>s % obj</code></td><td><code>mod(s, obj)</code></td></tr><tr><td>减法</td><td><code>a - b</code></td><td><code>sub(a, b)</code></td></tr><tr><td>真值测试</td><td><code>obj</code></td><td><code>truth(obj)</code></td></tr><tr><td>比较</td><td><code>a &lt; b</code></td><td><code>lt(a, b)</code></td></tr><tr><td>比较</td><td><code>a &lt;= b</code></td><td><code>le(a, b)</code></td></tr><tr><td>相等</td><td><code>a == b</code></td><td><code>eq(a, b)</code></td></tr><tr><td>不等</td><td><code>a != b</code></td><td><code>ne(a, b)</code></td></tr><tr><td>比较</td><td><code>a &gt;= b</code></td><td><code>ge(a, b)</code></td></tr><tr><td>比较</td><td><code>a &gt; b</code></td><td><code>gt(a, b)</code></td></tr></tbody></table><h3 id="原地运算符"><a href="#原地运算符" class="headerlink" title="原地运算符"></a>原地运算符</h3><ul><li><p><code>operator.iadd(*a*, *b*)</code></p></li><li><p><code>operator.__iadd__(*a*, *b*)</code></p><p><code>a = iadd(a, b)</code> 等价于 <code>a += b</code>。</p></li><li><p><code>operator.iand(*a*, *b*)</code></p></li><li><p><code>operator.__iand__(*a*, *b*)</code></p><p><code>a = iand(a, b)</code> 等价于 <code>a &amp;= b</code>。</p></li><li><p><code>operator.iconcat(*a*, *b*)</code></p></li><li><p><code>operator.__iconcat__(*a*, *b*)</code></p><p><code>a = iconcat(a, b)</code> 等价于 <code>a += b</code> 其中 <em>a</em> 和 <em>b</em> 为序列。</p></li><li><p><code>operator.ifloordiv(*a*, *b*)</code></p></li><li><p><code>operator.__ifloordiv__(*a*, *b*)</code></p><p><code>a = ifloordiv(a, b)</code> 等价于 <code>a //= b</code>。</p></li><li><p><code>operator.ilshift(*a*, *b*)</code></p></li><li><p><code>operator.__ilshift__(*a*, *b*)</code></p><p><code>a = ilshift(a, b)</code> 等价于 <code>a &lt;&lt;= b</code>。</p></li><li><p><code>operator.imod(*a*, *b*)</code></p></li><li><p><code>operator.__imod__(*a*, *b*)</code></p><p><code>a = imod(a, b)</code> 等价于 <code>a %= b</code>。</p></li><li><p><code>operator.imul(*a*, *b*)</code></p></li><li><p><code>operator.__imul__(*a*, *b*)</code></p><p><code>a = imul(a, b)</code> 等价于 <code>a *= b</code>。</p></li><li><p><code>operator.imatmul(*a*, *b*)</code></p></li><li><p><code>operator.__imatmul__(*a*, *b*)</code></p><p><code>a = imatmul(a, b)</code> 等价于 <code>a @= b</code>。<em>3.5 新版功能.</em></p></li><li><p><code>operator.ior(*a*, *b*)</code></p></li><li><p><code>operator.__ior__(*a*, *b*)</code></p><p><code>a = ior(a, b)</code> 等价于 <code>a |= b</code>。</p></li><li><p><code>operator.ipow(*a*, *b*)</code></p></li><li><p><code>operator.__ipow__(*a*, *b*)</code></p><p><code>a = ipow(a, b)</code> 等价于 <code>a **= b</code>。</p></li><li><p><code>operator.irshift(*a*, *b*)</code></p></li><li><p><code>operator.__irshift__(*a*, *b*)</code></p><p><code>a = irshift(a, b)</code> 等价于 <code>a &gt;&gt;= b</code>。</p></li><li><p><code>operator.isub(*a*, *b*)</code></p></li><li><p><code>operator.__isub__(*a*, *b*)</code></p><p><code>a = isub(a, b)</code> 等价于 <code>a -= b</code>。</p></li><li><p><code>operator.itruediv(*a*, *b*)</code></p></li><li><p><code>operator.__itruediv__(*a*, *b*)</code></p><p><code>a = itruediv(a, b)</code> 等价于 <code>a /= b</code>。</p></li><li><p><code>operator.ixor(*a*, *b*)</code></p></li><li><p><code>operator.__ixor__(*a*, *b*)</code></p><p><code>a = ixor(a, b)</code> 等价于 <code>a ^= b</code>。</p></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>朋友建议我说,别光说标准库的基本使用,最好有一些实际的例子,接下来我会在每一篇博客的最后给大家一些实际应用的例子，欢迎大家批评指正。</p><p>稍后我会在对应的文章下面开通gitalk,大家可以及时给我留言。</p><p>实现一个简单的计算器,不使用if else</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculator</span><span class="params">(a, b, k)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'+'</span>: add,</span><br><span class="line">        <span class="string">'-'</span>: sub,</span><br><span class="line">        <span class="string">'*'</span>: mul,</span><br><span class="line">        <span class="string">'/'</span>: truediv,</span><br><span class="line">        <span class="string">'**'</span>: pow</span><br><span class="line">    &#125;[k](a, b)</span><br><span class="line"></span><br><span class="line">calculator(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'+'</span>)  <span class="comment"># 3</span></span><br><span class="line">calculator(<span class="number">3</span>, <span class="number">4</span>, <span class="string">'**'</span>)  <span class="comment"># 81</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-operator&quot;&gt;&lt;a href=&quot;#python-标准库-operator&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 operator&quot;&gt;&lt;/a&gt;python 标准库 operator&lt;/h1&gt;&lt;p&gt;今天的关键词: trouble &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;trouble&lt;/p&gt;
&lt;p&gt;[英]  [ˈtrʌbl]&lt;/p&gt;
&lt;p&gt;[美] [ˈtrʌbəl]&lt;/p&gt;
&lt;p&gt;n.麻烦； 烦恼； 故障； 动乱；&lt;/p&gt;
&lt;p&gt;vi.费心； 烦恼；&lt;/p&gt;
&lt;p&gt;vt.麻烦； 使烦恼； 折磨；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200110_fan2.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;python-标准库学习-operator&quot;&gt;&lt;a href=&quot;#python-标准库学习-operator&quot; class=&quot;headerlink&quot; title=&quot;python 标准库学习  operator&quot;&gt;&lt;/a&gt;python 标准库学习  operator&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/operator.html#module-operator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;operator&lt;/code&gt;&lt;/a&gt; 模块提供了一套与Python的内置运算符对应的高效率函数。例如，&lt;code&gt;operator.add(x, y)&lt;/code&gt; 与表达式 &lt;code&gt;x+y&lt;/code&gt; 相同。 许多函数名与特殊方法名相同，只是没有双下划线。为了向后兼容性，也保留了许多包含双下划线的函数。为了表述清楚，建议使用没有双下划线的函数。&lt;/p&gt;
&lt;p&gt;函数包含的种类有：对象的比较运算、逻辑运算、数学运算以及序列运算。&lt;/p&gt;
&lt;p&gt;对象比较函数适用于所有的对象，函数名根据它们对应的比较运算符命名。&lt;/p&gt;
&lt;h3 id=&quot;比较运算&quot;&gt;&lt;a href=&quot;#比较运算&quot; class=&quot;headerlink&quot; title=&quot;比较运算&quot;&gt;&lt;/a&gt;比较运算&lt;/h3&gt;&lt;p&gt;&lt;code&gt;operator.lt(*a*, *b*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator.le(*a*, *b*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator.eq(*a*, *b*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator.ne*a*, *b*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator.ge*a*, *b*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator.gt*a*, *b*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator.__lt__*a*, *b*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator.__le__*a*, *b*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator.__eq__*a*, *b*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator.__ne__*a*, *b*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator.__ge__*a*, *b*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;operator.__gt__*a*, *b*)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="operator" scheme="https://pinghailinfeng.gitee.io/tags/operator/"/>
    
  </entry>
  
  <entry>
    <title>python standard library http.cookies</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/09/python-standard-library-http-cookies/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/09/python-standard-library-http-cookies/</id>
    <published>2020-01-09T01:25:34.000Z</published>
    <updated>2020-01-09T06:08:43.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-http-cookies"><a href="#python-标准库-http-cookies" class="headerlink" title="python 标准库 http.cookies"></a>python 标准库 http.cookies</h1><p>最近需要教孩子自然拼读,所以我想还是每天用一个关键词描述吧。</p><blockquote><p>traffic  .n UK /træf.ɪk/  US /ˈtræf.ɪk/  交通(拥堵)</p><p><em>There was heavy/a lot of traffic on the roads this morning.</em>今天早晨道路上车流量很大。</p><p><em>We got stuck in traffic for several hours.</em>我们碰上交通阻塞被堵了好几个小时。</p><p><em>New measures have been introduced to try and ease traffic congestion in the city.</em>这个城市已经采取了新措施，试图缓解交通拥堵。</p><p><em>Five people were injured in a traffic accident (= one involving vehicles).</em>有5人在交通事故中受伤。</p><p>US <em>I heard about the accident on the traffic report on the radio this morning.</em>我在今早电台的交通节目中听到了这起事故。</p><p><em>Air traffic has increased 30 percent in the last decade.</em>在过去的10年里，空中交通量增加了30%。</p></blockquote><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200109_traffic.jpg?raw=true" alt></p><h2 id="python-标准库学习-http-cookies"><a href="#python-标准库学习-http-cookies" class="headerlink" title="python 标准库学习   http.cookies"></a>python 标准库学习   http.cookies</h2><p>http.cookies 模块定义了类实现了http状态管理机制和cookies概念。不仅支持字符串格式化的cookie值,还支持任何序列化对象的cookie值。</p><p>模块的实现完全遵循 <a href="https://tools.ietf.org/html/rfc2109.html" target="_blank" rel="noopener"><strong>RFC 2109</strong></a> 和  <a href="https://tools.ietf.org/html/rfc2068.html" target="_blank" rel="noopener"><strong>RFC 2068</strong></a> 协议规范。但MSIE 3.0x不遵循那些规范中概述的字符规则，并且当涉及Cookie处理时，许多当今的浏览器和服务器已经放宽了解析规则。</p><p>Cookie名定义字符集中非法字符囊括在 <code>string.ascii_letters</code>,<code>string.digits</code> 和 <code>!#$%&amp;&#39;*+-.^_</code>|~:`中。    </p><h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><ul><li><p><em>exception</em> <code>http.cookies.CookieError</code></p><p>违反<a href="https://tools.ietf.org/html/rfc2109.html" target="_blank" rel="noopener"><strong>RFC 2109</strong></a> 规范中的错误,例如:不正确的属性或不正确的Set-Cookies header</p></li><li><p><em>class</em> <code>http.cookies.BaseCookie([*input*])</code></p><p>这个类是一个字典类型的对象,键是字符串,值是 <a href="https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.Morsel" target="_blank" rel="noopener"><code>Morsel</code></a> 的实例。</p><p>如果设置参数<code>input</code>,实际上是通过<a href="https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.BaseCookie.load" target="_blank" rel="noopener"><code>load()</code></a> 方法设置。</p></li><li><p><em>class</em> <code>http.cookies.SimpleCookie([*input*])</code></p><p>这个类是从<a href="https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.BaseCookie" target="_blank" rel="noopener"><code>BaseCookie</code></a> 继承过来并重写了   <code>value_decode()</code> and <code>value_encode()</code>方法。</p><p>SimpleCookies支持字符串格式的cookie values.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p></li></ul><a id="more"></a><h3 id="Cookie对象"><a href="#Cookie对象" class="headerlink" title="Cookie对象"></a>Cookie对象</h3><ul><li><p><code>BaseCookie.value_decode(val)</code></p><p>以字符串形式返回 一个元组(real_value,coded_value)。其中<code>real_value</code>可以是任意类型。此方法在[<code>BaseCookie</code>]（<a href="https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.BaseCookie）中不进行解码,---因为已经存在被重写了。" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.BaseCookie）中不进行解码,---因为已经存在被重写了。</a></p></li><li><p><code>BaseCookie.value_encode</code>(<em>val</em>)</p><p>以字符串形式返回 一个元组(real_value,coded_value)。其中<code>val</code>可以是任意类型,<code>coded_value</code> 通常被转换为字符串类型。</p></li><li><p><code>BaseCookie.output(*attrs=None*, *header=&#39;Set-Cookie:&#39;*, *sep=&#39;\r\n&#39;*)</code></p><p>返回一个字符串表示的 用来适配 Http请求头,属性的相关方法。分隔符默认使用<code>\r\n</code>（CRLF）。</p></li><li><p><code>BaseCookie.js_output(*attrs=None*)</code></p><p>返回一个绑定Javascript脚本的对象,如果运行的浏览器支持Javascript脚本,作为输出和 out_put()的实现一样。</p></li><li><p><code>BaseCookie.load</code>(<em>rawdata</em>)`</p><p>如果参数rawdata 是字符串,转化为 HTTP_COOKIE对象,并添加值。</p><p>如果参数是字典类型,可以这样取值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> rawdata.items():     </span><br><span class="line">     cookie[k] = v</span><br></pre></td></tr></table></figure></li></ul><h3 id="Morsel-对象"><a href="#Morsel-对象" class="headerlink" title="Morsel 对象"></a>Morsel 对象</h3><p><em>class</em> <code>http.cookies.Morsel</code></p><p>部分实现了  <a href="https://tools.ietf.org/html/rfc2109.html" target="_blank" rel="noopener"><strong>RFC 2109</strong></a>  规范的键值对抽象类。</p><p>Morsels是一个字典类型的对象, 里面的键是一个常量,同<a href="https://tools.ietf.org/html/rfc2109.html" target="_blank" rel="noopener"><strong>RFC 2109</strong></a>  规范,如下面所示:</p><ul><li><code>expires</code></li><li><code>path</code></li><li><code>comment</code></li><li><code>domain</code></li><li><code>max-age</code></li><li><code>secure</code></li><li><code>version</code></li><li><code>httponly</code></li><li><code>samesite</code></li></ul><p><code>httponly</code> 属性声明了cookie只能通过HTTP 请求传输,并且包括Javascript脚本。这将会被合并到跨站脚本部分。</p><p><code>samesite</code> 声明了浏览器是否允许发送跨站请求的cookie。这将会避免CSRF 攻击。无效的值包括  “Strict” and “Lax”。</p><p>这些键是大小写敏感的.默认值是<code>&#39;&#39;</code>.</p><ul><li><p><code>Morsel.value</code></p><p>Cookie的值。</p></li><li><p><code>Morsel.coded_value</code><br>编码后的cookie值。</p></li><li><p><code>Morsel.key</code></p><p>cookie的名字</p></li><li><p><code>Morsel.set</code>(<em>key</em>, <em>value</em>, <em>coded_value</em>)</p><p>设置<code>key</code> ,<code>value</code>和 <code>coded_value* attributes</code> 属性。</p></li><li><p><code>Morsel.isReservedKey(*K*)</code></p><p>判断 键 知否是 <a href="https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.Morsel" target="_blank" rel="noopener"><code>Morsel</code></a>  里的键的成员。</p></li><li><p><code>Morsel.output(*attrs=None*, *header=&#39;Set-Cookie:&#39;*)</code></p><p>返回字符串格式的  <a href="https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.Morsel" target="_blank" rel="noopener"><code>Morsel</code></a> 。默认包括所有的属性,除非指定声明attrs 属性,<code>header</code> 参数默认值是<code>&quot;Set-Cookie:&quot;</code>.</p></li><li><p><code>Morsel.js_output(*attrs=None*)</code></p><p>返回一个绑定Javascript脚本的对象,如果运行的浏览器支持Javascript脚本,作为输出和 out_put()的实现一样。</p></li><li><p><code>Morsel.OutputString(*attrs=None*)</code></p><p>返回一个字符串格式的 Morsel,不包括Http或Javascript。</p></li><li><p><code>Morsel.update(*values*)</code></p><p>根据参数值更新Morsel 字典。如果参数不在字典中则引发异常。具体可以参考  <a href="https://tools.ietf.org/html/rfc2109.html" target="_blank" rel="noopener"><strong>RFC 2109</strong></a> </p></li><li><p><code>Morsel.copy(*value*)</code></p><p>返回一个 Morsel 对象的浅拷贝。</p></li><li><p><code>Morsel.setdefault(*key*, *value=None*)</code></p><p>Raise an error if key is not a valid <a href="https://tools.ietf.org/html/rfc2109.html" target="_blank" rel="noopener"><strong>RFC 2109</strong></a> attribute, otherwise behave the same as <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.setdefault" target="_blank" rel="noopener"><code>dict.setdefault()</code></a>.</p></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> http <span class="keyword">import</span> cookies</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = cookies.SimpleCookie()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"fig"</span>] = <span class="string">"newton"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"sugar"</span>] = <span class="string">"wafer"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C) <span class="comment"># generate HTTP headers</span></span><br><span class="line">Set-Cookie: fig=newton</span><br><span class="line">Set-Cookie: sugar=wafer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C.output()) <span class="comment"># same thing</span></span><br><span class="line">Set-Cookie: fig=newton</span><br><span class="line">Set-Cookie: sugar=wafer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = cookies.SimpleCookie()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"rocky"</span>] = <span class="string">"road"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"rocky"</span>][<span class="string">"path"</span>] = <span class="string">"/cookie"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C.output(header=<span class="string">"Cookie:"</span>))</span><br><span class="line">Cookie: rocky=road; Path=/cookie</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C.output(attrs=[], header=<span class="string">"Cookie:"</span>))</span><br><span class="line">Cookie: rocky=road</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = cookies.SimpleCookie()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.load(<span class="string">"chips=ahoy; vienna=finger"</span>) <span class="comment"># load from a string (HTTP header)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C)</span><br><span class="line">Set-Cookie: chips=ahoy</span><br><span class="line">Set-Cookie: vienna=finger</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = cookies.SimpleCookie()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.load(<span class="string">'keebler="E=everybody; L=\\"Loves\\"; fudge=\\012;";'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C)</span><br><span class="line">Set-Cookie: keebler=<span class="string">"E=everybody; L=\"Loves\"; fudge=\012;"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = cookies.SimpleCookie()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"oreo"</span>] = <span class="string">"doublestuff"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"oreo"</span>][<span class="string">"path"</span>] = <span class="string">"/"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C)</span><br><span class="line">Set-Cookie: oreo=doublestuff; Path=/</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = cookies.SimpleCookie()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"twix"</span>] = <span class="string">"none for you"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"twix"</span>].value</span><br><span class="line"><span class="string">'none for you'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = cookies.SimpleCookie()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"number"</span>] = <span class="number">7</span> <span class="comment"># equivalent to C["number"] = str(7)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"string"</span>] = <span class="string">"seven"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"number"</span>].value</span><br><span class="line"><span class="string">'7'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C[<span class="string">"string"</span>].value</span><br><span class="line"><span class="string">'seven'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(C)</span><br><span class="line">Set-Cookie: number=<span class="number">7</span></span><br><span class="line">Set-Cookie: string=seven</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>顺便了解了下http协议的相关内容,附链接。</p><p>RFC 2068 ：<a href="http://www.blogjava.net/sunchaojin/archive/2013/12/18/279164.html#407729" target="_blank" rel="noopener">http超文本传输协议1.0</a></p><p>RFC 2616 ：<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">http超文本传输协议1.1</a></p><p>RFC 2109:  <a href="http://www.stupidbeauty.com/Blog/article/1134/RFC2109%E7%BF%BB%E8%AF%91%EF%BC%9AHTTP%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%9AHTTP%20State%20Management%20Mechanism" target="_blank" rel="noopener">http状态管理机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-http-cookies&quot;&gt;&lt;a href=&quot;#python-标准库-http-cookies&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 http.cookies&quot;&gt;&lt;/a&gt;python 标准库 http.cookies&lt;/h1&gt;&lt;p&gt;最近需要教孩子自然拼读,所以我想还是每天用一个关键词描述吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;traffic  .n UK /træf.ɪk/  US /ˈtræf.ɪk/  交通(拥堵)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;There was heavy/a lot of traffic on the roads this morning.&lt;/em&gt;今天早晨道路上车流量很大。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;We got stuck in traffic for several hours.&lt;/em&gt;我们碰上交通阻塞被堵了好几个小时。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;New measures have been introduced to try and ease traffic congestion in the city.&lt;/em&gt;这个城市已经采取了新措施，试图缓解交通拥堵。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Five people were injured in a traffic accident (= one involving vehicles).&lt;/em&gt;有5人在交通事故中受伤。&lt;/p&gt;
&lt;p&gt;US &lt;em&gt;I heard about the accident on the traffic report on the radio this morning.&lt;/em&gt;我在今早电台的交通节目中听到了这起事故。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Air traffic has increased 30 percent in the last decade.&lt;/em&gt;在过去的10年里，空中交通量增加了30%。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200109_traffic.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;python-标准库学习-http-cookies&quot;&gt;&lt;a href=&quot;#python-标准库学习-http-cookies&quot; class=&quot;headerlink&quot; title=&quot;python 标准库学习   http.cookies&quot;&gt;&lt;/a&gt;python 标准库学习   http.cookies&lt;/h2&gt;&lt;p&gt;http.cookies 模块定义了类实现了http状态管理机制和cookies概念。不仅支持字符串格式化的cookie值,还支持任何序列化对象的cookie值。&lt;/p&gt;
&lt;p&gt;模块的实现完全遵循 &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; 和  &lt;a href=&quot;https://tools.ietf.org/html/rfc2068.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;RFC 2068&lt;/strong&gt;&lt;/a&gt; 协议规范。但MSIE 3.0x不遵循那些规范中概述的字符规则，并且当涉及Cookie处理时，许多当今的浏览器和服务器已经放宽了解析规则。&lt;/p&gt;
&lt;p&gt;Cookie名定义字符集中非法字符囊括在 &lt;code&gt;string.ascii_letters&lt;/code&gt;,&lt;code&gt;string.digits&lt;/code&gt; 和 &lt;code&gt;!#$%&amp;amp;&amp;#39;*+-.^_&lt;/code&gt;|~:`中。    &lt;/p&gt;
&lt;h2 id=&quot;核心类&quot;&gt;&lt;a href=&quot;#核心类&quot; class=&quot;headerlink&quot; title=&quot;核心类&quot;&gt;&lt;/a&gt;核心类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;exception&lt;/em&gt; &lt;code&gt;http.cookies.CookieError&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;违反&lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; 规范中的错误,例如:不正确的属性或不正确的Set-Cookies header&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;class&lt;/em&gt; &lt;code&gt;http.cookies.BaseCookie([*input*])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个类是一个字典类型的对象,键是字符串,值是 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.Morsel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Morsel&lt;/code&gt;&lt;/a&gt; 的实例。&lt;/p&gt;
&lt;p&gt;如果设置参数&lt;code&gt;input&lt;/code&gt;,实际上是通过&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.BaseCookie.load&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt; 方法设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;class&lt;/em&gt; &lt;code&gt;http.cookies.SimpleCookie([*input*])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个类是从&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/http.cookies.html#http.cookies.BaseCookie&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;BaseCookie&lt;/code&gt;&lt;/a&gt; 继承过来并重写了   &lt;code&gt;value_decode()&lt;/code&gt; and &lt;code&gt;value_encode()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;SimpleCookies支持字符串格式的cookie values.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="http" scheme="https://pinghailinfeng.gitee.io/tags/http/"/>
    
      <category term="cookies" scheme="https://pinghailinfeng.gitee.io/tags/cookies/"/>
    
  </entry>
  
  <entry>
    <title>python standard library http</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/08/python-standard-library-http/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/08/python-standard-library-http/</id>
    <published>2020-01-08T02:57:24.000Z</published>
    <updated>2020-01-08T03:55:07.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库之-http"><a href="#python-标准库之-http" class="headerlink" title="python 标准库之 http"></a>python 标准库之 http</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20191223_blog_2.jpg?raw=true" alt></p><p>山雨欲来风满楼,最近不是很太平,希望世界和平吧。</p><h2 id="python-标准库学习-之-http"><a href="#python-标准库学习-之-http" class="headerlink" title="python 标准库学习 之  http"></a>python 标准库学习 之  http</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/http.html#module-http" target="_blank" rel="noopener"><code>http</code></a> 是一个包，它收集了多个用于处理超文本传输协议的模块:</p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.html" target="_blank" rel="noopener">参考文档</a></p><ul><li><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#module-http.client" target="_blank" rel="noopener"><code>http.client</code></a> 是一个低层级的 HTTP 协议客户端；对于高层级的 URL 访问请使用 <a href="https://docs.python.org/zh-cn/3.8/library/urllib.request.html#module-urllib.request" target="_blank" rel="noopener"><code>urllib.request</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#module-http.server" target="_blank" rel="noopener"><code>http.server</code></a> 包含基于 <a href="https://docs.python.org/zh-cn/3.8/library/socketserver.html#module-socketserver" target="_blank" rel="noopener"><code>socketserver</code></a> 的基本 HTTP 服务类</li><li><a href="https://docs.python.org/zh-cn/3.8/library/http.cookies.html#module-http.cookies" target="_blank" rel="noopener"><code>http.cookies</code></a> 包含一些有用来实现通过 cookies 进行状态管理的工具</li><li><a href="https://docs.python.org/zh-cn/3.8/library/http.cookiejar.html#module-http.cookiejar" target="_blank" rel="noopener"><code>http.cookiejar</code></a> 提供了 cookies 的持久化</li></ul><p>本次只整理 http.client的内容,后面持续更新。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><code>class http.HTTPStatus</code></p><p>使用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> http <span class="keyword">import</span> HTTPStatus</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>HTTPStatus.OK</span><br><span class="line">&lt;HTTPStatus.OK: <span class="number">200</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>HTTPStatus.OK == <span class="number">200</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>HTTPStatus.OK.value</span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>HTTPStatus.OK.phrase</span><br><span class="line"><span class="string">'OK'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>HTTPStatus.OK.description</span><br><span class="line"><span class="string">'Request fulfilled, document follows'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(HTTPStatus)</span><br><span class="line">[&lt;HTTPStatus.CONTINUE: <span class="number">100</span>&gt;, &lt;HTTPStatus.SWITCHING_PROTOCOLS: <span class="number">101</span>&gt;, ...]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><table><thead><tr><th>状态码</th><th>映射名</th><th>详情</th></tr></thead><tbody><tr><td><code>100</code></td><td><code>CONTINUE</code></td><td>HTTP/1.1 <a href="https://tools.ietf.org/html/rfc7231.html" target="_blank" rel="noopener"><strong>RFC 7231</strong></a>, 6.2.1 节</td></tr><tr><td><code>101</code></td><td><code>SWITCHING_PROTOCOLS</code></td><td>HTTP/1.1 RFC 7231, 6.2.2 节</td></tr><tr><td><code>102</code></td><td><code>PROCESSING</code></td><td>WebDAV RFC 2518, 10.1 节</td></tr><tr><td><code>200</code></td><td><code>OK</code></td><td>HTTP/1.1 RFC 7231, 6.3.1 节</td></tr><tr><td><code>201</code></td><td><code>CREATED</code></td><td>HTTP/1.1 RFC 7231, 6.3.2 节</td></tr><tr><td><code>202</code></td><td><code>ACCEPTED</code></td><td>HTTP/1.1 RFC 7231, 6.3.3 节</td></tr><tr><td><code>203</code></td><td><code>NON_AUTHORITATIVE_INFORMATION</code></td><td>HTTP/1.1 RFC 7231, 6.3.4 节</td></tr><tr><td><code>204</code></td><td><code>NO_CONTENT</code></td><td>HTTP/1.1 RFC 7231, 6.3.5 节</td></tr><tr><td><code>205</code></td><td><code>RESET_CONTENT</code></td><td>HTTP/1.1 RFC 7231, 6.3.6 节</td></tr><tr><td><code>206</code></td><td><code>PARTIAL_CONTENT</code></td><td>HTTP/1.1 RFC 7233, 4.1 节</td></tr><tr><td><code>207</code></td><td><code>MULTI_STATUS</code></td><td>WebDAV RFC 4918, 11.1 节</td></tr><tr><td><code>208</code></td><td><code>ALREADY_REPORTED</code></td><td>WebDAV Binding Extensions RFC 5842, 7.1 节（实验性）</td></tr><tr><td><code>226</code></td><td><code>IM_USED</code></td><td>Delta Encoding in HTTP RFC 3229, 10.4.1 节</td></tr><tr><td><code>300</code></td><td><code>MULTIPLE_CHOICES</code>：有多种资源可选择</td><td>HTTP/1.1 RFC 7231, 6.4.1 节</td></tr><tr><td><code>301</code></td><td><code>MOVED_PERMANENTLY</code>：永久移动</td><td>HTTP/1.1 RFC 7231, 6.4.2 节</td></tr><tr><td><code>302</code></td><td><code>FOUND</code>：临时移动</td><td>HTTP/1.1 RFC 7231, 6.4.3 节</td></tr><tr><td><code>303</code></td><td><code>SEE_OTHER</code>：已经移动</td><td>HTTP/1.1 RFC 7231, 6.4.4 节</td></tr><tr><td><code>304</code></td><td><code>NOT_MODIFIED</code>：没有修改</td><td>HTTP/1.1 RFC 7232, 4.1 节</td></tr><tr><td><code>305</code></td><td><code>USE_PROXY</code>：使用代理</td><td>HTTP/1.1 RFC 7231, 6.4.5 节</td></tr><tr><td><code>307</code></td><td><code>TEMPORARY_REDIRECT</code>：临时重定向</td><td>HTTP/1.1 <a href="https://tools.ietf.org/html/rfc7231.html" target="_blank" rel="noopener"><strong>RFC 7231</strong></a>, 6.4.7 节</td></tr><tr><td><code>308</code></td><td><code>PERMANENT_REDIRECT</code>：永久重定向</td><td>Permanent Redirect <a href="https://tools.ietf.org/html/rfc7238.html" target="_blank" rel="noopener"><strong>RFC 7238</strong></a>, Section 3 (Experimental)</td></tr><tr><td><code>400</code></td><td><code>BAD_REQUEST</code>：错误请求</td><td>HTTP/1.1 RFC 7231, 6.5.1 节</td></tr><tr><td><code>401</code></td><td><code>UNAUTHORIZED</code>：未授权</td><td>HTTP/1.1 Authentication RFC 7235, 3.1 节</td></tr><tr><td><code>402</code></td><td><code>PAYMENT_REQUIRED</code>：保留，将来使用</td><td>HTTP/1.1 RFC 7231, 6.5.2 节</td></tr><tr><td><code>403</code></td><td><code>FORBIDDEN</code>：禁止</td><td>HTTP/1.1 RFC 7231, 6.5.3 节</td></tr><tr><td><code>404</code></td><td><code>NOT_FOUND</code>：没有找到</td><td>HTTP/1.1 RFC 7231, 6.5.4 节</td></tr><tr><td><code>405</code></td><td><code>METHOD_NOT_ALLOWED</code>：该请求方法不允许</td><td>HTTP/1.1 RFC 7231, 6.5.5 节</td></tr><tr><td><code>406</code></td><td><code>NOT_ACCEPTABLE</code>：不可接受</td><td>HTTP/1.1 RFC 7231, 6.5.6 节</td></tr><tr><td><code>407</code></td><td><code>PROXY_AUTHENTICATION_REQUIRED</code>：要求使用代理验证身份</td><td>HTTP/1.1 Authentication RFC 7235, 3.1 节</td></tr><tr><td><code>408</code></td><td><code>REQUEST_TIMEOUT</code>：请求超时</td><td>HTTP/1.1 <a href="https://tools.ietf.org/html/rfc7231.html" target="_blank" rel="noopener"><strong>RFC 7231</strong></a>, 6.5.7 节</td></tr><tr><td><code>409</code></td><td><code>CONFLICT</code>：冲突</td><td>HTTP/1.1 RFC 7231, 6.5.8 节</td></tr><tr><td><code>410</code></td><td><code>GONE</code>：已经不在了</td><td>HTTP/1.1 RFC 7231, 6.5.9 节</td></tr><tr><td><code>411</code></td><td><code>LENGTH_REQUIRED</code>：长度要求</td><td>HTTP/1.1 RFC 7231, 6.5.10 节</td></tr><tr><td><code>412</code></td><td><code>PRECONDITION_FAILED</code>：前提条件错误</td><td>HTTP/1.1 RFC 7232, 4.2 节</td></tr><tr><td><code>413</code></td><td><code>REQUEST_ENTITY_TOO_LARGE</code>：请求体太大了</td><td>HTTP/1.1 RFC 7231, 6.5.11 节</td></tr><tr><td><code>414</code></td><td><code>REQUEST_URI_TOO_LONG</code>：请求URI太长了</td><td>HTTP/1.1 RFC 7231, 6.5.12 节</td></tr><tr><td><code>415</code></td><td><code>UNSUPPORTED_MEDIA_TYPE</code>：不支持的媒体格式</td><td>HTTP/1.1 RFC 7231, 6.5.13 节</td></tr><tr><td><code>416</code></td><td><code>REQUESTED_RANGE_NOT_SATISFIABLE</code></td><td>HTTP/1.1 Range Requests RFC 7233, 4.4 节</td></tr><tr><td><code>417</code></td><td><code>EXPECTATION_FAILED</code>：期望失败</td><td>HTTP/1.1 RFC 7231, 6.5.14 节</td></tr><tr><td><code>421</code></td><td><code>MISDIRECTED_REQUEST</code></td><td>HTTP/2 <a href="https://tools.ietf.org/html/rfc7540.html" target="_blank" rel="noopener"><strong>RFC 7540</strong></a>, 9.1.2 节</td></tr><tr><td><code>422</code></td><td><code>UNPROCESSABLE_ENTITY</code>：可加工实体</td><td>WebDAV RFC 4918, 11.2 节</td></tr><tr><td><code>423</code></td><td><code>LOCKED</code>：锁着</td><td>WebDAV RFC 4918, 11.3 节</td></tr><tr><td><code>424</code></td><td><code>FAILED_DEPENDENCY</code>：失败的依赖</td><td>WebDAV RFC 4918, 11.4 节</td></tr><tr><td><code>426</code></td><td><code>UPGRADE_REQUIRED</code>：升级需要</td><td>HTTP/1.1 RFC 7231, 6.5.15 节</td></tr><tr><td><code>428</code></td><td><code>PRECONDITION_REQUIRED</code>：先决条件要求</td><td>Additional HTTP Status Codes RFC 6585</td></tr><tr><td><code>429</code></td><td><code>TOO_MANY_REQUESTS</code>：太多的请求</td><td>Additional HTTP Status Codes RFC 6585</td></tr><tr><td><code>431</code></td><td><code>REQUEST_HEADER_FIELDS_TOO_LARGE</code>：请求头太大</td><td>Additional HTTP Status Codes RFC 6585</td></tr><tr><td><code>451</code></td><td><code>UNAVAILABLE_FOR_LEGAL_REASONS</code></td><td>HTTP 状态码用于报告法律障碍 <a href="https://tools.ietf.org/html/rfc7725.html" target="_blank" rel="noopener"><strong>RFC 7725</strong></a></td></tr><tr><td><code>500</code></td><td><code>INTERNAL_SERVER_ERROR</code>：内部服务错误</td><td>HTTP/1.1 RFC 7231, 6.6.1 节</td></tr><tr><td><code>501</code></td><td><code>NOT_IMPLEMENTED</code>：不可执行</td><td>HTTP/1.1 RFC 7231, 6.6.2 节</td></tr><tr><td><code>502</code></td><td><code>BAD_GATEWAY</code>：无效网关</td><td>HTTP/1.1 RFC 7231, 6.6.3 节</td></tr><tr><td><code>503</code></td><td><code>SERVICE_UNAVAILABLE</code>：服务不可用</td><td>HTTP/1.1 RFC 7231, 6.6.4 节</td></tr><tr><td><code>504</code></td><td><code>GATEWAY_TIMEOUT</code>：网关超时</td><td>HTTP/1.1 RFC 7231, 6.6.5 节</td></tr><tr><td><code>505</code></td><td><code>HTTP_VERSION_NOT_SUPPORTED</code>：HTTP版本不支持</td><td>HTTP/1.1 RFC 7231, 6.6.6 节</td></tr><tr><td><code>506</code></td><td><code>VARIANT_ALSO_NEGOTIATES</code>：服务器存在内部配置错误</td><td>透明内容协商在： HTTP <a href="https://tools.ietf.org/html/rfc2295.html" target="_blank" rel="noopener"><strong>RFC 2295</strong></a>, 8.1 节（实验性）</td></tr><tr><td><code>507</code></td><td><code>INSUFFICIENT_STORAGE</code>：存储不足</td><td>WebDAV RFC 4918, 11.5 节</td></tr><tr><td><code>508</code></td><td><code>LOOP_DETECTED</code>：循环检测</td><td>WebDAV Binding Extensions RFC 5842, 7.2 节（实验性）</td></tr><tr><td><code>510</code></td><td><code>NOT_EXTENDED</code>：不扩展</td><td>WebDAV Binding Extensions RFC 5842, 7.2 节（实验性）</td></tr><tr><td><code>511</code></td><td><code>NETWORK_AUTHENTICATION_REQUIRED</code>：要求网络身份验证</td><td>Additional HTTP Status Codes <a href="https://tools.ietf.org/html/rfc6585.html" target="_blank" rel="noopener"><strong>RFC 6585</strong></a>, 6 节</td></tr></tbody></table><p>为了保持向后兼容性，枚举值也以常量形式出现在 <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#module-http.client" target="_blank" rel="noopener"><code>http.client</code></a> 模块中，。 枚举名等于常量名 (例如 <code>http.HTTPStatus.OK</code> 也可以是 <code>http.client.OK</code>)。</p><h2 id="http-client-对象"><a href="#http-client-对象" class="headerlink" title="http.client 对象"></a>http.client 对象</h2><p>这个模块定义了实现 HTTP 和 HTTPS 协议客户端的类。 它通常不直接使用 — 模块 <a href="https://docs.python.org/zh-cn/3.8/library/urllib.request.html#module-urllib.request" target="_blank" rel="noopener"><code>urllib.request</code></a> 用它来处理使用 HTTP 和 HTTPS 的 URL。</p><p>参见 The <a href="https://requests.readthedocs.io/en/master/" target="_blank" rel="noopener">Requests</a> 是一个高级的实现http协议的http客户端接口库.</p><p><strong>注意</strong>: HTTPS 支持仅在编译 Python 时启用了 SSL 支持的情况下（通过 <a href="https://docs.python.org/zh-cn/3.8/library/ssl.html#module-ssl" target="_blank" rel="noopener"><code>ssl</code></a> 模块）可用。</p><p>强烈建议看源代码 <a href="https://github.com/python/cpython/tree/3.8/Lib/http/client.py" target="_blank" rel="noopener">Lib/http/client.py</a></p><p>我摘取其中关于http请求状态的描述</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> (null)</span><br><span class="line">   |</span><br><span class="line">   | HTTPConnection()</span><br><span class="line">   v</span><br><span class="line"> Idle</span><br><span class="line">   |</span><br><span class="line">   | putrequest()</span><br><span class="line">   v</span><br><span class="line"> Request-started</span><br><span class="line">   |</span><br><span class="line">   | ( putheader() )*  endheaders()</span><br><span class="line">   v</span><br><span class="line"> Request-sent</span><br><span class="line">   |\_____________________________</span><br><span class="line">   |                              | getresponse() raises</span><br><span class="line">   | response = getresponse()     | ConnectionError</span><br><span class="line">   v                              v</span><br><span class="line"> Unread-response                Idle</span><br><span class="line"> [Response-headers-read]</span><br><span class="line">   |\____________________</span><br><span class="line">   |                     |</span><br><span class="line">   | response.read()     | putrequest()</span><br><span class="line">   v                     v</span><br><span class="line"> Idle                  Req-started-unread-response</span><br><span class="line">                  ______/|</span><br><span class="line">                /        |</span><br><span class="line">response.read() |        | ( putheader() )*  endheaders()</span><br><span class="line">                v        v</span><br><span class="line">    Request-started    Req-sent-unread-response</span><br><span class="line">                         |</span><br><span class="line">                         | response.read()</span><br><span class="line">                         v</span><br><span class="line">                       Request-sent</span><br></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li><code>class http.client.HTTPConnection(*host*, *port=None*, [*timeout*, ]*source_address=None*, *blocksize=8192*)</code></li></ul><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPConnection" target="_blank" rel="noopener"><code>HTTPConnection</code></a> 的实例代表与 HTTP 的一个连接事务。 它的实例化应当传入一个主机和可选的端口号。 如果没有传入端口号，如果主机字符串的形式为 <code>主机:端口</code> 则会从中提取端口，否则将使用默认的 HTTP 端口（80）。 如果给出了可选的 <em>timeout</em> 参数，则阻塞操作（例如连接尝试）将在指定的秒数之后超时（如果未给出，则使用全局默认超时设置）。 可选的 <em>source_address</em> 参数可以为一个 (主机, 端口) 元组，用作进行 HTTP 连接的源地址。 可选的 <em>blocksize</em> 参数可以字节为单位设置缓冲区的大小，用来发送文件类消息体。</p><p>举个例子，以下调用都是创建连接到同一主机和端口的服务器的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h1 = http.client.HTTPConnection(<span class="string">'www.python.org'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h2 = http.client.HTTPConnection(<span class="string">'www.python.org:80'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h3 = http.client.HTTPConnection(<span class="string">'www.python.org'</span>, <span class="number">80</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h4 = http.client.HTTPConnection(<span class="string">'www.python.org'</span>, <span class="number">80</span>, timeout=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li><p>`<em>class</em> http.client.HTTPSConnection(<em>host</em>, <em>port=None</em>, <em>key_file=None</em>, <em>cert_file=None</em>, [<em>timeout</em>, ]<em>source_address=None</em>, <em>**, </em>context=None<em>, </em>check_hostname=None<em>, </em>blocksize=8192*)<a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPSConnection" target="_blank" rel="noopener">¶</a></p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPConnection" target="_blank" rel="noopener"><code>HTTPConnection</code></a> 的子类，使用 SSL 与安全服务器进行通信。 默认端口为 <code>443</code>。 如果指定了 <em>context</em>，它必须为一个描述 SSL 各选项的 <a href="https://docs.python.org/zh-cn/3.8/library/ssl.html#ssl.SSLContext" target="_blank" rel="noopener"><code>ssl.SSLContext</code></a> 实例。</p></li><li><p><code>class http.client.`</code>HTTPResponse`(<em>sock</em>, <em>debuglevel=0</em>, <em>method=None</em>, <em>url=None</em>)</p></li></ul><p>在成功连接后返回类的实例，而不是由用户直接实例化。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li><p><em>exception</em> <code>http.client.`</code>HTTPException`</p><p>此模块中其他异常的基类。 它是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>http.client.`</code>NotConnected`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>http.client.`</code>InvalidURL`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类，如果给出了一个非数字或为空值的端口就会被引发。</p></li><li><p><em>exception</em> <code>http.client.`</code>UnknownProtocol`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>http.client.`</code>UnknownTransferEncoding`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>http.client.`</code>UnimplementedFileMode`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>http.client.`</code>IncompleteRead`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>http.client.`</code>ImproperConnectionState`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>http.client.`</code>CannotSendRequest`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.ImproperConnectionState" target="_blank" rel="noopener"><code>ImproperConnectionState</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>http.client.`</code>CannotSendHeader`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.ImproperConnectionState" target="_blank" rel="noopener"><code>ImproperConnectionState</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>http.client.`</code>ResponseNotReady`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.ImproperConnectionState" target="_blank" rel="noopener"><code>ImproperConnectionState</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>http.client.`</code>BadStatusLine`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。 如果服务器反馈了一个我们不理解的 HTTP 状态码就会被引发。</p></li><li><p><em>exception</em> <code>http.client.`</code>LineTooLong`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPException" target="_blank" rel="noopener"><code>HTTPException</code></a> 的一个子类。 如果在 HTTP 协议中从服务器接收到过长的行就会被引发。</p></li><li><p><em>exception</em> <code>http.client.`</code>RemoteDisconnected`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionResetError" target="_blank" rel="noopener"><code>ConnectionResetError</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.BadStatusLine" target="_blank" rel="noopener"><code>BadStatusLine</code></a> 的一个子类。 当尝试读取响应时的结果是未从连接读取到数据时由 <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPConnection.getresponse" target="_blank" rel="noopener"><code>HTTPConnection.getresponse()</code></a> 引发，表明远端已关闭连接。</p></li></ul><h3 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h3><ul><li><p><code>http.client.`</code>HTTP_PORT`</p><p>HTTP 协议默认的端口号 (总是 <code>80</code>)。</p></li><li><p><code>http.client.`</code>HTTPS_PORT`</p><p>HTTPS 协议默认的端口号 (总是 <code>443</code>)。</p></li><li><p><code>http.client.`</code>responses`</p><p>这个字典把 HTTP 1.1 状态码映射到 W3C 名称。例如：<code>http.client.responses[http.client.NOT_FOUND]</code> 是 <code>&#39;NOT FOUND</code> （未发现）。</p></li></ul><h2 id="HTTPConnection-对象"><a href="#HTTPConnection-对象" class="headerlink" title="HTTPConnection 对象"></a>HTTPConnection 对象</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><code>HTTPConnection.request</code>(<em>method</em>, <em>url</em>, <em>body=None</em>, <em>headers={}</em>, <em>, </em>encode_chunked=False*)</li></ul><p>这会使用 HTTP 请求方法 <em>method</em> 和选择器 <em>url</em> 向服务器发送请求。</p><p>如果给定 <em>body</em>，那么给定的数据会在信息头完成之后发送。它可能是一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 、一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 、一个打开的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a>，或者 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 迭代器。如果 <em>body</em> 是字符串，它会按 HTTP 默认的 ISO-8859-1 编码；如果是一个字节类对象，它会按原样发送；如果是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> ，文件的内容会被发送，这个文件对象应该支持 <code>read()</code> 方法。如果这个文件对象是一个 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.TextIOBase" target="_blank" rel="noopener"><code>io.TextIOBase</code></a> 实例， <code>read()</code> 方法返回的数据会按 ISO-8859-1 编码，否则 <code>read()</code> 方法返回的数据会按原样发送；如果 <em>body</em> 是一个迭代器，迭代器中的元素会被发送，直到迭代器耗尽。</p><p><em>headers</em> 参数应是额外的随请求发送的 HTTP 信息头的字典。</p><p>如果 <em>headers</em> 既不包含 Content-Length 也没有 Transfer-Encoding，但存在请求正文，那么这些头字段中的一个会自动设定。如果 <em>body</em> 是 <code>None</code>，那么对于要求正文的方法 (<code>PUT</code>，<code>POST</code>，和 <code>PATCH</code>)，Content-Length 头会被设为 <code>0</code>。如果 <em>body</em> 是字符串或者类似字节的对象，并且也不是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">文件</a>，Content-Length 头会设为正文的长度。任何其他类型的 <em>body</em> （一般是文件或迭代器）会按块编码，这时会自动设定 Transfer-Encoding 头以代替 Content-Length。</p><p>在 <em>headers</em> 中指定 Transfer-Encoding 时， <em>encode_chunked</em> 是唯一相关的参数。如果 <em>encode_chunked</em> 为 <code>False</code>，HTTPConnection 对象会假定所有的编码都由调用代码处理。如果为 <code>True</code>，正文会按块编码。</p><ul><li><p><code>HTTPConnection.`</code>set_debuglevel`(<em>level</em>)</p><p>设置调试等级。 默认的调试等级为 <code>0</code>，意味着不会打印调试输出。 任何大于 <code>0</code> 的值将使得所有当前定义的调试输出被打印到 stdout。 <code>debuglevel</code> 会被传给任何新创建的 <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPResponse" target="_blank" rel="noopener"><code>HTTPResponse</code></a> 对象。</p></li><li><p><code>HTTPConnection.`</code>set_tunnel`(<em>host</em>, <em>port=None</em>, <em>headers=None</em>)</p><p>为 HTTP 连接隧道设置主机和端口。 这将允许通过代理服务器运行连接。</p><p>host 和 port 参数指明隧道连接的位置（即 CONNECT 请求所包含的地址，而 <em>不是</em> 代理服务器的地址）。</p><p>headers 参数应为一个随 CONNECT 请求发送的额外 HTTP 标头的映射。</p><p>例如，要通过一个运行于本机 8080 端口的 HTTPS 代理服务器隧道，我们应当向 <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPSConnection" target="_blank" rel="noopener"><code>HTTPSConnection</code></a> 构造器传入代理的地址，并将我们最终想要访问的主机地址传给 <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPConnection.set_tunnel" target="_blank" rel="noopener"><code>set_tunnel()</code></a> 方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> http.client</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = http.client.HTTPSConnection(<span class="string">"localhost"</span>, <span class="number">8080</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.set_tunnel(<span class="string">"www.python.org"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.request(<span class="string">"HEAD"</span>,<span class="string">"/index.html"</span>)</span><br></pre></td></tr></table></figure></li><li><p>HTTPConnection.connect()</p><p>当对象被创建后连接到指定的服务器。 默认情况下，如果客户端还未建立连接，此函数会在发送请求时自动被调用。</p></li><li><p><code>HTTPConnection.close()</code></p><p>关闭到服务器的连接。</p></li><li><p><code>HTTPConnection.blocksize</code></p><p>用于发送文件类消息体的缓冲区大小。</p></li><li><p><code>HTTPConnection.send(data)</code></p><p>发送数据到服务器 。这个方法直接使用将会在<a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPConnection.endheaders" target="_blank" rel="noopener">endheaders()</a>方法后和   <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPConnection.getresponse" target="_blank" rel="noopener"><code>getresponse()</code></a> 方法调用之前被调用</p></li></ul><h2 id="HTTPResponse-对象"><a href="#HTTPResponse-对象" class="headerlink" title="HTTPResponse 对象"></a>HTTPResponse 对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPResponse" target="_blank" rel="noopener"><code>HTTPResponse</code></a> 对象实例绑定从服务器返回的 Http response 内容。 response是一个可迭代对象,可以使用with上下文语句来管理。</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul><li><p><code>HTTPResponse.read</code>([<em>amt</em>])</p><p>读取并返回response body</p></li><li><p><code>HTTPResponse.`</code>readinto`(<em>b</em>)</p><p>读取从 response body 的b长度的字节放到 buffer b中，并返回这个字节b。</p></li><li><p><code>HTTPResponse.getheader</code>(<em>name</em>, <em>default=None</em>)</p><p>如果有匹配的header name,则返回 header name的值。如果不止一个header name的名字，则返回所有的值的字符串,通过逗号连接。</p></li><li><p><code>HTTPResponse.getheaders()</code></p><p>返回一个包含header和value的元组元素的列表</p></li><li><p><code>HTTPResponse.fileno()</code></p><p>Return the <code>fileno</code> of the underlying socket.</p><p>返回底层套接字的fileno</p></li><li><p><code>HTTPResponse.msg</code></p><p>一个<code>http.client.HTTPMessage</code> 消息的实例,包含response header。 <code>http.client.HTTPMessage</code> 是 <a href="https://docs.python.org/zh-cn/3.8/library/email.compat32-message.html#email.message.Message" target="_blank" rel="noopener"><code>email.message.Message</code></a>的子类</p></li><li><p><code>HTTPResponse.version</code></p><p>Http response版本号,例如  HTTP/1.0, 11 for HTTP/1.1.</p></li><li><p><code>HTTPResponse.`</code>status`</p><p>由服务器返回的状态码。</p></li><li><p><code>HTTPResponse.reason</code></p><p>从服务器返回的状态码</p></li><li><p><code>HTTPResponse.debuglevel</code></p><p>一个 debugging hook. 如果 <a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.HTTPResponse.debuglevel" target="_blank" rel="noopener"><code>debuglevel</code></a> 大于0, 消息将会被打印到控制台。</p></li><li><p><code>HTTPResponse.closed</code></p><p>如果stream关闭,返回true</p></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h3><p>一个使用get请求的实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> http.client</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = http.client.HTTPSConnection(<span class="string">"www.python.org"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.request(<span class="string">"GET"</span>, <span class="string">"/"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r1 = conn.getresponse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(r1.status, r1.reason)</span><br><span class="line"><span class="number">200</span> OK</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data1 = r1.read()  <span class="comment"># This will return entire content.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># The following example demonstrates reading data in chunks.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.request(<span class="string">"GET"</span>, <span class="string">"/"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r1 = conn.getresponse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> chunk := r1.read(<span class="number">200</span>):</span><br><span class="line"><span class="meta">... </span>    print(repr(chunk))</span><br><span class="line"><span class="string">b'&lt;!doctype html&gt;\n&lt;!--[if"...</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; # Example of an invalid request</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; conn = http.client.HTTPSConnection("docs.python.org")</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; conn.request("GET", "/parrot.spam")</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; r2 = conn.getresponse()</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(r2.status, r2.reason)</span></span><br><span class="line"><span class="string">404 Not Found</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; data2 = r2.read()</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; conn.close()</span></span><br></pre></td></tr></table></figure><p>一个使用<code>head</code>方法的实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> http.client</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = http.client.HTTPSConnection(<span class="string">"www.python.org"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.request(<span class="string">"HEAD"</span>, <span class="string">"/"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = conn.getresponse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(res.status, res.reason)</span><br><span class="line"><span class="number">200</span> OK</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = res.read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(len(data))</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data == <span class="string">b''</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>一个使用<code>post</code>提交请求的实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> http.client, urllib.parse</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>params = urllib.parse.urlencode(&#123;<span class="string">'@number'</span>: <span class="number">12524</span>, <span class="string">'@type'</span>: <span class="string">'issue'</span>, <span class="string">'@action'</span>: <span class="string">'show'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>headers = &#123;<span class="string">"Content-type"</span>: <span class="string">"application/x-www-form-urlencoded"</span>,</span><br><span class="line"><span class="meta">... </span>           <span class="string">"Accept"</span>: <span class="string">"text/plain"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = http.client.HTTPConnection(<span class="string">"bugs.python.org"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.request(<span class="string">"POST"</span>, <span class="string">""</span>, params, headers)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = conn.getresponse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.status, response.reason)</span><br><span class="line"><span class="number">302</span> Found</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = response.read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data</span><br><span class="line"><span class="string">b'Redirecting to &lt;a href="http://bugs.python.org/issue12524"&gt;http://bugs.python.org/issue12524&lt;/a&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.close()</span><br></pre></td></tr></table></figure><p>一个使用<code>HTTP PUT</code>请求的实例 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># This creates an HTTP message</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># with the content of BODY as the enclosed representation</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># for the resource http://localhost:8080/file</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> http.client</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>BODY = <span class="string">"***filecontents***"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn = http.client.HTTPConnection(<span class="string">"localhost"</span>, <span class="number">8080</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.request(<span class="string">"PUT"</span>, <span class="string">"/file"</span>, BODY)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = conn.getresponse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(response.status, response.reason)</span><br><span class="line"><span class="number">200</span>, OK</span><br></pre></td></tr></table></figure><h2 id="HTTPMessage-对象"><a href="#HTTPMessage-对象" class="headerlink" title="HTTPMessage 对象"></a>HTTPMessage 对象</h2><p>一个 <code>http.client.HTTPMessage</code>的实例包含了http response 请求头. 是 <a href="https://docs.python.org/zh-cn/3.8/library/email.compat32-message.html#email.message.Message" target="_blank" rel="noopener"><code>email.message.Message</code></a>类的具体实现.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过阅读源码加深了对http协议的理解,看python实现的方式受益良多。继续加油!</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库之-http&quot;&gt;&lt;a href=&quot;#python-标准库之-http&quot; class=&quot;headerlink&quot; title=&quot;python 标准库之 http&quot;&gt;&lt;/a&gt;python 标准库之 http&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20191223_blog_2.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;山雨欲来风满楼,最近不是很太平,希望世界和平吧。&lt;/p&gt;
&lt;h2 id=&quot;python-标准库学习-之-http&quot;&gt;&lt;a href=&quot;#python-标准库学习-之-http&quot; class=&quot;headerlink&quot; title=&quot;python 标准库学习 之  http&quot;&gt;&lt;/a&gt;python 标准库学习 之  http&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/http.html#module-http&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;http&lt;/code&gt;&lt;/a&gt; 是一个包，它收集了多个用于处理超文本传输协议的模块:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/http.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文档&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/http.client.html#module-http.client&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;http.client&lt;/code&gt;&lt;/a&gt; 是一个低层级的 HTTP 协议客户端；对于高层级的 URL 访问请使用 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/urllib.request.html#module-urllib.request&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;urllib.request&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/http.server.html#module-http.server&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;http.server&lt;/code&gt;&lt;/a&gt; 包含基于 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/socketserver.html#module-socketserver&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;socketserver&lt;/code&gt;&lt;/a&gt; 的基本 HTTP 服务类&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/http.cookies.html#module-http.cookies&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;http.cookies&lt;/code&gt;&lt;/a&gt; 包含一些有用来实现通过 cookies 进行状态管理的工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/http.cookiejar.html#module-http.cookiejar&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;http.cookiejar&lt;/code&gt;&lt;/a&gt; 提供了 cookies 的持久化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次只整理 http.client的内容,后面持续更新。&lt;/p&gt;
&lt;h2 id=&quot;常量&quot;&gt;&lt;a href=&quot;#常量&quot; class=&quot;headerlink&quot; title=&quot;常量&quot;&gt;&lt;/a&gt;常量&lt;/h2&gt;&lt;p&gt;&lt;code&gt;class http.HTTPStatus&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; http &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; HTTPStatus&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;HTTPStatus.OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;HTTPStatus.OK: &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;HTTPStatus.OK == &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;HTTPStatus.OK.value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;HTTPStatus.OK.phrase&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;OK&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;HTTPStatus.OK.description&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;Request fulfilled, document follows&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;list(HTTPStatus)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;lt;HTTPStatus.CONTINUE: &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&amp;gt;, &amp;lt;HTTPStatus.SWITCHING_PROTOCOLS: &lt;span class=&quot;number&quot;&gt;101&lt;/span&gt;&amp;gt;, ...]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="http" scheme="https://pinghailinfeng.gitee.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>python standard library glob</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/07/python-standard-library-glob/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/07/python-standard-library-glob/</id>
    <published>2020-01-07T01:37:46.000Z</published>
    <updated>2020-01-07T03:23:55.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库之-glob"><a href="#python-标准库之-glob" class="headerlink" title="python 标准库之 glob"></a>python 标准库之 glob</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200107_cold.jpg?raw=true" alt></p><p>在严寒的冬季,温暖人的只有笑脸了吧。</p><h2 id="今天继续给大家介绍python标准库-glob"><a href="#今天继续给大家介绍python标准库-glob" class="headerlink" title="今天继续给大家介绍python标准库 glob"></a>今天继续给大家介绍python标准库 glob</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/glob.html" target="_blank" rel="noopener">参考文档</a></p><p><a href="https://docs.python.org/zh-cn/3.8/library/glob.html#module-glob" target="_blank" rel="noopener"><code>glob</code></a> 模块可根据 Unix 终端所用规则找出所有匹配特定模式的路径名，但会按不确定的顺序返回结果。支持查找文件只用到三个匹配符：’*’, “?”, “[ ]”，不包括波浪线~,因为这个符号在linux代表当前用户的home目录。</p><p>对于波浪号和终端变量扩展，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.expanduser" target="_blank" rel="noopener"><code>os.path.expanduser()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.expandvars" target="_blank" rel="noopener"><code>os.path.expandvars()</code></a>)。</p><p>根据阅读代码发现,这个底层使用cpython实现, 有兴趣的童鞋可以移步到源代码: <a href="https://github.com/python/cpython/tree/3.8/Lib/glob.py" target="_blank" rel="noopener">Lib/glob.py</a></p><p>相对于高级面向对象路径查找模块<a href="https://docs.python.org/zh-cn/3.8/library/pathlib.html#module-pathlib" target="_blank" rel="noopener">pathlib</a>  ,glob更偏向底层实现。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p><code>glob.glob(pathname, *, recursive=False)</code></p><blockquote><p>返回匹配 <em>pathname</em> 的可能为空的路径名列表，其中的元素必须为包含一个路径信息的字符串。 <em>pathname</em> 可以是绝对路径 (如 <code>/usr/src/Python-1.5/Makefile</code>) 或相对路径 (如 <code>../../Tools/*/*.gif</code>)，并且可包含 shell 风格的通配符。 结果也将包含无效的符号链接 (与在 shell 中一致)。 结果是否排序取决于具体文件系统。</p><p>如果 <em>recursive</em> 为真值，则模式 “<code>**</code>“ 将匹配目录中的任何文件以及零个或多个目录、子目录和符号链接。 如果模式加了一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sep" target="_blank" rel="noopener"><code>os.sep</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.altsep" target="_blank" rel="noopener"><code>os.altsep</code></a> 则将不匹配文件。</p></blockquote><p><strong>备注</strong>：在一个较大的目录树中使用 “<code>**</code>“ 模式可能会消耗非常多的时间。 <em>3.5 版更改:</em> 支持使用 “<code>**</code>“ 的递归 glob</p></li><li><p><code>glob.iglob(pathname, *, recursive=False)</code></p><blockquote><p>返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a>，它会产生与 <a href="https://docs.python.org/zh-cn/3.8/library/glob.html#module-glob" target="_blank" rel="noopener"><code>glob()</code></a> 相同的结果，但不会实际地同时保存它们。</p></blockquote></li><li><p><code>glob.escape(pathname)</code></p><blockquote><p>转义所有特殊字符 (<code>&#39;?&#39;</code>, <code>&#39;*&#39;</code> 和 <code>&#39;[&#39;</code>)。 这适用于当你想要匹配可能带有特殊字符的任意字符串字面值的情况。 在 drive/UNC 共享点中的特殊字符不会被转义，例如在 Windows 上 <code>escape(&#39;//?/c:/Quo vadis?.txt&#39;)</code> 将返回 <code>&#39;//?/c:/Quo vadis[?].txt&#39;</code>。</p></blockquote></li></ul><a id="more"></a><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例如，考虑一个包含以下内容的目录：文件 1.gif, 2.txt, card.gif 以及一个子目录 sub 其中只包含一个文件 3.txt. glob() 将产生如下结果。 请注意路径的任何开头部分都将被保留。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'./[0-9].*'</span>)</span><br><span class="line">[<span class="string">'./1.gif'</span>, <span class="string">'./2.txt'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'*.gif'</span>)</span><br><span class="line">[<span class="string">'1.gif'</span>, <span class="string">'card.gif'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'?.gif'</span>)</span><br><span class="line">[<span class="string">'1.gif'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'**/*.txt'</span>, recursive=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">'2.txt'</span>, <span class="string">'sub/3.txt'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'./**/'</span>, recursive=<span class="literal">True</span>)</span><br><span class="line">[<span class="string">'./'</span>, <span class="string">'./sub/'</span>]</span><br></pre></td></tr></table></figure><p>如果目录包含以 <code>.</code> 打头的文件，它们默认将不会被匹配。 例如，考虑一个包含 <code>card.gif</code> 和 <code>.card.gif</code> 的目录:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'*.gif'</span>)</span><br><span class="line">[<span class="string">'card.gif'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'.c*'</span>)</span><br><span class="line">[<span class="string">'.card.gif'</span>]</span><br></pre></td></tr></table></figure><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><blockquote><p> ”*”匹配任意0个或多个字符；”?”匹配任意单个字符；”[ ]”匹配指定范围内的字符，如：[0-9]匹配数字。</p></blockquote><p>如下图所示的文件结构</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200107_snapshot.PNG?raw=true" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="comment"># 返回上一级所有目录</span></span><br><span class="line">print(glob.glob(<span class="string">r"../*"</span>))</span><br><span class="line"><span class="comment"># 返回上本级所有目录</span></span><br><span class="line">print(glob.glob(<span class="string">r"./*"</span>))</span><br><span class="line"><span class="comment"># 本级所有文件</span></span><br><span class="line">print(glob.glob(<span class="string">r"./*.*"</span>))</span><br><span class="line"><span class="comment"># 本级所有.py文件</span></span><br><span class="line">print(glob.glob(<span class="string">'./*.py'</span>))</span><br><span class="line"><span class="comment">#两级目录所有的.py文件</span></span><br><span class="line">print(glob.glob(<span class="string">'./*/*.py'</span>))</span><br><span class="line"><span class="comment"># c盘所有文件</span></span><br><span class="line">print(glob.glob(<span class="string">r'c:/*'</span>))</span><br><span class="line"><span class="comment">#C盘所有包含pr/po/br/bo的目录</span></span><br><span class="line">print(glob.glob(<span class="string">'C:/*[PB][RO]*'</span>))</span><br><span class="line"><span class="comment">#C盘所有包含P_o的目录</span></span><br><span class="line">print(glob.glob(<span class="string">'C:/*P?O*'</span>))</span><br><span class="line"><span class="comment">#C盘两级目录所有的.txt文件</span></span><br><span class="line">print(glob.glob(<span class="string">'C:/*/*.txt'</span>))</span><br></pre></td></tr></table></figure><p>显示内容如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">['..\\class_demo.py', '..\\excel', '..\\flask_test', '..\\glob', '..\\image', '..\\mymodule', '..\\numpy', '..\\opencv', '..\\opencv_demo', '..\\othermodule', '..\\ppt', '..\\python_enuerate.py', '..\\python速成', '..\\selenium_test', '..\\交换算法.py', '..\\爬虫']</span><br><span class="line">['.\\app', '.\\config', '.\\data', '.\\glob_demo.py', '.\\other.py', '.\\readme.md']</span><br><span class="line">['.\\glob_demo.py', '.\\other.py', '.\\readme.md']</span><br><span class="line">['.\\glob_demo.py', '.\\other.py']</span><br><span class="line">['.\\app\\__init__.py', '.\\config\\config.py']</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>阅读源码中发现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""Filename globbing utility."""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> fnmatch</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">"glob"</span>, <span class="string">"iglob"</span>, <span class="string">"escape"</span>]</span><br></pre></td></tr></table></figure><p>顺便把<code>__all__</code>用法整理下,算是查漏补缺,</p><h2 id="all"><a href="#all" class="headerlink" title="__all__"></a><code>__all__</code></h2><p>问题描述:</p><blockquote><p>在研读pythonmodel源码时,会看到一些<em>.py文件或者<strong>init</strong>.py中会使用<strong>all</strong>。对于<strong>all</strong>具体所其的作用是什么?在此对查取结果进行总结下。2.总结(1)在<strong>init</strong>.py文件中表示形式:<strong>all</strong>=[“module_a”,”module_b”]在使用frompackage_nameimport</em>时,表示import该package中的两个module及两个module相关的类、方</p></blockquote><p>表示形式: <code>__all__=[&quot;class_name&quot;,&quot;function_name&quot;]</code></p><p>在使用 from module_name import * 时,表示import 该module中的<strong>all</strong>中所列出的。</p><p>使用注意事项:</p><p>(1) 在普通的*.py中, 使用<strong>all</strong> 时,可以使用<strong>all</strong>列出的 类、函数、变量等,不使用<strong>all</strong>时会使用module中的所有不以下划线开头的成员。</p><p>(2)<strong>all</strong>只能影响到 from import * 这种import 方式, 对于from import 的 import 方式没有影响。</p><p>(3) <strong>all</strong> 的数据类型:List or Tuple </p><h2 id="关联的模块"><a href="#关联的模块" class="headerlink" title="关联的模块"></a>关联的模块</h2><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/fnmatch.html#module-fnmatch" target="_blank" rel="noopener"><code>fnmatch</code></a></p><p>Shell 风格文件名（而非路径）扩展</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库之-glob&quot;&gt;&lt;a href=&quot;#python-标准库之-glob&quot; class=&quot;headerlink&quot; title=&quot;python 标准库之 glob&quot;&gt;&lt;/a&gt;python 标准库之 glob&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200107_cold.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;在严寒的冬季,温暖人的只有笑脸了吧。&lt;/p&gt;
&lt;h2 id=&quot;今天继续给大家介绍python标准库-glob&quot;&gt;&lt;a href=&quot;#今天继续给大家介绍python标准库-glob&quot; class=&quot;headerlink&quot; title=&quot;今天继续给大家介绍python标准库 glob&quot;&gt;&lt;/a&gt;今天继续给大家介绍python标准库 glob&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/glob.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/glob.html#module-glob&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt; 模块可根据 Unix 终端所用规则找出所有匹配特定模式的路径名，但会按不确定的顺序返回结果。支持查找文件只用到三个匹配符：’*’, “?”, “[ ]”，不包括波浪线~,因为这个符号在linux代表当前用户的home目录。&lt;/p&gt;
&lt;p&gt;对于波浪号和终端变量扩展，请使用 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.expanduser&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;os.path.expanduser()&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.expandvars&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;os.path.expandvars()&lt;/code&gt;&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;根据阅读代码发现,这个底层使用cpython实现, 有兴趣的童鞋可以移步到源代码: &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/glob.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lib/glob.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相对于高级面向对象路径查找模块&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/pathlib.html#module-pathlib&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pathlib&lt;/a&gt;  ,glob更偏向底层实现。&lt;/p&gt;
&lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;glob.glob(pathname, *, recursive=False)&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;返回匹配 &lt;em&gt;pathname&lt;/em&gt; 的可能为空的路径名列表，其中的元素必须为包含一个路径信息的字符串。 &lt;em&gt;pathname&lt;/em&gt; 可以是绝对路径 (如 &lt;code&gt;/usr/src/Python-1.5/Makefile&lt;/code&gt;) 或相对路径 (如 &lt;code&gt;../../Tools/*/*.gif&lt;/code&gt;)，并且可包含 shell 风格的通配符。 结果也将包含无效的符号链接 (与在 shell 中一致)。 结果是否排序取决于具体文件系统。&lt;/p&gt;
&lt;p&gt;如果 &lt;em&gt;recursive&lt;/em&gt; 为真值，则模式 “&lt;code&gt;**&lt;/code&gt;“ 将匹配目录中的任何文件以及零个或多个目录、子目录和符号链接。 如果模式加了一个 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/os.html#os.sep&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;os.sep&lt;/code&gt;&lt;/a&gt; 或 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/os.html#os.altsep&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;os.altsep&lt;/code&gt;&lt;/a&gt; 则将不匹配文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：在一个较大的目录树中使用 “&lt;code&gt;**&lt;/code&gt;“ 模式可能会消耗非常多的时间。 &lt;em&gt;3.5 版更改:&lt;/em&gt; 支持使用 “&lt;code&gt;**&lt;/code&gt;“ 的递归 glob&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;glob.iglob(pathname, *, recursive=False)&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;返回一个 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iterator&lt;/a&gt;，它会产生与 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/glob.html#module-glob&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;glob()&lt;/code&gt;&lt;/a&gt; 相同的结果，但不会实际地同时保存它们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;glob.escape(pathname)&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;转义所有特殊字符 (&lt;code&gt;&amp;#39;?&amp;#39;&lt;/code&gt;, &lt;code&gt;&amp;#39;*&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;[&amp;#39;&lt;/code&gt;)。 这适用于当你想要匹配可能带有特殊字符的任意字符串字面值的情况。 在 drive/UNC 共享点中的特殊字符不会被转义，例如在 Windows 上 &lt;code&gt;escape(&amp;#39;//?/c:/Quo vadis?.txt&amp;#39;)&lt;/code&gt; 将返回 &lt;code&gt;&amp;#39;//?/c:/Quo vadis[?].txt&amp;#39;&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="glob" scheme="https://pinghailinfeng.gitee.io/tags/glob/"/>
    
      <category term="__all__" scheme="https://pinghailinfeng.gitee.io/tags/all/"/>
    
  </entry>
  
  <entry>
    <title>python standard library textwrap</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/06/python-standard-library-textwrap/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/06/python-standard-library-textwrap/</id>
    <published>2020-01-06T06:56:14.000Z</published>
    <updated>2020-01-06T07:33:40.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-标准库-之-textwrap"><a href="#Python-标准库-之-textwrap" class="headerlink" title="Python 标准库 之 textwrap"></a>Python 标准库 之 textwrap</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200106_code_2.jpg?raw=true" alt></p><h2 id="今天给大家介绍-python标准库中的-textwrap"><a href="#今天给大家介绍-python标准库中的-textwrap" class="headerlink" title="今天给大家介绍 python标准库中的 textwrap"></a>今天给大家介绍 python标准库中的 textwrap</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html" target="_blank" rel="noopener">参考文档</a></p><p>标准库 <code>textwrap</code> 是一个关于文本自动换行和填充的模块。</p><p>关于这个模块官网介绍如下:</p><p><a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#module-textwrap" target="_blank" rel="noopener"><code>textwrap</code></a> 模块提供了一些快捷函数，以及可以完成所有工作的类 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper" target="_blank" rel="noopener"><code>TextWrapper</code></a>。 </p><p>如果你只是要对一两个文本字符串进行自动换行或填充，快捷函数应该就够用了；</p><p>否则的话，你应该使用 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper" target="_blank" rel="noopener"><code>TextWrapper</code></a> 的实例来提高效率。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><code>textwrap.wrap(*text*, *width=70*, kwargs)</code></li></ul><p>对 <em>text</em> (字符串) 中的单独段落自动换行以使每行长度最多为 <em>width</em> 个字符。 返回由输出行组成的列表，行尾不带换行符。</p><ul><li><code>textwrap.fill</code>(<em>text</em>, <em>width=70</em>, kwargs)</li></ul><p>对 <em>text</em> 中的单独段落自动换行，并返回一个包含被自动换行段落的单独字符串。 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.fill" target="_blank" rel="noopener"><code>fill()</code></a> 是以下语句的快捷方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\n"</span>.join(wrap(text, ...))</span><br></pre></td></tr></table></figure><ul><li><code>textwrap.shorten(text, width, kwargs)</code></li></ul><p>折叠并截短给定的 <em>text</em> 以符合给定的 <em>width</em>。</p><a id="more"></a><ul><li><code>textwrap.dedent</code>(<em>text</em>)`</li></ul><p>移除 <em>text</em> 中每一行的任何相同前缀空白符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># end first line with \ to avoid the empty line!</span></span><br><span class="line">s = <span class="string">'''\</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">  world</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(repr(s))          <span class="comment"># prints '    hello\n      world\n    '</span></span><br><span class="line">print(repr(dedent(s)))  <span class="comment"># prints 'hello\n  world\n'</span></span><br></pre></td></tr></table></figure><ul><li><code>textwrap.</code>indent(<em>text</em>, <em>prefix</em>, predicate=None)`</li></ul><p>将 <em>prefix</em> 添加到 <em>text</em> 中选定行的开头。</p><p>通过调用 <code>text.splitlines(True)</code> 来对行进行拆分。</p><p>默认情况下，<em>prefix</em> 会被添加到所有不是只由空白符（包括任何行结束符）组成的行。</p><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'hello\n\n \nworld'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>indent(s, <span class="string">'  '</span>)</span><br><span class="line"><span class="string">'  hello\n\n \n  world'</span></span><br></pre></td></tr></table></figure><p>可选的 <em>predicate</em> 参数可用来控制哪些行要缩进。 例如，可以很容易地为空行或只有空白符的行添加 <em>prefix</em>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(indent(s, <span class="string">'+ '</span>, <span class="keyword">lambda</span> line: <span class="literal">True</span>))</span><br><span class="line">+ hello</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">+ world</span><br></pre></td></tr></table></figure><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><ul><li><p><code>width</code></p><p>(默认: <code>70</code>) 自动换行的最大行长度。 只要输入文本中没有长于 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.width" target="_blank" rel="noopener"><code>width</code></a> 的单个单词，<a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper" target="_blank" rel="noopener"><code>TextWrapper</code></a> 就能保证没有长于 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.width" target="_blank" rel="noopener"><code>width</code></a> 个字符的输出行。</p></li><li><p><code>expand_tabs</code></p><p>(默认: <code>True</code>) 如果为真值，则 <em>text</em> 中所有的制表符将使用 <em>text</em> 的 <code>expandtabs()</code> 方法扩展为空格符。</p></li><li><p><code>tabsize</code></p><p>(默认: <code>8</code>) 如果 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.expand_tabs" target="_blank" rel="noopener"><code>expand_tabs</code></a> 为真值，则 <em>text</em> 中所有的制表符将扩展为零个或多个空格，具体取决于当前列位置和给定的制表宽度。</p></li><li><p><code>replace_whitespace</code></p><p>(default: <code>True</code>) 如果为真值，在制表符扩展之后、自动换行之前，<a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.wrap" target="_blank" rel="noopener"><code>wrap()</code></a> 方法将把每个空白字符都替换为单个空格。 会被替换的空白字符如下：制表，换行，垂直制表，进纸和回车 (<code>&#39;\t\n\v\f\r&#39;</code>)。注解 如果 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.expand_tabs" target="_blank" rel="noopener"><code>expand_tabs</code></a> 为假值且 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.replace_whitespace" target="_blank" rel="noopener"><code>replace_whitespace</code></a> 为真值，每个制表符将被替换为单个空格，这与制表符扩展是 <em>不</em> 一样的。注解 如果 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.replace_whitespace" target="_blank" rel="noopener"><code>replace_whitespace</code></a> 为假值，在一行的中间有可能出现换行符并导致怪异的输出。 因此，文本应当（使用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str.splitlines" target="_blank" rel="noopener"><code>str.splitlines()</code></a> 或类似方法）拆分为段落并分别进行自动换行。</p></li><li><p><code>drop_whitespace</code></p><p>(默认: <code>True</code>) 如果为真值，每一行开头和末尾的空白字符（在包装之后、缩进之前）会被丢弃。 但是段落开头的空白字符如果后面不带任何非空白字符则不会被丢弃。 如果被丢弃的空白字符占据了一个整行，则该整行将被丢弃。</p></li><li><p><code>initial_indent</code></p><p>(默认: <code>&#39;&#39;</code>) 将被添加到被自动换行输出内容的第一行的字符串。 其长度会被计入第一行的长度。 空字符串不会被缩进。</p></li><li><p><code>subsequent_indent</code></p><p>(default: <code>&#39;&#39;</code>) 将被添加到被自动换行输出内容除第一行外的所有行的字符串。 其长度会被计入除行一行外的所有行的长度。</p></li><li><p><code>fix_sentence_endings</code></p><p>(默认: <code>False</code>) 如果为真值，<a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper" target="_blank" rel="noopener"><code>TextWrapper</code></a> 将尝试检测句子结尾并确保句子间总是以恰好两个空格符分隔。 对于使用等宽字体的文本来说通常都需要这样。 但是，句子检测算法并不完美：它假定句子结尾是一个小写字母加字符 <code>&#39;.&#39;</code>, <code>&#39;!&#39;</code> 或 <code>&#39;?&#39;</code> 中的一个，并可能带有字符 <code>&#39;&quot;&#39;</code> 或 <code>&quot;&#39;&quot;</code>，最后以一个空格结束。 此算法的问题之一是它无法区分以下文本中的 “Dr.”<code>[...] Dr. Frankenstein&#39;s monster [...]</code>和以下文本中的 “Spot.”<code>[...] See Spot. See Spot run [...]</code><a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.fix_sentence_endings" target="_blank" rel="noopener"><code>fix_sentence_endings</code></a> 默认为假值。由于句子检测算法依赖于 <code>string.lowercase</code> 来确定“小写字母”，以及约定在句点后使用两个空格来分隔处于同一行的句子，因此只适用于英语文本。</p></li><li><p><code>break_long_words</code></p><p>(默认: <code>True</code>) 如果为真值，则长度超过 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.width" target="_blank" rel="noopener"><code>width</code></a> 的单词将被分开以保证行的长度不会超过 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.width" target="_blank" rel="noopener"><code>width</code></a>。 如果为假值，超长单词不会被分开，因而某些行的长度可能会超过 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.width" target="_blank" rel="noopener"><code>width</code></a>。 （超长单词将被单独作为一行，以尽量减少超出 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.width" target="_blank" rel="noopener"><code>width</code></a> 的情况。）</p></li><li><p><code>break_on_hyphens</code></p><p>(默认: <code>True</code>) 如果为真值，将根据英语的惯例首选在空白符和复合词的连字符之后自动换行。 如果为假值，则只有空白符会被视为合适的潜在断行位置，但如果你确实不希望出现分开的单词则你必须将 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.break_long_words" target="_blank" rel="noopener"><code>break_long_words</code></a> 设为假值。 之前版本的默认行为总是允许分开带有连字符的单词。</p></li><li><p><code>max_lines</code></p><p>(默认: <code>None</code>) 如果不为 <code>None</code>，则输出内容将最多包含 <em>max_lines</em> 行，并使 <em>placeholder</em> 出现在输出内容的末尾。</p></li><li><p><code>placeholder</code></p><p>(默认: <code>&#39; [...]&#39;</code>) 该文本将在输出文本被截短时出现在文本末尾。</p></li></ul><h2 id="公有方法"><a href="#公有方法" class="headerlink" title="公有方法"></a>公有方法</h2><ul><li><p><code>wrap</code>(<em>text</em>)</p><p>对 <em>text</em> (字符串) 中的单独段落自动换行以使每行长度最多为 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper.width" target="_blank" rel="noopener"><code>width</code></a> 个字符。 所有自动换行选项均获取自 <a href="https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper" target="_blank" rel="noopener"><code>TextWrapper</code></a> 实例的实例属性。 返回由输出行组成的列表，行尾不带换行符。 如果自动换行输出结果没有任何内容，则返回空列表。</p></li><li><p><code>fill</code>(<em>text</em>)</p><p>对 <em>text</em> 中的单独段落自动换行并返回包含被自动换行段落的单独字符串。</p></li></ul><h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><p>比如我想格式化一个文本,每一行要求输出的文字固定字符的长度30,就可以使用textwrap这个模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> textwrap <span class="keyword">import</span> wrap</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = <span class="string">'This is python programming language. One of its kind, it is also one of the most popular language in the world.'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = wrap(text = string, width = <span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'This is python programming'</span>, <span class="string">'language. One of its kind, it'</span>, <span class="string">'is also one of the most'</span>, <span class="string">'popular language in the world.'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line"><span class="keyword">print</span> i</span><br><span class="line"> </span><br><span class="line">This <span class="keyword">is</span> python programming</span><br><span class="line">language. One of its kind, it</span><br><span class="line"><span class="keyword">is</span> also one of the most</span><br><span class="line">popular language <span class="keyword">in</span> the world.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-标准库-之-textwrap&quot;&gt;&lt;a href=&quot;#Python-标准库-之-textwrap&quot; class=&quot;headerlink&quot; title=&quot;Python 标准库 之 textwrap&quot;&gt;&lt;/a&gt;Python 标准库 之 textwrap&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200106_code_2.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;今天给大家介绍-python标准库中的-textwrap&quot;&gt;&lt;a href=&quot;#今天给大家介绍-python标准库中的-textwrap&quot; class=&quot;headerlink&quot; title=&quot;今天给大家介绍 python标准库中的 textwrap&quot;&gt;&lt;/a&gt;今天给大家介绍 python标准库中的 textwrap&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/textwrap.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;标准库 &lt;code&gt;textwrap&lt;/code&gt; 是一个关于文本自动换行和填充的模块。&lt;/p&gt;
&lt;p&gt;关于这个模块官网介绍如下:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/textwrap.html#module-textwrap&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;textwrap&lt;/code&gt;&lt;/a&gt; 模块提供了一些快捷函数，以及可以完成所有工作的类 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;TextWrapper&lt;/code&gt;&lt;/a&gt;。 &lt;/p&gt;
&lt;p&gt;如果你只是要对一两个文本字符串进行自动换行或填充，快捷函数应该就够用了；&lt;/p&gt;
&lt;p&gt;否则的话，你应该使用 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.TextWrapper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;TextWrapper&lt;/code&gt;&lt;/a&gt; 的实例来提高效率。&lt;/p&gt;
&lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;textwrap.wrap(*text*, *width=70*, kwargs)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对 &lt;em&gt;text&lt;/em&gt; (字符串) 中的单独段落自动换行以使每行长度最多为 &lt;em&gt;width&lt;/em&gt; 个字符。 返回由输出行组成的列表，行尾不带换行符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;textwrap.fill&lt;/code&gt;(&lt;em&gt;text&lt;/em&gt;, &lt;em&gt;width=70&lt;/em&gt;, kwargs)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对 &lt;em&gt;text&lt;/em&gt; 中的单独段落自动换行，并返回一个包含被自动换行段落的单独字符串。 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/textwrap.html#textwrap.fill&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;fill()&lt;/code&gt;&lt;/a&gt; 是以下语句的快捷方式&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;.join(wrap(text, ...))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;textwrap.shorten(text, width, kwargs)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;折叠并截短给定的 &lt;em&gt;text&lt;/em&gt; 以符合给定的 &lt;em&gt;width&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
  </entry>
  
  <entry>
    <title>python standard library http.server</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/05/python-standard-library-http-server/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/05/python-standard-library-http-server/</id>
    <published>2020-01-05T13:11:30.000Z</published>
    <updated>2020-01-06T06:53:31.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库之-http-server"><a href="#python-标准库之-http-server" class="headerlink" title="python 标准库之 http.server"></a>python 标准库之 http.server</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200105_with_my_angle.jpg?raw=true" alt></p><p>今天下午主要是陪我闺女,组装完成一个桌面足球,很开心的一下午。</p><p>孩子的童年只有一次,有时间多陪陪孩子吧。</p><h2 id="python-标准库-http-server"><a href="#python-标准库-http-server" class="headerlink" title="python 标准库 http.server"></a>python 标准库 http.server</h2><p>从python2时代开始 SimpleHttpServer就陪伴我走过那些快乐的时光。可以自己建立一个简单的文件服务器,让同事们通过浏览器就可以访问我电脑上的资源,而不需要http server或者 ftp软件。</p><p>到了python3时代,这个模块被合并进了http.server。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/http.server.html" target="_blank" rel="noopener">参考网址</a></p><p>这个模块定义了实现 HTTP 服务器（ Web 服务器）的类 。</p><p> <a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.HTTPServer" target="_blank" rel="noopener"><code>HTTPServer</code></a> 是 <a href="https://docs.python.org/zh-cn/3.8/library/socketserver.html#socketserver.TCPServer" target="_blank" rel="noopener"><code>socketserver.TCPServer</code></a> 的一个子类。它会创建和侦听 HTTP 套接字，并将请求调度给处理程序。用于创建和运行服务器的代码看起来像这样 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(server_class=HTTPServer, handler_class=BaseHTTPRequestHandler)</span>:</span></span><br><span class="line">    server_address = (<span class="string">''</span>, <span class="number">8000</span>)</span><br><span class="line">    httpd = server_class(server_address, handler_class)</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure><h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><p><code>class http.server.HTTPServer(server_address, RequestHandlerClass)</code></p><blockquote><p> 该类基于 <a href="https://docs.python.org/zh-cn/3.8/library/socketserver.html#socketserver.TCPServer" target="_blank" rel="noopener"><code>TCPServer</code></a> 类，并会将服务器地址存入名为 <code>server_name</code> 和 <code>server_port</code> 的实例变量中。服务器可被处理程序通过 <code>server</code> 实例变量访问。 </p></blockquote><p><code>class http.server.ThreadingHTTPServer(server_address, RequestHandlerClass)</code></p><blockquote><p>根据官方说明,这是一个基于 <a href="https://docs.python.org/zh-cn/3.8/library/socketserver.html#socketserver.ThreadingMixIn" target="_blank" rel="noopener"><code>ThreadingMixIn</code></a>的类,主要功能是使用线程处理请求。</p></blockquote><a id="more"></a><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler" target="_blank" rel="noopener"><code>BaseHTTPRequestHandler</code></a> has the following instance variables:</p><ul><li><p><code>client_address</code></p><p>包含指向客户地址的元组类型数据(host,port)</p></li><li><p><code>server</code></p><p>包含Server实例</p></li><li><p><code>close_connection</code></p><p>返回一个Boolean类型数据,在<a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.handle_one_request" target="_blank" rel="noopener"><code>handle_one_request()</code></a> ,表明另一个请求开始,或者当前请求关闭。</p></li><li><p><code>requestline</code></p><p>包含http请求行，. 这个属性应该用 <a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.handle_one_request" target="_blank" rel="noopener"><code>handle_one_request()</code></a>设置. 如果一个不存在的请求被执行,应将其设置成空字符串。</p></li><li><p><code>command</code></p><p>包含Http请求类型,例如:’Get’</p></li><li><p><code>path</code></p><p>包含请求url路径</p></li><li><p><code>request_version</code></p><p>包含请求的版本,例如:’ HTTP/1.0 ‘</p></li><li><p><code>headers</code></p><p>包含通过<a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.MessageClass" target="_blank" rel="noopener"><code>MessageClass</code></a> 类声明的变量。实例会转化为http请求。<a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#module-http.client" target="_blank" rel="noopener"><code>http.client</code></a> 中<a href="https://docs.python.org/zh-cn/3.8/library/http.client.html#http.client.parse_headers" target="_blank" rel="noopener"><code>parse_headers()</code></a> 方法可以验证一个非法的请求头,参照 <a href="https://tools.ietf.org/html/rfc2822.html" target="_blank" rel="noopener"><strong>RFC 2822</strong></a> 中请求头说明。</p></li><li><p><code>rfile</code></p><p>一个<a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.BufferedIOBase" target="_blank" rel="noopener"><code>io.BufferedIOBase</code></a> 输入流对象，读取可能输入数据。</p></li><li><p><code>wfile</code></p><p>根据客户端请求,返回数据</p></li></ul><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><ul><li><p><code>server_version</code></p><p>格式化输出服务器版本信息,例如<code>&#39;BaseHTTP/0.2&#39;</code>.</p></li><li><p><code>sys_version</code></p><p>包含系统版本,使用<a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.version_string" target="_blank" rel="noopener"><code>version_string</code></a> 方法和<a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.server_version" target="_blank" rel="noopener"><code>server_version</code></a> 类变量,例如:<code>&#39;Python/1.4&#39;</code>.</p></li><li><p><code>error_message_format</code></p><p>声明错误信息</p></li><li><p><code>error_content_type</code></p><p>声明错误上下文类型默认值是 <code>&#39;text/html&#39;</code>.</p></li><li><p><code>protocol_version</code></p><p>声明HTTP协议版本,例如:<code>&#39;HTTP/1.1&#39;</code>, 服务器会保持连接。</p></li><li><p><code>MessageClass</code></p><p>声明<code>email.message.Message</code>](<a href="https://docs.python.org/zh-cn/3.8/library/email.compat32-message.html#email.message.Message)-like" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3.8/library/email.compat32-message.html#email.message.Message)-like</a> 类处理请求头。通常不用重写,默认指向<code>http.client.HTTPMessage</code>属性。.</p></li><li><p><code>responses</code></p><p>回应 通常使用<a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.send_response_only" target="_blank" rel="noopener"><code>send_response_only()</code></a> 和<a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.send_error" target="_blank" rel="noopener"><code>send_error()</code></a> 方法实现。</p></li></ul><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul><li><p><code>handle</code>()</p><p>调用<a href="https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.BaseHTTPRequestHandler.handle_one_request" target="_blank" rel="noopener"><code>handle_one_request()</code></a> 方法一次(如果保持连接,会调用多次) 来管理http请求。. 此方法不需要重写,除此以外,可以重写 <code>do_*()</code> 等方法实现处理请求。</p></li><li><p><code>handle_one_request</code>()</p><p>此方法不需要重写,实现处理 <code>do_*()</code>等方法.</p></li><li><p><code>handle_expect_100</code>()</p><p>当 HTTP/1.1 请求时,服务器期望返回  100-continue 并返回 <code>200</code>响应码。如果想拒绝客户端连接,会抛出一个异常。</p></li><li><p><code>send_error</code>(<em>code</em>, <em>message=None</em>, <em>explain=None</em>) </p></li><li><p><code>send_response</code>(<em>code</em>, <em>message=None</em>) </p></li><li><p><code>send_header</code>(<em>keyword</em>, <em>value</em>) </p></li><li><p><code>send_response_only</code>(<em>code</em>, <em>message=None</em>) </p></li><li><p><code>end_headers</code>() </p></li><li><p><code>flush_headers</code>() </p></li><li><p><code>log_request</code>(<em>code=’-‘</em>, <em>size=’-‘</em>) </p></li><li><p><code>log_error</code>(<em>…</em>) </p></li><li><p><code>log_message</code>(<em>format</em>, <em>…</em>) </p></li><li><p><code>version_string</code>() </p></li><li><p><code>date_time_string</code>(<em>timestamp=None</em>) </p></li><li><p><code>log_date_time_string</code>() </p></li><li><p><code>address_string</code>() </p></li></ul><h3 id="创建一个简易服务器"><a href="#创建一个简易服务器" class="headerlink" title="创建一个简易服务器"></a>创建一个简易服务器</h3><p>例如下面的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http.server</span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line">PORT = <span class="number">8000</span></span><br><span class="line"></span><br><span class="line">Handler = http.server.SimpleHTTPRequestHandler</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socketserver.TCPServer((<span class="string">""</span>, PORT), Handler) <span class="keyword">as</span> httpd:</span><br><span class="line">    print(<span class="string">"serving at port"</span>, PORT)</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure><p>当然也可以通过命令行方式创建,例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server <span class="number">8000</span></span><br></pre></td></tr></table></figure><p>默认绑定本机的ip地址。</p><p>当然你可以指定一个ip地址,加入<code>--bind</code>参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server <span class="number">8000</span> --bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>3.8 新增 支持绑定ipv6地址</p><p>3.7 新增支持绑定一个cgi程序,例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server --cgi <span class="number">8000</span></span><br></pre></td></tr></table></figure><h3 id="一个具体应用的实例"><a href="#一个具体应用的实例" class="headerlink" title="一个具体应用的实例"></a>一个具体应用的实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</span><br><span class="line"> </span><br><span class="line"><span class="comment"># HTTPRequestHandler class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testHTTPServer_RequestHandler</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment"># GET</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Send response status code</span></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># Send headers</span></span><br><span class="line">        self.send_header(<span class="string">'Content-type'</span>,<span class="string">'text/html'</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># Send message back to client</span></span><br><span class="line">        message = <span class="string">"Hello world!"</span></span><br><span class="line">        <span class="comment"># Write content as utf-8 data</span></span><br><span class="line">        self.wfile.write(bytes(message, <span class="string">"utf8"</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'starting server...'</span>)</span><br><span class="line"> </span><br><span class="line">  <span class="comment"># Server settings</span></span><br><span class="line">  <span class="comment"># Choose port 8080, for port 80, which is normally used for a http server, you need root access</span></span><br><span class="line">  server_address = (<span class="string">'127.0.0.1'</span>, <span class="number">8081</span>)</span><br><span class="line">  httpd = HTTPServer(server_address, testHTTPServer_RequestHandler)</span><br><span class="line">  print(<span class="string">'running server...'</span>)</span><br><span class="line">  httpd.serve_forever()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">run()</span><br></pre></td></tr></table></figure><p><strong>备注</strong>: 此处<code>wfile.write</code>方法 需要转成 byte类型,</p><p>可以参考stackoverflow上的关于这个问题的讨论:: </p><p><a href="https://stackoverflow.com/questions/23264569/python-3-x-basehttpserver-or-http-server" target="_blank" rel="noopener">python-3-x-basehttpserver-or-http-server</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>看完http.server 深有感触,一个简单的服务器学习了这么多http协议实现,看来还得继续深入理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库之-http-server&quot;&gt;&lt;a href=&quot;#python-标准库之-http-server&quot; class=&quot;headerlink&quot; title=&quot;python 标准库之 http.server&quot;&gt;&lt;/a&gt;python 标准库之 http.server&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200105_with_my_angle.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;今天下午主要是陪我闺女,组装完成一个桌面足球,很开心的一下午。&lt;/p&gt;
&lt;p&gt;孩子的童年只有一次,有时间多陪陪孩子吧。&lt;/p&gt;
&lt;h2 id=&quot;python-标准库-http-server&quot;&gt;&lt;a href=&quot;#python-标准库-http-server&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 http.server&quot;&gt;&lt;/a&gt;python 标准库 http.server&lt;/h2&gt;&lt;p&gt;从python2时代开始 SimpleHttpServer就陪伴我走过那些快乐的时光。可以自己建立一个简单的文件服务器,让同事们通过浏览器就可以访问我电脑上的资源,而不需要http server或者 ftp软件。&lt;/p&gt;
&lt;p&gt;到了python3时代,这个模块被合并进了http.server。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/http.server.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考网址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个模块定义了实现 HTTP 服务器（ Web 服务器）的类 。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/http.server.html#http.server.HTTPServer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;HTTPServer&lt;/code&gt;&lt;/a&gt; 是 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/socketserver.html#socketserver.TCPServer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;socketserver.TCPServer&lt;/code&gt;&lt;/a&gt; 的一个子类。它会创建和侦听 HTTP 套接字，并将请求调度给处理程序。用于创建和运行服务器的代码看起来像这样 &lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(server_class=HTTPServer, handler_class=BaseHTTPRequestHandler)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    server_address = (&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    httpd = server_class(server_address, handler_class)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    httpd.serve_forever()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;核心类&quot;&gt;&lt;a href=&quot;#核心类&quot; class=&quot;headerlink&quot; title=&quot;核心类&quot;&gt;&lt;/a&gt;核心类&lt;/h3&gt;&lt;p&gt;&lt;code&gt;class http.server.HTTPServer(server_address, RequestHandlerClass)&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 该类基于 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/socketserver.html#socketserver.TCPServer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;TCPServer&lt;/code&gt;&lt;/a&gt; 类，并会将服务器地址存入名为 &lt;code&gt;server_name&lt;/code&gt; 和 &lt;code&gt;server_port&lt;/code&gt; 的实例变量中。服务器可被处理程序通过 &lt;code&gt;server&lt;/code&gt; 实例变量访问。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;class http.server.ThreadingHTTPServer(server_address, RequestHandlerClass)&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根据官方说明,这是一个基于 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/socketserver.html#socketserver.ThreadingMixIn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt;的类,主要功能是使用线程处理请求。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="http.server" scheme="https://pinghailinfeng.gitee.io/tags/http-server/"/>
    
  </entry>
  
  <entry>
    <title>windows jupyter notebook nbextension usage</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/04/windows-jupyter-notebook-nbextension-usage/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/04/windows-jupyter-notebook-nbextension-usage/</id>
    <published>2020-01-04T07:22:07.000Z</published>
    <updated>2020-01-04T07:52:25.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="windows下jupyter-安装nbextension-插件填坑记"><a href="#windows下jupyter-安装nbextension-插件填坑记" class="headerlink" title="windows下jupyter 安装nbextension 插件填坑记"></a>windows下jupyter 安装nbextension 插件填坑记</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200104_cold.png?raw=true" alt></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><table><thead><tr><th>软件和操作系统</th><th>版本号</th></tr></thead><tbody><tr><td>操作系统</td><td>win7 64位 sp1</td></tr><tr><td>python版本</td><td>3.6.2</td></tr><tr><td>jupyter core</td><td>4.5.0</td></tr><tr><td>jupyter notebook</td><td>6.0.0</td></tr></tbody></table><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>本来以为给jupyter安装个插件,分分钟搞定的事,结果三天了还是没解决。</p><p>我回家用win10的电脑,5分钟搞定。</p><p>尝试了各种方式,卸载重装,修改环境变量,换不同的python版本。后来我快要放放弃的时候，我终于搞定了。</p><a id="more"></a><h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>我突然想到,是不是因为我安装了anaconda,于是增加了搜索关键字,终于发现了问题所在。</p><h2 id="正确操作步骤"><a href="#正确操作步骤" class="headerlink" title="正确操作步骤"></a>正确操作步骤</h2><ol><li><p>确定是已经安装好<code>anaconda</code></p></li><li><p>要在<strong><code>anaconda prompt</code></strong>模式下(重要的事情说三遍,三遍,三遍，此处省略一万字,万马奔腾)</p></li><li><p><code>pip install jupyter_contrib_nbextensions</code></p></li><li><p>配置：<code>jupyter contrib nbextension install --user --skip-running-check</code></p></li><li><p>启动<code>jupyter notebook</code>，“Nbextensions”出现在导航栏中，在勾选目录。  </p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20190418142848765.png?raw=true" alt></p></li></ol><h2 id="查看-jupyter-版本"><a href="#查看-jupyter-版本" class="headerlink" title="查看 jupyter 版本"></a>查看 jupyter 版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) C:\Users\Mr.Sui&gt;jupyter --version</span><br><span class="line">jupyter core     : 4.5.0</span><br><span class="line">jupyter-notebook : 6.0.0</span><br><span class="line">qtconsole        : 4.5.1</span><br><span class="line">ipython          : 7.6.1</span><br><span class="line">ipykernel        : 5.1.1</span><br><span class="line">jupyter client   : 5.3.1</span><br><span class="line">jupyter lab      : 1.0.2</span><br><span class="line">nbconvert        : 5.5.0</span><br><span class="line">ipywidgets       : 7.5.0</span><br><span class="line">nbformat         : 4.4.0</span><br><span class="line">traitlets        : 4.3.2</span><br></pre></td></tr></table></figure><h2 id="有用的插件"><a href="#有用的插件" class="headerlink" title="有用的插件"></a>有用的插件</h2><ol><li>代码导航功能 Table of Contents</li><li>变量检查器 Variable Inspector</li><li>显示单元格运行的时间和长度 Excute time</li><li>折叠/放下标题 Collapsible Headings</li><li>折叠代码 Codefolding</li><li>隐藏代码 hide input 隐藏选定代码 hide input all 隐藏所有代码</li><li>代码自动补全 Hinterland</li><li>通知 Notify Jupyter Notebook</li></ol><blockquote><p>首先你要勾选Notify扩展，其次再点击按钮正式启动。你选择的时间是Jupyter Notebook运行的最短时间，到点后它会向你发送通知</p></blockquote><ol start="9"><li><p>隐藏活动状态栏 zenmode</p></li><li><p>tqdm_notebook 为循环代码显示执行进度条</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 先安装 tqdm ：pip install tqdm</span><br><span class="line"># 使用时导入：from tqdm import tqdm_notebook</span><br></pre></td></tr></table></figure><ol start="11"><li>脚本自动保存 AutoSaveTime</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/install.html#install-the-python-package" target="_blank" rel="noopener">官网教程</a></p><p><a href="https://blog.csdn.net/qq_34705900/article/details/80197956" target="_blank" rel="noopener">jupyter notebook的插件拓展—-jupyter_contrib_nbextensions</a></p><p><a href="https://www.cnblogs.com/noticeable/p/9010881.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/noticeable/p/9010881.html" target="_blank" rel="noopener">使用Jupyter Notebook编写技术文档</a></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;windows下jupyter-安装nbextension-插件填坑记&quot;&gt;&lt;a href=&quot;#windows下jupyter-安装nbextension-插件填坑记&quot; class=&quot;headerlink&quot; title=&quot;windows下jupyter 安装nbextension 插件填坑记&quot;&gt;&lt;/a&gt;windows下jupyter 安装nbextension 插件填坑记&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200104_cold.png?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;软件和操作系统&lt;/th&gt;
&lt;th&gt;版本号&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;操作系统&lt;/td&gt;
&lt;td&gt;win7 64位 sp1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;python版本&lt;/td&gt;
&lt;td&gt;3.6.2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jupyter core&lt;/td&gt;
&lt;td&gt;4.5.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jupyter notebook&lt;/td&gt;
&lt;td&gt;6.0.0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;本来以为给jupyter安装个插件,分分钟搞定的事,结果三天了还是没解决。&lt;/p&gt;
&lt;p&gt;我回家用win10的电脑,5分钟搞定。&lt;/p&gt;
&lt;p&gt;尝试了各种方式,卸载重装,修改环境变量,换不同的python版本。后来我快要放放弃的时候，我终于搞定了。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="windows" scheme="https://pinghailinfeng.gitee.io/tags/windows/"/>
    
      <category term="juypter" scheme="https://pinghailinfeng.gitee.io/tags/juypter/"/>
    
      <category term="nbextension" scheme="https://pinghailinfeng.gitee.io/tags/nbextension/"/>
    
  </entry>
  
  <entry>
    <title>python standard library webbrowser</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/03/python-standard-library-webbrowser/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/03/python-standard-library-webbrowser/</id>
    <published>2020-01-03T04:07:55.000Z</published>
    <updated>2020-01-03T08:26:48.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库之-webbrowser"><a href="#python-标准库之-webbrowser" class="headerlink" title="python 标准库之 webbrowser"></a>python 标准库之 webbrowser</h1><h2 id="没啥前提"><a href="#没啥前提" class="headerlink" title="没啥前提"></a>没啥前提</h2><p>一张图表示我现在的心情</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200103_cold.jpg?raw=true" alt="冷啊"></p><h2 id="标准库-webbrowser"><a href="#标准库-webbrowser" class="headerlink" title="标准库 webbrowser"></a>标准库 webbrowser</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#module-webbrowser" target="_blank" rel="noopener"><code>webbrowser</code></a> 模块提供了一个高级接口，允许向用户显示基于Web的文档。 在大多数情况下，只需从该模块调用 <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.open" target="_blank" rel="noopener"><code>open()</code></a> 函数就可以了。</p><p>在 Unix 下，图形浏览器在 X11 下是首选，但如果图形浏览器不可用或 X11 显示不可用，则将使用文本模式浏览器。 如果使用文本模式浏览器，则调用进程将阻塞，直到用户退出浏览器。</p><p>如果存在环境变量 <code>BROWSER</code> ，则将其解释为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pathsep" target="_blank" rel="noopener"><code>os.pathsep</code></a> 分隔的浏览器列表，以便在平台默认值之前尝试。 当列表部分的值包含字符串 <code>％s</code> 时，它被解释为一个文字浏览器命令行，用于替换 <code>％s</code> 的参数 URL ；如果该部分不包含 <code>％s</code>，则它只被解释为要启动的浏览器的名称。</p><p>脚本 <strong>webbrowser</strong> 可以用作模块的命令行界面。它接受一个 URL 作为参数。还接受以下可选参数：<code>-n</code> 如果可能，在新的浏览器窗口中打开 URL ； <code>-t</code> 在新的浏览器页面（“标签”）中打开 URL。这些选择当然是相互排斥的。用法示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m webbrowser -t <span class="string">"https://jeffsui.github.io"</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><em>exception</em> <code>webbrowser.Error</code></p><p>发生浏览器控件错误时引发异常。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p><code>webbrowser.`</code>open`(<em>url</em>, <em>new=0</em>, <em>autoraise=True</em>)</p><p>使用默认浏览器显示 <em>url</em>。 如果 <em>new</em> 为 0，则尽可能在同一浏览器窗口中打开 <em>url</em>。 如果 <em>new</em> 为 1，则尽可能打开新的浏览器窗口。 如果 <em>new</em> 为 2，则尽可能打开新的浏览器页面（“标签”）。 如果 <em>autoraise</em> 为 “True”，则会尽可能置前窗口（请注意，在许多窗口管理器下，无论此变量的设置如何，都会置前窗口）。请注意，在某些平台上，尝试使用此函数打开文件名，可能会起作用并启动操作系统的关联程序。 但是，这种方式不被支持也不可移植。使用 <code>url</code> 参数会引发 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">auditing event</a> <code>webbrowser.open</code> 。</p></li><li><p><code>webbrowser.open_new(url)</code></p><p>如果可能，在默认浏览器的新窗口中打开 <em>url</em>，否则，在唯一的浏览器窗口中打开 <em>url</em>。</p></li><li><p><code>webbrowser.open_new_tab(url)</code></p><p>如果可能，在默认浏览器的新页面（“标签”）中打开 <em>url</em>，否则等效于 <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.open_new" target="_blank" rel="noopener"><code>open_new()</code></a>。</p></li><li><p><code>webbrowser.get(*using=None*)</code></p><p>返回浏览器类型为 <em>using</em> 指定的控制器对象。 如果 <em>using</em> 为 <code>None</code>，则返回适用于调用者环境的默认浏览器的控制器。</p></li><li><p><code>webbrowser.register</code>(<em>name</em>, <em>constructor</em>, <em>instance=None</em>, <em>**, </em>preferred=False*)</p><p>注册 <em>name</em> 浏览器类型。 注册浏览器类型后， <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.get" target="_blank" rel="noopener"><code>get()</code></a> 函数可以返回该浏览器类型的控制器。 如果没有提供 <em>instance</em>，或者为 <code>None</code>，<em>constructor</em> 将在没有参数的情况下被调用，以在需要时创建实例。 如果提供了 <em>instance</em>，则永远不会调用 <em>constructor</em>，并且可能是 <code>None</code>。将 <em>preferred</em> 设置为 <code>True</code> 使得这个浏览器成为 <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.get" target="_blank" rel="noopener"><code>get()</code></a> 不带参数调用的首选结果。 否则，只有在您计划设置 <code>BROWSER</code> 变量，或使用与您声明的处理程序的名称相匹配的非空参数调用 <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.get" target="_blank" rel="noopener"><code>get()</code></a> 时，此入口点才有用。</p></li></ul><h3 id="浏览器类型"><a href="#浏览器类型" class="headerlink" title="浏览器类型"></a>浏览器类型</h3><p>预定义了许多浏览器类型。 此表给出了可以传递给 <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.get" target="_blank" rel="noopener"><code>get()</code></a> 函数的类型名称以及控制器类的相应实例化，这些都在此模块中定义。</p><table><thead><tr><th>类型名</th><th>类名</th><th>注释</th></tr></thead><tbody><tr><td><code>&#39;mozilla&#39;</code></td><td><code>Mozilla(&#39;mozilla&#39;)</code></td><td></td></tr><tr><td><code>&#39;firefox&#39;</code></td><td><code>Mozilla(&#39;mozilla&#39;)</code></td><td></td></tr><tr><td><code>&#39;netscape&#39;</code></td><td><code>Mozilla(&#39;netscape&#39;)</code></td><td></td></tr><tr><td><code>&#39;galeon&#39;</code></td><td><code>Galeon(&#39;galeon&#39;)</code></td><td></td></tr><tr><td><code>&#39;epiphany&#39;</code></td><td><code>Galeon(&#39;epiphany&#39;)</code></td><td></td></tr><tr><td><code>&#39;skipstone&#39;</code></td><td><code>BackgroundBrowser(&#39;skipstone&#39;)</code></td><td></td></tr><tr><td><code>&#39;kfmclient&#39;</code></td><td><code>Konqueror()</code></td><td>(1)</td></tr><tr><td><code>&#39;konqueror&#39;</code></td><td><code>Konqueror()</code></td><td>(1)</td></tr><tr><td><code>&#39;kfm&#39;</code></td><td><code>Konqueror()</code></td><td>(1)</td></tr><tr><td><code>&#39;mosaic&#39;</code></td><td><code>BackgroundBrowser(&#39;mosaic&#39;)</code></td><td></td></tr><tr><td><code>&#39;opera&#39;</code></td><td><code>Opera()</code></td><td></td></tr><tr><td><code>&#39;grail&#39;</code></td><td><code>Grail()</code></td><td></td></tr><tr><td><code>&#39;links&#39;</code></td><td><code>GenericBrowser(&#39;links&#39;)</code></td><td></td></tr><tr><td><code>&#39;elinks&#39;</code></td><td><code>Elinks(&#39;elinks&#39;)</code></td><td></td></tr><tr><td><code>&#39;lynx&#39;</code></td><td><code>GenericBrowser(&#39;lynx&#39;)</code></td><td></td></tr><tr><td><code>&#39;w3m&#39;</code></td><td><code>GenericBrowser(&#39;w3m&#39;)</code></td><td></td></tr><tr><td><code>&#39;windows-default&#39;</code></td><td><code>WindowsDefault</code></td><td>(2)</td></tr><tr><td><code>&#39;macosx&#39;</code></td><td><code>MacOSX(&#39;default&#39;)</code></td><td>(3)</td></tr><tr><td><code>&#39;safari&#39;</code></td><td><code>MacOSX(&#39;safari&#39;)</code></td><td>(3)</td></tr><tr><td><code>&#39;google-chrome&#39;</code></td><td><code>Chrome(&#39;google-chrome&#39;)</code></td><td></td></tr><tr><td><code>&#39;chrome&#39;</code></td><td><code>Chrome(&#39;chrome&#39;)</code></td><td></td></tr><tr><td><code>&#39;chromium&#39;</code></td><td><code>Chromium(&#39;chromium&#39;)</code></td><td></td></tr><tr><td><code>&#39;chromium-browser&#39;</code></td><td><code>Chromium(&#39;chromium-browser&#39;)</code></td></tr></tbody></table><p>简单的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">'http://docs.python.org/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Open URL in a new tab, if a browser window is already open.</span></span><br><span class="line">webbrowser.open_new_tab(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Open URL in new window, raising the window if possible.</span></span><br><span class="line">webbrowser.open_new(url)</span><br></pre></td></tr></table></figure><h3 id="浏览器控制器对象"><a href="#浏览器控制器对象" class="headerlink" title="浏览器控制器对象"></a>浏览器控制器对象</h3><p>浏览器控制器提供三个与模块级便捷函数相同的方法：</p><ul><li><p><code>controller.open</code>(<em>url</em>, <em>new=0</em>, <em>autoraise=True</em>)`</p><p>使用此控制器处理的浏览器显示 <em>url</em>。 如果 <em>new</em> 为 1，则尽可能打开新的浏览器窗口。 如果 <em>new</em> 为 2，则尽可能打开新的浏览器页面（“标签”）。</p></li><li><p><code>controller.open_new</code>(<em>url</em>)`</p><p>如果可能，在此控制器处理的浏览器的新窗口中打开 <em>url</em> ，否则，在唯一的浏览器窗口中打开 <em>url</em> 。 别名 <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.open_new" target="_blank" rel="noopener"><code>open_new()</code></a>。</p></li><li><p><code>controller.open_new_tab</code>(<em>url</em>)`</p><p>如果可能，在此控制器处理的浏览器的新页面（“标签”）中打开 <em>url</em>，否则等效于 <a href="https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.open_new" target="_blank" rel="noopener"><code>open_new()</code></a></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>标准库中的webbrowser只提供了一个简单的操作本地浏览器的接口。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库之-webbrowser&quot;&gt;&lt;a href=&quot;#python-标准库之-webbrowser&quot; class=&quot;headerlink&quot; title=&quot;python 标准库之 webbrowser&quot;&gt;&lt;/a&gt;python 标准库之 webbrowser&lt;/h1&gt;&lt;h2 id=&quot;没啥前提&quot;&gt;&lt;a href=&quot;#没啥前提&quot; class=&quot;headerlink&quot; title=&quot;没啥前提&quot;&gt;&lt;/a&gt;没啥前提&lt;/h2&gt;&lt;p&gt;一张图表示我现在的心情&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200103_cold.jpg?raw=true&quot; alt=&quot;冷啊&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;标准库-webbrowser&quot;&gt;&lt;a href=&quot;#标准库-webbrowser&quot; class=&quot;headerlink&quot; title=&quot;标准库 webbrowser&quot;&gt;&lt;/a&gt;标准库 webbrowser&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/webbrowser.html#module-webbrowser&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;webbrowser&lt;/code&gt;&lt;/a&gt; 模块提供了一个高级接口，允许向用户显示基于Web的文档。 在大多数情况下，只需从该模块调用 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/webbrowser.html#webbrowser.open&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; 函数就可以了。&lt;/p&gt;
&lt;p&gt;在 Unix 下，图形浏览器在 X11 下是首选，但如果图形浏览器不可用或 X11 显示不可用，则将使用文本模式浏览器。 如果使用文本模式浏览器，则调用进程将阻塞，直到用户退出浏览器。&lt;/p&gt;
&lt;p&gt;如果存在环境变量 &lt;code&gt;BROWSER&lt;/code&gt; ，则将其解释为 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/os.html#os.pathsep&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;os.pathsep&lt;/code&gt;&lt;/a&gt; 分隔的浏览器列表，以便在平台默认值之前尝试。 当列表部分的值包含字符串 &lt;code&gt;％s&lt;/code&gt; 时，它被解释为一个文字浏览器命令行，用于替换 &lt;code&gt;％s&lt;/code&gt; 的参数 URL ；如果该部分不包含 &lt;code&gt;％s&lt;/code&gt;，则它只被解释为要启动的浏览器的名称。&lt;/p&gt;
&lt;p&gt;脚本 &lt;strong&gt;webbrowser&lt;/strong&gt; 可以用作模块的命令行界面。它接受一个 URL 作为参数。还接受以下可选参数：&lt;code&gt;-n&lt;/code&gt; 如果可能，在新的浏览器窗口中打开 URL ； &lt;code&gt;-t&lt;/code&gt; 在新的浏览器页面（“标签”）中打开 URL。这些选择当然是相互排斥的。用法示例:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;python -m webbrowser -t &lt;span class=&quot;string&quot;&gt;&quot;https://jeffsui.github.io&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="webbrowser" scheme="https://pinghailinfeng.gitee.io/tags/webbrowser/"/>
    
  </entry>
  
  <entry>
    <title>python standard library csv</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/02/python-standard-library-csv/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/02/python-standard-library-csv/</id>
    <published>2020-01-02T06:33:07.000Z</published>
    <updated>2020-01-07T02:38:24.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库学习之csv"><a href="#python-标准库学习之csv" class="headerlink" title="python 标准库学习之csv"></a>python 标准库学习之<code>csv</code></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2019年立的flag,今年继续,标准库系列文章继续更新。</p><p>今天是真冷啊,屋里头才16℃,只能用一张图来表示我的心情。</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200102_not_cold.jpg?raw=true" alt></p><h2 id="标准库-csv"><a href="#标准库-csv" class="headerlink" title="标准库 csv"></a>标准库 csv</h2><h3 id="文档路径"><a href="#文档路径" class="headerlink" title="文档路径"></a>文档路径</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/csv.html" target="_blank" rel="noopener">python标准库csv</a></p><h3 id="CSV-文件格式"><a href="#CSV-文件格式" class="headerlink" title="CSV 文件格式"></a><code>CSV</code> 文件格式</h3><p>文件扩展名为.csv,通用的电子表格文件格式,经常使用在数据分析中。</p><p>分隔符可能有所差别, python中的csv模块提供了对csv文件的读写操作,非常方便。</p><h3 id="csv-常用方法"><a href="#csv-常用方法" class="headerlink" title="csv 常用方法"></a><code>csv</code> 常用方法</h3><h4 id="csv-reader-csvfile-dialect-39-excel-39-fmtparams"><a href="#csv-reader-csvfile-dialect-39-excel-39-fmtparams" class="headerlink" title="csv.reader(csvfile,dialect=&#39;excel&#39;, ***fmtparams)"></a><code>csv.reader(csvfile,dialect=&#39;excel&#39;, ***fmtparams)</code></h4><blockquote><p>返回一个reader对象,该对象遍历csvfile。csv对象可以是任何对象,只要这个对象支持iteratable协议,并在每次调用<code>__next__()</code>方法时都返回字符串即可。如果csvfile是文件对象,则打开它时应使用<code>newline=&#39;&#39;</code>。可选参数dialect是用于不同的csv文件类型,它可以是 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Dialect" target="_blank" rel="noopener"><code>Dialect</code></a> 类的子类的实例，也可以是 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.list_dialects" target="_blank" rel="noopener"><code>list_dialects()</code></a> 函数返回的字符串之一。完整的解释可以参考<a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv-fmt-params" target="_blank" rel="noopener">csv文件格式参数</a>。</p><p>csv文件的每一行都会默认当做字符串列表解析,除非指定了 <code>QUOTE_NONNUMERIC</code> 格式选项（在这种情况下，未加引号的字段会转换为浮点数），否则不会执行自动数据类型转换。</p></blockquote><p>一个读文件例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> csv</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'eggs.csv'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line"><span class="meta">... </span>    spamreader = csv.reader(csvfile, delimiter=<span class="string">' '</span>, quotechar=<span class="string">'|'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> row <span class="keyword">in</span> spamreader:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">', '</span>.join(row))</span><br><span class="line">Spam, Spam, Spam, Spam, Spam, Baked Beans</span><br><span class="line">Spam, Lovely Spam, Wonderful Spam</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="csv-writer-csvfile-dialect-39-excel-39-fmtparams"><a href="#csv-writer-csvfile-dialect-39-excel-39-fmtparams" class="headerlink" title="csv.writer(csvfile, dialect=&#39;excel&#39;, **fmtparams)"></a><code>csv.writer(csvfile, dialect=&#39;excel&#39;, **fmtparams)</code></h4><blockquote><p>返回一个 writer 对象，该对象负责将用户的数据在给定的文件类对象上转换为带分隔符的字符串。<em>csvfile</em> 可以是具有 <code>write()</code> 方法的任何对象。如果 <em>csvfile</em> 是文件对象，则打开它时应使用 <code>newline=&#39;&#39;</code>。</p><p>为了尽量简化与数据库 API 模块之间的对接，<a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 值会写入为空字符串。虽然这个转换是不可逆的，但它让 SQL 空数据值转储到 CSV 文件更容易，而无需预处理从 <code>cursor.fetch*</code> 调用返回的数据。写入前，所有非字符串数据都先用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a> 转化为字符串再写入。</p></blockquote><p>一个写文件例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'eggs.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    spamwriter = csv.writer(csvfile, delimiter=<span class="string">' '</span>,</span><br><span class="line">                            quotechar=<span class="string">'|'</span>, quoting=csv.QUOTE_MINIMAL)</span><br><span class="line">    spamwriter.writerow([<span class="string">'Spam'</span>] * <span class="number">5</span> + [<span class="string">'Baked Beans'</span>])</span><br><span class="line">    spamwriter.writerow([<span class="string">'Spam'</span>, <span class="string">'Lovely Spam'</span>, <span class="string">'Wonderful Spam'</span>])</span><br></pre></td></tr></table></figure><h4 id="csv-register-dialect-name-dialect-fmtparams"><a href="#csv-register-dialect-name-dialect-fmtparams" class="headerlink" title="csv.register_dialect(name[, dialect[, **fmtparams]])"></a><code>csv.register_dialect(name[, dialect[, **fmtparams]])</code></h4><blockquote><p>将 <em>name</em> 与 <em>dialect</em> 关联起来。<em>name</em> 必须是字符串。要指定变种 (dialect)，可以给出 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Dialect" target="_blank" rel="noopener"><code>Dialect</code></a> 的子类，或给出 <em>fmtparams</em> 关键字参数，或两者都给出（此时关键字参数会覆盖 <em>dialect</em> 参数）。 有关方言和格式设置参数的完整详细信息，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv-fmt-params" target="_blank" rel="noopener">方言格式参数</a> 部分。</p></blockquote><p>其他方法:</p><ul><li><p><code>csv.unregister_dialect(name)</code></p><p>从变种注册表中删除 <em>name</em> 对应的变种。如果 <em>name</em> 不是已注册的变种名称，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Error" target="_blank" rel="noopener"><code>Error</code></a> 异常。</p></li><li><p><code>csv.get_dialect(name)</code></p><p>返回 <em>name</em> 对应的变种。如果 <em>name</em> 不是已注册的变种名称，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Error" target="_blank" rel="noopener"><code>Error</code></a> 异常。该函数返回的是不可变的 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Dialect" target="_blank" rel="noopener"><code>Dialect</code></a> 对象。</p></li><li><p><code>csv.list_dialects()</code></p><p>返回所有已注册变种的名称。</p></li><li><p><code>csv.field_size_limit([new_limit])</code></p><p>返回解析器当前允许的最大字段大小。如果指定了 <em>new_limit</em>，则它将成为新的最大字段大小。</p></li></ul><h3 id="csv模块定义的类"><a href="#csv模块定义的类" class="headerlink" title="csv模块定义的类"></a>csv模块定义的类</h3><h4 id="class-csv-DictReader-f-fieldnames-None-restkey-None-restval-None-dialect-39-excel-39-args-kwds"><a href="#class-csv-DictReader-f-fieldnames-None-restkey-None-restval-None-dialect-39-excel-39-args-kwds" class="headerlink" title="class csv.DictReader(*f*, *fieldnames=None*, *restkey=None*, *restval=None*, *dialect=&#39;excel&#39;*, **args*, ***kwds*)"></a><code>class csv.DictReader(*f*, *fieldnames=None*, *restkey=None*, *restval=None*, *dialect=&#39;excel&#39;*, **args*, ***kwds*)</code></h4><blockquote><p>创建一个对象，该对象在操作上类似于常规 reader，但是将每行中的信息映射到一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>，该 dict 的键由 <em>fieldnames</em> 可选参数给出。</p><p><em>fieldnames</em> 参数是一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-sequence" target="_blank" rel="noopener">sequence</a>。如果省略 <em>fieldnames</em>，则文件 <em>f</em> 第一行中的值将用作字段名。无论字段名是如何确定的，字典都将保留其原始顺序。</p><p>如果某一行中的字段多于字段名，则其余字段将放入列表中，字段名由 <em>restkey</em> 指定（默认为 <code>None</code>）。如果非空白行的字段少于字段名，则缺少的值将用 <code>None</code> 填充。</p><p>所有其他可选或关键字参数都传递给底层的 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.reader" target="_blank" rel="noopener"><code>reader</code></a> 实例。</p><p>3.8 中,返回的行是 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 类型。</p></blockquote><p>一个使用<code>DictReader</code>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> csv</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'names.csv'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line"><span class="meta">... </span>    reader = csv.DictReader(csvfile)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line"><span class="meta">... </span>        print(row[<span class="string">'first_name'</span>], row[<span class="string">'last_name'</span>])</span><br><span class="line">...</span><br><span class="line">Eric Idle</span><br><span class="line">John Cleese</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(row)</span><br><span class="line">&#123;<span class="string">'first_name'</span>: <span class="string">'John'</span>, <span class="string">'last_name'</span>: <span class="string">'Cleese'</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="class-csv-DictWriter-f-fieldnames-restval-39-39-extrasaction-39-raise-39-dialect-39-excel-39-args-kwds"><a href="#class-csv-DictWriter-f-fieldnames-restval-39-39-extrasaction-39-raise-39-dialect-39-excel-39-args-kwds" class="headerlink" title="class csv.DictWriter(f, fieldnames, restval=&#39;&#39;, extrasaction=&#39;raise&#39;, dialect=&#39;excel&#39;, **args, **kwds)"></a><code>class csv.DictWriter(f, fieldnames, restval=&#39;&#39;, extrasaction=&#39;raise&#39;, dialect=&#39;excel&#39;, **args, **kwds)</code></h4><blockquote><p>创建一个对象，该对象在操作上类似常规 writer，但会将字典映射到输出行。 <em>fieldnames</em> 参数是由键组成的 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#module-collections.abc" target="_blank" rel="noopener"><code>序列</code></a>，它指定字典中值的顺序，这些值会按指定顺序传递给 <code>writerow()</code> 方法并写入文件 <em>f</em>。 如果字典缺少 <em>fieldnames</em> 中的键，则可选参数 <em>restval</em> 用于指定要写入的值。 如果传递给 <code>writerow()</code> 方法的字典的某些键在 <em>fieldnames</em> 中找不到，则可选参数 <em>extrasaction</em> 用于指定要执行的操作。 如果将其设置为默认值 <code>&#39;raise&#39;</code>，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。 如果将其设置为 <code>&#39;ignore&#39;</code>，则字典中的其他键值将被忽略。 所有其他可选或关键字参数都传递给底层的 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.writer" target="_blank" rel="noopener"><code>writer</code></a> 实例。</p><p>注意，与 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.DictReader" target="_blank" rel="noopener"><code>DictReader</code></a> 类不同，<a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.DictWriter" target="_blank" rel="noopener"><code>DictWriter</code></a> 类的 <em>fieldnames</em> 参数不是可选参数</p></blockquote><p>一个使用<code>DictWriter</code>写入文件例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'names.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    fieldnames = [<span class="string">'first_name'</span>, <span class="string">'last_name'</span>]</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line"></span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerow(&#123;<span class="string">'first_name'</span>: <span class="string">'Baked'</span>, <span class="string">'last_name'</span>: <span class="string">'Beans'</span>&#125;)</span><br><span class="line">    writer.writerow(&#123;<span class="string">'first_name'</span>: <span class="string">'Lovely'</span>, <span class="string">'last_name'</span>: <span class="string">'Spam'</span>&#125;)</span><br><span class="line">    writer.writerow(&#123;<span class="string">'first_name'</span>: <span class="string">'Wonderful'</span>, <span class="string">'last_name'</span>: <span class="string">'Spam'</span>&#125;)</span><br></pre></td></tr></table></figure><p>其他方法:</p><ul><li><p><em>class</em> <code>csv.Dialect</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Dialect" target="_blank" rel="noopener"><code>Dialect</code></a> 类是主要依赖于其属性的容器类，用于将定义好的参数传递给特定的 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.reader" target="_blank" rel="noopener"><code>reader</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.writer" target="_blank" rel="noopener"><code>writer</code></a> 实例。</p></li><li><p><em>class</em> <code>csv.excel</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.excel" target="_blank" rel="noopener"><code>excel</code></a> 类定义了 Excel 生成的 CSV 文件的常规属性。它在变种注册表中的名称是 <code>&#39;excel&#39;</code>。</p></li><li><p><em>class</em> <code>csv.excel_tab</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.excel_tab" target="_blank" rel="noopener"><code>excel_tab</code></a> 类定义了 Excel 生成的、制表符分隔的 CSV 文件的常规属性。它在变种注册表中的名称是 <code>&#39;excel-tab&#39;</code>。</p></li><li><p><em>class</em> <code>csv.unix_dialect</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.unix_dialect" target="_blank" rel="noopener"><code>unix_dialect</code></a> 类定义了在 UNIX 系统上生成的 CSV 文件的常规属性，即使用 <code>&#39;\n&#39;</code> 作为换行符，且所有字段都有引号包围。它在变种注册表中的名称是 <code>&#39;unix&#39;</code>。</p></li></ul><h4 id="class-csv-Sniffer"><a href="#class-csv-Sniffer" class="headerlink" title="class csv.Sniffer"></a><code>class csv.Sniffer</code></h4><p><a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Sniffer" target="_blank" rel="noopener"><code>Sniffer</code></a> 类用于推断 CSV 文件的格式。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Sniffer" target="_blank" rel="noopener"><code>Sniffer</code></a> 类提供了两个方法：</p><ul><li><p><code>sniff</code>(<em>sample</em>, <em>delimiters=None</em>)</p><p>分析给定的 <em>sample</em> 并返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Dialect" target="_blank" rel="noopener"><code>Dialect</code></a> 子类，该子类中包含了分析出的格式参数。如果给出可选的 <em>delimiters</em> 参数，则该参数会被解释为字符串，该字符串包含了可能的有效定界符。</p></li><li><p><code>has_header</code>(<em>sample</em>)</p><p>分析示例文本（假定为 CSV 格式），如果第一行很可能是一系列列标题，则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>。</p></li></ul><p>一个使用Sniffer的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'example.csv'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    dialect = csv.Sniffer().sniff(csvfile.read(<span class="number">1024</span>))</span><br><span class="line">    csvfile.seek(<span class="number">0</span>)</span><br><span class="line">    reader = csv.reader(csvfile, dialect)</span><br><span class="line">    <span class="comment"># ... process CSV file contents here ...</span></span><br></pre></td></tr></table></figure><h3 id="csv-中定义的常量"><a href="#csv-中定义的常量" class="headerlink" title="csv 中定义的常量"></a>csv 中定义的常量</h3><ul><li><p><code>csv.QUOTE_ALL</code></p><p>指示 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.writer" target="_blank" rel="noopener"><code>writer</code></a> 对象给所有字段加上引号。</p></li><li><p><code>csv.QUOTE_MINIMAL</code></p><p>指示 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.writer" target="_blank" rel="noopener"><code>writer</code></a> 对象仅为包含特殊字符（例如 <em>定界符</em>、<em>引号字符</em> 或 <em>行结束符</em> 中的任何字符）的字段加上引号。</p></li><li><p><code>csv.QUOTE_NONNUMERIC</code></p><p>指示 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.writer" target="_blank" rel="noopener"><code>writer</code></a> 对象为所有非数字字段加上引号。指示 reader 将所有未用引号引出的字段转换为 <em>float</em> 类型。</p></li><li><p><code>csv.QUOTE_NONE</code></p><p>指示 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.writer" target="_blank" rel="noopener"><code>writer</code></a> 对象不使用引号引出字段。当 <em>定界符</em> 出现在输出数据中时，其前面应该有 <em>转义符</em>。如果未设置 <em>转义符</em>，则遇到任何需要转义的字符时，writer 都会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Error" target="_blank" rel="noopener"><code>Error</code></a> 异常。指示 <a href="https://docs.python.org/zh-cn/3.8/library/csv.html#csv.reader" target="_blank" rel="noopener"><code>reader</code></a> 不对引号字符进行特殊处理。</p></li></ul><h3 id="csv模块定义了以下异常："><a href="#csv模块定义了以下异常：" class="headerlink" title="csv模块定义了以下异常："></a><code>csv</code>模块定义了以下异常：</h3><ul><li><p><em>exception</em> <code>csv.Error</code></p><p>该异常可能由任何发生错误的函数抛出。</p></li></ul><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>如果没有指定 <code>newline=&#39;&#39;</code>，则嵌入引号中的换行符将无法正确解析，并且在写入时，使用 <code>\r\n</code> 换行的平台会有多余的 <code>\r</code> 写入。由于 csv 模块会执行自己的（<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-universal-newlines" target="_blank" rel="noopener">通用</a>）换行符处理，因此指定 <code>newline=&#39;&#39;</code> 应该总是安全的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>csv模块是一个非常实用的处理csv文件的标准库，提供了两种处理方法。</p><p>一个是把csv文件对象当作字符串列表解析csv文件的方法,<code>reader</code>， <code>writer</code>，</p><p>另一个是把csv文件对象当作字典解析的类<code>dictReader</code>, <code>dictWriter</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库学习之csv&quot;&gt;&lt;a href=&quot;#python-标准库学习之csv&quot; class=&quot;headerlink&quot; title=&quot;python 标准库学习之csv&quot;&gt;&lt;/a&gt;python 标准库学习之&lt;code&gt;csv&lt;/code&gt;&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2019年立的flag,今年继续,标准库系列文章继续更新。&lt;/p&gt;
&lt;p&gt;今天是真冷啊,屋里头才16℃,只能用一张图来表示我的心情。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200102_not_cold.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;标准库-csv&quot;&gt;&lt;a href=&quot;#标准库-csv&quot; class=&quot;headerlink&quot; title=&quot;标准库 csv&quot;&gt;&lt;/a&gt;标准库 csv&lt;/h2&gt;&lt;h3 id=&quot;文档路径&quot;&gt;&lt;a href=&quot;#文档路径&quot; class=&quot;headerlink&quot; title=&quot;文档路径&quot;&gt;&lt;/a&gt;文档路径&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/csv.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;python标准库csv&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;CSV-文件格式&quot;&gt;&lt;a href=&quot;#CSV-文件格式&quot; class=&quot;headerlink&quot; title=&quot;CSV 文件格式&quot;&gt;&lt;/a&gt;&lt;code&gt;CSV&lt;/code&gt; 文件格式&lt;/h3&gt;&lt;p&gt;文件扩展名为.csv,通用的电子表格文件格式,经常使用在数据分析中。&lt;/p&gt;
&lt;p&gt;分隔符可能有所差别, python中的csv模块提供了对csv文件的读写操作,非常方便。&lt;/p&gt;
&lt;h3 id=&quot;csv-常用方法&quot;&gt;&lt;a href=&quot;#csv-常用方法&quot; class=&quot;headerlink&quot; title=&quot;csv 常用方法&quot;&gt;&lt;/a&gt;&lt;code&gt;csv&lt;/code&gt; 常用方法&lt;/h3&gt;&lt;h4 id=&quot;csv-reader-csvfile-dialect-39-excel-39-fmtparams&quot;&gt;&lt;a href=&quot;#csv-reader-csvfile-dialect-39-excel-39-fmtparams&quot; class=&quot;headerlink&quot; title=&quot;csv.reader(csvfile,dialect=&amp;#39;excel&amp;#39;, ***fmtparams)&quot;&gt;&lt;/a&gt;&lt;code&gt;csv.reader(csvfile,dialect=&amp;#39;excel&amp;#39;, ***fmtparams)&lt;/code&gt;&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;返回一个reader对象,该对象遍历csvfile。csv对象可以是任何对象,只要这个对象支持iteratable协议,并在每次调用&lt;code&gt;__next__()&lt;/code&gt;方法时都返回字符串即可。如果csvfile是文件对象,则打开它时应使用&lt;code&gt;newline=&amp;#39;&amp;#39;&lt;/code&gt;。可选参数dialect是用于不同的csv文件类型,它可以是 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/csv.html#csv.Dialect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Dialect&lt;/code&gt;&lt;/a&gt; 类的子类的实例，也可以是 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/csv.html#csv.list_dialects&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;list_dialects()&lt;/code&gt;&lt;/a&gt; 函数返回的字符串之一。完整的解释可以参考&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/csv.html#csv-fmt-params&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;csv文件格式参数&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;csv文件的每一行都会默认当做字符串列表解析,除非指定了 &lt;code&gt;QUOTE_NONNUMERIC&lt;/code&gt; 格式选项（在这种情况下，未加引号的字段会转换为浮点数），否则不会执行自动数据类型转换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个读文件例子&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; csv&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; open(&lt;span class=&quot;string&quot;&gt;&#39;eggs.csv&#39;&lt;/span&gt;, newline=&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; csvfile:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    spamreader = csv.reader(csvfile, delimiter=&lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;, quotechar=&lt;span class=&quot;string&quot;&gt;&#39;|&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; row &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; spamreader:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;        print(&lt;span class=&quot;string&quot;&gt;&#39;, &#39;&lt;/span&gt;.join(row))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Spam, Spam, Spam, Spam, Spam, Baked Beans&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Spam, Lovely Spam, Wonderful Spam&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="csv" scheme="https://pinghailinfeng.gitee.io/tags/csv/"/>
    
  </entry>
  
  <entry>
    <title>using python venv to create virtual environment</title>
    <link href="https://pinghailinfeng.gitee.io/2019/12/26/using-python-venv-to-create-virtual-environment/"/>
    <id>https://pinghailinfeng.gitee.io/2019/12/26/using-python-venv-to-create-virtual-environment/</id>
    <published>2019-12-26T03:17:57.000Z</published>
    <updated>2020-01-02T08:27:36.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-env-创建虚拟环境"><a href="#python-env-创建虚拟环境" class="headerlink" title="python env 创建虚拟环境"></a>python env 创建虚拟环境</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又断更了,长此以往,我可能无法完成100天打卡任务了。</p><p>红包是刺激自己前进的动力。</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20191223_blog_3.jpg?raw=true" alt></p><h2 id="python-标准库03之虚拟环境创建"><a href="#python-标准库03之虚拟环境创建" class="headerlink" title="python 标准库03之虚拟环境创建"></a>python 标准库03之虚拟环境创建</h2><p><a href="https://docs.python.org/zh-cn/3/library/venv.html" target="_blank" rel="noopener">参考文档</a></p><p>python目前官方推荐的工具是<code>venv</code></p><p>顺便介绍下目前常用的python虚拟环境工具</p><ul><li>virsualenv</li><li>pyvenv (3.3,3.4中推荐的虚拟环境创建工具,3.6中被弃用)</li><li>venv(3.6以后推荐的虚拟环境创建工具)</li></ul><a id="more"></a><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><p>使用下面的命令创建一个虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv /path/to/new/virtual/environment</span><br></pre></td></tr></table></figure><p>windows下使用venv来创建虚拟环境</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\&gt;c:\Python35\python -m venv c:\path\to\myenv</span><br></pre></td></tr></table></figure><p>使用<code>-h</code>参数可以查看<code>venv</code>命令行的帮助文档</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear]</span><br><span class="line">            [--upgrade] [--without-pip] [--prompt PROMPT]</span><br><span class="line">            ENV_DIR [ENV_DIR ...]</span><br><span class="line"></span><br><span class="line">Creates virtual Python environments <span class="keyword">in</span> one or more target directories.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  ENV_DIR               A directory to create the environment in.</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and <span class="keyword">exit</span></span><br><span class="line">  --system-site-packages</span><br><span class="line">                        Give the virtual environment access to the system</span><br><span class="line">                        site-packages dir.</span><br><span class="line">  --symlinks            <span class="keyword">Try</span> to use symlinks rather than copies, when symlinks</span><br><span class="line">                        are not the default <span class="keyword">for</span> the platform.</span><br><span class="line">  --copies              <span class="keyword">Try</span> to use copies rather than symlinks, even when</span><br><span class="line">                        symlinks are the default <span class="keyword">for</span> the platform.</span><br><span class="line">  --clear               Delete the contents of the environment directory <span class="keyword">if</span> it</span><br><span class="line">                        already exists, before environment creation.</span><br><span class="line">  --upgrade             Upgrade the environment directory to use this version</span><br><span class="line">                        of Python, assuming Python has been upgraded in-place.</span><br><span class="line">  --without-pip         Skips installing or upgrading pip <span class="keyword">in</span> the virtual</span><br><span class="line">                        environment (pip is bootstrapped by default)</span><br><span class="line">  --prompt PROMPT       Provides an alternative prompt prefix <span class="keyword">for</span> this</span><br><span class="line">                        environment.</span><br></pre></td></tr></table></figure><p>除非你使用了<code>--without-pip</code> 参数,否则 <a href="https://docs.python.org/zh-cn/3/library/ensurepip.html#module-ensurepip" target="_blank" rel="noopener">ensurepip</a> 模块会默认安装<code>pip</code>指令到创建好的虚拟环境中。</p><p>一旦一个虚拟环境被创建，可以通过下面的命令激活这个虚拟环境。不同平台下的激活方式略有不同,下面总结了各个平台下虚拟环境的激活命令脚本,请参考。</p><h3 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h3><table><thead><tr><th>平台</th><th>Shell</th><th>用于激活虚拟环境的命令</th></tr></thead><tbody><tr><td>POSIX</td><td>bash/zsh</td><td>$ source <venv>/bin/activate</venv></td></tr><tr><td></td><td>fish</td><td>$ . <venv>/bin/activate.fish</venv></td></tr><tr><td></td><td>csh/tcsh</td><td>$ source <venv>/bin/activate.csh</venv></td></tr><tr><td></td><td>PowerShell Core</td><td>$ <venv>/bin/Activate.ps1</venv></td></tr><tr><td>Windows</td><td>cmd.exe</td><td>C:> <venv>\Scripts\activate.bat</venv></td></tr><tr><td></td><td>PowerShell</td><td>PS C:> <venv>\Scripts\Activate.ps1</venv></td></tr></tbody></table><p>You don’t specifically <em>need</em> to activate an environment; activation just prepends the virtual environment’s binary directory to your path, so that “python” invokes the virtual environment’s Python interpreter and you can run installed scripts without having to use their full path. However, all scripts installed in a virtual environment should be runnable without activating it, and run with the virtual environment’s Python automatically.</p><p>You can deactivate a virtual environment by typing “deactivate” in your shell. The exact mechanism is platform-specific and is an internal implementation detail (typically a script or shell function will be used).</p><p>你无需关心如何激活一个虚拟环境；使用相对于项目当前路径下的可执行方法,python解析器就可以激活虚拟环境。已经激活的虚拟环境, 就可以使用python的命令直接执行脚本或者安装其他软件包到当前的虚拟环境，而不需要关心是否会污染本地python环境的问题。同样，使用deactivate 就可以退出当前的虚拟环境。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>下面展示的是一个使用<code>EnvBuilder</code> 创建一个自定义虚拟环境的脚本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class venv.EnvBuilder(system_site_packages=False, clear=False, symlinks=False, upgrade=False, with_pip=False, prompt=None)</span><br></pre></td></tr></table></figure><ul><li><p><code>create</code>(<em>env_dir</em>)</p><ul><li><code>system_site_packages</code> – 一个Boolean值,是否将<code>site-packages</code>添加到虚拟环境中 默认是False.</li><li><code>clear</code> – 一个Boolean值,如果为真,将会在创建环境之前清除已经存在的目标路径.</li><li><code>symlinks</code> – 一个Boolean值,如果为真,将会在创建环境前删除包含内容的目录  </li><li><code>upgrade</code> –  一个Boolean值,如果为真, 则将用正在运行的Python升级现有环境 - 用于在Python就地升级（默认为False）时使用。.</li><li><code>with_pip</code> – 一个Boolean值,如果为真,pip命令将会安装到虚拟环境中 ,使用 <a href="https://docs.python.org/zh-cn/3/library/ensurepip.html#module-ensurepip" target="_blank" rel="noopener"><code>ensurepip</code></a> 的默认 <code>--default-pip</code> 参数选项.</li><li><code>prompt</code> – 在激活虚拟环境后使用的字符串（默认为None表示将使用环境的目录名称）。.</li></ul></li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, env_dir)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create a virtualized Python environment in a directory.</span></span><br><span class="line"><span class="string">    env_dir is the target directory to create an environment in.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    env_dir = os.path.abspath(env_dir)</span><br><span class="line">    context = self.ensure_directories(env_dir)</span><br><span class="line">    self.create_configuration(context)</span><br><span class="line">    self.setup_python(context)</span><br><span class="line">    self.setup_scripts(context)</span><br><span class="line">    self.post_setup(context)</span><br></pre></td></tr></table></figure><ul><li><p><code>ensure_directories</code>(<em>env_dir</em>)  </p><blockquote><p>创建环境目录和所有必需的目录，并返回一个上下文对象。这只是属性（如路径）的<br>持有者，供其他方法使用。这些目录已被允许存在，只要其中一个clear或被upgrade<br>指定为允许在现有环境目录上进行操作即可。</p></blockquote></li><li><p><code>create_configuration</code>(<em>context</em>) </p><blockquote><p>pyvenv.cfg在环境中创建配置文件。</p></blockquote></li><li><p><code>setup_python</code>(<em>context</em>) </p><blockquote><p>在环境中创建Python可执行文件（以及Windows下的DLL）的副本。在POSIX系统<br>中，如果一个特定的可执行文件 python3.x使用，符号链接python和python3将创建指<br>向该可执行文件，除非已存在具有这些名称的文件。</p></blockquote></li><li><p><code>setup_scripts</code>(<em>context</em>) </p><blockquote><p>将适合该平台的激活脚本安装到虚拟环境中。</p></blockquote></li><li><p><code>post_setup</code>(<em>context</em>)</p><blockquote><p>一种占位符方法，可以在第三方实现中重写，以在虚拟环境中预安装包或执行其他后<br>创建步骤。</p></blockquote><p>此外，EnvBuilder提供这种工具方法，可以从被称为setup_scripts()或post_setup()在子<br>类中，以协助安装自定义脚本到虚拟环境中。<br>install_scripts（上下文，路径）<br>路径是应包含子目录“common”，“posix”，“nt”的目录的路径，每个目录都包含指向环<br>境中bin目录的脚本。os.name经过一些文本替换占位符后，“common”的内容和相应的<br>目录被复制：</p><ul><li><p><code>__VENV_DIR__</code> 被替换为环境目录的绝对路径。</p></li><li><p><code>__VENV_NAME__</code> 被替换为环境名称（环境目录的最终路径段）。</p></li><li><p><code>__VENV_PROMPT__</code> 被提示符替换（环境名称由括号括起来，并带有下面的空格）</p></li><li><p><code>__VENV_BIN_NAME__</code>被替换为bin目录的名称（bin或者Scripts）。</p></li><li><p><code>__VENV_PYTHON__</code>被替换为环境可执行文件的绝对路径。<br>允许目录存在（用于在现有环境正在升级时）。</p><p>还有一个模块级的便利功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">venv.create（env_dir，system_site_packages = False，clear = False，symlinks =</span><br><span class="line">False，with_pip = False ）</span><br></pre></td></tr></table></figure><p><code>EnvBuilder</code>用给定的关键字参数创建一个参数，并调用create()并使用<code>env_dir</code>参数。</p></li></ul></li></ul><h3 id="一个扩展EnvBuilder例子"><a href="#一个扩展EnvBuilder例子" class="headerlink" title="一个扩展EnvBuilder例子"></a>一个扩展<code>EnvBuilder</code>例子</h3><p>以下脚本展示了如何<code>EnvBuilder</code>通过实现将<code>setuptools</code>和<code>pip</code>安装到创建的虚拟环境中的子类来进行扩展：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen, PIPE</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"><span class="keyword">import</span> venv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedEnvBuilder</span><span class="params">(venv.EnvBuilder)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    This builder installs setuptools and pip so that you can pip or</span></span><br><span class="line"><span class="string">    easy_install other packages into the created virtual environment.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param nodist: If true, setuptools and pip are not installed into the</span></span><br><span class="line"><span class="string">                   created virtual environment.</span></span><br><span class="line"><span class="string">    :param nopip: If true, pip is not installed into the created</span></span><br><span class="line"><span class="string">                  virtual environment.</span></span><br><span class="line"><span class="string">    :param progress: If setuptools or pip are installed, the progress of the</span></span><br><span class="line"><span class="string">                     installation can be monitored by passing a progress</span></span><br><span class="line"><span class="string">                     callable. If specified, it is called with two</span></span><br><span class="line"><span class="string">                     arguments: a string indicating some progress, and a</span></span><br><span class="line"><span class="string">                     context indicating where the string is coming from.</span></span><br><span class="line"><span class="string">                     The context argument can have one of three values:</span></span><br><span class="line"><span class="string">                     'main', indicating that it is called from virtualize()</span></span><br><span class="line"><span class="string">                     itself, and 'stdout' and 'stderr', which are obtained</span></span><br><span class="line"><span class="string">                     by reading lines from the output streams of a subprocess</span></span><br><span class="line"><span class="string">                     which is used to install the app.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     If a callable is not specified, default progress</span></span><br><span class="line"><span class="string">                     information is output to sys.stderr.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.nodist = kwargs.pop(<span class="string">'nodist'</span>, <span class="literal">False</span>)</span><br><span class="line">        self.nopip = kwargs.pop(<span class="string">'nopip'</span>, <span class="literal">False</span>)</span><br><span class="line">        self.progress = kwargs.pop(<span class="string">'progress'</span>, <span class="literal">None</span>)</span><br><span class="line">        self.verbose = kwargs.pop(<span class="string">'verbose'</span>, <span class="literal">False</span>)</span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_setup</span><span class="params">(self, context)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Set up any packages which need to be pre-installed into the</span></span><br><span class="line"><span class="string">        virtual environment being created.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param context: The information for the virtual environment</span></span><br><span class="line"><span class="string">                        creation request being processed.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        os.environ[<span class="string">'VIRTUAL_ENV'</span>] = context.env_dir</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.nodist:</span><br><span class="line">            self.install_setuptools(context)</span><br><span class="line">        <span class="comment"># Can't install pip without setuptools</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.nopip <span class="keyword">and</span> <span class="keyword">not</span> self.nodist:</span><br><span class="line">            self.install_pip(context)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">(self, stream, context)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Read lines from a subprocess' output stream and either pass to a progress</span></span><br><span class="line"><span class="string">        callable (if specified) or write progress information to sys.stderr.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        progress = self.progress</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            s = stream.readline()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> progress <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                progress(s, context)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.verbose:</span><br><span class="line">                    sys.stderr.write(<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sys.stderr.write(s.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">                sys.stderr.flush()</span><br><span class="line">        stream.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">install_script</span><span class="params">(self, context, name, url)</span>:</span></span><br><span class="line">        _, _, path, _, _, _ = urlparse(url)</span><br><span class="line">        fn = os.path.split(path)[<span class="number">-1</span>]</span><br><span class="line">        binpath = context.bin_path</span><br><span class="line">        distpath = os.path.join(binpath, fn)</span><br><span class="line">        <span class="comment"># Download script into the virtual environment's binaries folder</span></span><br><span class="line">        urlretrieve(url, distpath)</span><br><span class="line">        progress = self.progress</span><br><span class="line">        <span class="keyword">if</span> self.verbose:</span><br><span class="line">            term = <span class="string">'\n'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            term = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> progress <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            progress(<span class="string">'Installing %s ...%s'</span> % (name, term), <span class="string">'main'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sys.stderr.write(<span class="string">'Installing %s ...%s'</span> % (name, term))</span><br><span class="line">            sys.stderr.flush()</span><br><span class="line">        <span class="comment"># Install in the virtual environment</span></span><br><span class="line">        args = [context.env_exe, fn]</span><br><span class="line">        p = Popen(args, stdout=PIPE, stderr=PIPE, cwd=binpath)</span><br><span class="line">        t1 = Thread(target=self.reader, args=(p.stdout, <span class="string">'stdout'</span>))</span><br><span class="line">        t1.start()</span><br><span class="line">        t2 = Thread(target=self.reader, args=(p.stderr, <span class="string">'stderr'</span>))</span><br><span class="line">        t2.start()</span><br><span class="line">        p.wait()</span><br><span class="line">        t1.join()</span><br><span class="line">        t2.join()</span><br><span class="line">        <span class="keyword">if</span> progress <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            progress(<span class="string">'done.'</span>, <span class="string">'main'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sys.stderr.write(<span class="string">'done.\n'</span>)</span><br><span class="line">        <span class="comment"># Clean up - no longer needed</span></span><br><span class="line">        os.unlink(distpath)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">install_setuptools</span><span class="params">(self, context)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Install setuptools in the virtual environment.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param context: The information for the virtual environment</span></span><br><span class="line"><span class="string">                        creation request being processed.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        url = <span class="string">'https://bitbucket.org/pypa/setuptools/downloads/ez_setup.py'</span></span><br><span class="line">        self.install_script(context, <span class="string">'setuptools'</span>, url)</span><br><span class="line">        <span class="comment"># clear up the setuptools archive which gets downloaded</span></span><br><span class="line">        pred = <span class="keyword">lambda</span> o: o.startswith(<span class="string">'setuptools-'</span>) <span class="keyword">and</span> o.endswith(<span class="string">'.tar.gz'</span>)</span><br><span class="line">        files = filter(pred, os.listdir(context.bin_path))</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">            f = os.path.join(context.bin_path, f)</span><br><span class="line">            os.unlink(f)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">install_pip</span><span class="params">(self, context)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Install pip in the virtual environment.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param context: The information for the virtual environment</span></span><br><span class="line"><span class="string">                        creation request being processed.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        url = <span class="string">'https://raw.github.com/pypa/pip/master/contrib/get-pip.py'</span></span><br><span class="line">        self.install_script(context, <span class="string">'pip'</span>, url)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(args=None)</span>:</span></span><br><span class="line">    compatible = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> sys.version_info &lt; (<span class="number">3</span>, <span class="number">3</span>):</span><br><span class="line">        compatible = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> hasattr(sys, <span class="string">'base_prefix'</span>):</span><br><span class="line">        compatible = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> compatible:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'This script is only for use with '</span></span><br><span class="line">                         <span class="string">'Python 3.3 or later'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">        parser = argparse.ArgumentParser(prog=__name__,</span><br><span class="line">                                         description=<span class="string">'Creates virtual Python '</span></span><br><span class="line">                                                     <span class="string">'environments in one or '</span></span><br><span class="line">                                                     <span class="string">'more target '</span></span><br><span class="line">                                                     <span class="string">'directories.'</span>)</span><br><span class="line">        parser.add_argument(<span class="string">'dirs'</span>, metavar=<span class="string">'ENV_DIR'</span>, nargs=<span class="string">'+'</span>,</span><br><span class="line">                            help=<span class="string">'A directory in which to create the</span></span><br><span class="line"><span class="string">                                 '</span>virtual environment.<span class="string">')</span></span><br><span class="line"><span class="string">        parser.add_argument('</span>--no-setuptools<span class="string">', default=False,</span></span><br><span class="line"><span class="string">                            action='</span>store_true<span class="string">', dest='</span>nodist<span class="string">',</span></span><br><span class="line"><span class="string">                            help="Don'</span>t install setuptools <span class="keyword">or</span> pip <span class="keyword">in</span> the <span class="string">"</span></span><br><span class="line"><span class="string">                                 "</span>virtual environment.<span class="string">")</span></span><br><span class="line"><span class="string">        parser.add_argument('--no-pip', default=False,</span></span><br><span class="line"><span class="string">                            action='store_true', dest='nopip',</span></span><br><span class="line"><span class="string">                            help="</span>Don<span class="string">'t install pip in the virtual "</span></span><br><span class="line"><span class="string">                                 "environment.")</span></span><br><span class="line"><span class="string">        parser.add_argument('</span>--system-site-packages<span class="string">', default=False,</span></span><br><span class="line"><span class="string">                            action='</span>store_true<span class="string">', dest='</span>system_site<span class="string">',</span></span><br><span class="line"><span class="string">                            help='</span>Give the virtual environment access to the <span class="string">'</span></span><br><span class="line"><span class="string">                                 '</span>system site-packages dir.<span class="string">')</span></span><br><span class="line"><span class="string">        if os.name == '</span>nt<span class="string">':</span></span><br><span class="line"><span class="string">            use_symlinks = False</span></span><br><span class="line"><span class="string">        else:</span></span><br><span class="line"><span class="string">            use_symlinks = True</span></span><br><span class="line"><span class="string">        parser.add_argument('</span>--symlinks<span class="string">', default=use_symlinks,</span></span><br><span class="line"><span class="string">                            action='</span>store_true<span class="string">', dest='</span>symlinks<span class="string">',</span></span><br><span class="line"><span class="string">                            help='</span>Try to use symlinks rather than copies, <span class="string">'</span></span><br><span class="line"><span class="string">                                 '</span>when symlinks are <span class="keyword">not</span> the default <span class="keyword">for</span> <span class="string">'</span></span><br><span class="line"><span class="string">                                 '</span>the platform.<span class="string">')</span></span><br><span class="line"><span class="string">        parser.add_argument('</span>--clea<span class="string">r', default=False, action='</span>store_true<span class="string">',</span></span><br><span class="line"><span class="string">                            dest='</span>clea<span class="string">r', help='</span>Delete the contents of the <span class="string">'</span></span><br><span class="line"><span class="string">                                               '</span>virtual environment <span class="string">'</span></span><br><span class="line"><span class="string">                                               '</span>directory <span class="keyword">if</span> it already <span class="string">'</span></span><br><span class="line"><span class="string">                                               '</span>exists, before virtual <span class="string">'</span></span><br><span class="line"><span class="string">                                               '</span>environment creation.<span class="string">')</span></span><br><span class="line"><span class="string">        parser.add_argument('</span>--upgrade<span class="string">', default=False, action='</span>store_true<span class="string">',</span></span><br><span class="line"><span class="string">                            dest='</span>upgrade<span class="string">', help='</span>Upgrade the virtual <span class="string">'</span></span><br><span class="line"><span class="string">                                                 '</span>environment directory to <span class="string">'</span></span><br><span class="line"><span class="string">                                                 '</span>use this version of <span class="string">'</span></span><br><span class="line"><span class="string">                                                 '</span>Python, assuming Python <span class="string">'</span></span><br><span class="line"><span class="string">                                                 '</span>has been upgraded <span class="string">'</span></span><br><span class="line"><span class="string">                                                 '</span><span class="keyword">in</span>-place.<span class="string">')</span></span><br><span class="line"><span class="string">        parser.add_argument('</span>--verbose<span class="string">', default=False, action='</span>store_true<span class="string">',</span></span><br><span class="line"><span class="string">                            dest='</span>verbose<span class="string">', help='</span>Display the output <span class="string">'</span></span><br><span class="line"><span class="string">                                               '</span><span class="keyword">from</span> the scripts which <span class="string">'</span></span><br><span class="line"><span class="string">                                               '</span>install setuptools <span class="keyword">and</span> pip.<span class="string">')</span></span><br><span class="line"><span class="string">        options = parser.parse_args(args)</span></span><br><span class="line"><span class="string">        if options.upgrade and options.clear:</span></span><br><span class="line"><span class="string">            raise ValueError('</span>you cannot supply --upgrade <span class="keyword">and</span> --clear together.<span class="string">')</span></span><br><span class="line"><span class="string">        builder = ExtendedEnvBuilder(system_site_packages=options.system_site,</span></span><br><span class="line"><span class="string">                                       clear=options.clear,</span></span><br><span class="line"><span class="string">                                       symlinks=options.symlinks,</span></span><br><span class="line"><span class="string">                                       upgrade=options.upgrade,</span></span><br><span class="line"><span class="string">                                       nodist=options.nodist,</span></span><br><span class="line"><span class="string">                                       nopip=options.nopip,</span></span><br><span class="line"><span class="string">                                       verbose=options.verbose)</span></span><br><span class="line"><span class="string">        for d in options.dirs:</span></span><br><span class="line"><span class="string">            builder.create(d)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ == '</span>__main__<span class="string">':</span></span><br><span class="line"><span class="string">    rc = 1</span></span><br><span class="line"><span class="string">    try:</span></span><br><span class="line"><span class="string">        main()</span></span><br><span class="line"><span class="string">        rc = 0</span></span><br><span class="line"><span class="string">    except Exception as e:</span></span><br><span class="line"><span class="string">        print('</span>Error: %s<span class="string">' % e, file=sys.stderr)</span></span><br><span class="line"><span class="string">    sys.exit(rc)</span></span><br></pre></td></tr></table></figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在windows下<code>vscode</code>中通过venv 创建虚拟环境步骤:</p><ol><li><p><code>powershell</code>下,执行命令 <code>python -m venv .venv</code></p></li><li><p>执行激活命令 <code>.\Scripts\activate.ps1</code></p></li><li><p>退出虚拟环境  在项目目录下执行<code>deactivate</code> 即可。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-env-创建虚拟环境&quot;&gt;&lt;a href=&quot;#python-env-创建虚拟环境&quot; class=&quot;headerlink&quot; title=&quot;python env 创建虚拟环境&quot;&gt;&lt;/a&gt;python env 创建虚拟环境&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;又断更了,长此以往,我可能无法完成100天打卡任务了。&lt;/p&gt;
&lt;p&gt;红包是刺激自己前进的动力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20191223_blog_3.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;python-标准库03之虚拟环境创建&quot;&gt;&lt;a href=&quot;#python-标准库03之虚拟环境创建&quot; class=&quot;headerlink&quot; title=&quot;python 标准库03之虚拟环境创建&quot;&gt;&lt;/a&gt;python 标准库03之虚拟环境创建&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3/library/venv.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;python目前官方推荐的工具是&lt;code&gt;venv&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;顺便介绍下目前常用的python虚拟环境工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;virsualenv&lt;/li&gt;
&lt;li&gt;pyvenv (3.3,3.4中推荐的虚拟环境创建工具,3.6中被弃用)&lt;/li&gt;
&lt;li&gt;venv(3.6以后推荐的虚拟环境创建工具)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
  </entry>
  
</feed>
