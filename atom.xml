<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凭海临风的IT江湖</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pinghailinfeng.gitee.io/"/>
  <updated>2020-03-16T13:47:23.117Z</updated>
  <id>https://pinghailinfeng.gitee.io/</id>
  
  <author>
    <name>Jeff Sui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python standard_library _thread</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/16/python-standard-library-thread/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/16/python-standard-library-thread/</id>
    <published>2020-03-16T13:35:06.000Z</published>
    <updated>2020-03-16T13:47:23.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-thread"><a href="#python-标准库-thread" class="headerlink" title="python 标准库 _thread"></a>python 标准库 _thread</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200316_multiplethreading.jpg?raw=true" alt></p><a id="more"></a><p><code>python2</code> 中的<code>thread</code> 在 <code>python3</code>中叫<code>_thread</code>。相对于 <code>threading</code>来说更偏底层实现。</p><p>该模块提供了操作多个线程（也被称为 <em>轻量级进程</em> 或 <em>任务</em>）的底层原语 —— 多个控制线程共享全局数据空间。为了处理同步问题，也提供了简单的锁机制（也称为 <em>互斥锁</em> 或 <em>二进制信号</em>）。<a href="https://docs.python.org/zh-cn/3.8/library/threading.html#module-threading" target="_blank" rel="noopener"><code>threading</code></a> 模块基于该模块提供了更易用的高级多线程 API。</p><p><em>在 3.7 版更改:</em> 这个模块曾经是可选的，但现在总是可用的。</p><h2 id="常量和函数"><a href="#常量和函数" class="headerlink" title="常量和函数"></a>常量和函数</h2><p>这个模块定义了以下常量和函数：</p><ul><li><p><em>exception</em> <code>_thread.error</code></p><p>发生线程相关错误时抛出。<em>在 3.3 版更改:</em> 现在是内建异常 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 的别名。</p></li><li><p><code>_thread.LockType</code></p><p>锁对象的类型。</p></li><li><p><code>_thread.start_new_thread</code>(<em>function</em>, <em>args</em>[, <em>kwargs</em>])</p><p>开启一个新线程并返回其标识。 线程执行函数 <em>function</em> 并附带参数列表 <em>args</em> (必须是元组)。 可选的 <em>kwargs</em> 参数指定一个关键字参数字典。当函数返回时，线程会静默地退出。当函数因某个未处理异常而终结时，<a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.unraisablehook" target="_blank" rel="noopener"><code>sys.unraisablehook()</code></a> 会被调用以处理异常。 钩子参数的 <em>object</em> 属性为 <em>function</em>。 在默认情况下，会打印堆栈回溯然后该线程将退出（但其他线程会继续运行）。当函数引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a> 异常时，它会被静默地忽略。<em>在 3.8 版更改:</em> 现在会使用 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.unraisablehook" target="_blank" rel="noopener"><code>sys.unraisablehook()</code></a> 来处理未处理的异常。</p></li><li><p><code>_thread.interrupt_main</code>()</p><p>模拟一个 <code>signal.SIGINT</code> 信号到达主线程的效果。 线程可以使用这个函数来中断主线程。如果 Python 没有处理 <code>signal.SIGINT</code> (将它设为 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.SIG_DFL" target="_blank" rel="noopener"><code>signal.SIG_DFL</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.SIG_IGN" target="_blank" rel="noopener"><code>signal.SIG_IGN</code></a>)，此函数将不做任何事。</p></li><li><p><code>_thread.exit</code>()</p><p>抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a> 异常。如果没有捕获的话，这个异常会使线程退出。</p></li><li><p><code>_thread.allocate_lock</code>()</p><p>返回一个新的锁对象。锁中的方法在后面描述。初始情况下锁处于解锁状态。</p></li><li><p><code>_thread.get_ident</code>()</p><p>返回当前线程的 “线程描述符”。它是一个非零的整型数。它的值没有什么含义，主要是作为 magic cookie 使用，比如作为含有线程相关数据的字典的索引。线程描述符可能会在线程退出，新线程创建时复用。</p></li><li><p><code>_thread.get_native_id</code>()</p><p>返回内核分配给当前线程的原生集成线程 ID。 这是一个非负整数。 它的值可被用来在整个系统中唯一地标识这个特定线程（直到线程终结，在那之后该值可能会被 OS 回收再利用）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows, FreeBSD, Linux, macOS, OpenBSD, NetBSD, AIX。<em>3.8 新版功能.</em></p></li><li><p><code>_thread.stack_size</code>([<em>size</em>])</p><p>返回新建线程时使用的堆栈大小。可选参数 <em>size</em> 指定之后新建的线程的堆栈大小，而且一定要是0（根据平台或者默认配置）或者最小是32,768(32KiB)的一个正整数。如果<em>size</em>没有指定，默认是0。如果不支持改变线程堆栈大小，会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 错误。如果指定的堆栈大小不合法，会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 错误并且不会修改堆栈大小。32KiB是当前最小的能保证解释器足够堆栈空间的堆栈大小。需要注意的是部分平台对于堆栈大小会有特定的限制，例如要求大于32KiB的堆栈大小或者需要根据系统内存页面的整数倍进行分配 - 应当查阅平台文档有关详细信息（4KiB页面比较普遍，在没有更具体信息的情况下，建议的方法是使用4096的倍数作为堆栈大小）<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows，具有 POSIX 线程的系统。</p></li><li><p><code>_thread.TIMEOUT_MAX</code></p><p><code>Lock.acquire()</code> 方法中 <em>timeout</em> 参数允许的最大值。传入超过这个值的 timeout 会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a> 异常。<em>3.2 新版功能.</em></p></li></ul><h2 id="锁对象方法"><a href="#锁对象方法" class="headerlink" title="锁对象方法"></a>锁对象方法</h2><p>锁对象有以下方法：</p><ul><li><p><code>lock.acquire</code>(<em>waitflag=1</em>, <em>timeout=-1</em>)</p><p>没有任何可选参数时，该方法无条件申请获得锁，有必要的话会等待其他线程释放锁（同时只有一个线程能获得锁 —— 这正是锁存在的原因）。如果传入了整型参数 <em>waitflag</em>，具体的行为取决于传入的值：如果是 0 的话，只会在能够立刻获取到锁时才获取，不会等待，如果是非零的话，会像之前提到的一样，无条件获取锁。如果传入正浮点数参数 <em>timeout</em>，相当于指定了返回之前等待得最大秒数。如果传入负的 <em>timeout</em>，相当于无限期等待。如果 <em>waitflag</em> 是 0 的话，不能指定 <em>timeout</em>。如果成功获取到所会返回 <code>True</code>，否则返回 <code>False</code>。<em>在 3.2 版更改:</em> <em>timeout</em> 形参是新增的。<em>在 3.2 版更改:</em> 现在获取锁的操作可以被 POSIX 信号中断。</p></li><li><p><code>lock.release</code>()</p><p>释放锁。锁必须已经被获取过，但不一定是同一个线程获取的。</p></li><li><p><code>lock.locked</code>()</p><p>返回锁的状态：如果已被某个线程获取，返回 <code>True</code>，否则返回 <code>False</code>。</p></li></ul><p>除了这些方法之外，锁对象也可以通过 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句使用，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"></span><br><span class="line">a_lock = _thread.allocate_lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> a_lock:</span><br><span class="line">    print(<span class="string">"a_lock is locked while this executes"</span>)</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>线程与中断奇怪地交互：<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyboardInterrupt" target="_blank" rel="noopener"><code>KeyboardInterrupt</code></a> 异常可能会被任意一个线程捕获。（如果 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#module-signal" target="_blank" rel="noopener"><code>signal</code></a> 模块可用的话，中断总是会进入主线程。）</li><li>调用 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 或是抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a> 异常等效于调用 <a href="https://docs.python.org/zh-cn/3.8/library/_thread.html#_thread.exit" target="_blank" rel="noopener"><code>_thread.exit()</code></a>。</li><li>不可能中断锁的 <code>acquire()</code> 方法 —— <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyboardInterrupt" target="_blank" rel="noopener"><code>KeyboardInterrupt</code></a> 一场会在锁获取到之后发生。</li><li>当主线程退出时，由系统决定其他线程是否存活。在大多数系统中，这些线程会直接被杀掉，不会执行 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> … <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 语句，也不会执行对象析构函数。</li><li>当主线程退出时，不会进行正常的清理工作（除非使用了 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> … <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 语句），标准 I/O 文件也不会刷新。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-thread&quot;&gt;&lt;a href=&quot;#python-标准库-thread&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 _thread&quot;&gt;&lt;/a&gt;python 标准库 _thread&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200316_multiplethreading.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="_thread" scheme="https://pinghailinfeng.gitee.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library doctest</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/15/python-standard-library-doctest/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/15/python-standard-library-doctest/</id>
    <published>2020-03-15T03:50:31.000Z</published>
    <updated>2020-03-16T13:23:04.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-doctest"><a href="#python-标准库-doctest" class="headerlink" title="python  标准库 doctest"></a>python  标准库 doctest</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200316_westworld_3.jpg?raw=true" alt></p><a id="more"></a><p><code>doctest</code>模块搜索看起来像交互式Python会话的文本片段，然后执行这些会话以验证它们完全按照所示方式工作。有几种常用的方法可以使用doctest：</p><ul><li><p>通过验证所有交互式示例仍按记录工作来检查模块的文档是否是最新的。</p></li><li><p>通过验证测试文件或测试对象中的交互式示例如预期工作来执行回归测试。</p></li><li><p>为包编写教程文档，用输入输出示例大量地说明。根据实例或说明文本是否被强调，这具有“识字测试”或“可执行文档”的味道。</p></li></ul><p>这是一个完整但很小的示例模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">This is the "example" module.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The example module supplies one function, factorial().  For example,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>factorial(5)</span></span><br><span class="line"><span class="string">120</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""Return the factorial of n, an exact integer &gt;= 0.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the result is small enough to fit in an int, return an int.</span></span><br><span class="line"><span class="string">    Else return a long.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; [factorial(n) for n in range(6)]</span></span><br><span class="line"><span class="string">    [1, 1, 2, 6, 24, 120]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; [factorial(long(n)) for n in range(6)]</span></span><br><span class="line"><span class="string">    [1, 1, 2, 6, 24, 120]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30)</span></span><br><span class="line"><span class="string">    265252859812191058636308480000000L</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30L)</span></span><br><span class="line"><span class="string">    265252859812191058636308480000000L</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(-1)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    ValueError: n must be &gt;= 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Factorials of floats are OK, but the float must be an exact integer:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30.1)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    ValueError: n must be exact integer</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(30.0)</span></span><br><span class="line"><span class="string">    265252859812191058636308480000000L</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    It must also not be ridiculously large:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; factorial(1e100)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    OverflowError: n too large</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"n must be &gt;= 0"</span>)</span><br><span class="line">    <span class="keyword">if</span> math.floor(n) != n:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"n must be exact integer"</span>)</span><br><span class="line">    <span class="keyword">if</span> n+<span class="number">1</span> == n:  <span class="comment"># catch a value like 1e300</span></span><br><span class="line">        <span class="keyword">raise</span> OverflowError(<span class="string">"n too large"</span>)</span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    factor = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> factor &lt;= n:</span><br><span class="line">        result *= factor</span><br><span class="line">        factor += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure><p>如果您直接从命令行运行<code>example.py</code>，那么<code>doctest</code>可以发挥它的魔力：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python example.py</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>没有输出！这很正常，而且这意味着所有的例子都有效。传递<code>-v</code>给脚本，并<code>doctest</code>打印它正在尝试的详细日志，并在最后打印摘要：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ python example.py -v</span><br><span class="line">Trying:</span><br><span class="line">    factorial(<span class="number">5</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    <span class="number">120</span></span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    [factorial(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">Expecting:</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    [factorial(long(n)) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">Expecting:</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>以此类推，最终结局如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Trying:</span><br><span class="line">    factorial(<span class="number">1e100</span>)</span><br><span class="line">Expecting:</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">        ...</span><br><span class="line">    OverflowError: n too large</span><br><span class="line">ok</span><br><span class="line"><span class="number">2</span> items passed all tests:</span><br><span class="line">   <span class="number">1</span> tests <span class="keyword">in</span> __main__</span><br><span class="line">   <span class="number">8</span> tests <span class="keyword">in</span> __main__.factorial</span><br><span class="line"><span class="number">9</span> tests <span class="keyword">in</span> <span class="number">2</span> items.</span><br><span class="line"><span class="number">9</span> passed <span class="keyword">and</span> <span class="number">0</span> failed.</span><br><span class="line">Test passed.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>这就是你需要知道的开始有效使用<code>doctest</code>！跳入。以下部分提供完整的详细信息。请注意，标准Python测试套件和库中有很多文档测试的例子。在标准测试文件中可以找到特别有用的示例<code>Lib/test/test_doctest.py</code>。</p><h2 id="1-简单用法：检查Docstrings中的示例"><a href="#1-简单用法：检查Docstrings中的示例" class="headerlink" title="1.简单用法：检查Docstrings中的示例"></a>1.简单用法：检查Docstrings中的示例</h2><p>开始使用doctest的最简单的方法（但不一定是您继续这样做的方式）是结束每个模块<code>M</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure><p>然后<code>doctest</code>在模块中检查文档字符串<code>M</code>。</p><p>将模块作为脚本运行会导致文档字符串中的示例得到执行和验证：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python M.py</span><br></pre></td></tr></table></figure><p>这将不会显示任何东西，除非一个例子失败，在这种情况下，失败的例子和失败的原因被打印到标准输出，并且输出的最后一行是<code>***Test Failed*** N failures.</code>，其中<em>N</em>是数字失败的例子。</p><p>改为使用开关运行<code>-v</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python M.py -v</span><br></pre></td></tr></table></figure><p>并且所有尝试过的示例的详细报告都会打印到标准输出，并在最后列出各种摘要。</p><p>您可以通过传递<code>verbose=True</code>来强制详细模式<code>testmod()</code>，或通过传递来禁止它<code>verbose=False</code>。在任何一种情况下，<code>sys.argv</code>都不会被检查<code>testmod()</code>（如此通过<code>-v</code>或没有影响）。</p><p>自Python 2.6以来，还有一个用于运行的命令行快捷方式<code>testmod()</code>。您可以指示Python解释器直接从标准库运行doctest模块，并在命令行上传递模块名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m doctest -v example.py</span><br></pre></td></tr></table></figure><p>这将<code>example.py</code>作为独立模块导入并<code>testmod()</code>在其上运行。请注意，如果文件是软件包的一部分并从该软件包导入其他子模块，则可能无法正常工作。</p><p>有关更多信息<code>testmod()</code>，请参阅基本API一节。</p><h2 id="2-简单的用法：检查文本文件中的示例"><a href="#2-简单的用法：检查文本文件中的示例" class="headerlink" title="2.简单的用法：检查文本文件中的示例"></a>2.简单的用法：检查文本文件中的示例</h2><p>doctest的另一个简单应用是在文本文件中测试交互式示例。这可以通过以下<code>testfile()</code>功能完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line">doctest.testfile(<span class="string">"example.txt"</span>)</span><br></pre></td></tr></table></figure><p>该短脚本执行并验证文件中包含的任何交互式Python示例<code>example.txt</code>。文件内容被视为一个巨大的文档字符串; 该文件不需要包含Python程序！例如，也许<code>example.txt</code>包含这个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">The ``example`` module</span><br><span class="line">======================</span><br><span class="line"></span><br><span class="line">Using ``factorial``</span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line">This <span class="keyword">is</span> an example text file <span class="keyword">in</span> reStructuredText format.  First <span class="keyword">import</span></span><br><span class="line">``factorial`` <span class="keyword">from</span> the ``example`` module:</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; <span class="keyword">from</span> example <span class="keyword">import</span> factorial</span><br><span class="line"></span><br><span class="line">Now use it:</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; factorial(<span class="number">6</span>)</span><br><span class="line">    <span class="number">120</span></span><br></pre></td></tr></table></figure><p>运行<code>doctest.testfile(&quot;example.txt&quot;)</code>然后在这个文档中找到错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File <span class="string">"./example.txt"</span>, line <span class="number">14</span>, <span class="keyword">in</span> example.txt</span><br><span class="line">Failed example:</span><br><span class="line">    factorial(<span class="number">6</span>)</span><br><span class="line">Expected:</span><br><span class="line">    <span class="number">120</span></span><br><span class="line">Got:</span><br><span class="line">    <span class="number">720</span></span><br></pre></td></tr></table></figure><p>与<code>testmod()</code>一样，<code>testfile()</code>除非例子失败，否则不会显示任何内容。如果一个例子失败了，那么失败的例子和失败的原因将被打印到标准输出中，格式为<code>testmod()</code>。</p><p>默认情况下，<code>testfile()</code>查找调用模块目录中的文件。有关可用于指示其在其他位置查找文件的可选参数的说明，请参见Basic API一节。</p><p>就像<code>testmod()</code>，<code>testfile()</code>可以通过<code>-v</code>命令行开关或可选的关键字参数<em>verbose</em>来设置详细程度。</p><p>自Python 2.6以来，还有一个用于运行的命令行快捷方式<code>testfile()</code>。您可以指示Python解释器直接从标准库运行doctest模块，并在命令行上传递文件名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m doctest -v example.txt</span><br></pre></td></tr></table></figure><p>因为文件名并不以此结束<code>.py</code>，因此<code>doctest</code>推断它必须与其一起运行<code>testfile()</code>，而不是<code>testmod()</code>。</p><p>有关更多信息<code>testfile()</code>，请参阅基本API一节。</p><h2 id="3-它是如何工作的"><a href="#3-它是如何工作的" class="headerlink" title="3.它是如何工作的"></a>3.它是如何工作的</h2><p>本节将详细介绍doctest如何工作：查看它的文档字符串，它如何查找交互式示例，它使用的执行上下文，它如何处理异常以及如何使用选项标志来控制其行为。这是编写doctest示例时需要了解的信息; 有关在这些示例上实际运行doctest的信息，请参阅以下各节。</p><h3 id="3-1-哪些Docstrings被检查？"><a href="#3-1-哪些Docstrings被检查？" class="headerlink" title="3.1. 哪些Docstrings被检查？"></a>3.1. 哪些Docstrings被检查？</h3><p>模块docstring，以及所有函数，类和方法文档字符串被搜索。导入到模块中的对象不被搜索。</p><p>另外，如果<code>M.__test__</code>存在且“为真”，则它必须是字典，并且每个条目将（字符串）名称映射到函数对象，类对象或字符串。从中找到的函数和类对象文档字符串<code>M.__test__</code>被搜索，字符串被视为文档字符串。在输出，一键<code>K</code>在<code>M.__test__</code>出现与名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;name of M&gt;.__test__.K</span><br></pre></td></tr></table></figure><p>找到的任何类都以相似的方式递归搜索，以测试其包含的方法和嵌套类中的文档字符串。</p><p>在版本2.4中进行了更改：“专用名称”概念已被弃用且不再有记录。</p><h3 id="3-2-Docstring示例如何被认可？"><a href="#3-2-Docstring示例如何被认可？" class="headerlink" title="3.2. Docstring示例如何被认可？"></a>3.2. Docstring示例如何被认可？</h3><p>在大多数情况下，交互式控制台会话的复制和粘贴工作正常，但doctest并不试图精确模拟任何特定的Python shell。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># comments are ignored</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> x == <span class="number">13</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"yes"</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"no"</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"NO"</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"NO!!!"</span></span><br><span class="line">...</span><br><span class="line">no</span><br><span class="line">NO</span><br><span class="line">NO!!!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>任何期望的输出必须紧跟在包含代码的最后一行<code>&#39;&gt;&gt;&gt; &#39;</code>或<code>&#39;... &#39;</code>一行之后，并且预期的输出（如果有的话）扩展到下一行<code>&#39;&gt;&gt;&gt; &#39;</code>或全空白行。</p><p>细则：</p><ul><li><p>预期的输出不能包含全空白行，因为这样的行被用来表示预期输出的结束。如果预期的输出包含空白行，请<code>&lt;BLANKLINE&gt;</code>在doctest示例中输入空行。新的2.4版本：<code>&lt;BLANKLINE&gt;</code>加入; 没有办法在以前的版本中使用包含空行的预期输出。</p></li><li><p>所有硬标签字符都被扩展为空格，使用8列制表位。测试代码生成的输出中的选项卡不会被修改。由于示例输出<em>中的</em>任何硬标签<em>都是</em>展开的，这意味着如果代码输出包含硬标签，则doctest可以通过的唯一方式是如果<code>NORMALIZE_WHITESPACE</code>选项或指令有效。或者，可以重写测试以捕获输出并将其作为测试的一部分与预期值进行比较。源代码中对制表符的处理是通过反复试验得出的，并且已被证明是处理它们的最不容易出错的方式。通过编写自定义<code>DocTestParser</code>类，可以使用不同的算法来处理选项卡。</p></li><li><p>输出到标准输出被捕获，但不输出到标准错误（异常追溯通过不同的方式捕获）。 </p></li><li><p>如果在交互式会话中通过反斜线继续行，或者出于任何其他原因使用反斜杠，则应该使用原始文档字符串，该字符串将按照键入时的方式保存反斜杠：</p></li></ul><blockquote><p>def f(x): …     r’’’Backslashes in a raw docstring: m\n’’’ &gt;&gt;&gt; print f.<strong>doc</strong> Backslashes in a raw docstring: m\n </p></blockquote><p>否则，反斜杠将被解释为字符串的一部分。例如，<code>\n</code>以上将被解释为一个换行符。或者，您可以在doctest版本中将每个反斜杠加倍（并且不使用原始字符串）：</p><blockquote><p>def f(x): …     ‘’’Backslashes in a raw docstring: m\n’’’ &gt;&gt;&gt; print f.<strong>doc</strong> Backslashes in a raw docstring: m\n </p></blockquote><ul><li>起始栏无关紧要：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="string">"Easy!"</span></span><br><span class="line">      &gt;&gt;&gt; <span class="keyword">import</span> math</span><br><span class="line">          &gt;&gt;&gt; math.floor(<span class="number">1.9</span>)</span><br><span class="line">          <span class="number">1</span></span><br></pre></td></tr></table></figure><p>并且从开始示例的初始行中出现的预期输出中删除了许多主要的空白字符<code>&#39;&gt;&gt;&gt;&#39;</code>。</p><h3 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h3><p>默认情况下，每次<a href="https://docs.python.org/3/library/doctest.html#module-doctest" target="_blank" rel="noopener"><code>doctest</code></a>发现一个文档字符串进行测试，它采用的是 <em>浅拷贝</em>的<code>M</code>的全局，使运行测试不会改变模块真实的全局，因此，在一个测试<code>M</code>不能离开屑不小心让另外一个背后测试工作。这意味着示例可以自由使用任何在顶层定义的<code>M</code>名称，以及在运行的文档字符串中定义的名称。示例无法看到其他文档中定义的名称。</p><p>你可以通过强制使用自己的字典作为执行上下文 <code>globs=your_dict</code>来<a href="https://docs.python.org/3/library/doctest.html#doctest.testmod" target="_blank" rel="noopener"><code>testmod()</code></a>或<a href="https://docs.python.org/3/library/doctest.html#doctest.testfile" target="_blank" rel="noopener"><code>testfile()</code></a>替代。</p><h3 id="什么是例外？"><a href="#什么是例外？" class="headerlink" title="什么是例外？"></a>什么是例外？</h3><p>没问题，只要回溯是该示例生成的唯一输出：只需粘贴回溯。<a href="https://docs.python.org/3/library/doctest.html#id2" target="_blank" rel="noopener">[1]</a>由于回溯包含可能快速变化的细节（例如，确切的文件路径和行号），所以这是doctest很难灵活接受的一种情况。</p><p>简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].remove(<span class="number">42</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: list.remove(x): x <span class="keyword">not</span> <span class="keyword">in</span> list</span><br></pre></td></tr></table></figure><p>该文档测试成功，如果<a href="https://docs.python.org/3/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>提出，详情如图所示。<code>list.remove(x):</code> <code>x</code> <code>not</code> <code>in</code> <code>list</code></p><p>预期的异常输出必须以追溯标题开头，该标题可以是以下两行中的任一行，缩写与示例的第一行相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">Traceback (innermost last):</span><br></pre></td></tr></table></figure><p>traceback头后面跟着一个可选的traceback堆栈，其内容被doctest忽略。回溯堆栈通常被忽略，或者从交互式会话逐字复制。</p><p>跟踪堆栈后面是最有趣的部分：包含异常类型和细节的行。这通常是追溯的最后一行，但如果异常具有多行详细信息，则可以跨越多行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> ValueError(<span class="string">'multi\n    line\ndetail'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: multi</span><br><span class="line">    line</span><br><span class="line">detail</span><br></pre></td></tr></table></figure><p>最后三行（以开始<a href="https://docs.python.org/3/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>）与异常的类型和细节进行比较，其余部分将被忽略。</p><p>最佳做法是省略追溯堆栈，除非它为示例增加了重要的文档值。所以最后一个例子可能更好，因为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> ValueError(<span class="string">'multi\n    line\ndetail'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    ...</span><br><span class="line">ValueError: multi</span><br><span class="line">    line</span><br><span class="line">detail</span><br></pre></td></tr></table></figure><p>请注意，回溯处理非常特别。特别是，在改写的例子中，使用<code>...</code>独立于doctest的 <a href="https://docs.python.org/3/library/doctest.html#doctest.ELLIPSIS" target="_blank" rel="noopener"><code>ELLIPSIS</code></a>选项。这个例子中的省略号可以省略，或者可以是三个（或三百个）逗号或数字，或者Monty Python skit的缩进记录。</p><p>一些细节你应该阅读一次，但不需要记住：</p><ul><li><p>Doctest无法猜测您的预期输出是来自异常追溯还是来自普通打印。因此，例如，预计<code>ValueError: 42 is prime</code>会传递一个示例，无论是否<code>ValueError</code>实际提出，或者该示例仅打印该追溯文本。实际上，普通输出很少以追溯标题行开始，所以这不会产生实际问题。</p></li><li><p>回溯堆栈的每一行（如果存在）必须比示例的第一行缩进得更远，<em>或者</em>以非字母数字字符开始。追溯标题后面的第一行缩写相同，并以字母数字开头，作为异常详细信息的开始。当然这对于真正的回溯来说是正确的。</p></li><li><p>当<code>IGNORE_EXCEPTION_DETAIL</code>指定doctest选项时，将忽略最左侧冒号后面的所有内容以及异常名称中的所有模块信息。</p></li><li><p>交互式shell省略了一些<code>SyntaxError</code>s 的追溯标题行。但doctest使用traceback标题行来区分异常和非异常。因此，在极少数情况下，如果您需要测试一个<code>SyntaxError</code>省略traceback头的测试，则需要手动将traceback头行添加到测试示例中。</p></li><li><p>对于某些<code>SyntaxError</code>s，Python使用<code>^</code>标记来显示语法错误的字符位置：</p></li></ul><blockquote><p>1 1   File “<stdin>“, line 1     1 1       ^ SyntaxError: invalid syntax </stdin></p></blockquote><p>由于显示错误位置的行出现在异常类型和细节之前，因此它们不会被doctest检查。例如，即使将<code>^</code>标记放在错误的位置，也会通过以下测试：</p><blockquote><p>1 1   File “<stdin>“, line 1     1 1     ^ SyntaxError: invalid syntax </stdin></p></blockquote><h3 id="3-5-Option-Flags"><a href="#3-5-Option-Flags" class="headerlink" title="3.5. Option Flags"></a>3.5. Option Flags</h3><p>许多选项标志控制着doctest行为的各个方面。这些标志的符号名称作为模块常量提供，可以<a href="https://docs.python.org/2.7/reference/expressions.html#bitwise" target="_blank" rel="noopener">按位或运算</a>并传递给各种函数。这些名称也可以在doctest指令中使用。</p><p>第一组选项定义测试语义，控制doctest如何确定实际输出是否与示例预期输出相匹配的方面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.DONT_ACCEPT_TRUE_FOR_1</span><br></pre></td></tr></table></figure><p>默认情况下，如果预期的输出块只包含<code>1</code>，只是含有实际输出块<code>1</code>或仅<code>True</code>被认为是一个匹配，并类似地用于<code>0</code>对<code>False</code>。当<code>DONT_ACCEPT_TRUE_FOR_1</code>指定时，不允许替换。缺省行为迎合了Python将许多函数的返回类型从整数更改为布尔值; 希望“小整数”输出的doctests在这些情况下仍然有效。这个选项可能会消失，但不会持续数年。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.DONT_ACCEPT_BLANKLINE</span><br></pre></td></tr></table></figure><p>默认情况下，如果预期的输出块包含仅包含字符串的行<code>&lt;BLANKLINE&gt;</code>，则该行将匹配实际输出中的空行。由于真正的空行界定了预期的输出，因此这是沟通预期空行的唯一方式。什么时候<code>DONT_ACCEPT_BLANKLINE</code>被指定，这个替代是不允许的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.NORMALIZE_WHITESPACE</span><br></pre></td></tr></table></figure><p>指定时，所有空白（空格和换行符）都被视为相等。预期输出中的任何空白序列都将与实际输出中的任何空白序列相匹配。默认情况下，空白必须完全匹配。<code>NORMALIZE_WHITESPACE</code>当预期输出的行很长时，并且您想要在源代码中的多行中包装它时，它特别有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.ELLIPSIS</span><br></pre></td></tr></table></figure><p>指定时，<code>...</code>预期输出中的省略号标记（）可以匹配实际输出中的任何子字符串。这包括跨越行边界的子字符串和空的子字符串，所以最好保持简单的使用。复杂的用途可能会导致相同类型的“oops，它匹配得太多了！” <code>.*</code>在正则表达式中很容易出现意外。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.IGNORE_EXCEPTION_DETAIL</span><br></pre></td></tr></table></figure><p>指定时，即使异常详细信息不匹配，如果引发了期望类型的异常，那么期望异常的示例也会通过。例如，<code>ValueError: 42</code>如果引发的实际异常是预期的例子<code>ValueError: 3*14</code>，但会失败，例如，如果<code>TypeError</code>引发。</p><p>它也会忽略Python 3 doctest报告中使用的模块名称。因此，无论测试是在Python 2.7还是Python 3.2（或更高版本）下运行，这两种变体都可以与指定的标志一起使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raise CustomError(<span class="string">'message'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">CustomError: message</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; raise CustomError(<span class="string">'message'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">my_module.CustomError: message</span><br></pre></td></tr></table></figure><p>请注意，<code>ELLIPSIS</code>也可以用于忽略异常消息的详细信息，但根据是否将模块详细信息作为异常名称的一部分进行打印，此类测试可能仍会失败。使用<code>IGNORE_EXCEPTION_DETAIL</code>和来自Python 2.3的细节也是编写文档测试的唯一明确方式，它不关心异常细节，但仍然在Python 2.3或更低版本中继续传递（这些版本不支持doctest指令并将它们忽略为不相关的注释） 。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (<span class="number">1</span>, <span class="number">2</span>)[<span class="number">3</span>] = <span class="string">'moo'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line"><span class="built_in">TypeError</span>: object doesn<span class="string">'t support item assignment</span></span><br></pre></td></tr></table></figure><p>虽然Python 2.4中的细节更改为“不”而不是“不”，但在Python 2.3以及更高版本的Python版本中通过了指定的标志。</p><p>在 3.2 版更改:：<code>IGNORE_EXCEPTION_DETAIL</code>现在也忽略了与包含被测异常的模块有关的任何信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.SKIP</span><br></pre></td></tr></table></figure><p>指定时，请不要运行该示例。这在doctest示例既可用作文档也可用作测试用例的情况下非常有用，应将其用于文档目的，但不应进行检查。例如，该示例的输出可能是随机的; 或者该示例可能依赖于测试驱动程序无法使用的资源。</p><p>SKIP标志也可用于临时“注释”示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.COMPARISON_FLAGS</span><br></pre></td></tr></table></figure><p>将上面的所有比较标志掩盖起来。</p><p>第二组选项控制如何报告测试失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.REPORT_UDIFF</span><br></pre></td></tr></table></figure><p>指定时，涉及多行预期和实际输出的故障将使用统一差异显示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.REPORT_CDIFF</span><br></pre></td></tr></table></figure><p>指定时，涉及多行预期输出和实际输出的故障将使用上下文差异显示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.REPORT_NDIFF</span><br></pre></td></tr></table></figure><p>指定时，<code>difflib.Differ</code>使用与常用<code>ndiff.py</code>实用程序相同的算法计算差异。这是标记线内和线间差异的唯一方法。例如，如果预期输出的一行包含数字<code>1</code>，其中实际输出包含字母<code>l</code>，则会插入一行，并在其中插入用于标记不匹配列位置的插入符号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.REPORT_ONLY_FIRST_FAILURE</span><br></pre></td></tr></table></figure><p>指定时，显示每个doctest中的第一个失败示例，但禁止所有其他示例的输出。这将防止doctest报告因早期故障而中断的正确示例; 但它也可能隐藏不正确的例子，不依靠第一次失败而失败。当<code>REPORT_ONLY_FIRST_FAILURE</code>指定时，剩余的示例仍在运行，并仍然计入报告的故障总数; 只有输出被抑制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.FAIL_FAST</span><br></pre></td></tr></table></figure><p>指定时，在第一个失败示例后退出，不要尝试运行其余示例。因此，报告的故障数最多为 1。此标志在调试期间可能很有用，因为第一次失败后的示例不会生成调试输出。</p><p>3.4版新功能</p><p>还有一种方法可以注册新的选项标志名称，但除非您打算<code>doctest</code>通过子类扩展内部函数，否则这种方法并不有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.register_optionflag(name)</span><br></pre></td></tr></table></figure><p>用给定名称创建一个新选项标志，并返回新标志的整数值。<code>register_optionflag()</code>可用于子类化<code>OutputChecker</code>或<code>DocTestRunner</code>创建您的子类支持的新选项。<code>register_optionflag()</code>应该总是使用以下习惯用法来调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MY_FLAG = register_optionflag(<span class="string">'MY_FLAG'</span>)</span><br></pre></td></tr></table></figure><p>New in version 2.4.</p><h3 id="3-6-Directives"><a href="#3-6-Directives" class="headerlink" title="3.6. Directives"></a>3.6. Directives</h3><p>Doctest指令可用于修改单个示例的选项标志。Doctest指令是遵循示例源代码的特殊Python注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">directive             ::=  <span class="string">"#"</span> <span class="string">"doctest:"</span> directive_options</span><br><span class="line">directive_options     ::=  directive_option (<span class="string">","</span> directive_option)\*</span><br><span class="line">directive_option      ::=  on_or_off directive_option_name</span><br><span class="line">on_or_off             ::=  <span class="string">"+"</span> \| <span class="string">"-"</span></span><br><span class="line">directive_option_name ::=  <span class="string">"DONT_ACCEPT_BLANKLINE"</span> \| <span class="string">"NORMALIZE_WHITESPACE"</span> \| ...</span><br></pre></td></tr></table></figure><p><code>+</code>or <code>-</code>和指令选项名称之间不允许有空格。指令选项名称可以是上面解释的任何选项标志名称。</p><p>一个例子的doctest指令修改了doctest的这个例子的行为。使用<code>+</code>启用这个名字的行为，或<code>-</code>将其禁用。</p><p>例如，这个测试通过：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> range(<span class="number">20</span>) <span class="comment"># doctest: +NORMALIZE_WHITESPACE</span></span><br><span class="line">[<span class="number">0</span>,   <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,</span><br><span class="line"><span class="number">10</span>,  <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>如果没有指令，它会失败，这是因为实际输出在单个数字列表元素之前没有两个空格，并且因为实际输出在单行上。这个测试也通过了，并且还需要一个指令来做到这一点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> range(<span class="number">20</span>) <span class="comment"># doctest: +ELLIPSIS</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, ..., <span class="number">18</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>多条指令可用于单条物理线路，用逗号分隔：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> range(<span class="number">20</span>) <span class="comment"># doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span></span><br><span class="line">[<span class="number">0</span>,    <span class="number">1</span>, ...,   <span class="number">18</span>,    <span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>如果单个示例使用多个指令注释，则将它们合并：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print range(20) # doctest: +ELLIPSIS</span><br><span class="line">...                 # doctest: +NORMALIZE_WHITESPACE</span><br><span class="line">[<span class="number">0</span>,    <span class="number">1</span>, ...,   <span class="number">18</span>,    <span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>如前例所示，您可以将<code>...</code>行添加到仅包含指令的示例中。当一个例子对于指令很容易适合同一行时太长了，这会很有用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print range(<span class="number">5</span>) + range(<span class="number">10</span>,<span class="number">20</span>) + range(<span class="number">30</span>,<span class="number">40</span>) + range(<span class="number">50</span>,<span class="number">60</span>)</span><br><span class="line">... # doctest: +ELLIPSIS</span><br><span class="line">[<span class="number">0</span>, ..., <span class="number">4</span>, <span class="number">10</span>, ..., <span class="number">19</span>, <span class="number">30</span>, ..., <span class="number">39</span>, <span class="number">50</span>, ..., <span class="number">59</span>]</span><br></pre></td></tr></table></figure><p>请注意，由于默认情况下所有选项都被禁用，并且指令仅适用于它们出现的示例，因此启用选项（通过<code>+</code>指令）通常是唯一有意义的选择。但是，选项标志也可以传递给运行doctests的函数，建立不同的默认值。在这种情况下，通过<code>-</code>指令禁用选项可能很有用。</p><p>2.4版新增功能：增加了对doctest指令的支持。</p><h3 id="3-7-警告"><a href="#3-7-警告" class="headerlink" title="3.7. 警告"></a>3.7. 警告</h3><p><code>doctest</code>严格要求在预期产出中要求完全匹配。如果即使单个字符不匹配，测试也会失败。这可能会让你感到惊讶，因为你确切地知道Python做了什么，并且不能保证输出。例如，在打印字典时，Python不保证键值对将以任何特定的顺序打印，因此像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo()</span><br><span class="line">&#123;<span class="string">"Hermione"</span>: <span class="string">"hippogryph"</span>, <span class="string">"Harry"</span>: <span class="string">"broomstick"</span>&#125;</span><br></pre></td></tr></table></figure><p>很脆弱！一种解决方法是做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo() == &#123;<span class="string">"Hermione"</span>: <span class="string">"hippogryph"</span>, <span class="string">"Harry"</span>: <span class="string">"broomstick"</span>&#125;</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>代替。另一个是要做的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = foo().items()</span><br><span class="line">&gt;&gt;&gt; d.sort()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">[(<span class="string">'Harry'</span>, <span class="string">'broomstick'</span>), (<span class="string">'Hermione'</span>, <span class="string">'hippogryph'</span>)]</span><br></pre></td></tr></table></figure><p>还有其他的，但你明白了。</p><p>另一个不好的想法是打印嵌入对象地址的东西，比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="number">1.0</span>) <span class="comment"># certain to fail some of the time</span></span><br><span class="line"><span class="number">7948648</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C()   <span class="comment"># the default repr() for instances embeds an address</span></span><br><span class="line">&lt;__main__.C instance at <span class="number">0x00AC18F0</span>&gt;</span><br></pre></td></tr></table></figure><p><code>ELLIPSIS</code>指令为最后一个示例提供了一个很好的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C() <span class="comment">#doctest: +ELLIPSIS</span></span><br><span class="line">&lt;__main__.C instance at <span class="number">0</span>x...&gt;</span><br></pre></td></tr></table></figure><p>浮点数也受到跨平台的小输出变化的影响，因为Python遵循平台C库进行浮点格式化，而C库在质量上差别很大。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1./7  # risky</span><br><span class="line"><span class="number">0.14285714285714285</span></span><br><span class="line">&gt;&gt;&gt; print 1./7 # safer</span><br><span class="line"><span class="number">0.142857142857</span></span><br><span class="line">&gt;&gt;&gt; print round(1./7, 6) # much safer</span><br><span class="line"><span class="number">0.142857</span></span><br></pre></td></tr></table></figure><p>表格<code>I/2.**J</code>中的数字在所有平台上都是安全的，而且我通常会编写一些doctest的例子来生成这种格式的数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3.</span>/<span class="number">4</span>  <span class="comment"># utterly safe</span></span><br><span class="line"><span class="number">0.75</span></span><br></pre></td></tr></table></figure><p>简单的分数对于人们来说也更容易理解，并且这使得更好的文档。</p><h2 id="4-基本API"><a href="#4-基本API" class="headerlink" title="4.基本API"></a>4.基本API</h2><p>函数<code>testmod()</code>和<code>testfile()</code>提供了一个简单的界面，文档测试，应该是足够了最基本的用途。有关这两个函数的不太正式的介绍，请参见简单用法：检查文档字符串和简单用法中的示例：检查文本文件中的示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.testfile(filename[, module_relative][, name][, package][, globs][, verbose][, report][, optionflags][, extraglobs][, raise_on_error][, parser][, encoding])</span><br></pre></td></tr></table></figure><p>除<em>文件名</em>以外的所有参数都是可选的，并应以关键字形式指定。</p><p>在名为<em>filename</em>的文件中测试示例。返回<code>(failure_count, test_count)</code>。</p><p>可选参数<em>module_relative</em>指定应如何解释文件名：</p><ul><li><p>如果<em>module_relative</em>是<code>True</code>（缺省值），则<em>filename</em>指定一个与操作系统无关的模块相对路径。默认情况下，这个路径是相对于调用模块的目录；但是如果指定了<em>package</em>参数，那么它与该包相关。为了确保OS独立性，<em>文件名</em>应该使用<code>/</code>字符来分隔路径段，并且可能不是绝对路径（即它可能不以开头<code>/</code>）。</p></li><li><p>如果<em>module_relative</em>是<code>False</code>，则<em>filename</em>指定一个OS特定的路径。路径可以是绝对的或相对的; 相对路径相对于当前工作目录被解析。</p></li></ul><p>可选参数<em>名称</em>给出测试的名称; 默认情况下，或者<code>None</code>，<code>os.path.basename(filename)</code>被使用。</p><p>可选参数<em>包</em>是一个Python包或一个Python包的名称，其目录应该用作模块相关文件名的基本目录。如果未指定包，则调用模块的目录将用作模块相关文件名的基本目录。如果<em>module_relative</em>是指定<em>包，</em>那是错误的。<code>False</code></p><p>可选参数<em>globs</em>在执行示例时给出了一个用作全局变量的字典。这个词典的一个新的浅拷贝是为doctest创建的，所以它的例子从一个干净的石板开始。默认情况下，或者如果<code>None</code>使用新的空字典。</p><p>可选参数<em>extraglobs</em>给出了一个合并到用于执行示例的全局变量中的字典。这适用于<code>dict.update()</code>：如果<em>globs</em>和<em>extraglobs</em>具有共同的键，则<em>extraglobs</em>中的关联值出现在组合字典中。默认情况下，或者如果<code>None</code>，不使用额外的全局变量。这是一个允许doctests参数化的高级功能。例如，可以为基类编写一个doctest，使用该类的通用名称，然后通过传递将泛型名称映射到要测试的子类的<em>extraglobs</em>字典来测试任意数量的子类。</p><p>可选参数<em>详细信息</em>如果为true，则会打印大量内容，如果为false，则仅打印失败; 默认情况下，或者如果<code>None</code>，当且仅当<code>&#39;-v&#39;</code>在时才是<code>sys.argv</code>。</p><p>可选的参数<em>报告</em>在最后打印摘要时为真，否则在最后不打印任何内容。在详细模式下，摘要是详细的，否则摘要非常简短（实际上，如果所有测试都通过，则为空）。</p><p>可选参数<em>optionflags</em>或一起选项标志。请参见选项标志部分。</p><p>可选参数<em>raise_on_error</em>默认为false。如果为true，则在例子中发生第一次失败或意外异常时引发异常。这样可以对故障进行事后调试。默认行为是继续运行示例。</p><p>可选参数<em>解析器</em>指定<code>DocTestParser</code>应该用于从文件中提取测试的一个（或子类）。它默认为一个普通的解析器（即，<code>DocTestParser()</code>）。</p><p>可选的参数<em>编码</em>指定应该用于将文件转换为unicode的编码。</p><p>2.4版本中的新功能。</p><p>在版本2.5中更改：添加了参数<em>编码</em>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.testmod([m][, name][, globs][, verbose][, report][, optionflags][, extraglobs][, raise_on_error][, exclude_empty])</span><br></pre></td></tr></table></figure><p>所有参数都是可选的，除<em>m</em>外的所有参数都应以关键字形式指定。</p><p>在从<em>m开始</em>可以访问的函数和类中的docstrings中的测试示例（或者<code>__main__</code>如果<em>m</em>没有提供或者是<code>None</code>，则为module ），以<code>m.__doc__</code>。开头。</p><p>还有可以从字典中获得的测试例子<code>m.__test__</code>，如果它存在与否<code>None</code>。<code>m.__test__</code>将名称（字符串）映射到函数，类和字符串; 函数和类docstrings搜索的例子; 字符串被直接搜索，就好像它们是docstrings一样。</p><p>仅搜索附加到属于模块<em>m的</em>对象的文档字符串。</p><p>返回<code>(failure_count, test_count)</code>。</p><p>可选参数<em>名称</em>给出模块的名称; 默认情况下，或者<code>None</code>，<code>m.__name__</code>被使用。</p><p>可选参数<em>exclude_empty</em>默认为false。如果属实，则没有找到doctests的对象将被排除在考虑之外。默认值是向后兼容的黑客，使代码仍然使用<code>doctest.master.summarize()</code>连同<code>testmod()</code>继续得到输出，没有测试对象。新构造函数的<em>exclude_empty</em>参数<code>DocTestFinder</code>默认为true。</p><p>可选参数<em>extraglobs</em>，<em>verbose</em>，<em>report</em>，<em>optionflags</em>，<em>raise_on_error</em>和<em>globs</em>与<code>testfile()</code>上述函数相同，只是<em>globs</em>默认为<code>m.__dict__</code>。</p><p>在版本2.3中更改：添加了参数<em>optionflags</em>。</p><p>在版本2.4中更改：添加了参数<em>extraglobs</em>，<em>raise_on_error</em>和<em>exclude_empty</em>。</p><p>在版本2.5中更改：可选参数<em>isprivate</em>，在2.4中弃用，已被删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.run_docstring_examples(f, globs[, verbose][, name][, compileflags][, optionflags])</span><br></pre></td></tr></table></figure><p>与对象<em>f</em>相关的测试例子; 例如，<em>f</em>可以是字符串，模块，函数或类对象。</p><p>字典参数<em>glob的</em>浅拷贝用于执行上下文。</p><p>失败消息中使用可选参数<em>名称</em>，缺省值为<code>&quot;NoName&quot;</code>。</p><p>如果可选参数<em>verbose</em>为true，则即使没有失败，也会生成输出。默认情况下，仅在发生示例故障时才会生成输出。</p><p>可选参数<em>compileflags</em>给出了运行示例时应由Python编译器使用的一组标志。默认情况下，或者如果<code>None</code>，推导的标志对应于在<em>globs中</em>找到的一组未来特征。</p><p>可选参数<em>optionflags</em>与<code>testfile()</code>上面的函数一样。</p><h2 id="5-Unittest-API"><a href="#5-Unittest-API" class="headerlink" title="5. Unittest API"></a>5. Unittest API</h2><p>随着您的文档测试模块集合的增长，您需要一种系统地运行所有文档测试的方法。在Python 2.4之前，<code>doctest</code>有一个几乎没有文档记录的<code>Tester</code>类，它提供了一个基本方法来组合多个模块的doctests。<code>Tester</code>是虚弱的，实际上最严重的Python测试框架建立在<code>unittest</code>模块上，它提供了许多灵活的方法来结合多个来源的测试。所以，在Python 2.4，<code>doctest</code>的<code>Tester</code>类已被弃用，<code>doctest</code>提供了可用于创建两个函数<code>unittest</code>从模块和包含文档测试的文本文件的测试套件。要与<code>unittest</code>测试发现集成，<code>load_tests()</code>在您的测试模块中包含一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line"><span class="keyword">import</span> my_module_with_doctests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_tests</span><span class="params">(loader, tests, ignore)</span>:</span></span><br><span class="line">    tests.addTests(doctest.DocTestSuite(my_module_with_doctests))</span><br><span class="line">    <span class="keyword">return</span> tests</span><br></pre></td></tr></table></figure><p>有两个主要的功能可以用<code>unittest.TestSuite</code>文本文件和模块创建实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.DocFileSuite(*paths, [module_relative][, package][, setUp][, tearDown][, globs][, optionflags][, parser][, encoding])</span><br></pre></td></tr></table></figure><p>将doctest测试从一个或多个文本文件转换为<code>unittest.TestSuite</code>。</p><p>返回的<code>unittest.TestSuite</code>内容将由unittest框架运行并在每个文件中运行交互式示例。如果任何文件中的示例失败，则合成的单元测试将失败，并<code>failureException</code>引发异常，显示包含测试的文件的名称和一个（有时是近似的）行号。</p><p>将一个或多个路径（字符串）传递给要检查的文本文件。</p><p>选项可以作为关键字参数提供：</p><p>可选参数<em>module_relative</em>指定应如何解释<em>路径中</em>的文件名：</p><ul><li><p>如果<em>module_relative</em>是<code>True</code>（缺省值），则<em>路径</em>中的每个文件名指定与操作系统无关的模块相对路径。默认情况下，这个路径是相对于调用模块的目录; 但是如果指定了<em>package</em>参数，那么它与该包相关。为确保操作系统无关性，每个文件名应使用<code>/</code>字符来分隔路径段，并且可能不是绝对路径（即可能不以其开头<code>/</code>）。</p></li><li><p>如果<em>module_relative</em>是<code>False</code>，则<em>路径</em>中的每个文件名都指定一个OS特定的路径。路径可以是绝对的或相对的; 相对路径相对于当前工作目录被解析。</p></li></ul><p>可选参数<em>包</em>是Python包或Python包的名称，其目录应该用作<em>路径中</em>与模块相关的文件名的基本目录。如果未指定包，则调用模块的目录将用作模块相关文件名的基本目录。如果<em>module_relative</em>是指定<em>包，</em>那是<code>False</code>错误的。</p><p>可选参数<em>setUp</em>指定测试套件的设置函数。这在每个文件中运行测试之前被调用。该<em>的setUp</em>函数将被传递一个<code>DocTest</code>对象。setUp函数可以在测试的<em>globs</em>属性通过时访问测试全局变量。</p><p>可选参数<em>tearDown</em>指定测试套件的拆卸函数。这是在每个文件中运行测试后调用的。在<em>拆卸</em>会被传递给一个<code>DocTest</code>对象。setUp函数可以在测试的<em>globs</em>属性通过时访问测试全局变量。</p><p>可选参数<em>globs</em>是包含测试的初始全局变量的字典。每个测试都会创建一本新字典。默认情况下，<em>globs</em>是一个新的空字典。</p><p>可选参数<em>optionflags</em>指定测试的默认doctest选项，由各个选项标记组合或创建。请参见选项标志部分。请参阅<code>set_unittest_reportflags()</code>下面的功能以更好地设置报告选项。</p><p>可选参数<em>解析器</em>指定<code>DocTestParser</code>应该用于从文件中提取测试的一个（或子类）。它默认为一个普通的解析器（即，<code>DocTestParser()</code>）。</p><p>可选的参数<em>编码</em>指定应该用于将文件转换为unicode的编码。</p><p>2.4版本中的新功能。</p><p>在版本2.5中进行了更改：将全局<code>__file__</code>添加到提供给使用文本文件加载的文档测试的全局文件中<code>DocFileSuite()</code>。</p><p>在版本2.5中更改：添加了参数<em>编码</em>。</p><p>注意</p><p>不像<code>testmod()</code>和<code>DocTestFinder</code>，<code>ValueError</code>如果<em>模块不</em>包含文档字符串，该函数会引发一个问题。您可以通过传递一个<code>DocTestFinder</code>实例作为<em>test_finder</em>参数，并将其<em>exclude_empty</em>关键字参数设置为<code>False</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>finder = doctest.DocTestFinder(exclude_empty=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>suite = doctest.DocTestSuite(test_finder=finder)</span><br><span class="line">doctest.DocTestSuite([module][, globs][, extraglobs][, test_finder][, setUp][, tearDown][, checker])</span><br></pre></td></tr></table></figure><p>将模块的doctest测试转换为一个模块<code>unittest.TestSuite</code>。</p><p>返回的<code>unittest.TestSuite</code>是由unittest框架运行并在模块中运行每个doctest。如果有任何文档测试失败，则合成的单元测试失败，并<code>failureException</code>引发异常，显示包含测试的文件的名称和一个（有时是近似的）行号。</p><p>可选参数<em>模块</em>提供要测试的模块。它可以是一个模块对象或一个（可能点缀的）模块名称。如果未指定，则使用调用此函数的模块。</p><p>可选参数<em>globs</em>是包含测试的初始全局变量的字典。每个测试都会创建一本新字典。默认情况下，<em>globs</em>是一个新的空字典。</p><p>可选参数<em>extraglobs</em>指定一组额外的全局变量，这是合并成的<em>水珠</em>。默认情况下，不使用额外的全局变量。</p><p>可选参数<em>test_finder</em>是<code>DocTestFinder</code>用于从模块中提取doctests 的对象（或插入替换）。</p><p>可选参数<em>setUp</em>，<em>tearDown</em>和<em>optionflags</em>与<code>DocFileSuite()</code>上面的函数相同。</p><p>2.3版本的新功能。</p><p>在版本2.4中更改：添加了参数<em>globs</em>，<em>extraglobs</em>，<em>test_finder</em>，<em>setUp</em>，<em>tearDown</em>和<em>optionflags</em> ; 这个功能现在使用和。一样的搜索技术<code>testmod()</code>。</p><p>在幕后，<code>DocTestSuite()</code>创建<code>unittest.TestSuite</code>出的<code>doctest.DocTestCase</code>实例，<code>DocTestCase</code>是的子类<code>unittest.TestCase</code>。<code>DocTestCase</code>这里没有记录（这是一个内部细节），但是研究它的代码可以回答关于<code>unittest</code>集成确切细节的问题。</p><p>同样，<code>DocFileSuite()</code>创建<code>unittest.TestSuite</code>出的<code>doctest.DocFileCase</code>实例，<code>DocFileCase</code>是的子类<code>DocTestCase</code>。</p><p>因此创建<code>unittest.TestSuite</code>运行实例的两种方式<code>DocTestCase</code>。这对于一个微妙的原因很重要：当你<code>doctest</code>自己运行函数时，可以<code>doctest</code>通过将选项标志传递给<code>doctest</code>函数来直接控制正在使用的选项。但是，如果你正在编写一个<code>unittest</code>框架，<code>unittest</code>最终控制何时以及如何运行测试。框架作者通常希望控制<code>doctest</code>报表选项（可能例如由命令行选项指定），但是没有办法将选项传递<code>unittest</code>给<code>doctest</code>测试运行者。</p><p>出于这个原因，<code>doctest</code>还支持通过此功能支持<code>doctest</code>特定于<code>unittest</code>支持的报告标志的概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.set_unittest_reportflags(flags)</span><br></pre></td></tr></table></figure><p>设置<code>doctest</code>要使用的报告标志。</p><p>参数<em>标志</em>或一起选项标志。请参见选项标志部分。只能使用“报告标志”。</p><p>这是一个模块全局设置，并影响模块运行的所有将来的doctests <code>unittest</code>：在<code>DocTestCase</code>实例构建时查看为测试用例指定的选项标记<code>DocTestCase</code>的<code>runTest()</code>方法。如果没有指定报告的标志（这是典型的和预期的情况下），<code>doctest</code>的<code>unittest</code>报告标志是<a href="https://docs.python.org/2.7/reference/expressions.html#bitwise" target="_blank" rel="noopener">按位或运算</a>进入选项标志，因此增强选项标志传递给创建运行文档测试<code>DocTestRunner</code>实例。如果时指定的任何报告的标志例如构建<code>DocTestCase</code>，<code>doctest</code>的<code>unittest</code>报告标志被忽略。</p><p>在函数被调用之前生效的报告标志的值由函数返回<code>unittest</code>。</p><p>New in version 2.4.</p><h2 id="6-Advanced-API"><a href="#6-Advanced-API" class="headerlink" title="6. Advanced API"></a>6. Advanced API</h2><p>基本的API是一个简单的包装，旨在使doctest易于使用。它相当灵活，应该满足大多数用户的需求; 但是，如果您需要对测试进行更精细的控制，或者希望扩展doctest的功能，那么您应该使用高级API。</p><p>高级API围绕两个容器类进行，这两个容器类用于存储从doctest案例中提取的交互式示例：</p><ul><li><p><code>Example</code>：一个Python <a href="https://docs.python.org/2.7/glossary.html#term-statement" target="_blank" rel="noopener">语句</a>，与它的预期输出配对。</p></li><li><p><code>DocTest</code>：<code>Example</code>s 的集合，通常从单个文档字符串或文本文件中提取。</p></li></ul><p>定义其他处理类来查找，分析和运行，并检查doctest示例：</p><ul><li><p><code>DocTestFinder</code>：查找给定模块中的所有文档字符串，并使用<code>DocTestParser</code>a <code>DocTest</code>从包含交互式示例的每个文档字符串中创建一个。</p></li><li><p><code>DocTestParser</code>：<code>DocTest</code>从字符串中创建一个对象（例如对象的文档字符串）。</p></li><li><p><code>DocTestRunner</code>：执行<code>DocTest</code>中的例子，并使用一个<code>OutputChecker</code>来验证它们的输出。</p></li><li><p><code>OutputChecker</code>：将doctest示例中的实际输出与预期输出进行比较，并确定它们是否匹配。</p></li></ul><p>下图总结了这些处理类之间的关系：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                            list <span class="keyword">of</span>:</span><br><span class="line">+------+                   +---------+</span><br><span class="line">|<span class="built_in">module</span>| --DocTestFinder-&gt; | DocTest | --DocTestRunner-&gt; results</span><br><span class="line">+------+    |        ^     +---------+     |       ^    (printed)</span><br><span class="line">            |        |     | Example |     |       |</span><br><span class="line">            v        |     |   ...   |     v       |</span><br><span class="line">           DocTestParser   | Example |   OutputChecker</span><br><span class="line">                           +---------+</span><br></pre></td></tr></table></figure><h3 id="6-1-DocTest-Objects"><a href="#6-1-DocTest-Objects" class="headerlink" title="6.1. DocTest Objects"></a>6.1. DocTest Objects</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class doctest.DocTest(examples, globs, name, filename, lineno, docstring)</span><br></pre></td></tr></table></figure><p>应该在单个命名空间中运行的doctest示例的集合。构造函数参数用于初始化相同名称的属性。</p><p>2.4版本中的新功能。</p><p><code>DocTest</code>定义了以下属性。它们由构造函数初始化，不应该直接修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">examples</span><br></pre></td></tr></table></figure><p><code>Example</code>编码应该由此测试运行的各个交互式Python示例的对象列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">globs</span><br></pre></td></tr></table></figure><p>应该运行示例的名称空间（又称全局变量）。这是一个将名称映射到值的字典。<code>globs</code>在测试运行之后，示例所做的任何对名称空间的更改（例如绑定新变量）都会反映出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name</span><br></pre></td></tr></table></figure><p>一个字符串名称标识<code>DocTest</code>。通常，这是测试从中提取的对象或文件的名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename</span><br></pre></td></tr></table></figure><p>这<code>DocTest</code>是从中提取的文件的名称; 或者<code>None</code>如果文件名是未知的，或者如果<code>DocTest</code>没有从文件中提取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lineno</span><br></pre></td></tr></table></figure><p>行号在<code>filename</code>哪里<code>DocTest</code>开始，或<code>None</code>行号是否不可用。该行号相对于文件的开头是从零开始的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docstring</span><br></pre></td></tr></table></figure><p>从中提取测试<code>None</code>的字符串，或者字符串不可用，或者测试未从字符串中提取。</p><h3 id="6-2-示例对象"><a href="#6-2-示例对象" class="headerlink" title="6.2. 示例对象"></a>6.2. 示例对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class doctest.Example(source, want[, exc_msg][, lineno][, indent][, options])</span><br></pre></td></tr></table></figure><p>一个交互式示例，由Python语句及其预期输出组成。构造函数参数用于初始化相同名称的属性。</p><p>2.4版本中的新功能。</p><p><code>Example</code>定义了以下属性。它们由构造函数初始化，不应该直接修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source</span><br></pre></td></tr></table></figure><p>包含示例源代码的字符串。这个源代码由一个Python语句组成，并且总是以换行符结尾; 构造函数在必要时添加一个换行符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">want</span><br></pre></td></tr></table></figure><p>运行示例源代码的预期输出（来自标准输出，或者异常情况下的回溯）。<code>want</code>除非没有输出，否则以换行符结束，在这种情况下，它是一个空字符串。构造函数在必要时添加一个换行符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exc_msg</span><br></pre></td></tr></table></figure><p>该示例生成的异常消息，如果该示例预计会生成异常; 或者<code>None</code>如果不希望产生异常。该异常消息与返回值进行比较<code>traceback.format_exception_only()</code>。<code>exc_msg</code>除非是换行符，否则以换行符结尾<code>None</code>。如果需要，构造函数会添加一个换行符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lineno</span><br></pre></td></tr></table></figure><p>包含示例开始处的示例的字符串中的行号。该行号相对于包含字符串的开头是从零开始的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indent</span><br></pre></td></tr></table></figure><p>包含字符串中的示例缩进，即示例第一个提示之前的空格字符数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options</span><br></pre></td></tr></table></figure><p>从选项标记到<code>True</code>or的字典映射<code>False</code>，用于覆盖此示例的默认选项。任何未包含在此字典中的选项标志都保留默认值（由<code>DocTestRunner</code>s 指定<code>optionflags</code>）。默认情况下，不设置任何选项。</p><h3 id="6-3-DocTestFinder对象"><a href="#6-3-DocTestFinder对象" class="headerlink" title="6.3. DocTestFinder对象"></a>6.3. DocTestFinder对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">doctest</span>.<span class="title">DocTestFinder</span><span class="params">([verbose][, parser][, recurse][, exclude_empty])</span></span></span><br></pre></td></tr></table></figure><p>一个处理类，用于<code>DocTest</code>从文档字符串及其包含对象的文档字符串中提取与给定对象相关的s。<code>DocTest</code>s可以从下列对象类型中提取：模块，函数，类，方法，静态方法，类方法和属性。</p><p>可选参数<em>verbose</em>可用于显示查找器搜索的对象。它默认为<code>False</code>（不输出）。</p><p>可选参数<em>解析器</em>指定<code>DocTestParser</code>用于从文档字符串中提取文档测试的对象（或插入替换）。</p><p>如果可选参数<em>recurse</em>为false，那么<code>DocTestFinder.find()</code>将只检查给定的对象，而不检查任何包含的对象。</p><p>如果可选参数<em>exclude_empty</em>为false，<code>DocTestFinder.find()</code>则将包含具有空文档字符串的对象的测试。</p><p>2.4版本中的新功能。</p><p><code>DocTestFinder</code> 定义了以下方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find(obj[, name][, module][, globs][, extraglobs])</span><br></pre></td></tr></table></figure><p>返回<code>DocTest</code>由<em>obj</em>的文档字符串或其包含的任何对象的文档字符串定义的s 的列表。</p><p>可选参数<em>名称</em>指定对象的名称; 这个名字将被用来为返回的<code>DocTest</code>s 构造名字。如果没有指定<em>名称</em>，则<code>obj.__name__</code>使用。</p><p>可选参数<em>模块</em>是包含给定对象的模块。如果模块没有被指定或者是<code>None</code>，则测试发现者将尝试自动确定正确的模块。使用该对象的模块：</p><ul><li><p>作为默认命名空间，如果没有指定<em>globs</em>。</p></li><li><p>阻止DocTestFinder从其他模块导入的对象中提取DocTests。（包含模块以外的<em>模块的</em>包含对象将被忽略。）</p></li><li><p>查找包含该对象的文件的名称。</p></li><li><p>帮助查找文件中对象的行号。</p></li></ul><p>如果<em>模块</em>是<code>False</code>，则不会尝试找到该模块。这是很晦涩的，主要用于测试doctest本身：如果<em>module</em>是<code>False</code>，或者是<code>None</code>但不能自动找到，那么所有对象都被认为属于（不存在的）模块，因此所有包含的对象将（递归地）被搜索为doctests。</p><p>对于每个全局<code>DocTest</code>通过组合形成<em>水珠</em>和<em>extraglobs</em>（在绑定<em>extraglobs</em>倍率绑定在<em>水珠</em>）。为每个字典创建一个新的globals字典的浅表副本<code>DocTest</code>。如果未指定<em>globs</em>，则默认为模块的<strong>_dict</strong> <em>（如果已指定）或</em><code>*{}*</code><em>以其他方式指定。如果_extraglobs</em>没有被指定，那么它默认为<code>{}</code>。</p><h3 id="6-4-DocTestParser对象"><a href="#6-4-DocTestParser对象" class="headerlink" title="6.4. DocTestParser对象"></a>6.4. DocTestParser对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">doctest</span>.<span class="title">DocTestParser</span></span></span><br></pre></td></tr></table></figure><p>一个处理类，用于从字符串中提取交互式示例，并使用它们创建<code>DocTest</code>对象。</p><p>2.4版本中的新功能。</p><p><code>DocTestParser</code> 定义了以下方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_doctest(string, globs, name, filename, lineno)</span><br></pre></td></tr></table></figure><p>从给定的字符串中提取所有doctest示例，并将它们收集到一个<code>DocTest</code>对象中。</p><p><em>globs</em>，<em>name</em>，<em>filename</em>和<em>lineno</em>是新<code>DocTest</code>对象的属性。请参阅文档以<code>DocTest</code>获取更多信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_examples(string[, name])</span><br></pre></td></tr></table></figure><p>从给定的字符串中提取所有doctest示例，并将它们作为<code>Example</code>对象列表返回。行号是从0开始的。可选参数<em>名称</em>是标识此字符串的名称，仅用于错误消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parse(string[, name])</span><br></pre></td></tr></table></figure><p>将给定的字符串分成示例和干预文本，并将它们作为交替<code>Example</code>s和字符串的列表返回。<code>Example</code>s的行号是基于0的。可选参数<em>名称</em>是标识此字符串的名称，仅用于错误消息。</p><h3 id="6-5-DocTestRunner对象"><a href="#6-5-DocTestRunner对象" class="headerlink" title="6.5. DocTestRunner对象"></a>6.5. DocTestRunner对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class doctest.DocTestRunner([checker][, verbose][, optionflags])</span><br></pre></td></tr></table></figure><p>处理类用于执行和验证<code>DocTest</code>中的交互式示例。</p><p>预期产出与实际产出之间的比较由<code>OutputChecker</code>。这种比较可以用许多选项标志来定制; 有关更多信息，请参阅选项标志部分。如果选项标志不足，则可以通过<code>OutputChecker</code>向构造函数传递一个子类来定制比较。</p><p>测试运行者的显示输出可以通过两种方式进行控制。首先，可以传递一个输出函数<code>TestRunner.run()</code>; 这个函数将会被显示的字符串调用。它默认为<code>sys.stdout.write</code>。如果捕获的输出不充分，则显示输出也可以通过继承DocTestRunner，并覆盖方法定制<code>report_start()</code>，<code>report_success()</code>，<code>report_unexpected_exception()</code>，和<code>report_failure()</code>。</p><p>可选的关键字参数<em>检查器</em>指定<code>OutputChecker</code>应该用于比较预期输出与doctest示例的实际输出的对象（或插入替换）。</p><p>可选的关键字参数<em>verbose</em>控制着<code>DocTestRunner</code>冗长。如果<em>详细</em>是<code>True</code>，则会在每个示例运行时打印信息。如果<em>详细</em>是<code>False</code>，则只打印故障。如果<em>verbose</em>未指定，或者<code>None</code>使用详细输出，则使用命令行开关<code>-v</code>。</p><p>可选的关键字参数<em>optionflags</em>可用于控制测试运行器如何将预期输出与实际输出进行比较，以及它如何显示故障。有关更多信息，请参见选项标志部分。</p><p>2.4版本中的新功能。</p><p><code>DocTestParser</code> 定义了以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">report_start(out, test, example)</span><br></pre></td></tr></table></figure><p>报告测试运行人员即将处理给出的示例。提供此方法以允许其子类<code>DocTestRunner</code>定制其输出；它不应该直接调用。</p><p><em>例子</em>就是要处理的例子。<em>测试</em>是<em>包含示例</em>的测试。<em>out</em>是传递给的输出函数<code>DocTestRunner.run()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">report_success(out, test, example, got)</span><br></pre></td></tr></table></figure><p>报告给出的示例已成功运行。提供此方法以允许其子类<code>DocTestRunner</code>定制其输出；它不应该直接调用。</p><p><em>例子</em>就是要处理的例子。<em>得到的</em>是实例的实际输出。<em>测试</em>是包含<em>示例</em>的测试。<em>out</em>是传递给的输出函数<code>DocTestRunner.run()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">report_failure(out, test, example, got)</span><br></pre></td></tr></table></figure><p>报告给出的例子失败。提供此方法以允许其子类<code>DocTestRunner</code>定制其输出; 它不应该直接调用。</p><p><em>例子</em>就是要处理的例子。<em>得到的</em>是实例的实际输出。<em>测试</em>是包含<em>示例</em>的测试。<em>out</em>是传递给的输出函数<code>DocTestRunner.run()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">report_unexpected_exception(out, test, example, exc_info)</span><br></pre></td></tr></table></figure><p>报告给出的示例引发了意外的异常。提供此方法以允许其子类<code>DocTestRunner</code>定制其输出; 它不应该直接调用。</p><p><em>例子</em>就是要处理的例子。<em>exc_info</em>是包含有关意外异常（由返回的<code>sys.exc_info()</code>）的信息的元组。<em>测试</em>是包含<em>示例</em>的测试。<em>out</em>是传递给的输出函数<code>DocTestRunner.run()</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(test[, compileflags][, out][, clear_globs])</span><br></pre></td></tr></table></figure><p>运行在实施例中<em>测试</em>（一个<code>DocTest</code>对象），并使用写入器功能显示结果<em>出来</em>。</p><p>这些示例在命名空间中运行<code>test.globs</code>。如果<em>clear_globs</em>为true（缺省值），那么该名称空间将在测试运行后清除，以帮助进行垃圾回收。如果您想在测试完成后检查名称空间，请使用<em>clear_globs = False</em>。</p><p><em>compileflags</em>给出了运行示例时Python编译器应该使用的一组标志。如果未指定，则它将默认为适用于<em>globs</em>的future-import标志集。</p><p>每个示例的输出都使用<code>DocTestRunner</code>输出检查器进行检查，并且结果由这些<code>DocTestRunner.report_*()</code>方法进行格式化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">summarize([verbose])</span><br></pre></td></tr></table></figure><p>打印由此DocTestRunner运行的所有测试用例的摘要，并返回一个<a href="https://docs.python.org/2.7/glossary.html#term-named-tuple" target="_blank" rel="noopener">指定的元组</a> <code>TestResults(failed, attempted)</code>。</p><p>可选的<em>详细</em>参数控制摘要的详细程度。如果没有指定<code>DocTestRunner</code>详细程度，则使用冗长度。</p><p>在版本2.6中更改：使用命名的元组。</p><h3 id="6-6-OutputChecker对象"><a href="#6-6-OutputChecker对象" class="headerlink" title="6.6. OutputChecker对象"></a>6.6. OutputChecker对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class doctest.OutputChecker</span><br></pre></td></tr></table></figure><p>用于检查doctest示例的实际输出是否与预期输出匹配的类。<code>OutputChecker</code>定义了两种方法：<code>check_output()</code>，它比较给定的一对输出，如果匹配则返回真; 并<code>output_difference()</code>返回一个描述两个输出之间差异的字符串。</p><p>2.4版本中的新功能。</p><p><code>OutputChecker</code> 定义了以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">check_output(want, got, optionflags)</span><br></pre></td></tr></table></figure><p><code>True</code>如果示例（<em>got</em>）的实际输出与预期输出（<em>想要</em>）匹配，则返回。如果这些字符串相同，则始终认为它们匹配；但取决于测试运行器使用的选项标志，还可以使用几种非精确匹配类型。有关选项标志的更多信息，请参见选项标志部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output_difference(example, got, optionflags)</span><br></pre></td></tr></table></figure><p>返回一个字符串，描述给定示例（<em>示例</em>）的预期输出与实际输出（<em>获得</em>）之间的差异。<em>optionflags</em>是用来比较<em>想要</em>和<em>得到</em>的选项标志的集合。</p><h2 id="7-调试"><a href="#7-调试" class="headerlink" title="7.调试"></a>7.调试</h2><p>Doctest提供了几种调试doctest示例的机制：</p><ul><li><p>几个函数将doctests转换为可执行的Python程序，可以在Python调试器下运行<code>pdb</code>。</p></li><li><p><code>DebugRunner</code>类是的一个子类<code>DocTestRunner</code>的是提高用于第一故障的例子的异常，包含有关实施例的信息。该信息可用于对示例执行事后调试。</p></li><li><p><code>unittest</code>通过<code>DocTestSuite()</code>支持由<code>debug()</code>所定义的方法生成的案例<code>unittest.TestCase</code>。</p></li><li><p>您可以<code>pdb.set_trace()</code>在doctest示例中添加调用，并在执行该行时放入Python调试器。然后你可以检查变量的当前值，等等。例如，假设<code>a.py</code>只包含这个模块docstring：</p></li></ul><blockquote><p> “”” &gt;&gt;&gt; def f(x): …     g(x*2) &gt;&gt;&gt; def g(x): …     print x+3 …     import pdb; pdb.set_trace() &gt;&gt;&gt; f(3) 9 “”” </p></blockquote><p> 然后，一个交互式Python会话可能如下所示：</p><blockquote><p>import a, doctest &gt;&gt;&gt; doctest.testmod(a) –Return– &gt; <doctest a1>(3)g()-&gt;None -&gt; import pdb; pdb.set_trace() (Pdb) list   1     def g(x):   2         print x+3   3  -&gt;     import pdb; pdb.set_trace() EOF print x 6 (Pdb) step –Return– &gt; <doctest a0>(2)f()-&gt;None -&gt; g(x<em>2) (Pdb) list   1     def f(x):   2  -&gt;     g(x</em>2) EOF print x 3 (Pdb) step –Return– &gt; <doctest a2>(1)?()-&gt;None -&gt; f(3) (Pdb) cont (0, 3) &gt;&gt;&gt; </doctest></doctest></doctest></p></blockquote><p>  在版本2.4中进行了更改：<code>pdb.set_trace()</code>添加了在文档测试中使用有用的功能。</p><p>将doctests转换为Python代码的函数，并可能在调试器下运行综合代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.script_from_examples(s)</span><br></pre></td></tr></table></figure><p>将带有示例的文本转换为脚本。</p><p>参数<em>s</em>是一个包含doctest示例的字符串。该字符串被转换为Python脚本，其中<em>s</em>中的doctest示例转换为常规代码，其他所有内容都转换为Python注释。生成的脚本作为字符串返回。例如，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> doctest</span><br><span class="line"><span class="keyword">print</span> doctest.script_from_examples(<span class="string">r"""</span></span><br><span class="line"><span class="string">    Set x and y to 1 and 2.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y = 1, 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Print their sum:</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print x+y</span></span><br><span class="line"><span class="string">    3</span></span><br><span class="line"><span class="string">"""</span>)</span><br></pre></td></tr></table></figure><p>显示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set x and y to 1 and 2.</span></span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Print their sum:</span></span><br><span class="line"><span class="keyword">print</span> x+y</span><br><span class="line"><span class="comment"># Expected:</span></span><br><span class="line"><span class="comment">## 3</span></span><br></pre></td></tr></table></figure><p>该函数在其他函数的内部使用（请参见下文），但是当您想要将交互式Python会话转换为Python脚本时，该函数也很有用。</p><p>2.4版本中的新功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.testsource(module, name)</span><br></pre></td></tr></table></figure><p>将对象的doctest转换为脚本。</p><p>参数<em>模块</em>是一个模块对象，或者一个模块的虚线名称，包含其文档感兴趣的对象。参数<em>名称</em>是具有感兴趣的doctests的对象的名称（在模块内）。结果是一个字符串，包含对象的文档字符串转换为Python脚本，<code>script_from_examples()</code>如上所述。例如，如果模块<code>a.py</code>包含顶级函数<code>f()</code>，那么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> a, doctest</span><br><span class="line">print doctest.testsource(a, <span class="string">"a.f"</span>)</span><br></pre></td></tr></table></figure><p>打印函数<code>f()</code>的文档字符串的脚本版本，将文档转换为代码，其余部分放在注释中。</p><p>2.3版本的新功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.debug(module, name[, pm])</span><br></pre></td></tr></table></figure><p>调试对象的doctests。</p><p>该<em>模块</em>和<em>名称</em>参数是相同的功能<code>testsource()</code>之上。已命名对象的文档字符串的合成Python脚本被写入临时文件，然后该文件在Python调试器的控制下运行<code>pdb</code>。</p><p><code>module.__dict__</code>本地和全局执行上下文都使用浅表副本。</p><p>可选参数<em>pm</em>控制是否使用验尸调试。如果<em>pm</em>具有真值，则脚本文件将直接运行，并且仅当脚本通过引发未处理的异常终止时才会涉及调试器。如果确实如此，则通过<code>pdb.post_mortem()</code>从未处理的异常中传递回溯对象来调用验尸调试。如果<em>pm</em>没有被指定，或者是false，那么通过传递一个适当的<code>execfile()</code>调用来从脚本开始运行脚本<code>pdb.run()</code>。</p><p>2.3版本的新功能。</p><p>在版本2.4中更改：添加了<em>pm</em>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctest.debug_src(src[, pm][, globs])</span><br></pre></td></tr></table></figure><p>用字符串调试doctests。</p><p>这与<code>debug()</code>上面的函数类似，只是通过<em>src</em>参数直接指定了包含doctest示例的字符串。</p><p>可选参数<em>pm</em>与<code>debug()</code>上面的函数具有相同的含义。</p><p>可选的参数<em>globs</em>给出了一个字典，用作本地和全局执行上下文。如果未指定，或者<code>None</code>使用空字典。如果指定，则使用字典的浅表副本。</p><p>2.4版本中的新功能。</p><p><code>DebugRunner</code>级和特殊的例外可能提高，最感兴趣的测试框架的作者，并且只在这里勾勒。查看源代码，尤其<code>DebugRunner</code>是docstring（这是一个doctest！）以获取更多详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class doctest.DebugRunner([checker][, verbose][, optionflags])</span><br></pre></td></tr></table></figure><p>只要<code>DocTestRunner</code>遇到故障，它的一个子类就会引发异常。如果发生意外异常，则会引发<code>UnexpectedException</code>异常，包含测试，示例和原始异常。如果输出不匹配，则会<code>DocTestFailure</code>引发异常，包含测试，示例和实际输出。</p><p>有关构造函数参数和方法的信息，请参阅<code>DocTestRunner</code>高级API一节中的文档。</p><p><code>DebugRunner</code>实例可能会引发两个例外情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception doctest.DocTestFailure(test, example, got)</span><br></pre></td></tr></table></figure><p><code>DocTestRunner</code>表示doctest示例的实际输出与预期输出不符的异常。构造函数参数用于初始化相同名称的属性。</p><p><code>DocTestFailure</code> 定义了以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocTestFailure.test</span><br></pre></td></tr></table></figure><p><code>DocTest</code>示例失败时正在运行的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocTestFailure.example</span><br></pre></td></tr></table></figure><p><code>Example</code>失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocTestFailure.got</span><br></pre></td></tr></table></figure><p>示例的实际输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception doctest.UnexpectedException(test, example, exc_info)</span><br></pre></td></tr></table></figure><p>一个异常<code>DocTestRunner</code>提示表示doctest示例引发了意外异常。构造函数参数用于初始化相同名称的属性。</p><p><code>UnexpectedException</code> 定义了以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnexpectedException.test</span><br></pre></td></tr></table></figure><p><code>DocTest</code>示例失败时正在运行的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnexpectedException.example</span><br></pre></td></tr></table></figure><p><code>Example</code>失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnexpectedException.exc_info</span><br></pre></td></tr></table></figure><p>包含有关意外异常的信息的元组，返回的是<code>sys.exc_info()</code>。</p><h2 id="8-Soapbox"><a href="#8-Soapbox" class="headerlink" title="8. Soapbox"></a>8. Soapbox</h2><p>正如引言中提到的，<code>doctest</code>已经发展到三个主要用途：</p><ol><li>检查文档字符串中的示例。</li></ol><p>\2. 回归测试。</p><p>\3. 可执行文档/文字测试。</p><p>这些用途具有不同的要求，区分它们很重要。特别是，用不明确的测试用例填充文档字符串会导致错误的文档。</p><p>在编写文档字符串时，请小心选择文档字符串示例。有一个学问需要学习 - 起初可能并不自然。示例应该为文档增加真正的价值。一个很好的例子往往可以说很多话。如果谨慎处理，这些示例对您的用户来说将是非常宝贵的，并且会随着时间的推移和事情的变化而回报多次收集它们所需的时间。我仍然惊讶于我的一个<code>doctest</code>示例在“无害”更改后停止工作的频率。</p><p>Doctest也是回归测试的绝佳工具，特别是如果你不吝啬解释性文本。通过插入散文和例子，跟踪实际正在测试的内容以及为什么更容易。当一个测试失败时，好的散文可以使得更容易找出问题所在，以及应该如何解决问题。的确，您可以在基于代码的测试中编写大量的评论，但很少有程序员会这样做。许多人已经发现使用doctest方法会导致更清晰的测试。也许这只是因为doctest使编写散文比编写代码容易一些，而在代码中编写注释有点困难。我认为它比以上更深刻：编写基于doctest的测试时的自然态度是您想解释软件的优点，并用示例来说明它们。这反过来自然会导致以最简单的功能开始的测试文件，并在逻辑上进展到复杂性和边缘情况。一个连贯的叙述是结果，而不是一组孤立的函数，它们似乎随机地测试孤立的功能位。这是一种不同的态度，产生不同的结果，模糊了测试和解释之间的区别。</p><p>回归测试最好局限于专用对象或文件。有几种组织测试的选项：</p><ul><li><p>将包含测试用例的文本文件编写为交互式示例，并使用<code>testfile()</code>或测试这些文件<code>DocFileSuite()</code>。这是推荐的，尽管对于从一开始就使用doctest设计的新项目来说，这是最容易做到的。</p></li><li><p>定义名为<code>_regrtest_topic</code>包含单个文档字符串的函数，其中包含指定主题的测试用例。这些功能可以包含在与模块相同的文件中，或者分离到单独的测试文件中。</p></li><li><p>定义<code>__test__</code>从回归测试主题到包含测试用例的文档字符串的字典映射。</p></li></ul><p>当您将测试放入模块中时，模块本身可以成为测试运行者。当测试失败时，您可以安排测试运行者在调试问题时仅重新运行失败的doctest。这是一个这样的测试运行者的最小例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    flags = doctest.REPORT_NDIFF|doctest.REPORT_ONLY_FIRST_FAILURE</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">        name = sys.argv[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> globals():</span><br><span class="line">            obj = globals()[name]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            obj = __test__[name]</span><br><span class="line">        doctest.run_docstring_examples(obj, globals(), name=name,</span><br><span class="line">                                       optionflags=flags)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fail, total = doctest.testmod(optionflags=flags)</span><br><span class="line">        print(<span class="string">"&#123;&#125; failures out of &#123;&#125; tests"</span>.format(fail, total))</span><br></pre></td></tr></table></figure><h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><p>不支持包含预期输出和异常的示例。试图猜测一个结束和另一个开始的地方太容易出错，这也会导致一个令人困惑的测试。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-doctest&quot;&gt;&lt;a href=&quot;#python-标准库-doctest&quot; class=&quot;headerlink&quot; title=&quot;python  标准库 doctest&quot;&gt;&lt;/a&gt;python  标准库 doctest&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200316_westworld_3.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="doctest" scheme="https://pinghailinfeng.gitee.io/tags/doctest/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library Tkinter</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/14/python-standard-library-Tkinter/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/14/python-standard-library-Tkinter/</id>
    <published>2020-03-14T13:17:11.000Z</published>
    <updated>2020-03-15T03:49:19.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-Tkinter"><a href="#python-标准库-Tkinter" class="headerlink" title="python 标准库 Tkinter"></a>python 标准库 Tkinter</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200314_what_is_friends_mean_to_u.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>what life should mean to you ?</p><p>推荐这本书 中文版 翻译为：自卑与超越</p></blockquote><p>该<code>Tkinter</code>模块（“Tk接口”）是Tk GUI工具包的标准Python接口。Tk和<code>Tkinter</code>在大多数Unix平台以及Windows系统上均可用。（Tk本身不是Python的一部分;它保存在ActiveState中。）</p><p>注意</p><p><code>Tkinter</code>已被重新命名为<code>tkinter</code>Python 3. 当将源代码转换为Python 3时，<a href="https://docs.python.org/2.7/glossary.html#term-2to3" target="_blank" rel="noopener">2to3</a>工具将自动适应导入。</p><p>扩展内容</p><p> <a href="https://wiki.python.org/moin/TkInter" target="_blank" rel="noopener">Python Tkinter资源</a> Python Tkinter主题指南提供了大量关于从Python使用Tk和链接到Tk上的其他信息源的信息。<a href="http://www.tkdocs.com/" target="_blank" rel="noopener">TKDocs</a>广泛的教程和一些小部件的更友好的小部件页面。<a href="https://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html" target="_blank" rel="noopener">Tkinter参考：用于Python的GUI</a>在线参考资料。<a href="http://effbot.org/tkinterbook/" target="_blank" rel="noopener">来自effbot的Tkinter文档由effbot.org</a>支持的tkinter的在线参考。<a href="https://www.tcl.tk/man/tcl8.5/" target="_blank" rel="noopener">Tcl / Tk手册</a>最新tcl / tk版本的官方手册。由Mark Lutz <a href="http://learning-python.com/books/about-pp4e.html" target="_blank" rel="noopener">编写的Python</a>书籍，对Tkinter有很好的报道。<a href="http://www.amazon.com/Modern-Tkinter-Python-Developers-ebook/dp/B0071QDNLO/" target="_blank" rel="noopener">繁忙Python开发人员的现代Tkinter</a>由Mark Rozerman撰写关于用Python和Tkinter构建具有吸引力和现代化图形用户界面的内容。<a href="https://www.manning.com/books/python-and-tkinter-programming" target="_blank" rel="noopener">Python和Tkinter编程</a> John Grayson的书（ISBN 1-884777-81-3）。  </p><h2 id="1-Tkinter模块"><a href="#1-Tkinter模块" class="headerlink" title="1. Tkinter模块"></a>1. Tkinter模块</h2><p>大多数情况下，<code>Tkinter</code>模块都是您真正需要的，但也有一些额外的模块可供选择。Tk接口位于名为的二进制模块中<code>_tkinter</code>。该模块包含Tk的底层接口，不应直接由应用程序员使用。它通常是共享库（或DLL），但在某些情况下可能会与Python解释器静态链接。</p><p>除了Tk接口模块外，<code>Tkinter</code>还包括许多Python模块。两个最重要的模块是<code>Tkinter</code>模块本身，还有一个模块叫做<code>Tkconstants</code>。前者自动导入后者，所以要使用Tkinter，你只需要导入一个模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Tkinter</span><br></pre></td></tr></table></figure><p>或者更经常地：</p><figure class="highlight plain"><figcaption><span>Tkinter import *</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Tkinter.Tk(screenName=None, baseName=None, className=&apos;Tk&apos;, useTk=1)</span><br></pre></td></tr></table></figure><p>将<code>Tk</code>类实例化没有参数。这会创建一个Tk的顶层小部件，它通常是应用程序的主窗口。每个实例都有自己关联的Tcl解释器。</p><p>在版本2.4中更改：添加了<em>useTk</em>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tkinter.Tcl(screenName=None, baseName=None, className=&apos;Tk&apos;, useTk=0)</span><br></pre></td></tr></table></figure><p>该<code>Tcl()</code>函数是一个工厂函数<code>Tk</code>，除了不初始化Tk子系统外，它创建的对象非常类似于该类创建的对象。在不希望创建无关的顶层窗口的环境中，或者在无法（如没有X服务器的Unix / Linux系统）环境中驱动Tcl解释器时，这通常很有用。由对象创建的<code>Tcl()</code>对象可以通过调用其<code>loadtk()</code>方法创建Toplevel窗口（并初始化Tk子系统）。</p><p>2.4版本中的新功能。</p><p>其他提供Tk支持的模块包括：</p><p>ScrolledTextText小部件，内置一个垂直滚动条in.tkColorChooserDialog，让用户选择一个color.tkCommonDialogBase类，用于在这里列出的其他模块中定义的对话框。tkFileDialogCommon对话框允许用户指定要打开的文件或save.tkFontUtilities以帮助 使用fonts.tkMessageBoxAccess来标准Tk对话框boxes.tkSimpleDialogBasic对话框和便捷函数.Tkdnd拖放支持Tkinter。 这是实验性的，当它在Tk窗口中用Tk DND.turtleTurtle图形取代时应该被弃用。</p><p>这些已经在Python 3中重新命名了; 他们都是新<code>tkinter</code>包装的子模块。</p><h2 id="2-Tkinter救生员系统"><a href="#2-Tkinter救生员系统" class="headerlink" title="2. Tkinter救生员系统"></a>2. Tkinter救生员系统</h2><p>本节不是为Tk或Tkinter的详尽教程而设计的。相反，它旨在作为一个制止差距，为系统提供一些入门指导。</p><p>Credits:</p><ul><li><p>Tkinter由Steen Lumholt和Guido van Rossum撰写。</p></li><li><p>Tk由John Ousterhout在伯克利书写。</p></li><li><p>这个Life Preserver 是由弗吉尼亚大学的马特康威编写的。</p></li><li><p>HTML渲染和一些自由编辑是由Ken Manheimer的FrameMaker版本生成的。</p></li><li><p>Fredrik Lundh详细阐述并修改了类接口描述，以使它们与Tk 4.2一致。</p></li><li><p>Mike Clarkson将文档转换为LaTeX，并编译了参考手册的用户界面章节。</p></li></ul><h3 id="2-1-如何使用本节"><a href="#2-1-如何使用本节" class="headerlink" title="2.1 如何使用本节"></a>2.1 如何使用本节</h3><p>本部分分为两部分：前半部分（大致）包含背景材料，后半部分可作为便于参考的键盘。</p><p>当试图回答“我该怎么做”这个形式的问题时，通常最好找出如何在直接Tk中做“无用”，然后将其转换回相应的<code>Tkinter</code>呼叫。Python程序员通常可以通过查看Tk文档来猜测正确的Python命令。这意味着为了使用Tkinter，你必须知道一些关于Tk的知识。这个文件不能完成这个角色，所以我们能做的最好的事情就是向您提供最好的文档。以下是一些提示：</p><ul><li><p>作者强烈建议获取Tk手册页的副本。具体来说，<code>mann</code>目录中的手册页是最有用的。该<code>man3</code>手册页介绍了C接口Tk库，因此不为脚本编写者特别有用。</p></li><li><p>Addison-Wesley出版了一本名为Tcl的书和John Ousterhout的Tk Toolkit（ISBN 0-201-63337-X），这是对新手Tcl和Tk的一个很好的介绍。这本书并非详尽无遗，对于许多细节，它都遵循手册页。</p></li><li><p><code>Tkinter.py</code> 对大多数人来说是最后的选择，但如果没有其他任何意义的话，它可能是一个很好的去处。</p></li></ul><p>扩展内容</p><p> <a href="http://tcl.activestate.com/" target="_blank" rel="noopener">ActiveState Tcl主页</a> Tk / Tcl开发主要发生在ActiveState上。<a href="http://www.amazon.com/exec/obidos/ASIN/020163337X" target="_blank" rel="noopener">Tcl和Tk工具包</a> Tcl的发明人John Ousterhout的书。<a href="http://www.beedub.com/book/" target="_blank" rel="noopener">Tcl和Tk中的实用编程</a> Brent Welch的百科全书。  </p><h3 id="2-2-一个简单的Hello-World程序"><a href="#2-2-一个简单的Hello-World程序" class="headerlink" title="2.2  一个简单的Hello World程序"></a>2.2  一个简单的Hello World程序</h3><figure class="highlight plain"><figcaption><span>import *</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Application(Frame):</span><br><span class="line">    def say_hi(self):</span><br><span class="line">        print &quot;hi there, everyone!&quot;</span><br><span class="line"></span><br><span class="line">    def createWidgets(self):</span><br><span class="line">        self.QUIT = Button(self)</span><br><span class="line">        self.QUIT[&quot;text&quot;] = &quot;QUIT&quot;</span><br><span class="line">        self.QUIT[&quot;fg&quot;]   = &quot;red&quot;</span><br><span class="line">        self.QUIT[&quot;command&quot;] =  self.quit</span><br><span class="line"></span><br><span class="line">        self.QUIT.pack(&#123;&quot;side&quot;: &quot;left&quot;&#125;)</span><br><span class="line"></span><br><span class="line">        self.hi_there = Button(self)</span><br><span class="line">        self.hi_there[&quot;text&quot;] = &quot;Hello&quot;,</span><br><span class="line">        self.hi_there[&quot;command&quot;] = self.say_hi</span><br><span class="line"></span><br><span class="line">        self.hi_there.pack(&#123;&quot;side&quot;: &quot;left&quot;&#125;)</span><br><span class="line"></span><br><span class="line">    def __init__(self, master=None):</span><br><span class="line">        Frame.__init__(self, master)</span><br><span class="line">        self.pack()</span><br><span class="line">        self.createWidgets()</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">app = Application(master=root)</span><br><span class="line">app.mainloop()</span><br><span class="line">root.destroy()</span><br></pre></td></tr></table></figure><h2 id="3-（非常）快速浏览Tcl-Tk"><a href="#3-（非常）快速浏览Tcl-Tk" class="headerlink" title="3. （非常）快速浏览Tcl / Tk"></a>3. （非常）快速浏览Tcl / Tk</h2><p>类层次结构看起来很复杂，但实际上，应用程序员几乎总是引用层次结构底部的类。</p><p>注意：</p><ul><li><p>提供这些类是为了在一个命名空间下组织某些功能。它们不是要独立实例化的。</p></li><li><p>该<code>Tk</code>类，就是要在应用程序中只有一次实例化。应用程序员不需要明确地实例化一个实例，只要有任何其他类实例化，系统就会创建一个。</p></li><li><p>这个<code>Widget</code>类不意味着被实例化，它只是意味着子类化才能生成“真实”的小部件（在C ++中，这被称为“抽象类”）。</p></li></ul><p>为了使用这个参考资料，有时候您需要知道如何阅读Tk的简短段落以及如何识别Tk命令的各个部分。（请参阅将Tk的基本Tk映射到Tkinter中，<code>Tkinter</code>以了解下面的内容。）</p><p>Tk脚本是Tcl程序。像所有的Tcl程序一样，Tk脚本只是由空格分隔的令牌列表。传统知识小部件就是它的<em>类</em>的<em>选项</em>，帮助配置，和<em>行动</em>，使人们做有用的事情。</p><p>要在Tk中创建一个小部件，该命令始终是以下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpythond newPathname options</span><br></pre></td></tr></table></figure><p>classCommand_表示要制作哪种小部件（按钮，标签，菜单…）_ newPathname_是此小部件的新名称。 Tk中的所有名称都必须是唯一的。 为了帮助执行此操作，Tk中的窗口小部件以_pathnames命名，就像文件系统中的文件一样。 调用顶级小部件root。 （期间）和孩子被更多的时期划定界限。 例如，.myApp.controlPanel.okButton可能是一个窗口小部件的名称._options_configure窗口小部件的外观，在某些情况下，它的行为。 选项以标志和值列表的形式出现。 标志前面有一个’ - ‘，就像Unix shell命令标志一样，并且如果值超过一个单词，则会将值放在引号中。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buttopython  -fg red -text <span class="string">"hi there"</span></span><br><span class="line">   ^       ^     \_____________________/</span><br><span class="line">   |       |                |</span><br><span class="line"> <span class="class"><span class="keyword">class</span>    <span class="title">new</span>            <span class="title">options</span></span></span><br><span class="line"><span class="class"><span class="title">command</span>  <span class="title">widget</span>  <span class="params">(-opt val -opt val ...)</span></span></span><br></pre></td></tr></table></figure><p>一旦创建，小部件的路径名变成新命令。这个新的<em>Widget命令</em>是程序员获取新Widget执行某些<em>操作</em>的句柄。在C语言中，你可以用C ++表示它为someAction（fred，someOptions），你可以将它表示为fred.someAction（someOptions），在Tk中，你会说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.fred sompythonmeOptions</span><br></pre></td></tr></table></figure><p>请注意，对象名称.fred以点开头。</p><p>正如你所期望的那样，someAction的合法值将取决于窗口部件的类：.fred禁用如果fred是一个按钮（fred变灰），但不起作用，但如果fred是标签，则不起作用（不支持禁用标签 在Tk）。</p><p>someOptions的合法价值取决于行动。 某些操作（如disable）不需要参数，其他操作（如文本输入框的delete命令）需要参数来指定要删除的文本范围。</p><h2 id="4-将Tk映射到Tkinter"><a href="#4-将Tk映射到Tkinter" class="headerlink" title="4.将Tk映射到Tkinter"></a>4.将Tk映射到Tkinter</h2><p>Tk中的类命令对应于Tkinter中的类构造函数。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button .fred python     =====&gt;  fred = Button()</span><br></pre></td></tr></table></figure><p>对象的主对象隐含在创建时给它的新名称中。在Tkinter中，明确指定了主人。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button .panel.frepython =====&gt;  fred = Button(panel)</span><br></pre></td></tr></table></figure><p>Tk中的配置选项在带有数值的紧跟标签列表中给出。在Tkinter中，选项在实例构造函数中被指定为关键字参数，在配置调用中被指定为keyword-args，或者在字典样式中被指定为已建立实例的实例索引。请参见设置选项中的设置选项部分。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button .fred -fg red python==&gt;  fred = Button(panel, fg = "red")</span><br><span class="line">.fred configure -fg red     =====&gt;  fred["fg"] = red</span><br><span class="line">                            OR ==&gt;  fred.config(fg = "red")</span><br></pre></td></tr></table></figure><p>在Tk中，要在小部件上执行操作，请使用小部件名称作为命令，然后使用操作名称，可能带有参数（选项）。在Tkinter中，您可以调用类实例上的方法来调用窗口小部件上的操作。Tkinter.py模块中列出了给定小部件可以执行的动作（方法）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.fred invoke             python fred.invoke()</span><br></pre></td></tr></table></figure><p>要给封装器（几何管理器）提供一个小部件，可以使用可选参数调用封装。在Tkinter中，Pack类拥有所有这些功能，并且各种形式的pack命令都作为方法实现。所有的小部件<code>Tkinter</code>都是从Packer中分类出来的，因此继承了所有的打包方法。有关<code>Tix</code>表格几何管理器的其他信息，请参阅模块文档。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pack .fred -side left       =pythond.pack(side = <span class="string">"left"</span>)</span><br></pre></td></tr></table></figure><h2 id="5-Tk和Tkinter是如何相关的"><a href="#5-Tk和Tkinter是如何相关的" class="headerlink" title="5. Tk和Tkinter是如何相关的"></a>5. Tk和Tkinter是如何相关的</h2><p>从上到下：</p><p>你的应用程序在这里（Python）一个Python应用程序进行<code>Tkinter</code>调用.Tkinter（Python模块）这个调用（例如，创建一个按钮控件）在<em>Tkinter</em>模块中实现，该模块是用Python编写的。这个Python函数将解析命令和参数并将它们转换为一种形式，使它们看起来好像它们来自Tk脚本而不是Python脚本.tkinter（C）这些命令及其参数将传递给C在<em>tkinter</em>中的<em>功能</em> - 注意小写 - 扩展模块.Tk Widgets（C和Tcl）这个C函数可以调用其他C模块，包括组成Tk库的C函数。Tk在C和一些Tcl中实现。Tk小部件的Tcl部分用于将某些默认行为绑定到小部件，并且在<code>Tkinter</code>导入Python 模块的位置执行一次。（用户从不会看到这个阶段）.Tk（C）Tk Widgets的Tk部分实现了最终映射到… Xlib（C）Xlib库在屏幕上绘制图形。</p><h2 id="6-方便的参考"><a href="#6-方便的参考" class="headerlink" title="6.方便的参考"></a>6.方便的参考</h2><h3 id="6-1-设置选项"><a href="#6-1-设置选项" class="headerlink" title="6.1  设置选项"></a>6.1  设置选项</h3><p>选项控制一些东西，比如一个小部件的颜色和边框宽度。选项可以通过三种方式设置：</p><p>在创建对象时，使用关键字参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fred = Button(self, fg = <span class="string">"red"</span>, bpython)</span><br></pre></td></tr></table></figure><p>创建对象后，将选项名称视为字典索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fred[<span class="string">"fg"</span>] = <span class="string">"red"</span></span><br><span class="line">fred[<span class="string">"bg"</span>] = <span class="string">"bluepythononfig（）方法更新对象创建后的多个attrs</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">​```python</span></span><br><span class="line"><span class="string">fred.config(fg = "</span>red<span class="string">", bg = "</span>blue<span class="string">")</span></span><br></pre></td></tr></table></figure><p>python为的完整说明，请参阅相关Widget的Tk手册页。</p><p>请注意，手册页列出了每个窗口小部件的“标准选项”和“小部件特定选项”。前者是许多小部件通用的选项列表，后者是特定小部件特有的选项。标准选项记录在<em>选项（3）</em>手册页上。</p><p>本文档没有区分标准和特定于窗口小部件的选项。有些选项不适用于某些类型的小部件。给定小部件是否响应特定选项取决于小部件的类别; 按钮有一个<code>command</code>选项，标签没有。</p><p>给定小部件支持的选项列在该小部件的手册页中，或者可以在运行时通过调用<code>config()</code>没有参数的方法或通过调用该<code>keys()</code>小部件上的方法来查询。这些调用的返回值是一个字典，其中的键是作为字符串（例如，<code>&#39;relief&#39;</code>）的选项的名称，其值是5元组。</p><p>一些选项，如bg是长名称的常见选项的同义词（bg是“背景”的简写）。 传递config（）方法的简写选项的名称将返回一个2元组，而不是5元组。 传回的2元组将包含同义词的名称和“真实”选项（例如（’bg’，’background’））。</p><table><thead><tr><th style="text-align:left">指数</th><th style="text-align:left">含义</th><th style="text-align:left">例</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">选项名称</td><td style="text-align:left">‘relief’</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">数据库查找的选项名称</td><td style="text-align:left">‘relief’</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">选项类用于数据库查找</td><td style="text-align:left">‘relief’</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">默认值</td><td style="text-align:left">‘raised’</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">当前值</td><td style="text-align:left">‘groove’</td></tr></tbody></table><p>例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> fred.config()</span><br><span class="line">&#123;<span class="string">'relief'</span>: (<span class="string">'relief'</span>,python <span class="string">'Relief'</span>, <span class="string">'raised'</span>, <span class="string">'groove'</span>)&#125;</span><br></pre></td></tr></table></figure><p>当然，打印的字典将包括所有可用选项及其值。这只是作为一个例子。</p><h3 id="6-2-包装工"><a href="#6-2-包装工" class="headerlink" title="6.2 包装工"></a>6.2 包装工</h3><p>封隔器是Tk的几何管理机制之一。几何管理器用于指定小部件在其容器中的定位的相对位置 - 它们是相互的<em>主人</em>。相较于较为繁琐<em>placer</em>（用于不常用，我们在这里不介绍），封隔器采用定性关系规范- <em>above</em>, <em>to the left of</em>, <em>filling</em>等等-和工作的一切，以确定确切位置坐标为你。</p><p>任何<em>主</em>控件的大小由内部“从控件”的大小决定。打包器用于控制从站窗口小部件在其打包的主站内出现的位置。您可以将窗口小部件封装到框架中，并将框架封装到其他框架中，以实现您所需的布局。此外，这种安排是动态调整的，以适应配置的增量变化，一旦打包完成。</p><p>请注意，窗口小部件在用几何管理器指定几何图形之前不会显示。忽略几何规格是一个常见的早期错误，然后在创建小部件时会感到惊讶，但没有任何内容出现。例如，小部件只有在<code>pack()</code>应用打包器的方法后才会出现。</p><p>可以使用关键字选项/值对调用pack（）方法，该对控制了窗口小部件出现在其容器中的位置，以及在主应用程序窗口调整大小时的行为方式。这里有些例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fred.pack()                     <span class="comment"># defaults to sidpythonfred.pack(side = "left")</span></span><br><span class="line">fred.pack(expand = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="6-3-封装选项"><a href="#6-3-封装选项" class="headerlink" title="6.3  封装选项"></a>6.3  封装选项</h3><p>有关打包机的更多信息及其可以选择的选项，请参阅John Ousterhout书中的手册页和第183页。</p><p>anchorAnchor类型。 表示封装器将每个从器件放置在parcel.expandBoolean，0或1.fillLegal值中的位置：’x’，’y’，’both’，’none’.ipadx和ipadyA distance - 指定每个从器件的内部填充 从属widget.padx和padyA距离 - 指定从属widget的每边的外部填充。sideLegal值为：’left’，’right’，’top’，’bottom’。</p><h3 id="6-4-耦合小部件变量"><a href="#6-4-耦合小部件变量" class="headerlink" title="6.4  耦合小部件变量"></a>6.4  耦合小部件变量</h3><p>某些小部件（如文本输入小部件）的当前值设置可以通过使用特殊选项直接连接到应用程序变量。 这些选项是可变的，文本变量，onvalue，offvalue和值。 这种连接可以两种方式工作：如果变量因任何原因而变化，它所连接的小部件将被更新以反映新值。</p><p>不幸的是，在Tkinter的当前实现中，不可能通过变量或文本变量选项将任意Python变量移交给小部件。 这个变量的唯一类型是从Tkinter模块中定义的类变量中分类的变量。</p><p>已经定义了许多有用的变量的子类：StringVar，IntVar，DoubleVar和BooleanVar。 要读取此变量的当前值，请调用get（）方法，并更改其值，您可以调用set（）方法。 如果你遵循这个协议，那么这个小部件将总是跟踪这个变量的值，而不需要你做进一步的干预。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span><span class="params">(Frame)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, master=None)</span><span class="title">pythonFrame</span>.<span class="title">__init__</span><span class="params">(self, master)</span></span></span><br><span class="line"><span class="function">        <span class="title">self</span>.<span class="title">pack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">        self.entrythingy = Entry()</span><br><span class="line">        self.entrythingy.pack()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># here is the application variable</span></span><br><span class="line">        self.contents = StringVar()</span><br><span class="line">        <span class="comment"># set it to some value</span></span><br><span class="line">        self.contents.set(<span class="string">"this is a variable"</span>)</span><br><span class="line">        <span class="comment"># tell the entry widget to watch this variable</span></span><br><span class="line">        self.entrythingy[<span class="string">"textvariable"</span>] = self.contents</span><br><span class="line"></span><br><span class="line">        <span class="comment"># and here we get a callback when the user hits return.</span></span><br><span class="line">        <span class="comment"># we will have the program print out the value of the</span></span><br><span class="line">        <span class="comment"># application variable when the user hits return</span></span><br><span class="line">        self.entrythingy.bind(<span class="string">'&lt;Key-Return&gt;'</span>,</span><br><span class="line">                              self.print_contents)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_contents</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"hi. contents of entry is now ----&gt;"</span>, \</span><br><span class="line">              self.contents.get()</span><br></pre></td></tr></table></figure><h3 id="6-5-窗口管理器"><a href="#6-5-窗口管理器" class="headerlink" title="6.5  窗口管理器"></a>6.5  窗口管理器</h3><p>在Tk中，有一个实用程序命令wm用于与窗口管理器交互。 wm命令的选项允许您控制标题，位置，图标位图等。 在Tkinter中，这些命令已经作为Wm类的方法实现。 Toplevel小部件从Wm类中继承，因此可以直接调用Wm方法。</p><p>要查看包含给定窗口小部件的顶层窗口，通常可以引用窗口小部件的主窗口。当然，如果这个小部件已经被封装在一个框架内，那么这个主框架将不会代表一个顶层窗口。要访问包含任意小部件的顶级窗口，可以调用该<code>_root()</code>方法。该方法以下划线开头，表示这个函数是实现的一部分，而不是Tk功能的接口。</p><p>以下是一些典型用法的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span><span class="params">(Frame)</span>:</span></span><br><span class="line">    def __inipythonmaster=None):</span><br><span class="line">        Frame.__init__(self, master)</span><br><span class="line">        self.pack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># create the application</span></span><br><span class="line">myapp = App()</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># here are method calls to the window manager class</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">myapp.master.title(<span class="string">"My Do-Nothing Application"</span>)</span><br><span class="line">myapp.master.maxsize(<span class="number">1000</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># start the program</span></span><br><span class="line">myapp.mainloop()</span><br></pre></td></tr></table></figure><h3 id="6-6-Tk选项数据类型"><a href="#6-6-Tk选项数据类型" class="headerlink" title="6.6 Tk选项数据类型"></a>6.6 Tk选项数据类型</h3><p>anchorLegal值是指南针的点：“n”，“ne”，“e”，“se”，“s”，“sw”，“w”，“nw”以及“center”.bitmap有八个 -in，命名位图：<code>&#39;error&#39;</code>, <code>&#39;gray25&#39;</code>, <code>&#39;gray50&#39;</code>, <code>&#39;hourglass&#39;</code>, <code>&#39;info&#39;</code>, <code>&#39;questhead&#39;</code>, <code>&#39;question&#39;</code>, <code>&#39;warning&#39;</code>。 要指定一个X位图文件名，给出该文件的完整路径，前面带@，如“@ / usr / contrib / bitmap / gumby.bit”.boolean您可以传递整数0或1或字符串“yes”或“不”.callback</p><p>这是任何不带参数的Python函数。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_it</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"hi there"</span></span><br><span class="line">fred[<span class="string">"command"</span>] = print_it</span><br></pre></td></tr></table></figure><p>colorColors可以作为rgb.txt文件中X颜色的名称，或以4位表示RGB值的字符串形式给出：“#RGB”，8位：“#RRGGBB”，12位“#RRRGGGBBB”或16位位“#RRRRGGGGBBBB”范围，其中R，G，B在这里表示任何合法的十六进制数字。有关详细信息，请参阅Ousterhout书籍的第160页.cursor可以使用cursorfont.h中的标准X光标名称，而不使用XC_前缀。例如，要获得手形光标（XC_hand2），请使用字符串“hand2”。你也可以指定你自己的位图和掩码文件。请参阅Ousterhout书的第179页。距离可以在像素或绝对距离中指定屏幕距离。像素以数字和绝对距离作为字符串给出，尾部字符表示单位：c表示厘米，i表示英寸，m表示毫米，p表示打印机的点数。例如，3.5英寸表示为“3.5i”.fontTk使用列表字体名称格式，例如{courier 10 bold}。正数的字体大小以点为单位;尺寸为负数的尺寸以pixels.geometry度量。这是一个widthxheight形式的字符串，其中宽度和高度以像素为单位测量大多数小部件（显示文本的小部件的字符数）。例如：fred [“geometry”] =“200x100”.justifyLegal 值是字符串：“left”，“center”，“right”和“fill”.region这是一个带有四个空格分隔元素的字符串，这是一个合法的距离（见上文）。例如：“2 3 4 5”和“3i 2i 4.5i 2i”和“3c 2c 4c 10.4c”都是合法的区域.relief确定小部件的边框样式。合法值是：<code>&quot;raised&quot;</code>, <code>&quot;sunken&quot;</code>, <code>&quot;flat&quot;</code>, <code>&quot;groove&quot;</code>与 <code>&quot;ridge&quot;</code>.scrollcommand这几乎总是某个滚动条小部件的set（）方法，但可以是任何只有一个参数的小部件方法。例如，请参阅Python源代码分发中的Demo / tkinter / matt / canvas-with-scrollbars.py文件.wrap：必须是“none”，“char”或“word”中的一个。</p><h3 id="6-7-绑定和事件"><a href="#6-7-绑定和事件" class="headerlink" title="6.7 绑定和事件"></a>6.7 绑定和事件</h3><p>通过widget命令的绑定方法，您可以监视某些事件并在发生该事件类型时触发回调函数。绑定方法的形式是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bind</span><span class="params">(self, sequence, func, add=<span class="string">''</span>)</span>:</span></span><br></pre></td></tr></table></figure><p>如下：</p><p>sequence是一个表示事件目标类型的字符串。 （有关详细信息，请参阅John Ousterhout书中的绑定手册页和第201页）。当事件发生时，调用一个带有一个参数的Python函数。 一个Event实例将作为参数传递。 （以这种方式部署的函数通常称为回调。）addis可选，可以是’’或’+’。 传递一个空字符串表示这个绑定是要替换这个事件关联的任何其他绑定。 传递’+’意味着此函数将被添加到绑定到此事件类型的函数列表中。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def turnRed(self, event):</span><br><span class="line">    event.widget[<span class="string">"activeforeground"</span>] = <span class="string">"red"</span></span><br><span class="line"></span><br><span class="line">self.button.bind(<span class="string">"&lt;Enter&gt;"</span>, self.turnRed)</span><br></pre></td></tr></table></figure><p>注意事件的widget字段在turnRed（）回调中被访问。 该字段包含捕获X事件的小部件。 下表列出了您可以访问的其他事件字段以及它们在Tk中的表示方式，这在引用Tk手册页时非常有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Tk      Tkinter Event Field             Tk      Tkinter Event Field</span><br><span class="line">--      -------------------             --      -------------------</span><br><span class="line">%f      focus                           %A      char</span><br><span class="line">%h      height                          %E      send_event</span><br><span class="line">%k      keycode                         %K      keysym</span><br><span class="line">%s      state                           %N      keysym_num</span><br><span class="line">%t      time                            %T      type</span><br><span class="line">%w      width                           %W      widget</span><br><span class="line">%x      x                               %X      x_root</span><br><span class="line">%y      y                               %Y      y_root</span><br></pre></td></tr></table></figure><h3 id="6-8-索引参数"><a href="#6-8-索引参数" class="headerlink" title="6.8 索引参数"></a>6.8 索引参数</h3><p>许多小部件需要传递“索引”参数。它们用于指向Text小部件中的特定位置，或指向Entry小部件中的特定字符或指向Menu小部件中的特定菜单项。</p><p>Entry widget indexes (index, view index, etc.)</p><p>条目窗口小部件具有涉及正在显示的文本中的字符位置的选项。您可以使用这些<code>Tkinter</code>函数来访问文本小部件中的这些特殊点：</p><p>AtEnd（）指的是textAtInsert（）中的最后一个位置，指的是文本光标isAtSelFirst（）指示选定文本的开始点的点.AtSelLast（）表示所选文本的最后一个点，finallyAt（x，y）指向到像素位置<em>x</em>，<em>y</em>处的字符（对于包含单行文本的文本输入小部件，<em>y</em>不使用<em>y</em>）。文本小部件索引文本小部件的索引符号非常丰富，最好在Tk中进行描述man pages.Menu索引（menu.invoke（），menu.entryconfig（）等）</p><p>一些菜单选项和方法可以操作特定的菜单条目。无论何时，对于选项或参数都需要菜单索引，您可以通过：</p><ul><li><p>一个整数，它指向窗口小部件中的条目的数字位置，从顶部开始计数，从0开始;</p></li><li><p>字符串<code>&#39;active&#39;</code>，它是指当前在光标下的菜单位置;</p></li><li><p><code>&quot;last&quot;</code>引用最后一个菜单项的字符串;</p></li><li><p>通过前面的整数<code>@</code>，如在<code>@6</code>，其中整数被解释为y像素菜单的坐标系统中的坐标;</p></li><li><p>该字符串<code>&quot;none&quot;</code>表示根本没有菜单条目，通常与menu.activate（）一起使用来停用所有条目，最后，</p></li><li><p>一个与菜单条目标签相匹配的文本字符串，从菜单顶部扫描到底部。 请注意，此索引类型在所有其他索引类型之后被考虑，这意味着标记为last，active或none的菜单项的匹配可能会被解释为上述文字。</p></li></ul><h3 id="6-9-图片"><a href="#6-9-图片" class="headerlink" title="6.9 图片"></a>6.9 图片</h3><p>位图/像素图像可以通过以下子类创建<code>Tkinter.Image</code>：</p><ul><li><p><code>BitmapImage</code> 可用于X11位图数据。</p></li><li><p><code>PhotoImage</code> 可用于GIF和PPM / PGM颜色位图。</p></li></ul><p>任何类型的图像都是通过<code>file</code>或<code>data</code>选项创建的（其他选项也可用）。</p><p>这个图像对象可以用于任何一个<code>image</code>小部件支持的选项（例如标签，按钮，菜单）。在这些情况下，Tk将不会保留对图像的引用。当删除对图像对象的最后一个Python引用时，图像数据也会被删除，并且无论图像在哪里使用，Tk都会显示一个空框。</p><h2 id="7-文件处理程序"><a href="#7-文件处理程序" class="headerlink" title="7.文件处理程序"></a>7.文件处理程序</h2><p>Tk允许你注册和取消注册一个回调函数，当一个文件描述符可能有I / O时，这个回调函数将从Tk mainloop调用。每个文件描述符只能注册一个处理程序。示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Tkinter</span><br><span class="line">widget = Tkinter.Tk()</span><br><span class="line">mask = Tkinter.READABLE | Tkinter.WRITABLE</span><br><span class="line">widget.tk.createfilehandler(file, mask, callback)</span><br><span class="line">...</span><br><span class="line">widget.tk.deletefilehandler(file)</span><br></pre></td></tr></table></figure><p>此功能在Windows上不可用。</p><p>由于您不知道有多少字节可供读取，因此您可能不想使用<code>BufferedIOBase</code>or <code>TextIOBase</code> <code>read()</code>或<code>readline()</code>方法，因为这些字节会坚持读取预定义的字节数。对于套接字，<code>recv()</code>or <code>recvfrom()</code>方法可以正常工作; 对于其他文件，请使用原始读取或<code>os.read(file.fileno(), maxbytecount)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget.tk.createfilehandler(file, mask, func)</span><br></pre></td></tr></table></figure><p>注册文件处理程序回调函数<em>func</em>。该<em>文件</em>的参数可以是与一个对象<code>fileno()</code>的方法（例如，文件或套接字对象），或一个整数文件描述符。的<em>掩模</em>参数是任何以下三个常量的或运算组合。回调被调用如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">callback(file, mask)</span><br><span class="line">Widget.tk.deletefilehandler(file)</span><br></pre></td></tr></table></figure><p>取消注册文件处理程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tkinter.READABLETkinter.WRITABLETkinter.EXCEPTION</span><br></pre></td></tr></table></figure><p><em>掩码</em>参数中使用的常量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-Tkinter&quot;&gt;&lt;a href=&quot;#python-标准库-Tkinter&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 Tkinter&quot;&gt;&lt;/a&gt;python 标准库 Tkinter&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200314_what_is_friends_mean_to_u.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="Tkinter" scheme="https://pinghailinfeng.gitee.io/tags/Tkinter/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library xml dom</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/13/python-standard-library-xml-dom/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/13/python-standard-library-xml-dom/</id>
    <published>2020-03-13T13:55:43.000Z</published>
    <updated>2020-03-15T03:49:19.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-XML-dom-对象API"><a href="#python-标准库-XML-dom-对象API" class="headerlink" title="python 标准库 XML dom 对象API"></a>python 标准库 XML dom 对象API</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200313_bravo.gif?raw=true" alt></p><a id="more"></a><blockquote><p>bravo英音：[‘brɑ:’vəu]美音：[‘brɑ’vo]</p><p>名词 n.</p><ol><li><p>喝彩声</p></li><li><p>暴徒</p></li></ol><p>感叹词 int.</p><ol><li>好极了</li></ol><p>这个词必然来自拉丁语，所以法语意大利语西班牙语都有，英语也有了</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/python/cpython/tree/3.8/Lib/xml/dom/__init__.py" target="_blank" rel="noopener">Lib/xml/dom/<strong>init</strong>.py</a> </p><p>本节介绍 python 中DOM 模块。</p><p>文档对象模型或“DOM”是万维网联盟（W3C）的跨语言API，用于访问和修改XML文档。DOM实现将XML文档呈现为树结构，或者允许客户端代码从头构建这样的结构。然后通过提供众所周知的接口的一组对象来访问该结构。</p><p>DOM对随机访问应用程序非常有用。SAX只允许您一次查看文档的一个位。如果您正在查看一个SAX元素，则无法访问其他元素。如果您正在查看文本节点，则无法访问包含元素。当你编写一个SAX应用程序时，你需要跟踪自己代码中某个地方的程序在文档中的位置。SAX不会为你做。另外，如果你需要在XML文档中向前看，你只是运气不好。</p><p>某些应用程序在事件驱动模型中无法访问树是根本不可能的。当然，你可以在SAX事件中自己构建某种树，但是DOM允许你避免编写代码。DOM是XML数据的标准树表示。</p><p>文档对象模型由W3C分阶段定义，或者在其术语中定义为“级别”。API的Python映射基本上基于DOM Level 2推荐。</p><p>通常，DOM应用程序首先将一些XML解析为DOM。 如何实现这一点完全没有被DOM Level 1覆盖，而Level 2只提供了有限的改进：有一个DOMImplementation对象类，它提供了对文档创建方法的访问，但没有办法访问XML读取器/解析器/文档构建器 独立于实现的方式。 在没有现有Document对象的情况下，也没有明确定义的方式来访问这些方法。 在Python中，每个DOM实现将提供一个函数 <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.html#xml.dom.getDOMImplementation" target="_blank" rel="noopener"><code>getDOMImplementation()</code></a>。 DOM Level 3添加了一个Load / Store规范，该规范为读者定义了一个接口，但是这在Python标准库中尚不可用。</p><p>一旦有了DOM文档对象，就可以通过其属性和方法访问XML文档的各个部分。这些属性在DOM规范中定义; 这部分参考手册描述了Python中规范的解释。</p><p>W3C提供的规范定义了用于Java，ECMAScript和OMG IDL的DOM API。这里定义的Python映射很大程度上基于IDL版本的规范，但不需要严格的遵从（尽管实现可以自由支持来自IDL的严格映射）。有关映射要求的详细讨论，请参阅一致性部分。</p><p>扩展内容</p><p> <a href="https://www.w3.org/TR/DOM-Level-2-Core/" target="_blank" rel="noopener">文档对象模型（DOM）Level 2规范</a> </p><p>Python DOM API所基于的W3C推荐标准。</p><p><a href="https://www.w3.org/TR/REC-DOM-Level-1/" target="_blank" rel="noopener">文档对象模型（DOM）1级规范</a> </p><p>W3C推荐的DOM支持<code>xml.dom.minidom</code>。</p><p><a href="http://www.omg.org/spec/PYTH/1.2/PDF" target="_blank" rel="noopener">Python语言映射规范</a></p><p>这指定了从OMG IDL到Python的映射。  </p><h2 id="模块内容"><a href="#模块内容" class="headerlink" title="模块内容"></a>模块内容</h2><p>将<code>xml.dom</code>包含以下功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.dom.registerDOMImplementation(name, factory)</span><br></pre></td></tr></table></figure><p>注册<em>工厂</em>名称为功能<em>名称</em>。工厂函数应该返回一个实现<code>DOMImplementation</code>接口的对象。工厂函数可以每次都返回相同的对象，或者针对每次调用返回一个新对象，以适合特定的实现（例如，如果该实现支持一些定制）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.dom.getDOMImplementation([name[, features]])</span><br></pre></td></tr></table></figure><p>返回一个合适的DOM实现。 该名称是众所周知的，DOM实现的模块名称或None。 如果不是None，则导入相应的模块，并在导入成功时返回<code>DOMImplementation</code>对象。 如果未给出名称，并且已设置环境变量PYTHON_DOM，则使用此变量查找实现。</p><p>如果没有给出名称，这将检查可用实现以找到具有所需功能集的实现。如果没有找到实现，请举一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a> 。<code>(feature, version)</code>要素列表必须是<code>hasFeature()</code>在可用<code>DOMImplementation</code>对象上传递给方法的一系列对。</p><p>还提供了一些常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.dom.EMPTY_NAMESPACE</span><br></pre></td></tr></table></figure><p>用于指示没有名称空间与DOM中的节点关联的值。 这通常可以作为节点的<code>namespaceURI</code>找到，或者用作名称空间特定方法的<code>namespaceURI</code>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.dom.XML_NAMESPACE</span><br></pre></td></tr></table></figure><p>与保留前缀关联的名称空间URI <code>xml</code>，由<a href="https://www.w3.org/TR/REC-xml-names/" target="_blank" rel="noopener">XML中</a>的<a href="https://www.w3.org/TR/REC-xml-names/" target="_blank" rel="noopener">Namespaces</a>定义（第4节）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.dom.XMLNS_NAMESPACE</span><br></pre></td></tr></table></figure><p>由<a href="https://www.w3.org/TR/DOM-Level-2-Core/core.html" target="_blank" rel="noopener">文档对象模型（DOM）Level 2 Core Specification</a>（第1.1.8节）定义的名称空间声明的名称空间URI 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.dom.XHTML_NAMESPACE</span><br></pre></td></tr></table></figure><p>由<a href="https://www.w3.org/TR/xhtml1/" target="_blank" rel="noopener">XHTML 1.0</a>定义的XHTML名称空间的URI <a href="https://www.w3.org/TR/xhtml1/" target="_blank" rel="noopener">：可扩展超文本标记语言</a>（3.1.1节）。</p><p>另外，xml.dom包含一个基本的Node类和DOM异常类。 这个模块提供的Node类没有实现DOM规范定义的任何方法或属性; 具体的DOM实现必须提供这些。 作为此模块一部分提供的Node类确实提供了用于具体Node对象上的nodeType属性的常量; 它们位于类内而不是模块级，以符合DOM规范。</p><h2 id="DOM中的对象"><a href="#DOM中的对象" class="headerlink" title="DOM中的对象"></a>DOM中的对象</h2><p>DOM的权威性文档是W3C的DOM规范。</p><p>请注意，DOM属性也可以作为节点来操作，而不是简单的字符串。然而，你必须这样做是非常罕见的，所以这种用法还没有记录。</p><table><thead><tr><th style="text-align:left">接口</th><th style="text-align:left">分块</th><th style="text-align:left">目的</th></tr></thead><tbody><tr><td style="text-align:left">DOMImplementation</td><td style="text-align:left">DOMImplementation对象</td><td style="text-align:left">接口的底层实现。</td></tr><tr><td style="text-align:left">Node</td><td style="text-align:left">节点对象</td><td style="text-align:left">文档中大多数对象的基本接口。</td></tr><tr><td style="text-align:left">NodeList</td><td style="text-align:left">NodeList对象</td><td style="text-align:left">一系列节点的接口。</td></tr><tr><td style="text-align:left">DocumentType</td><td style="text-align:left">DocumentType对象</td><td style="text-align:left">关于处理文档所需声明的信息。</td></tr><tr><td style="text-align:left">Document</td><td style="text-align:left">文档对象</td><td style="text-align:left">表示整个文档的对象。</td></tr><tr><td style="text-align:left">Element</td><td style="text-align:left">元素对象</td><td style="text-align:left">文档层次结构中的元素节点。</td></tr><tr><td style="text-align:left">ATTR</td><td style="text-align:left">属性对象</td><td style="text-align:left">元素节点上的属性值节点。</td></tr><tr><td style="text-align:left">Comment</td><td style="text-align:left">注释对象</td><td style="text-align:left">在源文档中注释的表示形式。</td></tr><tr><td style="text-align:left">Text</td><td style="text-align:left">文本和CDATASection对象</td><td style="text-align:left">包含文档中文本内容的节点。</td></tr><tr><td style="text-align:left">ProcessingInstruction</td><td style="text-align:left">ProcessingInstruction对象</td><td style="text-align:left">处理指令表示。</td></tr></tbody></table><p>附加部分描述了在Python中使用DOM定义的异常。</p><h3 id="DOMImplementation对象"><a href="#DOMImplementation对象" class="headerlink" title="DOMImplementation对象"></a>DOMImplementation对象</h3><p><code>DOMImplementation</code>接口为应用程序提供了一种方法来确定他们正在使用的DOM中特定功能的可用性。 DOM Level 2增加了使用<code>DOMImplementation</code>创建新的<code>Document</code>和<code>DocumentType</code>对象的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMImplementation.hasFeature(feature, version)</span><br></pre></td></tr></table></figure><p>如果实现了一对字符串<em>功能</em>和<em>版本</em>标识的功能，则返回true 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMImplementation.createDocument(namespaceUri, qualifiedName, doctype)</span><br></pre></td></tr></table></figure><p>使用具有给定<code>namespaceUri</code>和<code>qualifiedName</code>的子元素对象返回一个新的Document对象（DOM的根）。 doctype必须是由 <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.html#xml.dom.DOMImplementation.createDocumentType" target="_blank" rel="noopener"><code>createDocumentType()</code></a> 或None创建的DocumentType对象。 在Python DOM API中，前两个参数也可以是None，以表示不要创建Element子元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMImplementation.createDocumentType(qualifiedName, publicId, systemId)</span><br></pre></td></tr></table></figure><p>返回一个<code>DocumentType</code>封装给定的<em>qualifiedName</em>，<em>publicId</em>和<em>systemId</em>字符串的新对象，表示包含在XML文档类型声明中的信息。</p><h3 id="节点对象"><a href="#节点对象" class="headerlink" title="节点对象"></a>节点对象</h3><p>XML文档的所有组件都是Node的子类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.nodeType</span><br></pre></td></tr></table></figure><p>表示节点类型的整数。 这些类型的符号常量位于Node对象上：ELEMENT_NODE，ATTRIBUTE_NODE，TEXT_NODE，CDATA_SECTION_NODE，ENTITY_NODE，PROCESSING_INSTRUCTION_NODE，COMMENT_NODE，DOCUMENT_NODE，DOCUMENT_TYPE_NODE，NOTATION_NODE。 这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.parentNode</span><br></pre></td></tr></table></figure><p>当前节点的父节点，或文档节点的None。 该值始终是一个Node对象或None。 对于元素节点，这将是父元素，除了根元素，在这种情况下它将是Document对象。 对于Attr节点，这总是无。 这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.attributes</span><br></pre></td></tr></table></figure><p>一个<code>NamedNodeMap</code>属性对象。只有元素才具有实际的价值; 其他人提供<code>None</code>这个属性。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.previousSibling</span><br></pre></td></tr></table></figure><p>紧跟在同一父节点之前的节点。例如，在<em>自身</em>元素的开始标记之前有一个结束标记的元素。当然，XML文档不仅仅包含元素，所以以前的兄弟可以是文本，评论或其他东西。如果此节点是父项的第一个子项，则此属性将为<code>None</code>。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.nextSibling</span><br></pre></td></tr></table></figure><p>紧跟在这个父节点之后的节点。另见<code>previousSibling</code>。如果这是父项的最后一个子项，则此属性将为<code>None</code>。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.childNodes</span><br></pre></td></tr></table></figure><p>此节点中包含的节点列表。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.firstChild</span><br></pre></td></tr></table></figure><p>节点的第一个孩子，如果有的话，或者<code>None</code>。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.lastChild</span><br></pre></td></tr></table></figure><p>节点的最后一个子节点，如果有的话，或者<code>None</code>。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.localName</span><br></pre></td></tr></table></figure><p>如果有冒号，冒号后面的部分是冒号，否则整个tagName。 该值是一个字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.prefix</span><br></pre></td></tr></table></figure><p>tagName在冒号前面的部分（如果有），否则为空字符串。 该值是一个字符串，或None。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.namespaceURI</span><br></pre></td></tr></table></figure><p>与元素名称关联的名称空间。这将是一个字符串或<code>None</code>。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.nodeName</span><br></pre></td></tr></table></figure><p>这对每种节点类型都有不同的含义; 有关详细信息，请参阅DOM规范。 您始终可以从另一个属性获取您在此处获得的信息，例如元素的tagName属性或属性的name属性。 对于所有节点类型，此属性的值将是一个字符串或None。 这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.nodeValue</span><br></pre></td></tr></table></figure><p>这对每种节点类型都有不同的含义; 有关详细信息，请参阅DOM规范。情况类似于<code>nodeName</code>。该值是一个字符串或<code>None</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.hasAttributes()</span><br></pre></td></tr></table></figure><p>如果节点具有任何属性，则返回true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.hasChildNodes()</span><br></pre></td></tr></table></figure><p>如果节点有任何子节点，则返回true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.isSameNode(other)</span><br></pre></td></tr></table></figure><p>如果<em>other</em> 引用与此节点相同的节点，则返回true 。这对于使用任何类型的代理体系结构的DOM实现特别有用（因为多个对象可以引用同一个节点）。</p><p>注意</p><p>这是基于建议的DOM Level 3 API，它仍处于“工作草案”阶段，但这个特定的界面似乎没有争议。来自W3C的改变不一定会影响Python DOM接口中的这种方法（尽管任何新的W3C API也会被支持）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.appendChild(newChild)</span><br></pre></td></tr></table></figure><p>将新的子节点添加到子节点列表末尾的此节点，并返回<em>newChild</em>。如果节点已经在树中，它将首先被移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.insertBefore(newChild, refChild)</span><br></pre></td></tr></table></figure><p>在现有的子节点之前插入一个新的孩子节点。 它必须是refChild是这个节点的子节点的情况; 如果不是，则引发ValueError。 返回newChild返回。 如果refChild为None，它将在子列表的末尾插入newChild。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.removeChild(oldChild)</span><br></pre></td></tr></table></figure><p>删除一个子节点。 oldChild必须是该节点的子节点; 如果不是，则引发ValueError。 oldChild成功返回。 如果oldChild不会进一步使用，则应调用其unlink（）方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.replaceChild(newChild, oldChild)</span><br></pre></td></tr></table></figure><p>用新节点替换现有节点。<em>oldChild</em>必须是这个节点的子节点; 如果没有，则会提出<code>ValueError</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.normalize()</span><br></pre></td></tr></table></figure><p>加入相邻的文本节点，以便所有文本段都作为单个<code>Text</code>实例存储。这为许多应用程序简化了从DOM树处理文本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.cloneNode(deep)</span><br></pre></td></tr></table></figure><p>克隆这个节点。设置<em>deep</em> 意味着克隆所有子节点。这将返回克隆。</p><h3 id="NodeList对象"><a href="#NodeList对象" class="headerlink" title="NodeList对象"></a>NodeList对象</h3><p>NodeList表示一系列节点。 这些对象在DOM核心推荐中以两种方式使用：一个Element对象提供一个作为其子节点列表，Node的getElementsByTagName（）和getElementsByTagNameNS（）方法返回具有此接口的对象以表示查询结果。</p><p>DOM Level 2建议为这些对象定义了一个方法和一个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NodeList.item(i)</span><br></pre></td></tr></table></figure><p>如果还有一个，则返回序列中的第<em>i</em> 项<code>None</code>。指数<em>i</em> 不得小于零或大于或等于序列的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NodeList.length</span><br></pre></td></tr></table></figure><p>序列中的节点数量。</p><p>另外，Python DOM接口要求提供一些额外的支持，以允许NodeList对象用作Python序列。 所有的NodeList实现都必须包含对<strong>len </strong>（）和<strong>getitem </strong>（）的支持; 这允许迭代NodeList中的for语句并正确支持len（）内置函数。</p><p>如果一个DOM实现支持文档的修改，那么<code>NodeList</code>实现也必须支持<a href="https://docs.python.org/2.7/reference/datamodel.html#object.__setitem__" target="_blank" rel="noopener"><code>__setitem__()</code></a>和<a href="https://docs.python.org/2.7/reference/datamodel.html#object.__delitem__" target="_blank" rel="noopener"><code>__delitem__()</code></a>方法。</p><h3 id="DocumentType对象"><a href="#DocumentType对象" class="headerlink" title="DocumentType对象"></a>DocumentType对象</h3><p>有关由文档声明的符号和实体的信息（包括解析器使用它并可以提供信息的外部子集）可从DocumentType对象中获得。 文档的DocumentType可以从Document对象的doctype属性中获得; 如果文档没有DOCTYPE声明，则文档的doctype属性将设置为None，而不是此接口的实例。</p><p><code>DocumentType</code>是专业化的<code>Node</code>，并增加了以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentType.publicId</span><br></pre></td></tr></table></figure><p>文档类型定义的外部子集的公共标识符。这将是一个字符串或<code>None</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentType.systemId</span><br></pre></td></tr></table></figure><p>文档类型定义的外部子集的系统标识符。这将作为一个字符串的URI，或<code>None</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentType.internalSubset</span><br></pre></td></tr></table></figure><p>从文档中提供完整内部子集的字符串。这不包括包含子集的括号。如果文档没有内部子集，应该是<code>None</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentType.name</span><br></pre></td></tr></table></figure><p><code>DOCTYPE</code>声明中给出的根元素的名称（如果存在）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentType.entities</span><br></pre></td></tr></table></figure><p>这是一个给出外部实体定义的NamedNodeMap。 对于不止一次定义的实体名称，只提供第一个定义（其他则根据XML建议的要求被忽略）。 如果信息不是由解析器提供的，或者没有定义实体，则这可能是None。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DocumentType.notations</span><br></pre></td></tr></table></figure><p>这是一个NamedNodeMap，给出了符号的定义。 对于不止一次定义的记法名称，只提供第一个定义（其他则根据XML建议的要求而被忽略）。 如果信息不是由解析器提供的，或者没有定义符号，则这可能是None。</p><h3 id="文档对象"><a href="#文档对象" class="headerlink" title="文档对象"></a>文档对象</h3><p> <code>Document</code>表示整个XML文档，包括其组成元素，属性，处理指令，注释等。请记住它从中继承属性<code>Node</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.documentElement</span><br></pre></td></tr></table></figure><p>文档的唯一根元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.createElement(tagName)</span><br></pre></td></tr></table></figure><p>创建并返回一个新的元素节点。 元素在创建时未插入到文档中。 您需要使用其他方法之一（如insertBefore（）或appendChild（））来显式插入它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.createElementNS(namespaceURI, tagName)</span><br></pre></td></tr></table></figure><p>用命名空间创建并返回一个新元素。 tagName可能有一个前缀。 元素在创建时未插入到文档中。 您需要使用其他方法之一（如insertBefore（）或appendChild（））来显式插入它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.createTextNode(data)</span><br></pre></td></tr></table></figure><p>创建并返回包含作为参数传递的数据的文本节点。与其他创建方法一样，这个方法不会将节点插入树中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.createComment(data)</span><br></pre></td></tr></table></figure><p>创建并返回包含作为参数传递的数据的注释节点。与其他创建方法一样，这个方法不会将节点插入树中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.createProcessingInstruction(target, data)</span><br></pre></td></tr></table></figure><p>创建并返回包含作为参数传递的<em>目标</em>和<em>数据</em>的处理指令节点。与其他创建方法一样，这个方法不会将节点插入树中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.createAttribute(name)</span><br></pre></td></tr></table></figure><p>创建并返回一个属性节点。 此方法不会将属性节点与任何特定元素相关联。 您必须在适当的Element对象上使用setAttributeNode（）来使用新创建的属性实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.createAttributeNS(namespaceURI, qualifiedName)</span><br></pre></td></tr></table></figure><p>用命名空间创建并返回一个属性节点。 tagName可能有一个前缀。 此方法不会将属性节点与任何特定元素相关联。 您必须在适当的Element对象上使用setAttributeNode（）来使用新创建的属性实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.getElementsByTagName(tagName)</span><br></pre></td></tr></table></figure><p>搜索所有具有特定元素类型名称的后代（直接子代，子代孩子等）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document.getElementsByTagNameNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure><p>使用特定的命名空间URI和本地名搜索所有后代（直接的子节点，子节点的子节点等）。localname是前缀后的名称空间的一部分。</p><h3 id="元素对象"><a href="#元素对象" class="headerlink" title="元素对象"></a>元素对象</h3><p><code>Element</code>是node的一个子类，所以继承了该类的所有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.tagName</span><br></pre></td></tr></table></figure><p>元素类型名称。在使用命名空间的文档中，它可能有冒号。该值是一个字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getElementsByTagName(tagName)</span><br></pre></td></tr></table></figure><p>与<code>Document</code>类中的等同方法类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getElementsByTagNameNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure><p>与<code>Document</code>类中的等同方法相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.hasAttribute(name)</span><br></pre></td></tr></table></figure><p>如果元素具有按<em>名称</em> 命名的属性，则返回true 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.hasAttributeNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure><p>如果元素具有由<em>namespaceURI</em>和<em>localName</em>命名的属性，则返回true 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getAttribute(name)</span><br></pre></td></tr></table></figure><p>以字符串形式返回按<em>名称</em> 命名的属性的值。如果不存在这样的属性，则返回空字符串，就好像该属性没有值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getAttributeNode(attrname)</span><br></pre></td></tr></table></figure><p>返回<code>Attr</code>由<em>attrname</em>命名的属性的节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getAttributeNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure><p>以字符串形式返回由<em>namespaceURI</em>和<em>localName</em>命名的属性的值。如果不存在这样的属性，则返回空字符串，就好像该属性没有值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.getAttributeNodeNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure><p>在给定<em>namespaceURI</em>和<em>localName的情况下</em>，将属性值作为节点返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.removeAttribute(name)</span><br></pre></td></tr></table></figure><p>按名称删除属性。如果没有匹配的属性，则引发<code>NotFoundErr</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.removeAttributeNode(oldAttr)</span><br></pre></td></tr></table></figure><p>如果存在，请从属性列表中删除并返回<em>oldAttr</em>。如果<em>oldAttr</em>不存在，则提出<code>NotFoundErr</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.removeAttributeNS(namespaceURI, localName)</span><br></pre></td></tr></table></figure><p>按名称删除属性。请注意，它使用localName而不是qname。如果没有匹配属性，则不会引发异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.setAttribute(name, value)</span><br></pre></td></tr></table></figure><p>从字符串中设置一个属性值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.setAttributeNode(newAttr)</span><br></pre></td></tr></table></figure><p>将新的属性节点添加到元素，如果<code>name</code>属性匹配，则在必要时替换现有的属性。如果发生替换，则将返回旧的属性节点。如果<em>newAttr</em>已被使用，<code>InuseAttributeErr</code>将会被提出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.setAttributeNodeNS(newAttr)</span><br></pre></td></tr></table></figure><p>添加一个新的属性节点到元素中，如果<code>namespaceURI</code>和<code>localName</code>属性匹配，则在必要时替换现有的属性。如果发生替换，则将返回旧的属性节点。如果<em>newAttr</em>已被使用，<code>InuseAttributeErr</code>将会被提出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element.setAttributeNS(namespaceURI, qname, value)</span><br></pre></td></tr></table></figure><p>给定一个<em>namespaceURI</em> 和一个<em>qname</em>，从一个字符串中设置一个属性值。请注意，qname是整个属性名称。这与以上不同。</p><h3 id="属性对象"><a href="#属性对象" class="headerlink" title="属性对象"></a>属性对象</h3><p><code>Attr</code>从<code>Node</code>中继承，所以继承了它的所有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Attr.name</span><br></pre></td></tr></table></figure><p>属性名称。在使用命名空间的文档中，它可能包含冒号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Attr.localName</span><br></pre></td></tr></table></figure><p>如果有冒号，冒号后面的部分名称，否则为整个名称。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Attr.prefix</span><br></pre></td></tr></table></figure><p>冒号前面的部分名称，如果有的话，否则为空字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Attr.value</span><br></pre></td></tr></table></figure><p>属性的文本值。这是该<code>nodeValue</code>属性的同义词。</p><h3 id="命名的节点映射对象"><a href="#命名的节点映射对象" class="headerlink" title="命名的节点映射对象"></a>命名的节点映射对象</h3><p><code>NamedNodeMap</code>并<em>没有</em>继承<code>Node</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NamedNodeMap.length</span><br></pre></td></tr></table></figure><p>属性列表的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NamedNodeMap.item(index)</span><br></pre></td></tr></table></figure><p>返回具有特定索引的属性。您获取属性的顺序是任意的，但对于DOM的生命周期将保持一致。每个项目是一个属性节点。通过<code>value</code>属性获取它的值。</p><p>也有实验方法给这个类更多的映射行为。您可以使用它们，也可以<code>getAttribute*()</code>在<code>Element</code>对象上使用标准化的方法族。</p><h3 id="注释对象"><a href="#注释对象" class="headerlink" title="注释对象"></a>注释对象</h3><p><code>Comment</code>代表XML文档中的评论。它是子类<code>Node</code>，但不能有子节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comment.data</span><br></pre></td></tr></table></figure><p>注释的内容为一个字符串。该属性包含前导<code>和尾随之间的所有字符</code>–&gt;`，但不包括它们。</p><h3 id="文本和CDATASection对象"><a href="#文本和CDATASection对象" class="headerlink" title="文本和CDATASection对象"></a>文本和<code>CDATASection</code>对象</h3><p>该<code>Text</code>接口表示在XML文档中的文本。如果解析器和DOM实现支持DOM的XML扩展，那么封装在CDATA标记节中的部分文本将存储在<code>CDATASection</code>对象中。这两个接口是相同的，但为<code>nodeType</code>属性提供不同的值。</p><p>这些接口扩展了<code>Node</code>接口。他们不能有子节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text.data</span><br></pre></td></tr></table></figure><p>文本节点的内容为字符串。</p><p>注意</p><p><code>CDATASection</code>节点的使用并不表示该节点表示一个完整的CDATA标记部分，只是该节点的内容是CDATA部分的一部分。 单个CDATA部分可以由文档树中的多个节点表示。 无法确定两个相邻的CDATASection节点是否代表不同的CDATA标记节。</p><h3 id="ProcessingInstruction对象"><a href="#ProcessingInstruction对象" class="headerlink" title="ProcessingInstruction对象"></a><code>ProcessingInstruction</code>对象</h3><p>表示XML文档中的处理指令; 这从<code>Node</code>接口继承并且不能有子节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProcessingInstruction.target</span><br></pre></td></tr></table></figure><p>处理指令的内容直至第一个空白字符。这是一个只读属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProcessingInstruction.data</span><br></pre></td></tr></table></figure><p>处理指令的内容跟在第一个空白字符之后。</p><h3 id="Exceptions-异常"><a href="#Exceptions-异常" class="headerlink" title="Exceptions 异常"></a><strong>Exceptions</strong> 异常</h3><p>DOM Level 2建议定义了一个单例，DOMException和一些允许应用程序确定发生的错误的常量。 DOMException实例携带一个代码属性，为特定的异常提供适当的值。</p><p>Python DOM接口提供了常量，但也扩展了一组异常，以便DOM中定义的每个异常代码都存在特定的异常。这些实现必须引发适当的特定异常，每个异常都带有相应的<code>code</code>属性值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.DOMException</span><br></pre></td></tr></table></figure><p>用于所有特定DOM异常的基本异常类。这个异常类不能直接实例化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.DomstringSizeErr</span><br></pre></td></tr></table></figure><p>当指定范围的文本不适合字符串时引发。这不是已知用于Python DOM实现，但可能从未使用Python编写的DOM实现中获得。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.HierarchyRequestErr</span><br></pre></td></tr></table></figure><p>当尝试插入不允许节点类型的节点时引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.IndexSizeErr</span><br></pre></td></tr></table></figure><p>当方法的索引或大小参数为负值或超出允许值时引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.InuseAttributeErr</span><br></pre></td></tr></table></figure><p>当尝试插入已存在于文档中其他位置的Attr节点时引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.InvalidAccessErr</span><br></pre></td></tr></table></figure><p>如果基础对象不支持参数或操作，则引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.InvalidCharacterErr</span><br></pre></td></tr></table></figure><p>如果字符串参数包含在XML 1.0建议中使用的上下文中不允许的字符，则会引发此异常。例如，尝试<code>Element</code>在元素类型名称中创建具有空格的节点会导致此错误的发生。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.InvalidModificationErr</span><br></pre></td></tr></table></figure><p>当尝试修改节点的类型时引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.InvalidStateErr</span><br></pre></td></tr></table></figure><p>当尝试使用未定义或不再可用的对象时引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.NamespaceErr</span><br></pre></td></tr></table></figure><p>如果尝试<a href="https://www.w3.org/TR/REC-xml-names/" target="_blank" rel="noopener">以XML</a>建议中的<a href="https://www.w3.org/TR/REC-xml-names/" target="_blank" rel="noopener">名称空间</a>不允许的方式更改任何对象，则会引发此异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.NotFoundErr</span><br></pre></td></tr></table></figure><p>在引用的上下文中不存在节点时异常。 例如，如果传入的节点在地图中不存在，NamedNodeMap.removeNamedItem（）将引发此操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.NotSupportedErr</span><br></pre></td></tr></table></figure><p>当实现不支持请求类型的对象或操作时引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.NoDataAllowedErr</span><br></pre></td></tr></table></figure><p>如果为不支持数据的节点指定了数据，则会引发此问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.NoModificationAllowedErr</span><br></pre></td></tr></table></figure><p>引发尝试修改不允许修改的对象（例如对于只读节点）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.SyntaxErr</span><br></pre></td></tr></table></figure><p>当指定了无效或非法字符串时引发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.dom.WrongDocumentErr</span><br></pre></td></tr></table></figure><p>当节点插入到与当前所属不同的文档中时引发，并且实现不支持将节点从一个文档迁移到另一个文档。</p><p>DOM建议中定义的异常代码根据此表映射到上述异常：</p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">例外</th></tr></thead><tbody><tr><td style="text-align:left">DOMSTRING_SIZE_ERR</td><td style="text-align:left">DomstringSizeErr</td></tr><tr><td style="text-align:left">HIERARCHY_REQUEST_ERR</td><td style="text-align:left">HierarchyRequestErr</td></tr><tr><td style="text-align:left">INDEX_SIZE_ERR</td><td style="text-align:left">IndexSizeErr</td></tr><tr><td style="text-align:left">INUSE_ATTRIBUTE_ERR</td><td style="text-align:left">InuseAttributeErr</td></tr><tr><td style="text-align:left">INVALID_ACCESS_ERR</td><td style="text-align:left">InvalidAccessErr</td></tr><tr><td style="text-align:left">INVALID_CHARACTER_ERR</td><td style="text-align:left">InvalidCharacterErr</td></tr><tr><td style="text-align:left">INVALID_MODIFICATION_ERR</td><td style="text-align:left">InvalidModificationErr</td></tr><tr><td style="text-align:left">INVALID_STATE_ERR</td><td style="text-align:left">InvalidStateErr</td></tr><tr><td style="text-align:left">NAMESPACE_ERR</td><td style="text-align:left">NamespaceErr</td></tr><tr><td style="text-align:left">NOT_FOUND_ERR</td><td style="text-align:left">NotFoundErr</td></tr><tr><td style="text-align:left">NOT_SUPPORTED_ERR</td><td style="text-align:left">NotSupportedErr</td></tr><tr><td style="text-align:left">NO_DATA_ALLOWED_ERR</td><td style="text-align:left">NoDataAllowedErr</td></tr><tr><td style="text-align:left">NO_MODIFICATION_ALLOWED_ERR</td><td style="text-align:left">NoModificationAllowedErr</td></tr><tr><td style="text-align:left">SYNTAX_ERR</td><td style="text-align:left">SyntaxErr</td></tr><tr><td style="text-align:left">WRONG_DOCUMENT_ERR</td><td style="text-align:left">WrongDocumentErr</td></tr></tbody></table><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>本节介绍Python DOM API，W3C DOM推荐和Python的OMG IDL映射之间的一致性要求和关系。</p><h3 id="类型映射"><a href="#类型映射" class="headerlink" title="类型映射"></a>类型映射</h3><p>根据下表将DOM规范中使用的原始IDL类型映射到Python类型。</p><table><thead><tr><th style="text-align:left">IDL类型</th><th style="text-align:left">Python类型</th></tr></thead><tbody><tr><td style="text-align:left">布尔</td><td style="text-align:left">IntegerType（值为0或1）</td></tr><tr><td style="text-align:left">INT</td><td style="text-align:left">IntegerType</td></tr><tr><td style="text-align:left">长整型</td><td style="text-align:left">IntegerType</td></tr><tr><td style="text-align:left">无符号整数</td><td style="text-align:left">IntegerType</td></tr></tbody></table><p>此外，<code>DOMString</code>建议中定义的内容将映射到Python字符串或Unicode字符串。每当从DOM返回字符串时，应用程序应该能够处理Unicode。</p><p>IDL <code>null</code>值被映射到<code>None</code>，只要<code>null</code>API允许，该值可以被实现接受或提供。</p><h3 id="访问器方法"><a href="#访问器方法" class="headerlink" title="访问器方法"></a>访问器方法</h3><p>从OMG IDL到Python <code>attribute</code>的映射以Java映射的方式为IDL 声明定义访问器函数。映射IDL声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readonly attribute string someValue;</span><br><span class="line">         attribute string anotherValue;</span><br></pre></td></tr></table></figure><p>产生三种存取器函数：一个“获取”方法<code>someValue</code>（<code>_get_someValue()</code>），和“获取”和“设置”为方法<code>anotherValue</code>（<code>_get_anotherValue()</code>和<code>_set_anotherValue()</code>）。映射，尤其是不需要的IDL属性是访问正常的Python属性：<code>object.someValue</code>是<em>不是</em>工作需要，并且可能引发<code>AttributeError</code>。</p><p>但是，Python DOM API <em>确实</em>需要正常的属性访问。这意味着由Python IDL编译器生成的典型代理不可能工作，并且如果通过CORBA访问DOM对象，则可能需要在客户端上包装对象。虽然这确实需要对CORBA DOM客户端进行一些额外的考虑，但具有从Python使用DOM到CORBA的经验的实施者并不认为这是一个问题。所声明的属性<code>readonly</code>可能不会限制所有DOM实现中的写入访问。</p><p>在Python DOM API中，访问函数不是必需的。如果提供，它们应该采用由Python IDL映射定义的形式，但这些方法被认为是不必要的，因为可以直接从Python访问这些属性。不应该为<code>readonly</code>属性提供“设置”访问器。</p><p>IDL定义并未完全体现W3C DOM API的要求，例如某些对象的概念，如返回值为<code>getElementsByTagName()</code>“live”。Python DOM API不需要实现来执行这些需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-XML-dom-对象API&quot;&gt;&lt;a href=&quot;#python-标准库-XML-dom-对象API&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 XML dom 对象API&quot;&gt;&lt;/a&gt;python 标准库 XML dom 对象API&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200313_bravo.gif?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="xml" scheme="https://pinghailinfeng.gitee.io/tags/xml/"/>
    
      <category term="dom" scheme="https://pinghailinfeng.gitee.io/tags/dom/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library xml sax</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/12/python-standard-library-xml-sax/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/12/python-standard-library-xml-sax/</id>
    <published>2020-03-12T13:52:19.000Z</published>
    <updated>2020-03-15T03:49:19.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-xml-sax"><a href="#python-标准库-xml-sax" class="headerlink" title="python 标准库  xml.sax"></a>python 标准库  xml.sax</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200312_youmo.jpg?raw=true" alt></p><a id="more"></a><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p> <a href="https://github.com/python/cpython/tree/3.8/Lib/xml/sax/__init__.py" target="_blank" rel="noopener">Lib/xml/sax/<strong>init</strong>.py</a> </p><p>该<code>xml.sax</code>软件包提供了许多实现Python简单API（SAX）接口的模块。程序包本身提供SAX异常和SAX API用户最常使用的便利功能。</p><p>Warning</p><p>该<code>xml.sax</code>模块对恶意构建的数据不安全。如果您需要解析不可信或未经身份验证的数据，请参阅XML漏洞。</p><p>便利功能是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.sax.make_parser([parser_list])</span><br></pre></td></tr></table></figure><p>创建并返回一个SAX <code>XMLReader</code>对象。找到的第一个解析器将被使用。如果提供了<em>parser_list</em>，它必须是一个字符串序列，这些字符串命名具有名为函数的模块<code>create_parser()</code>。<em>parser_list中</em>列出的模块将在解析器默认列表中的模块之前使用。</p><p> <em>在 3.8 版更改</em> ,parser_list参数可以是认可可迭代对象，不仅只是列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.sax.parse(filename_or_stream, handler[, error_handler])</span><br></pre></td></tr></table></figure><p>创建一个SAX解析器并用它来解析文档。 以filename_or_stream形式传入的文档可以是文件名或文件对象。 处理程序参数需要是SAX ContentHandler实例。 如果给出error_handler，它必须是一个SAX ErrorHandler实例; 如果省略，则会在所有错误中引发SAXParseException。 没有回报价值; 所有的工作必须由传入的处理程序来完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.sax.parseString(string, handler[, error_handler])</span><br></pre></td></tr></table></figure><p>与parse（）类似，但从作为参数接收的缓冲区字符串中解析。</p><p>典型的SAX应用程序使用三种对象：读者，处理程序和输入源。在这种情况下，“读者”是解析器的另一个术语，即某些代码从输入源读取字节或字符，并产生一系列事件。事件然后被分配给处理程序对象，即读者调用处理程序上的方法。因此，SAX应用程序必须获取reader对象，创建或打开输入源，创建处理程序并将这些对象连接在一起。作为准备的最后一步，读者被调用来解析输入。在解析过程中，处理程序对象的方法基于来自输入数据的结构和语法事件来调用。</p><p>对于这些对象，只有接口是相关的; 它们通常不是由应用程序本身实例化的。 由于Python没有明确的接口概念，因此它们被正式引入为类，但是应用程序可能会使用不从所提供的类继承的实现。 InputSource，Locator，Attributes，AttributesNS和XMLReader接口在模块xml.sax.xmlreader中定义。 处理程序接口在xml.sax.handler中定义。 为了方便，InputSource（通常直接实例化）和处理程序类也可以从xml.sax中获得。 这些接口如下所述。</p><p>除这些类外，<code>xml.sax</code>还提供以下异常类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.sax.SAXException(msg[, exception])</span><br></pre></td></tr></table></figure><p>封装XML错误或警告。该类可以包含来自XML解析器或应用程序的基本错误或警告信息：它可以被分类以提供附加功能或添加本地化。请注意，虽然<code>ErrorHandler</code>界面中定义的处理程序会接收此异常的实例，但实际并不需要引发异常 - 它也可用作信息容器。</p><p>实例化时，<em>msg</em> 应该是错误的可读描述。可选的<em>异常</em>参数（如果给出）应该是<code>None</code>解析代码捕获的异常，并作为信息传递。</p><p>这是其他SAX异常类的基类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.sax.SAXParseException(msg, exception, locator)</span><br></pre></td></tr></table></figure><p>解析错误引发SAXException的子类。 将此类的实例传递给SAX ErrorHandler接口的方法，以提供有关分析错误的信息。 该类支持SAX Locator接口以及SAXException接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.sax.SAXNotRecognizedException(msg[, exception])</span><br></pre></td></tr></table></figure><p>当SAX XMLReader遇到无法识别的特征或属性时引发SAXException的子类。 SAX应用程序和扩展可能会将此类用于类似目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception xml.sax.SAXNotSupportedException(msg[, exception])</span><br></pre></td></tr></table></figure><p>SAXException的子类在SAX XMLReader被要求启用不支持的功能或将属性设置为实现不支持的值时引发。 SAX应用程序和扩展可能会将此类用于类似目的。</p><p>扩展内容</p><p>SAX：XML的简单API这个站点是定义SAX API的焦点。 它提供了Java实现和在线文档。 实现和历史信息的链接也可用。 模块xml.sax.handler应用程序提供的对象的接口定义。 模块xml.sax.saxutils用于SAX应用程序的便捷函数。 模块xml.sax.xmlreader解析器提供的对象的接口定义。</p><h2 id="1-SAXException对象"><a href="#1-SAXException对象" class="headerlink" title="1. SAXException对象"></a>1. SAXException对象</h2><p>该<code>SAXException</code>异常类支持下列方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAXException.getMessage()</span><br></pre></td></tr></table></figure><p>返回描述错误情况的可读信息。</p><p><a href="javascript:;" target="_blank" rel="noopener">纠错</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAXException.getException()</span><br></pre></td></tr></table></figure><p>返回一个封装的异常对象，或者<code>None</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-xml-sax&quot;&gt;&lt;a href=&quot;#python-标准库-xml-sax&quot; class=&quot;headerlink&quot; title=&quot;python 标准库  xml.sax&quot;&gt;&lt;/a&gt;python 标准库  xml.sax&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200312_youmo.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="xml" scheme="https://pinghailinfeng.gitee.io/tags/xml/"/>
    
      <category term="sax" scheme="https://pinghailinfeng.gitee.io/tags/sax/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library XML minidom</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/11/python-standard-library-XML-minidom/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/11/python-standard-library-XML-minidom/</id>
    <published>2020-03-11T12:32:55.000Z</published>
    <updated>2020-03-12T13:31:50.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-minidom"><a href="#python-标准库-minidom" class="headerlink" title="python 标准库 minidom"></a>python 标准库 minidom</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200311order.png?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词：</p><p>Order  美音 [‘ɔrdər] 英音  [‘ɔː(r)də(r) ]</p><p>词根解释:</p><p>order,ord,ordin(ordain) = ord,ordin<br>来自拉丁语的ord,ordin 意为to order,变形为ordain。</p><p>n.顺序；命令；勋章；规则</p><p>v.命令；整理；定货；下令</p><p>网络订单；秩序；目</p><p>下面是一个本地翻译的例句:</p><p>  The <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.minidom.html#xml.dom.minidom.Node.writexml" target="_blank" rel="noopener"><code>writexml()</code></a> method now preserves the attribute order specified by the user. </p><p>此处的order结合上下文,我翻译成 <strong>规则</strong> </p><p> <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.minidom.html#xml.dom.minidom.Node.writexml" target="_blank" rel="noopener"><code>writexml()</code></a> 方法允许用户保留属性<strong>规则</strong>声明.</p></blockquote><p><strong>源代码：</strong> <a href="https://hg.python.org/cpython/file/2.7/Lib/xml/dom/minidom.py" target="_blank" rel="noopener">Lib / xml / dom / minidom.py</a></p><p><code>xml.dom.minidom</code>是文档对象模型接口的最小实现，其API类似于其他语言。它的目标是比完整的DOM更简单，也更小。不熟悉DOM的用户应考虑使用该<code>xml.etree.ElementTree</code>模块进行XML处理。</p><blockquote><p>警告:该<code>xml.dom.minidom</code>模块对恶意构建的数据不安全。如果您需要解析不可信或未经身份验证的数据，请参阅  <a href="https://docs.python.org/zh-cn/3.8/library/xml.html#xml-vulnerabilities" target="_blank" rel="noopener">XML 漏洞</a> 。</p></blockquote><p>通常，DOM应用程序首先将一些XML解析为DOM。有了<code>xml.dom.minidom</code>，这是通过解析函数完成的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.dom.minidom <span class="keyword">import</span> parse, parseString</span><br><span class="line"></span><br><span class="line">dom1 = parse(<span class="string">'c:\\temp\\mydata.xml'</span>)  <span class="comment"># parse an XML file by name</span></span><br><span class="line"></span><br><span class="line">datasource = open(<span class="string">'c:\\temp\\mydata.xml'</span>)</span><br><span class="line">dom2 = parse(datasource)  <span class="comment"># parse an open file</span></span><br><span class="line"></span><br><span class="line">dom3 = parseString(<span class="string">'&lt;myxml&gt;Some data&lt;empty/&gt; some more data&lt;/myxml&gt;'</span>)</span><br></pre></td></tr></table></figure><p>该<code>parse()</code>函数可以采用文件名或打开的文件对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.dom.minidom.parse(filename_or_file[, parser[, bufsize]])</span><br></pre></td></tr></table></figure><p><code>Document</code>从给定的输入中被返回 。<em>filename_or_file</em>可以是文件名，也可以是文件类对象。<em>解析器</em>（如果有的话）必须是SAX2解析器对象。该函数将更改解析器的文档处理程序并激活命名空间支持; 其他解析器配置（如设置实体解析器）必须事先完成。</p><p>如果你在一个字符串中有XML，你可以使用这个<code>parseString()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xml.dom.minidom.parseString(string[, parser])</span><br></pre></td></tr></table></figure><p>返回一个表示字符串的文档。 此方法为该字符串创建一个StringIO对象，并将其传递给parse（）。</p><p>这两个函数都会返回一个<code>Document</code>代表文档内容的对象。</p><p><code>parse()</code>和<code>parseString()</code>功能做的是一个“DOM生成器”，可以从任何SAX解析器解析接受事件并将它们转换成DOM树连接XML解析器。这些功能的名称可能是误导性的，但在学习接口时很容易理解。文档的解析将在这些函数返回之前完成; 只是这些函数本身不提供解析器实现。</p><p>您也可以通过调用“DOM实现”对象上的方法来创建文档。 您可以通过调用xml.dom包中的getDOMImplementation（）函数或xml.dom.minidom模块来获取此对象。 使用xml.dom.minidom模块中的实现将始终从minidom实现中返回一个Document实例，而来自xml.dom的版本可能会提供一个替代实现（如果您安装了PyXML包，则可能会发生这种情况）。 一旦你有一个文档，你可以添加子节点来填充DOM：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.dom.minidom <span class="keyword">import</span> getDOMImplementation</span><br><span class="line"></span><br><span class="line">impl = getDOMImplementation()</span><br><span class="line"></span><br><span class="line">newdoc = impl.createDocument(<span class="literal">None</span>, <span class="string">"some_tag"</span>, <span class="literal">None</span>)</span><br><span class="line">top_element = newdoc.documentElement</span><br><span class="line">text = newdoc.createTextNode(<span class="string">'Some textual content.'</span>)</span><br><span class="line">top_element.appendChild(text)</span><br></pre></td></tr></table></figure><p>一旦有了DOM文档对象，就可以通过其属性和方法访问XML文档的各个部分。这些属性在DOM规范中定义。文档对象的主要属性是<code>documentElement</code>属性。它为您提供了XML文档中的主要元素：包含所有其他元素的元素。这是一个示例程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dom3 = parseString(<span class="string">"&lt;myxml&gt;Some data&lt;/myxml&gt;"</span>)</span><br><span class="line">assert dom3.documentElement.tagName == <span class="string">"myxml"</span></span><br></pre></td></tr></table></figure><p>当你完成一个DOM树时，你可以选择调用unlink（）方法来鼓励早期清理不需要的对象。 unlink（）是DOM API的一个xml.dom.minidom专用扩展，它呈现节点及其后代实质上是无用的。 否则，Python的垃圾收集器将最终处理树中的对象。</p><p>扩展内容</p><p> <a href="https://www.w3.org/TR/REC-DOM-Level-1/" target="_blank" rel="noopener">文档对象模型（DOM）1级规范</a> W3C推荐的DOM支持<code>xml.dom.minidom</code>。  </p><h2 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h2><p>Python的DOM API的定义是作为<code>xml.dom</code>模块文档的一部分给出的。本节列出了API和<code>xml.dom.minidom</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.unlink()</span><br></pre></td></tr></table></figure><p>打破DOM内的内部引用，以便在没有循环GC的情况下在Python版本上进行垃圾回收。 即使循环GC可用，使用它也可以更快地提供大量内存，因此，在不再需要DOM对象时立即调用它是很好的做法。 这只需要在Document对象上调用，但可以在子节点上调用以放弃该节点的子节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.writexml(writer, indent=&quot;&quot;, addindent=&quot;&quot;, newl=&quot;&quot;)</span><br></pre></td></tr></table></figure><p>将XML写入作者对象。 作者应该有一个与文件对象接口匹配的write（）方法。 缩进参数是当前节点的缩进。 addindent参数是用于当前子节点的递增缩进。 newl参数指定用于终止换行符的字符串。</p><p>对于Document节点，可以使用其他关键字参数编码来指定XML标头的编码字段。</p><p>在<em>3.8</em>版本中 <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.minidom.html#xml.dom.minidom.Node.writexml" target="_blank" rel="noopener"><code>writexml()</code></a> 方法允许用户保留属性规则声明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.toxml([encoding])</span><br></pre></td></tr></table></figure><p>将DOM表示的XML返回为字符串。</p><p>如果默认编码不能表示文档中的所有字符，那么没有参数时，XML标头不会指定编码，并且结果为Unicode字符串。使用UTF-8以外的编码对此字符串进行编码可能不正确，因为UTF-8是XML的默认编码。</p><p>使用显式<em>编码</em> [1]参数，结果是指定编码中的字节字符串。建议始终指定此参数。为避免<code>UnicodeError</code>出现无法表示的文本数据时出现异常，应将编码参数指定为“utf-8”。</p><p>在<em>3.8</em>版本中   <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.minidom.html#xml.dom.minidom.Node.toxml" target="_blank" rel="noopener"><code>toxml()</code></a>  方法允许用户保留属性规则声明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.toprettyxml([indent=<span class="string">""</span>[, newl=<span class="string">""</span>[, encoding=<span class="string">""</span>]]])</span><br></pre></td></tr></table></figure><p>返回文档的完美版本。<em>indent</em> 指定缩进字符串，并默认为制表符; <em>newl</em>指定在每行末尾发射的字符串，默认为<code>\n</code>。</p><p>在<em>3.8</em>版本中    <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.minidom.html#xml.dom.minidom.Node.toprettyxml" target="_blank" rel="noopener"><code>toprettyxml()</code></a>    方法允许用户保留属性规则声明</p><p>以下标准DOM方法对xml.dom.minidom有特殊考虑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node.cloneNode(deep)</span><br></pre></td></tr></table></figure><p>尽管此方法出现在与Python 2.0一起打包的xml.dom.minidom版本中，但它被严重破坏。 这已为后续版本纠正。</p><h2 id="DOM例子"><a href="#DOM例子" class="headerlink" title="DOM例子"></a>DOM例子</h2><p>这个示例程序是一个简单程序的相当现实的例子。在这种特殊情况下，我们没有充分利用DOM的灵活性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.dom.minidom</span><br><span class="line"></span><br><span class="line">document = <span class="string">"""\</span></span><br><span class="line"><span class="string">&lt;slideshow&gt;</span></span><br><span class="line"><span class="string">&lt;title&gt;Demo slideshow&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;slide&gt;&lt;title&gt;Slide title&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;point&gt;This is a demo&lt;/point&gt;</span></span><br><span class="line"><span class="string">&lt;point&gt;Of a program for processing slides&lt;/point&gt;</span></span><br><span class="line"><span class="string">&lt;/slide&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;slide&gt;&lt;title&gt;Another demo slide&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;point&gt;It is important&lt;/point&gt;</span></span><br><span class="line"><span class="string">&lt;point&gt;To have more than&lt;/point&gt;</span></span><br><span class="line"><span class="string">&lt;point&gt;one slide&lt;/point&gt;</span></span><br><span class="line"><span class="string">&lt;/slide&gt;</span></span><br><span class="line"><span class="string">&lt;/slideshow&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">dom = xml.dom.minidom.parseString(document)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getText</span><span class="params">(nodelist)</span>:</span></span><br><span class="line">    rc = []</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodelist:</span><br><span class="line">        <span class="keyword">if</span> node.nodeType == node.TEXT_NODE:</span><br><span class="line">            rc.append(node.data)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(rc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleSlideshow</span><span class="params">(slideshow)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&lt;html&gt;"</span></span><br><span class="line">    handleSlideshowTitle(slideshow.getElementsByTagName(<span class="string">"title"</span>)[<span class="number">0</span>])</span><br><span class="line">    slides = slideshow.getElementsByTagName(<span class="string">"slide"</span>)</span><br><span class="line">    handleToc(slides)</span><br><span class="line">    handleSlides(slides)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&lt;/html&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleSlides</span><span class="params">(slides)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> slide <span class="keyword">in</span> slides:</span><br><span class="line">        handleSlide(slide)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleSlide</span><span class="params">(slide)</span>:</span></span><br><span class="line">    handleSlideTitle(slide.getElementsByTagName(<span class="string">"title"</span>)[<span class="number">0</span>])</span><br><span class="line">    handlePoints(slide.getElementsByTagName(<span class="string">"point"</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleSlideshowTitle</span><span class="params">(title)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&lt;title&gt;%s&lt;/title&gt;"</span> % getText(title.childNodes)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleSlideTitle</span><span class="params">(title)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&lt;h2&gt;%s&lt;/h2&gt;"</span> % getText(title.childNodes)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handlePoints</span><span class="params">(points)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&lt;ul&gt;"</span></span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">        handlePoint(point)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&lt;/ul&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handlePoint</span><span class="params">(point)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&lt;li&gt;%s&lt;/li&gt;"</span> % getText(point.childNodes)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleToc</span><span class="params">(slides)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> slide <span class="keyword">in</span> slides:</span><br><span class="line">        title = slide.getElementsByTagName(<span class="string">"title"</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"&lt;p&gt;%s&lt;/p&gt;"</span> % getText(title.childNodes)</span><br><span class="line"></span><br><span class="line">handleSlideshow(dom)</span><br></pre></td></tr></table></figure><h2 id="minidom和DOM标准"><a href="#minidom和DOM标准" class="headerlink" title="minidom和DOM标准"></a>minidom和DOM标准</h2><p>该<code>xml.dom.minidom</code>模块本质上是一个DOM 1.0兼容的DOM，具有一些DOM 2功能（主要是名称空间功能）。</p><p>在Python中使用DOM接口非常简单。以下映射规则适用：</p><ul><li><p>接口通过实例对象访问。应用程序不应该自己实例化类; 他们应该使用<code>Document</code>对象上可用的创建者函数。派生接口支持来自基本接口的所有操作（和属性）以及任何新的操作。</p></li><li><p>操作被用作方法。由于DOM只使用<a href="https://docs.python.org/2.7/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a>参数，参数按正常顺序传递（从左到右）。没有可选参数。<code>void</code>操作返回<code>None</code>。</p></li><li><p>IDL属性映射到实例属性。为了与Python的OMG IDL语言映射兼容，<code>foo</code>还可以通过访问器方法<code>_get_foo()</code>和访问属性<code>_set_foo()</code>。<code>readonly</code>属性不能改变; 这不是在运行时强制执行的。</p></li><li><p>类型<code>short int</code>，<code>unsigned int</code>，<code>unsigned long long</code>，和<code>boolean</code>所有映射到Python的整数对象。</p></li><li><p>DOMString类型映射到Python字符串。 xml.dom.minidom支持字节或Unicode字符串，但通常会生成Unicode字符串。 DOMString类型的值也可以是None，其中允许通过W3C的DOM规范获得IDL空值。</p></li><li><p>常量声明映射到各自范围内的变量（例如xml.dom.minidom.Node.PROCESSING_INSTRUCTION_NODE）; 他们不能改变。</p></li><li><p>DOMException目前在xml.dom.minidom中不受支持。 相反，xml.dom.minidom使用标准Python异常，例如TypeError和AttributeError。</p></li><li><p><code>NodeList</code>对象是使用Python的内置列表类型实现的。从Python 2.2开始，这些对象提供了DOM规范中定义的接口，但是对于早期版本的Python，它们不支持官方API。然而，它们比W3C建议中定义的接口更“Pythonic”。</p></li></ul><p>以下接口在xml.dom.minidom中没有实现：</p><ul><li><p><code>DOMTimeStamp</code></p></li><li><p><code>EntityReference</code></p></li></ul><p>其中大多数反映了XML文档中的信息，这对大多数DOM用户来说并不普遍。</p><h4 id="脚注、"><a href="#脚注、" class="headerlink" title="脚注、"></a>脚注、</h4><blockquote><p>XML输出中包含的编码字符串应符合相应的标准。例如，“UTF-8”是有效的，但“UTF8”不是。请参阅<a href="https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl和https://www.iana.org/assignments/character-sets/character-sets.xhtml。" target="_blank" rel="noopener">https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl和https://www.iana.org/assignments/character-sets/character-sets.xhtml。</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-minidom&quot;&gt;&lt;a href=&quot;#python-标准库-minidom&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 minidom&quot;&gt;&lt;/a&gt;python 标准库 minidom&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200311order.png?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="XML" scheme="https://pinghailinfeng.gitee.io/tags/XML/"/>
    
      <category term="minidom" scheme="https://pinghailinfeng.gitee.io/tags/minidom/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library XML</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/10/python-standard-library-XML/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/10/python-standard-library-XML/</id>
    <published>2020-03-10T14:43:43.000Z</published>
    <updated>2020-03-12T13:31:50.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-XML-处理模块-概述"><a href="#python-标准库-XML-处理模块-概述" class="headerlink" title="python 标准库 XML 处理模块 (概述)"></a>python 标准库 XML 处理模块 (概述)</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200310_huangshi.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>黄石国家公园（<strong>Yellowstone National Park</strong>）：简称黄石公园，由<a href="https://baike.baidu.com/item/美国国家公园管理局" target="_blank" rel="noopener">美国国家公园管理局</a>负责管理。1872年3月1日它被正式命名为保护野生动物和自然资源的国家公园，于1978年被列入《<a href="https://baike.baidu.com/item/世界遗产名录/6174540" target="_blank" rel="noopener">世界遗产名录</a>》的<a href="https://baike.baidu.com/item/世界自然遗产/6505343" target="_blank" rel="noopener">世界自然遗产</a>。这是世界上第一个<a href="https://baike.baidu.com/item/国家公园/11086" target="_blank" rel="noopener">国家公园</a>。</p><p>黄石国家公园占地面积约为898317公顷，主要位于美国<a href="https://baike.baidu.com/item/怀俄明州" target="_blank" rel="noopener">怀俄明州</a>，部分位于<a href="https://baike.baidu.com/item/蒙大拿州" target="_blank" rel="noopener">蒙大拿州</a>和<a href="https://baike.baidu.com/item/爱达荷州" target="_blank" rel="noopener">爱达荷州</a>。黄石公园分五个区：西北的<a href="https://baike.baidu.com/item/猛犸象温泉" target="_blank" rel="noopener">猛犸象温泉</a>区以石灰石台阶为主，故也称热台阶区；东北为罗斯福区，仍保留着老西部景观；中间为峡谷区，可观赏<a href="https://baike.baidu.com/item/黄石大峡谷" target="_blank" rel="noopener">黄石大峡谷</a>和瀑布；东南为<a href="https://baike.baidu.com/item/黄石湖区" target="_blank" rel="noopener">黄石湖区</a>，主要是湖光山色；西及西南为间歇喷泉区，遍布<a href="https://baike.baidu.com/item/间歇泉" target="_blank" rel="noopener">间歇泉</a>、<a href="https://baike.baidu.com/item/温泉" target="_blank" rel="noopener">温泉</a>、蒸气池、热水潭、<a href="https://baike.baidu.com/item/泥地" target="_blank" rel="noopener">泥地</a>和喷气孔。园内设有历史古迹博物馆。</p></blockquote><p> <strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/xml/" target="_blank" rel="noopener">Lib/xml/</a> </p><p>用于处理XML的Python接口分组在 <code>xml</code> 包中。</p><blockquote><p>警告:</p><p>XML 模块对于错误或恶意构造的数据是不安全的。 如果需要解析不受信任或未经身份验证的数据，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/xml.html#xml-vulnerabilities" target="_blank" rel="noopener">XML 漏洞</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/xml.html#defused-packages" target="_blank" rel="noopener">defusedxml 和 defusedexpat 软件包</a> 部分。</p></blockquote><p>值得注意的是 <a href="https://docs.python.org/zh-cn/3.8/library/xml.html#module-xml" target="_blank" rel="noopener"><code>xml</code></a> 包中的模块要求至少有一个 SAX 兼容的 XML 解析器可用。在 Pythonm中包含 Expat 解析器，因此 <a href="https://docs.python.org/zh-cn/3.8/library/pyexpat.html#module-xml.parsers.expat" target="_blank" rel="noopener"><code>xml.parsers.expat</code></a> 模块将始终可用。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.html#module-xml.dom" target="_blank" rel="noopener"><code>xml.dom</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/xml.sax.html#module-xml.sax" target="_blank" rel="noopener"><code>xml.sax</code></a> 包的文档是 DOM 和 SAX 接口的 Python 绑定的定义。</p><p>XML 处理子模块包括:</p><ul><li><p><a href="https://docs.python.org/zh-cn/3.8/library/xml.etree.elementtree.html#module-xml.etree.ElementTree" target="_blank" rel="noopener"><code>xml.etree.ElementTree</code></a>： ElementTree API，一个简单而轻量级的XML处理器</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.html#module-xml.dom" target="_blank" rel="noopener"><code>xml.dom</code></a>：DOM API 定义</p></li><li><a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.minidom.html#module-xml.dom.minidom" target="_blank" rel="noopener"><code>xml.dom.minidom</code></a>：最小的 DOM 实现</li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.pulldom.html#module-xml.dom.pulldom" target="_blank" rel="noopener"><code>xml.dom.pulldom</code></a>：支持构建部分 DOM 树</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/xml.sax.html#module-xml.sax" target="_blank" rel="noopener"><code>xml.sax</code></a>：SAX2 基类和便利函数</p></li><li><a href="https://docs.python.org/zh-cn/3.8/library/pyexpat.html#module-xml.parsers.expat" target="_blank" rel="noopener"><code>xml.parsers.expat</code></a>：Expat解析器绑定</li></ul><h2 id="XML-漏洞"><a href="#XML-漏洞" class="headerlink" title="XML 漏洞"></a>XML 漏洞</h2><p>XML 处理模块对于恶意构造的数据是不安全的。 攻击者可能滥用 XML 功能来执行拒绝服务攻击、访问本地文件、生成与其它计算机的网络连接或绕过防火墙。</p><p>下表概述了已知的攻击以及各种模块是否容易受到攻击。</p><table><thead><tr><th style="text-align:left">种类</th><th style="text-align:left">sax</th><th style="text-align:left">etree</th><th style="text-align:left">minidom</th><th style="text-align:left">pulldom</th><th style="text-align:left">xmlrpc</th></tr></thead><tbody><tr><td style="text-align:left">billion laughs</td><td style="text-align:left"><strong>易受攻击</strong></td><td style="text-align:left"><strong>易受攻击</strong></td><td style="text-align:left"><strong>易受攻击</strong></td><td style="text-align:left"><strong>易受攻击</strong></td><td style="text-align:left"><strong>易受攻击</strong></td></tr><tr><td style="text-align:left">quadratic blowup</td><td style="text-align:left"><strong>易受攻击</strong></td><td style="text-align:left"><strong>易受攻击</strong></td><td style="text-align:left"><strong>易受攻击</strong></td><td style="text-align:left"><strong>易受攻击</strong></td><td style="text-align:left"><strong>易受攻击</strong></td></tr><tr><td style="text-align:left">external entity expansion</td><td style="text-align:left">安全 (4)</td><td style="text-align:left">安全 (1)</td><td style="text-align:left">安全 (2)</td><td style="text-align:left">安全 (4)</td><td style="text-align:left">安全 (3)</td></tr><tr><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Document_type_definition" target="_blank" rel="noopener">DTD</a> retrieval</td><td style="text-align:left">安全 (4)</td><td style="text-align:left">安全</td><td style="text-align:left">安全</td><td style="text-align:left">安全 (4)</td><td style="text-align:left">安全</td></tr><tr><td style="text-align:left">decompression bomb</td><td style="text-align:left">安全</td><td style="text-align:left">安全</td><td style="text-align:left">安全</td><td style="text-align:left">安全</td><td style="text-align:left"><strong>易受攻击</strong></td></tr></tbody></table><ol><li><a href="https://docs.python.org/zh-cn/3.8/library/xml.etree.elementtree.html#module-xml.etree.ElementTree" target="_blank" rel="noopener"><code>xml.etree.ElementTree</code></a> 不会扩展外部实体并在实体发生时引发 <code>ParserError</code>。</li><li><a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.minidom.html#module-xml.dom.minidom" target="_blank" rel="noopener"><code>xml.dom.minidom</code></a> 不会扩展外部实体，只是简单地返回未扩展的实体。</li><li><code>xmlrpclib</code> 不扩展外部实体并省略它们。</li><li>从 Python 3.7.1 开始，默认情况下不再处理外部通用实体。</li></ol><ul><li><p>billion laughs / exponential entity expansion （狂笑/递归实体扩展）</p><p><a href="https://en.wikipedia.org/wiki/Billion_laughs" target="_blank" rel="noopener">Billion Laughs</a> 攻击 – 也称为递归实体扩展 – 使用多级嵌套实体。 每个实体多次引用另一个实体，最终实体定义包含一个小字符串。 指数级扩展导致几千 GB 的文本，并消耗大量内存和 CPU 时间。</p></li><li><p>quadratic blowup entity expansion（二次爆炸实体扩展）</p><p>二次爆炸攻击类似于 <a href="https://en.wikipedia.org/wiki/Billion_laughs" target="_blank" rel="noopener">Billion Laughs</a> 攻击，它也滥用实体扩展。 它不是嵌套实体，而是一遍又一遍地重复一个具有几千个字符的大型实体。攻击不如递归情况有效，但它避免触发禁止深度嵌套实体的解析器对策。</p></li><li><p>external entity expansion</p><p>实体声明可以包含的不仅仅是替换文本。 它们还可以指向外部资源或本地文件。 XML 解析器访问资源并将内容嵌入到 XML 文档中。</p></li><li><p><a href="https://en.wikipedia.org/wiki/Document_type_definition" target="_blank" rel="noopener">DTD</a> retrieval</p><p>Python 的一些 XML 库 <a href="https://docs.python.org/zh-cn/3.8/library/xml.dom.pulldom.html#module-xml.dom.pulldom" target="_blank" rel="noopener"><code>xml.dom.pulldom</code></a> 从远程或本地位置检索文档类型定义。 该功能与外部实体扩展问题具有相似的含义。</p></li><li><p>decompression bomb</p><p>Decompression bombs（解压炸弹，又名 <a href="https://en.wikipedia.org/wiki/Zip_bomb" target="_blank" rel="noopener">ZIP bomb</a>）适用于所有可以解析压缩 XML 流（例如 gzip 压缩的 HTTP 流或 LZMA 压缩的文件）的 XML 库。 对于攻击者来说，它可以将传输的数据量减少三个量级或更多。</p></li></ul><p>PyPI上 <a href="https://pypi.org/project/defusedxml/" target="_blank" rel="noopener">defusedxml</a> 的文档包含有关所有已知攻击向量的更多信息以及示例和参考。</p><h2 id="defusedxml-和-defusedexpat-软件包"><a href="#defusedxml-和-defusedexpat-软件包" class="headerlink" title="defusedxml 和 defusedexpat 软件包"></a><code>defusedxml</code> 和 <code>defusedexpat</code> 软件包</h2><p><a href="https://pypi.org/project/defusedxml/" target="_blank" rel="noopener">defusedxml</a> 是一个纯 Python 软件包，它修改了所有标准库 XML 解析器的子类，可以防止任何潜在的恶意操作。 对于解析不受信任的XML数据的任何服务器代码，建议使用此程序包。 该软件包还提供了有关更多 XML 漏洞（如 XPath 注入）的示例漏洞和扩展文档。</p><p><a href="https://pypi.org/project/defusedexpat/" target="_blank" rel="noopener">defusedexpat</a> 提供了一个修改过的 libexpat 和一个打过补丁的 <code>pyexpat</code> 模块，它有针对实体扩展DoS攻击的对策。 <code>defusedexpat</code> 模块仍然允许合理且可配置的实体扩展量。 这些修改可能包含在 Python 的某些未来版本中，但不会包含在 Python 的任何修复版本中，因为它们会破坏向后兼容性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-XML-处理模块-概述&quot;&gt;&lt;a href=&quot;#python-标准库-XML-处理模块-概述&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 XML 处理模块 (概述)&quot;&gt;&lt;/a&gt;python 标准库 XML 处理模块 (概述)&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200310_huangshi.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="XML" scheme="https://pinghailinfeng.gitee.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library argparse 2</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/09/python-standard-library-argparse-2/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/09/python-standard-library-argparse-2/</id>
    <published>2020-03-09T15:00:05.000Z</published>
    <updated>2020-03-12T13:31:50.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-argparse-续"><a href="#python-标准库-argparse-续" class="headerlink" title="python 标准库 argparse 续"></a>python 标准库 argparse 续</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200310_angrybirds.jpg?raw=true" alt></p><a id="more"></a><p>继续学习 argparse模块</p><h2 id="add-arguments-方法"><a href="#add-arguments-方法" class="headerlink" title="add_arguments 方法"></a>add_arguments 方法</h2><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p><code>help</code>参数主要用于参数的提示信息。 当使用 <code>-h</code> 或者 <code>--help</code> 命令行参数时将会显示下面参数的提示信息.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&apos;frobble&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;, action=&apos;store_true&apos;,</span><br><span class="line">...                     help=&apos;foo the bars before frobbling&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;bar&apos;, nargs=&apos;+&apos;,</span><br><span class="line">...                     help=&apos;one of the bars to be frobbled&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&apos;-h&apos;])</span><br><span class="line">usage: frobble [-h] [--foo] bar [bar ...]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar     one of the bars to be frobbled</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br><span class="line"> --foo   foo the bars before frobbling</span><br></pre></td></tr></table></figure><p>帮助信息字符串可以包含多种类型格式化声明,避免和默认参数相混淆。这里包括 <code>%(prog)s</code> 或<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 参数的众多关键字参数,例如 <code>%(default)s</code>, <code>%(type)s</code>,请看下面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&apos;frobble&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;bar&apos;, nargs=&apos;?&apos;, type=int, default=42,</span><br><span class="line">...                     help=&apos;the bar to %(prog)s (default: %(default)s)&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: frobble [-h] [bar]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar     the bar to frobble (default: 42)</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message and exit</span><br></pre></td></tr></table></figure><p>help 字符串支持 %格式化方式,如果你不希望在帮助字符串附近出现%,最好避免使用%%逃逸字符。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#module-argparse" target="_blank" rel="noopener"><code>argparse</code></a> 支持help入口参数切片,通过设置<code>argparse.SUPPRESS</code>参数就可以支持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&apos;frobble&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;, help=argparse.SUPPRESS)</span><br><span class="line">&gt;&gt;&gt; parser.print_help()</span><br><span class="line">usage: frobble [-h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help  show this help message and exit</span><br></pre></td></tr></table></figure><h3 id="metavar"><a href="#metavar" class="headerlink" title="metavar"></a>metavar</h3><p>当 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 生成帮助消息时，它需要一些方法来引用每个预期的参数。默认情况下，参数分析器对象使用<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> 值作为每个对象的”名称”值。默认情况下，对于位置参数操作，直接使用<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> 值，对于可选参数操作，<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> 值是大写字母。因此，带有<code>dest_bar&#39;bar</code>的单一位置参数将称为”bar”。单个可选参数”-foo”，后面应跟一个命令行参数，将称为”FOO”。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'X --foo Y'</span>.split())</span><br><span class="line">Namespace(bar=<span class="string">'X'</span>, foo=<span class="string">'Y'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage:  [-h] [--foo FOO] bar</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo FOO</span><br></pre></td></tr></table></figure><p>可以使用元变量指定替代名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, metavar=<span class="string">'YYY'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, metavar=<span class="string">'XXX'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'X --foo Y'</span>.split())</span><br><span class="line">Namespace(bar=<span class="string">'X'</span>, foo=<span class="string">'Y'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage:  [-h] [--foo YYY] XXX</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> XXX</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo YYY</span><br></pre></td></tr></table></figure><p><code>metavar</code> 仅更改显示的名称 - parse_args() 对象上属性的名称仍由  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> 确定</p><p>nargs 的不同值可能会导致多次使用 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> 。提供 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> 的元组为每个参数指定不同的显示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-x'</span>, nargs=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="number">2</span>, metavar=(<span class="string">'bar'</span>, <span class="string">'baz'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [-h] [-x X X] [--foo bar baz]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help     show this help message <span class="keyword">and</span> exit</span><br><span class="line"> -x X X</span><br><span class="line"> --foo bar baz</span><br></pre></td></tr></table></figure><h3 id="dest"><a href="#dest" class="headerlink" title="dest"></a>dest</h3><p>大多数  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 操作添加一些值作为由 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 返回的对象的属性。此属性的名称由  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 的<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a>关键字参数确定。对于位置参数操作，<code>dest</code>通常作为第一个参数提供给  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'XXX'</span>])</span><br><span class="line">Namespace(bar=<span class="string">'XXX'</span>)</span><br></pre></td></tr></table></figure><p>对于可选的参数操作，通常从选项字符串中推断出dest的值。 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener">ArgumentParser</a>生成<code>dest</code>的值，方法是提取第一个长选项字符串并去除 初始<code>--</code>字符串。 如果没有提供长选项字符串，则通过剥离开头的“-”字符，从第一个短选项字符串派生“ dest”。 任何内部的-字符都将转换为_字符，以确保该字符串是有效的属性名称。 下面的示例说明了此行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo-bar'</span>, <span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-x'</span>, <span class="string">'-y'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'-f 1 -x 2'</span>.split())</span><br><span class="line">Namespace(foo_bar=<span class="string">'1'</span>, x=<span class="string">'2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'--foo 1 -y 2'</span>.split())</span><br><span class="line">Namespace(foo_bar=<span class="string">'1'</span>, x=<span class="string">'2'</span>)</span><br></pre></td></tr></table></figure><p><code>dest</code> 允许自定义可选属性的名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, dest=<span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'--foo XXX'</span>.split())</span><br><span class="line">Namespace(bar=<span class="string">'XXX'</span>)</span><br></pre></td></tr></table></figure><h3 id="Action-classes"><a href="#Action-classes" class="headerlink" title="Action classes"></a>Action classes</h3><p>这是一个实现了可调用API的函数，该函数返回一个可调用的函数，该可处理函数从命令行处理参数。 遵循此API的任何对象都可以作为操作参数传递给add_argument（）。</p><ul><li><em>class</em> <code>argparse.Action</code>(<em>option_strings</em>, <em>dest</em>, <em>nargs=None</em>, <em>const=None</em>, <em>default=None</em>, <em>type=None</em>, <em>choices=None</em>, <em>required=False</em>, <em>help=None</em>, <em>metavar=None</em>)</li></ul><p>ArgumentParser对象使用动作对象表示从命令行的一个或多个字符串解析单个参数所需的信息。 Action类必须接受两个位置参数以及传递给<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser的任何关键字参数" target="_blank" rel="noopener"><code>ArgumentParser</code>和<code>argument()</code></a>.add_argument()，但<code>action</code>本身除外。</p><p>Action实例（或可调用<code>action</code>参数的任何返回值）应具有定义的属性<code>dest</code>，<code>option_strings</code>，<code>default</code>，<code>type”，“ required</code>，<code>help</code>等。 确保定义这些属性的最简单方法是调用<code>Action .__ init__</code>。</p><p>Action 实例是可调用的，因此子类必须重写<strong>call</strong>方法，该方法应接受四个参数：</p><ul><li><code>parser</code> -  ArgumentParser对象 包含的动作</li><li><code>namespace</code> -  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.Namespace" target="_blank" rel="noopener"><code>Namespace</code></a> 对象通过 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a>方法返回. 大部分actions 通过 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#setattr" target="_blank" rel="noopener"><code>setattr()</code></a>方法添加属性</li><li><code>values</code> - 关联命令行参数,已应用任何类型转换，通过 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a>中的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#type" target="_blank" rel="noopener">type</a> 关键字参数声明类型转换</li><li><code>option_string</code> - 用于调用此操作的选项字符串。 option_string参数是可选的，如果该动作与位置参数相关联，则将不起作用。</li></ul><h2 id="parse-args-方法"><a href="#parse-args-方法" class="headerlink" title="parse_args() 方法"></a>parse_args() 方法</h2><ul><li><p><code>ArgumentParser.`</code>parse_args`(<em>args=None</em>, <em>namespace=None</em>)</p><p>将参数字符串转换为对象，并将其分配为名称空间的属性。 返回填充的名称空间。先前对<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument（）</code></a>的调用确定创建了哪些对象 以及它们的分配方式。 有关详细信息，请参见  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 。</p><ul><li>要解析的字符串列表。 默认值来自<a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.argv" target="_blank" rel="noopener"><code>sys.argv</code></a>。</li><li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#namespace" target="_blank" rel="noopener">namespace</a>）-带有属性的对象。 默认为一个新的空的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.Namespace" target="_blank" rel="noopener"><code>Namespace</code></a> 对象。</li></ul></li></ul><h3 id="Option-value-syntax"><a href="#Option-value-syntax" class="headerlink" title="Option value syntax"></a>Option value syntax</h3><p> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a>方法支持多种方法来指定选项的值（如果 需要一个）。 在最简单的情况下，选项及其值作为两个单独的参数传递：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-x'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-x'</span>, <span class="string">'X'</span>])</span><br><span class="line">Namespace(foo=<span class="literal">None</span>, x=<span class="string">'X'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'FOO'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'FOO'</span>, x=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>对于长选项（名称长于单个字符的选项），选项和值也可以作为单个命令行参数传递，使用<code>=</code>分隔它们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo=FOO'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'FOO'</span>, x=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>对于短选项（选项仅一个字符长），可以将选项及其值连接在一起：    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-xX'</span>])</span><br><span class="line">Namespace(foo=<span class="literal">None</span>, x=<span class="string">'X'</span>)</span><br></pre></td></tr></table></figure><p>只要仅最后一个选项（或其中一个都不要求）需要一个值，几个短选项可以仅使用一个前缀-组合在一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-x'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-y'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-z'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-xyzZ'</span>])</span><br><span class="line">Namespace(x=<span class="literal">True</span>, y=<span class="literal">True</span>, z=<span class="string">'Z'</span>)</span><br></pre></td></tr></table></figure><h3 id="无效的参数"><a href="#无效的参数" class="headerlink" title="无效的参数"></a>无效的参数</h3><p>  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 检查各种错误，包括 模棱两可的选项，无效的类型，无效的选项，错误的位置参数数量等。遇到此类错误时，它将退出并打印错误以及用法消息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, type=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'?'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># invalid type</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'spam'</span>])</span><br><span class="line">usage: PROG [-h] [--foo FOO] [bar]</span><br><span class="line">PROG: error: argument --foo: invalid int value: <span class="string">'spam'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># invalid option</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--bar'</span>])</span><br><span class="line">usage: PROG [-h] [--foo FOO] [bar]</span><br><span class="line">PROG: error: no such option: --bar</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># wrong number of arguments</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'spam'</span>, <span class="string">'badger'</span>])</span><br><span class="line">usage: PROG [-h] [--foo FOO] [bar]</span><br><span class="line">PROG: error: extra arguments found: badger</span><br></pre></td></tr></table></figure><h3 id="包含-的参数"><a href="#包含-的参数" class="headerlink" title="包含 - 的参数"></a>包含 <code>-</code> 的参数</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a>方法尝试在用户明显犯错时给出错误 ，但某些情况本质上是模棱两可的。 例如，命令行参数-1可以是尝试指定选项，也可以是提供位置参数。 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 方法在这里非常谨慎：位置参数只能以<code>-</code>如果它们看起来像负数，并且解析器中没有选项看起来像负数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-x'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, nargs=<span class="string">'?'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># no negative number options, so -1 is a positional argument</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-x'</span>, <span class="string">'-1'</span>])</span><br><span class="line">Namespace(foo=<span class="literal">None</span>, x=<span class="string">'-1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># no negative number options, so -1 and -5 are positional arguments</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-x'</span>, <span class="string">'-1'</span>, <span class="string">'-5'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'-5'</span>, x=<span class="string">'-1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-1'</span>, dest=<span class="string">'one'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, nargs=<span class="string">'?'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># negative number options present, so -1 is an option</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-1'</span>, <span class="string">'X'</span>])</span><br><span class="line">Namespace(foo=<span class="literal">None</span>, one=<span class="string">'X'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># negative number options present, so -2 is an option</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-2'</span>])</span><br><span class="line">usage: PROG [-h] [<span class="number">-1</span> ONE] [foo]</span><br><span class="line">PROG: error: no such option: <span class="number">-2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># negative number options present, so both -1s are options</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-1'</span>, <span class="string">'-1'</span>])</span><br><span class="line">usage: PROG [-h] [<span class="number">-1</span> ONE] [foo]</span><br><span class="line">PROG: error: argument <span class="number">-1</span>: expected one argument</span><br></pre></td></tr></table></figure><p>如果您的位置参数必须以<code>-</code>开头并且看起来不像负数，则可以插入伪参数<code>&#39;-&#39;</code>来告诉<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a>  之后的所有内容都是位置参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--'</span>, <span class="string">'-f'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'-f'</span>, one=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h3 id="参数缩写（前缀匹配）"><a href="#参数缩写（前缀匹配）" class="headerlink" title="参数缩写（前缀匹配）"></a>参数缩写（前缀匹配）</h3><p>The <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> method <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#allow-abbrev" target="_blank" rel="noopener">by default</a> allows long options to be abbreviated to a prefix, if the abbreviation is unambiguous (the prefix matches a unique option):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-bacon'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-badger'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'-bac MMM'</span>.split())</span><br><span class="line">Namespace(bacon=<span class="string">'MMM'</span>, badger=<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'-bad WOOD'</span>.split())</span><br><span class="line">Namespace(bacon=<span class="literal">None</span>, badger=<span class="string">'WOOD'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'-ba BA'</span>.split())</span><br><span class="line">usage: PROG [-h] [-bacon BACON] [-badger BADGER]</span><br><span class="line">PROG: error: ambiguous option: -ba could match -badger, -bacon</span><br></pre></td></tr></table></figure><p>对于可能产生多个选项的参数会产生错误。 可以通过将 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#allow-abbrev" target="_blank" rel="noopener">allow_abbrev</a>设置为False来禁用此功能。</p><h3 id="Beyond-sys-argv¶"><a href="#Beyond-sys-argv¶" class="headerlink" title="Beyond sys.argv¶"></a>Beyond <code>sys.argv</code><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#beyond-sys-argv" target="_blank" rel="noopener">¶</a></h3><p>有时让ArgumentParser解析除之外的参数可能会很有用。 这可以通过将字符串列表传递给<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a>来完成。 这对于在交互式提示符下进行测试很有用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(</span><br><span class="line"><span class="meta">... </span>    <span class="string">'integers'</span>, metavar=<span class="string">'int'</span>, type=int, choices=range(<span class="number">10</span>),</span><br><span class="line"><span class="meta">... </span>    nargs=<span class="string">'+'</span>, help=<span class="string">'an integer in the range 0..9'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(</span><br><span class="line"><span class="meta">... </span>    <span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>, const=sum,</span><br><span class="line"><span class="meta">... </span>    default=max, help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>])</span><br><span class="line">Namespace(accumulate=&lt;built-<span class="keyword">in</span> function max&gt;, integers=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'--sum'</span>])</span><br><span class="line">Namespace(accumulate=&lt;built-<span class="keyword">in</span> function sum&gt;, integers=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><h3 id="命名空间对象"><a href="#命名空间对象" class="headerlink" title="命名空间对象"></a>命名空间对象</h3><ul><li><p><em>class</em> <code>argparse.`</code>Namespace`</p><p>默认情况下由<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 使用的简单类来创建保存属性并返回的对象 它。</p></li></ul><p>此类是故意简化的，只是一个具有可读字符串表示形式的<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a>子类。 如果您希望对属性有类似dict的视图，可以使用标准的Python习惯用法<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#vars" target="_blank" rel="noopener"><code>vars()</code></a>#vars）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'BAR'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(args)</span><br><span class="line">&#123;<span class="string">'foo'</span>: <span class="string">'BAR'</span>&#125;</span><br></pre></td></tr></table></figure><p>让  <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a>  将属性分配给已经存在的对象，而不是 一个新的[ <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.Namespace" target="_blank" rel="noopener"><code>Namespace</code></a>  对象。 这可以通过指定<code>namespace =</code>关键字参数来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(args=[<span class="string">'--foo'</span>, <span class="string">'BAR'</span>], namespace=c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.foo</span><br><span class="line"><span class="string">'BAR'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-argparse-续&quot;&gt;&lt;a href=&quot;#python-标准库-argparse-续&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 argparse 续&quot;&gt;&lt;/a&gt;python 标准库 argparse 续&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200310_angrybirds.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="argparse" scheme="https://pinghailinfeng.gitee.io/tags/argparse/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library argparse</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/08/python-standard-library-argparse/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/08/python-standard-library-argparse/</id>
    <published>2020-03-08T13:39:27.000Z</published>
    <updated>2020-03-12T13:31:50.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-argparse-命令行选项"><a href="#python-标准库-argparse-命令行选项" class="headerlink" title="python 标准库 argparse 命令行选项"></a>python 标准库 argparse 命令行选项</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200308_Altered_Carbon2.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词:</p><p> eternity  n 永恒  不朽</p><p>近义词:</p><p> invariability  n 恒久不变的东西</p><p> perpetuity  n 永久 永恒</p><p> timelessness　 n 永恒</p><p> permanence　  n 永久 持久</p><p> everlasting  adj永恒的 </p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/argparse.py" target="_blank" rel="noopener">Lib/argparse.py</a> </p><p> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#module-argparse" target="_blank" rel="noopener"><code>argparse</code></a> 模块可以让人轻松编写用户友好的命令行接口。程序定义它需要的参数，然后 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#module-argparse" target="_blank" rel="noopener"><code>argparse</code></a> 将弄清如何从 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.argv" target="_blank" rel="noopener"><code>sys.argv</code></a> 解析出那些参数。 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#module-argparse" target="_blank" rel="noopener"><code>argparse</code></a> 模块还会自动生成帮助和使用手册，并在用户给程序传入无效参数时报出错误信息。 </p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p> 以下代码是一个 Python 程序，它获取一个整数列表并计算总和或者最大值： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                    help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                    const=sum, default=max,</span><br><span class="line">                    help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args.accumulate(args.integers))</span><br></pre></td></tr></table></figure><p> 假设上面的 Python 代码保存在名为 <code>prog.py</code> 的文件中，它可以在命令行运行并提供有用的帮助消息： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python prog.py -h</span><br><span class="line">usage: prog.py [-h] [--sum] N [N ...]</span><br><span class="line"></span><br><span class="line">Process some integers.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> N           an integer <span class="keyword">for</span> the accumulator</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --sum       sum the integers (default: find the max)</span><br></pre></td></tr></table></figure><p> 当使用适当的参数运行时，它会输出命令行传入整数的总和或者最大值： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python prog.py <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line">$ python prog.py <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> --sum</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p> 如果传入无效参数，则会报出错误： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python prog.py a b c</span><br><span class="line">usage: prog.py [-h] [--sum] N [N ...]</span><br><span class="line">prog.py: error: argument N: invalid int value: <span class="string">'a'</span></span><br></pre></td></tr></table></figure><p> 以下部分将引导你完成这个示例。 </p><h3 id="创建一个解析器"><a href="#创建一个解析器" class="headerlink" title="创建一个解析器"></a>创建一个解析器</h3><p> 使用 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#module-argparse" target="_blank" rel="noopener"><code>argparse</code></a> 的第一步是创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br></pre></td></tr></table></figure><p> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象包含将命令行解析成 Python 数据类型所需的全部信息。 </p><h3 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h3><p> 给一个 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 添加程序参数信息是通过调用 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 方法完成的。通常，这些调用指定 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 如何获取命令行字符串并将其转换为对象。这些信息在 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 调用时被存储和使用。例如： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line"><span class="meta">... </span>                    help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line"><span class="meta">... </span>                    const=sum, default=max,</span><br><span class="line"><span class="meta">... </span>                    help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br></pre></td></tr></table></figure><p> 稍后，调用 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 将返回一个具有 <code>integers</code> 和 <code>accumulate</code> 两个属性的对象。<code>integers</code> 属性将是一个包含一个或多个整数的列表，而 <code>accumulate</code> 属性当命令行中指定了 <code>--sum</code> 参数时将是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sum" target="_blank" rel="noopener"><code>sum()</code></a> 函数，否则则是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#max" target="_blank" rel="noopener"><code>max()</code></a> 函数。 </p><h3 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h3><p> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 通过 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 方法解析参数。它将检查命令行，把每个参数转换为适当的类型然后调用相应的操作。在大多数情况下，这意味着一个简单的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.Namespace" target="_blank" rel="noopener"><code>Namespace</code></a> 对象将从命令行参数中解析出的属性构建： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--sum'</span>, <span class="string">'7'</span>, <span class="string">'-1'</span>, <span class="string">'42'</span>])</span><br><span class="line">Namespace(accumulate=&lt;built-<span class="keyword">in</span> function sum&gt;, integers=[<span class="number">7</span>, <span class="number">-1</span>, <span class="number">42</span>])</span><br></pre></td></tr></table></figure><p> 在脚本中，通常 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 会被不带参数调用，而 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 将自动从 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.argv" target="_blank" rel="noopener"><code>sys.argv</code></a> 中确定命令行参数。 </p><h2 id="ArgumentParser-对象"><a href="#ArgumentParser-对象" class="headerlink" title="ArgumentParser 对象"></a>ArgumentParser 对象</h2><p>  创建一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象。所有的参数都应当作为关键字参数传入。每个参数在下面都有它更详细的描述，但简而言之，它们是：</p><ul><li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#prog" target="_blank" rel="noopener">prog</a> - 程序的名称（默认：<code>sys.argv[0]</code>）</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#usage" target="_blank" rel="noopener">usage</a> - 描述程序用途的字符串（默认值：从添加到解析器的参数生成）</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#description" target="_blank" rel="noopener">description</a> - 在参数帮助文档之前显示的文本（默认值：无）</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#epilog" target="_blank" rel="noopener">epilog</a> - 在参数帮助文档之后显示的文本（默认值：无）</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#parents" target="_blank" rel="noopener">parents</a> - 一个 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象的列表，它们的参数也应包含在内</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#formatter-class" target="_blank" rel="noopener">formatter_class</a> - 用于自定义帮助文档输出格式的类</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#prefix-chars" target="_blank" rel="noopener">prefix_chars</a> - 可选参数的前缀字符集合（默认值：’-‘）</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#fromfile-prefix-chars" target="_blank" rel="noopener">fromfile_prefix_chars</a> - 当需要从文件中读取其他参数时，用于标识文件名的前缀字符集合（默认值：<code>None</code>）</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argument-default" target="_blank" rel="noopener">argument_default</a> - 参数的全局默认值（默认值： <code>None</code>）</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#conflict-handler" target="_blank" rel="noopener">conflict_handler</a> - 解决冲突选项的策略（通常是不必要的）</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#add-help" target="_blank" rel="noopener">add_help</a> - 为解析器添加一个 <code>-h/--help</code> 选项（默认值： <code>True</code>）</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#allow-abbrev" target="_blank" rel="noopener">allow_abbrev</a> - 如果缩写是无歧义的，则允许缩写长选项 （默认值：<code>True</code>）</p></li></ul><p>以下部分描述这些参数如何使用。 </p><h3 id="prog"><a href="#prog" class="headerlink" title="prog"></a>prog</h3><p> 默认情况下，<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象使用 <code>sys.argv[0]</code> 来确定如何在帮助消息中显示程序名称。这一默认值几乎总是可取的，因为它将使帮助消息与从命令行调用此程序的方式相匹配。例如，对于有如下代码的名为 <code>myprogram.py</code> 的文件： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>, help=<span class="string">'foo help'</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><p> 该程序的帮助信息将显示 <code>myprogram.py</code> 作为程序名称（无论程序从何处被调用）： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ python myprogram.py --help</span><br><span class="line">usage: myprogram.py [-h] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo FOO   foo help</span><br><span class="line">$ cd ..</span><br><span class="line">$ python subdir/myprogram.py --help</span><br><span class="line">usage: myprogram.py [-h] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo FOO   foo help</span><br></pre></td></tr></table></figure><p> 要更改这样的默认行为，可以使用 <code>prog=</code> 参数为 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 提供另一个值： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'myprogram'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: myprogram [-h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br></pre></td></tr></table></figure><p> 需要注意的是，无论是从 <code>sys.argv[0]</code> 或是从 <code>prog=</code> 参数确定的程序名称，都可以在帮助消息里通过 <code>%(prog)s</code> 格式串来引用。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'myprogram'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, help=<span class="string">'foo of the %(prog)s program'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: myprogram [-h] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo FOO   foo of the myprogram program</span><br></pre></td></tr></table></figure><h3 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h3><p> 默认情况下，<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 根据它包含的参数来构建用法消息： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="string">'?'</span>, help=<span class="string">'foo help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'+'</span>, help=<span class="string">'bar help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [-h] [--foo [FOO]] bar [bar ...]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar          bar help</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help   show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo [FOO]  foo help</span><br></pre></td></tr></table></figure><p> 可以通过 <code>usage=</code> 关键字参数覆盖这一默认消息： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>, usage=<span class="string">'%(prog)s [options]'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="string">'?'</span>, help=<span class="string">'foo help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'+'</span>, help=<span class="string">'bar help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [options]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar          bar help</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help   show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo [FOO]  foo help</span><br></pre></td></tr></table></figure><p> 在用法消息中可以使用 <code>%(prog)s</code> 格式说明符来填入程序名称。 </p><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p> 大多数对 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 构造方法的调用都会使用 <code>description=</code> 关键字参数。这个参数简要描述这个程度做什么以及怎么做。在帮助消息中，这个描述会显示在命令行用法字符串和各种参数的帮助消息之间： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(description=<span class="string">'A foo that bars'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: argparse.py [-h]</span><br><span class="line"></span><br><span class="line">A foo that bars</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br></pre></td></tr></table></figure><p> 在默认情况下，description 将被换行以便适应给定的空间。如果想改变这种行为，见 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#formatter-class" target="_blank" rel="noopener">formatter_class</a> 参数。 </p><h3 id="epilog"><a href="#epilog" class="headerlink" title="epilog"></a>epilog</h3><p> 一些程序喜欢在 description 参数后显示额外的对程序的描述。这种文字能够通过给 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a>:: 提供 <code>epilog=</code> 参数而被指定。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(</span><br><span class="line"><span class="meta">... </span>    description=<span class="string">'A foo that bars'</span>,</span><br><span class="line"><span class="meta">... </span>    epilog=<span class="string">"And that's how you'd foo a bar"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: argparse.py [-h]</span><br><span class="line"></span><br><span class="line">A foo that bars</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"></span><br><span class="line">And that<span class="string">'s how you'</span>d foo a bar</span><br></pre></td></tr></table></figure><p> 和 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#description" target="_blank" rel="noopener">description</a> 参数一样，<code>epilog=</code> text 在默认情况下会换行，但是这种行为能够被调整通过提供 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#formatter-class" target="_blank" rel="noopener">formatter_class</a> 参数给 <code>ArgumentParse</code>. </p><h3 id="parents"><a href="#parents" class="headerlink" title="parents"></a>parents</h3><p> 有些时候，少数解析器会使用同一系列参数。 单个解析器能够通过提供 <code>parents=</code> 参数给 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 而使用相同的参数而不是重复这些参数的定义。<code>parents=</code> 参数使用 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象的列表，从它们那里收集所有的位置和可选的行为，然后将这写行为加到正在构建的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parent_parser = argparse.ArgumentParser(add_help=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parent_parser.add_argument(<span class="string">'--parent'</span>, type=int)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo_parser = argparse.ArgumentParser(parents=[parent_parser])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo_parser.add_argument(<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo_parser.parse_args([<span class="string">'--parent'</span>, <span class="string">'2'</span>, <span class="string">'XXX'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'XXX'</span>, parent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar_parser = argparse.ArgumentParser(parents=[parent_parser])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar_parser.add_argument(<span class="string">'--bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar_parser.parse_args([<span class="string">'--bar'</span>, <span class="string">'YYY'</span>])</span><br><span class="line">Namespace(bar=<span class="string">'YYY'</span>, parent=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p> 请注意大多数父解析器会指定 <code>add_help=False</code> . 否则， <code>ArgumentParse</code> 将会看到两个 <code>-h/--help</code> 选项（一个在父参数中一个在子参数中）并且产生一个错误。 </p><blockquote><p> 你在传parents=给那些解析器时必须完全初始化它们。如果你在子解析器之后改变父解析器是，这些改变不会反映在子解析器上。 </p></blockquote><h3 id="formatter-class"><a href="#formatter-class" class="headerlink" title="formatter_class"></a>formatter_class</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象允许通过指定备用格式化类来自定义帮助格式。目前，有四种这样的类。</p><ul><li><em>class</em> <code>argparse.RawDescriptionHelpFormatter</code></li><li><em>class</em> <code>argparse.RawTextHelpFormatter</code></li><li><em>class</em> <code>argparse.ArgumentDefaultsHelpFormatter</code></li><li><p><em>class</em> <code>argparse.MetavarTypeHelpFormatter</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.RawDescriptionHelpFormatter" target="_blank" rel="noopener"><code>RawDescriptionHelpFormatter</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.RawTextHelpFormatter" target="_blank" rel="noopener"><code>RawTextHelpFormatter</code></a> 在正文的描述和展示上给与了更多的控制。<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象会将 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#description" target="_blank" rel="noopener">description</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#epilog" target="_blank" rel="noopener">epilog</a> 的文字在命令行中自动换行。 </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(</span><br><span class="line"><span class="meta">... </span>    prog=<span class="string">'PROG'</span>,</span><br><span class="line"><span class="meta">... </span>    description=<span class="string">'''this description</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        was indented weird</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            but that is okay'''</span>,</span><br><span class="line"><span class="meta">... </span>    epilog=<span class="string">'''</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            likewise for this epilog whose whitespace will</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        be cleaned up and whose words will be wrapped</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        across a couple lines'''</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [-h]</span><br><span class="line"></span><br><span class="line">this description was indented weird but that <span class="keyword">is</span> okay</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"></span><br><span class="line">likewise <span class="keyword">for</span> this epilog whose whitespace will be cleaned up <span class="keyword">and</span> whose words</span><br><span class="line">will be wrapped across a couple lines</span><br></pre></td></tr></table></figure><p> 传 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.RawDescriptionHelpFormatter" target="_blank" rel="noopener"><code>RawDescriptionHelpFormatter</code></a> 给 <code>formatter_class=</code> 表示 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#description" target="_blank" rel="noopener">description</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#epilog" target="_blank" rel="noopener">epilog</a> 已经被正确的格式化了，不能在命令行中被自动换行: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(</span><br><span class="line"><span class="meta">... </span>    prog=<span class="string">'PROG'</span>,</span><br><span class="line"><span class="meta">... </span>    formatter_class=argparse.RawDescriptionHelpFormatter,</span><br><span class="line"><span class="meta">... </span>    description=textwrap.dedent(<span class="string">'''\</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        Please do not mess up this text!</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        --------------------------------</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            I have indented it</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            exactly the way</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            I want it</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        '''</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [-h]</span><br><span class="line"></span><br><span class="line">Please do <span class="keyword">not</span> mess up this text!</span><br><span class="line">--------------------------------</span><br><span class="line">   I have indented it</span><br><span class="line">   exactly the way</span><br><span class="line">   I want it</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.RawTextHelpFormatter" target="_blank" rel="noopener"><code>RawTextHelpFormatter</code></a> 保留所有种类文字的空格，包括参数的描述。然而，多重的新行会被替换成一行。如果你想保留多重的空白行，可以在新行之间加空格。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentDefaultsHelpFormatter" target="_blank" rel="noopener"><code>ArgumentDefaultsHelpFormatter</code></a> 自动添加默认的值的信息到每一个帮助信息的参数中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(</span><br><span class="line"><span class="meta">... </span>    prog=<span class="string">'PROG'</span>,</span><br><span class="line"><span class="meta">... </span>    formatter_class=argparse.ArgumentDefaultsHelpFormatter)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, type=int, default=<span class="number">42</span>, help=<span class="string">'FOO!'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'*'</span>, default=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], help=<span class="string">'BAR!'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [-h] [--foo FOO] [bar [bar ...]]</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> bar         BAR! (default: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo FOO   FOO! (default: <span class="number">42</span>)</span><br></pre></td></tr></table></figure><p> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.MetavarTypeHelpFormatter" target="_blank" rel="noopener"><code>MetavarTypeHelpFormatter</code></a> 为它的值在每一个参数中使用 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#type" target="_blank" rel="noopener">type</a> 的参数名当作它的显示名（而不是使用通常的格式 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> ): </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(</span><br><span class="line"><span class="meta">... </span>    prog=<span class="string">'PROG'</span>,</span><br><span class="line"><span class="meta">... </span>    formatter_class=argparse.MetavarTypeHelpFormatter)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, type=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, type=float)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [-h] [--foo int] float</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  float</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line">  --foo int</span><br></pre></td></tr></table></figure><h3 id="prefix-chars"><a href="#prefix-chars" class="headerlink" title="prefix_chars"></a>prefix_chars</h3><p>许多命令行会使用 <code>-</code> 当作前缀，比如 <code>-f/--foo</code>。如果解析器需要支持不同的或者额外的字符，比如像 <code>+f</code> 或者 <code>/foo</code> 的选项，可以在参数解析构建器中使用 <code>prefix_chars=</code> 参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>, prefix_chars=<span class="string">'-+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'+f'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'++bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'+f X ++bar Y'</span>.split())</span><br><span class="line">Namespace(bar=<span class="string">'Y'</span>, f=<span class="string">'X'</span>)</span><br></pre></td></tr></table></figure><p> The <code>prefix_chars=</code> 参数默认使用 <code>&#39;-&#39;</code>. 支持一系列字符，但是不包括 <code>-</code> ，这样会产生不被允许的 <code>-f/--foo</code> 选项。 </p><h3 id="fromfile-prefix-chars"><a href="#fromfile-prefix-chars" class="headerlink" title="fromfile_prefix_chars"></a>fromfile_prefix_chars</h3><p> 有些时候，先举个例子，当处理一个特别长的参数列表的时候，把它存入一个文件中而不是在命令行打出来会很有意义。如果 <code>fromfile_prefix_chars=</code> 参数提供给 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 构造函数，之后所有类型的字符的参数都会被当成文件处理，并且会被文件包含的参数替代。举个栗子: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'args.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> fp:</span><br><span class="line"><span class="meta">... </span>    fp.write(<span class="string">'-f\nbar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(fromfile_prefix_chars=<span class="string">'@'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-f'</span>, <span class="string">'foo'</span>, <span class="string">'@args.txt'</span>])</span><br><span class="line">Namespace(f=<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p>从文件读取的参数在默认情况下必须一个一行（但是可参见 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.convert_arg_line_to_args" target="_blank" rel="noopener"><code>convert_arg_line_to_args()</code></a>）并且它们被视为与命令行上的原始文件引用参数位于同一位置。所以在以上例子中，<code>[&#39;-f&#39;, &#39;foo&#39;, &#39;@args.txt&#39;]</code> 的表示和 <code>[&#39;-f&#39;, &#39;foo&#39;, &#39;-f&#39;, &#39;bar&#39;]</code> 的表示相同。</p><p><code>fromfile_prefix_chars=</code> 参数默认为 <code>None</code>，意味着参数不会被当作文件对待。</p><h3 id="argument-default"><a href="#argument-default" class="headerlink" title="argument_default"></a>argument_default</h3><p> 一般情况下，参数默认会通过设置一个默认到 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 或者调用带一组指定键值对的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.set_defaults" target="_blank" rel="noopener"><code>ArgumentParser.set_defaults()</code></a> 方法。但是有些时候，为参数指定一个普遍适用的解析器会更有用。这能够通过传输 <code>argument_default=</code> 关键词参数给 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 来完成。举个栗子，要全局禁止在 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 中创建属性，我们提供 <code>argument_default=SUPPRESS</code>: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'?'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'1'</span>, <span class="string">'BAR'</span>])</span><br><span class="line">Namespace(bar=<span class="string">'BAR'</span>, foo=<span class="string">'1'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">Namespace()</span><br></pre></td></tr></table></figure><h3 id="allow-abbrev"><a href="#allow-abbrev" class="headerlink" title="allow_abbrev"></a>allow_abbrev</h3><p>正常情况下，当你向 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 方法传入一个参数列表时，它会 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#prefix-matching" target="_blank" rel="noopener">recognizes abbreviations</a>。</p><p>这个特性可以设置 <code>allow_abbrev</code> 为 <code>False</code> 来关闭:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>, allow_abbrev=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foobar'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foonley'</span>, action=<span class="string">'store_false'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foon'</span>])</span><br><span class="line">usage: PROG [-h] [--foobar] [--foonley]</span><br><span class="line">PROG: error: unrecognized arguments: --foon</span><br></pre></td></tr></table></figure><h3 id="conflict-handler"><a href="#conflict-handler" class="headerlink" title="conflict_handler"></a>conflict_handler</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象不允许在相同选项字符串下有两种行为。默认情况下， <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象会产生一个异常如果去创建一个正在使用的选项字符串参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo'</span>, help=<span class="string">'old foo help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, help=<span class="string">'new foo help'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> ..</span><br><span class="line">ArgumentError: argument --foo: conflicting option string(s): --foo</span><br></pre></td></tr></table></figure><p> 有些时候（例如：使用 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#parents" target="_blank" rel="noopener">parents</a>），重写旧的有相同选项字符串的参数会更有用。为了产生这种行为， <code>&#39;resolve&#39;</code> 值可以提供给 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 的 <code>conflict_handler=</code> 参数: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>, conflict_handler=<span class="string">'resolve'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo'</span>, help=<span class="string">'old foo help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, help=<span class="string">'new foo help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [-h] [-f FOO] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> -f FOO      old foo help</span><br><span class="line"> --foo FOO   new foo help</span><br></pre></td></tr></table></figure><p> <strong>注意</strong> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象只能移除一个行为如果它所有的选项字符串都被重写。所以，在上面的例子中，旧的 <code>-f/--foo</code> 行为 回合 <code>-f</code> 行为保持一样, 因为只有 <code>--foo</code> 选项字符串被重写。 </p><h3 id="add-help"><a href="#add-help" class="headerlink" title="add_help"></a>add_help</h3><p> 默认情况下，ArgumentParser 对象添加一个简单的显示解析器帮助信息的选项。举个栗子，考虑一个名为 <code>myprogram.py</code> 的文件包含如下代码: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--foo'</span>, help=<span class="string">'foo help'</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><p> 如果 <code>-h</code> or <code>--help</code> 在命令行中被提供, 参数解析器帮助信息会打印: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python myprogram.py --help</span><br><span class="line">usage: myprogram.py [-h] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --help  show this help message <span class="keyword">and</span> exit</span><br><span class="line"> --foo FOO   foo help</span><br></pre></td></tr></table></figure><p>有时候可能会需要关闭额外的帮助信息。这可以通过在 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 中设置 <code>add_help=</code> 参数为 <code>False</code> 来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>, add_help=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, help=<span class="string">'foo help'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> --foo FOO  foo help</span><br></pre></td></tr></table></figure><p>帮助选项一般为 <code>-h/--help</code>。如果 <code>prefix_chars=</code> 被指定并且没有包含 <code>-</code> 字符，在这种情况下， <code>-h</code> <code>--help</code> 不是有效的选项。此时， <code>prefix_chars</code> 的第一个字符将用作帮助选项的前缀。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>, prefix_chars=<span class="string">'+/'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.print_help()</span><br><span class="line">usage: PROG [+h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  +h, ++help  show this help message <span class="keyword">and</span> exit</span><br></pre></td></tr></table></figure><h2 id="add-argument-方法"><a href="#add-argument-方法" class="headerlink" title="add_argument() 方法"></a>add_argument() 方法</h2><p> <code>ArgumentParser.add_argument</code>(<em>name or flags…</em>[, <em>action</em>][, <em>nargs</em>][, <em>const</em>][, <em>default</em>][, <em>type</em>][, <em>choices</em>][, <em>required</em>][, <em>help</em>][, <em>metavar</em>][, <em>dest</em>]) </p><p>定义单个的命令行参数应当如何解析。每个形参都在下面有它自己更多的描述，长话短说有：</p><ul><li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#name-or-flags" target="_blank" rel="noopener">name or flags</a> - 一个命名或者一个选项字符串的列表，例如 <code>foo</code> 或 <code>-f, --foo</code>。</li><li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#action" target="_blank" rel="noopener">action</a> - 当参数在命令行中出现时使用的动作基本类型。</li><li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#nargs" target="_blank" rel="noopener">nargs</a> - 命令行参数应当消耗的数目。</li><li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#const" target="_blank" rel="noopener">const</a> - 被一些 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#action" target="_blank" rel="noopener">action</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#nargs" target="_blank" rel="noopener">nargs</a> 选择所需求的常数。</li><li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#default" target="_blank" rel="noopener">default</a> - 当参数未在命令行中出现时使用的值。</li><li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#type" target="_blank" rel="noopener">type</a> - 命令行参数应当被转换成的类型。</li><li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#choices" target="_blank" rel="noopener">choices</a> - 可用的参数的容器。</li><li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#required" target="_blank" rel="noopener">required</a> - 此命令行选项是否可省略 （仅选项可用）。</li><li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#help" target="_blank" rel="noopener">help</a> - 一个此选项作用的简单描述。</li><li><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#metavar" target="_blank" rel="noopener">metavar</a> - 在使用方法消息中使用的参数值示例。</li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#dest" target="_blank" rel="noopener">dest</a> - 被添加到 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 所返回对象上的属性名。</p><p>以下部分描述这些参数如何使用。 </p></li></ul><h3 id="name-or-flags"><a href="#name-or-flags" class="headerlink" title="name or flags"></a>name or flags</h3><p> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 方法必须知道它是否是一个选项，例如 <code>-f</code> 或 <code>--foo</code>，或是一个位置参数，例如一组文件名。第一个传递给 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 的参数必须是一系列 flags 或者是一个简单的参数名。例如，可以选项可以被这样创建: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo'</span>)</span><br></pre></td></tr></table></figure><p>而位置参数可以这么创建:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><p>当 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 被调用，选项会以 <code>-</code> 前缀识别，剩下的参数则会被假定为位置参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'-f'</span>, <span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'BAR'</span>])</span><br><span class="line">Namespace(bar=<span class="string">'BAR'</span>, foo=<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'BAR'</span>, <span class="string">'--foo'</span>, <span class="string">'FOO'</span>])</span><br><span class="line">Namespace(bar=<span class="string">'BAR'</span>, foo=<span class="string">'FOO'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'FOO'</span>])</span><br><span class="line">usage: PROG [-h] [-f FOO] bar</span><br><span class="line">PROG: error: the following arguments are required: bar</span><br></pre></td></tr></table></figure><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p> <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象将命令行参数与动作相关联。这些动作可以做与它们相关联的命令行参数的任何事，尽管大多数动作只是简单的向 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 返回的对象上添加属性。<code>action</code> 命名参数指定了这个命令行参数应当如何处理。供应的动作有： </p><ul><li><p><code>&#39;store&#39;</code> - 存储参数的值。这是默认的动作。例如: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'--foo 1'</span>.split())</span><br><span class="line">Namespace(foo=<span class="string">'1'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>&#39;store_const&#39;</code> - 存储被 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#const" target="_blank" rel="noopener">const</a> 命名参数指定的值。 <code>&#39;store_const&#39;</code> 动作通常用在选项中来指定一些标志。例如: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store_const'</span>, const=<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>])</span><br><span class="line">Namespace(foo=<span class="number">42</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>&#39;store_true&#39;</code> and <code>&#39;store_false&#39;</code> - 这些是 <code>&#39;store_const&#39;</code> 分别用作存储 <code>True</code> 和 <code>False</code> 值的特殊用例。另外，它们的默认值分别为 <code>False</code> 和 <code>True</code>。例如: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--bar'</span>, action=<span class="string">'store_false'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--baz'</span>, action=<span class="string">'store_false'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'--foo --bar'</span>.split())</span><br><span class="line">Namespace(foo=<span class="literal">True</span>, bar=<span class="literal">False</span>, baz=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>&#39;append&#39;</code> - 存储一个列表，并且将每个参数值追加到列表中。在允许多次使用选项时很有用。例如: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, action=<span class="string">'append'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'--foo 1 --foo 2'</span>.split())</span><br><span class="line">Namespace(foo=[<span class="string">'1'</span>, <span class="string">'2'</span>])</span><br></pre></td></tr></table></figure></li><li><p><code>&#39;append_const&#39;</code> - 这存储一个列表，并将 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#const" target="_blank" rel="noopener">const</a> 命名参数指定的值追加到列表中。（注意 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#const" target="_blank" rel="noopener">const</a> 命名参数默认为 <code>None</code>。）’append_const’ 动作一般在多个参数需要在同一列表中存储常数时会有用。例如: </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--str'</span>, dest=<span class="string">'types'</span>, action=<span class="string">'append_const'</span>, const=str)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--int'</span>, dest=<span class="string">'types'</span>, action=<span class="string">'append_const'</span>, const=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'--str --int'</span>.split())</span><br><span class="line">Namespace(types=[&lt;class 'str'&gt;, &lt;class 'int'&gt;])</span><br></pre></td></tr></table></figure></li><li><p><code>&#39;count&#39;</code> - 计算一个关键字参数出现的数目或次数。例如，对于一个增长的详情等级来说有用: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--verbose'</span>, <span class="string">'-v'</span>, action=<span class="string">'count'</span>, default=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'-vvv'</span>])</span><br><span class="line">Namespace(verbose=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p> Note, the <em>default</em> will be <code>None</code> unless explicitly set to <em>0</em>. </p></li><li><p><code>&#39;help&#39;</code> - 打印所有当前解析器中的选项和参数的完整帮助信息，然后退出。默认情况下，一个 help 动作会被自动加入解析器。关于输出是如何创建的，参与 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a>。</p></li><li><p><code>&#39;version&#39;</code> - 期望有一个 <code>version=</code> 命名参数在 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 调用中，并打印版本信息并在调用后退出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> argparse</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--version'</span>, action=<span class="string">'version'</span>, version=<span class="string">'%(prog)s 2.0'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--version'</span>])</span><br><span class="line">PROG <span class="number">2.0</span></span><br></pre></td></tr></table></figure></li><li><p><code>&#39;extend&#39;</code> - This stores a list, and extends each argument value to the list. Example usage: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">"--foo"</span>, action=<span class="string">"extend"</span>, nargs=<span class="string">"+"</span>, type=str)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">"--foo"</span>, <span class="string">"f1"</span>, <span class="string">"--foo"</span>, <span class="string">"f2"</span>, <span class="string">"f3"</span>, <span class="string">"f4"</span>])</span><br><span class="line">Namespace(foo=[<span class="string">'f1'</span>, <span class="string">'f2'</span>, <span class="string">'f3'</span>, <span class="string">'f4'</span>])</span><br></pre></td></tr></table></figure></li></ul><p><strong>3.8 新版功能.</strong> </p><p>您还可以通过传递 Action 子类或实现相同接口的其他对象来指定任意操作。建议的方法是扩展 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.Action" target="_blank" rel="noopener"><code>Action</code></a>，覆盖 <code>__call__</code> 方法和可选的 <code>__init__</code> 方法。</p><p>一个自定义动作的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">FooAction</span><span class="params">(argparse.Action)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, option_strings, dest, nargs=None, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> nargs <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> ValueError(<span class="string">"nargs not allowed"</span>)</span><br><span class="line"><span class="meta">... </span>        super(FooAction, self).__init__(option_strings, dest, **kwargs)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, parser, namespace, values, option_string=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'%r %r %r'</span> % (namespace, values, option_string))</span><br><span class="line"><span class="meta">... </span>        setattr(namespace, self.dest, values)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, action=FooAction)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, action=FooAction)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = parser.parse_args(<span class="string">'1 --foo 2'</span>.split())</span><br><span class="line">Namespace(bar=<span class="literal">None</span>, foo=<span class="literal">None</span>) <span class="string">'1'</span> <span class="literal">None</span></span><br><span class="line">Namespace(bar=<span class="string">'1'</span>, foo=<span class="literal">None</span>) <span class="string">'2'</span> <span class="string">'--foo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args</span><br><span class="line">Namespace(bar=<span class="string">'1'</span>, foo=<span class="string">'2'</span>)</span><br></pre></td></tr></table></figure><h3 id="nargs"><a href="#nargs" class="headerlink" title="nargs"></a>nargs</h3><p>ArgumentParser 对象通常关联一个单独的命令行参数到一个单独的被执行的动作。 <code>nargs</code> 命名参数关联不同数目的命令行参数到单一动作。支持的值有：</p><ul><li><p><code>N</code> （一个整数）。命令行中的 <code>N</code> 个参数会被聚集到一个列表中。 例如:</p><p>>&gt;&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;, nargs=2)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;bar&apos;, nargs=1)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args(&apos;c --foo a b&apos;.split())</span><br><span class="line">Namespace(bar=[&apos;c&apos;], foo=[&apos;a&apos;, &apos;b&apos;])</span><br></pre></td></tr></table></figure><p>注意 <code>nargs=1</code> 会产生一个单元素列表。这和默认的元素本身是不同的。</p></li><li><p><code>&#39;?&#39;</code>。如果可能的话，会从命令行中消耗一个参数，并产生一个单一项。如果当前没有命令行参数，则会产生 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#default" target="_blank" rel="noopener">default</a> 值。注意，对于选项，有另外的用例 - 选项字符串出现但没有跟随命令行参数，则会产生 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#const" target="_blank" rel="noopener">const</a> 值。一些说用用例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="string">'?'</span>, const=<span class="string">'c'</span>, default=<span class="string">'d'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, nargs=<span class="string">'?'</span>, default=<span class="string">'d'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'XX'</span>, <span class="string">'--foo'</span>, <span class="string">'YY'</span>])</span><br><span class="line">Namespace(bar=<span class="string">'XX'</span>, foo=<span class="string">'YY'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'XX'</span>, <span class="string">'--foo'</span>])</span><br><span class="line">Namespace(bar=<span class="string">'XX'</span>, foo=<span class="string">'c'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">Namespace(bar=<span class="string">'d'</span>, foo=<span class="string">'d'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>nargs=&#39;?&#39;</code> 的一个更普遍用法是允许可选的输入或输出文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'infile'</span>, nargs=<span class="string">'?'</span>, type=argparse.FileType(<span class="string">'r'</span>),</span><br><span class="line"><span class="meta">... </span>                    default=sys.stdin)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'outfile'</span>, nargs=<span class="string">'?'</span>, type=argparse.FileType(<span class="string">'w'</span>),</span><br><span class="line"><span class="meta">... </span>                    default=sys.stdout)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'input.txt'</span>, <span class="string">'output.txt'</span>])</span><br><span class="line">Namespace(infile=&lt;_io.TextIOWrapper name=<span class="string">'input.txt'</span> encoding=<span class="string">'UTF-8'</span>&gt;,</span><br><span class="line">          outfile=&lt;_io.TextIOWrapper name=<span class="string">'output.txt'</span> encoding=<span class="string">'UTF-8'</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">Namespace(infile=&lt;_io.TextIOWrapper name=<span class="string">'&lt;stdin&gt;'</span> encoding=<span class="string">'UTF-8'</span>&gt;,</span><br><span class="line">          outfile=&lt;_io.TextIOWrapper name=<span class="string">'&lt;stdout&gt;'</span> encoding=<span class="string">'UTF-8'</span>&gt;)</span><br></pre></td></tr></table></figure></li><li><p><code>&#39;*&#39;</code>。所有当前命令行参数被聚集到一个列表中。注意通过 <code>nargs=&#39;*&#39;</code> 来实现多个位置参数通常没有意义，但是多个选项是可能的。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="string">'*'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--bar'</span>, nargs=<span class="string">'*'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'baz'</span>, nargs=<span class="string">'*'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'a b --foo x y --bar 1 2'</span>.split())</span><br><span class="line">Namespace(bar=[<span class="string">'1'</span>, <span class="string">'2'</span>], baz=[<span class="string">'a'</span>, <span class="string">'b'</span>], foo=[<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br></pre></td></tr></table></figure></li><li><p><code>&#39;+&#39;</code>。和 <code>&#39;*&#39;</code> 类似，所有当前命令行参数被聚集到一个列表中。另外，当前没有至少一个命令行参数时会产生一个错误信息。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, nargs=<span class="string">'+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">Namespace(foo=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">usage: PROG [-h] foo [foo ...]</span><br><span class="line">PROG: error: the following arguments are required: foo</span><br></pre></td></tr></table></figure></li><li><p><code>argarse.REMAINDER</code>。所有剩余的命令行参数被聚集到一个列表中。这通常在从一个命令行功能传递参数到另一个命令行功能中时有用:</p><p>>&gt;&gt;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'command'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'args'</span>, nargs=argparse.REMAINDER)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(parser.parse_args(<span class="string">'--foo B cmd --arg1 XX ZZ'</span>.split()))</span><br><span class="line">Namespace(args=[<span class="string">'--arg1'</span>, <span class="string">'XX'</span>, <span class="string">'ZZ'</span>], command=<span class="string">'cmd'</span>, foo=<span class="string">'B'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>如果不提供 <code>nargs</code> 命名参数，则消耗参数的数目将被 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#action" target="_blank" rel="noopener">action</a> 决定。通常这意味着单一项目（非列表）消耗单一命令行参数。 </p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 的const 参数用于保存不从命令行中读取但被各种 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 动作需求的常数值。最常用的两例为：</p><ul><li>当 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 通过 <code>action=&#39;store_const&#39;</code> 或 <code>action=&#39;append_const</code> 调用时。这些动作将 <code>const</code> 值添加到 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.parse_args" target="_blank" rel="noopener"><code>parse_args()</code></a> 返回的对象的属性中。在 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#action" target="_blank" rel="noopener">action</a> 的描述中查看案例。</li><li>当 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 通过选项（例如 <code>-f</code> 或 <code>--foo</code>）调用并且 <code>nargs=&#39;?&#39;</code> 时。这会创建一个可以跟随零个或一个命令行参数的选项。当解析命令行时，如果选项后没有参数，则将用 <code>const</code> 代替。在 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#nargs" target="_blank" rel="noopener">nargs</a> 描述中查看案例。</li></ul><p>对 <code>&#39;store_const&#39;</code> 和 <code>&#39;append_const&#39;</code> 动作， <code>const</code> 命名参数必须给出。对其他动作，默认为 <code>None</code>。</p><h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>所有选项和一些位置参数可能在命令行中被忽略。<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 的命名参数 <code>default</code>，默认值为 <code>None</code>，指定了在命令行参数未出现时应当使用的值。对于选项， <code>default</code> 值在选项未在命令行中出现时使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, default=<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'2'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'2'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">Namespace(foo=<span class="number">42</span>)</span><br></pre></td></tr></table></figure><p>如果 <code>default</code> 值是一个字符串，解析器解析此值就像一个命令行参数。特别是，在将属性设置在 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.Namespace" target="_blank" rel="noopener"><code>Namespace</code></a> 的返回值之前，解析器应用任何提供的 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#type" target="_blank" rel="noopener">type</a> 转换参数。否则解析器使用原值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--length'</span>, default=<span class="string">'10'</span>, type=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--width'</span>, default=<span class="number">10.5</span>, type=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args()</span><br><span class="line">Namespace(length=<span class="number">10</span>, width=<span class="number">10.5</span>)</span><br></pre></td></tr></table></figure><p>对于 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#nargs" target="_blank" rel="noopener">nargs</a> 等于 <code>?</code> 或 <code>*</code> 的位置参数， <code>default</code> 值在没有命令行参数出现时使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, nargs=<span class="string">'?'</span>, default=<span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'a'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'a'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">Namespace(foo=<span class="number">42</span>)</span><br></pre></td></tr></table></figure><p>提供 <code>default=argparse.SUPPRESS</code> 导致命令行参数未出现时没有属性被添加:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'--foo'</span>, default=argparse.SUPPRESS)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([])</span><br><span class="line">Namespace()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'1'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'1'</span>)</span><br></pre></td></tr></table></figure><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>默认情况下，<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser" target="_blank" rel="noopener"><code>ArgumentParser</code></a> 对象将命令行参数当作简单字符串读入。然而，命令行字符串经常需要被当作其它的类型，比如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 或者 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 的 <code>type</code> 关键词参数允许任何的类型检查和类型转换。一般的内建类型和函数可以直接被 <code>type</code> 参数使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, type=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, type=open)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args(<span class="string">'2 temp.txt'</span>.split())</span><br><span class="line">Namespace(bar=&lt;_io.TextIOWrapper name=<span class="string">'temp.txt'</span> encoding=<span class="string">'UTF-8'</span>&gt;, foo=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>当 <code>type</code> 参数被应用到默认参数时，请参考 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#default" target="_blank" rel="noopener">default</a> 参数的部分。</p><p>type 也可以指定写入文件,通过指定 <code>mode=</code>, <code>bufsize=</code>, <code>encoding=</code> and <code>errors=</code> 等参数调用<code>open</code>方法打开文件。举个栗子,设定<code>FileType(&#39;w&#39;)</code> 参数可以设定创建一个可写的文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'bar'</span>, type=argparse.FileType(<span class="string">'w'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'out.txt'</span>])</span><br><span class="line">Namespace(bar=&lt;_io.TextIOWrapper name=<span class="string">'out.txt'</span> encoding=<span class="string">'UTF-8'</span>&gt;)</span><br></pre></td></tr></table></figure><p><code>type=</code> can take any callable that takes a single string argument and returns the converted value:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">perfect_square</span><span class="params">(string)</span>:</span></span><br><span class="line"><span class="meta">... </span>    value = int(string)</span><br><span class="line"><span class="meta">... </span>    sqrt = math.sqrt(value)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> sqrt != int(sqrt):</span><br><span class="line"><span class="meta">... </span>        msg = <span class="string">"%r is not a perfect square"</span> % string</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">raise</span> argparse.ArgumentTypeError(msg)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> value</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, type=perfect_square)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'9'</span>])</span><br><span class="line">Namespace(foo=<span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'7'</span>])</span><br><span class="line">usage: PROG [-h] foo</span><br><span class="line">PROG: error: argument foo: <span class="string">'7'</span> <span class="keyword">is</span> <span class="keyword">not</span> a perfect square</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#choices" target="_blank" rel="noopener">choices</a> 关键词参数可能会使类型检查者更方便的检查一个范围的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'PROG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'foo'</span>, type=int, choices=range(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'7'</span>])</span><br><span class="line">Namespace(foo=<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'11'</span>])</span><br><span class="line">usage: PROG [-h] &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">PROG: error: argument foo: invalid choice: <span class="number">11</span> (choose <span class="keyword">from</span> <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure><h3 id="choices"><a href="#choices" class="headerlink" title="choices"></a>choices</h3><p>一些命令行参数从一组受限制的值中获取。这些可以通过容器对象,借助<code>choice</code>关键字参数传递给 <a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a> 来处理，分析命令行时，将检查参数值，如果参数不是可接受的值之一，将显示错误消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=&apos;game.py&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;move&apos;, choices=[&apos;rock&apos;, &apos;paper&apos;, &apos;scissors&apos;])</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&apos;rock&apos;])</span><br><span class="line">Namespace(move=&apos;rock&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&apos;fire&apos;])</span><br><span class="line">usage: game.py [-h] &#123;rock,paper,scissors&#125;</span><br><span class="line">game.py: error: argument move: invalid choice: &apos;fire&apos; (choose from &apos;rock&apos;,</span><br><span class="line">&apos;paper&apos;, &apos;scissors&apos;)</span><br></pre></td></tr></table></figure><p>需要注意的是 类型转换执行后执行检查, <code>choice</code>容器必须匹配这些类型声明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = argparse.ArgumentParser(prog=<span class="string">'doors.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.add_argument(<span class="string">'door'</span>, type=int, choices=range(<span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(parser.parse_args([<span class="string">'3'</span>]))</span><br><span class="line">Namespace(door=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'4'</span>])</span><br><span class="line">usage: doors.py [-h] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">doors.py: error: argument door: invalid choice: <span class="number">4</span> (choose <span class="keyword">from</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>任何容器可以通过 <code>choice</code>值来传递参数,例如 list 和 set 对象,亦或者是支持的自定义容器。</p><h3 id="required"><a href="#required" class="headerlink" title="required"></a>required</h3><p>通常情况下,可以通过 <code>-f</code> and <code>--bar</code>参数声明可选参数,这些参数可以在命令行执行的时候被忽略。如果想把这些单数设置成必须参数，则需要在<a href="https://docs.python.org/zh-cn/3.8/library/argparse.html#argparse.ArgumentParser.add_argument" target="_blank" rel="noopener"><code>add_argument()</code></a>参数中将 require参数设置成True</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(&apos;--foo&apos;, required=True)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([&apos;--foo&apos;, &apos;BAR&apos;])</span><br><span class="line">Namespace(foo=&apos;BAR&apos;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([])</span><br><span class="line">usage: argparse.py [-h] [--foo FOO]</span><br><span class="line">argparse.py: error: option --foo is required</span><br></pre></td></tr></table></figure><p>就像上述例子显示的情况一样。如果一个功能被标识为必须的，在命令行执行的时候,会不断报错。</p><blockquote><p>必须参数被认为不是一个好习惯。用户期望功能都是可选的,避免成为必须参数</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-argparse-命令行选项&quot;&gt;&lt;a href=&quot;#python-标准库-argparse-命令行选项&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 argparse 命令行选项&quot;&gt;&lt;/a&gt;python 标准库 argparse 命令行选项&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200308_Altered_Carbon2.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="argparse" scheme="https://pinghailinfeng.gitee.io/tags/argparse/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library sched</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/07/python-standard-library-sched/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/07/python-standard-library-sched/</id>
    <published>2020-03-07T14:48:57.000Z</published>
    <updated>2020-03-12T13:31:50.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-sched-同步队列类"><a href="#python-标准库-sched-同步队列类" class="headerlink" title="python 标准库 sched 同步队列类"></a>python 标准库 sched 同步队列类</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200307_westworld2.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>什么是人工智能？难道我们其实就生活在一个被定制了的剧场中？</p><p>HBO 剧集 &lt;西部世界&gt; 第二季 强势回归,也许你可以找到答案。</p></blockquote><p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/sched.py" target="_blank" rel="noopener">Lib/sched.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/sched.html#module-sched" target="_blank" rel="noopener"><code>sched</code></a> 模块定义了一个实现通用事件调度程序的类：</p><ul><li><p><em>class</em> <code>sched.scheduler</code>(<em>timefunc=time.monotonic</em>, <em>delayfunc=time.sleep</em>)</p><p><a href="https://docs.python.org/zh-cn/3.8/library/sched.html#sched.scheduler" target="_blank" rel="noopener"><code>scheduler</code></a> 类定义了一个调度事件的通用接口。 它需要两个函数来实际处理“外部世界” —— <em>timefunc</em> 应当不带参数地调用，并返回一个数字（“时间”，可以为任意单位）。 <em>delayfunc</em> 函数应当带一个参数调用，与 <em>timefunc</em> 的输出相兼容，并且应当延迟其所指定的时间单位。 每个事件运行后还将调用 <em>delayfunc</em> 并传入参数 <code>0</code> 以允许其他线程有机会在多线程应用中运行。<em>在 3.3 版更改:</em> <em>timefunc</em> 和 <em>delayfunc</em> 参数是可选的。<em>在 3.3 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/sched.html#sched.scheduler" target="_blank" rel="noopener"><code>scheduler</code></a> 类可以安全的在多线程环境中使用。</p></li></ul><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sched, time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = sched.scheduler(time.time, time.sleep)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_time</span><span class="params">(a=<span class="string">'default'</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"From print_time"</span>, time.time(), a)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_some_times</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(time.time())</span><br><span class="line"><span class="meta">... </span>    s.enter(<span class="number">10</span>, <span class="number">1</span>, print_time)</span><br><span class="line"><span class="meta">... </span>    s.enter(<span class="number">5</span>, <span class="number">2</span>, print_time, argument=(<span class="string">'positional'</span>,))</span><br><span class="line"><span class="meta">... </span>    s.enter(<span class="number">5</span>, <span class="number">1</span>, print_time, kwargs=&#123;<span class="string">'a'</span>: <span class="string">'keyword'</span>&#125;)</span><br><span class="line"><span class="meta">... </span>    s.run()</span><br><span class="line"><span class="meta">... </span>    print(time.time())</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_some_times()</span><br><span class="line"><span class="number">930343690.257</span></span><br><span class="line">From print_time <span class="number">930343695.274</span> positional</span><br><span class="line">From print_time <span class="number">930343695.275</span> keyword</span><br><span class="line">From print_time <span class="number">930343700.273</span> default</span><br><span class="line"><span class="number">930343700.276</span></span><br></pre></td></tr></table></figure><h2 id="调度器对象"><a href="#调度器对象" class="headerlink" title="调度器对象"></a>调度器对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/sched.html#sched.scheduler" target="_blank" rel="noopener"><code>scheduler</code></a> 实例拥有以下方法和属性：</p><ul><li><p><code>scheduler.enterabs</code>(<em>time</em>, <em>priority</em>, <em>action</em>, <em>argument=()</em>, <em>kwargs={}</em>)</p><p>安排一个新事件。 <em>time</em> 参数应该有一个数字类型兼容的返回值，与传递给构造函数的 <em>timefunc</em> 函数的返回值兼容。 计划在相同 <em>time</em> 的事件将按其 <em>priority</em> 的顺序执行。 数字越小表示优先级越高。执行事件意为执行 <code>action(*argument, **kwargs)</code>。 <em>argument</em> 是包含有 <em>action</em> 的位置参数的序列。 <em>kwargs</em> 是包含 <em>action</em> 的关键字参数的字典。返回值是一个事件，可用于以后取消事件（ 参见 <a href="https://docs.python.org/zh-cn/3.8/library/sched.html#sched.scheduler.cancel" target="_blank" rel="noopener"><code>cancel()</code></a> ）。<em>在 3.3 版更改:</em> <em>argument</em> 参数是可选的。<em>在 3.3 版更改:</em> 添加了 <em>kwargs</em> 形参。</p></li><li><p><code>scheduler.enter</code>(<em>delay</em>, <em>priority</em>, <em>action</em>, <em>argument=()</em>, <em>kwargs={}</em>)</p><p>安排延后 <em>delay</em> 时间单位的事件。 除了相对时间，其他参数、效果和返回值与 <a href="https://docs.python.org/zh-cn/3.8/library/sched.html#sched.scheduler.enterabs" target="_blank" rel="noopener"><code>enterabs()</code></a> 的相同。<em>在 3.3 版更改:</em> <em>argument</em> 参数是可选的。<em>在 3.3 版更改:</em> 添加了 <em>kwargs</em> 形参。</p></li><li><p><code>scheduler.cancel</code>(<em>event</em>)</p><p>从队列中删除事件。 如果 <em>event</em> 不是当前队列中的事件，则此方法将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。</p></li><li><p><code>scheduler.empty</code>()</p><p>如果事件队列为空则返回 <code>True</code>。</p></li><li><p><code>scheduler.run</code>(<em>blocking=True</em>)</p><p>运行所有预定事件。 此方法将等待（使用传递给构造函数的 <code>delayfunc()</code> 函数）进行下一个事件，然后执行它，依此类推，直到没有更多的计划事件。如果 <em>blocking</em> 为false，则执行由于最快到期（如果有）的预定事件，然后在调度程序中返回下一个预定调用的截止时间（如果有）。<em>action</em> 或 <em>delayfunc</em> 都可以引发异常。 在任何一种情况下，调度程序都将保持一致状态并传播异常。 如果 <em>action</em> 引发异常，则在将来调用 <a href="https://docs.python.org/zh-cn/3.8/library/sched.html#sched.scheduler.run" target="_blank" rel="noopener"><code>run()</code></a> 时不会尝试该事件。如果一系列事件的运行时间比下一个事件之前的可用时间长，那么调度程序将完全落后。 不会发生任何事件；调用代码负责取消不再相关的事件。<em>在 3.3 版更改:</em> 添加了 <em>blocking</em> 形参。</p></li><li><p><code>scheduler.queue</code></p><p>只读属性按照将要运行的顺序返回即将发生的事件列表。 每个事件都显示为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-named-tuple" target="_blank" rel="noopener">named tuple</a> ，包含以下字段：time、priority、action、argument、kwargs。</p></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>基本用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sched_basic.py</span></span><br><span class="line"><span class="keyword">import</span> sched</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">scheduler = sched.scheduler(time.time, time.sleep)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_event</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'EVENT:'</span>, time.time(), name)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'START:'</span>, time.time())</span><br><span class="line">scheduler.enter(<span class="number">2</span>, <span class="number">1</span>, print_event, (<span class="string">'first'</span>,))</span><br><span class="line">scheduler.enter(<span class="number">3</span>, <span class="number">1</span>, print_event, (<span class="string">'second'</span>,))</span><br><span class="line"></span><br><span class="line">scheduler.run()</span><br></pre></td></tr></table></figure><p>overloop</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sched</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">scheduler = sched.scheduler(time.time, time.sleep)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_event</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'BEGIN EVENT :'</span>, time.time(), name)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'FINISH EVENT:'</span>, time.time(), name)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'START:'</span>, time.time())</span><br><span class="line">scheduler.enter(<span class="number">2</span>, <span class="number">1</span>, long_event, (<span class="string">'first'</span>,))</span><br><span class="line">scheduler.enter(<span class="number">3</span>, <span class="number">1</span>, long_event, (<span class="string">'second'</span>,))</span><br><span class="line"></span><br><span class="line">scheduler.run()</span><br></pre></td></tr></table></figure><p>cancel_event</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sched</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">scheduler = sched.scheduler(time.time, time.sleep)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up a global to be modified by the threads</span></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_counter</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    print(<span class="string">'EVENT:'</span>, time.time(), name)</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'NOW:'</span>, counter)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'START:'</span>, time.time())</span><br><span class="line">e1 = scheduler.enter(<span class="number">2</span>, <span class="number">1</span>, increment_counter, (<span class="string">'E1'</span>,))</span><br><span class="line">e2 = scheduler.enter(<span class="number">3</span>, <span class="number">1</span>, increment_counter, (<span class="string">'E2'</span>,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Start a thread to run the events</span></span><br><span class="line">t = threading.Thread(target=scheduler.run)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Back in the main thread, cancel the first scheduled event.</span></span><br><span class="line">scheduler.cancel(e1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for the scheduler to finish running in the thread</span></span><br><span class="line">t.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'FINAL:'</span>, counter)</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://pymotw.com/3/sched/" target="_blank" rel="noopener">python标准库</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-sched-同步队列类&quot;&gt;&lt;a href=&quot;#python-标准库-sched-同步队列类&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 sched 同步队列类&quot;&gt;&lt;/a&gt;python 标准库 sched 同步队列类&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200307_westworld2.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="sched" scheme="https://pinghailinfeng.gitee.io/tags/sched/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library futures</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/06/python-standard-library-futures/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/06/python-standard-library-futures/</id>
    <published>2020-03-06T14:30:36.000Z</published>
    <updated>2020-03-12T13:31:50.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-Futures"><a href="#python-标准库-Futures" class="headerlink" title="python 标准库 Futures"></a>python 标准库 Futures</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200306_picard.webp?raw=true" alt></p><a id="more"></a><blockquote><p>I could either watch it pappen,or be part of it！</p><p>孤独是困苦的；但可不要变得庸俗；因为这样，你就会发现到处都是一片沙漠。 </p><p>​                                                                              —叔本华 《要么庸俗，要么孤独》</p></blockquote><p>这是模块<code>asyncio</code>的一部分。</p><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/asyncio/futures.py" target="_blank" rel="noopener">Lib/asyncio/futures.py</a>, <a href="https://github.com/python/cpython/tree/3.8/Lib/asyncio/base_futures.py" target="_blank" rel="noopener">Lib/asyncio/base_futures.py</a></p><hr><p><em>Future</em> 对象用来链接 <strong>底层回调式代码</strong> 和高层异步/等待式代码。</p><h2 id="Future-函数"><a href="#Future-函数" class="headerlink" title="Future 函数"></a>Future 函数</h2><ul><li><p><code>asyncio.isfuture</code>(<em>obj</em>)</p><p>如果 <em>obj</em> 为下面任意对象，返回 <code>True</code>：一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>asyncio.Future</code></a> 类的实例，一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>asyncio.Task</code></a> 类的实例，带有 <code>_asyncio_future_blocking</code> 属性的类似 Future 的对象。<em>3.5 新版功能.</em></p></li><li><p><code>asyncio.ensure_future</code>(<em>obj</em>, <em>**, </em>loop=None*)</p><p>返回：<em>obj</em> 参数会是保持原样，如果 <em>obj</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 或 类似 Future 的对象( <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.isfuture" target="_blank" rel="noopener"><code>isfuture()</code></a> 用于测试。)封装了 <em>obj</em> 的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 对象，如果 <em>obj</em> 是一个协程 (使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.iscoroutine" target="_blank" rel="noopener"><code>iscoroutine()</code></a> 进行检测)；在此情况下该协程将通过 <code>ensure_future()</code> 加入执行计划。等待 <em>obj</em> 的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 对象，如果 <em>obj</em> 是一个可等待对象( <a href="https://docs.python.org/zh-cn/3.8/library/inspect.html#inspect.isawaitable" target="_blank" rel="noopener"><code>inspect.isawaitable()</code></a> 用于测试)如果 <em>obj</em> 不是上述对象会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 异常。重要 查看 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>create_task()</code></a> 函数，它是创建新任务的首选途径。<em>在 3.5.1 版更改:</em> 这个函数接受任意 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a> 对象。</p></li><li><p><code>asyncio.wrap_future</code>(<em>future</em>, <em>**, </em>loop=None*)</p><p>将一个 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>concurrent.futures.Future</code></a> 对象封装到 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>asyncio.Future</code></a> 对象中。</p></li></ul><h2 id="Future-对象"><a href="#Future-对象" class="headerlink" title="Future 对象"></a>Future 对象</h2><ul><li><p><em>class</em> <code>asyncio.Future</code>(<em>**, </em>loop=None*)</p><p>一个 Future 代表一个异步运算的最终结果。线程不安全。</p><p>Future 是一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a> 对象。协程可以等待 Future 对象直到它们有结果或异常集合或被取消。</p><p>通常 Future 用于支持底层回调式代码(例如在协议实现中使用asyncio <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-protocol.html#asyncio-transports-protocols" target="_blank" rel="noopener">transports</a>) 与高层异步/等待式代码交互。</p><p>经验告诉我们永远不要面向用户的接口暴露 Future 对象，同时建议使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.loop.create_future" target="_blank" rel="noopener"><code>loop.create_future()</code></a> 来创建 Future 对象。这种方法可以让 Future 对象使用其它的事件循环实现，它可以注入自己的优化实现。</p><p><em>在 3.7 版更改:</em> 加入对 <a href="https://docs.python.org/zh-cn/3.8/library/contextvars.html#module-contextvars" target="_blank" rel="noopener"><code>contextvars</code></a> 模块的支持。</p><ul><li><p><code>result</code>()</p><p>返回 Future 的结果。如果 Future 状态为 <em>完成</em> ，并由 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_result" target="_blank" rel="noopener"><code>set_result()</code></a> 方法设置一个结果，则返回这个结果。如果 Future 状态为 <em>完成</em> ，并由 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_exception" target="_blank" rel="noopener"><code>set_exception()</code></a> 方法设置一个异常，那么这个方法会引发异常。如果 Future 已 <em>取消</em>，方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。如果 Future 的结果还不可用，此方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 异常。</p></li><li><p><code>set_result</code>(<em>result</em>)</p><p>将 Future 标记为 <em>完成</em> 并设置结果。如果 Future 已经 <em>完成</em> 则抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 错误。</p></li><li><p><code>set_exception</code>(<em>exception</em>)</p><p>将 Future 标记为 <em>完成</em> 并设置一个异常。如果 Future 已经 <em>完成</em> 则抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 错误。</p></li><li><p><code>done</code>()</p><p>如果 Future 为已 <em>完成</em> 则返回 <code>True</code> 。如果 Future 为 <em>取消</em> 或调用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_result" target="_blank" rel="noopener"><code>set_result()</code></a> 设置了结果或调用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_exception" target="_blank" rel="noopener"><code>set_exception()</code></a> 设置了异常，那么它就是 <em>完成</em> 。</p></li><li><p><code>cancelled</code>()</p><p>如果 Future 已 <em>取消</em> 则返回 <code>True</code>这个方法通常在设置结果或异常前用来检查 Future 是否已 <em>取消</em> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> fut.cancelled():</span><br><span class="line">    fut.set_result(<span class="number">42</span>)</span><br></pre></td></tr></table></figure><ul><li><p><code>add_done_callback</code>(<em>callback</em>, <em>**, </em>context=None*)</p><p>添加一个在 Future <em>完成</em> 时运行的回调函数。</p><p> 调用 <em>callback</em> 时，Future 对象是它的唯一参数。</p><p> 调用这个方法时 Future 已经 <em>完成</em> , 回调函数已被 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.loop.call_soon" target="_blank" rel="noopener"><code>loop.call_soon()</code></a> 调度。</p><p> 可选键值类的参数 <em>context</em> 允许 <em>callback</em> 运行在一个指定的自定义 <a href="https://docs.python.org/zh-cn/3.8/library/contextvars.html#contextvars.Context" target="_blank" rel="noopener"><code>contextvars.Context</code></a> 对象中。如果没有提供 <em>context</em> ，则使用当前上下文。</p><p> 可以用 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>functools.partial()</code></a> 给回调函数传递参数，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Call 'print("Future:", fut)' when "fut" is done.</span></span><br><span class="line">fut.add_done_callback(</span><br><span class="line">    functools.partial(<span class="keyword">print</span>, <span class="string">"Future:"</span>))</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><pre><code>*在 3.7 版更改:* 加入键值类形参 *context*。请参阅 [**PEP 567**](https://www.python.org/dev/peps/pep-0567) 查看更多细节。 </code></pre><ul><li><p><code>remove_done_callback</code>(<em>callback</em>)</p><p>从回调列表中移除 <em>callback</em> 。返回被移除的回调函数的数量，通常为1，除非一个回调函数被添加多次。</p></li><li><p><code>cancel</code>()</p><p>取消 Future 并调度回调函数。如果 Future 已经 <em>完成</em> 或 <em>取消</em> ，返回 <code>False</code> 。否则将 Future 状态改为 <em>取消</em> 并在调度回调函数后返回 <code>True</code> 。</p></li><li><p><code>exception</code>()</p><p>返回 Future 已设置的异常。只有 Future 在 <em>完成</em> 时才返回异常（或者 <code>None</code> ，如果没有设置异常）。如果 Future 已 <em>取消</em>，方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。如果 Future 还没 <em>完成</em> ，这个方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 异常。</p></li><li><p><code>get_loop</code>()</p><p>返回 Future 对象已绑定的事件循环。<em>3.7 新版功能.</em></p><p> 这个例子创建一个 Future 对象，创建和调度一个异步任务去设置 Future 结果，然后等待其结果: </p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">set_after</span><span class="params">(fut, delay, value)</span>:</span></span><br><span class="line">    <span class="comment"># Sleep for *delay* seconds.</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set *value* as a result of *fut* Future.</span></span><br><span class="line">    fut.set_result(value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Get the current event loop.</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create a new Future object.</span></span><br><span class="line">    fut = loop.create_future()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run "set_after()" coroutine in a parallel Task.</span></span><br><span class="line">    <span class="comment"># We are using the low-level "loop.create_task()" API here because</span></span><br><span class="line">    <span class="comment"># we already have a reference to the event loop at hand.</span></span><br><span class="line">    <span class="comment"># Otherwise we could have just used "asyncio.create_task()".</span></span><br><span class="line">    loop.create_task(</span><br><span class="line">        set_after(fut, <span class="number">1</span>, <span class="string">'... world'</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'hello ...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait until *fut* has a result (1 second) and print it.</span></span><br><span class="line">    print(<span class="keyword">await</span> fut)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>: </p><p>该 Future 对象是为了模仿 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>concurrent.futures.Future</code></a> 类。主要差异包含：</p><ul><li>与 asyncio 的 Future 不同，<a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>concurrent.futures.Future</code></a> 实例不是可等待对象。</li><li><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.result" target="_blank" rel="noopener"><code>asyncio.Future.result()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.exception" target="_blank" rel="noopener"><code>asyncio.Future.exception()</code></a> 不接受 <em>timeout</em> 参数。</li><li>Future 没有 <em>完成</em> 时 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.result" target="_blank" rel="noopener"><code>asyncio.Future.result()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.exception" target="_blank" rel="noopener"><code>asyncio.Future.exception()</code></a> 抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 异常。</li><li>使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.add_done_callback" target="_blank" rel="noopener"><code>asyncio.Future.add_done_callback()</code></a> 注册的回调函数不会立即调用，而是被 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.loop.call_soon" target="_blank" rel="noopener"><code>loop.call_soon()</code></a> 调度。</li><li>asyncio Future 不能兼容 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.wait" target="_blank" rel="noopener"><code>concurrent.futures.wait()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.as_completed" target="_blank" rel="noopener"><code>concurrent.futures.as_completed()</code></a> 函数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-Futures&quot;&gt;&lt;a href=&quot;#python-标准库-Futures&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 Futures&quot;&gt;&lt;/a&gt;python 标准库 Futures&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200306_picard.webp?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standar_library" scheme="https://pinghailinfeng.gitee.io/tags/standar-library/"/>
    
      <category term="futures" scheme="https://pinghailinfeng.gitee.io/tags/futures/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library code</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/05/python-standard-library-code/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/05/python-standard-library-code/</id>
    <published>2020-03-05T14:17:08.000Z</published>
    <updated>2020-03-06T13:28:00.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python标准库-code"><a href="#python标准库-code" class="headerlink" title="python标准库 code"></a>python标准库 code</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200305longmao.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>龙猫 となりのトトロ (1988)</p><p>这可能是宫崎骏众多作品中最温馨而淳朴的片子了。</p><p>小时候只记得范晓萱的那首《豆豆龙》。</p><p>30年后的很幸运我和孩子一起看了这部片子。</p><p>看完了,我热泪盈眶。无法用词语去形容那种纯净的感觉。</p><p>回家的路上我问孩子,你看懂了吗？她点了点头。</p><p>我也看懂了。</p></blockquote><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/code.py" target="_blank" rel="noopener">Lib/code.py</a></p><hr><p><code>code</code> 模块提供了在 Python 中实现 read-eval-print 循环的功能。它包含两个类和一些快捷功能，可用于构建提供交互式解释器的应用程序。</p><ul><li><p><em>class</em> <code>code.InteractiveInterpreter</code>(<em>locals=None</em>)</p><p>这个类处理解析器和解释器状态（用户命名空间的）；它不处理缓冲器、终端提示区或着输入文件名（文件名总是显示地传递）。可选的 <em>locals</em> 参数指定一个字典，字典里面包含将在此类执行的代码；它默认创建新的字典，其键 <code>&#39;__name__&#39;</code> 设置为 <code>&#39;__console__&#39;</code> ，键 <code>&#39;__doc__&#39;</code> 设置为 <code>None</code> 。</p></li><li><p><em>class</em> <code>code.InteractiveConsole</code>(<em>locals=None</em>, <em>filename=””</em>)</p><p>尽可能模拟交互式 Python 解释器的行为。此类建立在 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter" target="_blank" rel="noopener"><code>InteractiveInterpreter</code></a> 的基础上，使用熟悉的 <code>sys.ps1</code> 和 <code>sys.ps2</code> 作为输入提示符，并有输入缓冲。</p></li><li><p><code>code.interact</code>(<em>banner=None</em>, <em>readfunc=None</em>, <em>local=None</em>, <em>exitmsg=None</em>)</p><p>运行一个 read-eval-print 循环的便捷函数。这会创建一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveConsole" target="_blank" rel="noopener"><code>InteractiveConsole</code></a> 实例。如果提供了 <em>readfunc</em> ，会设置为 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveConsole.raw_input" target="_blank" rel="noopener"><code>InteractiveConsole.raw_input()</code></a> 方法。如果提供了 <em>local</em> ，则将其传递给 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveConsole" target="_blank" rel="noopener"><code>InteractiveConsole</code></a> 的构造函数，以用作解释器循环的默认命名空间。然后，如果提供了 <em>banner</em> 和 <em>exitmsg</em> ，实例的 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.interact" target="_blank" rel="noopener"><code>interact()</code></a> 方法会以此为标题和退出消息。控制台对象在使用后将被丢弃。<em>在 3.6 版更改:</em> 加入 <em>exitmsg</em> 参数。</p></li><li><p><code>code.compile_command</code>(<em>source</em>, <em>filename=””</em>, <em>symbol=”single”</em>)</p><p>这个函数主要用来模拟 Python 解释器的主循环（即 read-eval-print 循环）。难点的部分是当用户输入不完整命令时，判断能否通过之后的输入来完成（要么成为完整的命令，要么语法错误）。该函数 <em>几乎</em> 和实际的解释器主循环的判断是相同的。<em>source</em> 是源字符串； <em>filename</em> 是可选文件名，用来读取源文件，默认为 <code>&#39;&#39;</code> ； <em>symbol</em> 是可选的语法开始符号，应为 <code>&#39;single&#39;</code> （默认）或 <code>&#39;eval&#39;</code> 。如果命令完整且有效则返回一个代码对象 (等价于 <code>compile(source, filename, symbol)</code>)；如果命令不完整则返回 <code>None</code>；如果命令完整但包含语法错误则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a> 而如果命令包含无效字面值则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。</p></li></ul><h2 id="交互解释器对象"><a href="#交互解释器对象" class="headerlink" title="交互解释器对象"></a>交互解释器对象</h2><ul><li><p><code>InteractiveInterpreter.runsource</code>(<em>source</em>, <em>filename=””</em>, <em>symbol=”single”</em>)</p><p>在解释器中编译并运行一段源码。 所用参数与 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.compile_command" target="_blank" rel="noopener"><code>compile_command()</code></a> 一样；<em>filename</em> 的默认值为 <code>&#39;&#39;</code>，<em>symbol</em> 则为 <code>&#39;single&#39;</code>。 可能发生以下情况之一：</p><ul><li>输入不正确；<a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.compile_command" target="_blank" rel="noopener"><code>compile_command()</code></a> 引发了一个异常 (<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a>)。 将通过调用 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.showsyntaxerror" target="_blank" rel="noopener"><code>showsyntaxerror()</code></a> 方法打印语法回溯信息。 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.runsource" target="_blank" rel="noopener"><code>runsource()</code></a> 返回 <code>False</code>。</li><li>输入不完整，需要更多输入；函数 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.compile_command" target="_blank" rel="noopener"><code>compile_command()</code></a> 返回 <code>None</code> 。方法 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.runsource" target="_blank" rel="noopener"><code>runsource()</code></a> 返回 <code>True</code> 。</li><li>输入完整；<a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.compile_command" target="_blank" rel="noopener"><code>compile_command()</code></a> 返回了一个代码对象。 将通过调用 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.runcode" target="_blank" rel="noopener"><code>runcode()</code></a> 执行代码（该方法也会处理运行时异常，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a> 除外）。 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.runsource" target="_blank" rel="noopener"><code>runsource()</code></a> 返回 <code>False</code>。</li></ul><p>该返回值用于决定使用 <code>sys.ps1</code> 还是 <code>sys.ps2</code> 来作为下一行的输入提示符。</p></li><li><p><code>InteractiveInterpreter.runcode</code>(<em>code</em>)</p><p>执行一个代码对象。当发生异常时，调用 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.showtraceback" target="_blank" rel="noopener"><code>showtraceback()</code></a> 来显示回溯。除 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a> （允许传播）以外的所有异常都会被捕获。有关 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyboardInterrupt" target="_blank" rel="noopener"><code>KeyboardInterrupt</code></a> 的说明，该异常可能发生于此代码的其他位置，并且并不总能被捕获。 调用者应当准备好处理它。</p></li><li><p><code>InteractiveInterpreter.showsyntaxerror</code>(<em>filename=None</em>)</p><p>显示刚发生的语法错误。 这不会显示堆栈回溯因为语法错误并无此种信息。 如果给出了 <em>filename</em>，它会被放入异常来替代 Python 解析器所提供的默认文件名，因为它在从一个字符串读取时总是会使用 <code>&#39;&#39;</code>。 输出将由 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.write" target="_blank" rel="noopener"><code>write()</code></a> 方法来写入。</p></li><li><p><code>InteractiveInterpreter.showtraceback</code>()</p><p>显示刚发生的异常。 我们移除了第一个堆栈条目因为它从属于解释器对象的实现。 输出将由 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter.write" target="_blank" rel="noopener"><code>write()</code></a> 方法来写入。<em>在 3.5 版更改:</em> 将显示完整的链式回溯，而不只是主回溯。</p></li><li><p><code>InteractiveInterpreter.write</code>(<em>data</em>)</p><p>将一个字符串写入到标准错误流 (<code>sys.stderr</code>)。 所有派生类都应重载此方法以提供必要的正确输出处理。</p></li></ul><h2 id="交互式控制台对象"><a href="#交互式控制台对象" class="headerlink" title="交互式控制台对象"></a>交互式控制台对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveConsole" target="_blank" rel="noopener"><code>InteractiveConsole</code></a> 类是 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveInterpreter" target="_blank" rel="noopener"><code>InteractiveInterpreter</code></a> 的子类，因此它提供了解释器对象的所有方法，还有以下的额外方法。</p><ul><li><p><code>InteractiveConsole.interact</code>(<em>banner=None</em>, <em>exitmsg=None</em>)</p><p>近似地模拟交互式 Python 终端。 可选的 <em>banner</em> 参数指定要在第一次交互前打印的条幅；默认情况下会类似于标准 Python 解释器所打印的内容，并附上外加圆括号的终端对象类名（这样就不会与真正的解释器混淆 —— 因为确实太像了！）</p><p>可选的 <em>exitmsg</em> 参数指定要在退出时打印的退出消息。 传入空字符串可以屏蔽退出消息。 如果 <em>exitmsg</em> 未给出或为 <code>None</code>，则将打印默认消息。</p><p><em>在 3.4 版更改:</em> 要禁止打印任何条幅消息，请传递一个空字符串。</p><p><em>在 3.6 版更改:</em> 退出时打印退出消息。</p></li><li><p><code>InteractiveConsole.push</code>(<em>line</em>)</p><p>将一行源文本推入解释器。 行内容不应带有末尾换行符；它可以有内部换行符。 行内容会被添加到一个缓冲区并且会调用解释器的 <code>runsource()</code> 方法，附带缓冲区内容的拼接结果作为源文本。 如果显示命令已执行或不合法，缓冲区将被重置；否则，则命令尚未结束，缓冲区将在添加行后保持原样。 如果要求更多输入则返回值为 <code>True</code>，如果行已按某种方式被处理则返回值为 <code>False</code> (这与 <code>runsource()</code> 相同)。</p></li><li><p><code>InteractiveConsole.resetbuffer</code>()</p><p>从输入缓冲区中删除所有未处理的内容。</p></li><li><p><code>InteractiveConsole.raw_input</code>(<em>prompt=””</em>)</p><p>输出提示并读取一行。返回的行不包含末尾的换行符。当用户输入 EOF 键序列时，会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EOFError" target="_blank" rel="noopener"><code>EOFError</code></a> 异常。默认实现是从 <code>sys.stdin</code> 读取；子类可以用其他实现代替。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python标准库-code&quot;&gt;&lt;a href=&quot;#python标准库-code&quot; class=&quot;headerlink&quot; title=&quot;python标准库 code&quot;&gt;&lt;/a&gt;python标准库 code&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200305longmao.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="code" scheme="https://pinghailinfeng.gitee.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library readline</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/04/python-standard-library-readline/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/04/python-standard-library-readline/</id>
    <published>2020-03-04T13:48:34.000Z</published>
    <updated>2020-03-04T13:54:50.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-readline"><a href="#python-标准库-readline" class="headerlink" title="python  标准库 readline"></a>python  标准库 readline</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200304_remember_beyond_the_futrue.jpg?raw=true" alt></p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=539420&auto=0&height=66"></iframe><p><a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 模块定义了许多方便从 Python 解释器完成和读取/写入历史文件的函数。 此模块可以直接使用，或通过支持在交互提示符下完成 Python 标识符的 <a href="https://docs.python.org/zh-cn/3.8/library/rlcompleter.html#module-rlcompleter" target="_blank" rel="noopener"><code>rlcompleter</code></a> 模块使用。 使用此模块进行的设置会同时影响解释器的交互提示符以及内置 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#input" target="_blank" rel="noopener"><code>input()</code></a> 函数提供的提示符。</p><p>Readline keybindings may be configured via an initialization file, typically <code>.inputrc</code> in your home directory. See <a href="https://tiswww.cwru.edu/php/chet/readline/rluserman.html#SEC9" target="_blank" rel="noopener">Readline Init File</a> in the GNU Readline manual for information about the format and allowable constructs of that file, and the capabilities of the Readline library in general.</p><blockquote><p>注解:底层的 Readline 库 API 可能使用 <code>libedit</code> 库来实现而不是 GNU readline。 在 macOS 上 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 模块会在运行时检测所使用的是哪个库。</p></blockquote><p><code>libedit</code> 所用的配置文件与 GNU readline 的不同。 如果你要在程序中载入配置字符串你可以在 <code>readline.__doc__</code> 中检测文本 “libedit” 来区分 GNU readline 和 libedit。</p><p>如果你是在 macOS 上使用 <em>editline</em>/<code>libedit</code> readline 模拟，则位于你的主目录中的初始化文件名称为 <code>.editrc</code>。 例如，<code>~/.editrc</code> 中的以下内容将开启 <em>vi</em> 按键绑定以及 TAB 补全:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python:bind -v</span><br><span class="line">python:bind ^I rl_complete</span><br></pre></td></tr></table></figure><h2 id="初始化文件"><a href="#初始化文件" class="headerlink" title="初始化文件"></a>初始化文件</h2><p>下列函数与初始化文件和用户配置有关：</p><ul><li><p><code>readline.parse_and_bind</code>(<em>string</em>)</p><p>执行在 <em>string</em> 参数中提供的初始化行。 此函数会调用底层库中的 <code>rl_parse_and_bind()</code>。</p></li><li><p><code>readline.read_init_file</code>([<em>filename</em>])</p><p>执行一个 readline 初始化文件。 默认文件名为最近所使用的文件名。 此函数会调用底层库中的 <code>rl_read_init_file()</code>。</p></li></ul><h2 id="行缓冲区"><a href="#行缓冲区" class="headerlink" title="行缓冲区"></a>行缓冲区</h2><p>下列函数会在行缓冲区上操作。</p><ul><li><p><code>readline.get_line_buffer</code>()</p><p>返回行缓冲区的当前内容 (底层库中的 <code>rl_line_buffer</code>)。</p></li><li><p><code>readline.insert_text</code>(<em>string</em>)</p><p>将文本插入行缓冲区的当前游标位置。 该函数会调用底层库中的 <code>rl_insert_text()</code>，但会忽略其返回值。</p></li><li><p><code>readline.redisplay</code>()</p><p>改变屏幕的显示以反映行缓冲区的当前内容。 该函数会调用底层库中的 <code>rl_redisplay()</code>。</p></li></ul><h2 id="历史文件"><a href="#历史文件" class="headerlink" title="历史文件"></a>历史文件</h2><p>下列函数会在历史文件上操作：</p><ul><li><p><code>readline.read_history_file</code>([<em>filename</em>])</p><p>载入一个 readline 历史文件，并将其添加到历史列表。 默认文件名为 <code>~/.history</code>。 此函数会调用底层库中的 <code>read_history()</code>。</p></li><li><p><code>readline.write_history_file</code>([<em>filename</em>])</p><p>将历史列表保存为 readline 历史文件，覆盖任何现有文件。 默认文件名为 <code>~/.history</code>。 此函数会调用底层库中的 <code>write_history()</code>。</p></li><li><p><code>readline.append_history_file</code>(<em>nelements</em>[, <em>filename</em>])</p><p>将历史列表的最后 <em>nelements</em> 项添加到历史文件。 默认文件名为 <code>~/.history</code>。 文件必须已存在。 此函数会调用底层库中的 <code>append_history()</code>。 此函数仅当 Python 编译包带有支持此功能的库版本时才会存在。<em>3.5 新版功能.</em></p></li><li><p><code>readline.get_history_length</code>()</p></li><li><p><code>readline.set_history_length</code>(<em>length</em>)</p><p>设置或返回需要保存到历史文件的行数。 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#readline.write_history_file" target="_blank" rel="noopener"><code>write_history_file()</code></a> 函数会通过调用底层库中的 <code>history_truncate_file()</code> 以使用该值来截取历史文件。 负值意味着不限制历史文件的大小。</p></li></ul><h2 id="历史列表"><a href="#历史列表" class="headerlink" title="历史列表"></a>历史列表</h2><p>以下函数会在全局历史列表上操作：</p><ul><li><p><code>readline.clear_history</code>()</p><p>清除当前历史。 此函数会调用底层库的 <code>clear_history()</code>。 此 Python 函数仅当 Python 编译包带有支持此功能的库版本时才会存在。</p></li><li><p><code>readline.get_current_history_length</code>()</p><p>返回历史列表的当前项数。 （此函数不同于 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#readline.get_history_length" target="_blank" rel="noopener"><code>get_history_length()</code></a>，后者是返回将被写入历史文件的最大行数。）</p></li><li><p><code>readline.get_history_item</code>(<em>index</em>)</p><p>返回序号为 <em>index</em> 的历史条目的当前内容。 条目序号从一开始。 此函数会调用底层库中的 <code>history_get()</code>。</p></li><li><p><code>readline.remove_history_item</code>(<em>pos</em>)</p><p>从历史列表中移除指定位置上的历史条目。 条目位置从零开始。 此函数会调用底层库中的 <code>remove_history()</code>。</p></li><li><p><code>readline.replace_history_item</code>(<em>pos</em>, <em>line</em>)</p><p>将指定位置上的历史条目替换为 <em>line</em>。 条目位置从零开始。 此函数会调用底层库中的 <code>replace_history_entry()</code>。</p></li><li><p><code>readline.add_history</code>(<em>line</em>)</p><p>将 <em>line</em> 添加到历史缓冲区，相当于是最近输入的一行。 此函数会调用底层库中的 <code>add_history()</code>。</p></li><li><p><code>readline.set_auto_history</code>(<em>enabled</em>)</p><p>启用或禁用当通过 readline 读取输入时自动调用 <code>add_history()</code>。 <em>enabled</em> 参数应为一个布尔值，当其为真值时启用自动历史，当其为假值时禁用自动历史。<em>3.6 新版功能.**</em>CPython implementation detail:** Auto history is enabled by default, and changes to this do not persist across multiple sessions.</p></li></ul><h2 id="启动钩子"><a href="#启动钩子" class="headerlink" title="启动钩子"></a>启动钩子</h2><ul><li><p><code>readline.set_startup_hook</code>([<em>function</em>])</p><p>设置或移除底层库的 <code>rl_startup_hook</code> 回调所发起调用的函数。 如果指定了 <em>function</em>，它将被用作新的钩子函数；如果省略或为 <code>None</code>，任何已安装的函数将被移除。 钩子函数将在 readline 打印第一个提示信息之前不带参数地被调用。</p></li><li><p><code>readline.set_pre_input_hook</code>([<em>function</em>])</p><p>设置或移除底层库的 <code>rl_pre_input_hook</code> 回调所发起调用的函数。 如果指定了 <em>function</em>，它将被用作新的钩子函数；如果省略或为 <code>None</code>，任何已安装的函数将被移除。 钩子函数将在打印第一个提示信息之后、readline 开始读取输入字符之前不带参数地被调用。 此函数仅当 Python 编译包带有支持此功能的库版本时才会存在。</p></li></ul><h2 id="Completion"><a href="#Completion" class="headerlink" title="Completion"></a>Completion</h2><p>以下函数与自定义单词补全函数的实现有关。 这通常使用 Tab 键进行操作，能够提示并自动补全正在输入的单词。 默认情况下，Readline 设置为由 <a href="https://docs.python.org/zh-cn/3.8/library/rlcompleter.html#module-rlcompleter" target="_blank" rel="noopener"><code>rlcompleter</code></a> 来补全交互模式解释器的 Python 标识符。 如果 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 模块要配合自定义的补全函数来使用，则需要设置不同的单词分隔符。</p><ul><li><p><code>readline.set_completer</code>([<em>function</em>])</p><p>设置或移除补全函数。 如果指定了 <em>function</em>，它将被用作新的补全函数；如果省略或为 <code>None</code>，任何已安装的补全函数将被移除。 补全函数的调用形式为 <code>function(text, state)</code>，其中 <em>state</em> 为 <code>0</code>, <code>1</code>, <code>2</code>, …, 直至其返回一个非字符串值。 它应当返回下一个以 <em>text</em> 开头的候选补全内容。已安装的补全函数将由传递给底层库中 <code>rl_completion_matches()</code> 的 <em>entry_func</em> 回调函数来发起调用。 <em>text</em> 字符串来自于底层库中 <code>rl_attempted_completion_function</code> 回调函数的第一个形参。</p></li><li><p><code>readline.get_completer</code>()</p><p>获取补全函数，如果没有设置补全函数则返回 <code>None</code>。</p></li><li><p><code>readline.get_completion_type</code>()</p><p>获取正在尝试的补全类型。 此函数会将底层库中的 <code>rl_completion_type</code> 变量作为一个整数返回。</p></li><li><p><code>readline.get_begidx</code>()</p></li><li><p><code>readline.get_endidx</code>()</p><p>获取补全域的开始和结束序号。 这些序号就是传给底层库中 <code>rl_attempted_completion_function</code> 回调函数的 <em>start</em> 和 <em>end</em> 参数。</p></li><li><p><code>readline.set_completer_delims</code>(<em>string</em>)</p></li><li><p><code>readline.get_completer_delims</code>()</p><p>设置或获取补全的单词分隔符。 此分隔符确定了要考虑补全的单词的开始和结束位置（补全域）。 这些函数会访问底层库的 <code>rl_completer_word_break_characters</code> 变量。</p></li><li><p><code>readline.set_completion_display_matches_hook</code>([<em>function</em>])</p><p>设置或移除补全显示函数。 如果指定了 <em>function</em>，它将被用作新的补全显示函数；如果省略或为 <code>None</code>，任何已安装的补全显示函数将被移除。 此函数会设置或清除底层库的 <code>rl_completion_display_matches_hook</code> 回调函数。 补全显示函数会在每次需要显示匹配项时以 <code>function(substitution, [matches], longest_match_length)</code> 的形式被调用。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下示例演示了如何使用 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 模块的历史读取或写入函数来自动加载和保存用户主目录下名为 <code>.python_history</code> 的历史文件。 以下代码通常应当在交互会话期间从用户的 <a href="https://docs.python.org/zh-cn/3.8/using/cmdline.html#envvar-PYTHONSTARTUP" target="_blank" rel="noopener"><code>PYTHONSTARTUP</code></a> 文件自动执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> atexit</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> readline</span><br><span class="line"></span><br><span class="line">histfile = os.path.join(os.path.expanduser(<span class="string">"~"</span>), <span class="string">".python_history"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    readline.read_history_file(histfile)</span><br><span class="line">    <span class="comment"># default history len is -1 (infinite), which may grow unruly</span></span><br><span class="line">    readline.set_history_length(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">atexit.register(readline.write_history_file, histfile)</span><br></pre></td></tr></table></figure><p>此代码实际上会在 Python 运行于 <a href="https://docs.python.org/zh-cn/3.8/tutorial/interpreter.html#tut-interactive" target="_blank" rel="noopener">交互模式</a> 时自动运行 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/site.html#rlcompleter-config" target="_blank" rel="noopener">Readline configuration</a>)。</p><p>以下示例实现了同样的目标，但是通过只添加新历史的方式来支持并发的交互会话。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> atexit</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> readline</span><br><span class="line">histfile = os.path.join(os.path.expanduser(<span class="string">"~"</span>), <span class="string">".python_history"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    readline.read_history_file(histfile)</span><br><span class="line">    h_len = readline.get_current_history_length()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    open(histfile, <span class="string">'wb'</span>).close()</span><br><span class="line">    h_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(prev_h_len, histfile)</span>:</span></span><br><span class="line">    new_h_len = readline.get_current_history_length()</span><br><span class="line">    readline.set_history_length(<span class="number">1000</span>)</span><br><span class="line">    readline.append_history_file(new_h_len - prev_h_len, histfile)</span><br><span class="line">atexit.register(save, h_len, histfile)</span><br></pre></td></tr></table></figure><p>以下示例扩展了 <a href="https://docs.python.org/zh-cn/3.8/library/code.html#code.InteractiveConsole" target="_blank" rel="noopener"><code>code.InteractiveConsole</code></a> 类以支持历史保存/恢复。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> atexit</span><br><span class="line"><span class="keyword">import</span> code</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> readline</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HistoryConsole</span><span class="params">(code.InteractiveConsole)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, locals=None, filename=<span class="string">"&lt;console&gt;"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 histfile=os.path.expanduser<span class="params">(<span class="string">"~/.console-history"</span>)</span>)</span>:</span></span><br><span class="line">        code.InteractiveConsole.__init__(self, locals, filename)</span><br><span class="line">        self.init_history(histfile)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_history</span><span class="params">(self, histfile)</span>:</span></span><br><span class="line">        readline.parse_and_bind(<span class="string">"tab: complete"</span>)</span><br><span class="line">        <span class="keyword">if</span> hasattr(readline, <span class="string">"read_history_file"</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                readline.read_history_file(histfile)</span><br><span class="line">            <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            atexit.register(self.save_history, histfile)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_history</span><span class="params">(self, histfile)</span>:</span></span><br><span class="line">        readline.set_history_length(<span class="number">1000</span>)</span><br><span class="line">        readline.write_history_file(histfile)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-readline&quot;&gt;&lt;a href=&quot;#python-标准库-readline&quot; class=&quot;headerlink&quot; title=&quot;python  标准库 readline&quot;&gt;&lt;/a&gt;python  标准库 readline&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200304_remember_beyond_the_futrue.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="readline" scheme="https://pinghailinfeng.gitee.io/tags/readline/"/>
    
  </entry>
  
  <entry>
    <title>python standard library atexit</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/03/python-standard-library-atexit/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/03/python-standard-library-atexit/</id>
    <published>2020-03-03T13:09:49.000Z</published>
    <updated>2020-03-03T13:51:30.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-atexit"><a href="#python-标准库-atexit" class="headerlink" title="python 标准库 atexit"></a>python 标准库 atexit</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200303_Prometheus.jpeg?raw=true" alt></p><a id="more"></a><blockquote><p>Prometheus  普罗米修斯(盗火者)</p><p>在希腊神话中，是最具智慧的神明之一，最早的泰坦巨神后代，名字有“先见之明”（Forethought）的意思。<a href="https://baike.baidu.com/item/%E6%B3%B0%E5%9D%A6%E5%8D%81%E4%BA%8C%E7%A5%9E/3078723" target="_blank" rel="noopener">泰坦十二神</a><a href="https://baike.baidu.com/item/%E4%BC%8A%E9%98%BF%E4%BD%A9%E6%89%98%E6%96%AF/10284100" target="_blank" rel="noopener">伊阿佩托斯</a>与<a href="https://baike.baidu.com/item/%E5%85%8B%E5%90%95%E5%A2%A8%E6%B6%85" target="_blank" rel="noopener">克吕墨涅</a>的儿子。普罗米修斯不仅创造了人类，给人类带来了火，还教会了他们许多知识和技能。</p><p>例句:</p><p>Zeus saw through the trick and felt displeased at the Titan’s favour towards men. </p><p>宙斯识破了这套把戏,<strong>普罗米修斯</strong>对人类的偏爱让他很不高兴.</p><p>扩展:</p><p> 电影&lt;普罗米修斯&gt;  讲述的是 21世纪末，人类的科技水平已高度发达，克隆人技术和宇宙航行早已实现，不再是梦想。与此同时，许多科学家仍孜孜不倦追索着人类起源的秘密与真相。人类可能是来自一个遥远星系的外星人创造的,经典中的经典。</p></blockquote><p><a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 模块定义了清理函数的注册和反注册函数. 被注册的函数会在解释器正常终止时执行. <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 会按照注册顺序的<em>逆序</em>执行; 如果你注册了 <code>A</code>, <code>B</code> 和 <code>C</code>, 那么在解释器终止时会依序执行 <code>C</code>, <code>B</code>, <code>A</code>.</p><p><strong>注意:</strong> 通过该模块注册的函数, 在程序被未被 Python 捕获的信号杀死时并不会执行, 在检测到 Python 内部致命错误以及调用了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os._exit" target="_blank" rel="noopener"><code>os._exit()</code></a> 时也不会执行.</p><p><em>在 3.7 版更改:</em> 当配合 C-API 子解释器使用时，已注册函数是它们所注册解释器中的局部对象。</p><ul><li><p><code>atexit.register</code>(<em>func</em>, <strong>args<em>, </em></strong>kwargs*)</p><p>将 <em>func</em> 注册为终止时执行的函数. 任何传给 <em>func</em> 的可选的参数都应当作为参数传给 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#atexit.register" target="_blank" rel="noopener"><code>register()</code></a>. 可以多次注册同样的函数及参数.在正常的程序终止时 (举例来说, 当调用了 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 或是主模块的执行完成时), 所有注册过的函数都会以后进先出的顺序执行. 这样做是假定更底层的模块通常会比高层模块更早引入, 因此需要更晚清理.如果在 exit 处理程序执行期间引发了异常，将会打印回溯信息 (除非引发的是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a>) 并且异常信息会被保存。 在所有 exit 处理程序获得运行机会之后，所引发的最后一个异常会被重新引发。这个函数返回 <em>func</em> 对象，可以把它当作装饰器使用。</p></li><li><p><code>atexit.unregister</code>(<em>func</em>)</p><p>从解释器关闭前要运行的函数列表中移除 <em>func</em>。 在调用 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#atexit.unregister" target="_blank" rel="noopener"><code>unregister()</code></a> 之后，当解释器关闭时会确保 <em>func</em> 不会被调用，即使它被多次注册。 如果 <em>func</em> 之前没有被注册，<a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#atexit.unregister" target="_blank" rel="noopener"><code>unregister()</code></a> 会静默地不做任何操作。</p></li></ul><p>参见</p><ul><li><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a></p><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 读写 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 历史文件的有用的例子。</p></li></ul><h2 id="atexit-示例"><a href="#atexit-示例" class="headerlink" title="atexit 示例"></a><a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 示例</h2><p>以下简单例子演示了一个模块在被导入时如何从文件初始化一个计数器，并在程序终结时自动保存计数器的更新值，此操作不依赖于应用在终结时对此模块进行显式调用。:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    with open(&quot;counterfile&quot;) as infile:</span><br><span class="line">        _count = int(infile.read())</span><br><span class="line">except FileNotFoundError:</span><br><span class="line">    _count = 0</span><br><span class="line"></span><br><span class="line">def incrcounter(n):</span><br><span class="line">    global _count</span><br><span class="line">    _count = _count + n</span><br><span class="line"></span><br><span class="line">def savecounter():</span><br><span class="line">    with open(&quot;counterfile&quot;, &quot;w&quot;) as outfile:</span><br><span class="line">        outfile.write(&quot;%d&quot; % _count)</span><br><span class="line"></span><br><span class="line">import atexit</span><br><span class="line">atexit.register(savecounter)</span><br></pre></td></tr></table></figure><p>位置和关键字参数也可传入 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#atexit.register" target="_blank" rel="noopener"><code>register()</code></a> 以便传递给被调用的已注册函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def goodbye(name, adjective):</span><br><span class="line">    print(&apos;Goodbye, %s, it was %s to meet you.&apos; % (name, adjective))</span><br><span class="line"></span><br><span class="line">import atexit</span><br><span class="line">atexit.register(goodbye, &apos;Donny&apos;, &apos;nice&apos;)</span><br><span class="line"></span><br><span class="line"># or:</span><br><span class="line">atexit.register(goodbye, adjective=&apos;nice&apos;, name=&apos;Donny&apos;)</span><br></pre></td></tr></table></figure><p>作为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-decorator" target="_blank" rel="noopener">decorator</a>: 使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import atexit</span><br><span class="line"></span><br><span class="line">@atexit.register</span><br><span class="line">def goodbye():</span><br><span class="line">    print(&quot;You are now leaving the Python sector.&quot;)</span><br></pre></td></tr></table></figure><p>只有在函数不需要任何参数调用时才能工作.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-atexit&quot;&gt;&lt;a href=&quot;#python-标准库-atexit&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 atexit&quot;&gt;&lt;/a&gt;python 标准库 atexit&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200303_Prometheus.jpeg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="atexit" scheme="https://pinghailinfeng.gitee.io/tags/atexit/"/>
    
  </entry>
  
  <entry>
    <title>python standard library keyword</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/02/python-standard-library-keyword/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/02/python-standard-library-keyword/</id>
    <published>2020-03-02T14:02:38.000Z</published>
    <updated>2020-03-02T14:27:42.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python-标准库-keyword"><a href="#python-标准库-keyword" class="headerlink" title="python 标准库 keyword"></a>python 标准库 keyword</h2><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200302_luoxia.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>闺女语录:</p><p>我和同事聊天说起,养个孩子容易吗! 我闺女说,“养什么容易啊。”</p><p>同事咂舌,这个小孩不简单。</p></blockquote><blockquote><p>每日一词:</p><p>candaign [kæm’peɪn]</p><ul><li>n.战役；运动（为社会、商业或政治目的而进行的一系列有计划的活动）</li><li>v.领导运动（如为实现政治变革或赢得竞选）</li><li>网络战役模式；竞选运动；广告活动</li></ul></blockquote><p>这估计是标准库中最简单的模块了</p><p>源代码比较少,这就直接贴出来了</p><p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/keyword.py" target="_blank" rel="noopener">Lib/keyword.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">kwlist = [</span><br><span class="line">    <span class="string">'False'</span>,</span><br><span class="line">    <span class="string">'None'</span>,</span><br><span class="line">    <span class="string">'True'</span>,</span><br><span class="line">    <span class="string">'and'</span>,</span><br><span class="line">    <span class="string">'as'</span>,</span><br><span class="line">    <span class="string">'assert'</span>,</span><br><span class="line">    <span class="string">'async'</span>,</span><br><span class="line">    <span class="string">'await'</span>,</span><br><span class="line">    <span class="string">'break'</span>,</span><br><span class="line">    <span class="string">'class'</span>,</span><br><span class="line">    <span class="string">'continue'</span>,</span><br><span class="line">    <span class="string">'def'</span>,</span><br><span class="line">    <span class="string">'del'</span>,</span><br><span class="line">    <span class="string">'elif'</span>,</span><br><span class="line">    <span class="string">'else'</span>,</span><br><span class="line">    <span class="string">'except'</span>,</span><br><span class="line">    <span class="string">'finally'</span>,</span><br><span class="line">    <span class="string">'for'</span>,</span><br><span class="line">    <span class="string">'from'</span>,</span><br><span class="line">    <span class="string">'global'</span>,</span><br><span class="line">    <span class="string">'if'</span>,</span><br><span class="line">    <span class="string">'import'</span>,</span><br><span class="line">    <span class="string">'in'</span>,</span><br><span class="line">    <span class="string">'is'</span>,</span><br><span class="line">    <span class="string">'lambda'</span>,</span><br><span class="line">    <span class="string">'nonlocal'</span>,</span><br><span class="line">    <span class="string">'not'</span>,</span><br><span class="line">    <span class="string">'or'</span>,</span><br><span class="line">    <span class="string">'pass'</span>,</span><br><span class="line">    <span class="string">'raise'</span>,</span><br><span class="line">    <span class="string">'return'</span>,</span><br><span class="line">    <span class="string">'try'</span>,</span><br><span class="line">    <span class="string">'while'</span>,</span><br><span class="line">    <span class="string">'with'</span>,</span><br><span class="line">    <span class="string">'yield'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">iskeyword = frozenset(kwlist).__contains__</span><br></pre></td></tr></table></figure><p>此模块允许 Python 程序确定字符串是否为关键字。</p><ul><li><p><code>keyword.iskeyword</code>(<em>s</em>)</p><p>如果 <em>s</em> 是一个 Python 保留关键字则返回 <code>True</code>,否则返回<code>False</code>。</p></li><li><p><code>keyword.kwlist</code></p><p>序列包含为解释器定义的所有关键字。 如果任何被定义的关键字为仅在 <a href="https://docs.python.org/zh-cn/3.8/library/__future__.html#module-__future__" target="_blank" rel="noopener"><code>__future__</code></a> 语句生效是特定时间处于活动状态，则也将包含这些关键字。</p><p>其实就是获得所有关键字构成的列表。</p></li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>这里主要涉及两个知识点:</p><ol><li><p>冻结集合: <code>frozenset</code> 通过这个函数,创建一个由参数构成的不可变集合。</p></li><li><p>魔术方法 <code>__contains__</code> ： 定义当使用成员测试运算符（in 或 not in）时的行为</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;python-标准库-keyword&quot;&gt;&lt;a href=&quot;#python-标准库-keyword&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 keyword&quot;&gt;&lt;/a&gt;python 标准库 keyword&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200302_luoxia.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="keyword" scheme="https://pinghailinfeng.gitee.io/tags/keyword/"/>
    
  </entry>
  
  <entry>
    <title>python standard_library select</title>
    <link href="https://pinghailinfeng.gitee.io/2020/03/01/python-standard-library-select/"/>
    <id>https://pinghailinfeng.gitee.io/2020/03/01/python-standard-library-select/</id>
    <published>2020-03-01T14:32:30.000Z</published>
    <updated>2020-03-01T14:47:50.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-select-等待-I-O-完成"><a href="#python-标准库-select-等待-I-O-完成" class="headerlink" title="python 标准库 select  等待 I/O 完成"></a>python 标准库 select  等待 I/O 完成</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200301_ncc_1701.webp?raw=true" alt></p><a id="more"></a><blockquote><p>star trek n 星际迷航</p><p>trek n 长途跋涉</p><p>​      vi 旅行</p><p>例句：</p><ol><li>It took us a week to trek to the foot of the mountain.<br>我们花了一星期才跋涉到山脚。</li><li><p>I hate having to trek up that hill with all the groceries.<br>我很不愿意得带着这么多吃用杂物爬上那个山头。</p></li><li><p>The trek is especially difficult for us.<br>我们走起来更加艰难。</p></li><li>My boots were punished by our long trek in the mountains.<br>我的靴子因为我们在山中漫长的徒步而受损。</li></ol></blockquote><p>该模块提供了对 <code>select()</code> 和 <code>poll()</code> 函数的访问，这些函数在大多数操作系统中是可用的。在 Solaris 及其衍生版本上可用 <code>devpoll()</code>，在 Linux 2.5+ 上可用 <code>epoll()</code>，在大多数 BSD 上可用 <code>kqueue()</code>。注意，在 Windows 上，本模块仅适用于套接字；在其他操作系统上，本模块也适用于其他文件类型（特别地，在 Unix 上也适用于管道）。本模块不能用于常规文件，不能检测出（自上次读取文件后）文件是否有新数据写入。</p><blockquote><p> <a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#module-selectors" target="_blank" rel="noopener"><code>selectors</code></a> 模块是在 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#module-select" target="_blank" rel="noopener"><code>select</code></a> 模块原型的基础上进行高级且高效的 I/O 复用。推荐用户改用 <a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#module-selectors" target="_blank" rel="noopener"><code>selectors</code></a> 模块，除非用户希望对 OS 级的函数原型进行精确控制。</p></blockquote><p>该模块定义以下内容：</p><ul><li><p><em>exception</em> <code>select.error</code></p><p>一个被弃用的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的别名。<em>在 3.3 版更改:</em> 根据 <a href="https://www.python.org/dev/peps/pep-3151" target="_blank" rel="noopener"><strong>PEP 3151</strong></a>，这个类是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的别名。</p></li><li><p><code>select.devpoll</code>()</p><p>（仅支持 Solaris 及其衍生版本）返回一个 <code>/dev/poll</code> 轮询对象，请参阅下方 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#devpoll-objects" target="_blank" rel="noopener">/dev/poll 轮询对象</a> 获取 devpoll 对象所支持的方法。<code>devpoll()</code> 对象与实例化时允许的文件描述符数量有关，如果在程序中降低了此数值，<code>devpoll()</code> 调用将失败。如果程序提高了此数值，<code>devpoll()</code> 可能会返回一个不完整的活动文件描述符列表。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承的</a>。<em>3.3 新版功能.**在 3.4 版更改:</em> 新的文件描述符现在是不可继承的。</p></li><li><p><code>select.epoll</code>(<em>sizehint=-1</em>, <em>flags=0</em>)</p><p>（仅支持 Linux 2.5.44 或更高版本）返回一个 edge poll 对象，该对象可作为 I/O 事件的边缘触发或水平触发接口。<em>sizehint</em> 指示 epoll 预计需要注册的事件数。它必须为正数，或为 -1 以使用默认值。它仅在 <code>epoll_create1()</code> 不可用的旧系统上会被用到，其他情况下它没有任何作用（尽管仍会检查其值）。<em>flags</em> 已经弃用且完全被忽略。但是，如果提供该值，则它必须是 <code>0</code> 或 <code>select.EPOLL_CLOEXEC</code>，否则会抛出 <code>OSError</code> 异常。请参阅下方 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#epoll-objects" target="_blank" rel="noopener">边缘触发和水平触发的轮询 (epoll) 对象</a> 获取 epoll 对象所支持的方法。<code>epoll</code> 对象支持上下文管理器：当在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中使用时，新建的文件描述符会在运行至语句块结束时自动关闭。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承的</a>。<em>在 3.3 版更改:</em> 增加了 <em>flags</em> 参数。<em>在 3.4 版更改:</em> 增加了对 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的支持。新的文件描述符现在是不可继承的。<em>3.4 版后已移除:</em> <em>flags</em> 参数。现在默认采用 <code>select.EPOLL_CLOEXEC</code> 标志。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.set_inheritable" target="_blank" rel="noopener"><code>os.set_inheritable()</code></a> 来让文件描述符可继承。</p></li><li><p><code>select.poll</code>()</p><p>（部分操作系统不支持）返回一个 poll 对象，该对象支持注册和注销文件描述符，支持对描述符进行轮询以获取 I/O 事件。请参阅下方 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#poll-objects" target="_blank" rel="noopener">Poll 对象</a> 获取 poll 对象所支持的方法。</p></li><li><p><code>select.kqueue</code>()</p><p>（仅支持 BSD）返回一个内核队列对象，请参阅下方 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#kqueue-objects" target="_blank" rel="noopener">Kqueue 对象</a> 获取 kqueue 对象所支持的方法。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承的</a>。<em>在 3.4 版更改:</em> 新的文件描述符现在是不可继承的。</p></li><li><p><code>select.kevent</code>(<em>ident</em>, <em>filter=KQ_FILTER_READ</em>, <em>flags=KQ_EV_ADD</em>, <em>fflags=0</em>, <em>data=0</em>, <em>udata=0</em>)</p><p>（仅支持 BSD）返回一个内核事件对象，请参阅下方 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#kevent-objects" target="_blank" rel="noopener">Kevent 对象</a> 获取 kevent 对象所支持的方法。</p></li><li><p><code>select.select</code>(<em>rlist</em>, <em>wlist</em>, <em>xlist</em>[, <em>timeout</em>])</p><p>这是 Unix <code>select()</code> 系统调用的直接接口。前三个参数是由“等待对象”组成的序列，“等待对象”可以是表示文件描述符的整数，也可以是带有 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法的对象（该方法没有参数，返回一个整数）：<em>rlist</em>：等待，直到可以开始读取<em>wlist</em>：等待，直到可以开始写入<em>xlist</em>：等待“异常情况”（请参阅当前系统的手册，以获取哪些情况称为异常情况）允许使用空序列，但是否接受三个空序列取决于平台。（目前已知在 Unix 上可以但 Windows 上不行。）可选的 <em>timeout</em> 参数指定超时时长，为浮点数，以秒为单位。如果省略了 <em>timeout</em> 参数，则该函数将阻塞，直到至少一个文件描述符准备就绪。超时值为零表示轮询且永不阻塞。返回值是三个列表，包含已就绪对象，返回的三个列表是前三个参数的子集。当超时时间已到且没有文件描述符就绪时，返回三个空列表。序列中可接受的对象类型包括 Python <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">文件对象</a> (例如 <code>sys.stdin</code>、<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>os.popen()</code></a> 返回的对象)，<a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.socket" target="_blank" rel="noopener"><code>socket.socket()</code></a> 返回的套接字对象。 你也可以自定义 <em>wrapper</em> 类，只要它具有合适的 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法（该方法应返回实际的文件描述符，而不仅仅返回一个随机整数）。</p><blockquote><p>Windows 上不接受文件对象，但接受套接字。在 Windows 上，底层的 <code>select()</code> 函数由 WinSock 库提供，且不处理不是源自 WinSock 的文件描述符。</p></blockquote><p> <em>3.5 版更改:</em> 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p></li><li><p>select.PIPE_BUF</p><p>当一个管道已经被 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.select" target="_blank" rel="noopener"><code>select()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.poll" target="_blank" rel="noopener"><code>poll()</code></a> 或本模块中的某个接口报告为可写入时，可以在不阻塞该管道的情况下写入的最小字节数。它不适用于套接字等其他类型的文件类对象。</p><p>POSIX 上须保证该值不小于 512。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix</p></li></ul><h2 id="dev-poll-轮询对象"><a href="#dev-poll-轮询对象" class="headerlink" title="/dev/poll 轮询对象"></a><code>/dev/poll</code> 轮询对象</h2><p>Solaris 及其衍生版本具备 <code>/dev/poll</code>。<code>select()</code> 复杂度为 O（最高文件描述符），<code>poll()</code> 为 O（文件描述符数量），而 <code>/dev/poll</code> 为 O（活动的文件描述符）。</p><p><code>/dev/poll</code> 的行为与标准 <code>poll()</code> 对象十分类似。</p><ul><li><p><code>devpoll.close</code>()</p><p>关闭轮询对象的文件描述符。<em>3.4 新版功能.</em></p></li><li><p><code>devpoll.closed</code></p><p>如果轮询对象已关闭，则返回 <code>True</code>。<em>3.4 新版功能.</em></p></li><li><p><code>devpoll.fileno</code>()</p><p>返回轮询对象的文件描述符对应的数字。<em>3.4 新版功能.</em></p></li><li><p><code>devpoll.register</code>(<em>fd</em>[, <em>eventmask</em>])</p><p>在轮询对象中注册文件描述符。这样，将来调用 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.poll" target="_blank" rel="noopener"><code>poll()</code></a> 方法时将检查文件描述符是否有未处理的 I/O 事件。<em>fd</em> 可以是整数，也可以是带有 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法的对象（该方法返回一个整数）。文件对象已经实现了 <code>fileno()</code>，因此它们也可以用作参数。<em>eventmask</em> 是可选的位掩码，用于指定要检查的事件类型。这些常量与 <code>poll()</code> 对象所用的相同。本参数的默认值是常量 <code>POLLIN</code>、<code>POLLPRI</code> 和 <code>POLLOUT</code> 的组合。</p></li><li><p><code>devpoll.modify</code>(<em>fd</em>[, <em>eventmask</em>])</p><p>此方法先执行 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.devpoll.unregister" target="_blank" rel="noopener"><code>unregister()</code></a> 后执行 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.devpoll.register" target="_blank" rel="noopener"><code>register()</code></a>。直接执行此操作效率（稍微）高一些。</p></li><li><p><code>devpoll.unregister</code>(<em>fd</em>)</p><p>删除轮询对象正在跟踪的某个文件描述符。与 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.devpoll.register" target="_blank" rel="noopener"><code>register()</code></a> 方法类似，<em>fd</em> 可以是整数，也可以是带有 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法的对象（该方法返回一个整数）。尝试删除从未注册过的文件描述符将被安全地忽略。</p></li><li><p><code>devpoll.poll</code>([<em>timeout</em>])</p><p>轮询已注册的文件描述符的集合，并返回一个列表，列表可能为空，也可能有多个 <code>(fd, event)</code> 二元组，其中包含了要报告事件或错误的描述符。<em>fd</em> 是文件描述符，<em>event</em> 是一个位掩码，表示该描述符所报告的事件 — <code>POLLIN</code> 表示可以读取，<code>POLLOUT</code> 表示该描述符可以写入，依此类推。空列表表示调用超时，没有任何文件描述符报告事件。如果指定了 <em>timeout</em>，它将指定系统等待事件时，等待多长时间后返回（以毫秒为单位）。如果 <em>timeout</em> 为空，-1 或 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>，则本调用将阻塞，直到轮询对象发生事件为止。<em>在 3.5 版更改:</em> 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p></li></ul><h2 id="边缘触发和水平触发的轮询-epoll-对象"><a href="#边缘触发和水平触发的轮询-epoll-对象" class="headerlink" title="边缘触发和水平触发的轮询 (epoll) 对象"></a>边缘触发和水平触发的轮询 (epoll) 对象</h2><p><a href="https://linux.die.net/man/4/epoll" target="_blank" rel="noopener">https://linux.die.net/man/4/epoll</a></p><p><em>eventmask</em></p><table><thead><tr><th>常数</th><th>意义</th></tr></thead><tbody><tr><td><code>EPOLLIN</code></td><td>可读</td></tr><tr><td><code>EPOLLOUT</code></td><td>可写</td></tr><tr><td><code>EPOLLPRI</code></td><td>紧急数据读取</td></tr><tr><td><code>EPOLLERR</code></td><td>在关联的文件描述符上有错误情况发生</td></tr><tr><td><code>EPOLLHUP</code></td><td>关联的文件描述符已挂起</td></tr><tr><td><code>EPOLLET</code></td><td>设置触发方式为边缘触发，默认为水平触发</td></tr><tr><td><code>EPOLLONESHOT</code></td><td>设置 one-shot 模式。触发一次事件后，该描述符会在轮询对象内部被禁用。</td></tr><tr><td><code>EPOLLEXCLUSIVE</code></td><td>当已关联的描述符发生事件时，仅唤醒一个 epoll 对象。默认（如果未设置此标志）是唤醒所有轮询该描述符的 epoll 对象。</td></tr><tr><td><code>EPOLLRDHUP</code></td><td>流套接字的对侧关闭了连接或关闭了写入到一半的连接。</td></tr><tr><td><code>EPOLLRDNORM</code></td><td>等同于 <code>EPOLLIN</code></td></tr><tr><td><code>EPOLLRDBAND</code></td><td>可以读取优先数据带。</td></tr><tr><td><code>EPOLLWRNORM</code></td><td>等同于 <code>EPOLLOUT</code></td></tr><tr><td><code>EPOLLWRBAND</code></td><td>可以写入优先级数据。</td></tr><tr><td><code>EPOLLMSG</code></td><td>忽略</td></tr></tbody></table><p><em>3.6 新版功能:</em> 增加了 <code>EPOLLEXCLUSIVE</code>。仅支持 Linux Kernel 4.5 或更高版本。</p><ul><li><p><code>epoll.close</code>()</p><p>关闭用于控制 epoll 对象的文件描述符。</p></li><li><p><code>epoll.closed</code></p><p>如果 epoll 对象已关闭，则返回 <code>True</code>。</p></li><li><p><code>epoll.fileno</code>()</p><p>返回文件描述符对应的数字，该描述符用于控制 epoll 对象。</p></li><li><p><code>epoll.fromfd</code>(<em>fd</em>)</p><p>根据给定的文件描述符创建 epoll 对象。</p></li><li><p><code>epoll.register</code>(<em>fd</em>[, <em>eventmask</em>])</p><p>在 epoll 对象中注册一个文件描述符。</p></li><li><p><code>epoll.modify</code>(<em>fd</em>, <em>eventmask</em>)</p><p>修改一个已注册的文件描述符。</p></li><li><p><code>epoll.unregister</code>(<em>fd</em>)</p><p>从 epoll 对象中删除一个已注册的文件描述符。</p></li><li><p><code>epoll.poll</code>(<em>timeout=None</em>, <em>maxevents=-1</em>)</p><p>等待事件发生，timeout 是浮点数，单位为秒。<em>在 3.5 版更改:</em> 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p></li></ul><h2 id="Poll-对象"><a href="#Poll-对象" class="headerlink" title="Poll 对象"></a>Poll 对象</h2><p>大多数 Unix 系统支持 <code>poll()</code> 系统调用，为服务器提供了更好的可伸缩性，使服务器可以同时服务于大量客户端。<code>poll()</code> 的伸缩性更好，因为该调用内部仅列出所关注的文件描述符，而 <code>select()</code> 会构造一个 bitmap，在其中将所关注的描述符所对应的 bit 打开，然后重新遍历整个 bitmap。因此 <code>select()</code> 复杂度是 O（最高文件描述符），而 <code>poll()</code> 是 O（文件描述符数量）。</p><ul><li><p><code>poll.register</code>(<em>fd</em>[, <em>eventmask</em>])</p><p>在轮询对象中注册文件描述符。这样，将来调用 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.poll" target="_blank" rel="noopener"><code>poll()</code></a> 方法时将检查文件描述符是否有未处理的 I/O 事件。<em>fd</em> 可以是整数，也可以是带有 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法的对象（该方法返回一个整数）。文件对象已经实现了 <code>fileno()</code>，因此它们也可以用作参数。<em>eventmask</em> 是可选的位掩码，用于指定要检查的事件类型，它可以是常量 <code>POLLIN</code>、<code>POLLPRI</code> 和 <code>POLLOUT</code> 的组合，如下表所述。如果未指定本参数，默认将会检查所有 3 种类型的事件。</p><p>| 常数        | 意义                                               |<br>| ———– | ————————————————– |<br>| <code>POLLIN</code>    | 有要读取的数据                                     |<br>| <code>POLLPRI</code>   | 有紧急数据需要读取                                 |<br>| <code>POLLOUT</code>   | 准备输出：写不会阻塞                               |<br>| <code>POLLERR</code>   | 某种错误条件                                       |<br>| <code>POLLHUP</code>   | 挂起                                               |<br>| <code>POLLRDHUP</code> | 流套接字的对侧关闭了连接，或关闭了写入到一半的连接 |<br>| <code>POLLNVAL</code>  | 无效的请求：描述符未打开                           |</p><p>注册已注册过的文件描述符不会报错，且等同于只注册一次该描述符。</p></li><li><p><code>poll.modify</code>(<em>fd</em>, <em>eventmask</em>)</p><p>修改一个已注册的文件描述符，等同于 <code>register(fd, eventmask)</code>。尝试修改未注册的文件描述符会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，错误码为 <code>ENOENT</code>。</p></li><li><p><code>poll.unregister</code>(<em>fd</em>)</p><p>删除轮询对象正在跟踪的某个文件描述符。与 <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.poll.register" target="_blank" rel="noopener"><code>register()</code></a> 方法类似，<em>fd</em> 可以是整数，也可以是带有 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法的对象（该方法返回一个整数）。尝试删除从未注册过的文件描述符会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 异常。</p></li><li><p><code>poll.poll</code>([<em>timeout</em>])</p><p>轮询已注册的文件描述符的集合，并返回一个列表，列表可能为空，也可能有多个 <code>(fd, event)</code> 二元组，其中包含了要报告事件或错误的描述符。<em>fd</em> 是文件描述符，<em>event</em> 是一个位掩码，表示该描述符所报告的事件 — <code>POLLIN</code> 表示可以读取，<code>POLLOUT</code> 表示该描述符可以写入，依此类推。空列表表示调用超时，没有任何文件描述符报告事件。如果指定了 <em>timeout</em>，它将指定系统等待事件时，等待多长时间后返回（以毫秒为单位）。如果 <em>timeout</em> 为空、负数 或 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>，则本调用将阻塞，直到轮询对象发生事件为止。<em>在 3.5 版更改:</em> 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p></li></ul><h2 id="Kqueue-对象"><a href="#Kqueue-对象" class="headerlink" title="Kqueue 对象"></a>Kqueue 对象</h2><ul><li><p><code>kqueue.close</code>()</p><p>关闭用于控制 kqueue 对象的文件描述符。</p></li><li><p><code>kqueue.closed</code></p><p>如果 kqueue 对象已关闭，则返回 <code>True</code>。</p></li><li><p><code>kqueue.fileno</code>()</p><p>返回文件描述符对应的数字，该描述符用于控制 epoll 对象。</p></li><li><p><code>kqueue.fromfd</code>(<em>fd</em>)</p><p>根据给定的文件描述符创建 kqueue 对象。</p></li><li><p><code>kqueue.control</code>(<em>changelist</em>, <em>max_events</em>[, <em>timeout</em>]) → eventlist</p><p>Kevent 的低级接口changelist 必须是一个可迭代对象，迭代出 kevent 对象，否则置为 <code>None</code>。max_events 必须是 0 或一个正整数。timeout 单位为秒（一般为浮点数），默认为 <code>None</code>，即永不超时。<em>在 3.5 版更改:</em> 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p></li></ul><h2 id="Kevent-对象"><a href="#Kevent-对象" class="headerlink" title="Kevent 对象"></a>Kevent 对象</h2><p><a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2" target="_blank" rel="noopener">https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2</a></p><p><a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2" target="_blank" rel="noopener">https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2</a></p><ul><li><p><code>kevent.ident</code></p><p>用于区分事件的标识值。其解释取决于筛选器，但该值通常是文件描述符。在构造函数中，该标识值可以是整数或带有 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法的对象。kevent 在内部存储整数。</p></li><li><p><code>kevent.filter</code></p><p>内核筛选器的名称。</p><p>| 常数               | 意义                                              |<br>| —————— | ————————————————- |<br>| <code>KQ_FILTER_READ</code>   | 获取描述符，并在有数据可读时返回                  |<br>| <code>KQ_FILTER_WRITE</code>  | 获取描述符，并在有数据可写时返回                  |<br>| <code>KQ_FILTER_AIO</code>    | AIO 请求                                          |<br>| <code>KQ_FILTER_VNODE</code>  | 当在 <em>fflag</em> 中监视的一个或多个请求事件发生时返回 |<br>| <code>KQ_FILTER_PROC</code>   | 监视进程ID上的事件                                |<br>| <code>KQ_FILTER_NETDEV</code> | 观察网络设备上的事件[在Mac OS X上不可用]          |<br>| <code>KQ_FILTER_SIGNAL</code> | 每当监视的信号传递到进程时返回                    |<br>| <code>KQ_FILTER_TIMER</code>  | 建立一个任意的计时器                              |</p></li></ul><ul><li><p>kevent.flags</p><p>筛选器操作。</p></li></ul><table><thead><tr><th>常数</th><th>意义</th></tr></thead><tbody><tr><td><code>KQ_EV_ADD</code></td><td>添加或修改事件</td></tr><tr><td><code>KQ_EV_DELETE</code></td><td>从队列中删除事件</td></tr><tr><td><code>KQ_EV_ENABLE</code></td><td>Permitscontrol() 返回事件</td></tr><tr><td><code>KQ_EV_DISABLE</code></td><td>禁用事件</td></tr><tr><td><code>KQ_EV_ONESHOT</code></td><td>在第一次发生后删除事件</td></tr><tr><td><code>KQ_EV_CLEAR</code></td><td>检索事件后重置状态</td></tr><tr><td><code>KQ_EV_SYSFLAGS</code></td><td>内部事件</td></tr><tr><td><code>KQ_EV_FLAG1</code></td><td>内部事件</td></tr><tr><td><code>KQ_EV_EOF</code></td><td>筛选特定EOF条件</td></tr><tr><td><code>KQ_EV_ERROR</code></td><td>请参阅返回值</td></tr></tbody></table><ul><li>kevent.fflags</li></ul><p>筛选特定标志。</p><p><code>KQ_FILTER_READ</code> 和 <code>KQ_FILTER_WRITE</code> 筛选标志：</p><table><thead><tr><th>常数</th><th>意义</th></tr></thead><tbody><tr><td><code>KQ_NOTE_LOWAT</code></td><td>套接字缓冲区的低水线</td></tr></tbody></table><p><code>KQ_FILTER_VNODE</code> 筛选标志：</p><table><thead><tr><th>常数</th><th>意义</th></tr></thead><tbody><tr><td><code>KQ_NOTE_DELETE</code></td><td>已调用 <em>unlink()</em></td></tr><tr><td><code>KQ_NOTE_WRITE</code></td><td>发生写入</td></tr><tr><td><code>KQ_NOTE_EXTEND</code></td><td>文件已扩展</td></tr><tr><td><code>KQ_NOTE_ATTRIB</code></td><td>属性已更改</td></tr><tr><td><code>KQ_NOTE_LINK</code></td><td>链接计数已更改</td></tr><tr><td><code>KQ_NOTE_RENAME</code></td><td>文件已重命名</td></tr><tr><td><code>KQ_NOTE_REVOKE</code></td><td>对文件的访问权限已被撤销</td></tr></tbody></table><p><code>KQ_FILTER_PROC</code> filter flags:</p><table><thead><tr><th>常数</th><th>意义</th></tr></thead><tbody><tr><td><code>KQ_NOTE_EXIT</code></td><td>进程已退出</td></tr><tr><td><code>KQ_NOTE_FORK</code></td><td>该进程调用了 <em>fork()</em></td></tr><tr><td><code>KQ_NOTE_EXEC</code></td><td>进程已执行新进程</td></tr><tr><td><code>KQ_NOTE_PCTRLMASK</code></td><td>内部筛选器标志</td></tr><tr><td><code>KQ_NOTE_PDATAMASK</code></td><td>内部筛选器标志</td></tr><tr><td><code>KQ_NOTE_TRACK</code></td><td>跨 <em>fork()</em> 执行进程</td></tr><tr><td><code>KQ_NOTE_CHILD</code></td><td>在 <em>NOTE_TRACK</em> 的子进程上返回</td></tr><tr><td><code>KQ_NOTE_TRACKERR</code></td><td>无法附加到子对象</td></tr></tbody></table><p><code>KQ_FILTER_NETDEV</code> 筛选器标志（在 Mac OS X 上不可用）：</p><table><thead><tr><th>常数</th><th>意义</th></tr></thead><tbody><tr><td><code>KQ_NOTE_LINKUP</code></td><td>链接已建立</td></tr><tr><td><code>KQ_NOTE_LINKDOWN</code></td><td>链接已断开</td></tr><tr><td><code>KQ_NOTE_LINKINV</code></td><td>链接状态无效</td></tr></tbody></table><ul><li><p><code>kevent.data</code><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.kevent.data" target="_blank" rel="noopener">¶</a></p><p>筛选特定数据。</p></li><li><p><code>kevent.udata</code></p><p>用户自定义值。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-select-等待-I-O-完成&quot;&gt;&lt;a href=&quot;#python-标准库-select-等待-I-O-完成&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 select  等待 I/O 完成&quot;&gt;&lt;/a&gt;python 标准库 select  等待 I/O 完成&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200301_ncc_1701.webp?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="select" scheme="https://pinghailinfeng.gitee.io/tags/select/"/>
    
  </entry>
  
  <entry>
    <title>python standard library selectors</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/29/python-standard-library-selectors/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/29/python-standard-library-selectors/</id>
    <published>2020-02-29T13:52:55.000Z</published>
    <updated>2020-02-29T15:45:26.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-selectors-高级-I-O-复用库"><a href="#python-标准库-selectors-高级-I-O-复用库" class="headerlink" title="python 标准库 selectors  高级 I/O 复用库"></a>python 标准库 selectors  高级 I/O 复用库</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200229selectors.jpg?raw=true" alt></p><a id="more"></a><p><strong>源码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/selectors.py" target="_blank" rel="noopener">Lib/selectors.py</a></p><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>它的功能与linux的epoll，还是select模块,poll等类似；实现高效的I/O multiplexing,  常用于非阻塞的socket的编程中</p><p>模块定义了一个 BaseSelector的抽象基类， 以及它的子类，包括：EpollSelector, KqueueSelector等模块,</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Classes hierarchy:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseSelector</span><br><span class="line">+-- SelectSelector</span><br><span class="line">+-- PollSelector</span><br><span class="line">+-- EpollSelector</span><br><span class="line">+-- DevpollSelector</span><br><span class="line">+-- KqueueSelector</span><br></pre></td></tr></table></figure><p>模块定义了两个常量，用于描述 event Mask</p><table><thead><tr><th>常数</th><th>意义</th></tr></thead><tbody><tr><td><code>EVENT_READ</code></td><td>可读</td></tr><tr><td><code>EVENT_WRITE</code></td><td>可写</td></tr></tbody></table><p>模块定义了一个 SelectorKey类,是一个 <a href="https://docs.python.org/zh-cn/3.8/library/collections.html#collections.namedtuple" target="_blank" rel="noopener"><code>namedtuple</code></a> 类型, 一般用这个类的实例来描述一个已经注册的文件对象的状态，</p><p>常用属性:</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">fileobj</td><td style="text-align:left">表示已经注册的文件对象</td></tr><tr><td style="text-align:center">fd</td><td style="text-align:left">表示文件对象的描述符，是一个整数，它是文件对象的 fileno()方法的返回值</td></tr><tr><td style="text-align:center">events</td><td style="text-align:left">表示注册一个文件对象时，我们等待的events, 即上面的event Mask, 是可读呢还是可写</td></tr><tr><td style="text-align:center">data</td><td style="text-align:left">表示注册一个文件对象是邦定的data</td></tr></tbody></table><p><em>class</em> <code>selectors.BaseSelector</code></p><p>定义了一个抽象基类,能够注册和取消注册,通过一个可选的timeout,等待流中的I/O事件。抽象基类无法实例化,所以通常使用<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.DefaultSelector" target="_blank" rel="noopener"><code>DefaultSelector</code></a> 代替，或者<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectSelector" target="_blank" rel="noopener">SelectSelector`</a>, <a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.KqueueSelector" target="_blank" rel="noopener"><code>KqueueSelector</code></a> 来实现。如果你想声明一个操作系统平台支持的实现, <a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.BaseSelector" target="_blank" rel="noopener"><code>BaseSelector</code></a> 和他的子类支持 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-context-manager" target="_blank" rel="noopener">上下文管理</a> 实现。</p><ul><li><p><em>abstractmethod</em> <code>register</code>(<em>fileobj</em>, <em>events</em>, <em>data=None</em>)</p><p>用于注册一个文件对象或监控I/O事件的抽象方法。<strong>fileobj</strong> 参数是一个用于监控的对象。它可能是一个整形文件描述符或者是一个拥有 <code>fileno()</code>方法的对象。返回一个新创建的<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectorKey" target="_blank" rel="noopener">SelectorKey`</a> 类实例,或因为不存在的<code>event mask</code> 或文件描述符,或者该文件对象已经被注册过而引发<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。</p></li><li><p><em>abstractmethod</em> <code>unregister</code>(<em>fileobj</em>)</p><p>用于注销注册文件对象或移除监控I/O事件的抽象方法。该文件对象必须是之前已经注册的对象。返回值关联了<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectorKey" target="_blank" rel="noopener"><code>SelectorKey</code></a> 实例,或因为不存在的<code>event mask</code> 或文件描述符,或者该文件对象已经被注册过而引发<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。</p></li><li><p><code>modify</code>(<em>fileobj</em>, <em>events</em>, <em>data=None</em>)</p><p>用于修改一个注册过的文件对象，比如从监听可读变为监听可写；它其实就是register() 后再跟unregister(),       但是使用modify( ) 更高效；返回一个新创建的<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectorKey" target="_blank" rel="noopener">SelectorKey`</a> 类实例,或因为不存在的<code>event mask</code> 或文件描述符,或者该文件对象已经被注册过而引发<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。</p></li><li><p><em>abstractmethod</em> <code>select</code>(<em>timeout=None</em>)</p><p>用于选择满足我们监听的event的文件对象的抽象方法。</p></li><li><p><code>close</code>()</p><p>关闭 selector,为了 要确保所有的资源被释放,最后一定要调用该方法。</p></li><li><p><code>get_key</code>(<em>fileobj</em>)</p><p>返回注册文件对象的 <a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectorKey" target="_blank" rel="noopener"><code>SelectorKey</code></a> 实例。该实例关联文件对象,若文件对象未注册,将抛出<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 异常。</p></li><li><p><em>abstractmethod</em> <code>get_map</code>()</p><p>返回selectors key 的文件对象的映射。</p></li><li><p><em>class</em> <code>selectors.DefaultSelector</code></p><p>默认的selector类,其中一个子类的别名，它自动选择为当前环境中最有效的Selector。</p><p><em>selectors模块默认会用epoll，如果你的系统中没有epoll(比如windows)则会自动使用select</em></p></li><li><p><em>class</em> <code>selectors.SelectSelector</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.select" target="_blank" rel="noopener"><code>select.select()</code></a>-based selector.</p></li><li><p><em>class</em> <code>selectors.PollSelector</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.poll" target="_blank" rel="noopener"><code>select.poll()</code></a>-based selector.</p></li><li><p><em>class</em> <code>selectors.EpollSelector</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.epoll" target="_blank" rel="noopener"><code>select.epoll()</code></a>-based selector.<code>fileno</code>()This returns the file descriptor used by the underlying <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.epoll" target="_blank" rel="noopener"><code>select.epoll()</code></a> object.</p></li><li><p><em>class</em> <code>selectors.DevpollSelector</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.devpoll" target="_blank" rel="noopener"><code>select.devpoll()</code></a>-based selector.<code>fileno</code>()This returns the file descriptor used by the underlying <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.devpoll" target="_blank" rel="noopener"><code>select.devpoll()</code></a> object.<em>3.5 新版功能.</em></p></li><li><p><em>class</em> <code>selectors.KqueueSelector</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.kqueue" target="_blank" rel="noopener"><code>select.kqueue()</code></a>-based selector.<code>fileno</code>()This returns the file descriptor used by the underlying <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.kqueue" target="_blank" rel="noopener"><code>select.kqueue()</code></a> object.</p></li></ul><h2 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h2><p>Here is a simple echo server implementation:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sel = selectors.DefaultSelector()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span><span class="params">(sock, mask)</span>:</span></span><br><span class="line">    conn, addr = sock.accept()  <span class="comment"># Should be ready</span></span><br><span class="line">    print(<span class="string">'accepted'</span>, conn, <span class="string">'from'</span>, addr)</span><br><span class="line">    conn.setblocking(<span class="literal">False</span>)</span><br><span class="line">    sel.register(conn, selectors.EVENT_READ, read)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(conn, mask)</span>:</span></span><br><span class="line">    data = conn.recv(<span class="number">1000</span>)  <span class="comment"># Should be ready</span></span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        print(<span class="string">'echoing'</span>, repr(data), <span class="string">'to'</span>, conn)</span><br><span class="line">        conn.send(data)  <span class="comment"># Hope it won't block</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'closing'</span>, conn)</span><br><span class="line">        sel.unregister(conn)</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">sock = socket.socket()</span><br><span class="line">sock.bind((<span class="string">'localhost'</span>, <span class="number">1234</span>))</span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line">sock.setblocking(<span class="literal">False</span>)</span><br><span class="line">sel.register(sock, selectors.EVENT_READ, accept)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    events = sel.select()</span><br><span class="line">    <span class="keyword">for</span> key, mask <span class="keyword">in</span> events:</span><br><span class="line">        callback = key.data</span><br><span class="line">        callback(key.fileobj, mask)</span><br></pre></td></tr></table></figure><h2 id="一个基于socket的客户端与服务器端实例"><a href="#一个基于socket的客户端与服务器端实例" class="headerlink" title="一个基于socket的客户端与服务器端实例"></a>一个基于socket的客户端与服务器端实例</h2><h3 id="基于socket的服务器端实例"><a href="#基于socket的服务器端实例" class="headerlink" title="基于socket的服务器端实例"></a>基于socket的服务器端实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">selectors_echo_server.py</span><br><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">mysel = selectors.DefaultSelector()</span><br><span class="line">keep_running = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(connection, mask)</span>:</span></span><br><span class="line">    <span class="string">"Callback for read events"</span></span><br><span class="line">    <span class="keyword">global</span> keep_running</span><br><span class="line"></span><br><span class="line">    client_address = connection.getpeername()</span><br><span class="line">    print(<span class="string">'read(&#123;&#125;)'</span>.format(client_address))</span><br><span class="line">    data = connection.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        <span class="comment"># A readable client socket has data</span></span><br><span class="line">        print(<span class="string">'  received &#123;!r&#125;'</span>.format(data))</span><br><span class="line">        connection.sendall(data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Interpret empty result as closed connection</span></span><br><span class="line">        print(<span class="string">'  closing'</span>)</span><br><span class="line">        mysel.unregister(connection)</span><br><span class="line">        connection.close()</span><br><span class="line">        <span class="comment"># Tell the main loop to stop</span></span><br><span class="line">        keep_running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span><span class="params">(sock, mask)</span>:</span></span><br><span class="line">    <span class="string">"Callback for new connections"</span></span><br><span class="line">    new_connection, addr = sock.accept()</span><br><span class="line">    print(<span class="string">'accept(&#123;&#125;)'</span>.format(addr))</span><br><span class="line">    new_connection.setblocking(<span class="literal">False</span>)</span><br><span class="line">    mysel.register(new_connection, selectors.EVENT_READ, read)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server_address = (<span class="string">'localhost'</span>, <span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'starting up on &#123;&#125; port &#123;&#125;'</span>.format(*server_address))</span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.setblocking(<span class="literal">False</span>)</span><br><span class="line">server.bind(server_address)</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">mysel.register(server, selectors.EVENT_READ, accept)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> keep_running:</span><br><span class="line">    print(<span class="string">'waiting for I/O'</span>)</span><br><span class="line">    <span class="keyword">for</span> key, mask <span class="keyword">in</span> mysel.select(timeout=<span class="number">1</span>):</span><br><span class="line">        callback = key.data</span><br><span class="line">        callback(key.fileobj, mask)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'shutting down'</span>)</span><br><span class="line">mysel.close()</span><br></pre></td></tr></table></figure><h3 id="基于socket的客户端实例"><a href="#基于socket的客户端实例" class="headerlink" title="基于socket的客户端实例"></a>基于socket的客户端实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">selectors_echo_client.py</span><br><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">mysel = selectors.DefaultSelector()</span><br><span class="line">keep_running = <span class="literal">True</span></span><br><span class="line">outgoing = [</span><br><span class="line">    <span class="string">b'It will be repeated.'</span>,</span><br><span class="line">    <span class="string">b'This is the message.  '</span>,</span><br><span class="line">]</span><br><span class="line">bytes_sent = <span class="number">0</span></span><br><span class="line">bytes_received = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Connecting is a blocking operation, so call setblocking()</span></span><br><span class="line"><span class="comment"># after it returns.</span></span><br><span class="line">server_address = (<span class="string">'localhost'</span>, <span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'connecting to &#123;&#125; port &#123;&#125;'</span>.format(*server_address))</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.connect(server_address)</span><br><span class="line">sock.setblocking(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up the selector to watch for when the socket is ready</span></span><br><span class="line"><span class="comment"># to send data as well as when there is data to read.</span></span><br><span class="line">mysel.register(</span><br><span class="line">    sock,</span><br><span class="line">    selectors.EVENT_READ | selectors.EVENT_WRITE,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> keep_running:</span><br><span class="line">    print(<span class="string">'waiting for I/O'</span>)</span><br><span class="line">    <span class="keyword">for</span> key, mask <span class="keyword">in</span> mysel.select(timeout=<span class="number">1</span>):</span><br><span class="line">        connection = key.fileobj</span><br><span class="line">        client_address = connection.getpeername()</span><br><span class="line">        print(<span class="string">'client(&#123;&#125;)'</span>.format(client_address))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mask &amp; selectors.EVENT_READ:</span><br><span class="line">            print(<span class="string">'  ready to read'</span>)</span><br><span class="line">            data = connection.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                <span class="comment"># A readable client socket has data</span></span><br><span class="line">                print(<span class="string">'  received &#123;!r&#125;'</span>.format(data))</span><br><span class="line">                bytes_received += len(data)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Interpret empty result as closed connection,</span></span><br><span class="line">            <span class="comment"># and also close when we have received a copy</span></span><br><span class="line">            <span class="comment"># of all of the data sent.</span></span><br><span class="line">            keep_running = <span class="keyword">not</span> (</span><br><span class="line">                data <span class="keyword">or</span></span><br><span class="line">                (bytes_received <span class="keyword">and</span></span><br><span class="line">                 (bytes_received == bytes_sent))</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mask &amp; selectors.EVENT_WRITE:</span><br><span class="line">            print(<span class="string">'  ready to write'</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> outgoing:</span><br><span class="line">                <span class="comment"># We are out of messages, so we no longer need to</span></span><br><span class="line">                <span class="comment"># write anything. Change our registration to let</span></span><br><span class="line">                <span class="comment"># us keep reading responses from the server.</span></span><br><span class="line">                print(<span class="string">'  switching to read-only'</span>)</span><br><span class="line">                mysel.modify(sock, selectors.EVENT_READ)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Send the next message.</span></span><br><span class="line">                next_msg = outgoing.pop()</span><br><span class="line">                print(<span class="string">'  sending &#123;!r&#125;'</span>.format(next_msg))</span><br><span class="line">                sock.sendall(next_msg)</span><br><span class="line">                bytes_sent += len(next_msg)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'shutting down'</span>)</span><br><span class="line">mysel.unregister(connection)</span><br><span class="line">connection.close()</span><br><span class="line">mysel.close()</span><br></pre></td></tr></table></figure><h3 id="Server和client交互"><a href="#Server和client交互" class="headerlink" title="Server和client交互"></a>Server和client交互</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ python3 source/selectors/selectors_echo_server.py</span><br><span class="line">starting up on localhost port <span class="number">10000</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">accept((<span class="string">'127.0.0.1'</span>, <span class="number">59850</span>))</span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">read((<span class="string">'127.0.0.1'</span>, <span class="number">59850</span>))</span><br><span class="line">  received <span class="string">b'This is the message.  It will be repeated.'</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">read((<span class="string">'127.0.0.1'</span>, <span class="number">59850</span>))</span><br><span class="line">  closing</span><br><span class="line">shutting down</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ python3 source/selectors/selectors_echo_client.py</span><br><span class="line">connecting to localhost port <span class="number">10000</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">client((<span class="string">'127.0.0.1'</span>, <span class="number">10000</span>))</span><br><span class="line">  ready to write</span><br><span class="line">  sending <span class="string">b'This is the message.  '</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">client((<span class="string">'127.0.0.1'</span>, <span class="number">10000</span>))</span><br><span class="line">  ready to write</span><br><span class="line">  sending <span class="string">b'It will be repeated.'</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">client((<span class="string">'127.0.0.1'</span>, <span class="number">10000</span>))</span><br><span class="line">  ready to write</span><br><span class="line">  switching to read-only</span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">client((<span class="string">'127.0.0.1'</span>, <span class="number">10000</span>))</span><br><span class="line">  ready to read</span><br><span class="line">  received <span class="string">b'This is the message.  It will be repeated.'</span></span><br><span class="line">shutting down</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://pymotw.com/3/selectors/" target="_blank" rel="noopener">python标准库之selectors</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-selectors-高级-I-O-复用库&quot;&gt;&lt;a href=&quot;#python-标准库-selectors-高级-I-O-复用库&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 selectors  高级 I/O 复用库&quot;&gt;&lt;/a&gt;python 标准库 selectors  高级 I/O 复用库&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200229selectors.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="selectors" scheme="https://pinghailinfeng.gitee.io/tags/selectors/"/>
    
      <category term="socket" scheme="https://pinghailinfeng.gitee.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>python standard library turtle-2</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/28/python-standard-library-turtle-2/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/28/python-standard-library-turtle-2/</id>
    <published>2020-02-28T11:31:49.000Z</published>
    <updated>2020-02-28T12:21:30.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-turtle-海龟制图-续"><a href="#python-标准库-turtle-海龟制图-续" class="headerlink" title="python 标准库 turtle 海龟制图(续)"></a>python 标准库 turtle 海龟制图(续)</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/2020200228english.png?raw=true" alt></p><a id="more"></a><h3 id="使用事件"><a href="#使用事件" class="headerlink" title="使用事件"></a>使用事件</h3><ul><li><p><code>turtle.onclick</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p><p>参数<strong>fun</strong> – 一个函数，调用时将传入两个参数表示在画布上点击的坐标。<strong>btn</strong> – 鼠标按钮编号，默认值为 1 (鼠标左键)<strong>add</strong> – <code>True</code> 或 <code>False</code> – 如为 <code>True</code> 则将添加一个新绑定，否则将取代先前的绑定将 <em>fun</em> 指定的函数绑定到鼠标点击此海龟事件。如果 <em>fun</em> 值为 <code>None</code>，则移除现有的绑定。以下为使用匿名海龟即过程式的示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">turn</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    left(<span class="number">180</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>onclick(turn)  <span class="comment"># Now clicking into the turtle will turn it.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>onclick(<span class="literal">None</span>)  <span class="comment"># event-binding will be removed</span></span><br></pre></td></tr></table></figure></li><li><p><code>turtle.onrelease</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p><ul><li>参数</li></ul><p><strong>fun</strong> – 一个函数，调用时将传入两个参数表示在画布上点击的坐标。<strong>btn</strong> – 鼠标按钮编号，默认值为 1 (鼠标左键)<strong>add</strong> – <code>True</code> 或 <code>False</code> – 如为 <code>True</code> 则将添加一个新绑定，否则将取代先前的绑定</p><p>将 <em>fun</em> 指定的函数绑定到在此海龟上释放鼠标按键事件。如果 <em>fun</em> 值为 <code>None</code>，则移除现有的绑定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyTurtle</span><span class="params">(Turtle)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">glow</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.fillcolor(<span class="string">"red"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">unglow</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.fillcolor(<span class="string">""</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle = MyTurtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.onclick(turtle.glow)     <span class="comment"># clicking on turtle turns fillcolor red,</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.onrelease(turtle.unglow) <span class="comment"># releasing turns it to transparent.</span></span><br></pre></td></tr></table></figure></li><li><p><code>turtle.ondrag</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p><ul><li><p>参数</p><p><strong>fun</strong> – 一个函数，调用时将传入两个参数表示在画布上点击的坐标。<strong>btn</strong> – 鼠标按钮编号，默认值为 1 (鼠标左键)<strong>add</strong> – <code>True</code> 或 <code>False</code> – 如为 <code>True</code> 则将添加一个新绑定，否则将取代先前的绑定</p></li></ul><p>将 <em>fun</em> 指定的函数绑定到在此海龟上移动鼠标事件。如果 <em>fun</em> 值为 <code>None</code>，则移除现有的绑定。</p><p>注: 在海龟上移动鼠标事件之前应先发生在此海龟上点击鼠标事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; turtle.ondrag(turtle.goto)</span><br></pre></td></tr></table></figure><p>在此之后点击并拖动海龟可在屏幕上手绘线条 (如果画笔为落下)。</p></li></ul><h3 id="特殊海龟方法"><a href="#特殊海龟方法" class="headerlink" title="特殊海龟方法"></a>特殊海龟方法</h3><ul><li><p><code>turtle.begin_poly</code>()</p><p>开始记录多边形的顶点。当前海龟位置为多边形的第一个顶点。</p></li><li><p><code>turtle.end_poly</code>()</p><p>停止记录多边形的顶点。当前海龟位置为多边形的最后一个顶点。它将连线到第一个顶点。</p></li><li><p><code>turtle.get_poly</code>()</p><p>返回最新记录的多边形。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.begin_poly()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.end_poly()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = turtle.get_poly()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>register_shape(<span class="string">"myFavouriteShape"</span>, p)</span><br></pre></td></tr></table></figure></li></ul><ul><li><code>turtle.clone</code>()</li></ul><p>创建并返回海龟的克隆体，具有相同的位置、朝向和海龟属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mick = Turtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe = mick.clone()</span><br></pre></td></tr></table></figure><ul><li><p><code>turtle.getturtle</code>()</p></li><li><p><code>turtle.getpen</code>()</p></li></ul><p>返回海龟对象自身。唯一合理的用法: 作为一个函数来返回 “匿名海龟”:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pet = getturtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pet.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pet</span><br><span class="line">&lt;turtle.Turtle object at <span class="number">0</span>x...&gt;</span><br></pre></td></tr></table></figure><ul><li><code>turtle.getscreen</code>()</li></ul><p>返回作为海龟绘图场所的 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 类对象。该对象将可调用 TurtleScreen 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ts = turtle.getscreen()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ts</span><br><span class="line">&lt;turtle._Screen object at <span class="number">0</span>x...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ts.bgcolor(<span class="string">"pink"</span>)</span><br></pre></td></tr></table></figure><ul><li><p><code>turtle.setundobuffer</code>(<em>size</em>)</p><ul><li><p>参数</p><p><strong>size</strong> – 一个整型数值或 <code>None</code></p></li></ul></li></ul><p>设置或禁用撤消缓冲区。如果 <em>size</em> 为一个整型数则将开辟一个指定大小的空缓冲区。<em>size</em> 表示可使用 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.undo" target="_blank" rel="noopener"><code>undo()</code></a> 方法/函数撤消的海龟命令的次数上限。如果 <em>size</em> 为 <code>None</code> 则禁用撤消缓冲区。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setundobuffer(<span class="number">42</span>)</span><br></pre></td></tr></table></figure><ul><li><code>turtle.undobufferentries</code>()</li></ul><p>返回撤销缓冲区里的条目数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> undobufferentries():</span><br><span class="line"><span class="meta">... </span>    undo()</span><br></pre></td></tr></table></figure><h3 id="复合形状"><a href="#复合形状" class="headerlink" title="复合形状"></a>复合形状</h3><p>要使用由多个不同颜色多边形构成的复合海龟形状，你必须明确地使用辅助类 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Shape" target="_blank" rel="noopener"><code>Shape</code></a>，具体步骤如下:</p><ol><li><p>创建一个空 Shape 对象，类型为 “compound”。</p></li><li><p>按照需要使用 <code>addcomponent()</code> 方法向此对象添加多个部件。</p><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Shape(<span class="string">"compound"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>poly1 = ((<span class="number">0</span>,<span class="number">0</span>),(<span class="number">10</span>,<span class="number">-5</span>),(<span class="number">0</span>,<span class="number">10</span>),(<span class="number">-10</span>,<span class="number">-5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.addcomponent(poly1, <span class="string">"red"</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>poly2 = ((<span class="number">0</span>,<span class="number">0</span>),(<span class="number">10</span>,<span class="number">-5</span>),(<span class="number">-10</span>,<span class="number">-5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.addcomponent(poly2, <span class="string">"blue"</span>, <span class="string">"red"</span>)</span><br></pre></td></tr></table></figure></li><li><p>接下来将 Shape 对象添加到 Screen 对象的形状列表并使用它:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>register_shape(<span class="string">"myshape"</span>, s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shape(<span class="string">"myshape"</span>)</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Shape" target="_blank" rel="noopener"><code>Shape</code></a> 类在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.register_shape" target="_blank" rel="noopener"><code>register_shape()</code></a> 方法的内部以多种方式使用。应用程序编写者 <em>只有</em> 在使用上述的复合形状时才需要处理 Shape 类。</p></blockquote><h2 id="TurtleScreen-Screen-方法及对应函数"><a href="#TurtleScreen-Screen-方法及对应函数" class="headerlink" title="TurtleScreen/Screen 方法及对应函数"></a>TurtleScreen/Screen 方法及对应函数</h2><p>本节中的大部分示例都使用 TurtleScreen 类的一个实例，命名为 <code>screen</code>。</p><h3 id="窗口控制"><a href="#窗口控制" class="headerlink" title="窗口控制"></a>窗口控制</h3><ul><li><p><code>turtle.bgcolor</code>(*<em>args</em>)</p><p>参数<strong>args</strong> – 一个颜色字符串或三个取值范围 0..colormode 内的数值或一个取值范围相同的数值3元组设置或返回 TurtleScreen 的背景颜色。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgcolor()</span><br><span class="line"><span class="string">'orange'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgcolor(<span class="string">"#800080"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgcolor()</span><br><span class="line">(<span class="number">128.0</span>, <span class="number">0.0</span>, <span class="number">128.0</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>urtle.bgpic</code>(<em>picname=None</em>)</p><ul><li><p>参数</p><p><strong>picname</strong> – 一个字符串, gif-文件名, <code>&quot;nopic&quot;</code>, 或 <code>None</code></p></li></ul><p>设置背景图片或返回当前背景图片名称。如果 <em>picname</em> 为一个文件名，则将相应图片设为背景。如果 <em>picname</em> 为 <code>&quot;nopic&quot;</code>，则删除当前背景图片。如果 <em>picname</em> 为 <code>None</code>，则返回当前背景图片文件名。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgpic()</span><br><span class="line"><span class="string">'nopic'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgpic(<span class="string">"landscape.gif"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgpic()</span><br><span class="line"><span class="string">"landscape.gif"</span></span><br></pre></td></tr></table></figure></li><li><p><code>turtle.clear</code>()</p><p><code>turtle.clearscreen</code>()</p><p>从中删除所有海龟的全部绘图。将已清空的 TurtleScreen 重置为初始状态: 白色背景，无背景片，无事件绑定并启用追踪。</p><blockquote><p>此 TurtleScreen 方法作为全局函数时只有一个名字 <code>clearscreen</code>。全局函数 <code>clear</code> 所对应的是 Turtle 方法 <code>clear</code>。</p></blockquote></li><li><p><code>turtle.reset</code>()</p></li><li><p><code>turtle.resetscreen</code>()</p><p>重置屏幕上的所有海龟为其初始状态。</p></li><li><p><code>turtle.reset</code>()</p><p><code>turtle.resetscreen</code>()</p><p>重置屏幕上的所有海龟为其初始状态。</p><blockquote><p>此 TurtleScreen 方法作为全局函数时只有一个名字 <code>resetscreen</code>。全局函数 <code>reset</code> 所对应的是 Turtle 方法 <code>reset</code>。</p></blockquote></li><li><p><code>turtle.screensize</code>(<em>canvwidth=None</em>, <em>canvheight=None</em>, <em>bg=None</em>)</p><ul><li><p>参数</p><p><strong>canvwidth</strong> – 正整型数，以像素表示画布的新宽度值<strong>canvheight</strong> – 正整型数，以像素表示画面的新高度值<strong>bg</strong> – 颜色字符串或颜色元组，新的背景颜色</p></li></ul><p>如未指定任何参数，则返回当前的 (canvaswidth, canvasheight)。否则改变作为海龟绘图场所的画布大小。不改变绘图窗口。要观察画布的隐藏区域，可以使用滚动条。通过此方法可以令之前绘制于画布之外的图形变为可见。</p><p>可见。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.screensize()</span><br><span class="line">(<span class="number">400</span>, <span class="number">300</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.screensize(<span class="number">2000</span>,<span class="number">1500</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.screensize()</span><br><span class="line">(<span class="number">2000</span>, <span class="number">1500</span>)</span><br></pre></td></tr></table></figure><p>也可以用来寻找意外逃走的海龟 ;-)</p></li><li><p><code>turtle.setworldcoordinates</code>(<em>llx</em>, <em>lly</em>, <em>urx</em>, <em>ury</em>)</p><ul><li><p>参数</p><p><strong>llx</strong> – 一个数值, 画布左下角的 x-坐标</p><p><strong>lly</strong> – 一个数值, 画布左下角的 y-坐标</p><p><strong>urx</strong> – 一个数值, 画面右上角的 x-坐标</p><p><strong>ury</strong> – 一个数值, 画布右上角的 y-坐标</p></li></ul><p>设置用户自定义坐标系并在必要时切换模式为 “world”。这会执行一次 <code>screen.reset()</code>。如果 “world” 模式已激活，则所有图形将根据新的坐标系重绘。</p><p><strong>注意</strong>: 在用户自定义坐标系中，角度可能显得扭曲。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.setworldcoordinates(<span class="number">-50</span>,<span class="number">-7.5</span>,<span class="number">50</span>,<span class="number">7.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">72</span>):</span><br><span class="line"><span class="meta">... </span>    left(<span class="number">10</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line"><span class="meta">... </span>    left(<span class="number">45</span>); fd(<span class="number">2</span>)   <span class="comment"># a regular octagon</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="动画控制"><a href="#动画控制" class="headerlink" title="动画控制"></a>动画控制</h3><ul><li><p><code>turtle.delay</code>(<em>delay=None</em>)</p><ul><li><p>参数</p><p><strong>delay</strong> – 正整型数</p></li></ul><p>设置或返回以毫秒数表示的延迟值 <em>delay</em>。(这约等于连续两次画布刷新的间隔时间。) 绘图延迟越长，动画速度越慢。</p><p>可选参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.delay()</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.delay(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.delay()</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p><code>turtle.tracer</code>(<em>n=None</em>, <em>delay=None</em>)</p><p>参数<strong>n</strong> – 非负整型数<strong>delay</strong> – 非负整型数启用/禁用海龟动画并设置刷新图形的延迟时间。如果指定 <em>n</em> 值，则只有每第 n 次屏幕刷新会实际执行。(可被用来加速复杂图形的绘制。) 如果调用时不带参数，则返回当前保存的 n 值。第二个参数设置延迟值 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.delay" target="_blank" rel="noopener"><code>delay()</code></a>)。<code>&gt;&gt;&gt; screen.tracer(8, 25) &gt;&gt;&gt; dist = 2 &gt;&gt;&gt; for i in range(200): ...     fd(dist) ...     rt(90) ...     dist += 2</code></p></li><li><p><code>turtle.update</code>()</p><p>执行一次 TurtleScreen 刷新。在禁用追踪时使用。</p></li></ul><p>另参见 RawTurtle/Turtle 方法 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.speed" target="_blank" rel="noopener"><code>speed()</code></a>。</p><h3 id="使用屏幕事件"><a href="#使用屏幕事件" class="headerlink" title="使用屏幕事件"></a>使用屏幕事件</h3><ul><li><p><code>turtle.listen</code>(<em>xdummy=None</em>, <em>ydummy=None</em>)</p><p>设置焦点到 TurtleScreen (以便接收按键事件)。使用两个 Dummy 参数以便能够传递 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.listen" target="_blank" rel="noopener"><code>listen()</code></a> 给 onclick 方法。</p></li><li><p><code>turtle.onkey</code>(<em>fun</em>, <em>key</em>)</p></li><li><p><code>turtle.onkeyrelease</code>(<em>fun</em>, <em>key</em>)</p><ul><li><p>参数</p><p><strong>fun</strong> – 一个无参数的函数或 <code>None</code><strong>key</strong> – 一个字符串: 键 (例如 “a”) 或键标 (例如 “space”)</p></li></ul><p>绑定 <em>fun</em> 指定的函数到按键释放事件。如果 <em>fun</em> 值为 <code>None</code>，则移除事件绑定。注: 为了能够注册按键事件，TurtleScreen 必须得到焦点。(参见 method <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.listen" target="_blank" rel="noopener"><code>listen()</code></a> 方法。)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">... </span>    lt(<span class="number">60</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.onkey(f, <span class="string">"Up"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.listen()</span><br></pre></td></tr></table></figure></li><li><p><code>turtle.onkeypress</code>(<em>fun</em>, <em>key=None</em>)</p><ul><li><p>参数</p><p><strong>fun</strong> – 一个无参数的函数或 <code>None</code><strong>key</strong> – 一个字符串: 键 (例如 “a”) 或键标 (例如 “space”)</p></li></ul><p>绑定 <em>fun</em> 指定的函数到指定键的按下事件。如未指定键则绑定到任意键的按下事件。注: 为了能够注册按键事件，必须得到焦点。(参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.listen" target="_blank" rel="noopener"><code>listen()</code></a> 方法。)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    fd(<span class="number">50</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.onkey(f, <span class="string">"Up"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.listen()</span><br></pre></td></tr></table></figure></li><li><p><code>turtle.onclick</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p><p><code>turtle.onscreenclick</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p><ul><li><p>参数</p><p><strong>fun</strong> – 一个函数，调用时将传入两个参数表示在画布上点击的坐标。<strong>btn</strong> – 鼠标按钮编号，默认值为 1 (鼠标左键)<strong>add</strong> – <code>True</code> 或 <code>False</code> – 如为 <code>True</code> 则将添加一个新绑定，否则将取代先前的绑定</p></li></ul><p>绑定 <em>fun</em> 指定的函数到鼠标点击屏幕事件。如果 <em>fun</em> 值为 <code>None</code>，则移除现有的绑定。</p><p>以下示例使用一个 TurtleScreen 实例 <code>screen</code> 和一个 Turtle 实例 turtle:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.onclick(turtle.goto) <span class="comment"># Subsequently clicking into the TurtleScreen will</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>                            <span class="comment"># make the turtle move to the clicked point.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.onclick(<span class="literal">None</span>)        <span class="comment"># remove event binding again</span></span><br></pre></td></tr></table></figure><blockquote><p> 此 TurtleScreen 方法作为全局函数时只有一个名字 <code>onscreenclick</code>。全局函数 <code>onclick</code> 所对应的是 Turtle 方法 <code>onclick</code>。</p></blockquote></li><li><p><code>turtle.ontimer</code>(<em>fun</em>, <em>t=0</em>)</p><ul><li><p>参数</p><p><strong>fun</strong> – 一个无参数的函数<strong>t</strong> – 一个数值 &gt;= 0</p></li></ul><p>安装一个计时器，在 <em>t</em> 毫秒后调用 <em>fun</em> 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>running = <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> running:</span><br><span class="line"><span class="meta">... </span>        fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">... </span>        lt(<span class="number">60</span>)</span><br><span class="line"><span class="meta">... </span>        screen.ontimer(f, <span class="number">250</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()   <span class="comment">### makes the turtle march around</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>running = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p><code>turtle.mainloop</code>()</p><p><code>turtle.done</code>()</p><p>开始事件循环 - 调用 Tkinter 的 mainloop 函数。必须作为一个海龟绘图程序的结束语句。如果一个脚本是在以 -n 模式 (无子进程) 启动的 IDLE 中运行时 <em>不可</em> 使用 - 用于实现海龟绘图的交互功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.mainloop()</span><br></pre></td></tr></table></figure></li></ul><h3 id="输入方法"><a href="#输入方法" class="headerlink" title="输入方法"></a>输入方法</h3><ul><li><p><code>turtle.textinput</code>(<em>title</em>, <em>prompt</em>)</p><p>参数<strong>title</strong> – 字符串<strong>prompt</strong> – 字符串弹出一个对话框窗口用来输入一个字符串。形参 title 为对话框窗口的标题，prompt 为一条文本，通常用来提示要输入什么信息。返回输入的字符串。如果对话框被取消则返回 <code>None</code>。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.textinput(<span class="string">"NIM"</span>, <span class="string">"Name of first player:"</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>turtle.numinput</code>(<em>title</em>, <em>prompt</em>, <em>default=None</em>, <em>minval=None</em>, <em>maxval=None</em>)</p><ul><li><p>参数</p><p><strong>title</strong> – 字符串<strong>prompt</strong> – 字符串<strong>default</strong> – 数值 (可选)<strong>minval</strong> – 数值 (可选)<strong>maxval</strong> – 数值 (可选)</p></li></ul><p>弹出一个对话框窗口用来输入一个数值。title 为对话框窗口的标题，prompt 为一条文本，通常用来描述要输入的数值信息。default: 默认值, minval: 可输入的最小值, maxval: 可输入的最大值。输入数值的必须在指定的 minval .. maxval 范围之内，否则将给出一条提示，对话框保持打开等待修改。返回输入的数值。如果对话框被取消则返回 <code>None</code>。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.numinput(<span class="string">"Poker"</span>, <span class="string">"Your stakes:"</span>, <span class="number">1000</span>, minval=<span class="number">10</span>, maxval=<span class="number">10000</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="设置与特殊方法"><a href="#设置与特殊方法" class="headerlink" title="设置与特殊方法"></a>设置与特殊方法</h3><p><code>turtle.mode</code>(<em>mode=None</em>)</p><ul><li><p>参数</p><p><strong>mode</strong> – 字符串 “standard”, “logo” 或 “world” 其中之一</p></li></ul><p>设置海龟模式 (“standard”, “logo” 或 “world”) 并执行重置。如未指定模式则返回当前的模式。</p><p>“standard” 模式与旧的 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 兼容。”logo” 模式与大部分 Logo 海龟绘图兼容。”world” 模式使用用户自定义的 “世界坐标系”。<strong>注意</strong>: 在此模式下，如果 <code>x/y</code> 单位比率不等于 1 则角度会显得扭曲。</p><table><thead><tr><th>模式</th><th>初始海龟朝向</th><th>正数角度</th></tr></thead><tbody><tr><td>“standard”</td><td>朝右 (东)</td><td>逆时针</td></tr><tr><td>“logo”</td><td>朝上 (北)</td><td>顺时针</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mode(<span class="string">"logo"</span>)   <span class="comment"># resets turtle heading to north</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mode()</span><br><span class="line"><span class="string">'logo'</span></span><br></pre></td></tr></table></figure><p><code>turtle.colormode</code>(<em>cmode=None</em>)</p><ul><li><p>参数</p><p><strong>cmode</strong> – 数值 1.0 或 255 其中之一</p></li></ul><p>返回颜色模式或将其设为 1.0 或 255。构成颜色三元组的 <em>r</em>, <em>g</em>, <em>b</em> 数值必须在 0..<em>cmode</em> 范围之内。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.colormode(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(<span class="number">240</span>, <span class="number">160</span>, <span class="number">80</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">     ...</span><br><span class="line">TurtleGraphicsError: bad color sequence: (<span class="number">240</span>, <span class="number">160</span>, <span class="number">80</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.colormode()</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.colormode(<span class="number">255</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.colormode()</span><br><span class="line"><span class="number">255</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(<span class="number">240</span>,<span class="number">160</span>,<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.getcanvas</code>()</p><p>返回此 TurtleScreen 的 Canvas 对象。供了解 Tkinter 的 Canvas 对象内部机理的人士使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv = screen.getcanvas()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv</span><br><span class="line">&lt;turtle.ScrolledCanvas object ...&gt;</span><br></pre></td></tr></table></figure><p><code>turtle.getshapes</code>()</p><p>返回所有当前可用海龟形状的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.getshapes()</span><br><span class="line">[<span class="string">'arrow'</span>, <span class="string">'blank'</span>, <span class="string">'circle'</span>, ..., <span class="string">'turtle'</span>]</span><br></pre></td></tr></table></figure><p><code>turtle.register_shape</code>(<em>name</em>, <em>shape=None</em>)</p><p><code>turtle.addshape</code>(<em>name</em>, <em>shape=None</em>)</p><p>调用此函数有三种不同方式:</p><ol><li><p><em>name</em> 为一个 gif 文件的文件名， <em>shape</em> 为 <code>None</code>: 安装相应的图像形状。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.register_shape(<span class="string">"turtle.gif"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>当海龟转向时图像形状 <em>不会</em> 转动，因此无法显示海龟的朝向!</p></blockquote></li><li><p><em>name</em> 为指定的字符串，<em>shape</em> 为由坐标值对构成的元组: 安装相应的多边形形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.register_shape(<span class="string">"triangle"</span>, ((<span class="number">5</span>,<span class="number">-3</span>), (<span class="number">0</span>,<span class="number">5</span>), (<span class="number">-5</span>,<span class="number">-3</span>)))</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><em>name</em> 为指定的字符串， 为一个 (复合) <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Shape" target="_blank" rel="noopener"><code>Shape</code></a> 类对象: 安装相应的复合形状。</li></ol><p>将一个海龟形状加入 TurtleScreen 的形状列表。只有这样注册过的形状才能通过执行 <code>shape(shapename)</code> 命令来使用。</p><p><code>turtle.turtles</code>()</p><p>返回屏幕上的海龟列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> turtle <span class="keyword">in</span> screen.turtles():</span><br><span class="line"><span class="meta">... </span>    turtle.color(<span class="string">"red"</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.window_height</code>()</p><p>返回海龟窗口的高度。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.window_height()</span><br><span class="line"><span class="number">480</span></span><br></pre></td></tr></table></figure><p><code>turtle.window_width</code>()</p><p>返回海龟窗口的宽度。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.window_width()</span><br><span class="line"><span class="number">640</span></span><br></pre></td></tr></table></figure><h3 id="Screen-专有方法-而非继承自-TurtleScreen"><a href="#Screen-专有方法-而非继承自-TurtleScreen" class="headerlink" title="Screen 专有方法, 而非继承自 TurtleScreen"></a>Screen 专有方法, 而非继承自 TurtleScreen</h3><ul><li><p><code>turtle.bye</code>()</p><p>关闭海龟绘图窗口。</p></li><li><p><code>turtle.exitonclick</code>()</p><p>将 bye() 方法绑定到 Screen 上的鼠标点击事件。如果配置字典中 “using_IDLE” 的值为 <code>False</code> (默认值) 则同时进入主事件循环。注: 如果启动 IDLE 时使用了 <code>-n</code> 开关 (无子进程)，<code>turtle.cfg</code> 中此数值应设为 <code>True</code>。在此情况下 IDLE 本身的主事件循环同样会作用于客户脚本。</p></li><li><p><code>turtle.setup</code>(<em>width=_CFG[“width”], height=_CFG[“height”], startx=_CFG[“leftright”], starty=_CFG[“topbottom”]</em>)</p><p>设置主窗口的大小和位置。默认参数值保存在配置字典中，可通过 <code>turtle.cfg</code> 文件进行修改。</p><ul><li><strong>width</strong> – 如为一个整型数值，表示大小为多少像素，如为一个浮点数值，则表示屏幕的占比；默认为屏幕的 50%</li><li><strong>height</strong> – 如为一个整型数值，表示高度为多少像素，如为一个浮点数值，则表示屏幕的占比；默认为屏幕的 75%</li><li><strong>startx</strong> – 如为正值，表示初始位置距离屏幕左边缘多少像素，负值表示距离右边缘，<code>None</code> 表示窗口水平居中</li><li><strong>starty</strong> – 如为正值，表示初始位置距离屏幕上边缘多少像素，负值表示距离下边缘，<code>None</code> 表示窗口垂直居中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.setup (width=<span class="number">200</span>, height=<span class="number">200</span>, startx=<span class="number">0</span>, starty=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>             <span class="comment"># sets window to 200x200 pixels, in upper left of screen</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.setup(width=<span class="number">.75</span>, height=<span class="number">0.5</span>, startx=<span class="literal">None</span>, starty=<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>             <span class="comment"># sets window to 75% of screen by 50% of screen and centers</span></span><br></pre></td></tr></table></figure></li></ul><p><code>turtle.title</code>(<em>titlestring</em>)</p><ul><li><p>参数</p><p><strong>titlestring</strong> – 一个字符串，显示为海龟绘图窗口的标题栏文本</p></li></ul><p>设置海龟窗口标题为 <em>titlestring</em> 指定的文本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.title(<span class="string">"Welcome to the turtle zoo!"</span>)</span><br></pre></td></tr></table></figure><h2 id="公共类"><a href="#公共类" class="headerlink" title="公共类"></a>公共类</h2><ul><li><p><em>class</em> <code>turtle.RawTurtle</code>(<em>canvas</em>)</p></li><li><p><em>class</em> <code>turtle.RawPen</code>(<em>canvas</em>)</p><p>参数<strong>canvas</strong> – 一个 <code>tkinter.Canvas</code> , <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ScrolledCanvas" target="_blank" rel="noopener"><code>ScrolledCanvas</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 类对象创建一个海龟。海龟对象具有 “Turtle/RawTurtle 方法” 一节所述的全部方法。</p></li><li><p><em>class</em> <code>turtle.Turtle</code></p><p>RawTurtle 的子类，具有相同的接口，但其绘图场所为默认的 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Screen" target="_blank" rel="noopener"><code>Screen</code></a> 类对象，在首次使用时自动创建。</p></li><li><p><em>class</em> <code>turtle.TurtleScreen</code>(<em>cv</em>)</p><p>参数<strong>cv</strong> – 一个 <code>tkinter.Canvas</code> 类对象提供面向屏幕的方法例如 <code>setbg()</code> 等。说明见上文。</p></li><li><p><em>class</em> <code>turtle.Screen</code></p><p>TurtleScreen 的子类，<a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#screenspecific" target="_blank" rel="noopener">增加了四个方法</a>.</p></li><li><p><em>class</em> <code>turtle.ScrolledCanvas</code>(<em>master</em>)</p><p>参数<strong>master</strong> – 可容纳 ScrolledCanvas 的 Tkinter 部件，即添加了滚动条的 Tkinter-canvas由 Screen 类使用，使其能够自动提供一个 ScrolledCanvas 作为海龟的绘图场所。</p></li><li><p><em>class</em> <code>turtle.Shape</code>(<em>type_</em>, <em>data</em>)</p><p>参数<strong>type_</strong> – 字符串 “polygon”, “image”, “compound” 其中之一实现形状的数据结构。<code>(type_, data)</code> 必须遵循以下定义:</p><p>| <em>type_</em>    | <em>data</em>                                                       |<br>| ———- | ———————————————————— |<br>| “polygon”  | 一个多边形元组，即由坐标值对构成的元组                       |<br>| “image”    | 一个图片 (此形式仅限内部使用!)                               |<br>| “compound” | <code>None</code> (复合形状必须使用 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Shape.addcomponent" target="_blank" rel="noopener"><code>addcomponent()</code></a> 方法来构建) |</p></li><li><p><code>addcomponent</code>(<em>poly</em>, <em>fill</em>, <em>outline=None</em>)</p><ul><li><p><strong>poly</strong> – 一个多边形，即由数值对构成的元组</p></li><li><p><strong>fill</strong> – 一种颜色，将用来填充 <em>poly</em> 指定的多边形</p></li><li><p><strong>outline</strong> – 一种颜色，用于多边形的轮廓 (如有指定)</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>poly = ((<span class="number">0</span>,<span class="number">0</span>),(<span class="number">10</span>,<span class="number">-5</span>),(<span class="number">0</span>,<span class="number">10</span>),(<span class="number">-10</span>,<span class="number">-5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Shape(<span class="string">"compound"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.addcomponent(poly, <span class="string">"red"</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># ... add more components and then use register_shape()</span></span><br></pre></td></tr></table></figure><p>参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#compoundshapes" target="_blank" rel="noopener">复合形状</a>。<em>**</em></p></li></ul></li><li><p><em>class</em> <code>turtle.Vec2D</code>(<em>x</em>, <em>y</em>)</p><p>一个二维矢量类，用来作为实现海龟绘图的辅助类。也可能在海龟绘图程序中使用。派生自元组，因此矢量也属于元组!</p><p>提供的运算 (<em>a</em>, <em>b</em> 为矢量, <em>k</em> 为数值):</p><ul><li><code>a + b</code> 矢量加法</li><li><code>a - b</code> 矢量减法</li><li><code>a * b</code> 内积</li><li><code>k * a</code> 和 <code>a * k</code> 与标量相乘</li><li><code>abs(a)</code> a 的绝对值</li><li><code>a.rotate(angle)</code> 旋转</li></ul></li></ul><h2 id="帮助与配置"><a href="#帮助与配置" class="headerlink" title="帮助与配置"></a>帮助与配置</h2><h3 id="如何使用帮助"><a href="#如何使用帮助" class="headerlink" title="如何使用帮助"></a>如何使用帮助</h3><p>Screen 和 Turtle 类的公用方法以文档字符串提供了详细的文档。因此可以利用 Python 帮助工具获取这些在线帮助信息:</p><ul><li><p>当使用 IDLE 时，输入函数/方法调用将弹出工具提示显示其签名和文档字符串的头几行。</p></li><li><p>对文法或函数调用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#help" target="_blank" rel="noopener"><code>help()</code></a> 将显示其文档字符串:</p><p>>&gt;&gt;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(Screen.bgcolor)</span><br><span class="line">Help on method bgcolor <span class="keyword">in</span> module turtle:</span><br><span class="line"></span><br><span class="line">bgcolor(self, *args) unbound turtle.Screen method</span><br><span class="line">    Set <span class="keyword">or</span> <span class="keyword">return</span> backgroundcolor of the TurtleScreen.</span><br><span class="line"></span><br><span class="line">    Arguments (<span class="keyword">if</span> given): a color string <span class="keyword">or</span> three numbers</span><br><span class="line">    <span class="keyword">in</span> the range <span class="number">0.</span>.colormode <span class="keyword">or</span> a <span class="number">3</span>-tuple of such numbers.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &gt;&gt;&gt; screen.bgcolor(<span class="string">"orange"</span>)</span><br><span class="line">      &gt;&gt;&gt; screen.bgcolor()</span><br><span class="line">      <span class="string">"orange"</span></span><br><span class="line">      &gt;&gt;&gt; screen.bgcolor(<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">0.5</span>)</span><br><span class="line">      &gt;&gt;&gt; screen.bgcolor()</span><br><span class="line">      <span class="string">"#800080"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(Turtle.penup)</span><br><span class="line">Help on method penup <span class="keyword">in</span> module turtle:</span><br><span class="line"></span><br><span class="line">penup(self) unbound turtle.Turtle method</span><br><span class="line">    Pull the pen up -- no drawing when moving.</span><br><span class="line"></span><br><span class="line">    Aliases: penup | pu | up</span><br><span class="line"></span><br><span class="line">    No argument</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; turtle.penup()</span><br></pre></td></tr></table></figure></li></ul><p>方法对应函数的文档字符串的形式会有一些修改:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(bgcolor)</span><br><span class="line">Help on function bgcolor <span class="keyword">in</span> module turtle:</span><br><span class="line"></span><br><span class="line">bgcolor(*args)</span><br><span class="line">    Set <span class="keyword">or</span> <span class="keyword">return</span> backgroundcolor of the TurtleScreen.</span><br><span class="line"></span><br><span class="line">    Arguments (<span class="keyword">if</span> given): a color string <span class="keyword">or</span> three numbers</span><br><span class="line">    <span class="keyword">in</span> the range <span class="number">0.</span>.colormode <span class="keyword">or</span> a <span class="number">3</span>-tuple of such numbers.</span><br><span class="line"></span><br><span class="line">    Example::</span><br><span class="line"></span><br><span class="line">      &gt;&gt;&gt; bgcolor(<span class="string">"orange"</span>)</span><br><span class="line">      &gt;&gt;&gt; bgcolor()</span><br><span class="line">      <span class="string">"orange"</span></span><br><span class="line">      &gt;&gt;&gt; bgcolor(<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">0.5</span>)</span><br><span class="line">      &gt;&gt;&gt; bgcolor()</span><br><span class="line">      <span class="string">"#800080"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(penup)</span><br><span class="line">Help on function penup <span class="keyword">in</span> module turtle:</span><br><span class="line"></span><br><span class="line">penup()</span><br><span class="line">    Pull the pen up -- no drawing when moving.</span><br><span class="line"></span><br><span class="line">    Aliases: penup | pu | up</span><br><span class="line"></span><br><span class="line">    No argument</span><br><span class="line"></span><br><span class="line">    Example:</span><br><span class="line">    &gt;&gt;&gt; penup()</span><br></pre></td></tr></table></figure><p>这些修改版文档字符串是在导入时与方法对应函数的定义一起自动生成的。</p><h3 id="文档字符串翻译为不同的语言"><a href="#文档字符串翻译为不同的语言" class="headerlink" title="文档字符串翻译为不同的语言"></a>文档字符串翻译为不同的语言</h3><p>可使用工具创建一个字典，键为方法名，值为 Screen 和 Turtle 类公共方法的文档字符串。</p><ul><li><p><code>turtle.write_docstringdict</code>(<em>filename=”turtle_docstringdict”</em>)</p><p>参数<strong>filename</strong> – 一个字符串，表示文件名创建文档字符串字典并将其写入 filename 指定的 Python 脚本文件。此函数必须显示地调用 (海龟绘图类并不使用此函数)。文档字符串字典将被写入到 Python 脚本文件 <code>*filename*.py</code>。该文件可作为模板用来将文档字符串翻译为不同语言。</p></li></ul><p>如果你 (或你的学生) 想使用本国语言版本的 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 在线帮助，你必须翻译文档字符串并保存结果文件，例如 <code>turtle_docstringdict_german.py</code>.</p><p>如果你在 <code>turtle.cfg</code> 文件中加入了相应的条目，此字典将在导入模块时被读取并替代原有的英文版文档字符串。</p><p>在撰写本文档时已经有了德语和意大利语版的文档字符串字典。(更多需求请联系 <a href="mailto:glingl%40aon.at" target="_blank" rel="noopener">glingl@aon.at</a>)</p><h3 id="如何配置-Screen-和-Turtle"><a href="#如何配置-Screen-和-Turtle" class="headerlink" title="如何配置 Screen 和 Turtle"></a>如何配置 Screen 和 Turtle</h3><p>内置的默认配置是模仿旧 turtle 模块的外观和行为，以便尽可能地与其保持兼容。</p><p>如果你想使用不同的配置，以便更好地反映此模块的特性或是更适合你的需求，例如在课堂中使用，你可以准备一个配置文件 <code>turtle.cfg</code>，该文件将在导入模块时被读取并根据其中的设定修改模块配置。</p><p>内置的配置对应以下的 turtle.cfg:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">width = <span class="number">0.5</span></span><br><span class="line">height = <span class="number">0.75</span></span><br><span class="line">leftright = <span class="literal">None</span></span><br><span class="line">topbottom = <span class="literal">None</span></span><br><span class="line">canvwidth = <span class="number">400</span></span><br><span class="line">canvheight = <span class="number">300</span></span><br><span class="line">mode = standard</span><br><span class="line">colormode = <span class="number">1.0</span></span><br><span class="line">delay = <span class="number">10</span></span><br><span class="line">undobuffersize = <span class="number">1000</span></span><br><span class="line">shape = classic</span><br><span class="line">pencolor = black</span><br><span class="line">fillcolor = black</span><br><span class="line">resizemode = noresize</span><br><span class="line">visible = <span class="literal">True</span></span><br><span class="line">language = english</span><br><span class="line">exampleturtle = turtle</span><br><span class="line">examplescreen = screen</span><br><span class="line">title = Python Turtle Graphics</span><br><span class="line">using_IDLE = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>选定条目的简短说明:</p><ul><li>开头的四行对应 <code>Screen.setup()</code> 方法的参数。</li><li>第 5 和 6 行对应 <code>Screen.screensize()</code> 方法的参数。</li><li><em>shape</em> 可以是任何内置形状，即: arrow, turtle 等。更多信息可用 <code>help(shape)</code> 查看。</li><li>如果你想使用无填充色 (即令海龟变透明)，你必须写 <code>fillcolor = &quot;&quot;</code> (但 cfg 文件中所有非空字符串都不可加引号)。</li><li>如果你想令海龟反映其状态，你必须使用 <code>resizemode = auto</code>。</li><li>如果你设置语言例如 <code>language = italian</code> 则文档字符串字典 <code>turtle_docstringdict_italian.py</code> 将在导入模块时被加载 (如果导入路径即 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 的目录中存在此文件。</li><li><em>exampleturtle</em> 和 <em>examplescreen</em> 条目定义了相应对象在文档字符串中显示的名称。方法文档字符串转换为函数文档字符串时将从文档字符串中删去这些名称。</li><li><em>using_IDLE</em>: 如果你经常使用 IDLE 并启用其 -n 开关 (“无子进程”) 则应将此项设为 <code>True</code>，这将阻止 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.exitonclick" target="_blank" rel="noopener"><code>exitonclick()</code></a> 进入主事件循环。</li></ul><p><code>turtle.cfg</code> 文件可以保存于 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 所在目录，当前工作目录也可以有一个同名文件。后者会重载覆盖前者的设置。</p><p><code>Lib/turtledemo</code> 目录中也有一个 <code>turtle.cfg</code> 文件。你可以将其作为示例进行研究，并在运行演示时查看其作用效果 (但最好不要在演示查看器中运行)。</p><h2 id="turtledemo-—-演示脚本集"><a href="#turtledemo-—-演示脚本集" class="headerlink" title="turtledemo — 演示脚本集"></a><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtledemo" target="_blank" rel="noopener"><code>turtledemo</code></a> — 演示脚本集</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtledemo" target="_blank" rel="noopener"><code>turtledemo</code></a> 包汇集了一组演示脚本。这些脚本可以通过以下命令打开所提供的演示查看器运行和查看:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m turtledemo</span><br></pre></td></tr></table></figure><p>此外，你也可以单独运行其中的演示脚本。例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m turtledemo.bytedesign</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtledemo" target="_blank" rel="noopener"><code>turtledemo</code></a> 包目录中的内容:</p><ul><li>一个演示查看器 <code>__main__.py</code>，可用来查看脚本的源码并即时运行。</li><li>多个脚本文件，演示 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 模块的不同特性。所有示例可通过 Examples 菜单打开。也可以单独运行每个脚本。</li><li>一个 <code>turtle.cfg</code> 文件，作为说明如何编写并使用模块配置文件的示例模板。</li></ul><p>演示脚本清单如下:</p><table><thead><tr><th>名称</th><th>描述</th><th>相关特性</th></tr></thead><tbody><tr><td>bytedesign</td><td>复杂的传统海龟绘图模式</td><td><code>tracer()</code>, delay, <code>update()</code></td></tr><tr><td>chaos</td><td>绘制 Verhulst 动态模型，演示通过计算机的运算可能会生成令人惊叹的结果</td><td>世界坐标系</td></tr><tr><td>clock</td><td>绘制模拟时钟显示本机的当前时间</td><td>海龟作为表针, ontimer</td></tr><tr><td>colormixer</td><td>试验 r, g, b 颜色模式</td><td><code>ondrag()</code> 当鼠标拖动</td></tr><tr><td>forest</td><td>绘制 3 棵广度优先树</td><td>随机化</td></tr><tr><td>fractalcurves</td><td>绘制 Hilbert &amp; Koch 曲线</td><td>递归</td></tr><tr><td>lindenmayer</td><td>文化数学 (印度装饰艺术)</td><td>L-系统</td></tr><tr><td>minimal_hanoi</td><td>汉诺塔</td><td>矩形海龟作为汉诺盘 (shape, shapesize)</td></tr><tr><td>nim</td><td>玩经典的“尼姆”游戏，开始时有三堆小棒，与电脑对战。</td><td>海龟作为小棒，事件驱动 (鼠标, 键盘)</td></tr><tr><td>paint</td><td>超极简主义绘画程序</td><td><code>onclick()</code> 当鼠标点击</td></tr><tr><td>peace</td><td>初级技巧</td><td>海龟: 外观与动画</td></tr><tr><td>penrose</td><td>非周期性地使用风筝和飞镖形状铺满平面</td><td><code>stamp()</code> 印章</td></tr><tr><td>planet_and_moon</td><td>模拟引力系统</td><td>复合开关, <code>Vec2D</code> 类</td></tr><tr><td>round_dance</td><td>两两相对并不断旋转舞蹈的海龟</td><td>复合形状, clone shapesize, tilt, get_shapepoly, update</td></tr><tr><td>sorting_animate</td><td>动态演示不同的排序方法</td><td>简单对齐, 随机化</td></tr><tr><td>tree</td><td>一棵 (图形化的) 广度优先树 (使用生成器)</td><td><code>clone()</code> 克隆</td></tr><tr><td>two_canvases</td><td>简单设计</td><td>两块画布上的海龟</td></tr><tr><td>wikipedia</td><td>一个来自介绍海龟绘图的维基百科文章的图案</td><td><code>clone()</code>, <code>undo()</code></td></tr><tr><td>yinyang</td><td>另一个初级示例</td><td><code>circle()</code> 画圆</td></tr></tbody></table><p>祝你玩得开心！</p><h2 id="Python-2-6-之后的变化"><a href="#Python-2-6-之后的变化" class="headerlink" title="Python 2.6 之后的变化"></a>Python 2.6 之后的变化</h2><ul><li><code>Turtle.tracer()</code>, <code>Turtle.window_width()</code> 和 <code>Turtle.window_height()</code> 方法已被去除。具有这些名称和功能的方法现在只限于 <code>Screen</code> 类的方法。但其对应的函数仍然可用。(实际上在 Python 2.6 中这些方法就已经只是从对应的 <code>TurtleScreen</code>/<code>Screen</code> 类的方法复制而来。)</li><li><code>Turtle.fill()</code> 方法已被去除。<code>begin_fill()</code> 和 <code>end_fill()</code> 的行为则有细微改变: 现在每个填充过程必须以一个 <code>end_fill()</code> 调用来结束。</li><li>新增了一个 <code>Turtle.filling()</code> 方法。该方法返回一个布尔值: 如果填充过程正在进行为 <code>True</code>，否则为 <code>False</code>。此行为相当于 Python 2.6 中不带参数的 <code>fill()</code> 调用。</li></ul><h2 id="Python-3-0-之后的变化"><a href="#Python-3-0-之后的变化" class="headerlink" title="Python 3.0 之后的变化"></a>Python 3.0 之后的变化</h2><ul><li>新增了 <code>Turtle.shearfactor()</code>, <code>Turtle.shapetransform()</code> 和 <code>Turtle.get_shapepoly()</code> 方法。这样就可以使用所有标准线性变换来调整海龟形状。<code>Turtle.tiltangle()</code> 的功能已被加强: 现在可被用来获取或设置倾角。<code>Turtle.settiltangle()</code> 已弃用。</li><li>新增了 <code>Screen.onkeypress()</code> 方法作为对 <code>Screen.onkey()</code> 的补充，实际就是将行为绑定到 keyrelease 事件。后者相应增加了一个别名: <code>Screen.onkeyrelease()</code>。</li><li>新增了 <code>Screen.mainloop()</code> 方法。这样当仅需使用 Screen 和 Turtle 对象时不需要再额外导入 <code>mainloop()</code>。</li><li>新增了两个方法 <code>Screen.textinput()</code> 和 <code>Screen.numinput()</code>。用来弹出对话框接受输入并分别返回字符串和数值。</li><li>两个新的示例脚本 <code>tdemo_nim.py</code> 和 <code>tdemo_round_dance.py</code> 被加入到 <code>Lib/turtledemo</code> 目录中。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-turtle-海龟制图-续&quot;&gt;&lt;a href=&quot;#python-标准库-turtle-海龟制图-续&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 turtle 海龟制图(续)&quot;&gt;&lt;/a&gt;python 标准库 turtle 海龟制图(续)&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/2020200228english.png?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="turtle" scheme="https://pinghailinfeng.gitee.io/tags/turtle/"/>
    
  </entry>
  
  <entry>
    <title>python standard library turtle</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/27/python-standard-library-turtle/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/27/python-standard-library-turtle/</id>
    <published>2020-02-27T11:55:25.000Z</published>
    <updated>2020-02-28T11:30:50.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-turtle-海龟制图"><a href="#python-标准库-turtle-海龟制图" class="headerlink" title="python 标准库 turtle 海龟制图"></a>python 标准库 turtle 海龟制图</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200227turtle.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>turtle n  海龟</p><p>vi. 捕海龟，捕鳖； （船等）翻没，倾覆；</p></blockquote><p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/turtle.py" target="_blank" rel="noopener">Lib/turtle.py</a></p><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>海龟绘图很适合用来引导孩子学习编程。 最初来自于 Wally Feurzeig, Seymour Papert 和 Cynthia Solomon 于 1967 年所创造的 Logo 编程语言。</p><p>请想象绘图区有一只机器海龟，起始位置在 x-y 平面的 (0, 0) 点。先执行 <code>import turtle</code>，再执行 <code>turtle.forward(15)</code>，它将(在屏幕上)朝所面对的 x 轴正方向前进 15 像素，随着它的移动画出一条线段。再执行 <code>turtle.right(25)</code>，它将原地右转 25 度。</p><p>通过组合使用此类命令，可以轻松地绘制出精美的形状和图案。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 模块是基于 Python 标准发行版 2.5 以来的同名模块重新编写并进行了功能扩展。</p><p>新模块尽量保持了原模块的特点，并且(几乎)100%与其兼容。这就意味着初学编程者能够以交互方式使用模块的所有命令、类和方法——运行 IDLE 时注意加 <code>-n</code> 参数。</p><p>turtle 模块提供面向对象和面向过程两种形式的海龟绘图基本组件。由于它使用 <a href="https://docs.python.org/zh-cn/3.8/library/tkinter.html#module-tkinter" target="_blank" rel="noopener"><code>tkinter</code></a> 实现基本图形界面，因此需要安装了 Tk 支持的 Python 版本。</p><p>面向对象的接口主要使用“2+2”个类：</p><ol><li><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 类定义图形窗口作为绘图海龟的运动场。它的构造器需要一个 <code>tkinter.Canvas</code> 或 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ScrolledCanvas" target="_blank" rel="noopener"><code>ScrolledCanvas</code></a> 作为参数。应在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 作为某个程序的一部分的时候使用。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Screen" target="_blank" rel="noopener"><code>Screen()</code></a> 函数返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 子类的单例对象。此函数应在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 作为独立绘图工具时使用。作为一个单例对象，其所属的类是不可被继承的。</p><p>TurtleScreen/Screen 的所有方法还存在对应的函数，即作为面向过程的接口组成部分。</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.RawTurtle" target="_blank" rel="noopener"><code>RawTurtle</code></a> (别名: <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.RawPen" target="_blank" rel="noopener"><code>RawPen</code></a>) 类定义海龟对象在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 上绘图。它的构造器需要一个 Canvas, ScrolledCanvas 或 TurtleScreen 作为参数，以指定 RawTurtle 对象在哪里绘图。</p><p>从 RawTurtle 派生出子类 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Turtle" target="_blank" rel="noopener"><code>Turtle</code></a> (别名: <code>Pen</code>)，该类对象在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Screen" target="_blank" rel="noopener"><code>Screen</code></a> 实例上绘图，如果实例不存在则会自动创建。</p><p>RawTurtle/Turtle 的所有方法也存在对应的函数，即作为面向过程的接口组成部分。</p></li></ol><p>过程式接口提供与 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Screen" target="_blank" rel="noopener"><code>Screen</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Turtle" target="_blank" rel="noopener"><code>Turtle</code></a> 类的方法相对应的函数。函数名与对应的方法名相同。当 Screen 类的方法对应函数被调用时会自动创建一个 Screen 对象。当 Turtle 类的方法对应函数被调用时会自动创建一个 (匿名的) Turtle 对象。</p><p>如果屏幕上需要有多个海龟，就必须使用面向对象的接口。</p><h2 id="可用的-Turtle-和-Screen-方法概览"><a href="#可用的-Turtle-和-Screen-方法概览" class="headerlink" title="可用的 Turtle 和 Screen 方法概览"></a>可用的 Turtle 和 Screen 方法概览</h2><h3 id="Turtle-方法"><a href="#Turtle-方法" class="headerlink" title="Turtle 方法"></a>Turtle 方法</h3><p>海龟动作</p><ul><li><p>移动和绘制</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.forward" target="_blank" rel="noopener"><code>forward()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.fd" target="_blank" rel="noopener"><code>fd()</code></a> 前进</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.backward" target="_blank" rel="noopener"><code>backward()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.bk" target="_blank" rel="noopener"><code>bk()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.back" target="_blank" rel="noopener"><code>back()</code></a> 后退</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.right" target="_blank" rel="noopener"><code>right()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.rt" target="_blank" rel="noopener"><code>rt()</code></a> 右转</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.left" target="_blank" rel="noopener"><code>left()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.lt" target="_blank" rel="noopener"><code>lt()</code></a> 左转</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.goto" target="_blank" rel="noopener"><code>goto()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setpos" target="_blank" rel="noopener"><code>setpos()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setposition" target="_blank" rel="noopener"><code>setposition()</code></a> 前往/定位</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setx" target="_blank" rel="noopener"><code>setx()</code></a> 设置x坐标</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.sety" target="_blank" rel="noopener"><code>sety()</code></a> 设置y坐标</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setheading" target="_blank" rel="noopener"><code>setheading()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.seth" target="_blank" rel="noopener"><code>seth()</code></a> 设置朝向</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.home" target="_blank" rel="noopener"><code>home()</code></a> 返回原点</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.circle" target="_blank" rel="noopener"><code>circle()</code></a> 画圆</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.dot" target="_blank" rel="noopener"><code>dot()</code></a> 画点</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.stamp" target="_blank" rel="noopener"><code>stamp()</code></a> 印章</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clearstamp" target="_blank" rel="noopener"><code>clearstamp()</code></a> 清除印章</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clearstamps" target="_blank" rel="noopener"><code>clearstamps()</code></a> 清除多个印章</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.undo" target="_blank" rel="noopener"><code>undo()</code></a> 撤消</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.speed" target="_blank" rel="noopener"><code>speed()</code></a> 速度</p></li><li><p>获取海龟的状态</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.position" target="_blank" rel="noopener"><code>position()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pos" target="_blank" rel="noopener"><code>pos()</code></a> 位置</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.towards" target="_blank" rel="noopener"><code>towards()</code></a> 目标方向</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.xcor" target="_blank" rel="noopener"><code>xcor()</code></a> x坐标</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ycor" target="_blank" rel="noopener"><code>ycor()</code></a> y坐标</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.heading" target="_blank" rel="noopener"><code>heading()</code></a> 朝向</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.distance" target="_blank" rel="noopener"><code>distance()</code></a> 距离</p></li><li><p>设置与度量单位</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.degrees" target="_blank" rel="noopener"><code>degrees()</code></a> 角度</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.radians" target="_blank" rel="noopener"><code>radians()</code></a> 弧度</p></li></ul><p>画笔控制</p><ul><li><p>绘图状态</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pendown" target="_blank" rel="noopener"><code>pendown()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pd" target="_blank" rel="noopener"><code>pd()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.down" target="_blank" rel="noopener"><code>down()</code></a> 画笔落下</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.penup" target="_blank" rel="noopener"><code>penup()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pu" target="_blank" rel="noopener"><code>pu()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.up" target="_blank" rel="noopener"><code>up()</code></a> 画笔抬起</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pensize" target="_blank" rel="noopener"><code>pensize()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.width" target="_blank" rel="noopener"><code>width()</code></a> 画笔粗细</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pen" target="_blank" rel="noopener"><code>pen()</code></a> 画笔</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.isdown" target="_blank" rel="noopener"><code>isdown()</code></a> 画笔是否落下</p></li><li><p>颜色控制</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.color" target="_blank" rel="noopener"><code>color()</code></a> 颜色</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pencolor" target="_blank" rel="noopener"><code>pencolor()</code></a> 画笔颜色</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.fillcolor" target="_blank" rel="noopener"><code>fillcolor()</code></a> 填充颜色</p></li><li><p>填充</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.filling" target="_blank" rel="noopener"><code>filling()</code></a> 是否填充</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.begin_fill" target="_blank" rel="noopener"><code>begin_fill()</code></a> 开始填充</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.end_fill" target="_blank" rel="noopener"><code>end_fill()</code></a> 结束填充</p></li><li><p>更多绘图控制</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.reset" target="_blank" rel="noopener"><code>reset()</code></a> 重置</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clear" target="_blank" rel="noopener"><code>clear()</code></a> 清空</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.write" target="_blank" rel="noopener"><code>write()</code></a> 书写</p></li></ul><p>海龟状态</p><ul><li><p>可见性</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.showturtle" target="_blank" rel="noopener"><code>showturtle()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.st" target="_blank" rel="noopener"><code>st()</code></a> 显示海龟</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.hideturtle" target="_blank" rel="noopener"><code>hideturtle()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ht" target="_blank" rel="noopener"><code>ht()</code></a> 隐藏海龟</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.isvisible" target="_blank" rel="noopener"><code>isvisible()</code></a> 是否可见</p></li><li><p>外观</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shape" target="_blank" rel="noopener"><code>shape()</code></a> 形状</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.resizemode" target="_blank" rel="noopener"><code>resizemode()</code></a> 大小调整模式</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shapesize" target="_blank" rel="noopener"><code>shapesize()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.turtlesize" target="_blank" rel="noopener"><code>turtlesize()</code></a> 形状大小</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shearfactor" target="_blank" rel="noopener"><code>shearfactor()</code></a> 剪切因子</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.settiltangle" target="_blank" rel="noopener"><code>settiltangle()</code></a> 设置倾角</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.tiltangle" target="_blank" rel="noopener"><code>tiltangle()</code></a> 倾角</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.tilt" target="_blank" rel="noopener"><code>tilt()</code></a> 倾斜</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shapetransform" target="_blank" rel="noopener"><code>shapetransform()</code></a> 变形</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.get_shapepoly" target="_blank" rel="noopener"><code>get_shapepoly()</code></a> 获取形状多边形</p></li></ul><p>使用事件</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onclick" target="_blank" rel="noopener"><code>onclick()</code></a> 当鼠标点击</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onrelease" target="_blank" rel="noopener"><code>onrelease()</code></a> 当鼠标释放</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ondrag" target="_blank" rel="noopener"><code>ondrag()</code></a> 当鼠标拖动</p><p>特殊海龟方法</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.begin_poly" target="_blank" rel="noopener"><code>begin_poly()</code></a> 开始记录多边形</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.end_poly" target="_blank" rel="noopener"><code>end_poly()</code></a> 结束记录多边形</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.get_poly" target="_blank" rel="noopener"><code>get_poly()</code></a> 获取多边形</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clone" target="_blank" rel="noopener"><code>clone()</code></a> 克隆</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getturtle" target="_blank" rel="noopener"><code>getturtle()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getpen" target="_blank" rel="noopener"><code>getpen()</code></a> 获取海龟画笔</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getscreen" target="_blank" rel="noopener"><code>getscreen()</code></a> 获取屏幕</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setundobuffer" target="_blank" rel="noopener"><code>setundobuffer()</code></a> 设置撤消缓冲区</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.undobufferentries" target="_blank" rel="noopener"><code>undobufferentries()</code></a> 撤消缓冲区条目数</p><h3 id="TurtleScreen-Screen-方法"><a href="#TurtleScreen-Screen-方法" class="headerlink" title="TurtleScreen/Screen 方法"></a>TurtleScreen/Screen 方法</h3><ul><li><p>窗口控制</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.bgcolor" target="_blank" rel="noopener"><code>bgcolor()</code></a> 背景颜色</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.bgpic" target="_blank" rel="noopener"><code>bgpic()</code></a> 背景图片</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clear" target="_blank" rel="noopener"><code>clear()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clearscreen" target="_blank" rel="noopener"><code>clearscreen()</code></a> 清屏</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.reset" target="_blank" rel="noopener"><code>reset()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.resetscreen" target="_blank" rel="noopener"><code>resetscreen()</code></a> 重置</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.screensize" target="_blank" rel="noopener"><code>screensize()</code></a> 屏幕大小</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setworldcoordinates" target="_blank" rel="noopener"><code>setworldcoordinates()</code></a> 设置世界坐标系</p></li><li><p>动画控制</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.delay" target="_blank" rel="noopener"><code>delay()</code></a> 延迟</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.tracer" target="_blank" rel="noopener"><code>tracer()</code></a> 追踪</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.update" target="_blank" rel="noopener"><code>update()</code></a> 更新</p><p>使用屏幕事件</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.listen" target="_blank" rel="noopener"><code>listen()</code></a> 监听</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onkey" target="_blank" rel="noopener"><code>onkey()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onkeyrelease" target="_blank" rel="noopener"><code>onkeyrelease()</code></a> 当键盘按下并释放</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onkeypress" target="_blank" rel="noopener"><code>onkeypress()</code></a> 当键盘按下</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onclick" target="_blank" rel="noopener"><code>onclick()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onscreenclick" target="_blank" rel="noopener"><code>onscreenclick()</code></a> 当点击屏幕</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ontimer" target="_blank" rel="noopener"><code>ontimer()</code></a> 当达到定时</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mainloop" target="_blank" rel="noopener"><code>mainloop()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.done" target="_blank" rel="noopener"><code>done()</code></a> 主循环</p></li><li><p>设置与特殊方法</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a> 模式</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.colormode" target="_blank" rel="noopener"><code>colormode()</code></a> 颜色模式</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getcanvas" target="_blank" rel="noopener"><code>getcanvas()</code></a> 获取画布</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getshapes" target="_blank" rel="noopener"><code>getshapes()</code></a> 获取形状</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.register_shape" target="_blank" rel="noopener"><code>register_shape()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.addshape" target="_blank" rel="noopener"><code>addshape()</code></a> 添加形状</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.turtles" target="_blank" rel="noopener"><code>turtles()</code></a> 所有海龟</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.window_height" target="_blank" rel="noopener"><code>window_height()</code></a> 窗口高度</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.window_width" target="_blank" rel="noopener"><code>window_width()</code></a> 窗口宽度</p></li><li><p>输入方法</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.textinput" target="_blank" rel="noopener"><code>textinput()</code></a> 文本输入</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.numinput" target="_blank" rel="noopener"><code>numinput()</code></a> 数字输入</p></li><li><p>Screen 专有方法</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.bye" target="_blank" rel="noopener"><code>bye()</code></a> 退出</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.exitonclick" target="_blank" rel="noopener"><code>exitonclick()</code></a> 当点击时退出</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setup" target="_blank" rel="noopener"><code>setup()</code></a> 设置</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.title" target="_blank" rel="noopener"><code>title()</code></a> 标题</p></li></ul><h2 id="RawTurtle-Turtle-方法和对应函数"><a href="#RawTurtle-Turtle-方法和对应函数" class="headerlink" title="RawTurtle/Turtle 方法和对应函数"></a>RawTurtle/Turtle 方法和对应函数</h2><p>本节中的大部分示例都使用 Turtle 类的一个实例，命名为 <code>turtle</code>。</p><h3 id="海龟动作"><a href="#海龟动作" class="headerlink" title="海龟动作"></a>海龟动作</h3><ul><li><p><code>turtle.forward</code>(<em>distance</em>)</p></li><li><p><code>turtle.fd</code>(<em>distance</em>)</p><p>参数<strong>distance</strong> – 一个数值 (整型或浮点型)海龟前进 <em>distance</em> 指定的距离，方向为海龟的朝向。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.forward(<span class="number">25</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">25.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.forward(<span class="number">-75</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">-50.00</span>,<span class="number">0.00</span>)</span><br></pre></td></tr></table></figure></li></ul><p><code>turtle.back</code>(<em>distance</em>)</p><p><code>turtle.bk</code>(<em>distance</em>)</p><p><code>turtle.backward</code>(<em>distance</em>)</p><ul><li>参数  :<strong>distance</strong> – 一个数值</li></ul><p>海龟后退 <em>distance</em> 指定的距离，方向与海龟的朝向相反。不改变海龟的朝向。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.backward(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">-30.00</span>,<span class="number">0.00</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.right</code>(<em>angle</em>)</p><p><code>turtle.rt</code>(<em>angle</em>)</p><ul><li>参数：<strong>angle</strong> – 一个数值 (整型或浮点型)</li></ul><p>海龟右转 <em>angle</em> 个单位。(单位默认为角度，但可通过 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.degrees" target="_blank" rel="noopener"><code>degrees()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.radians" target="_blank" rel="noopener"><code>radians()</code></a> 函数改变设置。) 角度的正负由海龟模式确定，参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">22.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.right(<span class="number">45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">337.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.left</code>(<em>angle</em>)</p><p><code>turtle.lt</code>(<em>angle</em>)</p><ul><li>参数:<strong>angle</strong> – 一个数值 (整型或浮点型)</li></ul><p>海龟左转 <em>angle</em> 个单位。(单位默认为角度，但可通过 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.degrees" target="_blank" rel="noopener"><code>degrees()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.radians" target="_blank" rel="noopener"><code>radians()</code></a> 函数改变设置。) 角度的正负由海龟模式确定，参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">22.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">67.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.goto</code>(<em>x</em>, <em>y=None</em>)</p><p><code>turtle.setpos</code>(<em>x</em>, <em>y=None</em>)</p><p><code>turtle.setposition</code>(<em>x</em>, <em>y=None</em>)</p><ul><li>参数：<strong>x</strong> – 一个数值或数值对/向量<strong>y</strong> – 一个数值或 <code>None</code></li></ul><p>如果 <em>y</em> 为 <code>None</code>，<em>x</em> 应为一个表示坐标的数值对或 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Vec2D" target="_blank" rel="noopener"><code>Vec2D</code></a> 类对象 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pos" target="_blank" rel="noopener"><code>pos()</code></a> 返回的对象).</p><p>海龟移动到一个绝对坐标。如果画笔已落下将会画线。不改变海龟的朝向。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tp = turtle.pos()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tp</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setpos(<span class="number">60</span>,<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">60.00</span>,<span class="number">30.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setpos((<span class="number">20</span>,<span class="number">80</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">20.00</span>,<span class="number">80.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setpos(tp)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.setx</code>(<em>x</em>)</p><ul><li>参数:<strong>x</strong> – 一个数值 (整型或浮点型)</li></ul><p>设置海龟的横坐标为 <em>x</em>，纵坐标保持不变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">240.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setx(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">10.00</span>,<span class="number">240.00</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.sety</code>(<em>y</em>)</p><ul><li>参数:<strong>y</strong> – 一个数值 (整型或浮点型)</li></ul><p>设置海龟的纵坐标为 <em>y</em>，横坐标保持不变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">40.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.sety(<span class="number">-10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">-10.00</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.setheading</code>(<em>to_angle</em>)</p><p><code>turtle.seth</code>(<em>to_angle</em>)</p><ul><li>参数:<strong>to_angle</strong> – 一个数值 (整型或浮点型)</li></ul><p>设置海龟的朝向为 <em>to_angle</em>。以下是以角度表示的几个常用方向：</p><table><thead><tr><th>标准模式</th><th>logo 模式</th></tr></thead><tbody><tr><td>0 - 东</td><td>0 - 北</td></tr><tr><td>90 - 北</td><td>90 - 东</td></tr><tr><td>180 - 西</td><td>180 - 南</td></tr><tr><td>270 - 南</td><td>270 - 西</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setheading(<span class="number">90</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.home</code>()</p><p>海龟移至初始坐标 (0,0)，并设置朝向为初始方向 (由海龟模式确定，参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a>)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">-10.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.circle</code>(<em>radius</em>, <em>extent=None</em>, <em>steps=None</em>)</p><p>三个参数:</p><ul><li><strong>radius</strong> – 一个数值</li><li><strong>extent</strong> – 一个数值 (或 <code>None</code>)</li><li><strong>steps</strong> – 一个整型数 (或 <code>None</code>)</li></ul><p>绘制一个 <em>radius</em> 指定半径的圆。圆心在海龟左边 <em>radius</em> 个单位；<em>extent</em> 为一个夹角，用来决定绘制圆的一部分。如未指定 <em>extent\</em>则绘制整个圆。如果 *extent<em> 不是完整圆周，则以当前画笔位置为一个端点绘制圆弧。如果 </em>radius<em> 为正值则朝逆时针方向绘制圆弧，否则朝顺时针方向。最终海龟的朝向会依据 </em>extent* 的值而改变。</p><p>圆实际是以其内切正多边形来近似表示的，其边的数量由 <em>steps</em> 指定。如果未指定边数则会自动确定。此方法也可用来绘制正多边形。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.circle(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">-0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.circle(<span class="number">120</span>, <span class="number">180</span>)  <span class="comment"># draw a semicircle</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">240.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">180.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.dot</code>(<em>size=None</em>, *<em>color</em>)</p><ul><li><p>参数</p><p><strong>size</strong> – 一个整型数 &gt;= 1 (如果指定)<strong>color</strong> – 一个颜色字符串或颜色数值元组</p></li></ul><p>绘制一个直径为 <em>size</em>，颜色为 <em>color</em> 的圆点。如果 <em>size</em> 未指定，则直径取 pensize+4 和 2*pensize 中的较大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.dot()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>); turtle.dot(<span class="number">20</span>, <span class="string">"blue"</span>); turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">100.00</span>,<span class="number">-0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.stamp</code>()</p><p>在海龟当前位置印制一个海龟形状。返回该印章的 stamp_id，印章可以通过调用 <code>clearstamp(stamp_id)</code> 来删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"blue"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.stamp()</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.clearstamp</code>(<em>stampid</em>)</p><ul><li><p>参数</p><p><strong>stampid</strong> – 一个整型数，必须是之前 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.stamp" target="_blank" rel="noopener"><code>stamp()</code></a> 调用的返回值</p></li></ul><p>删除 <em>stampid</em> 指定的印章。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">150.00</span>,<span class="number">-0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"blue"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>astamp = turtle.stamp()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">200.00</span>,<span class="number">-0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.clearstamp(astamp)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">200.00</span>,<span class="number">-0.00</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.clearstamps</code>(<em>n=None</em>)</p><ul><li><p>参数</p><p><strong>n</strong> – 一个整型数 (或 <code>None</code>)</p></li></ul><p>删除全部或前/后 <em>n</em> 个海龟印章。如果 <em>n</em> 为 <code>None</code> 则删除全部印章，如果 <em>n</em> &gt; 0 则删除前 <em>n</em> 个印章，否则如果 <em>n</em> &lt; 0 则删除后 <em>n</em> 个印章。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line"><span class="meta">... </span>    turtle.stamp(); turtle.fd(<span class="number">30</span>)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.clearstamps(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.clearstamps(<span class="number">-2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.clearstamps()</span><br></pre></td></tr></table></figure><p><code>turtle.undo</code>()</p><p>撤消 (或连续撤消) 最近的一个 (或多个) 海龟动作。可撤消的次数由撤消缓冲区的大小决定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    turtle.fd(<span class="number">50</span>); turtle.lt(<span class="number">80</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line"><span class="meta">... </span>    turtle.undo()</span><br></pre></td></tr></table></figure><p><code>turtle.speed</code>(<em>speed=None</em>)</p><ul><li><p>参数</p><p><strong>speed</strong> – 一个 0..10 范围内的整型数或速度字符串 (见下)</p></li></ul><p>设置海龟移动的速度为 0..10 表示的整型数值。如未指定参数则返回当前速度。</p><p>如果输入数值大于 10 或小于 0.5 则速度设为 0。速度字符串与速度值的对应关系如下:</p><ul><li>“fastest”: 0 最快</li><li>“fast”: 10 快</li><li>“normal”: 6 正常</li><li>“slow”: 3 慢</li><li>“slowest”: 1 最慢</li></ul><p>速度值从 1 到 10，画线和海龟转向的动画效果逐级加快。</p><p>注意: <em>speed</em> = 0 表示 <em>没有</em> 动画效果。forward/back 将使海龟向前/向后跳跃，同样的 left/right 将使海龟立即改变朝向。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed(<span class="string">'normal'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed()</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed(<span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="获取海龟的状态"><a href="#获取海龟的状态" class="headerlink" title="获取海龟的状态"></a>获取海龟的状态</h3><p><code>turtle.position</code>()</p><p><code>turtle.pos</code>()</p><p>返回海龟当前的坐标 (x,y) (为 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Vec2D" target="_blank" rel="noopener"><code>Vec2D</code></a> 矢量类对象)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">440.00</span>,<span class="number">-0.00</span>)</span><br></pre></td></tr></table></figure><p><code>urtle.towards</code>(<em>x</em>, <em>y=None</em>)</p><ul><li><p>参数</p><p><strong>x</strong> – 一个数值或数值对/矢量，或一个海龟实例<strong>y</strong> – 一个数值——如果 <em>x</em> 是一个数值，否则为 <code>None</code></p></li></ul><p>从海龟位置到由 (x,y)，矢量或另一海龟对应位置的连线的夹角。此数值依赖于海龟初始朝向 - 由 “standard”/“world” 或 “logo” 模式设置所决定)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.goto(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.towards(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="number">225.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.xcor</code>()</p><p>返回海龟的 x 坐标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.forward(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">64.28</span>,<span class="number">76.60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(round(turtle.xcor(), <span class="number">5</span>))</span><br><span class="line"><span class="number">64.27876</span></span><br></pre></td></tr></table></figure><p><code>turtle.ycor</code>()</p><p>返回海龟的 y 坐标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.forward(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(turtle.pos())</span><br><span class="line">(<span class="number">50.00</span>,<span class="number">86.60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(round(turtle.ycor(), <span class="number">5</span>))</span><br><span class="line"><span class="number">86.60254</span></span><br></pre></td></tr></table></figure><p><code>turtle.heading</code>()</p><p>返回海龟当前的朝向 (数值依赖于海龟模式参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a>)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">67</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">67.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.distance</code>(<em>x</em>, <em>y=None</em>)</p><ul><li><p>参数</p><p><strong>x</strong> – 一个数值或数值对/矢量，或一个海龟实例<strong>y</strong> – 一个数值——如果 <em>x</em> 是一个数值，否则为 <code>None</code></p></li></ul><p>返回从海龟位置到由 (x,y)，适量或另一海龟对应位置的单位距离。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.distance(<span class="number">30</span>,<span class="number">40</span>)</span><br><span class="line"><span class="number">50.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.distance((<span class="number">30</span>,<span class="number">40</span>))</span><br><span class="line"><span class="number">50.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe = Turtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe.forward(<span class="number">77</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.distance(joe)</span><br><span class="line"><span class="number">77.0</span></span><br></pre></td></tr></table></figure><h3 id="度量单位设置"><a href="#度量单位设置" class="headerlink" title="度量单位设置"></a>度量单位设置</h3><p><code>turtle.degrees</code>(<em>fullcircle=360.0</em>)</p><ul><li><p>参数</p><p><strong>fullcircle</strong> – 一个数值</p></li></ul><p>设置角度的度量单位，即设置一个圆周为多少 “度”。默认值为 360 度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">90</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br><span class="line"></span><br><span class="line">Change angle measurement unit to grad (also known <span class="keyword">as</span> gon,</span><br><span class="line">grade, <span class="keyword">or</span> gradian <span class="keyword">and</span> equals <span class="number">1</span>/<span class="number">100</span>-th of the right angle.)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.degrees(<span class="number">400.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.degrees(<span class="number">360</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.radians</code>()</p><p>设置角度的度量单位为弧度。其值等于 <code>degrees(2*math.pi)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">90</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.radians()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">1.5707963267948966</span></span><br></pre></td></tr></table></figure><h3 id="画笔控制"><a href="#画笔控制" class="headerlink" title="画笔控制"></a>画笔控制</h3><h4 id="绘图状态"><a href="#绘图状态" class="headerlink" title="绘图状态"></a>绘图状态</h4><ul><li><p><code>turtle.pendown</code>()</p></li><li><p><code>turtle.pd</code>()</p></li><li><p><code>turtle.down</code>()</p><p>画笔落下 – 移动时将画线。</p></li><li><p><code>turtle.penup</code>()</p></li><li><p><code>turtle.pu</code>()</p></li><li><p><code>turtle.up</code>()</p><p>画笔抬起 – 移动时不画线。</p></li><li><p><code>turtle.pensize</code>(<em>width=None</em>)</p></li><li><p><code>turtle.width</code>(<em>width=None</em>)<a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.width" target="_blank" rel="noopener">¶</a></p></li><li><p>参数</p><p><strong>width</strong> – 一个正数值</p></li></ul><p>设置线条的粗细为 <em>width</em> 或返回该值。如果 resizemode 设为 “auto” 并且 turtleshape 为多边形，该多边形也以同样组细的线条绘制。如未指定参数，则返回当前的 pensize。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pensize()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pensize(<span class="number">10</span>)   <span class="comment"># from here on lines of width 10 are drawn</span></span><br></pre></td></tr></table></figure><ul><li><p><code>turtle.pen</code>(<em>pen=None</em>, <em>**pendict</em>)</p><p><strong>pen</strong> – 一个包含部分或全部下列键的字典</p><p><strong>pendict</strong> – 一个或多个以下列键为关键字的关键字参数</p><p>返回或设置画笔的属性，以一个包含以下键值对的 “画笔字典” 表示:</p><ul><li>“shown”: True/False</li><li>“pendown”: True/False</li><li>“pencolor”: 颜色字符串或颜色元组</li><li>“fillcolor”: 颜色字符串或颜色元组</li><li>“pensize”: 正数值</li><li>“speed”: 0..10 范围内的数值</li><li>“resizemode”: “auto” 或 “user” 或 “noresize”</li><li>“stretchfactor”: (正数值, 正数值)</li><li>“outline”: 正数值</li><li>“tilt”: 数值</li></ul></li></ul><p>此字典可作为后续调用 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pen" target="_blank" rel="noopener"><code>pen()</code></a> 时的参数，以恢复之前的画笔状态。另外还可将这些属性作为关键词参数提交。使用此方式可以用一条语句设置画笔的多个属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pen(fillcolor=<span class="string">"black"</span>, pencolor=<span class="string">"red"</span>, pensize=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(turtle.pen().items())</span><br><span class="line">[(<span class="string">'fillcolor'</span>, <span class="string">'black'</span>), (<span class="string">'outline'</span>, <span class="number">1</span>), (<span class="string">'pencolor'</span>, <span class="string">'red'</span>),</span><br><span class="line"> (<span class="string">'pendown'</span>, <span class="literal">True</span>), (<span class="string">'pensize'</span>, <span class="number">10</span>), (<span class="string">'resizemode'</span>, <span class="string">'noresize'</span>),</span><br><span class="line"> (<span class="string">'shearfactor'</span>, <span class="number">0.0</span>), (<span class="string">'shown'</span>, <span class="literal">True</span>), (<span class="string">'speed'</span>, <span class="number">9</span>),</span><br><span class="line"> (<span class="string">'stretchfactor'</span>, (<span class="number">1.0</span>, <span class="number">1.0</span>)), (<span class="string">'tilt'</span>, <span class="number">0.0</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>penstate=turtle.pen()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"yellow"</span>, <span class="string">""</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.penup()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(turtle.pen().items())[:<span class="number">3</span>]</span><br><span class="line">[(<span class="string">'fillcolor'</span>, <span class="string">''</span>), (<span class="string">'outline'</span>, <span class="number">1</span>), (<span class="string">'pencolor'</span>, <span class="string">'yellow'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pen(penstate, fillcolor=<span class="string">"green"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(turtle.pen().items())[:<span class="number">3</span>]</span><br><span class="line">[(<span class="string">'fillcolor'</span>, <span class="string">'green'</span>), (<span class="string">'outline'</span>, <span class="number">1</span>), (<span class="string">'pencolor'</span>, <span class="string">'red'</span>)]</span><br></pre></td></tr></table></figure><p><code>turtle.isdown</code>()</p><p>如果画笔落下返回 <code>True</code>，如果画笔抬起返回 <code>False</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.penup()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.isdown()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pendown()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.isdown()</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="颜色控制"><a href="#颜色控制" class="headerlink" title="颜色控制"></a>颜色控制</h4><p><code>turtle.pencolor</code>(*<em>args</em>)</p><p>返回或设置画笔颜色。</p><p>允许以下四种输入格式:</p><ul><li><p><code>pencolor()</code></p><p>返回以颜色描述字符串或元组 (见示例) 表示的当前画笔颜色。可用作其他 color/pencolor/fillcolor 调用的输入。</p></li><li><p><code>pencolor(colorstring)</code></p><p>设置画笔颜色为 <em>colorstring</em> 指定的 Tk 颜色描述字符串，例如 <code>&quot;red&quot;</code>、<code>&quot;yellow&quot;</code> 或 <code>&quot;#33cc8c&quot;</code>。</p></li><li><p><code>pencolor((r, g, b))</code></p><p>设置画笔颜色为以 <em>r</em>, <em>g</em>, <em>b</em> 元组表示的 RGB 颜色。<em>r</em>, <em>g</em>, <em>b</em> 的取值范围应为 0..colormode，colormode 的值为 1.0 或 255 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.colormode" target="_blank" rel="noopener"><code>colormode()</code></a>)。</p></li><li><p><code>pencolor(r, g, b)</code></p><p>设置画笔颜色为以 <em>r</em>, <em>g</em>, <em>b</em> 表示的 RGB 颜色。<em>r</em>, <em>g</em>, <em>b</em> 的取值范围应为 0..colormode。如果 turtleshape 为多边形，该多边形轮廓也以新设置的画笔颜色绘制。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colormode()</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line"><span class="string">'red'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(<span class="string">"brown"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line"><span class="string">'brown'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup = (<span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.55</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(tup)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line">(<span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.5490196078431373</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colormode(<span class="number">255</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line">(<span class="number">51.0</span>, <span class="number">204.0</span>, <span class="number">140.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(<span class="string">'#32c18f'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line">(<span class="number">50.0</span>, <span class="number">193.0</span>, <span class="number">143.0</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.fillcolor</code>(*<em>args</em>)</p><p>返回或设置填充颜色。</p><p>允许以下四种输入格式:</p><ul><li><p><code>fillcolor()</code></p><p>返回以颜色描述字符串或元组 (见示例) 表示的当前填充颜色。可用作其他 color/pencolor/fillcolor 调用的输入。</p></li><li><p><code>fillcolor(colorstring)</code></p><p>设置填充颜色为 <em>colorstring</em> 指定的 Tk 颜色描述字符串，例如 <code>&quot;red&quot;</code>、<code>&quot;yellow&quot;</code> 或 <code>&quot;#33cc8c&quot;</code>。</p></li><li><p><code>fillcolor((r, g, b))</code></p><p>设置填充颜色为以 <em>r</em>, <em>g</em>, <em>b</em> 元组表示的 RGB 颜色。<em>r</em>, <em>g</em>, <em>b</em> 的取值范围应为 0..colormode，colormode 的值为 1.0 或 255 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.colormode" target="_blank" rel="noopener"><code>colormode()</code></a>)。</p></li><li><p><code>fillcolor(r, g, b)</code></p><p>设置填充颜色为 <em>r</em>, <em>g</em>, <em>b</em> 表示的 RGB 颜色。<em>r</em>, <em>g</em>, <em>b</em> 的取值范围应为 0..colormode。如果 turtleshape 为多边形，该多边形内部也以新设置的填充颜色填充。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor(<span class="string">"violet"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor()</span><br><span class="line"><span class="string">'violet'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line">(<span class="number">50.0</span>, <span class="number">193.0</span>, <span class="number">143.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor((<span class="number">50</span>, <span class="number">193</span>, <span class="number">143</span>))  <span class="comment"># Integers, not floats</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor()</span><br><span class="line">(<span class="number">50.0</span>, <span class="number">193.0</span>, <span class="number">143.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor(<span class="string">'#ffffff'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor()</span><br><span class="line">(<span class="number">255.0</span>, <span class="number">255.0</span>, <span class="number">255.0</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.color</code>(*<em>args</em>)</p><p>返回或设置画笔颜色和填充颜色。</p><p>允许多种输入格式。使用如下 0 至 3 个参数:</p><ul><li><p><code>color()</code></p><p>返回以一对颜色描述字符串或元组表示的当前画笔颜色和填充颜色，两者可分别由 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pencolor" target="_blank" rel="noopener"><code>pencolor()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.fillcolor" target="_blank" rel="noopener"><code>fillcolor()</code></a> 返回。</p></li><li><p><code>color(colorstring)</code>, <code>color((r,g,b))</code>, <code>color(r,g,b)</code></p><p>输入格式与 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pencolor" target="_blank" rel="noopener"><code>pencolor()</code></a> 相同，同时设置填充颜色和画笔颜色为指定的值。</p></li><li><p><code>color(colorstring1, colorstring2)</code>, <code>color((r1,g1,b1), (r2,g2,b2))</code></p><p>相当于 <code>pencolor(colorstring1)</code> 加 <code>fillcolor(colorstring2)</code>，使用其他输入格式的方法也与之类似。如果 turtleshape 为多边形，该多边形轮廓与填充也使用新设置的颜色。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"red"</span>, <span class="string">"green"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color()</span><br><span class="line">(<span class="string">'red'</span>, <span class="string">'green'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color(<span class="string">"#285078"</span>, <span class="string">"#a0c8f0"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color()</span><br><span class="line">((<span class="number">40.0</span>, <span class="number">80.0</span>, <span class="number">120.0</span>), (<span class="number">160.0</span>, <span class="number">200.0</span>, <span class="number">240.0</span>))</span><br></pre></td></tr></table></figure><p>另参见: Screen 方法 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.colormode" target="_blank" rel="noopener"><code>colormode()</code></a>。</p><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p><code>turtle.filling</code>()</p><p>返回填充状态 (填充为 <code>True</code>，否则为 <code>False</code>)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.begin_fill()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> turtle.filling():</span><br><span class="line"><span class="meta">... </span>   turtle.pensize(<span class="number">5</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>   turtle.pensize(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li><p><code>turtle.begin_fill</code>()<a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.begin_fill" target="_blank" rel="noopener">¶</a></p><p>在绘制要填充的形状之前调用。</p></li><li><p><code>turtle.end_fill</code>()</p><p>填充上次调用 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.begin_fill" target="_blank" rel="noopener"><code>begin_fill()</code></a> 之后绘制的形状。自相交多边形或多个形状间的重叠区域是否填充取决于操作系统的图形引擎、重叠的类型以及重叠的层数。 例如上面的 Turtle 多芒星可能会全部填充为黄色，也可能会有一些白色区域。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"black"</span>, <span class="string">"red"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.begin_fill()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.circle(<span class="number">80</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.end_fill()</span><br></pre></td></tr></table></figure></li></ul><h4 id="更多绘图控制"><a href="#更多绘图控制" class="headerlink" title="更多绘图控制"></a>更多绘图控制</h4><ul><li><p><code>turtle.reset</code>()</p><p>从屏幕中删除海龟的绘图，海龟回到原点并设置所有变量为默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.goto(<span class="number">0</span>,<span class="number">-22</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">-22.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br></pre></td></tr></table></figure></li><li><p><code>turtle.clear</code>()</p><p>从屏幕中删除指定海龟的绘图。不移动海龟。海龟的状态和位置以及其他海龟的绘图不受影响。</p></li><li><p><code>turtle.clear</code>()</p><p>从屏幕中删除指定海龟的绘图。不移动海龟。海龟的状态和位置以及其他海龟的绘图不受影响。</p></li><li><p><code>turtle.write</code>(<em>arg</em>, <em>move=False</em>, <em>align=”left”</em>, <em>font=(“Arial”</em>, <em>8</em>, <em>“normal”)</em>)</p><p>参数<strong>arg</strong> – 要书写到 TurtleScreen 的对象<strong>move</strong> – True/False<strong>align</strong> – 字符串 “left”, “center” 或 “right”<strong>font</strong> – 一个三元组 (fontname, fontsize, fonttype)书写文本 - <em>arg</em> 指定的字符串 - 到当前海龟位置，<em>align</em> 指定对齐方式 (“left”, “center” 或 right”)，font 指定字体。如果 <em>move</em> 为 True，画笔会移动到文本的右下角。默认 <em>move</em> 为 <code>False</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">turtle.write(<span class="string">"Home = "</span>, <span class="literal">True</span>, align=<span class="string">"center"</span>)</span><br><span class="line">turtle.write((<span class="number">0</span>,<span class="number">0</span>), <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="海龟状态"><a href="#海龟状态" class="headerlink" title="海龟状态"></a>海龟状态</h3><p>  可见性</p><ul><li><p><code>turtle.hideturtle</code>()</p></li><li><p><code>turtle.ht</code>()</p><p>使海龟不可见。当你绘制复杂图形时这是个好主意，因为隐藏海龟可显著加快绘制速度。<code>&gt;&gt;&gt; turtle.hideturtle()</code></p></li><li><p><code>turtle.showturtle</code>()</p><p><code>turtle.st</code>()</p><p>使海龟可见。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.showturtle()</span><br></pre></td></tr></table></figure></li><li><p><code>turtle.isvisible</code>()</p><p>如果海龟显示返回 <code>True</code>，如果海龟隐藏返回 <code>False</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.hideturtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.isvisible()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.showturtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.isvisible()</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h4><ul><li><p><code>turtle.shape</code>(<em>name=None</em>)</p><ul><li><strong>name</strong> – 一个有效的形状名字符串</li></ul><p>设置海龟形状为 <em>name</em> 指定的形状名，如未指定形状名则返回当前的形状名。<em>name</em> 指定的形状名应存在于 TurtleScreen 的 shape 字典中。多边形的形状初始时有以下几种: “arrow”, “turtle”, “circle”, “square”, “triangle”, “classic”。要了解如何处理形状请参看 Screen 方法 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.register_shape" target="_blank" rel="noopener"><code>register_shape()</code></a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape()</span><br><span class="line"><span class="string">'classic'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"turtle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape()</span><br><span class="line"><span class="string">'turtle'</span></span><br></pre></td></tr></table></figure></li><li><p><code>turtle.resizemode</code>(<em>rmode=None</em>)<a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.resizemode" target="_blank" rel="noopener">¶</a></p><ul><li><p>参数</p><p><strong>rmode</strong> – 字符串 “auto”, “user”, “noresize” 其中之一</p></li></ul><p>设置大小调整模式为以下值之一: “auto”, “user”, “noresize”。如未指定 <em>rmode</em> 则返回当前的大小调整模式。不同的大小调整模式的效果如下:</p><ul><li>“auto”: 根据画笔粗细值调整海龟的外观。</li><li>“user”: 根据拉伸因子和轮廓宽度 (outline) 值调整海龟的外观，两者是由 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shapesize" target="_blank" rel="noopener"><code>shapesize()</code></a> 设置的。</li><li>“noresize”: 不调整海龟的外观大小。</li></ul><p>大小调整模式 (“user”) 会在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shapesize" target="_blank" rel="noopener"><code>shapesize()</code></a> 带参数调用时生效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.resizemode()</span><br><span class="line"><span class="string">'noresize'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.resizemode(<span class="string">"auto"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.resizemode()</span><br><span class="line"><span class="string">'auto'</span></span><br></pre></td></tr></table></figure></li></ul><p><code>turtle.shapesize</code>(<em>stretch_wid=None</em>, <em>stretch_len=None</em>, <em>outline=None</em>)</p><p><code>turtle.turtlesize</code>(<em>stretch_wid=None</em>, <em>stretch_len=None</em>, <em>outline=None</em>)</p><ul><li><p>参数</p><p><strong>stretch_wid</strong> – 正数值<strong>stretch_len</strong> – 正数值<strong>outline</strong> – 正数值</p></li></ul><p>返回或设置画笔的属性 x/y-拉伸因子和/或轮廓。设置大小调整模式为 “user”。当且仅当大小调整模式设为 “user” 时海龟会基于其拉伸因子调整外观: <em>stretch_wid</em> 为垂直于其朝向的宽度拉伸因子，<em>stretch_len</em> 为平等于其朝向的长度拉伸因子，决定形状轮廓线的粗细。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize()</span><br><span class="line">(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.resizemode(<span class="string">"user"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize()</span><br><span class="line">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(outline=<span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize()</span><br><span class="line">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.shearfactor</code>(<em>shear=None</em>)</p><ul><li><p>参数</p><p><strong>shear</strong> – 数值 (可选)</p></li></ul><p>设置或返回当前的剪切因子。根据 share 指定的剪切因子即剪切角度的切线来剪切海龟形状。<em>不</em> 改变海龟的朝向 (移动方向)。如未指定 shear 参数: 返回当前的剪切因子即剪切角度的切线，与海龟朝向平行的线条将被剪切。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"circle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shearfactor(<span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shearfactor()</span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure><p><code>turtle.tilt</code>(<em>angle</em>)</p><ul><li><p>参数</p><p><strong>angle</strong> – 一个数值</p></li></ul><p>海龟形状自其当前的倾角转动 <em>angle</em> 指定的角度，但 <em>不</em> 改变海龟的朝向 (移动方向)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"circle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.tilt(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.tilt(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.settiltangle</code>(<em>angle</em>)</p><ul><li><p>参数</p><p><strong>angle</strong> – 一个数值</p></li></ul><p>旋转海龟形状使其指向 <em>angle</em> 指定的方向，忽略其当前的倾角，<em>不</em> 改变海龟的朝向 (移动方向)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"circle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.settiltangle(<span class="number">45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.settiltangle(<span class="number">-45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br></pre></td></tr></table></figure><p><em>3.1 版后已移除.</em></p><p><code>turtle.tiltangle</code>(<em>angle=None</em>)</p><ul><li><p>参数</p><p><strong>angle</strong> – 一个数值 (可选)</p></li></ul><p>设置或返回当前的倾角。如果指定 angle 则旋转海龟形状使其指向 angle 指定的方向，忽略其当前的倾角。<em>不</em> 改变海龟的朝向 (移动方向)。如果未指定 angle: 返回当前的倾角，即海龟形状的方向和海龟朝向 (移动方向) 之间的夹角。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"circle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.tilt(<span class="number">45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.tiltangle()</span><br><span class="line"><span class="number">45.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.shapetransform</code>(<em>t11=None</em>, <em>t12=None</em>, <em>t21=None</em>, <em>t22=None</em>)</p><ul><li><p>参数</p><p><strong>t11</strong> – 一个数值 (可选)<strong>t12</strong> – 一个数值 (可选)<strong>t21</strong> – 一个数值 (可选)<strong>t12</strong> – 一个数值 (可选)</p></li></ul><p>设置或返回海龟形状的当前变形矩阵。</p><p>如不指定任何矩阵元素，则返回以4元素元组表示的变形矩阵。否则使用指定元素设置变形矩阵改变海龟形状，矩阵第一排的值为 t11, t12，第二排的值为 t21, t22。行列式 t11 <em> t22 - t12 </em> t21 的值不能为零，否则会出错。根据指定的矩阵修改拉伸因子，剪切因子和倾角。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle = Turtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"square"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shearfactor(<span class="number">-0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapetransform()</span><br><span class="line">(<span class="number">4.0</span>, <span class="number">-1.0</span>, <span class="number">-0.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.get_shapepoly</code>()</p><p>返回以坐标值对元组表示的当前形状多边形。这可以用于定义一个新形状或一个复合形状的多个组成部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"square"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapetransform(<span class="number">4</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.get_shapepoly()</span><br><span class="line">((<span class="number">50</span>, <span class="number">-20</span>), (<span class="number">30</span>, <span class="number">20</span>), (<span class="number">-50</span>, <span class="number">20</span>), (<span class="number">-30</span>, <span class="number">-20</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-turtle-海龟制图&quot;&gt;&lt;a href=&quot;#python-标准库-turtle-海龟制图&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 turtle 海龟制图&quot;&gt;&lt;/a&gt;python 标准库 turtle 海龟制图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200227turtle.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="turtle" scheme="https://pinghailinfeng.gitee.io/tags/turtle/"/>
    
  </entry>
  
  <entry>
    <title>python standard library 2to3</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/26/python-standard-library-2to3/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/26/python-standard-library-2to3/</id>
    <published>2020-02-26T15:17:12.000Z</published>
    <updated>2020-02-27T02:06:49.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-2to3-自动转换python2到3"><a href="#python-标准库-2to3-自动转换python2到3" class="headerlink" title="python 标准库 2to3 自动转换python2到3"></a>python 标准库 2to3 自动转换python2到3</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200226Memorize-Words-Quickly-Step-8-Version-3.jpg?raw=true" alt></p><a id="more"></a><p>2to3 是一个 Python 程序，它可以用来读取 Python 2.x 版本的代码，并使用一系列的 <em>修复器</em> 来将其转换为合法的 Python 3.x 代码。标准库中已经包含了丰富的修复器，这足以处理绝大多数代码。不过 2to3 的支持库 <a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#module-lib2to3" target="_blank" rel="noopener"><code>lib2to3</code></a> 是一个很灵活通用的库，所以你也可以为 2to3 编写你自己的修复器。<a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#module-lib2to3" target="_blank" rel="noopener"><code>lib2to3</code></a> 也可以用在那些需要自动处理 Python 代码的应用中。</p><h2 id="使用-2to3"><a href="#使用-2to3" class="headerlink" title="使用 2to3"></a>使用 2to3</h2><p>2to3 通常会作为脚本和 Python 解释器一起安装，你可以在 Python 根目录的 <code>Tools/scripts</code> 文件夹下找到它。</p><p>2to3 的基本调用参数是一个需要转换的文件或目录列表。对于目录，会递归地寻找其中的 Python 源码。</p><p>这里有一个 Python 2.x 的源码文件，<code>example.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Hello, &#123;0&#125;!"</span>.format(name)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"What's your name?"</span></span><br><span class="line">name = raw_input()</span><br><span class="line">greet(name)</span><br></pre></td></tr></table></figure><p>它可以在命令行中使用 2to3 转换成 Python 3.x 版本的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 example.py</span><br></pre></td></tr></table></figure><p>这个命令会打印出和源文件的区别。通过传入 <code>-w</code> 参数，2to3 也可以把需要的修改写回到原文件中（除非传入了 <code>-n</code> 参数，否则会为原始文件创建一个副本）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -w example.py</span><br></pre></td></tr></table></figure><p>在转换完成后，<code>example.py</code> 看起来像是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"Hello, &#123;0&#125;!"</span>.format(name))</span><br><span class="line">print(<span class="string">"What's your name?"</span>)</span><br><span class="line">name = input()</span><br><span class="line">greet(name)</span><br></pre></td></tr></table></figure><p>注释和缩进都会在转换过程中保持不变。</p><p>默认情况下，2to3 会执行 <a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#to3-fixers" target="_blank" rel="noopener">预定义修复器</a> 的集合。使用 <code>-l</code> 参数可以列出所有可用的修复器。使用 <code>-f</code> 参数可以明确指定需要使用的修复器集合。而使用 <code>-x</code> 参数则可以明确指定不使用的修复器。下面的例子会只使用 <code>imports</code> 和 <code>has_key</code> 修复器运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -f imports -f has_key example.py</span><br></pre></td></tr></table></figure><p>这个命令会执行除了 <code>apply</code> 之外的所有修复器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -x apply example.py</span><br></pre></td></tr></table></figure><p>有一些修复器是需要 <em>显式指定</em> 的，它们默认不会执行，必须在命令行中列出才会执行。比如下面的例子，除了默认的修复器以外，还会执行 <code>idioms</code> 修复器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -f all -f idioms example.py</span><br></pre></td></tr></table></figure><p>注意这里使用 <code>all</code> 来启用所有默认的修复器。</p><p>有些情况下 2to3 会找到源码中有一些需要修改，但是无法自动处理的代码。在这种情况下，2to3 会在差异处下面打印一个警告信息。你应该定位到相应的代码并对其进行修改，以使其兼容 Python 3.x。</p><p>2to3 也可以重构 doctests。使用 <code>-d</code> 开启这个模式。需要注意<em>只有</em> doctests 会被重构。这种模式下不需要文件是合法的 Python 代码。举例来说，reST 文档中类似 doctests 的示例也可以使用这个选项进行重构。</p><p><code>-v</code> 选项可以输出更多转换程序的详细信息。</p><p>由于某些 print 语句可被解读为函数调用或是语句，2to3 并不是总能读取包含 print 函数的文件。当 2to3 检测到存在 <code>from __future__ import print_function</code> 编译器指令时，会修改其内部语法将 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 解读为函数。这一变动也可以使用 <code>-p</code> 选项手动开启。使用 <code>-p</code> 来为已经转换过 print 语句的代码运行修复器。</p><p><code>-o</code> 或 <code>--output-dir</code> 选项可以指定将转换后的文件写入其他目录中。由于这种情况下不会覆写原始文件，所以创建副本文件毫无意义，因此也需要使用 <code>-n</code> 选项来禁用创建副本。</p><p><em>3.2.3 新版功能:</em> 增加了 <code>-o</code> 选项。</p><p><code>-W</code> 或 <code>--write-unchanged-files</code> 选项用来告诉 2to3 始终需要输出文件，即使没有任何改动。这在使用 <code>-o</code> 参数时十分有用，这样就可以将整个 Python 源码包完整地转换到另一个目录。这个选项隐含了 <code>-w</code> 选项，否则等于没有作用。</p><p><em>3.2.3 新版功能:</em> 增加了 <code>-W</code> 选项。</p><p><code>--add-suffix</code> 选项接受一个字符串，用来作为后缀附加在输出文件名后面的后面。由于写入的文件名与原始文件不同，所以没有必要创建副本，因此 <code>-n</code> 选项也是必要的。举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -n -W --add-suffix=<span class="number">3</span> example.py</span><br></pre></td></tr></table></figure><p>这样会把转换后的文件写入 <code>example.py3</code> 文件。</p><p><em>3.2.3 新版功能:</em> 增加了 <code>--add-suffix</code> 选项。</p><p>将整个项目从一个目录转换到另一个目录可以用这样的命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 --output-dir=python3-version/mycode -W -n python2-version/mycode</span><br></pre></td></tr></table></figure><h2 id="修复器"><a href="#修复器" class="headerlink" title="修复器"></a>修复器</h2><p>转换代码的每一个步骤都封装在修复器中。可以使用 <code>2to3 -l</code> 来列出可用的修复器。<a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#to3-using" target="_blank" rel="noopener">之前已经提到</a>，每个修复器都可以独立地打开或是关闭。下面会对各个修复器做更详细的描述。</p><ul><li><p><code>apply</code></p><p>移除对 <code>apply()</code> 的使用，举例来说，<code>apply(function, *args, **kwargs)</code> 会被转换成 <code>function(*args, **kwargs)</code>。</p></li><li><p><code>asserts</code></p><p>将已弃用的 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 方法替换为正确的。</p></li></ul><table><thead><tr><th style="text-align:left">Python 2.x</th><th style="text-align:left">Python 3.x</th></tr></thead><tbody><tr><td style="text-align:left"><code>failUnlessEqual(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertEqual" target="_blank" rel="noopener"><code>assertEqual(a, b)</code></a></td></tr><tr><td style="text-align:left"><code>assertEquals(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertEqual" target="_blank" rel="noopener"><code>assertEqual(a, b)</code></a></td></tr><tr><td style="text-align:left"><code>failIfEqual(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertNotEqual" target="_blank" rel="noopener"><code>assertNotEqual(a, b)</code></a></td></tr><tr><td style="text-align:left"><code>assertNotEquals(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertNotEqual" target="_blank" rel="noopener"><code>assertNotEqual(a, b)</code></a></td></tr><tr><td style="text-align:left"><code>failUnless(a)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertTrue" target="_blank" rel="noopener"><code>assertTrue(a)</code></a></td></tr><tr><td style="text-align:left"><code>assert_(a)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertTrue" target="_blank" rel="noopener"><code>assertTrue(a)</code></a></td></tr><tr><td style="text-align:left"><code>failIf(a)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertFalse" target="_blank" rel="noopener"><code>assertFalse(a)</code></a></td></tr><tr><td style="text-align:left"><code>failUnlessRaises(exc, cal)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertRaises" target="_blank" rel="noopener"><code>assertRaises(exc, cal)</code></a></td></tr><tr><td style="text-align:left"><code>failUnlessAlmostEqual(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertAlmostEqual" target="_blank" rel="noopener"><code>assertAlmostEqual(a, b)</code></a></td></tr><tr><td style="text-align:left"><code>assertAlmostEquals(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertAlmostEqual" target="_blank" rel="noopener"><code>assertAlmostEqual(a, b)</code></a></td></tr><tr><td style="text-align:left"><code>failIfAlmostEqual(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertNotAlmostEqual" target="_blank" rel="noopener"><code>assertNotAlmostEqual(a, b)</code></a></td></tr><tr><td style="text-align:left"><code>assertNotAlmostEquals(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertNotAlmostEqual" target="_blank" rel="noopener"><code>assertNotAlmostEqual(a, b)</code></a></td></tr></tbody></table><ul><li><code>basestring</code></li></ul><ul><li><p><code>buffer</code></p><p>将 <code>buffer</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview</code></a>。这个修复器是可选的，因为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview</code></a> API 和 <code>buffer</code> 很相似，但不完全一样。</p></li><li><p><code>dict</code></p><p>修复字典迭代方法。<code>dict.iteritems()</code> 会转换成 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.items" target="_blank" rel="noopener"><code>dict.items()</code></a>，<code>dict.iterkeys()</code> 会转换成 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.keys" target="_blank" rel="noopener"><code>dict.keys()</code></a>，<code>dict.itervalues()</code> 会转换成 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.values" target="_blank" rel="noopener"><code>dict.values()</code></a>。类似的，<code>dict.viewitems()</code>，<code>dict.viewkeys()</code> 和 <code>dict.viewvalues()</code> 会分别转换成 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.items" target="_blank" rel="noopener"><code>dict.items()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.keys" target="_blank" rel="noopener"><code>dict.keys()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.values" target="_blank" rel="noopener"><code>dict.values()</code></a>。另外也会将原有的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.items" target="_blank" rel="noopener"><code>dict.items()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.keys" target="_blank" rel="noopener"><code>dict.keys()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.values" target="_blank" rel="noopener"><code>dict.values()</code></a> 方法调用用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装一层。</p></li><li><p><code>except</code></p><p>将 <code>except X, T</code> 转换为 <code>except X as T</code>。</p></li><li><p><code>exec</code></p><p>将 <code>exec</code> 语句转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 函数调用。</p></li><li><p><code>execfile</code></p><p>移除 <code>execfile()</code> 的使用。<code>execfile()</code> 的实参会使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#compile" target="_blank" rel="noopener"><code>compile()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 包装。</p></li><li><p><code>exitfunc</code></p><p>将对 <code>sys.exitfunc</code> 的赋值改为使用 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 模块代替。</p></li><li><p><code>filter</code></p><p>将 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#filter" target="_blank" rel="noopener"><code>filter()</code></a> 函数用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装一层。</p></li><li><p><code>funcattrs</code></p><p>修复已经重命名的函数属性。比如 <code>my_function.func_closure</code> 会被转换为 <code>my_function.__closure__</code>。</p></li><li><p><code>future</code></p><p>移除 <code>from __future__ import new_feature</code> 语句。</p></li><li><p><code>getcwdu</code></p><p>将 <code>os.getcwdu()</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getcwd" target="_blank" rel="noopener"><code>os.getcwd()</code></a>。</p></li><li><p><code>has_key</code></p><p>将 <code>dict.has_key(key)</code> 转换为 <code>key in dict</code>。</p></li><li><p><code>idioms</code></p><p>这是一个可选的修复器，会进行多种转换，将 Python 代码变成更加常见的写法。类似 <code>type(x) is SomeClass</code> 和 <code>type(x) == SomeClass</code> 的类型对比会被转换成 <code>isinstance(x, SomeClass)</code>。<code>while 1</code> 转换成 <code>while True</code>。这个修复器还会在合适的地方使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> 函数。举个例子，这样的代码块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = list(some_iterable)</span><br><span class="line">L.sort()</span><br></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = sorted(some_iterable)</span><br></pre></td></tr></table></figure></li><li><p><code>import</code></p><p>检测 sibling imports，并将其转换成相对 import。</p></li><li><p><code>imports</code></p><p>处理标准库模块的重命名。</p></li><li><p><code>imports2</code></p><p>处理标准库中其他模块的重命名。这个修复器由于一些技术上的限制，因此和 <a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#2to3fixer-imports" target="_blank" rel="noopener"><code>imports</code></a> 拆分开了。</p></li><li><p><code>input</code></p><p>将 <code>input(prompt)</code> 转换为 <code>eval(input(prompt))</code>。</p></li><li><p><code>intern</code></p><p>将 <code>intern()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.intern" target="_blank" rel="noopener"><code>sys.intern()</code></a>。</p></li><li><p><code>isinstance</code></p><p>修复 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a> 函数第二个实参中重复的类型。举例来说，<code>isinstance(x, (int, int))</code> 会转换为 <code>isinstance(x, int)</code>, <code>isinstance(x, (int, float, int))</code> 会转换为 <code>isinstance(x, (int, float))</code>。</p></li><li><p><code>itertools_imports</code></p><p>移除 <code>itertools.ifilter()</code>，<code>itertools.izip()</code> 以及 <code>itertools.imap()</code> 的 import。对 <code>itertools.ifilterfalse()</code> 的 import 也会替换成 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.filterfalse" target="_blank" rel="noopener"><code>itertools.filterfalse()</code></a>。</p></li><li><p><code>itertools</code></p><p>修改 <code>itertools.ifilter()</code>，<code>itertools.izip()</code> 和 <code>itertools.imap()</code> 的调用为对应的内建实现。<code>itertools.ifilterfalse()</code> 会替换成 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.filterfalse" target="_blank" rel="noopener"><code>itertools.filterfalse()</code></a>。</p></li><li><p><code>long</code></p><p>将 <code>long</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>。</p></li><li><p><code>map</code></p><p>用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a>。同时也会将 <code>map(None, x)</code> 替换为 <code>list(x)</code>。使用 <code>from future_builtins import map</code> 禁用这个修复器。</p></li><li><p><code>metaclass</code></p><p>将老的元类语法（类体中的 <code>__metaclass__ = Meta</code>）替换为新的（<code>class X(metaclass=Meta)</code>）。</p></li><li><p><code>methodattrs</code></p><p>修复老的方法属性名。例如 <code>meth.im_func</code> 会被转换为 <code>meth.__func__</code>。</p></li><li><p><code>ne</code></p><p>转换老的不等语法，将 <code>&lt;&gt;</code> 转为 <code>!=</code>。</p></li><li><p><code>next</code></p><p>将迭代器的 <code>next()</code> 方法调用转为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 函数。也会将 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 方法重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a>。</p></li><li><p><code>nonzero</code></p><p>将 <code>__nonzero__()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__bool__" target="_blank" rel="noopener"><code>__bool__()</code></a>。</p></li><li><p><code>numliterals</code></p><p>将八进制字面量转为新的语法。</p></li><li><p><code>operator</code></p><p>将 <a href="https://docs.python.org/zh-cn/3.8/library/operator.html#module-operator" target="_blank" rel="noopener"><code>operator</code></a> 模块中的许多方法调用转为其他的等效函数调用。如果有需要，会添加适当的 <code>import</code> 语句，比如 <code>import collections.abc</code>。有以下转换映射：</p></li></ul><table><thead><tr><th style="text-align:left">Python 2.x</th><th style="text-align:left">Python 3.x</th></tr></thead><tbody><tr><td style="text-align:left"><code>operator.isCallable(obj)</code></td><td style="text-align:left"><code>callable(obj)</code></td></tr><tr><td style="text-align:left"><code>operator.sequenceIncludes(obj)</code></td><td style="text-align:left"><code>operator.contains(obj)</code></td></tr><tr><td style="text-align:left"><code>operator.isSequenceType(obj)</code></td><td style="text-align:left"><code>isinstance(obj, collections.abc.Sequence)</code></td></tr><tr><td style="text-align:left"><code>operator.isMappingType(obj)</code></td><td style="text-align:left"><code>isinstance(obj, collections.abc.Mapping)</code></td></tr><tr><td style="text-align:left"><code>operator.isNumberType(obj)</code></td><td style="text-align:left"><code>isinstance(obj, numbers.Number)</code></td></tr><tr><td style="text-align:left"><code>operator.repeat(obj, n)</code></td><td style="text-align:left"><code>operator.mul(obj, n)</code></td></tr><tr><td style="text-align:left"><code>operator.irepeat(obj, n)</code></td><td style="text-align:left"><code>operator.imul(obj, n)</code></td></tr></tbody></table><ul><li><p><code>paren</code></p><p>在列表生成式中增加必须的括号。例如将 <code>[x for x in 1, 2]</code> 转换为 <code>[x for x in (1, 2)]</code>。</p></li><li><p><code>print</code></p><p>将 <code>print</code> 语句转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 函数。</p></li><li><p><code>raise</code></p><p>将 <code>raise E, V</code> 转换为 <code>raise E(V)</code>，将 <code>raise E, V, T</code> 转换为 <code>raise E(V).with_traceback(T)</code>。如果 <code>E</code> 是元组，这样的转换是不正确的，因为用元组代替异常的做法在 3.0 中已经移除了。</p></li><li><p><code>raw_input</code></p><p>将 <code>raw_input()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#input" target="_blank" rel="noopener"><code>input()</code></a>。</p></li><li><p><code>reduce</code></p><p>将 <code>reduce()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.reduce" target="_blank" rel="noopener"><code>functools.reduce()</code></a>。</p></li><li><p><code>reload</code></p><p>将 <code>reload()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/importlib.html#importlib.reload" target="_blank" rel="noopener"><code>importlib.reload()</code></a>。</p></li><li><p><code>renames</code></p><p>将 <code>sys.maxint</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.maxsize" target="_blank" rel="noopener"><code>sys.maxsize</code></a>。</p></li><li><p><code>repr</code></p><p>将反引号 repr 表达式替换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 函数。</p></li><li><p><code>set_literal</code></p><p>将 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 构造函数替换为 set literals 写法。这个修复器是可选的。</p></li><li><p><code>standarderror</code></p><p>将 <code>StandardError</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a>。</p></li><li><p><code>sys_exc</code></p><p>将弃用的 <code>sys.exc_value</code>，<code>sys.exc_type</code>，<code>sys.exc_traceback</code> 替换为 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exc_info" target="_blank" rel="noopener"><code>sys.exc_info()</code></a> 的用法。</p></li><li><p><code>throw</code></p><p>修复生成器的 <code>throw()</code> 方法的 API 变更。</p></li><li><p><code>tuple_params</code></p><p>移除隐式的元组参数解包。这个修复器会插入临时变量。</p></li><li><p><code>types</code></p><p>修复 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#type" target="_blank" rel="noopener"><code>type</code></a> 模块中一些成员的移除引起的代码问题。</p></li><li><p><code>unicode</code></p><p>将 <code>unicode</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>。</p></li><li><p><code>urllib</code></p><p>将 <a href="https://docs.python.org/zh-cn/3.8/library/urllib.html#module-urllib" target="_blank" rel="noopener"><code>urllib</code></a> 和 <code>urllib2</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/urllib.html#module-urllib" target="_blank" rel="noopener"><code>urllib</code></a> 包。</p></li><li><p><code>ws_comma</code></p><p>移除逗号分隔的元素之间多余的空白。这个修复器是可选的。</p></li><li><p><code>xrange</code></p><p>将 <code>xrange()</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#range" target="_blank" rel="noopener"><code>range()</code></a>，并用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装原有的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#range" target="_blank" rel="noopener"><code>range()</code></a>。</p></li><li><p><code>xreadlines</code></p><p>将 <code>for x in file.xreadlines()</code> 转换为 <code>for x in file</code>。</p></li><li><p><code>zip</code></p><p>用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#zip" target="_blank" rel="noopener"><code>zip()</code></a>。如果使用了 <code>from future_builtins import zip</code> 的话会禁用。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-2to3-自动转换python2到3&quot;&gt;&lt;a href=&quot;#python-标准库-2to3-自动转换python2到3&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 2to3 自动转换python2到3&quot;&gt;&lt;/a&gt;python 标准库 2to3 自动转换python2到3&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200226Memorize-Words-Quickly-Step-8-Version-3.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="2to3" scheme="https://pinghailinfeng.gitee.io/tags/2to3/"/>
    
  </entry>
  
</feed>
