<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凭海临风的IT江湖</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pinghailinfeng.gitee.io/"/>
  <updated>2020-02-24T16:04:58.911Z</updated>
  <id>https://pinghailinfeng.gitee.io/</id>
  
  <author>
    <name>Jeff Sui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python standard library binascii</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/24/python-standard-library-binascii/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/24/python-standard-library-binascii/</id>
    <published>2020-02-24T15:25:31.000Z</published>
    <updated>2020-02-24T16:04:58.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-binascii"><a href="#python-标准库-binascii" class="headerlink" title="python 标准库 binascii"></a>python 标准库 binascii</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200224_Happy-Hero-Day.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>the love of father is like a mountain  父爱如山</p></blockquote><p><a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#module-binascii" target="_blank" rel="noopener"><code>binascii</code></a> 模块包含很多在二进制和二进制表示的各种ASCII码之间转换的方法。 通常情况不会直接使用这些函数，而是使用像 <a href="https://docs.python.org/zh-cn/3.8/library/uu.html#module-uu" target="_blank" rel="noopener"><code>uu</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/base64.html#module-base64" target="_blank" rel="noopener"><code>base64</code></a> ，或 <a href="https://docs.python.org/zh-cn/3.8/library/binhex.html#module-binhex" target="_blank" rel="noopener"><code>binhex</code></a> 这样的封装模块。 为了执行效率高，<a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#module-binascii" target="_blank" rel="noopener"><code>binascii</code></a> 模块含有许多用 C 写的低级函数，这些底层函数被一些高级模块所使用。</p><blockquote><p> <code>a2b_*</code> 函数接受只含有 ASCII 码的Unicode 字符串。其他函数只接受 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> （例如 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 和其他支持缓冲区协议的对象）。</p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p><code>binascii.a2b_uu</code>(<em>string</em>)</p><p>将单行 uu 编码数据转换成二进制数据并返回。uu 编码每行的数据通常包含45 个（二进制）字节，最后一行除外。每行数据后面可能跟有空格。</p></li><li><p><code>binascii.b2a_uu</code>(<em>data</em>, <em>**, </em>backtick=False*)</p><p>将二进制数据转换为 ASCII 编码字符，返回值是转换后的行数据，包括换行符。 <em>data</em> 的长度最多为45。如果 <em>backtick</em> 为ture，则零由 <code>&#39;</code>‘` 而不是空格表示。<em>在 3.7 版更改:</em> 增加 <em>backtick</em> 形参。</p></li><li><p><code>binascii.a2b_base64</code>(<em>string</em>)</p><p>将 base64 数据块转换成二进制并以二进制数据形式返回。一次可以传递多行数据。</p></li><li><p><code>binascii.b2a_base64</code>(<em>data</em>, <em>**, </em>newline=True*)</p><p>将二进制数据转换为一行用 base64 编码的ASCII字符串。返回值是转换后的行数据，如果 <em>newline</em> 为true，则返回值包括换行符。该函数的输出符合：rfc：3548。<em>在 3.6 版更改:</em> 增加 <em>newline</em> 形参。</p></li><li><p><code>binascii.a2b_qp</code>(<em>data</em>, <em>header=False</em>)</p><p>将一个引号可打印的数据块转换成二进制数据并返回。一次可以转换多行。如果可选参数 <em>header</em> 存在且为true，则数据中的下划线将被解码成空格。</p></li><li><p><code>binascii.b2a_qp</code>(<em>data</em>, <em>quotetabs=False</em>, <em>istext=True</em>, <em>header=False</em>)</p><p>将二进制数据转换为一行或多行带引号可打印编码的ASCII字符串。返回值是转换后的行数据。如果可选参数 <em>quotetabs</em> 存在且为真值，则对所有制表符和空格进行编码。如果可选参数 <em>istext</em> 存在且为真值，则不对新行进行编码，但将对尾随空格进行编码。如果可选参数 <em>header</em> 存在且为true，则空格将被编码为下划线 <a href="https://tools.ietf.org/html/rfc1522.html" target="_blank" rel="noopener"><strong>RFC 1522</strong></a>。如果可选参数 <em>header</em> 存在且为假值，则也会对换行符进行编码;不进行换行转换编码可能会破坏二进制数据流。</p></li><li><p><code>binascii.a2b_hqx</code>(<em>string</em>)</p><p>将 binhex4 格式的 ASCII 数据不进行 RLE 解压缩直接转换为二进制数据。该字符串应包含完整数量的二进制字节，或者（在binhex4 数据最后部分）剩余位为零。</p></li><li><p><code>binascii.rledecode_hqx</code>(<em>data</em>)</p><p>根据 binhex4 标准对数据执行 RLE 解压缩。该算法在一个字节的数据后使用 <code>0x90</code> 作为重复指示符，然后计数。计数 <code>0</code> 指定字节值 <code>0x90</code> 。该例程返回解压缩的数据，输入数据以孤立的重复指示符结束的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#binascii.Incomplete" target="_blank" rel="noopener"><code>Incomplete</code></a> 异常。<em>在 3.2 版更改:</em> 仅接受 bytestring 或 bytearray 对象作为输入。</p></li><li><p><code>binascii.rlecode_hqx</code>(<em>data</em>)</p><p>在 <em>data</em> 上执行 binhex4 游程编码压缩并返回结果。</p></li><li><p><code>binascii.b2a_hqx</code>(<em>data</em>)</p><p>执行 hexbin4 类型二进制到 ASCII 码的转换并返回结果字符串。输入数据应经过 RLE 编码，且数据长度可被3整除（除了最后一个片段）。</p></li><li><p><code>binascii.crc_hqx</code>(<em>data</em>, <em>value</em>)</p><p>以 <em>value</em> 作为初始 CRC 计算 <em>data</em> 的16位 CRC 值，返回其结果。这里使用 CRC-CCITT 生成多项式 <em>x</em>16 + <em>x</em>12 + <em>x</em>5 + 1 ，通常表示为0x1021。该 CRC 被用于 binhex4 格式。</p></li><li><p><code>binascii.crc32</code>(<em>data</em>[, <em>value</em>])</p><p>计算 CRC-32 ，从 <em>value</em> 的初始 CRC 开始计算 <em>data</em> 的32位校验和。默认初始 CRC 为零。该算法与 ZIP 文件校验和一致。由于该算法被设计用作校验和算法，因此不适合用作通用散列算法。使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(binascii.crc32(<span class="string">b"hello world"</span>))</span><br><span class="line"><span class="comment"># Or, in two pieces:</span></span><br><span class="line">crc = binascii.crc32(<span class="string">b"hello"</span>)</span><br><span class="line">crc = binascii.crc32(<span class="string">b" world"</span>, crc)</span><br><span class="line">print(<span class="string">'crc32 = &#123;:#010x&#125;'</span>.format(crc))</span><br></pre></td></tr></table></figure><p><em>在 3.0 版更改:</em> 校验结果始终是无符号类型的。要在所有Python版本和平台上生成相同的数值，请使用 <code>crc32(data) &amp; 0xffffffff</code> 。</p></li><li><p><code>binascii.b2a_hex</code>(<em>data</em>[, <em>sep</em>[, <em>bytes_per_sep=1</em>]])</p></li><li><p><code>binascii.hexlify</code>(<em>data</em>[, <em>sep</em>[, <em>bytes_per_sep=1</em>]])</p><p>返回二进制数据 <em>data</em> 的十六进制表示形式。 <em>data</em> 的每个字节都被转换为相应的2位十六进制表示形式。因此返回的字节对象的长度是 <em>data</em> 的两倍。</p><p>使用：<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes.hex" target="_blank" rel="noopener"><code>bytes.hex()</code></a> 方法也可以方便地实现相似的功能（但仅返回文本字符串）。</p><p>如果指定了 <em>sep</em>，它必须为单字符 str 或 bytes 对象。 它将被插入每个 <em>bytes_per_sep</em> 输入字节之后。 分隔符位置默认从输出的右端开始计数，如果你希望从左端开始计数，请提供一个负的 <em>bytes_per_sep</em> 值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> binascii</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.b2a_hex(<span class="string">b'\xb9\x01\xef'</span>)</span><br><span class="line"><span class="string">b'b901ef'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.hexlify(<span class="string">b'\xb9\x01\xef'</span>, <span class="string">'-'</span>)</span><br><span class="line"><span class="string">b'b9-01-ef'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.b2a_hex(<span class="string">b'\xb9\x01\xef'</span>, <span class="string">b'_'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">b'b9_01ef'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.b2a_hex(<span class="string">b'\xb9\x01\xef'</span>, <span class="string">b' '</span>, <span class="number">-2</span>)</span><br><span class="line"><span class="string">b'b901 ef'</span></span><br></pre></td></tr></table></figure><p><em>在 3.8 版更改:</em> 添加了 <em>sep</em> 和 <em>bytes_per_sep</em> 形参。</p></li><li><p><code>binascii.a2b_hex</code>(<em>hexstr</em>)</p></li><li><p><code>binascii.unhexlify</code>(<em>hexstr</em>)</p><p>返回由十六进制字符串 <em>hexstr</em> 表示的二进制数据。此函数功能与 <a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#binascii.b2a_hex" target="_blank" rel="noopener"><code>b2a_hex()</code></a> 相反。 <em>hexstr</em> 必须包含偶数个十六进制数字（可以是大写或小写），否则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#binascii.Error" target="_blank" rel="noopener"><code>Error</code></a> 异常。</p><p>使用：<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes.fromhex" target="_blank" rel="noopener"><code>bytes.fromhex()</code></a> 类方法也实现相似的功能（仅接受文本字符串参数，不限制其中的空白字符）。</p></li><li><p><em>exception</em> <code>binascii.Error</code></p><p>通常是因为编程错误引发的异常。</p></li><li><p><em>exception</em> <code>binascii.Incomplete</code></p><p>数据不完整引发的异常。通常不是编程错误导致的，可以通过读取更多的数据并再次尝试来处理该异常。</p></li></ul><blockquote><p>参见:</p><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/base64.html#module-base64" target="_blank" rel="noopener"><code>base64</code></a></p><p>支持在16，32，64，85进制中进行符合 RFC 协议的 base64 样式编码。</p><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/binhex.html#module-binhex" target="_blank" rel="noopener"><code>binhex</code></a></p><p>支持在 Macintosh 上使用的 binhex 格式。</p><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/uu.html#module-uu" target="_blank" rel="noopener"><code>uu</code></a></p><p>支持在 Unix 上使用的 UU 编码。</p><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/quopri.html#module-quopri" target="_blank" rel="noopener"><code>quopri</code></a></p><p>支持在 MIME 版本电子邮件中使用引号可打印编码。</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment"># 导入binascii模块</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"> </span><br><span class="line">a = <span class="string">b'BE27E8FFFF010203'</span></span><br><span class="line"><span class="comment"># 先把b'BE27E8FFFF010203'转换成二进制数据然后在用十六进制表示</span></span><br><span class="line">b = binascii.b2a_hex(a)</span><br><span class="line"><span class="comment"># 打印出：b'42453237453846464646303130323033'，例如B对应ascii码42，E对应ascii码45</span></span><br><span class="line">print(b)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 与b2a_hex相反，打印出：b'BE27E8FFFF010203'</span></span><br><span class="line">print(binascii.a2b_hex(b))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个功能和b2a_hex()一样</span></span><br><span class="line"><span class="comment"># 打印出：b'42453237453846464646303130323033'，例如B对应ascii码42，E对应ascii码45</span></span><br><span class="line">c = binascii.hexlify(a)</span><br><span class="line">print(c)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个功能和a2b_hex()一样，打印出：b'BE27E8FFFF010203'</span></span><br><span class="line">print(binascii.unhexlify(c))</span><br></pre></td></tr></table></figure><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">a = <span class="string">'hello world'</span></span><br><span class="line"><span class="comment">#先把a转换成二进制数据然后在用十六进制表示</span></span><br><span class="line">b = binascii.b2a_hex(a)</span><br><span class="line">c = binascii.hexlify(a)<span class="comment">#和a2b_hex()功能是一样的,但是推荐用这个函数,具体不清楚= =</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;0:10s&#125;'</span>.format(<span class="string">'b2a_hex'</span>),</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(b),<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">print</span> b[i:i+<span class="number">2</span>],</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#到这是不是发现了,利用b2a_hex()返回的字符串长度为原串的两倍,因为转换为十六进制,一个字节用两个字节表示了</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;0:10s&#125;'</span>.format(<span class="string">'hexlify'</span>),</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(c),<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">print</span> c[i:i+<span class="number">2</span>],   </span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;0:10s&#125;'</span>.format(<span class="string">'ord'</span>),</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">print</span> hex(ord(i))[<span class="number">2</span>:],<span class="comment">#手动转换为二进制十六进制</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#与b2a_hex相反</span></span><br><span class="line"><span class="keyword">print</span> binascii.a2b_hex(b)</span><br><span class="line"><span class="keyword">print</span> binascii.unhexlify(c)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">result:</span></span><br><span class="line"><span class="string">b2a_hex    68 65 6c 6c 6f 20 77 6f 72 6c 64</span></span><br><span class="line"><span class="string">hexlify    68 65 6c 6c 6f 20 77 6f 72 6c 64</span></span><br><span class="line"><span class="string">ord        68 65 6c 6c 6f 20 77 6f 72 6c 64</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">d1 = datetime.datetime(<span class="number">2019</span>,<span class="number">4</span>,<span class="number">7</span>)</span><br><span class="line">d2 = datetime.datetime(<span class="number">2020</span>,<span class="number">2</span>,<span class="number">24</span>)</span><br><span class="line">print(d2-d1)</span><br></pre></td></tr></table></figure><blockquote><p>父亲离开我已经过去了323天。</p><p>今天整理云盘,发现了父亲的照片。</p><p>心里很难受。</p><p>父亲平时少言寡语。不太喜欢和我们交流。</p><p>最后一次和父亲聊天,是19年3月底,医院住院的时候。</p><p>他说:鑫儿,昨天大夫查房和说我了,我是个定时炸弹,随时都会爆发。栓塞已经不是主要问题了。指了指心。这里是大问题。这个3到5分钟就过去了。父亲顿了顿,继续说：存着都在你妈那里，我要是万一哪天过去了,就找你妈要,你和你姐都有份,你姐身体不好,孩子还上大学,你就多让点你姐,你还年轻,以后还有机会赚钱。</p><p>我调侃道：您这是要交代后事啊?</p><p>父亲说,对啊，现在说了,我就了心思了。能活一天算一天。</p><p>我不知道该说些什么。只能扶着父亲在医院走廊里继续走啊，走啊。</p><p>想起我小时候拉着父亲的手过马路的情形。和这时候差不多。父亲的腿因为栓塞，没有劲,需要拄着拐杖才能慢慢挪动脚步。</p><p>谁能想到这次谈话,竟是永别。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-binascii&quot;&gt;&lt;a href=&quot;#python-标准库-binascii&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 binascii&quot;&gt;&lt;/a&gt;python 标准库 binascii&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200224_Happy-Hero-Day.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python standard library gc</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/23/python_standard_library_gc/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/23/python_standard_library_gc/</id>
    <published>2020-02-23T13:12:27.000Z</published>
    <updated>2020-02-24T16:14:33.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-gc"><a href="#python-标准库-gc" class="headerlink" title="python 标准库 gc"></a>python 标准库 gc</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200224_father.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>离开的时候,才会记得你。</p></blockquote><p>此模块提供可选的垃圾回收器的接口，提供的功能包括：关闭收集器、调整收集频率、设置调试选项。它同时提供对回收器找到但是无法释放的不可达对象的访问。由于 Python 使用了带有引用计数的回收器，如果你确定你的程序不会产生循环引用，你可以关闭回收器。可以通过调用 <code>gc.disable()</code> 关闭自动垃圾回收。若要调试一个存在内存泄漏的程序，调用 <code>gc.set_debug(gc.DEBUG_LEAK)</code> ；需要注意的是，它包含 <code>gc.DEBUG_SAVEALL</code> ，使得被垃圾回收的对象会被存放在 gc.garbage 中以待检查。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/gc.html#module-gc" target="_blank" rel="noopener"><code>gc</code></a> 模块提供下列函数：</p><ul><li><p><code>gc.enable</code>()</p><p>启用自动垃圾回收</p></li><li><p><code>gc.disable</code>()</p><p>停用自动垃圾回收</p></li><li><p><code>gc.isenabled</code>()</p><p>如果启用了自动回收则返回 <code>True</code>。</p></li><li><p><code>gc.collect</code>(<em>generation=2</em>)</p><p>若被调用时不包含参数，则启动完全的垃圾回收。可选的参数 <em>generation</em> 可以是一个整数，指明需要回收哪一代（从 0 到 2 ）的垃圾。当参数 <em>generation</em> 无效时，会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。返回发现的不可达对象的数目。每当运行完整收集或最高代 (2) 收集时，为多个内置类型所维护的空闲列表会被清空。 由于特定类型特别是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 的实现，在某些空闲列表中并非所有项都会被释放。</p></li><li><p><code>gc.set_debug</code>(<em>flags</em>)</p><p>设置垃圾回收器的调试标识位。调试信息会被写入 <code>sys.stderr</code> 。此文档末尾列出了各个标志位及其含义；可以使用位操作对多个标志位进行设置以控制调试器。</p></li><li><p><code>gc.get_debug</code>()</p><p>返回当前调试标识位。</p></li><li><p><code>gc.get_objects</code>(<em>generation=None</em>)</p><p>返回一个收集器所跟踪的所有对象的列表，所返回的列表除外。 如果 <em>generation</em> 不为 None，则只返回收集器所跟踪的属于该生成的对象。<em>在 3.8 版更改:</em> 新的 <em>generation</em> 形参。</p></li><li><p><code>gc.get_stats</code>()</p><p>返回一个包含三个字典对象的列表，每个字典分别包含对应代的从解释器开始运行的垃圾回收统计数据。字典的键的数目在将来可能发生改变，目前每个字典包含以下内容：<code>collections</code> 是该代被回收的次数；<code>collected</code> 是该代中被回收的对象总数；<code>uncollectable</code> 是在这一代中被发现无法收集的对象总数 （因此被移动到 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>garbage</code></a> 列表中）。<em>3.4 新版功能.</em></p></li><li><p><code>gc.set_threshold</code>(<em>threshold0</em>[, <em>threshold1</em>[, <em>threshold2</em>]])</p><p>设置垃圾回收阈值（收集频率）。 将 <em>threshold0</em> 设为零会禁用回收。垃圾回收器把所有对象分类为三代，取决于对象幸存于多少次垃圾回收。新创建的对象会被放在最年轻代（第 <code>0</code> 代）。如果一个对象幸存于一次垃圾回收，则该对象会被放入下一代。第 <code>2</code> 代是最老的一代，因此这一代的对象幸存于垃圾回收后，仍会留在第 <code>2</code> 代。为了判定何时需要进行垃圾回收，垃圾回收器会跟踪上一次回收后，分配和释放的对象的数目。当分配对象的数量减去释放对象的数量大于阈值 <em>threshold0</em> 时，回收器开始进行垃圾回收。起初只有第 <code>0</code> 代会被检查。当上一次第 <code>1</code> 代被检查后，第 <code>0</code> 代被检查的次数多于阈值 <em>threshold1</em> 时，第 <code>1</code> 代也会被检查。相似的， <em>threshold2</em> 设置了触发第 <code>2</code> 代被垃圾回收的第 <code>1</code> 代被垃圾回收的次数。</p></li><li><p><code>gc.get_count</code>()</p><p>将当前回收计数以形为 <code>(count0, count1, count2)</code> 的元组返回。</p></li><li><p><code>gc.get_threshold</code>()</p><p>将当前回收阈值以形为 <code>(threshold0, threshold1, threshold2)</code> 的元组返回。</p></li><li><p><code>gc.get_referrers</code>(*<em>objs</em>)</p><p>返回直接引用任意一个 <em>ojbs</em> 的对象列表。这个函数只定位支持垃圾回收的容器；引用了其它对象但不支持垃圾回收的扩展类型不会被找到。需要注意的是，已经解除对 <em>objs</em> 引用的对象，但仍存在于循环引用中未被回收时，仍然会被作为引用者出现在返回的列表当中。若要获取当前正在引用 <em>objs</em> 的对象，需要调用 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.collect" target="_blank" rel="noopener"><code>collect()</code></a> 然后再调用 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.get_referrers" target="_blank" rel="noopener"><code>get_referrers()</code></a> 。在使用 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.get_referrers" target="_blank" rel="noopener"><code>get_referrers()</code></a> 返回的对象时必须要小心，因为其中一些对象可能仍在构造中因此处于暂时的无效状态。不要把 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.get_referrers" target="_blank" rel="noopener"><code>get_referrers()</code></a> 用于调试以外的其它目的。</p></li><li><p><code>gc.get_referents</code>(*<em>objs</em>)</p><p>返回被任意一个参数中的对象直接引用的对象的列表。返回的被引用对象是被参数中的对象的C语言级别方法（若存在） <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_traverse" target="_blank" rel="noopener"><code>tp_traverse</code></a> 访问到的对象，可能不是所有的实际直接可达对象。只有支持垃圾回收的对象支持 <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_traverse" target="_blank" rel="noopener"><code>tp_traverse</code></a>  方法，并且此方法只会在需要访问涉及循环引用的对象时使用。因此，可以有以下例子：一个整数对其中一个参数是直接可达的，这个整数有可能出现或不出现在返回的结果列表当中。</p></li><li><p><code>gc.is_tracked</code>(<em>obj</em>)</p><p>当对象正在被垃圾回收器监控时返回 <code>True</code> ，否则返回 <code>False</code> 。一般来说，原子类的实例不会被监控，而非原子类（如容器、用户自定义的对象）会被监控。然而，会有一些特定类型的优化以便减少垃圾回收器在简单实例（如只含有原子性的键和值的字典）上的消耗。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(<span class="number">0</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(<span class="string">"a"</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked([])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(&#123;&#125;)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(&#123;<span class="string">"a"</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(&#123;<span class="string">"a"</span>: []&#125;)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li><li><p><code>gc.freeze</code>()</p><p>冻结 gc 所跟踪的所有对象 —— 将它们移至永久代并忽略所有未来的集合。 这可以在 POSIX fork() 调用之前使用以便令对写入复制保持友好或加速收集。 并且在 POSIX fork() 调用之前的收集也可以释放页面以供未来分配，这也可能导致写入时复制，因此建议在主进程中禁用 gc 并在 fork 之前冻结，而在子进程中启用 gc。<em>3.7 新版功能.</em></p></li><li><p><code>gc.unfreeze</code>()</p><p>解冻永久代中的对象，并将它们放回到年老代中。<em>3.7 新版功能.</em></p></li><li><p><code>gc.get_freeze_count</code>()</p><p>返回永久代中的对象数量。<em>3.7 新版功能.</em></p></li></ul><p>提供以下变量仅供只读访问（你可以修改但不应该重绑定它们）：</p><ul><li><p><code>gc.garbage</code></p><p>一个回收器发现不可达而又无法被释放的对象（不可回收对象）列表。 从 Python 3.4 开始，该列表在大多数时候都应该是空的，除非使用了含有非 <code>NULL</code> <code>tp_del</code> 空位的 C 扩展类型的实例。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.DEBUG_SAVEALL" target="_blank" rel="noopener"><code>DEBUG_SAVEALL</code></a> ，则所有不可访问对象将被添加至该列表而不会被释放。<em>在 3.2 版更改:</em> 当 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-interpreter-shutdown" target="_blank" rel="noopener">interpreter shutdown</a> 即解释器关闭时，若此列表非空，会产生 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ResourceWarning" target="_blank" rel="noopener"><code>ResourceWarning</code></a> ，即资源警告，在默认情况下此警告不会被提醒。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.DEBUG_UNCOLLECTABLE" target="_blank" rel="noopener"><code>DEBUG_UNCOLLECTABLE</code></a> ，所有无法被回收的对象会被打印。<em>在 3.4 版更改:</em> 根据 <a href="https://www.python.org/dev/peps/pep-0442" target="_blank" rel="noopener"><strong>PEP 442</strong></a> ，带有 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法的对象最终不再会进入 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>gc.garbage</code></a> 。</p></li><li><p><code>gc.callbacks</code></p><p>在垃圾回收器开始前和完成后会被调用的一系列回调函数。这些回调函数在被调用时使用两个参数： <em>phase</em> 和 <em>info</em> 。<em>phase</em> 可为以下两值之一：”start”: 垃圾回收即将开始。”stop”: 垃圾回收已结束。<em>info</em> is a dict providing more information for the callback. The following keys are currently defined:”generation”（代） ：正在被回收的最久远的一代。”collected”（已回收的 ）: 当<em>phase</em> 为 “stop” 时，被成功回收的对象的数目。”uncollectable”（不可回收的）: 当 <em>phase</em> 为 “stop” 时，不能被回收并被放入 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>garbage</code></a> 的对象的数目。应用程序可以把他们自己的回调函数加入此列表。主要的使用场景有：统计垃圾回收的数据，如：不同代的回收频率、回收所花费的时间。使应用程序可以识别和清理他们自己的在 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>garbage</code></a> 中的不可回收类型的对象。<em>3.3 新版功能.</em></p></li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>以下常量被用于 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.set_debug" target="_blank" rel="noopener"><code>set_debug()</code></a> ：</p><ul><li><p><code>gc.DEBUG_STATS</code></p><p>在回收完成后打印统计信息。当回收频率设置较高时，这些信息会比较有用。</p></li><li><p><code>gc.DEBUG_COLLECTABLE</code></p><p>当发现可回收对象时打印信息。</p></li><li><p><code>gc.DEBUG_UNCOLLECTABLE</code></p><p>打印找到的不可回收对象的信息（指不能被回收器回收的不可达对象）。这些对象会被添加到 <code>garbage</code> 列表中。<em>在 3.2 版更改:</em> 当 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-interpreter-shutdown" target="_blank" rel="noopener">interpreter shutdown</a> 时，即解释器关闭时，若 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>garbage</code></a> 列表中存在对象，这些对象也会被打印输出。</p></li><li><p><code>gc.DEBUG_SAVEALL</code></p><p>设置后，所有回收器找到的不可达对象会被添加进 <em>garbage</em> 而不是直接被释放。这在调试一个内存泄漏的程序时会很有用。</p></li><li><p><code>gc.DEBUG_LEAK</code></p><p>调试内存泄漏的程序时，使回收器打印信息的调试标识位。（等价于 <code>DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_SAVEALL</code> ）。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-gc&quot;&gt;&lt;a href=&quot;#python-标准库-gc&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 gc&quot;&gt;&lt;/a&gt;python 标准库 gc&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200224_father.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="gc" scheme="https://pinghailinfeng.gitee.io/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>python standard library Built-in Exception</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/22/python-standard-library-Built-in-Exception/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/22/python-standard-library-Built-in-Exception/</id>
    <published>2020-02-22T14:47:29.000Z</published>
    <updated>2020-02-22T15:22:54.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-内置异常"><a href="#python-标准库-内置异常" class="headerlink" title="python 标准库 内置异常"></a>python 标准库 内置异常</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200221-happy-birthday.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词:</p><h1 id="worth"><a href="#worth" class="headerlink" title="worth"></a><strong>worth</strong></h1><p>n <strong>价值；意义；价值（十元、40 英镑等）的东西</strong></p><p>adj <strong>有…价值；值…钱；（指行动）值得；值得（费周折）</strong></p><p>web <strong>值得的；有……的价值；值…的</strong></p><p>短语:</p><p><strong>for all sb/it is worth</strong> 竭尽全力；拼命</p><p>for what its worth  非正式   （所说的只是个人意见）无论管不管用，不论好坏</p><p><strong>(the game is) not worth the candle</strong>  得不偿失<br>  <strong>not worth the paper its written/printed on</strong>  尤指 (法律上 )毫无价值</p><p>worth your/its salt   称职；胜任</p><p>worth sbs while    对…有好处（或用处）</p></blockquote><p>在 Python 中，所有异常必须为一个派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 的类的实例。 在带有提及一个特定类的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 子句的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句中，该子句也会处理任何派生自该类的异常类（但不处理 <em>它</em> 所派生出的异常类）。 通过子类化创建的两个不相关异常类永远是不等效的，既使它们具有相同的名称。</p><p>下面列出的内置异常可通过解释器或内置函数来生成。除非另有说明，它们都会具有一个提示导致错误详细原因的“关联值”。 这可以是一个字符串或由多个信息项（例如一个错误码和一个解释错误的字符串）组成的元组。 关联值通常会作为参数被传递给异常类的构造器。</p><p>用户代码可以引发内置异常。 这可被用于测试异常处理程序或报告错误条件，“就像” 在解释器引发了相同异常的情况时一样；但是请注意，没有任何机制能防止用户代码引发不适当的错误。</p><p>内置异常类可以被子类化以定义新的异常；鼓励程序员从 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 类或它的某个子类而不是从 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 来派生新的异常。 关于定义异常的更多信息可以在 Python 教程的 <a href="https://docs.python.org/zh-cn/3.8/tutorial/errors.html#tut-userexceptions" target="_blank" rel="noopener">用户自定义异常</a> 部分查看。</p><p>当在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句中引发（或重新引发）异常时，<code>__context__</code> 会被自动设为所捕获的最后一个异常；如果新的异常未被处理，则最终显示的回溯信息将包括原始的异常和最后的异常。</p><p>当引发一个新的异常（而不是简单地使用 <code>raise</code> 来重新引发当前在处理的异常）时，隐式的异常上下文可以通过使用带有 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#raise" target="_blank" rel="noopener"><code>raise</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 来补充一个显式的原因:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> new_exc <span class="keyword">from</span> original_exc</span><br></pre></td></tr></table></figure><p>跟在 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 之后的表达式必须为一个异常或 <code>None</code>。 它将在所引发的异常上被设置为 <code>__cause__</code>。 设置 <code>__cause__</code> 还会隐式地将 <code>__suppress_context__</code> 属性设为 <code>True</code>，这样使用 <code>raise new_exc from None</code> 可以有效地将旧异常替换为新异常来显示其目的 (例如将 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>)，同时让旧异常在 <code>__context__</code> 中保持可用状态以便在调试时进行内省。</p><p>除了异常本身的回溯以外，默认的回溯还会显示这些串连的异常。 <code>__cause__</code> 中的显式串连异常如果存在将总是显示。 <code>__context__</code> 中的隐式串连异常仅在 <code>__cause__</code> 为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 并且 <code>__suppress_context__</code> 为假值时显示。</p><p>不论在哪种情况下，异常本身总会在任何串连异常之后显示，以便回溯的最后一行总是显示所引发的最后一个异常。</p><h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><p>下列异常主要被用作其他异常的基类。</p><ul><li><p><em>exception</em> <code>BaseException</code></p><p>所有内置异常的基类。 它不应该被用户自定义类直接继承 (这种情况请使用 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a>)。 如果在此类的实例上调用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a>，则会返回实例的参数表示，或者当没有参数时返回空字符串。</p><ul><li><p><code>args</code></p><p>传给异常构造器的参数元组。 某些内置异常 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>) 接受特定数量的参数并赋予此元组中的元素特殊的含义，而其他异常通常只接受一个给出错误信息的单独字符串。</p></li><li><p><code>with_traceback</code>(<em>tb</em>)</p><p>此方法将 <em>tb</em> 设为异常的新回溯信息并返回该异常对象。 它通常以如下的形式在异常处理程序中使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">except</span> SomeException:</span><br><span class="line">    tb = sys.exc_info()[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">raise</span> OtherException(...).with_traceback(tb)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><em>exception</em> <code>Exception</code></p><p>所有内置的非系统退出类异常都派生自此类。 所有用户自定义异常也应当派生自此类。</p></li><li><p><em>exception</em> <code>ArithmeticError</code></p><p>此基类用于派生针对各种算术类错误而引发的内置异常: <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ZeroDivisionError" target="_blank" rel="noopener"><code>ZeroDivisionError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FloatingPointError" target="_blank" rel="noopener"><code>FloatingPointError</code></a>。</p></li><li><p><em>exception</em> <code>BufferError</code></p><p>当与 <a href="https://docs.python.org/zh-cn/3.8/c-api/buffer.html#bufferobjects" target="_blank" rel="noopener">缓冲区</a> 相关的操作无法执行时将被引发。</p></li><li><p><em>exception</em> <code>LookupError</code></p><p>此基类用于派生当映射或序列所使用的键或索引无效时引发的异常: <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。 这可以通过 <a href="https://docs.python.org/zh-cn/3.8/library/codecs.html#codecs.lookup" target="_blank" rel="noopener"><code>codecs.lookup()</code></a> 来直接引发。</p></li></ul><h2 id="具体异常"><a href="#具体异常" class="headerlink" title="具体异常"></a>具体异常</h2><p>以下异常属于经常被引发的异常。</p><ul><li><p><em>exception</em> <code>AssertionError</code></p><p>当 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#assert" target="_blank" rel="noopener"><code>assert</code></a> 语句失败时将被引发。</p></li><li><p><em>exception</em> <code>AttributeError</code></p><p>当属性引用 (参见 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#attribute-references" target="_blank" rel="noopener">属性引用</a>) 或赋值失败时将被引发。 （当一个对象根本不支持属性引用或属性赋值时则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。）</p></li><li><p><em>exception</em> <code>EOFError</code></p><p>当 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#input" target="_blank" rel="noopener"><code>input()</code></a> 函数未读取任何数据即达到文件结束条件 (EOF) 时将被引发。 （另外，<code>io.IOBase.read()</code> 和 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.readline" target="_blank" rel="noopener"><code>io.IOBase.readline()</code></a> 方法在遇到 EOF 则将返回一个空字符串。）</p></li><li><p><em>exception</em> <code>FloatingPointError</code></p><p>目前未被使用。</p></li><li><p><em>exception</em> <code>GeneratorExit</code></p><p>当一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 或 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 被关闭时将被引发；参见 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.close" target="_blank" rel="noopener"><code>generator.close()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine.close" target="_blank" rel="noopener"><code>coroutine.close()</code></a>。 它直接继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a>，因为从技术上来说它并不是一个错误。</p></li><li><p><em>exception</em> <code>ImportError</code></p><p>当 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句尝试加载模块遇到麻烦时将被引发。 并且当 <code>from ... import</code> 中的 “from list” 存在无法找到的名称时也会被引发。<code>name</code> 与 <code>path</code> 属性可通过对构造器使用仅关键字参数来设定。 设定后它们将分别表示被尝试导入的模块名称与触发异常的任意文件所在路径。<em>在 3.3 版更改:</em> 添加了 <code>name</code> 与 <code>path</code> 属性。</p></li><li><p><em>exception</em> <code>ModuleNotFoundError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a> 的子类，当一个模块无法被定位时将由 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 引发。 当在 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中找到 <code>None</code> 时也会被引发。</p><p><em>3.6 新版功能.</em></p></li><li><p><em>exception</em> <code>IndexError</code></p><p>当序列抽取超出范围时将被引发。 （切片索引会被静默截短到允许的范围；如果指定索引不是整数则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 会被引发。）</p></li><li><p><em>exception</em> <code>KeyError</code></p><p>当在现有键集合中找不到指定的映射（字典）键时将被引发。</p></li><li><p><em>exception</em> <code>KeyboardInterrupt</code></p><p>当用户按下中断键 (通常为 Control-C 或 Delete) 时将被引发。 在执行期间，会定期检测中断信号。 该异常继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 以确保不会被处理 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的代码意外捕获，这样可以避免退出解释器。</p></li><li><p><em>exception</em> <code>MemoryError</code></p><p>当一个操作耗尽内存但情况仍可（通过删除一些对象）进行挽救时将被引发。 关联的值是一个字符串，指明是哪种（内部）操作耗尽了内存。 请注意由于底层的内存管理架构（C 的 <code>malloc()</code> 函数），解释器也许并不总是能够从这种情况下完全恢复；但它毕竟可以引发一个异常，这样就能打印出栈回溯信息，以便找出导致问题的失控程序。</p></li><li><p><em>exception</em> <code>NameError</code></p><p>当某个局部或全局名称未找到时将被引发。 此异常仅用于非限定名称。 关联的值是一条错误信息，其中包含未找到的名称。</p></li><li><p><em>exception</em> <code>NotImplementedError</code></p><p>此异常派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 在用户自定义的基类中，抽象方法应当在其要求所派生类重载该方法，或是在其要求所开发的类提示具体实现尚待添加时引发此异常。</p><blockquote><p>它不应当用来表示一个运算符或方法根本不能被支持 – 在此情况下应当让特定运算符 / 方法保持未定义，或者在子类中将其设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p><p><code>NotImplementedError</code> 和 <code>NotImplemented</code> 不可互换，即使它们有相似的名称和用途。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#NotImplemented" target="_blank" rel="noopener"><code>NotImplemented</code></a> 了解有关何时使用它们的详细说明。</p></blockquote></li><li><p><em>exception</em> <code>OSError</code>([<em>arg</em>])</p><p><em>exception</em> <code>OSError</code>(<em>errno</em>, <em>strerror</em>[, <em>filename</em>[, <em>winerror</em>[, <em>filename2</em>]]])</p><p>此异常在一个系统函数返回系统相关的错误时将被引发，此类错误包括 I/O 操作失败例如 “文件未找到” 或 “磁盘已满” 等（不包括非法参数类型或其他偶然性错误）。</p><p>构造器的第二种形式可设置如下所述的相应属性。 如果未指定这些属性则默认为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。 为了能向下兼容，如果传入了三个参数，则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException.args" target="_blank" rel="noopener"><code>args</code></a> 属性将仅包含由前两个构造器参数组成的 2 元组。</p><p>构造器实际返回的往往是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的某个子类，如下文 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#os-exceptions" target="_blank" rel="noopener">OS exceptions</a> 中所描述的。 具体的子类取决于最终的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 值。 此行为仅在直接或通过别名来构造 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 时发生，并且在子类化时不会被继承。</p><ul><li><p><code>errno</code></p><p>来自于 C 变量 <code>errno</code> 的数字错误码。</p></li><li><p><code>winerror</code></p><p>在 Windows 下，此参数将给出原生的 Windows 错误码。 而 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 属性将是该原生错误码在 POSIX 平台下的近似转换形式。在 Windows 下，如果 <em>winerror</em> 构造器参数是一个整数，则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 属性会根据 Windows 错误码来确定，而 <em>errno</em> 参数会被忽略。 在其他平台上，<em>winerror</em> 参数会被忽略，并且 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.winerror" target="_blank" rel="noopener"><code>winerror</code></a> 属性将不存在。</p></li><li><p><code>strerror</code></p><p>操作系统所提供的相应错误信息。 它在 POSIX 平台中由 C 函数 <code>perror()</code> 来格式化，在 Windows 中则是由 <code>FormatMessage()</code>。</p></li><li><p><code>filename</code></p></li><li><p><code>filename2</code></p><p>对于与文件系统路径有关 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unlink" target="_blank" rel="noopener"><code>os.unlink()</code></a>) 的异常，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename" target="_blank" rel="noopener"><code>filename</code></a> 是传给函数的文件名。 对于涉及两个文件系统路径的函数 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a>)，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename2" target="_blank" rel="noopener"><code>filename2</code></a> 将是传给函数的第二个文件名。</p></li></ul><p><em>在 3.3 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EnvironmentError" target="_blank" rel="noopener"><code>EnvironmentError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IOError" target="_blank" rel="noopener"><code>IOError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#WindowsError" target="_blank" rel="noopener"><code>WindowsError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.error" target="_blank" rel="noopener"><code>socket.error</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.error" target="_blank" rel="noopener"><code>select.error</code></a> 与 <code>mmap.error</code> 已被合并到 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>，构造器可能返回其中一个子类。</p><p><em>在 3.4 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename" target="_blank" rel="noopener"><code>filename</code></a> 属性现在将是传给函数的原始文件名，而不是经过编码或基于文件系统编码进行解码之后的名称。 此外还添加了 <em>filename2</em> 构造器参数和属性。</p></li><li><p><em>exception</em> <code>OverflowError</code></p><p>当算术运算的结果大到无法表示时将被引发。 这对整数来说不可能发生（宁可引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#MemoryError" target="_blank" rel="noopener"><code>MemoryError</code></a> 也不会放弃尝试）。 但是出于历史原因，有时也会在整数超出要求范围的情况下引发 OverflowError。 因为在 C 中缺少对浮点异常处理的标准化，大多数浮点运算都不会做检查。</p></li><li><p><em>exception</em> <code>RecursionError</code></p><p>此异常派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 它会在解释器检测发现超过最大递归深度 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getrecursionlimit" target="_blank" rel="noopener"><code>sys.getrecursionlimit()</code></a>) 时被引发。<em>3.5 新版功能:</em> 在此之前将只引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p></li><li><p><em>exception</em> <code>ReferenceError</code></p><p>此异常将在使用 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.proxy" target="_blank" rel="noopener"><code>weakref.proxy()</code></a> 函数所创建的弱引用来访问该引用的某个已被作为垃圾回收的属性时被引发。 有关弱引用的更多信息请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块。</p></li><li><p><em>exception</em> <code>RuntimeError</code></p><p>当检测到一个不归属于任何其他类别的错误时将被引发。 关联的值是一个指明究竟发生了什么问题的字符串。</p></li><li><p><em>exception</em> <code>StopIteration</code></p><p>由内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法所引发，用来表示该迭代器不能产生下一项。该异常对象只有一个属性 <code>value</code>，它在构造该异常时作为参数给出，默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。当一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 或 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 函数返回时，将引发一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 实例，函数返回的值将被用作异常构造器的 <code>value</code> 形参。如果某个生成器代码直接或间接地引发了 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a>，它会被转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> (并将 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 保留为导致新异常的原因)。<em>在 3.3 版更改:</em> 添加了 <code>value</code> 属性及其被生成器函数用作返回值的功能。<em>在 3.5 版更改:</em> 引入了通过 <code>from __future__ import generator_stop</code> 来实现 RuntimeError 转换，参见 <a href="https://www.python.org/dev/peps/pep-0479" target="_blank" rel="noopener"><strong>PEP 479</strong></a>。<em>在 3.7 版更改:</em> 默认对所有代码启用 <a href="https://www.python.org/dev/peps/pep-0479" target="_blank" rel="noopener"><strong>PEP 479</strong></a>: 在生成器中引发的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 错误将被转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p></li><li><p><em>exception</em> <code>StopAsyncIteration</code></p><p>必须由一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterator" target="_blank" rel="noopener">asynchronous iterator</a> 对象的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__" target="_blank" rel="noopener"><code>__anext__()</code></a> 方法来引发以停止迭代操作。<em>3.5 新版功能.</em></p></li><li><p><em>exception</em> <code>SyntaxError</code></p><p>当解析器遇到语法错误时将被引发。 这可以发生在 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句，对内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 的调用，或者读取原始脚本或标准输入（也包括交互模式）的时候。该类的实例包含有属性 <code>filename</code>, <code>lineno</code>, <code>offset</code> 和 <code>text</code> 用于方便地访问相应的详细信息。 异常实例的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a> 仅返回消息文本。</p></li><li><p><em>exception</em> <code>IndentationError</code></p><p>与不正确的缩进相关的语法错误的基类。 这是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>TabError</code></p><p>当缩进包含对制表符和空格符不一致的使用时将被引发。 这是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndentationError" target="_blank" rel="noopener"><code>IndentationError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>SystemError</code></p><p>当解释器发现内部错误，但情况看起来尚未严重到要放弃所有希望时将被引发。 关联的值是一个指明发生了什么问题的字符串（表示为低层级的符号）。你应当将此问题报告给你所用 Python 解释器的作者或维护人员。 请确认报告 Python 解释器的版本号 (<code>sys.version</code>; 它也会在交互式 Python 会话开始时被打印出来)，具体的错误消息（异常所关联的值）以及可能触发该错误的程序源码。</p></li><li><p><em>exception</em> <code>SystemExit</code></p><p>此异常由 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 函数引发。 它继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 以确保不会被处理 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的代码意外捕获。 这允许此异常正确地向上传播并导致解释器退出。 如果它未被处理，则 Python 解释器就将退出；不会打印任何栈回溯信息。 构造器接受的可选参数与传递给 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 的相同。 如果该值为一个整数，则它指明系统退出状态码（会传递给 C 的 <code>exit()</code> 函数）；如果该值为 <code>None</code>，则退出状态码为零；如果该值为其他类型（例如字符串），则会打印对象的值并将退出状态码设为一。对 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 的调用会被转换为一个异常以便能执行清理处理程序 (<a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句)，并且使得调试器可以执行一段脚本而不必冒失去控制的风险。 如果绝对确实地需要立即退出（例如在调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>os.fork()</code></a> 之后的子进程中）则可使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os._exit" target="_blank" rel="noopener"><code>os._exit()</code></a>.<code>code</code>传给构造器的退出状态码或错误信息（默认为 <code>None</code>。）</p></li><li><p><em>exception</em> <code>TypeError</code></p><p>当一个操作或函数被应用于类型不适当的对象时将被引发。 关联的值是一个字符串，给出有关类型不匹配的详情。此异常可以由用户代码引发，以表明尝试对某个对象进行的操作不受支持也不应当受支持。 如果某个对象应当支持给定的操作但尚未提供相应的实现，所要引发的适当异常应为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a>。传入参数的类型错误 (例如在要求 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 时却传入了 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a>) 应当导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>，但传入参数的值错误 (例如传入要求范围之外的数值) 则应当导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。</p></li><li><p><em>exception</em> <code>UnboundLocalError</code></p><p>当在函数或方法中对某个局部变量进行引用，但该变量并未绑定任何值时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NameError" target="_blank" rel="noopener"><code>NameError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>UnicodeError</code></p><p>当发生与 Unicode 相关的编码或解码错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 的一个子类。<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 具有一些描述编码或解码错误的属性。 例如 <code>err.object[err.start:err.end]</code> 会给出导致编解码器失败的特定无效输入。<code>encoding</code>引发错误的编码名称。<code>reason</code>描述特定编解码器错误的字符串。<code>object</code>编解码器试图要编码或解码的对象。<code>start</code><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 中无效数据的开始位置索引。<code>end</code><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 中无效数据的末尾位置索引（不含）。</p></li><li><p><em>exception</em> <code>UnicodeEncodeError</code></p><p>当在编码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>UnicodeDecodeError</code></p><p>当在解码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>UnicodeTranslateError</code></p><p>在转写过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>ValueError</code></p><p>当操作或函数接收到具有正确类型但值不适合的参数，并且情况不能用更精确的异常例如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 来描述时将被引发。</p></li><li><p><em>exception</em> <code>ZeroDivisionError</code></p><p>当除法或取余运算的第二个参数为零时将被引发。 关联的值是一个字符串，指明操作数和运算的类型。</p></li></ul><p>下列异常被保留以与之前的版本相兼容；从 Python 3.3 开始，它们都是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的别名。</p><ul><li><em>exception</em> <code>EnvironmentError</code></li></ul><ul><li><em>exception</em> <code>IOError</code></li></ul><ul><li><p><em>exception</em> <code>WindowsError</code></p><p>限在 Windows 中可用。</p></li></ul><h3 id="OS-异常"><a href="#OS-异常" class="headerlink" title="OS 异常"></a>OS 异常</h3><p>下列异常均为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的子类，它们将根据系统错误代码被引发。</p><ul><li><p><em>exception</em> <code>BlockingIOError</code></p><p>当一个操作会被某个设置为非阻塞操作的对象（例如套接字）所阻塞时将被引发。 对应于 <code>errno</code> <code>EAGAIN</code>, <code>EALREADY</code>, <code>EWOULDBLOCK</code> 和 <code>EINPROGRESS</code>。除了 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 已有的属性，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BlockingIOError" target="_blank" rel="noopener"><code>BlockingIOError</code></a> 还有一个额外属性：<code>characters_written</code>一个整数，表示在被阻塞前已写入到流的字符数。 当使用来自 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#module-io" target="_blank" rel="noopener"><code>io</code></a> 模块的带缓冲 I/O 类时此属性可用。</p></li><li><p><em>exception</em> <code>ChildProcessError</code></p><p>当一个子进程上的操作失败时将被引发。 对应于 <code>errno</code> <code>ECHILD</code>。</p></li><li><p><em>exception</em> <code>ConnectionError</code></p><p>与连接相关问题的基类。其子类有 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BrokenPipeError" target="_blank" rel="noopener"><code>BrokenPipeError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionAbortedError" target="_blank" rel="noopener"><code>ConnectionAbortedError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionRefusedError" target="_blank" rel="noopener"><code>ConnectionRefusedError</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionResetError" target="_blank" rel="noopener"><code>ConnectionResetError</code></a>。</p></li><li><p><em>exception</em> <code>BrokenPipeError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当试图写入另一端已被关闭的管道，或是试图写入已关闭写入的套接字时将被引发。 对应于 <code>errno</code> <code>EPIPE</code> 和 <code>ESHUTDOWN</code>。</p></li><li><p><em>exception</em> <code>ConnectionAbortedError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接尝试被对端中止时将被引发。 对应于 <code>errno</code> <code>ECONNABORTED</code>。</p></li><li><p><em>exception</em> <code>ConnectionRefusedError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接尝试被对端拒绝时将被引发。 对应于 <code>errno</code> <code>ECONNREFUSED</code>。</p></li><li><p><em>exception</em> <code>ConnectionResetError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接被对端重置时将被引发。 对应于 <code>errno</code> <code>ECONNRESET</code>。</p></li><li><p><em>exception</em> <code>FileExistsError</code></p><p>当试图创建一个已存在的文件或目录时将被引发。 对应于 <code>errno</code> <code>EEXIST</code>。</p></li><li><p><em>exception</em> <code>FileNotFoundError</code></p><p>当所请求的文件或目录不存在时将被引发。 对应于 <code>errno</code> <code>ENOENT</code>。</p></li><li><p><em>exception</em> <code>InterruptedError</code></p><p>当系统调用被输入信号中断时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EINTR" target="_blank" rel="noopener"><code>EINTR</code></a>。<em>在 3.5 版更改:</em> 当系统调用被某个信号中断时，Python 现在会重试系统调用，除非该信号的处理程序引发了其它异常 (原理参见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>) 而不是引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a>。</p></li><li><p><em>exception</em> <code>IsADirectoryError</code></p><p>当请求对一个目录执行文件操作 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.remove" target="_blank" rel="noopener"><code>os.remove()</code></a>) 将被引发。 对应于 <code>errno</code> <code>EISDIR</code>。</p></li><li><p><em>exception</em> <code>NotADirectoryError</code></p><p>当请求对一个非目录对象执行目录操作 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>os.listdir()</code></a>) 时将被引发。 对应于 <code>errno</code> <code>ENOTDIR</code>。</p></li><li><p><em>exception</em> <code>PermissionError</code></p><p>当在没有足够操作权限的情况下试图执行某个操作时将被引发 —— 例如缺少文件系统权限。 对应于 <code>errno</code> <code>EACCES</code> 和 <code>EPERM</code>。</p></li><li><p><em>exception</em> <code>ProcessLookupError</code></p><p>当给定的进程不存在时将被引发。 对应于 <code>errno</code> <code>ESRCH</code>。</p></li><li><p><em>exception</em> <code>TimeoutError</code></p><p>当一个系统函数发生系统级超时的情况下将被引发。 对应于 <code>errno</code> <code>ETIMEDOUT</code>。</p></li></ul><p><em>3.3 新版功能:</em> 添加了以上所有 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的子类。</p><blockquote><p>参见：<a href="https://www.python.org/dev/peps/pep-3151" target="_blank" rel="noopener"><strong>PEP 3151</strong></a> - 重写 OS 和 IO 异常的层次结构</p></blockquote><h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>下列异常被用作警告类别；请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/warnings.html#warning-categories" target="_blank" rel="noopener">警告类别</a> 文档了解详情。</p><ul><li><p><em>exception</em> <code>Warning</code></p><p>警告类别的基类。</p></li><li><p><em>exception</em> <code>UserWarning</code></p><p>用户代码所产生警告的基类。</p></li><li><p><em>exception</em> <code>DeprecationWarning</code></p><p>如果所发出的警告是针对其他 Python 开发者的，则以此作为与已弃用特性相关警告的基类。</p></li><li><p><em>exception</em> <code>PendingDeprecationWarning</code></p><p>对于已过时并预计在未来弃用，但目前尚未弃用的特性相关警告的基类。这个类很少被使用，因为针对未来可能的弃用发出警告的做法并不常见，而针对当前已有的弃用则推荐使用 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#DeprecationWarning" target="_blank" rel="noopener"><code>DeprecationWarning</code></a>。</p></li><li><p><em>exception</em> <code>SyntaxWarning</code></p><p>与模糊的语法相关的警告的基类。</p></li><li><p><em>exception</em> <code>RuntimeWarning</code></p><p>与模糊的运行时行为相关的警告的基类。</p></li><li><p><em>exception</em> <code>FutureWarning</code></p><p>如果所发出的警告是针对以 Python 所编写应用的最终用户的，则以此作为与已弃用特性相关警告的基类。</p></li><li><p><em>exception</em> <code>ImportWarning</code></p><p>与在模块导入中可能的错误相关的警告的基类。</p></li><li><p><em>exception</em> <code>UnicodeWarning</code></p><p>与 Unicode 相关的警告的基类。</p></li><li><p><em>exception</em> <code>BytesWarning</code></p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 相关的警告的基类。</p></li><li><p><em>exception</em> <code>ResourceWarning</code></p><p>与资源使用相关的警告的基类。 会被默认的警告过滤器忽略。<em>3.2 新版功能.</em></p></li></ul><h2 id="异常层次结构"><a href="#异常层次结构" class="headerlink" title="异常层次结构"></a>异常层次结构</h2><p>内置异常的类层级结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- StopAsyncIteration</span><br><span class="line">      +-- ArithmeticError</span><br><span class="line">      |    +-- FloatingPointError</span><br><span class="line">      |    +-- OverflowError</span><br><span class="line">      |    +-- ZeroDivisionError</span><br><span class="line">      +-- AssertionError</span><br><span class="line">      +-- AttributeError</span><br><span class="line">      +-- BufferError</span><br><span class="line">      +-- EOFError</span><br><span class="line">      +-- ImportError</span><br><span class="line">      |    +-- ModuleNotFoundError</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br><span class="line">      +-- MemoryError</span><br><span class="line">      +-- NameError</span><br><span class="line">      |    +-- UnboundLocalError</span><br><span class="line">      +-- OSError</span><br><span class="line">      |    +-- BlockingIOError</span><br><span class="line">      |    +-- ChildProcessError</span><br><span class="line">      |    +-- ConnectionError</span><br><span class="line">      |    |    +-- BrokenPipeError</span><br><span class="line">      |    |    +-- ConnectionAbortedError</span><br><span class="line">      |    |    +-- ConnectionRefusedError</span><br><span class="line">      |    |    +-- ConnectionResetError</span><br><span class="line">      |    +-- FileExistsError</span><br><span class="line">      |    +-- FileNotFoundError</span><br><span class="line">      |    +-- InterruptedError</span><br><span class="line">      |    +-- IsADirectoryError</span><br><span class="line">      |    +-- NotADirectoryError</span><br><span class="line">      |    +-- PermissionError</span><br><span class="line">      |    +-- ProcessLookupError</span><br><span class="line">      |    +-- TimeoutError</span><br><span class="line">      +-- ReferenceError</span><br><span class="line">      +-- RuntimeError</span><br><span class="line">      |    +-- NotImplementedError</span><br><span class="line">      |    +-- RecursionError</span><br><span class="line">      +-- SyntaxError</span><br><span class="line">      |    +-- IndentationError</span><br><span class="line">      |         +-- TabError</span><br><span class="line">      +-- SystemError</span><br><span class="line">      +-- TypeError</span><br><span class="line">      +-- ValueError</span><br><span class="line">      |    +-- UnicodeError</span><br><span class="line">      |         +-- UnicodeDecodeError</span><br><span class="line">      |         +-- UnicodeEncodeError</span><br><span class="line">      |         +-- UnicodeTranslateError</span><br><span class="line">      +-- Warning</span><br><span class="line">           +-- DeprecationWarning</span><br><span class="line">           +-- PendingDeprecationWarning</span><br><span class="line">           +-- RuntimeWarning</span><br><span class="line">           +-- SyntaxWarning</span><br><span class="line">           +-- UserWarning</span><br><span class="line">           +-- FutureWarning</span><br><span class="line">           +-- ImportWarning</span><br><span class="line">           +-- UnicodeWarning</span><br><span class="line">           +-- BytesWarning</span><br><span class="line">           +-- ResourceWarning</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-内置异常&quot;&gt;&lt;a href=&quot;#python-标准库-内置异常&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 内置异常&quot;&gt;&lt;/a&gt;python 标准库 内置异常&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200221-happy-birthday.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="Exception" scheme="https://pinghailinfeng.gitee.io/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>python standard library cmd</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/21/python-standard-library-cmd/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/21/python-standard-library-cmd/</id>
    <published>2020-02-21T14:20:08.000Z</published>
    <updated>2020-02-22T15:14:11.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-cmd模块"><a href="#python-标准库-cmd模块" class="headerlink" title="python 标准库 cmd模块"></a>python 标准库 cmd模块</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200221_zhuakuang.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词:</p><p> collapse </p><p>近义词:</p><p>crash<br>breakdown<br>crumble<br>fall apart </p><p>例句:</p><p> 我曾经神经崩溃过。那是一次痛苦的经历。<br>I suffered a nervous breakdown. It was a traumatic experience </p><p> 他能明显地看出我快要精神崩溃了。<br>It was plain to him that I was having a nervous breakdown </p></blockquote><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/cmd.py" target="_blank" rel="noopener">Lib/cmd.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 类提供简单框架用于编写面向行的命令解释器。 这些通常对测试工具，管理工具和原型有用，这些工具随后将被包含在更复杂的接口中。</p><ul><li><p><em>class</em> <code>cmd.Cmd</code>(<em>completekey=’tab’</em>, <em>stdin=None</em>, <em>stdout=None</em>)</p><p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 实例或子类实例是面向行的解释器框架结构。 实例化 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 本身是没有充分理由的， 它作为自定义解释器类的超类是非常有用的为了继承 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 的方法并且封装动作方法。可选参数 <em>completekey</em> 是完成键的 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 名称；默认是 Tab 。如果 <em>completekey</em> 不是 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 并且 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 是可用的， 命令完成会自动完成。可选参数 <em>stdin</em> 和 <em>stdout</em> 指定了Cmd实例或子类实例将用于输入和输出的输入和输出文件对象。如果没有指定，他们将默认为 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdout" target="_blank" rel="noopener"><code>sys.stdout</code></a> 。如果你想要使用一个给定的 <em>stdin</em> ，确保将实例的 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.use_rawinput" target="_blank" rel="noopener"><code>use_rawinput</code></a> 属性设置为 <code>False</code> ，否则 <em>stdin</em> 将被忽略</p></li></ul><h2 id="Cmd-对象"><a href="#Cmd-对象" class="headerlink" title="Cmd 对象"></a>Cmd 对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 实例有下列方法：</p><ul><li><p><code>Cmd.cmdloop</code>(<em>intro=None</em>)</p><p>反复发出提示，接受输入，从收到的输入中解析出一个初始前缀，并分派给操作方法，将其余的行作为参数传递给它们。可选参数是在第一个提示之前发布的横幅或介绍字符串（这将覆盖 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.intro" target="_blank" rel="noopener"><code>intro</code></a> 类属性）。如果 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 继承模块被加载，输入将自动继承类似 <strong>bash</strong>的历史列表编辑（例如， Control-P 滚动回到最后一个命令， Control-N 转到下一个命令，以 Control-F 非破坏性的方式向右 Control-B 移动光标，破坏性地等）。输入的文件结束符被作为字符串传回 <code>&#39;EOF&#39;</code> 。解释器实例将会识别命令名称 <code>foo</code> 当且仅当它有方法 <code>do_foo()</code> 。有一个特殊情况，分派始于字符 <code>&#39;?&#39;</code> 的行到方法 <code>do_help()</code> 。另一种特殊情况，分派始于字符 <code>&#39;!&#39;</code> 的行到方法 <code>do_shell()</code> （如果定义了这个方法）这个方法将返回当 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.postcmd" target="_blank" rel="noopener"><code>postcmd()</code></a> 方法返回一个真值 。参数 <em>stop</em> 到 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.postcmd" target="_blank" rel="noopener"><code>postcmd()</code></a> 是命令对应的返回值 <code>do_*()</code> 的方法。如果激活了完成，全部命令将会自动完成，并且通过调用 <code>complete_foo()</code> 参数 <em>text</em> , <em>line</em>, <em>begidx</em> ,和 <em>endidx</em> 完成全部命令参数。 <em>text</em> 是我们试图匹配的字符串前缀，所有返回的匹配项必须以它为开头。 <em>line</em> 是删除了前导空格的当前的输入行， <em>begidx</em> 和 <em>endidx</em> 是前缀文本的开始和结束索引。，可以用于根据参数位置提供不同的完成。所有 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 的子类继承一个预定义 <code>do_help()</code> 。 这个方法使用参数 <code>&#39;bar&#39;</code> 调用， 调用对应的方法 <code>help_bar()</code> ，如果不存在，打印 <code>do_bar()</code> 的文档字符串，如果可用。没有参数的情况下， <code>do_help()</code> 方法会列出所有可用的帮助主题 （即所有具有相应的 <code>help_*()</code> 方法或命令的 文档字符串），也会列举所有未被记录的命令。</p></li><li><p><code>Cmd.onecmd</code>(<em>str</em>)</p><p>解释该参数，就好像它是为响应提示而键入的一样。 这可能会被覆盖，但通常不应该被覆盖; 请参阅： <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.precmd" target="_blank" rel="noopener"><code>precmd()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.postcmd" target="_blank" rel="noopener"><code>postcmd()</code></a> 方法，用于执行有用的挂钩。 返回值是一个标志，指示解释器对命令的解释是否应该停止。 如果命令 <em>str</em> 有一个 <code>do_*()</code> 方法，则返回该方法的返回值，否则返回 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.default" target="_blank" rel="noopener"><code>default()</code></a> 方法的返回值。</p></li><li><p><code>Cmd.emptyline</code>()</p><p>在响应提示输入空行时调用的方法。如果此方法未被覆盖，则重复输入的最后一个非空命令。</p></li><li><p><code>Cmd.default</code>(<em>line</em>)</p><p>当命令前缀不能被识别的时候在输入行调用的方法。如果此方法未被覆盖，它将输出一个错误信息并返回。</p></li><li><p><code>Cmd.completedefault</code>(<em>text</em>, <em>line</em>, <em>begidx</em>, <em>endidx</em>)</p><p>当没有特定于命令的 <code>complete_*()</code> 方法可用时，调用此方法完成输入行。默认情况下，它返回一个空列表。</p></li><li><p><code>Cmd.precmd</code>(<em>line</em>)</p><p>钩方法在命令行 <em>line</em> 被解释之前执行，但是在输入提示被生成和发出后。这个方法是一个在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 中的存根；它的存在是为了被子类覆盖。返回值被用作 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.onecmd" target="_blank" rel="noopener"><code>onecmd()</code></a> 方法执行的命令； <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.precmd" target="_blank" rel="noopener"><code>precmd()</code></a> 的实现或许会重写命令或者简单的返回 <em>line</em> 不变。</p></li><li><p><code>Cmd.postcmd</code>(<em>stop</em>, <em>line</em>)</p><p>钩方法只在命令调度完成后执行。这个方法是一个在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 中的存根；它的存在是为了子类被覆盖。 <em>line</em> 是被执行的命令行， <em>stop</em> 是一个表示在调用 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.postcmd" target="_blank" rel="noopener"><code>postcmd()</code></a> 之后是否终止执行的标志；这将作为 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.onecmd" target="_blank" rel="noopener"><code>onecmd()</code></a> 方法的返回值。这个方法的返回值被用作与 <em>stop</em> 相关联的内部标志的新值；返回 false 将导致解释继续。</p></li><li><p><code>Cmd.preloop</code>()</p><p>钩方法当 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 被调用时执行一次。方法是一个在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 中的存根；它的存在是为了被子类覆盖。</p></li><li><p><code>Cmd.postloop</code>()</p><p>钩方法在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 即将返回时执行一次。这个方法是一个在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 中的存根；塔顶存在是为了被子类覆盖。</p></li></ul><p>Instances of <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> subclasses have some public instance variables:</p><ul><li><p><code>Cmd.prompt</code></p><p>发出提示以请求输入。</p></li><li><p><code>Cmd.identchars</code></p><p>接受命令前缀的字符串。</p></li><li><p><code>Cmd.lastcmd</code></p><p>看到最后一个非空命令前缀。</p></li><li><p><code>Cmd.cmdqueue</code></p><p>排队的输入行列表。当需要新的输入时，在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 中检查 cmdqueue 列表；如果它不是空的，它的元素将被按顺序处理，就像在提示符处输入一样。</p></li><li><p><code>Cmd.intro</code></p><p>要作为简介或横幅发出的字符串。 可以通过给 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 方法一个参数来覆盖它。</p></li><li><p><code>Cmd.doc_header</code></p><p>如果帮助输出具有记录命令的段落，则发出头文件。</p></li><li><p><code>Cmd.misc_header</code></p><p>如果帮助输出其他帮助主题的部分（即与 <code>do_*()</code> 方法没有关联的 <code>help_*()</code> 方法），则发出头文件。</p></li><li><p><code>Cmd.undoc_header</code></p><p>如果帮助输出未被记录命令的部分（即与 <code>help_*()</code> 方法没有关联的 <code>do_*()</code> 方法），则发出头文件。</p></li><li><p><code>Cmd.ruler</code></p><p>用于在帮助信息标题的下方绘制分隔符的字符，如果为空，则不绘制标尺线。 这个字符默认是 <code>&#39;=&#39;</code> 。</p></li><li><p><code>Cmd.use_rawinput</code></p><p>这是一个标志，默认为 true 。如果为 true ，, <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#input" target="_blank" rel="noopener"><code>input()</code></a> 先是提示并且阅读下一个命令；如果为 false ， <code>sys.stdout.write()</code> 和 <code>sys.stdin.readline()</code> 被使用。（这意味着解释器将会自动支持类似于 <strong>Emacs</strong>的行编辑和命令历史记录按键操作，通过导入 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 在支持它的系统上。）</p></li></ul><h2 id="Cmd-例子"><a href="#Cmd-例子" class="headerlink" title="Cmd 例子"></a>Cmd 例子</h2><p>这部分提供了一个简单的例子来介绍如何使用一部分在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 模块中的命令构建一个 shell 。</p><p>基础的 turtle 命令比如 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.forward" target="_blank" rel="noopener"><code>forward()</code></a> 被添加进一个 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 子类，方法名为 <code>do_forward()</code> 。参数被转换成数字并且分发至 turtle 模组中。 docstring 是 shell 提供的帮助实用程序。</p><p>例子也包含使用 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.precmd" target="_blank" rel="noopener"><code>precmd()</code></a> 方法实现基础的记录和回放的功能，这个方法负责将输入转换为小写并且将命令写入文件。 <code>do_playback()</code> 方法读取文件并添加记录命令至 <code>cmdqueue</code> 用于即时回放:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cmd, sys</span><br><span class="line"><span class="keyword">from</span> turtle <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TurtleShell</span><span class="params">(cmd.Cmd)</span>:</span></span><br><span class="line">    intro = <span class="string">'Welcome to the turtle shell.   Type help or ? to list commands.\n'</span></span><br><span class="line">    prompt = <span class="string">'(turtle) '</span></span><br><span class="line">    file = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ----- basic turtle commands -----</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_forward</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Move the turtle forward by the specified distance:  FORWARD 10'</span></span><br><span class="line">        forward(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_right</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Turn turtle right by given number of degrees:  RIGHT 20'</span></span><br><span class="line">        right(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_left</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Turn turtle left by given number of degrees:  LEFT 90'</span></span><br><span class="line">        left(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_goto</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Move turtle to an absolute position with changing orientation.  GOTO 100 200'</span></span><br><span class="line">        goto(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_home</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Return turtle to the home position:  HOME'</span></span><br><span class="line">        home()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_circle</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Draw circle with given radius an options extent and steps:  CIRCLE 50'</span></span><br><span class="line">        circle(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_position</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Print the current turtle position:  POSITION'</span></span><br><span class="line">        print(<span class="string">'Current position is %d %d\n'</span> % position())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_heading</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Print the current turtle heading in degrees:  HEADING'</span></span><br><span class="line">        print(<span class="string">'Current heading is %d\n'</span> % (heading(),))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_color</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Set the color:  COLOR BLUE'</span></span><br><span class="line">        color(arg.lower())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_undo</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Undo (repeatedly) the last turtle action(s):  UNDO'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_reset</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Clear the screen and return turtle to center:  RESET'</span></span><br><span class="line">        reset()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_bye</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Stop recording, close the turtle window, and exit:  BYE'</span></span><br><span class="line">        print(<span class="string">'Thank you for using Turtle'</span>)</span><br><span class="line">        self.close()</span><br><span class="line">        bye()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ----- record and playback -----</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_record</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Save future commands to filename:  RECORD rose.cmd'</span></span><br><span class="line">        self.file = open(arg, <span class="string">'w'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_playback</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Playback commands from a file:  PLAYBACK rose.cmd'</span></span><br><span class="line">        self.close()</span><br><span class="line">        <span class="keyword">with</span> open(arg) <span class="keyword">as</span> f:</span><br><span class="line">            self.cmdqueue.extend(f.read().splitlines())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">precmd</span><span class="params">(self, line)</span>:</span></span><br><span class="line">        line = line.lower()</span><br><span class="line">        <span class="keyword">if</span> self.file <span class="keyword">and</span> <span class="string">'playback'</span> <span class="keyword">not</span> <span class="keyword">in</span> line:</span><br><span class="line">            print(line, file=self.file)</span><br><span class="line">        <span class="keyword">return</span> line</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.file:</span><br><span class="line">            self.file.close()</span><br><span class="line">            self.file = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="string">'Convert a series of zero or more numbers to an argument tuple'</span></span><br><span class="line">    <span class="keyword">return</span> tuple(map(int, arg.split()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    TurtleShell().cmdloop()</span><br></pre></td></tr></table></figure><p>这是一个示例会话，其中 turtle shell 显示帮助功能，使用空行重复命令，以及简单的记录和回放功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the turtle shell.   Type help or ? to list commands.</span><br><span class="line"></span><br><span class="line">(turtle) ?</span><br><span class="line"></span><br><span class="line">Documented commands (type help &lt;topic&gt;):</span><br><span class="line">========================================</span><br><span class="line">bye     color    goto     home  playback  record  right</span><br><span class="line">circle  forward  heading  left  position  reset   undo</span><br><span class="line"></span><br><span class="line">(turtle) help forward</span><br><span class="line">Move the turtle forward by the specified distance:  FORWARD <span class="number">10</span></span><br><span class="line">(turtle) record spiral.cmd</span><br><span class="line">(turtle) position</span><br><span class="line">Current position <span class="keyword">is</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">(turtle) heading</span><br><span class="line">Current heading <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">(turtle) reset</span><br><span class="line">(turtle) circle <span class="number">20</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">40</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">60</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">80</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">100</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">120</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">120</span></span><br><span class="line">(turtle) heading</span><br><span class="line">Current heading <span class="keyword">is</span> <span class="number">180</span></span><br><span class="line"></span><br><span class="line">(turtle) forward <span class="number">100</span></span><br><span class="line">(turtle)</span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">100</span></span><br><span class="line">(turtle)</span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">400</span></span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">500</span></span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">400</span></span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">300</span></span><br><span class="line">(turtle) playback spiral.cmd</span><br><span class="line">Current position <span class="keyword">is</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Current heading <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Current heading <span class="keyword">is</span> <span class="number">180</span></span><br><span class="line"></span><br><span class="line">(turtle) bye</span><br><span class="line">Thank you <span class="keyword">for</span> using Turtle</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-cmd模块&quot;&gt;&lt;a href=&quot;#python-标准库-cmd模块&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 cmd模块&quot;&gt;&lt;/a&gt;python 标准库 cmd模块&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200221_zhuakuang.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="cmd" scheme="https://pinghailinfeng.gitee.io/tags/cmd/"/>
    
  </entry>
  
  <entry>
    <title>python standard library os</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/20/python-standard-library-os/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/20/python-standard-library-os/</id>
    <published>2020-02-20T00:07:42.000Z</published>
    <updated>2020-02-22T15:14:11.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-os"><a href="#python-标准库-os" class="headerlink" title="python 标准库 os"></a>python 标准库 os</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200220_os.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词：</p><p> <a href="https://www.hujiang.com/ciku/bustle/" target="_blank" rel="noopener">bustle</a> v.[I] 1.闹哄哄地忙乱；匆忙；奔忙 2.充满 v.[T] 催促；使忙碌 n. 忙乱；喧扰 </p><p>短语：</p><p> hustle and bustle  熙熙攘攘</p><p> <a href="https://www.hujiang.com/ciku/bustle_in_and_out/" target="_blank" rel="noopener">bustle in and out</a> </p><p> <a href="https://www.hujiang.com/ciku/bustle_about/" target="_blank" rel="noopener">bustle about</a>  sth</p><p>近义词:</p><p>run out of one’s feet </p><p>on the fly<br>on the hump<br>on the jump </p></blockquote><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/os.py" target="_blank" rel="noopener">Lib/os.py</a></p><hr><p>本模块提供了一种使用与操作系统相关的功能的便捷式途径。 如果你只是想读写一个文件，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>，如果你想操作文件路径，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 模块，如果你想读取通过命令行给出的所有文件中的所有行，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#module-fileinput" target="_blank" rel="noopener"><code>fileinput</code></a> 模块。 为了创建临时文件和目录，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#module-tempfile" target="_blank" rel="noopener"><code>tempfile</code></a> 模块，对于高级文件和目录处理，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 模块。</p><p>关于这些函数的可用性的说明：</p><ul><li>Python中所有依赖于操作系统的内置模块的设计都是这样，只要不同的操作系统某一相同的功能可用，它就使用相同的接口。例如，函数 <code>os.stat(path)</code> 以相同的格式返回关于 <em>path</em> 的状态信息（该格式源于 POSIX 接口）。</li><li>特定于某一操作系统的扩展通过操作 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块也是可用的，但是使用它们当然是对可移植性的一种威胁。</li><li>所有接受路径或文件名的函数都同时支持字节串和字符串对象，并在返回路径或文件名时使用相应类型的对象作为结果。</li><li>在 VxWorks 系统上，os.fork, os.execv 和 os.spawn<em>p</em> 不被支持。</li></ul><blockquote><p> 如果使用无效或无法访问的文件名与路径，或者其他类型正确但操作系统不接受的参数，此模块的所有函数都抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> （或者它的子类）。 </p></blockquote><ul><li><p><em>exception</em> <code>os.error</code></p><p>内建的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常的一个别名。</p></li><li><p><code>os.name</code></p><p>导入的依赖特定操作系统的模块的名称。以下名称目前已注册: <code>&#39;posix&#39;</code>, <code>&#39;nt&#39;</code>, <code>&#39;java&#39;</code>.</p></li></ul><blockquote><p><a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.platform" target="_blank" rel="noopener"><code>sys.platform</code></a> 有更详细的描述. <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.uname" target="_blank" rel="noopener"><code>os.uname()</code></a> 只给出系统提供的版本信息。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/platform.html#module-platform" target="_blank" rel="noopener"><code>platform</code></a> 模块对系统的标识有更详细的检查。</p></blockquote><h2 id="文件名，命令行参数，以及环境变量。"><a href="#文件名，命令行参数，以及环境变量。" class="headerlink" title="文件名，命令行参数，以及环境变量。"></a>文件名，命令行参数，以及环境变量。</h2><p>在 Python 中，使用字符串类型表示文件名、命令行参数和环境变量。 在某些系统上，在将这些字符串传递给操作系统之前，必须将这些字符串解码为字节。 Python 使用文件系统编码来执行此转换（请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getfilesystemencoding" target="_blank" rel="noopener"><code>sys.getfilesystemencoding()</code></a> ）。</p><p><em>在 3.1 版更改:</em> 在某些系统上，使用文件系统编码进行转换可能会失败。 在这种情况下，Python 会使用 <a href="https://docs.python.org/zh-cn/3.8/library/codecs.html#surrogateescape" target="_blank" rel="noopener">代理转义编码错误处理器</a>，这意味着在解码时，不可解码的字节被 Unicode 字符 U+DCxx 替换，并且这些字节在编码时再次转换为原始字节。</p><p>文件系统编码必须保证成功解码小于 128 的所有字节。如果文件系统编码无法提供此保证， API 函数可能会引发 UnicodeErrors 。</p><h2 id="进程参数"><a href="#进程参数" class="headerlink" title="进程参数"></a>进程参数</h2><p>这些函数和数据项提供了操作当前进程和用户的信息。</p><ul><li><p><code>os.ctermid</code>()</p><p>返回与进程控制终端对应的文件名。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.environ</code></p><p>一个表示字符串环境的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-mapping" target="_blank" rel="noopener">mapping</a> 对象。 例如，<code>environ[&#39;HOME&#39;]</code> 是你的主目录（在某些平台上）的路径名，相当于 C 中的 <code>getenv(&quot;HOME&quot;)</code>。这个映射是在第一次导入 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块时捕获的，通常作为 Python 启动时处理 <code>site.py</code> 的一部分。除了通过直接修改 <code>os.environ</code> 之外，在此之后对环境所做的更改不会反映在 <code>os.environ</code> 中。如果平台支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 函数，这个映射除了可以用于查询环境外还能用于修改环境。 当这个映射被修改时，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 将被自动调用。在Unix系统上，键和值会使用 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getfilesystemencoding" target="_blank" rel="noopener"><code>sys.getfilesystemencoding()</code></a> 和 <code>&#39;surrogateescape&#39;</code> 的错误处理。如果你想使用其他的编码，使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environb" target="_blank" rel="noopener"><code>environb</code></a>。注解 直接调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 并不会影响 <code>os.environ</code>，所以推荐直接修改 <code>os.environ</code>。注解 在某些平台上，包括 FreeBSD 和 Mac OS X，设置 <code>environ</code> 可能导致内存泄露。参阅 <code>putenv()</code> 的系统文档。如果平台没有提供 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a>, 为了使启动的子进程使用修改后的环境，一份修改后的映射会被传给合适的进程创建函数。如果平台支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> 函数，你可以通过删除映射中元素的方式来删除对应的环境变量。当一个元素被从 <code>os.environ</code> 删除时，以及 <code>pop()</code> 或 <code>clear()</code> 被调用时， <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> 会被自动调用。</p></li><li><p><code>os.environb</code></p><p>字节版本的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>environ</code></a>: 一个以字节串表示环境的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-mapping" target="_blank" rel="noopener">mapping</a> 对象。 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>environ</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environb" target="_blank" rel="noopener"><code>environb</code></a> 是同步的（修改 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environb" target="_blank" rel="noopener"><code>environb</code></a> 会更新 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>environ</code></a>，反之亦然）。只有在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_bytes_environ" target="_blank" rel="noopener"><code>supports_bytes_environ</code></a> 为 <code>True</code> 的时候 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environb" target="_blank" rel="noopener"><code>environb</code></a> 才是可用的。<em>3.2 新版功能.</em></p></li><li><p><code>os.chdir</code>(<em>path</em>)</p></li><li><p><code>os.fchdir</code>(<em>fd</em>)</p></li><li><p><code>os.getcwd</code>()</p><p>以上函数请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os-file-dir" target="_blank" rel="noopener">文件和目录</a> 。</p></li><li><p><code>os.fsencode</code>(<em>filename</em>)</p><p>编码 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">路径类</a> <em>文件名</em> 为文件系统接受的形式，使用 <code>&#39;surrogateescape&#39;</code> 代理转义编码错误处理器，在Windows系统上会使用 <code>&#39;strict&#39;</code> ；返回 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 字节类型不变。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsdecode" target="_blank" rel="noopener"><code>fsdecode()</code></a> 是此函数的逆向函数。<em>3.2 新版功能.**在 3.6 版更改:</em> 增加对实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>os.PathLike</code></a> 接口的对象的支持。</p></li><li><p><code>os.fsdecode</code>(<em>filename</em>)</p><p>从文件系统编码方式解码为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">路径类</a> 文件名，使用 <code>&#39;surrogateescape&#39;</code> 代理转义编码错误处理器，在Windows系统上会使用 <code>&#39;strict&#39;</code> ；返回 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 字符串不变。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsencode" target="_blank" rel="noopener"><code>fsencode()</code></a> 是此函数的逆向函数。<em>3.2 新版功能.**在 3.6 版更改:</em> 增加对实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>os.PathLike</code></a> 接口的对象的支持。</p></li><li><p><code>os.fspath</code>(<em>path</em>)</p><p>返回路径的文件系统表示。如果传入的是 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型的字符串，将原样返回。否则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike.__fspath__" target="_blank" rel="noopener"><code>__fspath__()</code></a> 将被调用，如果得到的是一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型的对象，那就返回这个值。其他所有情况则会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 异常。<em>3.6 新版功能.</em></p></li><li><p><em>class</em> <code>os.PathLike</code></p><p>某些对象用于表示文件系统中的路径（如 <a href="https://docs.python.org/zh-cn/3.8/library/pathlib.html#pathlib.PurePath" target="_blank" rel="noopener"><code>pathlib.PurePath</code></a> 对象），本类是这些对象的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class" target="_blank" rel="noopener">抽象基类</a>。<em>3.6 新版功能.**abstractmethod</em> <code>__fspath__</code>()返回当前对象的文件系统表示。这个方法只应该返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 字符串或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 字节串，请优先选择 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 字符串。</p></li><li><p><code>os.getenv</code>(<em>key</em>, <em>default=None</em>)</p><p>如果存在，返回环境变量 <em>key</em> 的值，否则返回 <em>default</em>。 <em>key</em> ， <em>default</em> 和返回值均为 str 字符串类型。在Unix系统上，键和值会使用 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getfilesystemencoding" target="_blank" rel="noopener"><code>sys.getfilesystemencoding()</code></a> 和’surrogateescape’ 错误处理进行解码。如果你想使用其他的编码，使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getenvb" target="_blank" rel="noopener"><code>os.getenvb()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 大部分的Unix系统，Windows。</p></li><li><p><code>os.getenvb</code>(<em>key</em>, <em>default=None</em>)</p><p>如果存在环境变量 <em>key</em> 那么返回其值，否则返回 <em>default</em>。 <em>key</em> ， <em>default</em> 和返回值均为bytes字节串类型。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getenvb" target="_blank" rel="noopener"><code>getenvb()</code></a> 仅在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_bytes_environ" target="_blank" rel="noopener"><code>supports_bytes_environ</code></a> 为 <code>True</code> 时可用。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 大部分的Unix系统。<em>3.2 新版功能.</em></p></li><li><p><code>os.get_exec_path</code>(<em>env=None</em>)</p><p>返回将用于搜索可执行文件的目录列表，与在外壳程序中启动一个进程时相似。指定的 <em>env</em> 应为用于搜索 PATH 的环境变量字典。默认情况下，当 <em>env</em> 为 <code>None</code> 时，将会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>environ</code></a> 。<em>3.2 新版功能.</em></p></li><li><p><code>os.getegid</code>()</p><p>返回当前进程的有效组ID。对应当前进程执行文件的 “set id” 位。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.geteuid</code>()</p><p>返回当前进程的有效用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.getgid</code>()</p><p>返回当前进程的实际组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.getgrouplist</code>(<em>user</em>, <em>group</em>)</p><p>返回该用户所在的组 ID 列表。可能 <em>group</em> 参数没有在返回的列表中，实际上用户应该也是属于该 <em>group</em>。<em>group</em> 参数一般可以从储存账户信息的密码记录文件中找到。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.getgroups</code>()</p><p>返回当前进程对应的组ID列表<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p><blockquote><p>注解：在Mac OS X系统中，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 会和其他 Unix 平台有些不同。如果 Python 解释器是在 <code>10.5</code> 或更早版本中部署，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 返回当前用户进程相关的有效组ID列表。 该列表长度由于系统预设的接口限制，最长为 16。 而且在适当的权限下，返回结果还会因 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 而发生变化；如果 Python 解释器是在 <code>10.5</code> 以上版本中部署，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 返回进程所属有效用户 ID 所对应的用户的组 ID 列表，组用户列表可能因为进程的生存周期而发生变动，而且也不会因为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.setgroups" target="_blank" rel="noopener"><code>setgroups()</code></a> 的调用而发生，返回的组用户列表长度也没有长度 16 的限制。在部署中，Python 解释器用到的变量 <code>MACOSX_DEPLOYMENT_TARGET</code> 可以用 <a href="https://docs.python.org/zh-cn/3.8/library/sysconfig.html#sysconfig.get_config_var" target="_blank" rel="noopener"><code>sysconfig.get_config_var()</code></a>。</p></blockquote></li><li><p><code>os.getlogin</code>()</p><p>返回通过控制终端进程进行登录的用户名。在多数情况下，使用 <a href="https://docs.python.org/zh-cn/3.8/library/getpass.html#getpass.getuser" target="_blank" rel="noopener"><code>getpass.getuser()</code></a> 会更有效，因为后者会通过检查环境变量 <code>LOGNAME</code> 或 <code>USERNAME</code> 来查找用户，再由 <code>pwd.getpwuid(os.getuid())[0]</code> 来获取当前用户 ID 的登录名。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><code>os.getpgid</code>(<em>pid</em>)</p><p>根据进程id <em>pid</em> 返回进程的组 ID 列表。如果 <em>pid</em> 为 0，则返回当前进程的进程组 ID 列表<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.getpgrp</code>()</p><p>返回当时进程组的ID<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.getpid</code>()</p><p>返回当前进程ID</p></li><li><p><code>os.getppid</code>()</p><p>返回父进程ID。当父进程已经结束，在Unix中返回的ID是初始进程(1)中的一个，在Windows中仍然是同一个进程ID，该进程ID有可能已经被进行进程所占用。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加WIndows的支持。</p></li><li><p><code>os.getpriority</code>(<em>which</em>, <em>who</em>)</p><p>获取程序调度优先级。<em>which</em> 参数值可以是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PROCESS" target="_blank" rel="noopener"><code>PRIO_PROCESS</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PGRP" target="_blank" rel="noopener"><code>PRIO_PGRP</code></a>，或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_USER" target="_blank" rel="noopener"><code>PRIO_USER</code></a> 中的一个，<em>who</em> 是相对于 <em>which</em> (<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PROCESS" target="_blank" rel="noopener"><code>PRIO_PROCESS</code></a> 的进程标识符，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PGRP" target="_blank" rel="noopener"><code>PRIO_PGRP</code></a> 的进程组标识符和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_USER" target="_blank" rel="noopener"><code>PRIO_USER</code></a> 的用户ID)。当 <em>who</em> 为 0 时（分别）表示调用的进程，调用进程的进程组或调用进程所属的真实用户 ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.PRIO_PROCESS</code></p></li><li><p><code>os.PRIO_PGRP</code></p></li><li><p><code>os.PRIO_USER</code></p><p>函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getpriority" target="_blank" rel="noopener"><code>getpriority()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.setpriority" target="_blank" rel="noopener"><code>setpriority()</code></a> 的参数。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.getresuid</code>()</p><p>返回一个由 (ruid, euid, suid) 所组成的元组，分别表示当前进程的真实用户ID，有效用户ID和甲暂存用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p></li><li><p><code>os.getresgid</code>()</p><p>返回一个由 (rgid, egid, sgid) 所组成的元组，分别表示当前进程的真实组ID，有效组ID和暂存组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p></li><li><p><code>os.getuid</code>()</p><p>返回当前进程的真实用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.initgroups</code>(<em>username</em>, <em>gid</em>)</p><p>调用系统 initgroups()，使用指定用户所在的所有值来初始化组访问列表，包括指定的组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p></li><li><p><code>os.putenv</code>(<em>key</em>, <em>value</em>)</p><p>将名为 <em>key</em> 的环境变量值设置为 <em>value</em>。该变量名修改会影响由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>os.system()</code></a>， <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a> ，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>fork()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execv" target="_blank" rel="noopener"><code>execv()</code></a> 发起的子进程。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 大部分的Unix系统，Windows。注解 在一些平台，包括 FreeBSD 和 Mac OS X，设置 <code>environ</code> 可能导致内存泄露。详情参考 putenv 相关系统文档。当系统支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 时，<code>os.environ</code> 中的参数赋值会自动转换为对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 的调用。不过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 的调用不会更新 <code>os.environ</code>，因此最好使用 <code>os.environ</code> 对变量赋值。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.putenv</code>，附带参数 <code>key</code>, <code>value</code>。</p></li><li><p><code>os.setegid</code>(<em>egid</em>)</p><p>设置当前进程的有效组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.seteuid</code>(<em>euid</em>)</p><p>设置当前进程的有效用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.setgid</code>(<em>gid</em>)</p><p>设置当前进程的组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.setgroups</code>(<em>groups</em>)</p><p>将 <em>group</em> 参数值设置为与当进程相关联的附加组ID列表。<em>group</em> 参数必须为一个序列，每个元素应为每个组的数字ID。该操作通常只适用于超级用户。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。注解 在 Mac OS X 中，<em>groups</em> 的长度不能超过系统定义的最大有效组 ID 个数，一般为 16。 如果它没有返回与调用 setgroups() 所设置的相同的组列表，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 的文档。</p></li><li><p><code>os.setpgrp</code>()</p><p>根据已实现的版本（如果有）来调用系统 <code>setpgrp()</code> 或 <code>setpgrp(0, 0)</code> 。相关说明，请参考 Unix 手册。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.setpgid</code>(<em>pid</em>, <em>pgrp</em>)</p><p>使用系统调用 <code>setpgid()</code>，将 <em>pid</em> 对应进程的组ID设置为 <em>pgrp</em>。相关说明，请参考 Unix 手册。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.setpriority</code>(<em>which</em>, <em>who</em>, <em>priority</em>)</p><p>设置程序调度优先级。 <em>which</em> 的值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PROCESS" target="_blank" rel="noopener"><code>PRIO_PROCESS</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PGRP" target="_blank" rel="noopener"><code>PRIO_PGRP</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_USER" target="_blank" rel="noopener"><code>PRIO_USER</code></a> 之一，而 <em>who</em> 会相对于 <em>which</em> (<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PROCESS" target="_blank" rel="noopener"><code>PRIO_PROCESS</code></a> 的进程标识符, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PGRP" target="_blank" rel="noopener"><code>PRIO_PGRP</code></a> 的进程组标识符和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_USER" target="_blank" rel="noopener"><code>PRIO_USER</code></a> 的用户 ID) 被解析。 <em>who</em> 值为零 (分别) 表示调用进程，调用进程的进程组或调用进程的真实用户 ID。 <em>priority</em> 是范围在 -20 至 19 的值。 默认优先级为 0；较小的优先级数值会更优先被调度。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.setregid</code>(<em>rgid</em>, <em>egid</em>)</p><p>设置当前进程的真实和有效组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.setresgid</code>(<em>rgid</em>, <em>egid</em>, <em>sgid</em>)</p><p>设置当前进程的真实，有效和暂存组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p></li><li><p><code>os.setresuid</code>(<em>ruid</em>, <em>euid</em>, <em>suid</em>)</p><p>设置当前进程的真实，有效和暂存用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p></li><li><p><code>os.setreuid</code>(<em>ruid</em>, <em>euid</em>)</p><p>设置当前进程的真实和有效用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.getsid</code>(<em>pid</em>)</p><p>调用系统调用 <code>getsid()</code>。相关说明，请参考 Unix 手册。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.setsid</code>()</p><p>使用系统调用 <code>getsid()</code>。相关说明，请参考 Unix 手册。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.setuid</code>(<em>uid</em>)</p><p>设置当前进程的用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.strerror</code>(<em>code</em>)</p><p>根据 <em>code</em> 中的错误码返回错误消息。 在某些平台上当给出未知错误码时 <code>strerror()</code> 将返回 <code>NULL</code> 并会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。</p></li><li><p><code>os.supports_bytes_environ</code></p><p>如果操作系统上原生环境类型是字节型则为 <code>True</code> (例如在 Windows 上为 <code>False</code>)。<em>3.2 新版功能.</em></p></li><li><p><code>os.umask</code>(<em>mask</em>)</p><p>设定当前数值掩码并返回之前的掩码。</p></li><li><p><code>os.uname</code>()</p><p>返回当前操作系统的识别信息。返回值是一个有5个属性的对象：<code>sysname</code> - 操作系统名<code>nodename</code> - 机器在网络上的名称（需要先设定）<code>release</code> - 操作系统发行信息<code>version</code> - 操作系统版本信息<code>machine</code> - 硬件标识符为了向后兼容，该对象也是可迭代的，像是一个按照 <code>sysname</code>，<code>nodename</code>，<code>release</code>，<code>version</code>，和 <code>machine</code> 顺序组成的元组。有些系统会将 <code>nodename</code> 截短为 8 个字符或截短至前缀部分；获取主机名的一个更好方式是 <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.gethostname" target="_blank" rel="noopener"><code>socket.gethostname()</code></a> 或甚至可以用 <code>socket.gethostbyaddr(socket.gethostname())</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 较新的 Unix 版本。<em>在 3.3 版更改:</em> 返回结果的类型由元组变成一个类似元组的对象，同时具有命名的属性。</p></li><li><p><code>os.unsetenv</code>(<em>key</em>)</p><p>取消设置（删除）名为 <em>key</em> 的环境变量。变量名的改变会影响由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>os.system()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>fork()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execv" target="_blank" rel="noopener"><code>execv()</code></a> 触发的子进程。当系统支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> ，删除在 <code>os.environ</code> 中的变量会自动转换为对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> 的调用。但是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> 不能更新 <code>os.environ</code>，因此最好直接删除 <code>os.environ</code> 中的变量。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.unsetenv</code>，附带参数 <code>key</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 大部分的Unix系统。</p></li></ul><h2 id="创建文件对象"><a href="#创建文件对象" class="headerlink" title="创建文件对象"></a>创建文件对象</h2><p>这些函数创建新的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file objects</a> 。（参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>open()</code></a> 以获取打开文件描述符的相关信息。）</p><ul><li><p><code>os.fdopen</code>(<em>fd</em>, <strong>args<em>, </em></strong>kwargs*)</p><p>返回打开文件描述符 <em>fd</em> 对应文件的对象。类似内建 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 函数，二者接受同样的参数。不同之处在于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a> 第一个参数应该为整数。</p></li></ul><h2 id="文件描述符操作"><a href="#文件描述符操作" class="headerlink" title="文件描述符操作"></a>文件描述符操作</h2><p>这些函数对文件描述符所引用的 I/O 流进行操作。</p><p>文件描述符是一些小的整数，对应于当前进程所打开的文件。例如，标准输入的文件描述符通常是0，标准输出是1，标准错误是2。之后被进程打开的文件的文件描述符会被依次指定为3，4，5等。“文件描述符”这个词有点误导性，在 Unix 平台中套接字和管道也被文件描述符所引用。</p><p>当需要时，可以用 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 可以获得 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> 所对应的文件描述符。需要注意的是，直接使用文件描述符会绕过文件对象的方法，会忽略如数据内部缓冲等情况。</p><ul><li><p><code>os.close</code>(<em>fd</em>)</p><p>关闭文件描述符 <em>fd</em>。注解 该功能适用于低级 I/O 操作，必须用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pipe" target="_blank" rel="noopener"><code>pipe()</code></a> 返回的文件描述符。若要关闭由内建函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a> 返回的 “文件对象”，则应使用其相应的 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.close" target="_blank" rel="noopener"><code>close()</code></a> 方法。</p></li><li><p><code>os.closerange</code>(<em>fd_low</em>, <em>fd_high</em>)</p><p>关闭从 <em>fd_low</em> （包括）到 <em>fd_high</em> （排除）间的文件描述符，并忽略错误。类似（但快于）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> fd <span class="keyword">in</span> range(fd_low, fd_high):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.close(fd)</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p><code>os.copy_file_range</code>(<em>src</em>, <em>dst</em>, <em>count</em>, <em>offset_src=None</em>, <em>offset_dst=None</em>)</p><p>从文件描述符 <em>src</em> 复制 <em>count</em> 字节，从偏移量 <em>offset_src</em> 开始读取，到文件描述符 <em>dst</em>，从偏移量 <em>offset_dst</em> 开始写入。如果 <em>offset_src</em> 为 None，则 <em>src</em> 将从当前位置开始读取；<em>offset_dst</em> 同理。<em>src</em> 和 <em>dst</em> 指向的文件必须处于相同的文件系统，否则将会抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 被设为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EXDEV" target="_blank" rel="noopener"><code>errno.EXDEV</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 。此复制的完成没有额外的从内核到用户空间再回到内核的数据转移花费。另外，一些文件系统可能实现额外的优化。完成复制就如同打开两个二进制文件一样。返回值是复制的字节的数目。这可能低于需求的数目。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">Availability</a>: Linux kernel &gt;= 4.5 或 glibc &gt;= 2.27。<em>3.8 新版功能.</em></p></li><li><p><code>os.device_encoding</code>(<em>fd</em>)</p><p>如果连接到终端，则返回一个与 <em>fd</em> 关联的设备描述字符，否则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p></li><li><p><code>os.dup</code>(<em>fd</em>)</p><p>返回一个文件描述符 <em>fd</em> 的副本。该文件描述符的副本是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承的</a>。在 Windows 中，当复制一个标准流（0: stdin, 1: stdout, 2: stderr）时，新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">可继承的</a>。<em>在 3.4 版更改:</em> 新的文件描述符现在是不可继承的。</p></li><li><p><code>os.dup2</code>(<em>fd</em>, <em>fd2</em>, <em>inheritable=True</em>)</p><p>把文件描述符 <em>fd</em> 复制为 <em>fd2</em>，必要时先关闭后者。返回 <em>fd2</em>。新的文件描述符默认是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">可继承的</a>，除非在 <em>inheritable</em> 为 <code>False</code> 时，是不可继承的。<em>在 3.4 版更改:</em> 添加可选参数 <em>inheritable</em>。<em>在 3.7 版更改:</em> 成功时返回 <em>fd2</em>，以过去的版本中，总是返回 <code>None</code>。</p></li><li><p><code>os.fchmod</code>(<em>fd</em>, <em>mode</em>)</p><p>将 <em>fd</em> 指定文件的权限状态修改为 <em>mode</em>。可以参考 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>chmod()</code></a> 中列出 <em>mode</em> 的可用值。从Python 3.3开始，这相当于 <code>os.chmod(fd, mode)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chmod</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.fchown</code>(<em>fd</em>, <em>uid</em>, <em>gid</em>)</p><p>分别将 <em>fd</em> 指定文件的所有者和组 ID 修改为 <em>uid</em> 和 <em>gid</em> 的值。若不想变更其中的某个 ID，可将相应值设为 -1。参考 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chown" target="_blank" rel="noopener"><code>chown()</code></a>。从 Python 3.3 开始，这相当于 <code>os.chown(fd, uid, gid)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chown</code>，附带参数 <code>path</code>、<code>uid</code>、<code>gid</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.fdatasync</code>(<em>fd</em>)</p><p>强制将文件描述符 <em>fd</em> 指定文件写入磁盘。不强制更新元数据。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p><blockquote><p> 该功能在 MacOS 中不可用。 </p></blockquote></li><li><p><code>os.fpathconf</code>(<em>fd</em>, <em>name</em>)</p><p>返回与打开的文件有关的系统配置信息。<em>name</em> 指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX.1，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 <code>pathconf_names</code> 字典中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 <em>name</em>。如果 <em>name</em> 是一个字符串且不是已定义的名称，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。如果当前系统不支持 <em>name</em> 指定的配置名称，即使该名称存在于 <code>pathconf_names</code>，也会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，错误码为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EINVAL" target="_blank" rel="noopener"><code>errno.EINVAL</code></a>。从 Python 3.3 起，此功能等价于 <code>os.pathconf(fd, name)</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.fstat</code>(<em>fd</em>)</p><p>获取文件描述符 <em>fd</em> 的状态. 返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 对象。从 Python 3.3 起，此功能等价于 <code>os.stat(fd)</code>。</p><blockquote><p>参见：  <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 函数。</p></blockquote></li><li><p><code>os.fstatvfs</code>(<em>fd</em>)</p><p>返回文件系统的信息，该文件系统是文件描述符 <em>fd</em> 指向的文件所在的文件系统，与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.statvfs" target="_blank" rel="noopener"><code>statvfs()</code></a> 一样。从 Python 3.3 开始，它等效于 <code>os.statvfs(fd)</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.fsync</code>(<em>fd</em>)</p><p>强制将文件描述符 <em>fd</em> 指向的文件写入磁盘。在 Unix，这将调用原生 <code>fsync()</code> 函数；在 Windows，则是 MS <code>_commit()</code> 函数。如果要写入的是缓冲区内的 Python <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">文件对象</a> <em>f</em>，请先执行 <code>f.flush()</code>，然后执行 <code>os.fsync(f.fileno())</code>，以确保与 <em>f</em> 关联的所有内部缓冲区都写入磁盘。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><code>os.ftruncate</code>(<em>fd</em>, <em>length</em>)</p><p>截断文件描述符 <em>fd</em> 指向的文件，以使其最大为 <em>length</em> 字节。从 Python 3.3 开始，它等效于 <code>os.truncate(fd, length)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.truncate</code>，附带参数 <code>fd</code>, <code>length</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.5 版更改:</em> 添加了 Windows 支持</p></li><li><p><code>os.get_blocking</code>(<em>fd</em>)</p><p>获取文件描述符的阻塞模式：如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_NONBLOCK" target="_blank" rel="noopener"><code>O_NONBLOCK</code></a> 标志位，返回 <code>False</code>，如果该标志位被清除，返回 <code>True</code>。参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.set_blocking" target="_blank" rel="noopener"><code>set_blocking()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.socket.setblocking" target="_blank" rel="noopener"><code>socket.socket.setblocking()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.5 新版功能.</em></p></li><li><p><code>os.isatty</code>(<em>fd</em>)</p><p>如果文件描述符 <em>fd</em> 打开且已连接至 tty 设备（或类 tty 设备），返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p><code>os.lockf</code>(<em>fd</em>, <em>cmd</em>, <em>len</em>)</p><p>在打开的文件描述符上，使用、测试或删除 POSIX 锁。<em>fd</em> 是一个打开的文件描述符。<em>cmd</em> 指定要进行的操作，它们是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_LOCK" target="_blank" rel="noopener"><code>F_LOCK</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_TLOCK" target="_blank" rel="noopener"><code>F_TLOCK</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_ULOCK" target="_blank" rel="noopener"><code>F_ULOCK</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_TEST" target="_blank" rel="noopener"><code>F_TEST</code></a> 中的一个。<em>len</em> 指定哪部分文件需要锁定。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.lockf</code>，附带参数 <code>fd</code>、<code>cmd</code>、<code>len</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.F_LOCK</code></p></li><li><p><code>os.F_TLOCK</code></p></li><li><p><code>os.F_ULOCK</code></p></li><li><p><code>os.F_TEST</code></p><p>标志位，用于指定 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lockf" target="_blank" rel="noopener"><code>lockf()</code></a> 进行哪一种操作。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.lseek</code>(<em>fd</em>, <em>pos</em>, <em>how</em>)</p><p>将文件描述符 <em>fd</em> 的当前位置设置为 <em>pos</em>，位置的计算方式 <em>how</em> 如下：设置为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.SEEK_SET" target="_blank" rel="noopener"><code>SEEK_SET</code></a> 或 <code>0</code> 表示从文件开头计算，设置为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.SEEK_CUR" target="_blank" rel="noopener"><code>SEEK_CUR</code></a> 或 <code>1</code> 表示从文件当前位置计算，设置为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.SEEK_END" target="_blank" rel="noopener"><code>SEEK_END</code></a> 或 <code>2</code> 表示文件末尾计算。返回新指针位置，这个位置是从文件开头计算的，单位是字节。</p></li><li><p><code>os.SEEK_SET</code></p></li><li><p><code>os.SEEK_CUR</code></p></li><li><p><code>os.SEEK_END</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lseek" target="_blank" rel="noopener"><code>lseek()</code></a> 函数的参数，它们的值分别为 0、1 和 2。<em>3.3 新版功能:</em> 某些操作系统可能支持其他值，例如 <code>os.SEEK_HOLE</code> 或 <code>os.SEEK_DATA</code>。</p></li><li><p><code>os.open</code>(<em>path</em>, <em>flags</em>, <em>mode=0o777</em>, <em>**, </em>dir_fd=None*)</p><p>打开文件 <em>path</em>，根据 <em>flags</em> 设置各种标志位，并根据 <em>mode</em> 设置其权限状态。当计算 <em>mode</em> 时，会首先根据当前 umask 值将部分权限去除。本方法返回新文件的描述符。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承</a> 的。有关 flag 和 mode 取值的说明，请参见 C 运行时文档。标志位常量（如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_RDONLY" target="_blank" rel="noopener"><code>O_RDONLY</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_WRONLY" target="_blank" rel="noopener"><code>O_WRONLY</code></a>）在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中定义。特别地，在 Windows 上需要添加 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_BINARY" target="_blank" rel="noopener"><code>O_BINARY</code></a> 才能以二进制模式打开文件。本函数带有 <em>dir_fd</em> 参数，支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>open</code>，附带参数 <code>path</code>、<code>mode</code>、<code>flags</code>。<em>在 3.4 版更改:</em> 新的文件描述符现在是不可继承的。</p><blockquote><p>注解：本函数适用于底层的 I/O。常规用途请使用内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>，该函数的 <code>read()</code> 和 <code>write()</code> 方法（及其他方法）会返回 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">文件对象</a>。要将文件描述符包装在文件对象中，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a>。</p></blockquote><p><em>3.3 新版功能:</em> <em>dir_fd</em> 参数。</p><p><em>在 3.5 版更改:</em> 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>以下常量是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>open()</code></a> 函数 <em>flags</em> 参数的选项。可以用按位或运算符 <code>|</code> 将它们组合使用。部分常量并非在所有平台上都可用。有关其可用性和用法的说明，请参阅 <em><a href="https://manpages.debian.org/open(2" target="_blank" rel="noopener">open(2)</a>)</em> 手册（Unix 上）或 <a href="https://msdn.microsoft.com/en-us/library/z0kc8e3z.aspx" target="_blank" rel="noopener">MSDN</a> （Windows 上）。</p><ul><li><p><code>os.O_RDONLY</code></p></li><li><p><code>os.O_WRONLY</code></p></li><li><p><code>os.O_RDWR</code></p></li><li><p><code>os.O_APPEND</code></p></li><li><p><code>os.O_CREAT</code></p></li><li><p><code>os.O_EXCL</code></p></li><li><p><code>os.O_TRUNC</code></p><p>上述常量在 Unix 和 Windows 上均可用。</p></li><li><p><code>os.O_DSYNC</code></p></li><li><p><code>os.O_RSYNC</code></p></li><li><p><code>os.O_SYNC</code></p></li><li><p><code>os.O_NDELAY</code></p></li><li><p><code>os.O_NONBLOCK</code></p></li><li><p><code>os.O_NOCTTY</code></p></li><li><p><code>os.O_CLOEXEC</code></p><p>这个常数仅在 Unix 系统中可用。<em>在 3.3 版更改:</em> 增加 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_CLOEXEC" target="_blank" rel="noopener"><code>O_CLOEXEC</code></a> 常量。</p></li><li><p><code>os.O_BINARY</code></p></li><li><p><code>os.O_NOINHERIT</code></p></li><li><p><code>os.O_SHORT_LIVED</code></p></li><li><p><code>os.O_TEMPORARY</code></p></li><li><p><code>os.O_RANDOM</code></p></li><li><p><code>os.O_SEQUENTIAL</code></p></li><li><p><code>os.O_TEXT</code></p><p>这个常数仅在 Windows 系统中可用。</p></li><li><p><code>os.O_ASYNC</code></p></li><li><p><code>os.O_DIRECT</code></p></li><li><p><code>os.O_DIRECTORY</code></p></li><li><p><code>os.O_NOFOLLOW</code></p></li><li><p><code>os.O_NOATIME</code></p></li><li><p><code>os.O_PATH</code></p></li><li><p><code>os.O_TMPFILE</code></p></li><li><p><code>os.O_SHLOCK</code></p></li><li><p><code>os.O_EXLOCK</code></p><p>上述常量是扩展常量，如果 C 库未定义它们，则不存在。<em>在 3.4 版更改:</em> 在支持的系统上增加 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_PATH" target="_blank" rel="noopener"><code>O_PATH</code></a>。增加 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_TMPFILE" target="_blank" rel="noopener"><code>O_TMPFILE</code></a>，仅在 Linux Kernel 3.11 或更高版本可用。</p></li><li><p><code>os.openpty</code>()</p><p>打开一对新的伪终端，返回一对文件描述符 <code>（主，从）</code>，分别为 pty 和 tty。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承</a> 的。对于（稍微）轻量一些的方法，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/pty.html#module-pty" target="_blank" rel="noopener"><code>pty</code></a> 模块。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 某些 Unix。<em>在 3.4 版更改:</em> 新的文件描述符不再可继承。</p></li><li><p><code>os.pipe</code>()</p><p>创建一个管道，返回一对分别用于读取和写入的文件描述符 <code>(r, w)</code>。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承</a> 的。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.4 版更改:</em> 新的文件描述符不再可继承。</p></li><li><p><code>os.pipe2</code>(<em>flags</em>)</p><p>创建带有 <em>flags</em> 标志位的管道。可通过对以下一个或多个值进行“或”运算来构造这些 <em>flags</em>：<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_NONBLOCK" target="_blank" rel="noopener"><code>O_NONBLOCK</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_CLOEXEC" target="_blank" rel="noopener"><code>O_CLOEXEC</code></a>。返回一对分别用于读取和写入的文件描述符 <code>(r, w)</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 某些 Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.posix_fallocate</code>(<em>fd</em>, <em>offset</em>, <em>len</em>)</p><p>确保为 <em>fd</em> 指向的文件分配了足够的磁盘空间，该空间从偏移量 <em>offset</em> 开始，到 <em>len</em> 字节为止。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.posix_fadvise</code>(<em>fd</em>, <em>offset</em>, <em>len</em>, <em>advice</em>)</p><p>声明即将以特定模式访问数据，使内核可以提前进行优化。数据范围是从 <em>fd</em> 所指向文件的 <em>offset</em> 开始，持续 <em>len</em> 个字节。<em>advice</em> 的取值是如下之一：<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_NORMAL" target="_blank" rel="noopener"><code>POSIX_FADV_NORMAL</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_SEQUENTIAL" target="_blank" rel="noopener"><code>POSIX_FADV_SEQUENTIAL</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_RANDOM" target="_blank" rel="noopener"><code>POSIX_FADV_RANDOM</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_NOREUSE" target="_blank" rel="noopener"><code>POSIX_FADV_NOREUSE</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_WILLNEED" target="_blank" rel="noopener"><code>POSIX_FADV_WILLNEED</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_DONTNEED" target="_blank" rel="noopener"><code>POSIX_FADV_DONTNEED</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.POSIX_FADV_NORMAL</code></p></li><li><p><code>os.POSIX_FADV_SEQUENTIAL</code></p></li><li><p><code>os.POSIX_FADV_RANDOM</code></p></li><li><p><code>os.POSIX_FADV_NOREUSE</code></p></li><li><p><code>os.POSIX_FADV_WILLNEED</code></p></li><li><p><code>os.POSIX_FADV_DONTNEED</code></p><p>用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_fadvise" target="_blank" rel="noopener"><code>posix_fadvise()</code></a> 的 <em>advice</em> 参数的标志位，指定可能使用的访问模式。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.pread</code>(<em>fd</em>, <em>n</em>, <em>offset</em>)</p><p>从文件描述符 <em>fd</em> 所指向文件的偏移位置 <em>offset</em> 开始，读取至多 <em>n</em> 个字节，而保持文件偏移量不变。返回所读取字节的字节串 (bytestring)。如果到达了 <em>fd</em> 指向的文件末尾，则返回空字节对象。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.preadv</code>(<em>fd</em>, <em>buffers</em>, <em>offset</em>, <em>flags=0</em>)</p><p>从文件描述符 <em>fd</em> 所指向文件的偏移位置 <em>offset</em> 开始，将数据读取至可变 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 缓冲区 <em>buffers</em> 中，保持文件偏移量不变。将数据依次存放到每个缓冲区中，填满一个后继续存放到序列中的下一个缓冲区，来保存其余数据。flags 参数可以由零个或多个标志位进行按位或运算来得到：<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.RWF_HIPRI" target="_blank" rel="noopener"><code>RWF_HIPRI</code></a><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.RWF_NOWAIT" target="_blank" rel="noopener"><code>RWF_NOWAIT</code></a>返回实际读取的字节总数，该总数可以小于所有对象的总容量。操作系统可能对允许使用的缓冲区数量有限制（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 获取 <code>&#39;SC_IOV_MAX&#39;</code> 值）。本方法结合了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.readv" target="_blank" rel="noopener"><code>os.readv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pread" target="_blank" rel="noopener"><code>os.pread()</code></a> 的功能。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 2.6.30 或更高版本，FreeBSD 6.0 或更高版本，OpenBSD 2.7 或更高版本。使用标志位需要 Linux 4.6 或更高版本。<em>3.7 新版功能.</em></p></li><li><p><code>os.RWF_NOWAIT</code></p><p>不要等待无法立即获得的数据。如果指定了此标志，那么当需要从后备存储器中读取数据，或等待文件锁时，系统调用将立即返回。如果成功读取数据，则返回读取的字节数。如果未读取到数据，则返回 <code>-1</code>，并将错误码 errno 置为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EAGAIN" target="_blank" rel="noopener"><code>errno.EAGAIN</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 4.14 或更高版本。<em>3.7 新版功能.</em></p></li><li><p><code>os.RWF_HIPRI</code></p><p>高优先级读/写。允许基于块的文件系统对设备进行轮询，这样可以降低延迟，但可能会占用更多资源。目前在 Linux 上，此功能仅在使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_DIRECT" target="_blank" rel="noopener"><code>O_DIRECT</code></a> 标志打开的文件描述符上可用。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 4.6 或更高版本。<em>3.7 新版功能.</em></p></li><li><p><code>os.pwrite</code>(<em>fd</em>, <em>str</em>, <em>offset</em>)</p><p>将 <em>str</em> 中的字节串 (bytestring) 写入文件描述符 <em>fd</em> 的偏移位置 <em>offset</em> 处，保持文件偏移量不变。返回实际写入的字节数。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.pwritev</code>(<em>fd</em>, <em>buffers</em>, <em>offset</em>, <em>flags=0</em>)</p><p>将缓冲区 <em>buffers</em> 的内容写入文件描述符 <em>fd</em> 的偏移位置 <em>offset</em> 处，保持文件偏移量不变。缓冲区 <em>buffers</em> 必须是由 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 组成的序列。缓冲区以数组顺序处理。先写入第一个缓冲区的全部内容，再写入第二个缓冲区，照此继续。flags 参数可以由零个或多个标志位进行按位或运算来得到：<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.RWF_DSYNC" target="_blank" rel="noopener"><code>RWF_DSYNC</code></a><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.RWF_SYNC" target="_blank" rel="noopener"><code>RWF_SYNC</code></a>返回实际写入的字节总数。操作系统可能对允许使用的缓冲区数量有限制（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 获取 <code>&#39;SC_IOV_MAX&#39;</code> 值）。本方法结合了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.writev" target="_blank" rel="noopener"><code>os.writev()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pwrite" target="_blank" rel="noopener"><code>os.pwrite()</code></a> 的功能。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 2.6.30 或更高版本，FreeBSD 6.0 或更高版本，OpenBSD 2.7 或更高版本。使用标志位需要 Linux 4.7 或更高版本。<em>3.7 新版功能.</em></p></li><li><p><code>os.RWF_DSYNC</code></p><p>提供立即写入功能，等效于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_DSYNC" target="_blank" rel="noopener"><code>O_DSYNC</code></a> <code>open(2)</code> 标志。该标志仅作用于系统调用写入的数据。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 4.7 或更高版本。<em>3.7 新版功能.</em></p></li><li><p><code>os.RWF_SYNC</code></p><p>提供立即写入功能，等效于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_SYNC" target="_blank" rel="noopener"><code>O_SYNC</code></a> <code>open(2)</code> 标志。该标志仅作用于系统调用写入的数据。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 4.7 或更高版本。<em>3.7 新版功能.</em></p></li><li><p><code>os.read</code>(<em>fd</em>, <em>n</em>)</p><p>从文件描述符 <em>fd</em> 中读取至多 <em>n</em> 个字节。返回所读取字节的字节串 (bytestring)。如果到达了 <em>fd</em> 指向的文件末尾，则返回空字节对象。</p><blockquote><p> 该功能适用于低级 I/O 操作，必须用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pipe" target="_blank" rel="noopener"><code>pipe()</code></a> 返回的文件描述符。若要读取由内建函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a> 返回的 “文件对象”，则应使用其相应的 <code>read()</code> 或 <code>readline()</code> 方法。 </p></blockquote><p> <em>在 3.5 版更改:</em> 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。 </p></li><li><p><code>os.sendfile</code>(<em>out</em>, <em>in</em>, <em>offset</em>, <em>count</em>)</p><p><code>os.sendfile</code>(<em>out</em>, <em>in</em>, <em>offset</em>, <em>count</em>, [<em>headers</em>, ][<em>trailers</em>, ]<em>flags=0</em>)</p><p>将文件描述符 <em>in</em> 中的 <em>count</em> 字节复制到文件描述符 <em>out</em> 的偏移位置 <em>offset</em> 处。返回复制的字节数，如果到达 EOF，返回 0。</p><p>定义了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sendfile" target="_blank" rel="noopener"><code>sendfile()</code></a> 的所有平台均支持第一种函数用法。</p><p>在 Linux 上，将 <em>offset</em> 设置为 <code>None</code>，则从 <em>in</em> 的当前位置开始读取，并更新 <em>in</em> 的位置。</p><p>第二种函数用法可以在 Mac OS X 和 FreeBSD 上使用，其中，<em>headers</em> 和 <em>trailers</em> 是任意的缓冲区序列，它们分别在写入 <em>in</em> 的数据前、后被写入。返回值与第一种用法相同。</p><p>在 Mac OS X 和 FreeBSD 上，将 <em>count</em> 设为 0 表示持续复制直到 <em>in</em> 的结尾。</p><p>所有平台都支持将套接字作为 <em>out</em> 文件描述符，有些平台也支持其他类型（如常规文件或管道）。</p><p>跨平台应用程序不应使用 <em>headers</em>、<em>trailers</em> 和 <em>flags</em> 参数。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p><blockquote><p> 注解：有关 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sendfile" target="_blank" rel="noopener"><code>sendfile()</code></a> 的高级封装，参见 <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.socket.sendfile" target="_blank" rel="noopener"><code>socket.socket.sendfile()</code></a>。</p></blockquote></li><li><p><code>os.set_blocking</code>(<em>fd</em>, <em>blocking</em>)</p><p>设置指定文件描述符的阻塞模式：如果 blocking 为 <code>False</code>，则为该描述符设置 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_NONBLOCK" target="_blank" rel="noopener"><code>O_NONBLOCK</code></a> 标志位，反之则清除该标志位。参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.get_blocking" target="_blank" rel="noopener"><code>get_blocking()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.socket.setblocking" target="_blank" rel="noopener"><code>socket.socket.setblocking()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.5 新版功能.</em></p></li><li><p><code>os.SF_NODISKIO</code></p></li><li><p><code>os.SF_MNOWAIT</code></p></li><li><p><code>os.SF_SYNC</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sendfile" target="_blank" rel="noopener"><code>sendfile()</code></a> 函数的参数（假设当前实现支持这些参数）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.readv</code>(<em>fd</em>, <em>buffers</em>)</p><p>从文件描述符 <em>fd</em> 将数据读取至多个可变的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 缓冲区 <em>buffers</em> 中。将数据依次存放到每个缓冲区中，填满一个后继续存放到序列中的下一个缓冲区，来保存其余数据。返回实际读取的字节总数，该总数可以小于所有对象的总容量。操作系统可能对允许使用的缓冲区数量有限制（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 获取 <code>&#39;SC_IOV_MAX&#39;</code> 值）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.tcgetpgrp</code>(<em>fd</em>)</p><p>返回与 <em>fd</em> 指定的终端相关联的进程组（<em>fd</em> 是由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 返回的已打开的文件描述符）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.tcsetpgrp</code>(<em>fd</em>, <em>pg</em>)</p><p>设置与 <em>fd</em> 指定的终端相关联的进程组为 <em>pg\</em>（<em>fd</em> 是由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 返回的已打开的文件描述符）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.ttyname</code>(<em>fd</em>)</p><p>返回一个字符串，该字符串表示与文件描述符 <em>fd</em> 关联的终端。如果 <em>fd</em> 没有与终端关联，则抛出异常。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.write</code>(<em>fd</em>, <em>str</em>)</p><p>将 <em>str</em> 中的字节串 (bytestring) 写入文件描述符 <em>fd</em>。返回实际写入的字节数。</p><blockquote><p> 该功能适用于低级 I/O 操作，必须用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pipe" target="_blank" rel="noopener"><code>pipe()</code></a> 返回的文件描述符。若要写入由内建函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdout" target="_blank" rel="noopener"><code>sys.stdout</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stderr" target="_blank" rel="noopener"><code>sys.stderr</code></a> 返回的 “文件对象”，则应使用其相应的 <code>write()</code> 方法。 </p></blockquote><p> <em>在 3.5 版更改:</em> 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。 </p></li><li><p><code>os.writev</code>(<em>fd</em>, <em>buffers</em>)</p><p>将缓冲区 <em>buffers</em> 的内容写入文件描述符 <em>fd</em>。缓冲区 <em>buffers</em> 必须是由 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 组成的序列。缓冲区以数组顺序处理。先写入第一个缓冲区的全部内容，再写入第二个缓冲区，照此继续。</p><p>返回实际写入的字节总数。</p><p>操作系统可能对允许使用的缓冲区数量有限制（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 获取 <code>&#39;SC_IOV_MAX&#39;</code> 值）。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p><p><em>3.3 新版功能.</em></p></li></ul><h3 id="查询终端的尺寸"><a href="#查询终端的尺寸" class="headerlink" title="查询终端的尺寸"></a>查询终端的尺寸</h3><p><em>3.3 新版功能.</em></p><ul><li><p><code>os.get_terminal_size</code>(<em>fd=STDOUT_FILENO</em>)</p><p>返回终端窗口的尺寸，格式为 <code>(columns, lines)</code>，它是类型为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.terminal_size" target="_blank" rel="noopener"><code>terminal_size</code></a> 的元组。可选参数 <code>fd</code> （默认为 <code>STDOUT_FILENO</code> 或标准输出）指定应查询的文件描述符。如果文件描述符未连接到终端，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_terminal_size" target="_blank" rel="noopener"><code>shutil.get_terminal_size()</code></a> 是供常规使用的高阶函数，<code>os.get_terminal_size</code> 是其底层的实现。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><em>class</em> <code>os.terminal_size</code></p><p>元组的子类，存储终端窗口尺寸 <code>(columns, lines)</code>。<code>columns</code>终端窗口的宽度，单位为字符。<code>lines</code>终端窗口的高度，单位为字符。</p></li></ul><h3 id="文件描述符的继承"><a href="#文件描述符的继承" class="headerlink" title="文件描述符的继承"></a>文件描述符的继承</h3><p><em>3.4 新版功能.</em></p><p>每个文件描述符都有一个 “inheritable”（可继承）标志位，该标志位控制了文件描述符是否可以由子进程继承。从 Python 3.4 开始，由 Python 创建的文件描述符默认是不可继承的。</p><p>在 UNIX 上，执行新程序时，不可继承的文件描述符在子进程中是关闭的，其他文件描述符将被继承。</p><p>在 Windows 上，不可继承的句柄和文件描述符在子进程中是关闭的，但标准流（文件描述符 0、1 和 2 即标准输入、标准输出和标准错误）是始终继承的。如果使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 函数，所有可继承的句柄和文件描述符都将被继承。如果使用 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 模块，将关闭除标准流以外的所有文件描述符，并且仅当 <em>close_fds</em> 参数为 <code>False</code> 时才继承可继承的句柄。</p><ul><li><p><code>os.get_inheritable</code>(<em>fd</em>)</p><p>获取指定文件描述符的“可继承”标志位（为布尔值）。</p></li><li><p><code>os.set_inheritable</code>(<em>fd</em>, <em>inheritable</em>)</p><p>设置指定文件描述符的“可继承”标志位。</p></li><li><p><code>os.get_handle_inheritable</code>(<em>handle</em>)</p><p>获取指定句柄的“可继承”标志位（为布尔值）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。</p></li><li><p><code>os.set_handle_inheritable</code>(<em>handle</em>, <em>inheritable</em>)</p><p>设置指定句柄的“可继承”标志位。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。</p></li></ul><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>在某些 Unix 平台上，许多函数支持以下一项或多项功能：</p><ul><li><p><strong>指定文件描述符为参数：</strong> 通常在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中提供给函数的 <em>path</em> 参数必须是表示文件路径的字符串，但是，某些函数现在可以接受其 <em>path</em> 参数为打开文件描述符，该函数将对描述符指向的文件进行操作。（对于 POSIX 系统，Python 将调用以 <code>f</code> 开头的函数变体（如调用 <code>fchdir</code> 而不是 <code>chdir</code>）。）</p><p>可以用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_fd" target="_blank" rel="noopener"><code>os.supports_fd</code></a> 检查某个函数在你的平台上是否支持将 <em>path</em> 参数指定为文件描述符。如果不支持，使用该功能将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p><p>如果该函数还支持 <em>dir_fd</em> 或 <em>follow_symlinks</em> 参数，那么用文件描述符作为 <em>path</em> 后就不能再指定上述参数了。</p></li><li><p><strong>基于目录描述符的相对路径：</strong> 如果 <em>dir_fd</em> 不是 <code>None</code>，它就应该是一个指向目录的文件描述符，这时待操作的 path 应该是相对路径，相对路径是相对于前述目录的。如果 path 是绝对路径，则 <em>dir_fd</em> 将被忽略。（对于 POSIX 系统，Python 将调用该函数的变体，变体以 <code>at</code> 结尾，可能以 <code>f</code> 开头（如调用 <code>faccessat</code> 而不是 <code>access</code>）。</p><p>可以用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_dir_fd" target="_blank" rel="noopener"><code>os.supports_dir_fd</code></a> 检查某个函数在你的平台上是否支持 <em>dir_fd</em>。如果不支持，使用该功能将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p></li><li><p><strong>不跟踪符号链接：</strong> 如果 <em>follow_symlinks</em> 为 <code>False</code>，并且待操作路径的最后一个元素是符号链接，则该函数将在符号链接本身而不是链接所指向的文件上操作。（对于 POSIX 系统，Python 将调用该函数的 <code>l...</code> 变体。）</p><p>可以用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_follow_symlinks" target="_blank" rel="noopener"><code>os.supports_follow_symlinks</code></a> 检查某个函数在你的平台上是否支持 <em>follow_symlinks</em>。如果不支持，使用该功能将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p></li><li><p><code>os.access</code>(<em>path</em>, <em>mode</em>, <em>**, </em>dir_fd=None<em>, </em>effective_ids=False<em>, </em>follow_symlinks=True*)</p><p>使用 实际用户ID/用户组ID 测试对 <em>path</em> 的访问。请注意，大多数测试操作将使用 有效用户ID/用户组ID，因此可以在 suid/sgid 环境中运用此例程，来测试调用用户是否具有对 <em>path</em> 的指定访问权限。<em>mode</em> 为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_OK" target="_blank" rel="noopener"><code>F_OK</code></a> 时用于测试 <em>path</em> 是否存在，也可以对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.R_OK" target="_blank" rel="noopener"><code>R_OK</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.W_OK" target="_blank" rel="noopener"><code>W_OK</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.X_OK" target="_blank" rel="noopener"><code>X_OK</code></a> 中的一个或多个进行“或”运算来测试指定权限。允许访问则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>，否则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>。更多信息请参见 Unix 手册页 <em><a href="https://manpages.debian.org/access(2" target="_blank" rel="noopener">access(2)</a>)</em>。本函数支持指定 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。如果 <em>effective_ids</em> 为 <code>True</code>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>access()</code></a> 将使用 有效用户ID/用户组ID 而非 实际用户ID/用户组ID 进行访问检查。您的平台可能不支持 <em>effective_ids</em>，您可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_effective_ids" target="_blank" rel="noopener"><code>os.supports_effective_ids</code></a> 检查它是否可用。如果不可用，使用它时会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p><blockquote><p>注解：使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>access()</code></a> 来检查用户是否具有某项权限（如打开文件的权限），然后再使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 打开文件，这样做存在一个安全漏洞，因为用户可能会在检查和打开文件之间的时间里做其他操作。推荐使用 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-eafp" target="_blank" rel="noopener">EAFP</a> 技术。如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> os.access(<span class="string">"myfile"</span>, os.R_OK):</span><br><span class="line">&gt;     <span class="keyword">with</span> open(<span class="string">"myfile"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">&gt;         <span class="keyword">return</span> fp.read()</span><br><span class="line">&gt; <span class="keyword">return</span> <span class="string">"some default data"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>​      最好写成: </p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">try</span>:</span><br><span class="line">&gt;     fp = open(<span class="string">"myfile"</span>)</span><br><span class="line">&gt; <span class="keyword">except</span> PermissionError:</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="string">"some default data"</span></span><br><span class="line">&gt; <span class="keyword">else</span>:</span><br><span class="line">&gt;     <span class="keyword">with</span> fp:</span><br><span class="line">&gt;         <span class="keyword">return</span> fp.read()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>即使 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>access()</code></a> 指示 I/O 操作会成功，但实际操作仍可能失败，尤其是对网络文件系统的操作，其权限语义可能超出常规的 POSIX 权限位模型。</p></blockquote><ul><li><p><code>os.F_OK</code></p></li><li><p><code>os.R_OK</code></p></li><li><p><code>os.W_OK</code></p></li><li><p><code>os.X_OK</code></p><p>作为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>access()</code></a> 的 <em>mode</em> 参数的可选值，分别测试 <em>path</em> 的存在性、可读性、可写性和可执行性。</p></li><li><p><code>os.chdir</code>(<em>path</em>)</p><p>将当前工作目录更改为 <em>path</em>。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。其中，描述符必须指向打开的目录，不能是打开的文件。本函数可以抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 及其子类的异常，如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileNotFoundError" target="_blank" rel="noopener"><code>FileNotFoundError</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#PermissionError" target="_blank" rel="noopener"><code>PermissionError</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotADirectoryError" target="_blank" rel="noopener"><code>NotADirectoryError</code></a> 异常。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chdir</code>，附带参数 <code>path</code>。<em>3.3 新版功能:</em> 在某些平台上新增支持将 <em>path</em> 参数指定为文件描述符。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.chflags</code>(<em>path</em>, <em>flags</em>, <em>**, </em>follow_symlinks=True*)</p><p>将 <em>path</em> 的 flags 设置为其他由数字表示的 <em>flags</em>。<em>flags</em> 可以用以下值按位或组合起来（以下值在 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中定义）：<a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_NODUMP" target="_blank" rel="noopener"><code>stat.UF_NODUMP</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_IMMUTABLE" target="_blank" rel="noopener"><code>stat.UF_IMMUTABLE</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_APPEND" target="_blank" rel="noopener"><code>stat.UF_APPEND</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_OPAQUE" target="_blank" rel="noopener"><code>stat.UF_OPAQUE</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_NOUNLINK" target="_blank" rel="noopener"><code>stat.UF_NOUNLINK</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_COMPRESSED" target="_blank" rel="noopener"><code>stat.UF_COMPRESSED</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_HIDDEN" target="_blank" rel="noopener"><code>stat.UF_HIDDEN</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_ARCHIVED" target="_blank" rel="noopener"><code>stat.SF_ARCHIVED</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_IMMUTABLE" target="_blank" rel="noopener"><code>stat.SF_IMMUTABLE</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_APPEND" target="_blank" rel="noopener"><code>stat.SF_APPEND</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_NOUNLINK" target="_blank" rel="noopener"><code>stat.SF_NOUNLINK</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_SNAPSHOT" target="_blank" rel="noopener"><code>stat.SF_SNAPSHOT</code></a>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chflags</code>，附带参数 <code>path</code>、<code>flags</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能:</em> <em>follow_symlinks</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.chmod</code>(<em>path</em>, <em>mode</em>, <em>**, </em>dir_fd=None<em>, </em>follow_symlinks=True*)</p><p>将 <em>path</em> 的 mode 更改为其他由数字表示的 <em>mode</em>。<em>mode</em> 可以用以下值之一，也可以将它们按位或组合起来（以下值在 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中定义）：</p><ul><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ISUID" target="_blank" rel="noopener"><code>stat.S_ISUID</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ISGID" target="_blank" rel="noopener"><code>stat.S_ISGID</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ENFMT" target="_blank" rel="noopener"><code>stat.S_ENFMT</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ISVTX" target="_blank" rel="noopener"><code>stat.S_ISVTX</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IREAD" target="_blank" rel="noopener"><code>stat.S_IREAD</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IWRITE" target="_blank" rel="noopener"><code>stat.S_IWRITE</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IEXEC" target="_blank" rel="noopener"><code>stat.S_IEXEC</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRWXU" target="_blank" rel="noopener"><code>stat.S_IRWXU</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRUSR" target="_blank" rel="noopener"><code>stat.S_IRUSR</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IWUSR" target="_blank" rel="noopener"><code>stat.S_IWUSR</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IXUSR" target="_blank" rel="noopener"><code>stat.S_IXUSR</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRWXG" target="_blank" rel="noopener"><code>stat.S_IRWXG</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRGRP" target="_blank" rel="noopener"><code>stat.S_IRGRP</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IWGRP" target="_blank" rel="noopener"><code>stat.S_IWGRP</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IXGRP" target="_blank" rel="noopener"><code>stat.S_IXGRP</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRWXO" target="_blank" rel="noopener"><code>stat.S_IRWXO</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IROTH" target="_blank" rel="noopener"><code>stat.S_IROTH</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IWOTH" target="_blank" rel="noopener"><code>stat.S_IWOTH</code></a></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IXOTH" target="_blank" rel="noopener"><code>stat.S_IXOTH</code></a></p><p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符</a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">指定基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。 </p></li></ul><blockquote><p> 尽管 Windows 支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>chmod()</code></a>，但只能用它设置文件的只读标志（<code>stat.S_IWRITE</code> 和 <code>stat.S_IREAD</code> 常量或对应的整数值）。所有其他标志位都会被忽略。</p></blockquote></li></ul><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chmod</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。</p><p><em>3.3 新版功能:</em> 添加了指定 <em>path</em> 为文件描述符的支持，以及 <em>dir_fd</em> 和 <em>follow_symlinks</em> 参数。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><ul><li><p><code>os.chown</code>(<em>path</em>, <em>uid</em>, <em>gid</em>, <em>**, </em>dir_fd=None<em>, </em>follow_symlinks=True*)</p><p>将 <em>path</em> 的用户和组 ID 分别修改为数字形式的 <em>uid</em> 和 <em>gid</em>。若要使其中某个 ID 保持不变，请将其置为 -1。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符</a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">指定基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。参见更高阶的函数 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.chown" target="_blank" rel="noopener"><code>shutil.chown()</code></a>，除了数字 ID 之外，它也接受名称。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chown</code>，附带参数 <code>path</code>、<code>uid</code>、<code>gid</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能:</em> 添加了指定 <em>path</em> 为文件描述符的支持，以及 <em>dir_fd</em> 和 <em>follow_symlinks</em> 参数。<em>在 3.6 版更改:</em> 支持 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.chroot</code>(<em>path</em>)</p><p>将当前进程的根目录更改为 <em>path</em>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.fchdir</code>(<em>fd</em>)</p><p>将当前工作目录更改为文件描述符 <em>fd</em> 指向的目录。fd 必须指向打开的目录而非文件。从 Python 3.3 开始，它等效于 <code>os.chdir(fd)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chdir</code>，附带参数 <code>path</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.getcwd</code>()</p><p>返回表示当前工作目录的字符串。</p></li><li><p><code>os.getcwdb</code>()</p><p>返回表示当前工作目录的字节串 (bytestring)。<em>在 3.8 版更改:</em> 在 Windows 上，本函数现在会使用 UTF-8 编码格式而不是 ANSI 代码页：请参看 <a href="https://www.python.org/dev/peps/pep-0529" target="_blank" rel="noopener"><strong>PEP 529</strong></a> 了解具体原因。 该函数在 Windows 上不再被弃用。</p></li><li><p><code>os.lchflags</code>(<em>path</em>, <em>flags</em>)</p><p>将 <em>path</em> 的 flags 设置为其他由数字表示的 <em>flags</em>，与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chflags" target="_blank" rel="noopener"><code>chflags()</code></a> 类似，但不跟踪符号链接。从 Python 3.3 开始，它等效于 <code>os.chflags(path, flags, follow_symlinks=False)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chflags</code>，附带参数 <code>path</code>、<code>flags</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.lchmod</code>(<em>path</em>, <em>mode</em>)</p><p>将 <em>path</em> 的权限状态修改为 <em>mode</em>。如果 path 是符号链接，则影响符号链接本身而非链接目标。可以参考 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>chmod()</code></a> 中列出 <em>mode</em> 的可用值。从 Python 3.3 开始，它等效于 <code>os.chmod(path, mode, follow_symlinks=False)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chmod</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.lchown</code>(<em>path</em>, <em>uid</em>, <em>gid</em>)</p><p>将 <em>path</em> 的用户和组 ID 分别修改为数字形式的 <em>uid</em> 和 <em>gid</em>，本函数不跟踪符号链接。从 Python 3.3 开始，它等效于 <code>os.chown(path, uid, gid, follow_symlinks=False)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chown</code>，附带参数 <code>path</code>、<code>uid</code>、<code>gid</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.link</code>(<em>src</em>, <em>dst</em>, <em>**, </em>src_dir_fd=None<em>, </em>dst_dir_fd=None<em>, </em>follow_symlinks=True*)</p><p>创建一个指向 <em>src</em> 的硬链接，名为 <em>dst</em>。本函数支持将 <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 中的一个或两个指定为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>，支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.link</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加了对 Windows 的支持。<em>3.3 新版功能:</em> 添加 <em>src_dir_fd</em>、<em>dst_dir_fd</em> 和 <em>follow_symlinks</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p></li><li><p><code>os.listdir</code>(<em>path=’.’</em>)</p><p>返回一个列表，该列表包含了 <em>path</em> 中所有文件与目录的名称。该列表按任意顺序排列，并且不包含特殊条目 <code>&#39;.&#39;</code> 和 <code>&#39;..&#39;</code>，即使它们确实在目录中存在。<em>path</em> 可以是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。如果 <em>path</em> 是（直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入） <code>bytes</code> 类型，则返回的文件名也将是 <code>bytes</code> 类型，其他情况下是 <code>str</code> 类型。本函数也支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>，其中描述符必须指向目录。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.listdir</code>，附带参数 <code>path</code>。</p><blockquote><p>要将 <code>str</code> 类型的文件名编码为 <code>bytes</code>，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsencode" target="_blank" rel="noopener"><code>fsencode()</code></a>。</p></blockquote><p> <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 函数返回目录内文件名的同时，也返回文件属性信息，它在某些具体情况下能提供更好的性能。</p></li></ul><p><em>在 3.2 版更改:</em> <em>path</em> 变为可选参数。</p><p><em>3.3 新版功能:</em> 新增支持将 <em>path</em> 参数指定为打开的文件描述符。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><ul><li><code>os.lstat</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</li></ul><p>在给定路径上执行本函数，其操作相当于 <code>lstat()</code> 系统调用，类似于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 但不跟踪符号链接。返回值是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 对象。</p><p>在不支持符号链接的平台上，本函数是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 的别名。</p><p>从 Python 3.3 起，此功能等价于 <code>os.stat(path, dir_fd=dir_fd, follow_symlinks=False)</code>。</p><p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。</p><p><em>在 3.2 版更改:</em> 添加对 Windows 6.0 (Vista) 符号链接的支持。</p><p><em>在 3.3 版更改:</em> 添加了 <em>dir_fd</em> 参数。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p><p><em>在 3.8 版更改:</em> 目前在 Windows 上，遇到表示另一个路径的重解析点（即名称代理，包括符号链接和目录结点），本函数将打开它。其他种类的重解析点由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 交由操作系统解析。</p><ul><li><p><code>os.mkdir</code>(<em>path</em>, <em>mode=0o777</em>, <em>**, </em>dir_fd=None*)</p><p>创建一个名为 <em>path</em> 的目录，应用以数字表示的权限模式 <em>mode</em>。如果目录已存在，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileExistsError" target="_blank" rel="noopener"><code>FileExistsError</code></a> 异常。某些系统会忽略 <em>mode</em>。如果没有忽略它，那么将首先从它中减去当前的 umask 值。如果除最后 9 位（即 <em>mode</em> 八进制的最后 3 位）之外，还设置了其他位，则其他位的含义取决于各个平台。在某些平台上，它们会被忽略，应显式调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>chmod()</code></a> 进行设置。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。如果需要创建临时目录，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#module-tempfile" target="_blank" rel="noopener"><code>tempfile</code></a> 模块中的 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>tempfile.mkdtemp()</code></a> 函数。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.mkdir</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.makedirs</code>(<em>name</em>, <em>mode=0o777</em>, <em>exist_ok=False</em>)</p><p>递归目录创建函数。与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.mkdir" target="_blank" rel="noopener"><code>mkdir()</code></a> 类似，但会自动创建到达最后一级目录所需要的中间目录。<em>mode</em> 参数会传递给 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.mkdir" target="_blank" rel="noopener"><code>mkdir()</code></a>，用来创建最后一级目录，对于该参数的解释，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#mkdir-modebits" target="_blank" rel="noopener">mkdir() 中的描述</a>。要设置某些新建的父目录的权限，可以在调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.makedirs" target="_blank" rel="noopener"><code>makedirs()</code></a> 之前设置 umask。现有父目录的权限不会更改。如果 <em>exist_ok</em> 为 <code>False</code> (默认值)，则如果目标目录已存在将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileExistsError" target="_blank" rel="noopener"><code>FileExistsError</code></a>。</p><blockquote><p>如果要创建的路径元素包含 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pardir" target="_blank" rel="noopener"><code>pardir</code></a> (如 UNIX 系统中的 “..”) <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.makedirs" target="_blank" rel="noopener"><code>makedirs()</code></a> 将无法明确目标。</p></blockquote></li></ul><p>本函数能正确处理 UNC 路径。</p><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.mkdir</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。</p><p><em>3.2 新版功能:</em> <em>exist_ok</em> 参数。</p><p><em>在 3.4.1 版更改:</em> 在 Python 3.4.1 以前，如果 <em>exist_ok</em> 为 <code>True</code>，且目录已存在，且 <em>mode</em> 与现有目录的权限不匹配，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.makedirs" target="_blank" rel="noopener"><code>makedirs()</code></a> 仍会抛出错误。由于无法安全地实现此行为，因此在 Python 3.4.1 中将该行为删除。请参阅 <a href="https://bugs.python.org/issue21082" target="_blank" rel="noopener">bpo-21082</a>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>在 3.7 版更改:</em> <em>mode</em> 参数不再影响新创建的中间目录的权限。</p><ul><li><p><code>os.mkfifo</code>(<em>path</em>, <em>mode=0o666</em>, <em>**, </em>dir_fd=None*)</p><p>创建一个名为 <em>path</em> 的 FIFO（命名管道，一种先进先出队列），具有以数字表示的权限状态 <em>mode</em>。将从 mode 中首先减去当前的 umask 值。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。FIFO 是可以像常规文件一样访问的管道。FIFO 如果没有被删除（如使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unlink" target="_blank" rel="noopener"><code>os.unlink()</code></a>），会一直存在。通常，FIFO 用作“客户端”和“服务器”进程之间的汇合点：服务器打开 FIFO 进行读取，而客户端打开 FIFO 进行写入。请注意，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.mkfifo" target="_blank" rel="noopener"><code>mkfifo()</code></a> 不会打开 FIFO — 它只是创建汇合点。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.mknod</code>(<em>path</em>, <em>mode=0o600</em>, <em>device=0</em>, <em>**, </em>dir_fd=None*)</p><p>创建一个名为 <em>path</em> 的文件系统节点（文件，设备专用文件或命名管道）。<em>mode</em> 指定权限和节点类型，方法是将权限与下列节点类型 <code>stat.S_IFREG</code>、<code>stat.S_IFCHR</code>、<code>stat.S_IFBLK</code> 和 <code>stat.S_IFIFO</code> 之一（按位或）组合（这些常量可以在 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中找到）。对于 <code>stat.S_IFCHR</code> 和 <code>stat.S_IFBLK</code>，<em>device</em> 参数指定了新创建的设备专用文件（可能会用到 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.makedev" target="_blank" rel="noopener"><code>os.makedev()</code></a>），否则该参数将被忽略。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.major</code>(<em>device</em>)</p><p>提取主设备号，提取自原始设备号（通常是 <code>stat</code> 中的 <code>st_dev</code> 或 <code>st_rdev</code> 字段）。</p></li><li><p><code>os.minor</code>(<em>device</em>)</p><p>提取次设备号，提取自原始设备号（通常是 <code>stat</code> 中的 <code>st_dev</code> 或 <code>st_rdev</code> 字段）。</p></li><li><p><code>os.makedev</code>(<em>major</em>, <em>minor</em>)</p><p>将主设备号和次设备号组合成原始设备号。</p></li><li><p><code>os.pathconf</code>(<em>path</em>, <em>name</em>)</p><p>返回所给名称的文件有关的系统配置信息。<em>name</em> 指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX.1，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 <code>pathconf_names</code> 字典中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 <em>name</em>。如果 <em>name</em> 是一个字符串且不是已定义的名称，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。如果当前系统不支持 <em>name</em> 指定的配置名称，即使该名称存在于 <code>pathconf_names</code>，也会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，错误码为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EINVAL" target="_blank" rel="noopener"><code>errno.EINVAL</code></a>。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.pathconf_names</code></p><p>字典，表示映射关系，为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pathconf" target="_blank" rel="noopener"><code>pathconf()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fpathconf" target="_blank" rel="noopener"><code>fpathconf()</code></a> 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.readlink</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</p><p>返回一个字符串，为符号链接指向的实际路径。其结果可以是绝对或相对路径。如果是相对路径，则可用 <code>os.path.join(os.path.dirname(path), result)</code> 转换为绝对路径。如果 <em>path</em> 是字符串对象（直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入），则结果也将是字符串对象，且此类调用可能会引发 UnicodeDecodeError。如果 <em>path</em> 是字节对象（直接传入或间接传入），则结果将会是字节对象。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。当尝试解析的路径可能含有链接时，请改用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.realpath" target="_blank" rel="noopener"><code>realpath()</code></a> 以正确处理递归和平台差异。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加对 Windows 6.0 (Vista) 符号链接的支持。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 在 Unix 上可以接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。<em>在 3.8 版更改:</em> 在 Windows 上接受 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 和字节对象。<em>在 3.8 版更改:</em> 增加了对目录链接的支持，且返回值改为了“替换路径”的形式（通常带有 <code>\\?\</code> 前缀），而不是先前那样返回可选的 “print name” 字段。</p></li><li><p><code>os.remove</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</p><p>移除（删除）文件 <em>path</em>。如果 <em>path</em> 是目录，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IsADirectoryError" target="_blank" rel="noopener"><code>IsADirectoryError</code></a> 异常。请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rmdir" target="_blank" rel="noopener"><code>rmdir()</code></a> 删除目录。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。在 Windows 上，尝试删除正在使用的文件会抛出异常。而在 Unix 上，虽然该文件的条目会被删除，但分配给文件的存储空间仍然不可用，直到原始文件不再使用为止。本函数在语义上与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unlink" target="_blank" rel="noopener"><code>unlink()</code></a> 相同。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.remove</code>，附带参数 <code>path</code>、<code>dir_fd</code>。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.removedirs</code>(<em>name</em>)</p><p>递归删除目录。工作方式类似于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rmdir" target="_blank" rel="noopener"><code>rmdir()</code></a>，不同之处在于，如果成功删除了末尾一级目录，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.removedirs" target="_blank" rel="noopener"><code>removedirs()</code></a> 会尝试依次删除 <em>path</em> 中提到的每个父目录，直到抛出错误为止（但该错误会被忽略，因为这通常表示父目录不是空目录）。例如，<code>os.removedirs(&#39;foo/bar/baz&#39;)</code> 将首先删除目录 <code>&#39;foo/bar/baz&#39;</code>，然后如果 <code>&#39;foo/bar&#39;</code> 和 <code>&#39;foo&#39;</code> 为空，则继续删除它们。如果无法成功删除末尾一级目录，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.remove</code>，附带参数 <code>path</code>、<code>dir_fd</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.rename</code>(<em>src</em>, <em>dst</em>, <em>**, </em>src_dir_fd=None<em>, </em>dst_dir_fd=None*)</p><p>将文件或目录 <em>src</em> 重命名为 <em>dst</em>。如果 <em>dst</em> 已存在，则下列情况下将会操作失败，并抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的子类：在 Windows 上，如果 <em>dst</em> 已存在，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileExistsError" target="_blank" rel="noopener"><code>FileExistsError</code></a> 异常。在 Unix 上，如果 <em>src</em> 是文件而 <em>dst</em> 是目录，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IsADirectoryError" target="_blank" rel="noopener"><code>IsADirectoryError</code></a> 异常，反之则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotADirectoryError" target="_blank" rel="noopener"><code>NotADirectoryError</code></a> 异常。如果两者都是目录且 <em>dst</em> 为空，则 <em>dst</em> 将被静默替换。如果 <em>dst</em> 是非空目录，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。如果两者都是文件，则在用户具有权限的情况下，将对 <em>dst</em> 进行静默替换。如果 <em>src</em> 和 <em>dst</em> 在不同的文件系统上，则本操作在某些 Unix 分支上可能会失败。如果成功，重命名操作将是一个原子操作（这是 POSIX 的要求）。本函数支持将 <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 中的一个或两个指定为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。如果需要在不同平台上都能替换目标，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.replace" target="_blank" rel="noopener"><code>replace()</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.rename</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。<em>3.3 新版功能:</em> <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p></li><li><p><code>os.renames</code>(<em>old</em>, <em>new</em>)</p><p>递归重命名目录或文件。工作方式类似 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>rename()</code></a>，除了会首先创建新路径所需的中间目录。重命名后，将调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.removedirs" target="_blank" rel="noopener"><code>removedirs()</code></a> 删除旧路径中不需要的目录。注解 如果用户没有权限删除末级的目录或文件，则本函数可能会无法建立新的目录结构。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.rename</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>old</em> 和 <em>new</em>。</p></li><li><p><code>os.replace</code>(<em>src</em>, <em>dst</em>, <em>**, </em>src_dir_fd=None<em>, </em>dst_dir_fd=None*)</p><p>将文件或目录 <em>src</em> 重命名为 <em>dst</em>。如果 <em>dst</em> 是目录，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。如果 <em>dst</em> 已存在且为文件，则在用户具有权限的情况下，将对其进行静默替换。如果 <em>src</em> 和 <em>dst</em> 在不同的文件系统上，本操作可能会失败。如果成功，重命名操作将是一个原子操作（这是 POSIX 的要求）。本函数支持将 <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 中的一个或两个指定为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.rename</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。<em>3.3 新版功能.**在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p></li><li><p><code>os.rmdir</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</p><p>移除（删除）目录 <em>path</em>。如果目录不存在或不为空，则会分别抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileNotFoundError" target="_blank" rel="noopener"><code>FileNotFoundError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。要删除整个目录树，可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree" target="_blank" rel="noopener"><code>shutil.rmtree()</code></a>。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.rmdir</code>，附带参数 <code>path</code>、<code>dir_fd</code>。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.scandir</code>(<em>path=’.’</em>)</p><p>返回一个迭代出 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry" target="_blank" rel="noopener"><code>os.DirEntry</code></a> 对象的迭代器，这些对象对应于 <em>path</em> 目录中的条目。条目的生成顺序是任意的，特殊条目 <code>&#39;.&#39;</code> 和 <code>&#39;..&#39;</code> 不包括在内。如果需要文件类型或文件属性信息，使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 代替 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>listdir()</code></a> 可以大大提高这部分代码的性能，因为如果操作系统在扫描目录时返回的是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry" target="_blank" rel="noopener"><code>os.DirEntry</code></a> 对象，则该对象包含了这些信息。所有 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry" target="_blank" rel="noopener"><code>os.DirEntry</code></a> 的方法都可能执行一次系统调用，但是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.is_dir" target="_blank" rel="noopener"><code>is_dir()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.is_file" target="_blank" rel="noopener"><code>is_file()</code></a> 通常只在有符号链接时才执行一次系统调用。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.stat" target="_blank" rel="noopener"><code>os.DirEntry.stat()</code></a> 在 Unix 上始终需要一次系统调用，而在 Windows 上只在有符号链接时才需要。<em>path</em> 可以是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。如果 <em>path</em> 是（直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入的） <code>bytes</code> 类型，那么每个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry" target="_blank" rel="noopener"><code>os.DirEntry</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.name" target="_blank" rel="noopener"><code>name</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.path" target="_blank" rel="noopener"><code>path</code></a> 属性将是 <code>bytes</code> 类型，其他情况下是 <code>str</code> 类型。本函数也支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>，其中描述符必须指向目录。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.scandir</code>，附带参数 <code>path</code>。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 迭代器支持 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-context-manager" target="_blank" rel="noopener">上下文管理</a> 协议，并具有以下方法：<code>scandir.close</code>()关闭迭代器并释放占用的资源。当迭代器迭代完毕，或垃圾回收，或迭代过程出错时，将自动调用本方法。但仍建议显式调用它或使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句。</p><p><em>3.6 新版功能.</em></p><p>下面的例子演示了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的简单用法，用来显示给定 <em>path</em> 中所有不以 <code>&#39;.&#39;</code> 开头的文件（不包括目录）。<code>entry.is_file()</code> 通常不会增加一次额外的系统调用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> os.scandir(path) <span class="keyword">as</span> it:</span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> it:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> entry.name.startswith(<span class="string">'.'</span>) <span class="keyword">and</span> entry.is_file():</span><br><span class="line">            print(entry.name)</span><br></pre></td></tr></table></figure><blockquote><p>在基于 Unix 的系统上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 使用系统的 <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html" target="_blank" rel="noopener">opendir()</a> 和 <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html" target="_blank" rel="noopener">readdir()</a> 函数。在 Windows 上，它使用 Win32 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418(v=vs.85" target="_blank" rel="noopener">FindFirstFileW</a>.aspx) 和 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364428(v=vs.85" target="_blank" rel="noopener">FindNextFileW</a>.aspx) 函数。</p></blockquote><p><em>.5 新版功能.</em></p><p><em>3.6 新版功能:</em> 添加了对 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-context-manager" target="_blank" rel="noopener">上下文管理</a> 协议和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir.close" target="_blank" rel="noopener"><code>close()</code></a> 方法的支持。如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 迭代器没有迭代完毕且没有显式关闭，其析构函数将发出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ResourceWarning" target="_blank" rel="noopener"><code>ResourceWarning</code></a> 警告。</p><p>本函数接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>在 3.7 版更改:</em> 在 Unix 上新增支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。</p></li><li><p><em>class</em> <code>os.DirEntry</code></p><p>由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 生成的对象，用于显示目录内某个条目的文件路径和其他文件属性。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 将在不进行额外系统调用的情况下，提供尽可能多的此类信息。每次进行 <code>stat()</code> 或 <code>lstat()</code> 系统调用时，<code>os.DirEntry</code> 对象会将结果缓存下来。</p><p><code>os.DirEntry</code> 实例不适合存储在长期存在的数据结构中，如果你知道文件元数据已更改，或者自调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 以来已经经过了很长时间，请调用 <code>os.stat(entry.path)</code> 来获取最新信息。</p><p>因为 <code>os.DirEntry</code> 方法可以进行系统调用，所以它也可能抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。如需精确定位错误，可以逐个调用 <code>os.DirEntry</code> 中的方法来捕获 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>，并适当处理。</p><p>为了能直接用作 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>，<code>os.DirEntry</code> 实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口。</p><p><code>os.DirEntry</code> 实例所包含的属性和方法如下：</p><ul><li><p><code>name</code></p><p>本条目的基本文件名，是根据 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数得出的相对路径。如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数是 <code>bytes</code> 类型，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.name" target="_blank" rel="noopener"><code>name</code></a> 属性也是 <code>bytes</code> 类型，否则为 <code>str</code>。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsdecode" target="_blank" rel="noopener"><code>fsdecode()</code></a> 解码 byte 类型的文件名。</p></li><li><p><code>path</code></p><p>本条目的完整路径：等效于 <code>os.path.join(scandir_path, entry.name)</code>，其中 <em>scandir_path</em> 就是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数。仅当 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数为绝对路径时，本路径才是绝对路径。如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">文件描述符</a>，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>path</code></a> 属性与上述 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.name" target="_blank" rel="noopener"><code>name</code></a> 属性相同。如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数是 <code>bytes</code> 类型，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>path</code></a> 属性也是 <code>bytes</code> 类型，否则为 <code>str</code>。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsdecode" target="_blank" rel="noopener"><code>fsdecode()</code></a> 解码 byte 类型的文件名。</p></li><li><p><code>inode</code>()</p><p>返回本条目的索引节点号 (inode number)。这一结果是缓存在 <code>os.DirEntry</code> 对象中的，请调用 <code>os.stat(entry.path, follow_symlinks=False).st_ino</code> 来获取最新信息。一开始没有缓存时，在 Windows 上需要一次系统调用，但在 Unix 上不需要。</p></li><li><p><code>is_dir</code>(<em>**, </em>follow_symlinks=True*)</p><p>如果本条目是目录，或是指向目录的符号链接，则返回 <code>True</code>。如果本条目是文件，或指向任何其他类型的文件，或该目录不再存在，则返回 <code>False</code>。如果 <em>follow_symlinks</em> 是 <code>False</code>，那么仅当本条目为目录时返回 <code>True</code> （不跟踪符号链接），如果本条目是任何类型的文件，或该文件不再存在，则返回 <code>False</code>。这一结果是缓存在 <code>os.DirEntry</code> 对象中的，且 <em>follow_symlinks</em> 为 <code>True</code> 和 <code>False</code> 时的缓存是分开的。请调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ISDIR" target="_blank" rel="noopener"><code>stat.S_ISDIR()</code></a> 来获取最新信息。一开始没有缓存时，大多数情况下不需要系统调用。特别是对于非符号链接，Windows 和 Unix 都不需要系统调用，除非某些 Unix 文件系统（如网络文件系统）返回了 <code>dirent.d_type == DT_UNKNOWN</code>。如果本条目是符号链接，则需要一次系统调用来跟踪它（除非 <em>follow_symlinks</em> 为 <code>False</code>）。本方法可能抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#PermissionError" target="_blank" rel="noopener"><code>PermissionError</code></a> 异常，但 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileNotFoundError" target="_blank" rel="noopener"><code>FileNotFoundError</code></a> 异常会被内部捕获且不会抛出。</p></li><li><p><code>is_file</code>(<em>**, </em>follow_symlinks=True*)</p><p>如果本条目是文件，或是指向文件的符号链接，则返回 <code>True</code>。如果本条目是目录，或指向目录，或指向其他非文件条目，或该文件不再存在，则返回 <code>False</code>。如果 <em>follow_symlinks</em> 是 <code>False</code>，那么仅当本条目为文件时返回 <code>True</code> （不跟踪符号链接），如果本条目是目录或其他非文件条目，或该文件不再存在，则返回 <code>False</code>。这一结果是缓存在 <code>os.DirEntry</code> 对象中的。缓存、系统调用、异常抛出都与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.is_dir" target="_blank" rel="noopener"><code>is_dir()</code></a> 一致。</p></li><li><p><code>is_symlink</code>()</p><p>如果本条目是符号链接（即使是断开的链接），返回 <code>True</code>。如果是目录或任何类型的文件，或本条目不再存在，返回 <code>False</code>。这一结果是缓存在 <code>os.DirEntry</code> 对象中的，请调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>os.path.islink()</code></a> 来获取最新信息。一开始没有缓存时，大多数情况下不需要系统调用。其实 Windows 和 Unix 都不需要系统调用，除非某些 Unix 文件系统（如网络文件系统）返回了 <code>dirent.d_type == DT_UNKNOWN</code>。本方法可能抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#PermissionError" target="_blank" rel="noopener"><code>PermissionError</code></a> 异常，但 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileNotFoundError" target="_blank" rel="noopener"><code>FileNotFoundError</code></a> 异常会被内部捕获且不会抛出。</p></li><li><p><code>stat</code>(<em>**, </em>follow_symlinks=True*)</p><p>返回本条目对应的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 对象。本方法默认会跟踪符号链接，要获取符号链接本身的 stat，请添加 <code>follow_symlinks=False</code> 参数。在 Unix 上，本方法需要一次系统调用。在 Windows 上，仅在 <em>follow_symlinks</em> 为 <code>True</code> 且该条目是一个重解析点（如符号链接或目录结点）时，才需要一次系统调用。在 Windows 上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 的 <code>st_ino</code>、<code>st_dev</code> 和 <code>st_nlink</code> 属性总是为零。请调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 以获得这些属性。这一结果是缓存在 <code>os.DirEntry</code> 对象中的，且 <em>follow_symlinks</em> 为 <code>True</code> 和 <code>False</code> 时的缓存是分开的。请调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 来获取最新信息。</p></li></ul><p>注意，<code>os.DirEntry</code> 和 <a href="https://docs.python.org/zh-cn/3.8/library/pathlib.html#pathlib.Path" target="_blank" rel="noopener"><code>pathlib.Path</code></a> 的几个属性和方法之间存在很好的对应关系。具体来说是 <code>name</code> 属性，以及 <code>is_dir()</code>、<code>is_file()</code>、<code>is_symlink()</code> 和 <code>stat()</code> 方法，在两个类中具有相同的含义。</p><p><em>3.5 新版功能.</em></p><p><em>在 3.6 版更改:</em> 添加了对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口的支持。在 Windows 上添加了对 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型路径的支持。</p></li><li><p><code>os.stat</code>(<em>path</em>, <em>**, </em>dir_fd=None<em>, </em>follow_symlinks=True*)</p><p>获取文件或文件描述符的状态。在所给路径上执行等效于 <code>stat()</code> 系统调用的操作。<em>path</em> 可以是字符串类型，或（直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入的） bytes 类型，或打开的文件描述符。返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 对象。</p><p>本函数默认会跟踪符号链接，要获取符号链接本身的 stat，请添加 <code>follow_symlinks=False</code> 参数，或使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>lstat()</code></a>。</p><p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。</p><p>在 Windows 上，传入 <code>follow_symlinks=False</code> 将禁用所有名称代理重解析点，其中包括符号链接和目录结点。其他类型的重解析点将直接打开，比如不像链接的或系统无法跟踪的重解析点。当多个链接形成一个链时，本方法可能会返回原始链接的 stat，无法完整遍历到非链接的对象。在这种情况下，要获取最终路径的 stat，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.realpath" target="_blank" rel="noopener"><code>os.path.realpath()</code></a> 函数尽可能地解析路径，并在解析结果上调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>lstat()</code></a>。这不适用于空链接或交接点，否则会抛出异常。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statinfo = os.stat(<span class="string">'somefile.txt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statinfo</span><br><span class="line">os.stat_result(st_mode=<span class="number">33188</span>, st_ino=<span class="number">7876932</span>, st_dev=<span class="number">234881026</span>,</span><br><span class="line">st_nlink=<span class="number">1</span>, st_uid=<span class="number">501</span>, st_gid=<span class="number">501</span>, st_size=<span class="number">264</span>, st_atime=<span class="number">1297230295</span>,</span><br><span class="line">st_mtime=<span class="number">1297230027</span>, st_ctime=<span class="number">1297230027</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statinfo.st_size</span><br><span class="line"><span class="number">264</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fstat" target="_blank" rel="noopener"><code>fstat()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>lstat()</code></a> 函数。</p></blockquote><p><em>3.3 新版功能:</em> 增加 <em>dir_fd</em> 和 <em>follow_symlinks</em> 参数，可指定文件描述符代替路径。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>在 3.8 版更改:</em> 在 Windows 上，本方法将跟踪系统能解析的所有重解析点，并且传入 <code>follow_symlinks=False</code> 会停止跟踪所有名称代理重解析点。现在，如果操作系统遇到无法跟踪的重解析点，<em>stat</em> 将返回原始路径的信息，就像已指定 <code>follow_symlinks=False</code> 一样，而不会抛出异常。</p><p><em>class</em> <code>os.stat_result</code></p><p>本对象的属性大致对应于 <code>stat</code> 结构体成员，主要作为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fstat" target="_blank" rel="noopener"><code>os.fstat()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>os.lstat()</code></a> 的返回值。</p><p>属性：</p><ul><li><p><code>st_mode</code></p><p>文件模式：包括文件类型和文件模式位（即权限位）。</p></li><li><p><code>st_ino</code></p><p>与平台有关，但如果不为零，则根据 <code>st_dev</code> 值唯一地标识文件。通常：在 Unix 上该值表示索引节点号 (inode number)。在 Windows 上该值表示 <a href="https://msdn.microsoft.com/en-us/library/aa363788" target="_blank" rel="noopener">文件索引号</a> 。</p></li><li><p><code>st_dev</code></p><p>该文件所在设备的标识符。</p></li><li><p><code>st_nlink</code></p><p>硬链接的数量。</p></li><li><p><code>st_uid</code></p><p>文件所有者的用户 ID。</p></li><li><p><code>st_gid</code></p><p>文件所有者的用户组 ID。</p></li><li><p><code>st_size</code></p><p>文件大小（以字节为单位），文件可以是常规文件或符号链接。符号链接的大小是它包含的路径的长度，不包括末尾的空字节。</p></li></ul><p>时间戳：</p><ul><li><p><code>st_atime</code></p><p>最近的访问时间，以秒为单位。</p></li><li><p><code>st_mtime</code></p><p>最近的修改时间，以秒为单位。</p></li><li><p><code>st_ctime</code></p><p>取决于平台：在 Unix 上表示最近的元数据更改时间，在 Windows 上表示创建时间，以秒为单位。</p></li><li><p><code>st_atime_ns</code></p><p>最近的访问时间，以纳秒表示，为整数。</p></li><li><p><code>st_mtime_ns</code></p><p>最近的修改时间，以纳秒表示，为整数。</p></li><li><p><code>st_ctime_ns</code></p><p>取决于平台：在 Unix 上表示最近的元数据更改时间，在 Windows 上表示创建时间，以纳秒表示，为整数。</p></li></ul><blockquote><p> <code>st_atime</code>](<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime)、[`st_mtime`](https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime)" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime)、[`st_mtime`](https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime)</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime" target="_blank" rel="noopener"><code>st_ctime</code></a> 属性的确切含义和分辨率取决于操作系统和文件系统。例如，在使用 FAT 或 FAT32 文件系统的 Windows 上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime" target="_blank" rel="noopener"><code>st_mtime</code></a> 有 2 秒的分辨率，而 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime" target="_blank" rel="noopener"><code>st_atime</code></a> 仅有 1 天的分辨率。详细信息请参阅操作系统文档。</p><p>类似地，尽管 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime_ns" target="_blank" rel="noopener"><code>st_atime_ns</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime_ns" target="_blank" rel="noopener"><code>st_mtime_ns</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime_ns" target="_blank" rel="noopener"><code>st_ctime_ns</code></a> 始终以纳秒表示，但许多系统并不提供纳秒精度。在确实提供纳秒精度的系统上，用于存储 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime" target="_blank" rel="noopener"><code>st_atime</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime" target="_blank" rel="noopener"><code>st_mtime</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime" target="_blank" rel="noopener"><code>st_ctime</code></a> 的浮点对象无法保留所有精度，因此不够精确。如果需要确切的时间戳，则应始终使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime_ns" target="_blank" rel="noopener"><code>st_atime_ns</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime_ns" target="_blank" rel="noopener"><code>st_mtime_ns</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime_ns" target="_blank" rel="noopener"><code>st_ctime_ns</code></a>。</p></blockquote><p>在某些 Unix 系统上（如 Linux 上），以下属性可能也可用：</p><ul><li><p><code>st_blocks</code></p><p>为文件分配的字节块数，每块 512 字节。文件是稀疏文件时，它可能小于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_size" target="_blank" rel="noopener"><code>st_size</code></a>/512。</p></li><li><p><code>st_blksize</code></p><p>“首选的” 块大小，用于提高文件系统 I/O 效率。写入文件时块大小太小可能会导致读取-修改-重写效率低下。</p></li><li><p><code>st_rdev</code></p><p>设备类型（如果是 inode 设备）。</p></li><li><p><code>st_flags</code></p><p>用户定义的文件标志位。</p></li></ul><p>在其他 Unix 系统上（如 FreeBSD 上），以下属性可能可用（但仅当 root 使用它们时才被填充）：</p><ul><li><p><code>st_gen</code></p><p>文件生成号。</p></li><li><p><code>st_birthtime</code></p><p>文件创建时间。</p></li></ul><p>在 Solaris 及其衍生版本上，以下属性可能也可用：</p><ul><li><p><code>st_fstype</code></p><p>文件所在文件系统的类型的唯一标识，为字符串。</p></li></ul><p>在 Mac OS 系统上，以下属性可能也可用：</p><ul><li><p><code>st_rsize</code></p><p>文件的实际大小。</p></li><li><p><code>st_creator</code></p><p>文件的创建者。</p></li><li><p><code>st_type</code></p><p>文件类型。</p></li></ul><p>在 Windows 系统上，以下属性也可用：</p><ul><li><p><code>st_file_attributes</code></p><p>Windows 文件属性：<code>dwFileAttributes</code>，由 <code>GetFileInformationByHandle()</code> 返回的 <code>BY_HANDLE_FILE_INFORMATION</code> 结构体的成员之一。请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中的 <code>FILE_ATTRIBUTE_*</code> 常量。</p></li><li><p><code>st_reparse_tag</code></p><p>当 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_file_attributes" target="_blank" rel="noopener"><code>st_file_attributes</code></a> 存在 <code>FILE_ATTRIBUTE_REPARSE_POINT</code> 集合时，本字段包含重解析点类型标记。请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中的 <code>IO_REPARSE_TAG_*</code> 常量。</p></li></ul><p>标准模块 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 中定义了函数和常量，这些函数和常量可用于从 <code>stat</code> 结构体中提取信息。（在 Windows 上，某些项填充的是虚值。）</p><p>为了向后兼容，一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 实例还可以作为至少包含 10 个整数的元组访问，以提供 <code>stat</code> 结构中最重要（和可移植）的成员，整数顺序为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mode" target="_blank" rel="noopener"><code>st_mode</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ino" target="_blank" rel="noopener"><code>st_ino</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_dev" target="_blank" rel="noopener"><code>st_dev</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_nlink" target="_blank" rel="noopener"><code>st_nlink</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_uid" target="_blank" rel="noopener"><code>st_uid</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_gid" target="_blank" rel="noopener"><code>st_gid</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_size" target="_blank" rel="noopener"><code>st_size</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime" target="_blank" rel="noopener"><code>st_atime</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime" target="_blank" rel="noopener"><code>st_mtime</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime" target="_blank" rel="noopener"><code>st_ctime</code></a>。某些实现可能在末尾还有更多项。为了与旧版 Python 兼容，以元组形式访问 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 始终返回整数。</p><p><em>3.3 新版功能:</em> 添加了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime_ns" target="_blank" rel="noopener"><code>st_atime_ns</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime_ns" target="_blank" rel="noopener"><code>st_mtime_ns</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime_ns" target="_blank" rel="noopener"><code>st_ctime_ns</code></a> 成员。</p><p><em>3.5 新版功能:</em> 在 Windows 上添加了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_file_attributes" target="_blank" rel="noopener"><code>st_file_attributes</code></a> 成员。</p><p><em>在 3.5 版更改:</em> 在 Windows 上，如果可用，会返回文件索引作为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ino" target="_blank" rel="noopener"><code>st_ino</code></a> 的值。</p><p><em>3.7 新版功能:</em> 在 Solaris 及其衍生版本上添加了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_fstype" target="_blank" rel="noopener"><code>st_fstype</code></a> 成员。</p><p><em>3.8 新版功能:</em> 在 Windows 上添加了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_reparse_tag" target="_blank" rel="noopener"><code>st_reparse_tag</code></a> 成员。</p><p><em>在 3.8 版更改:</em> 在 Windows 上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mode" target="_blank" rel="noopener"><code>st_mode</code></a> 成员现在可以根据需要将特殊文件标识为 <code>S_IFCHR</code>、<code>S_IFIFO</code> 或 <code>S_IFBLK</code>。</p><ul><li><p><code>os.statvfs</code>(<em>path</em>)</p><p>在所给的路径上执行 <code>statvfs()</code> 系统调用。返回值是一个对象，其属性描述了所给路径上的文件系统，并且与 <code>statvfs</code> 结构体的成员相对应，即：<code>f_bsize</code>, <code>f_frsize</code>, <code>f_blocks</code>, <code>f_bfree</code>, <code>f_bavail</code>, <code>f_files</code>, <code>f_ffree</code>, <code>f_favail</code>, <code>f_flag</code>, <code>f_namemax</code>, <code>f_fsid</code>。</p><p>为 <code>f_flag</code> 属性位定义了两个模块级常量：如果存在 <code>ST_RDONLY</code> 位，则文件系统以只读挂载；如果存在 <code>ST_NOSUID</code> 位，则文件系统禁用或不支持 setuid/setgid 位。</p><p>为基于 GNU/glibc 的系统还定义了额外的模块级常量。它们是 <code>ST_NODEV</code> （禁止访问设备专用文件），<code>ST_NOEXEC</code> （禁止执行程序），<code>ST_SYNCHRONOUS</code> （写入后立即同步），<code>ST_MANDLOCK</code> （允许文件系统上的强制锁定），<code>ST_WRITE</code> （写入文件/目录/符号链接），<code>ST_APPEND</code> （仅追加文件），<code>ST_IMMUTABLE</code> （不可变文件），<code>ST_NOATIME</code> （不更新访问时间），<code>ST_NODIRATIME</code> （不更新目录访问时间），<code>ST_RELATIME</code> （相对于 mtime/ctime 更新访问时间）。</p><p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p><p><em>在 3.2 版更改:</em> 添加了 <code>ST_RDONLY</code> 和 <code>ST_NOSUID</code> 常量。</p><p><em>3.3 新版功能:</em> 新增支持将 <em>path</em> 参数指定为打开的文件描述符。</p><p><em>在 3.4 版更改:</em> 添加了 <code>ST_NODEV</code>、<code>ST_NOEXEC</code>、<code>ST_SYNCHRONOUS</code>、<code>ST_MANDLOCK</code>、<code>ST_WRITE</code>、<code>ST_APPEND</code>、<code>ST_IMMUTABLE</code>、<code>ST_NOATIME</code>、<code>ST_NODIRATIME</code> 和 <code>ST_RELATIME</code> 常量。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>3.7 新版功能:</em> 添加了 <code>f_fsid</code>。</p></li></ul><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.supports_dir_fd</span><br></pre></td></tr></table></figure><p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 对象，指示 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中的哪些函数接受一个打开的文件描述符作为 <em>dir_fd</em> 参数。不同平台提供的功能不同，且 Python 用于实现 <em>dir_fd</em> 参数的底层函数并非在 Python 支持的所有平台上都可用。考虑到一致性，支持 <em>dir_fd</em> 的函数始终允许指定描述符，但如果在底层不支持时调用了该函数，则会抛出异常。（在所有平台上始终支持将 <em>dir_fd</em> 指定为 <code>None</code>。）</p><p>要检查某个函数是否接受打开的文件描述符作为 <em>dir_fd</em> 参数，请在 <code>supports_dir_fd</code> 前使用 <code>in</code> 运算符。例如，如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 在当前平台上接受打开的文件描述符作为 <em>dir_fd</em> 参数，则此表达式的计算结果为 <code>True</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.stat <span class="keyword">in</span> os.supports_dir_fd</span><br></pre></td></tr></table></figure><p>目前 <em>dir_fd</em> 参数仅在 Unix 平台上有效，在 Windows 上均无效。</p><p><em>3.3 新版功能.</em></p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.supports_effective_ids</span><br></pre></td></tr></table></figure><p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 对象，指示 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>os.access()</code></a> 是否允许在当前平台上将其 <em>effective_ids</em> 参数指定为 <code>True</code>。（所有平台都支持将 <em>effective_ids</em> 指定为 <code>False</code>。）如果当前平台支持，则集合将包含 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>os.access()</code></a>，否则集合为空。</p><p>如果当前平台上的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>os.access()</code></a> 支持 <code>effective_ids=True</code>，则此表达式的计算结果为 <code>True</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.access <span class="keyword">in</span> os.supports_effective_ids</span><br></pre></td></tr></table></figure><p>目前仅 Unix 平台支持 <em>effective_ids</em>，Windows 不支持。</p><p><em>3.3 新版功能.</em></p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.supports_fd</span><br></pre></td></tr></table></figure><p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 对象，指示在当前平台上 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中的哪些函数接受一个打开的文件描述符作为 <em>path</em> 参数。不同平台提供的功能不同，且 Python 所使用到的底层函数（用于实现接受描述符作为 <em>path</em>）并非在 Python 支持的所有平台上都可用。</p><p>要判断某个函数是否接受打开的文件描述符作为 <em>path</em> 参数，请在 <code>supports_fd</code> 前使用 <code>in</code> 运算符。例如，如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chdir" target="_blank" rel="noopener"><code>os.chdir()</code></a> 在当前平台上接受打开的文件描述符作为 <em>path</em> 参数，则此表达式的计算结果为 <code>True</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.chdir <span class="keyword">in</span> os.supports_fd</span><br></pre></td></tr></table></figure><p><em>3.3 新版功能.</em></p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.supports_follow_symlinks</span><br></pre></td></tr></table></figure><p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 对象，指示在当前平台上 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中的哪些函数的 <em>follow_symlinks</em> 参数可指定为 <code>False</code>。不同平台提供的功能不同，且 Python 用于实现 <em>follow_symlinks</em> 的底层函数并非在 Python 支持的所有平台上都可用。考虑到一致性，支持 <em>follow_symlinks</em> 的函数始终允许将其指定为 <code>False</code>，但如果在底层不支持时调用了该函数，则会抛出异常。（在所有平台上始终支持将 <em>follow_symlinks</em> 指定为 <code>True</code>。）</p><p>要检查某个函数的 <em>follow_symlinks</em> 参数是否可以指定为 <code>False</code>，请在 <code>supports_follow_symlinks</code> 前使用 <code>in</code> 运算符。例如，如果在当前平台上调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 时可以指定 <code>follow_symlinks=False</code>，则此表达式的计算结果为 <code>True</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.stat <span class="keyword">in</span> os.supports_follow_symlinks</span><br></pre></td></tr></table></figure><p><em>3.3 新版功能.</em></p></li><li><p><code>os.symlink</code>(<em>src</em>, <em>dst</em>, <em>target_is_directory=False</em>, <em>**, </em>dir_fd=None*)</p><p>创建一个指向 <em>src</em> 的符号链接，名为 <em>dst</em>。</p><p>在 Windows 上，符号链接可以表示文件或目录两种类型，并且不会动态改变类型。如果目标存在，则新建链接的类型将与目标一致。否则，如果 <em>target_is_directory</em> 为 <code>True</code>，则符号链接将创建为目录链接，为 <code>False</code> （默认）将创建为文件链接。在非 Windows 平台上，<em>target_is_directory</em> 被忽略。</p><p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a></p><blockquote><p>在 Windows 10 或更高版本上，如果启用了开发人员模式，非特权帐户可以创建符号链接。如果开发人员模式不可用/未启用，则需要 <em>SeCreateSymbolicLinkPrivilege</em> 权限，或者该进程必须以管理员身份运行。</p><p>当本函数由非特权账户调用时，抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p></blockquote><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.symlink</code>，附带参数 <code>src</code>、<code>dst</code>、<code>dir_fd</code>。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p><p><em>在 3.2 版更改:</em> 添加对 Windows 6.0 (Vista) 符号链接的支持。</p><p><em>3.3 新版功能:</em> 添加了 <em>dir_fd</em> 参数，现在在非 Windows 平台上允许 <em>target_is_directory</em> 参数。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p><p><em>在 3.8 版更改:</em> 针对启用了开发人员模式的 Windows，添加了非特权账户创建符号链接的支持。</p></li><li><p><code>os.sync</code>()</p><p>强制将所有内容写入磁盘。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.truncate</code>(<em>path</em>, <em>length</em>)</p><p>截断 <em>path</em> 对应的文件，以使其最大为 <em>length</em> 字节。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.truncate</code>，附带参数 <code>path</code>, <code>length</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>3.3 新版功能.**在 3.5 版更改:</em> 添加了 Windows 支持<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.unlink</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</p><p>移除（删除）文件 <em>path</em>。该函数在语义上与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.remove" target="_blank" rel="noopener"><code>remove()</code></a> 相同，<code>unlink</code> 是其传统的 Unix 名称。请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.remove" target="_blank" rel="noopener"><code>remove()</code></a> 的文档以获取更多信息。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.remove</code>，附带参数 <code>path</code>、<code>dir_fd</code>。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.utime</code>(<em>path</em>, <em>times=None</em>, <em>**, [</em>ns<em>, ]</em>dir_fd=None<em>, </em>follow_symlinks=True*)</p><p>设置文件 <em>path</em> 的访问时间和修改时间。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.utime" target="_blank" rel="noopener"><code>utime()</code></a> 有 <em>times</em> 和 <em>ns</em> 两个可选参数，它们指定了设置给 <em>path</em> 的时间，用法如下：  </p><ul><li>如果指定 <em>ns</em>，它必须是一个 <code>(atime_ns, mtime_ns)</code> 形式的二元组，其中每个成员都是一个表示纳秒的整数。</li><li>如果 <em>times</em> 不为 <code>None</code>，则它必须是 <code>(atime, mtime)</code> 形式的二元组，其中每个成员都是一个表示秒的 int 或 float。</li><li>如果 <em>times</em> 为 <code>None</code> 且未指定 <em>ns</em>，则相当于指定 <code>ns=(atime_ns, mtime_ns)</code>，其中两个时间均为当前时间。</li></ul><p>同时为 <em>times</em> 和 <em>ns</em> 指定元组会出错。</p><p>注意，根据操作系统记录访问时间和修改时间的分辨率，后续的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 调用可能不会返回此处设置的确切时间。请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a>。保留精确时间的最佳方法是使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 结果对象中的 <em>st_atime_ns</em> 和 <em>st_mtime_ns</em> 字段，并将 <em>ns</em> 参数设置为 utime。</p><p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符</a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">指定基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。</p><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.utime</code>，附带参数 <code>path</code>、<code>times</code>、<code>ns</code>、<code>dir_fd</code>。</p><p><em>3.3 新版功能:</em> 新增支持将 <em>path</em> 参数指定为打开的文件描述符，以及支持 <em>dir_fd</em>、<em>follow_symlinks</em> 和 <em>ns</em> 参数。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.walk</code>(<em>top</em>, <em>topdown=True</em>, <em>onerror=None</em>, <em>followlinks=False</em>)</p><p>生成目录树中的文件名，方式是按上-&gt;下或下-&gt;上顺序浏览目录树。对于以 <em>top</em> 为根的目录树中的每个目录（包括 <em>top</em> 本身），它都会生成一个三元组 <code>(dirpath, dirnames, filenames)</code>。</p><p><em>dirpath</em> 是一个字符串，表示目录的路径。<em>dirnames</em> 是一个列表，内含 <em>dirpath</em> 中子目录的名称（不包括 <code>&#39;.&#39;</code> 和 <code>&#39;..&#39;</code> ）。<em>filenames</em> 也是列表，内含 <em>dirpath</em> 中文件（非目录）的名称。注意，列表中的名称不包含路径部分。要获取 <em>dirpath</em> 中文件或目录的完整路径（从 <em>top</em> 起始），请执行 <code>os.path.join(dirpath, name)</code>。</p><p>如果可选参数 <em>topdown</em> 为 <code>True</code> 或未指定，则在所有子目录的三元组之前生成父目录的三元组（目录是自上而下生成的）。如果 <em>topdown</em> 为 <code>False</code>，则在所有子目录的三元组生成之后再生成父目录的三元组（目录是自下而上生成的）。无论 <em>topdown</em> 为何值，在生成目录及其子目录的元组之前，都将检索全部子目录列表。</p><p>当 <em>topdown</em> 为 <code>True</code> 时，调用者可以就地修改 <em>dirnames</em> 列表（也许用到了 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#del" target="_blank" rel="noopener"><code>del</code></a> 或切片），而 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 将仅仅递归到仍保留在 <em>dirnames</em> 中的子目录内。这可用于减少搜索、加入特定的访问顺序，甚至可在继续 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 之前告知 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 由调用者新建或重命名的目录的信息。当 <em>topdown</em> 为 <code>False</code> 时，修改 <em>dirnames</em> 对 walk 的行为没有影响，因为在自下而上模式中，<em>dirnames</em> 中的目录是在 <em>dirpath</em> 本身之前生成的。</p><p>默认将忽略 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 调用中的错误。如果指定了可选参数 <em>onerror</em>，它应该是一个函数。出错时它会被调用，参数是一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 实例。它可以报告错误然后继续遍历，或者抛出异常然后中止遍历。注意，可以从异常对象的 <code>filename</code> 属性中获取出错的文件名。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 默认不会递归进指向目录的符号链接。可以在支持符号链接的系统上将 <em>followlinks</em> 设置为 <code>True</code>，以访问符号链接指向的目录。</p><blockquote><p> 注意，如果链接指向自身的父目录，则将 <em>followlinks</em> 设置为 <code>True</code> 可能导致无限递归。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 不会记录它已经访问过的目录。 </p><p> 如果传入的是相对路径，请不要在恢复 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 之间更改当前工作目录。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 不会更改当前目录，并假定其调用者也不会更改当前目录。 </p></blockquote><p>下面的示例遍历起始目录内所有子目录，打印每个目录内的文件占用的字节数，CVS 子目录不会被遍历:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> join, getsize</span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">'python/Lib/email'</span>):</span><br><span class="line">    print(root, <span class="string">"consumes"</span>, end=<span class="string">" "</span>)</span><br><span class="line">    print(sum(getsize(join(root, name)) <span class="keyword">for</span> name <span class="keyword">in</span> files), end=<span class="string">" "</span>)</span><br><span class="line">    print(<span class="string">"bytes in"</span>, len(files), <span class="string">"non-directory files"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'CVS'</span> <span class="keyword">in</span> dirs:</span><br><span class="line">        dirs.remove(<span class="string">'CVS'</span>)  <span class="comment"># don't visit CVS directories</span></span><br></pre></td></tr></table></figure><p>在下一个示例（<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree" target="_blank" rel="noopener"><code>shutil.rmtree()</code></a> 的简单实现）中，必须使树自下而上遍历，因为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rmdir" target="_blank" rel="noopener"><code>rmdir()</code></a> 只允许在目录为空时删除目录:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Delete everything reachable from the directory named in "top",</span></span><br><span class="line"><span class="comment"># assuming there are no symbolic links.</span></span><br><span class="line"><span class="comment"># CAUTION:  This is dangerous!  For example, if top == '/', it</span></span><br><span class="line"><span class="comment"># could delete all your disk files.</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(top, topdown=<span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">        os.remove(os.path.join(root, name))</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> dirs:</span><br><span class="line">        os.rmdir(os.path.join(root, name))</span><br></pre></td></tr></table></figure></li></ul><p><em>在 3.5 版更改:</em> 现在，本函数调用的是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>os.scandir()</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>os.listdir()</code></a>，从而减少了调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 的次数而变得更快。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><ul><li><p><code>os.fwalk</code>(<em>top=’.’</em>, <em>topdown=True</em>, <em>onerror=None</em>, <em>**, </em>follow_symlinks=False<em>, </em>dir_fd=None*)</p><p>本方法的行为与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 完全一样，除了它产生的是 4 元组 <code>(dirpath, dirnames, filenames, dirfd)</code>，并且它支持 <code>dir_fd</code>。</p><p><em>dirpath</em>、<em>dirnames</em> 和 <em>filenames</em> 与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 输出的相同，<em>dirfd</em> 是指向目录 <em>dirpath</em> 的文件描述符。</p><p>本函数始终支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。但是请注意，与其他函数不同，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fwalk" target="_blank" rel="noopener"><code>fwalk()</code></a> 的 <em>follow_symlinks</em> 的默认值为 <code>False</code>。</p><blockquote><p> 由于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fwalk" target="_blank" rel="noopener"><code>fwalk()</code></a> 会生成文件描述符，而它们仅在下一个迭代步骤前有效，因此如果要将描述符保留更久，则应复制它们（比如使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.dup" target="_blank" rel="noopener"><code>dup()</code></a>）。 </p></blockquote><p>下面的示例遍历起始目录内所有子目录，打印每个目录内的文件占用的字节数，CVS 子目录不会被遍历:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> root, dirs, files, rootfd <span class="keyword">in</span> os.fwalk(<span class="string">'python/Lib/email'</span>):</span><br><span class="line">    print(root, <span class="string">"consumes"</span>, end=<span class="string">""</span>)</span><br><span class="line">    print(sum([os.stat(name, dir_fd=rootfd).st_size <span class="keyword">for</span> name <span class="keyword">in</span> files]),</span><br><span class="line">          end=<span class="string">""</span>)</span><br><span class="line">    print(<span class="string">"bytes in"</span>, len(files), <span class="string">"non-directory files"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'CVS'</span> <span class="keyword">in</span> dirs:</span><br><span class="line">        dirs.remove(<span class="string">'CVS'</span>)  <span class="comment"># don't visit CVS directories</span></span><br></pre></td></tr></table></figure></li></ul><p>在下一个示例中，必须使树自下而上遍历，因为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rmdir" target="_blank" rel="noopener"><code>rmdir()</code></a> 只允许在目录为空时删除目录:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Delete everything reachable from the directory named in "top",</span></span><br><span class="line"><span class="comment"># assuming there are no symbolic links.</span></span><br><span class="line"><span class="comment"># CAUTION:  This is dangerous!  For example, if top == '/', it</span></span><br><span class="line"><span class="comment"># could delete all your disk files.</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> root, dirs, files, rootfd <span class="keyword">in</span> os.fwalk(top, topdown=<span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">        os.unlink(name, dir_fd=rootfd)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> dirs:</span><br><span class="line">        os.rmdir(name, dir_fd=rootfd)</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p><p>3<em>.3 新版功能.</em></p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>在 3.7 版更改:</em> 添加了对 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型路径的支持。</p><ul><li><p><code>os.memfd_create</code>(<em>name</em>[, <em>flags=os.MFD_CLOEXEC</em>])</p><p>创建一个匿名文件，返回指向该文件的文件描述符。<em>flags</em> 必须是系统上可用的 <code>os.MFD_*</code> 常量之一（或将它们按位“或”组合起来）。新文件描述符默认是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承的</a>。</p><p><em>name</em> 提供的名称会被用作文件名，并且 <code>/proc/self/fd/</code> 目录中相应符号链接的目标将显示为该名称。显示的名称始终以 <code>memfd:</code> 为前缀，并且仅用于调试目的。名称不会影响文件描述符的行为，因此多个文件可以有相同的名称，不会有副作用。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 3.17 或更高版本，且装有 glibc 2.27 或更高版本。</p><p><em>3.8 新版功能.</em> </p></li><li><p><code>os.MFD_CLOEXEC</code></p></li><li><p><code>os.MFD_ALLOW_SEALING</code></p></li><li><p><code>os.MFD_HUGETLB</code></p></li><li><p><code>os.MFD_HUGE_SHIFT</code></p></li><li><p><code>os.MFD_HUGE_MASK</code></p></li><li><p><code>os.MFD_HUGE_64KB</code></p></li><li><p><code>os.MFD_HUGE_512KB</code></p></li><li><p><code>os.MFD_HUGE_1MB</code></p></li><li><p><code>os.MFD_HUGE_2MB</code></p></li><li><p><code>os.MFD_HUGE_8MB</code></p></li><li><p><code>os.MFD_HUGE_16MB</code></p></li><li><p><code>os.MFD_HUGE_32MB</code></p></li><li><p><code>os.MFD_HUGE_256MB</code></p></li><li><p><code>os.MFD_HUGE_512MB</code></p></li><li><p><code>os.MFD_HUGE_1GB</code></p></li><li><p><code>os.MFD_HUGE_2GB</code></p></li><li><p><code>os.MFD_HUGE_16GB</code></p><p>以上标志位可以传递给 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.memfd_create" target="_blank" rel="noopener"><code>memfd_create()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 3.17 或更高版本，且装有 glibc 2.27 或更高版本。<code>MFD_HUGE*</code> 标志仅在 Linux 4.14 及以上可用。</p><p><em>3.8 新版功能.</em></p></li></ul><h3 id="Linux-扩展属性"><a href="#Linux-扩展属性" class="headerlink" title="Linux 扩展属性"></a>Linux 扩展属性</h3><p><em>3.3 新版功能.</em></p><p>这些函数仅在 Linux 上可用。</p><ul><li><p><code>os.getxattr</code>(<em>path</em>, <em>attribute</em>, <em>**, </em>follow_symlinks=True*)</p><p>返回 <em>path</em> 的扩展文件系统属性 <em>attribute</em> 的值。<em>attribute</em> 可以是 bytes 或 str （直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入）。如果是 str，则使用文件系统编码来编码字符串。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.getxattr</code>，附带参数 <code>path</code>、<code>attribute</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>path</em> 和 <em>attribute</em>。</p></li><li><p><code>os.listxattr</code>(<em>path=None</em>, <em>**, </em>follow_symlinks=True*)</p><p>返回一个列表，包含 <em>path</em> 的所有扩展文件系统属性。列表中的属性都表示为字符串，它们是根据文件系统编码解码出来的。如果 <em>path</em> 为 <code>None</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listxattr" target="_blank" rel="noopener"><code>listxattr()</code></a> 将检查当前目录。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.listxattr</code>，附带参数 <code>path</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.removexattr</code>(<em>path</em>, <em>attribute</em>, <em>**, </em>follow_symlinks=True*)</p><p>从 <em>path</em> 中删除扩展文件系统属性 <em>attribute</em>。<em>attribute</em> 应该是 bytes 或 str （直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入）。如果是 str，则使用文件系统编码来编码字符串。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.removexattr</code>，附带参数 <code>path</code>、<code>attribute</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>path</em> 和 <em>attribute</em>。</p></li><li><p><code>os.setxattr</code>(<em>path</em>, <em>attribute</em>, <em>value</em>, <em>flags=0</em>, <em>**, </em>follow_symlinks=True*)</p><p>将 <em>path</em> 的扩展文件系统属性 <em>attribute</em> 设置为 <em>value</em>。<em>attribute</em> 必须是没有空字符的 bytes 或 str （直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入）。如果是 str，则应使用文件系统编码进行编码。<em>flags</em> 可以是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.XATTR_REPLACE" target="_blank" rel="noopener"><code>XATTR_REPLACE</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.XATTR_CREATE" target="_blank" rel="noopener"><code>XATTR_CREATE</code></a>。如果指定 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.XATTR_REPLACE" target="_blank" rel="noopener"><code>XATTR_REPLACE</code></a> 而该属性不存在，则抛出 <code>EEXISTS</code> 异常。如果指定 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.XATTR_CREATE" target="_blank" rel="noopener"><code>XATTR_CREATE</code></a> 而该属性已经存在，则不会创建该属性，抛出 <code>ENODATA</code> 异常。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。</p><blockquote><p> Linux kernel 2.6.39 以下版本的一个 bug 导致在某些文件系统上，flags 参数会被忽略。 </p></blockquote><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.setxattr</code>，附带参数 <code>path</code>、<code>attribute</code>、<code>value</code>、<code>flags</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>path</em> 和 <em>attribute</em>。</p></li><li><p><code>os.XATTR_SIZE_MAX</code></p><p>一条扩展属性的值的最大大小。在当前的 Linux 上是 64 KiB。</p></li><li><p><code>os.XATTR_CREATE</code></p><p>这是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.setxattr" target="_blank" rel="noopener"><code>setxattr()</code></a> 的 flags 参数的可取值，它表示该操作必须创建一个属性。</p></li><li><p><code>os.XATTR_REPLACE</code></p><p>这是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.setxattr" target="_blank" rel="noopener"><code>setxattr()</code></a> 的 flags 参数的可取值，它表示该操作必须替换现有属性。</p></li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>下列函数可用于创建和管理进程。</p><p>所有 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*</code></a> 函数都接受一个参数列表，用来给新程序加载到它的进程中。在所有情况下，传递给新程序的第一个参数是程序本身的名称，而不是用户在命令行上输入的参数。对于 C 程序员来说，这就是传递给 <code>main()</code> 函数的 <code>argv[0]</code>。例如，<code>os.execv(&#39;/bin/echo&#39;, [&#39;foo&#39;, &#39;bar&#39;])</code> 只会在标准输出上打印 <code>bar</code>，而 <code>foo</code> 会被忽略。</p><ul><li><p><code>os.abort</code>()</p><p>发送 <code>SIGABRT</code> 信号到当前进程。在 Unix 上，默认行为是生成一个核心转储。在 Windows 上，该进程立即返回退出代码 <code>3</code>。请注意，使用 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.signal" target="_blank" rel="noopener"><code>signal.signal()</code></a> 可以为 <code>SIGABRT</code> 注册 Python 信号处理程序，而调用本函数将不会调用按前述方法注册的程序。</p></li><li><p><code>os.add_dll_directory</code>(<em>path</em>)</p><p>将路径添加到 DLL 搜索路径。当需要解析扩展模块的依赖时（扩展模块本身通过 sys.path 解析），会使用该搜索路径，<a href="https://docs.python.org/zh-cn/3.8/library/ctypes.html#module-ctypes" target="_blank" rel="noopener"><code>ctypes</code></a> 也会使用该搜索路径。要移除目录，可以在返回的对象上调用 <strong>close()</strong>，也可以在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句内使用本方法。参阅 <a href="https://msdn.microsoft.com/44228cf2-6306-466c-8f16-f513cd3ba8b5" target="_blank" rel="noopener">Microsoft 文档</a> 获取如何加载 DLL 的信息。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.add_dll_directory</code>，附带参数 <code>path</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。<em>3.8 新版功能:</em> 早期版本的 CPython 解析 DLL 时用的是当前进程的默认行为。这会导致不一致，比如不是每次都会去搜索 <code>PATH</code> 和当前工作目录，且系统函数（如 <code>AddDllDirectory</code> ）失效。在 3.8 中，DLL 的两种主要加载方式现在可以显式覆盖进程的行为，以确保一致性。请参阅 <a href="https://docs.python.org/zh-cn/3.8/whatsnew/3.8.html#bpo-36085-whatsnew" target="_blank" rel="noopener">移植说明</a> 了解如何更新你的库。</p></li><li><p><code>os.execl</code>(<em>path</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>)</p></li><li><p><code>os.execle</code>(<em>path</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>, <em>env</em>)</p></li><li><p><code>os.execlp</code>(<em>file</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>)</p></li><li><p><code>os.execlpe</code>(<em>file</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>, <em>env</em>)</p></li><li><p><code>os.execv</code>(<em>path</em>, <em>args</em>)</p></li><li><p><code>os.execve</code>(<em>path</em>, <em>args</em>, <em>env</em>)</p></li><li><p><code>os.execvp</code>(<em>file</em>, <em>args</em>)</p></li><li><p><code>os.execvpe</code>(<em>file</em>, <em>args</em>, <em>env</em>)</p><p>这些函数都将执行一个新程序，以替换当前进程。它们没有返回值。在 Unix 上，新程序会加载到当前进程中，且进程号与调用者相同。过程中的错误会被报告为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p><p>当前进程会被立即替换。打开的文件对象和描述符都不会刷新，因此如果这些文件上可能缓冲了数据，则应在调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*</code></a> 函数之前使用 <code>sys.stdout.flush()</code> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsync" target="_blank" rel="noopener"><code>os.fsync()</code></a> 刷新它们。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*</code></a> 函数的 “l” 和 “v” 变体不同在于命令行参数的传递方式。如果在编码时固定了参数数量，则 “l” 变体可能是最方便的，各参数作为 <code>execl*()</code> 函数的附加参数传入即可。当参数数量可变时，”v” 变体更方便，参数以列表或元组的形式作为 <em>args</em> 参数传递。在这两种情况下，子进程的第一个参数都应该是即将运行的命令名称，但这不是强制性的。</p><p>结尾包含 “p” 的变体（<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execlp" target="_blank" rel="noopener"><code>execlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execlpe" target="_blank" rel="noopener"><code>execlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execvp" target="_blank" rel="noopener"><code>execvp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execvpe" target="_blank" rel="noopener"><code>execvpe()</code></a> ）将使用 <code>PATH</code> 环境变量来查找程序 <em>file</em>。当环境被替换时（使用下一段讨论的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*e</code></a> 变体之一），<code>PATH</code> 变量将来自于新环境。其他变体 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>execl()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execle" target="_blank" rel="noopener"><code>execle()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execv" target="_blank" rel="noopener"><code>execv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 不使用 <code>PATH</code> 变量来查找程序，因此 <em>path</em> 必须包含正确的绝对或相对路径。</p><p>对于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execle" target="_blank" rel="noopener"><code>execle()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execlpe" target="_blank" rel="noopener"><code>execlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execvpe" target="_blank" rel="noopener"><code>execvpe()</code></a> （都以 “e” 结尾），<em>env</em> 参数是一个映射，用于定义新进程的环境变量（代替当前进程的环境变量）。而函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>execl()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execlp" target="_blank" rel="noopener"><code>execlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execv" target="_blank" rel="noopener"><code>execv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execvp" target="_blank" rel="noopener"><code>execvp()</code></a> 会将当前进程的环境变量过继给新进程。</p><p>某些平台上的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 可以将 <em>path</em> 指定为打开的文件描述符。当前平台可能不支持此功能，可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_fd" target="_blank" rel="noopener"><code>os.supports_fd</code></a> 检查它是否支持。如果不可用，则使用它会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.exec</code>，附带参数 <code>path</code>、<code>args</code>、<code>env</code>。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p><p><em>3.3 新版功能:</em> 新增支持将 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 的 <em>path</em> 参数指定为打开的文件描述符。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os._exit</code>(<em>n</em>)</p><p>以状态码 <em>n</em> 退出进程，不会调用清理处理程序，不会刷新 stdio，等等。</p><blockquote><p> 退出的标准方法是使用 <code>sys.exit(n)</code>。而 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os._exit" target="_blank" rel="noopener"><code>_exit()</code></a> 通常只应在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>fork()</code></a> 出的子进程中使用。 </p></blockquote><p> 以下是已定义的退出代码，可以用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os._exit" target="_blank" rel="noopener"><code>_exit()</code></a>，尽管它们不是必需的。这些退出代码通常用于 Python 编写的系统程序，例如邮件服务器的外部命令传递程序。 </p><blockquote><p> 其中部分退出代码在部分 Unix 平台上可能不可用，因为平台间存在差异。如果底层平台定义了这些常量，那上层也会定义。 </p></blockquote></li><li><p><code>os.EX_OK</code></p><p>退出代码，表示未发生任何错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_USAGE</code></p><p>退出代码，表示命令使用不正确，如给出的参数数量有误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_DATAERR</code></p><p>退出代码，表示输入数据不正确。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_NOINPUT</code></p><p>退出代码，表示某个输入文件不存在或不可读。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_NOUSER</code></p><p>退出代码，表示指定的用户不存在。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_NOHOST</code></p><p>退出代码，表示指定的主机不存在。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_UNAVAILABLE</code></p><p>退出代码，表示所需的服务不可用。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_SOFTWARE</code></p><p>退出代码，表示检测到内部软件错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_OSERR</code></p><p>退出代码，表示检测到操作系统错误，例如无法 fork 或创建管道。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_OSFILE</code></p><p>退出代码，表示某些系统文件不存在、无法打开或发生其他错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_CANTCREAT</code></p><p>退出代码，表示无法创建用户指定的输出文件。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_IOERR</code></p><p>退出代码，表示对某些文件进行读写时发生错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_TEMPFAIL</code></p><p>退出代码，表示发生了暂时性故障。它可能并非意味着真正的错误，例如在可重试的情况下无法建立网络连接。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_PROTOCOL</code></p><p>退出代码，表示协议交换是非法的、无效的或无法解读的。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_NOPERM</code></p><p>退出代码，表示没有足够的权限执行该操作（但不适用于文件系统问题）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_CONFIG</code></p><p>退出代码，表示发生某种配置错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_NOTFOUND</code></p><p>退出代码，表示的内容类似于“找不到条目”。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.fork</code>()</p><p>Fork 出一个子进程。在子进程中返回 <code>0</code>，在父进程中返回子进程的进程号。如果发生错误，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。注意，当从线程中使用 <code>fork()</code> 时，某些平台（包括 FreeBSD &lt;= 6.3 和 Cygwin）存在已知问题。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.fork</code>，没有附带参数。<em>在 3.8 版更改:</em> 不再支持在子解释器中调用 <code>fork()</code> （将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常）</p><p> 有关 SSL 模块与 fork() 结合的应用，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/ssl.html#module-ssl" target="_blank" rel="noopener"><code>ssl</code></a>。 </p><p> <a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix </p></li><li><p><code>os.forkpty</code>()</p><p>Fork 出一个子进程，使用新的伪终端作为子进程的控制终端。返回一对 <code>(pid, fd)</code>，其中 <em>pid</em> 在子进程中为 <code>0</code>，这是父进程中新子进程的进程号，而 <em>fd</em> 是伪终端主设备的文件描述符。对于更便于移植的方法，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/pty.html#module-pty" target="_blank" rel="noopener"><code>pty</code></a> 模块。如果发生错误，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.forkpty</code>，没有附带参数。<em>在 3.8 版更改:</em> 不再支持在子解释器中调用 <code>forkpty()</code> （将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 某些 Unix。</p></li><li><p><code>os.kill</code>(<em>pid</em>, <em>sig</em>)</p><p>将信号 <em>sig</em> 发送至进程 <em>pid</em>。特定平台上可用的信号常量定义在 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#module-signal" target="_blank" rel="noopener"><code>signal</code></a> 模块中。Windows： <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.CTRL_C_EVENT" target="_blank" rel="noopener"><code>signal.CTRL_C_EVENT</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.CTRL_BREAK_EVENT" target="_blank" rel="noopener"><code>signal.CTRL_BREAK_EVENT</code></a> 信号是特殊信号，只能发送给共享同一个控制台窗口的控制台进程，如某些子进程。<em>sig</em> 取任何其他值将导致该进程被 TerminateProcess API 无条件终止，且退出代码为 <em>sig</em>。Windows 版本的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.kill" target="_blank" rel="noopener"><code>kill()</code></a> 还需要传入待结束进程的句柄。另请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.pthread_kill" target="_blank" rel="noopener"><code>signal.pthread_kill()</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.kill</code>，附带参数 <code>pid</code>、<code>sig</code>。<em>3.2 新版功能:</em> Windows 支持。</p></li><li><p><code>os.killpg</code>(<em>pgid</em>, <em>sig</em>)</p><p>将信号 <em>sig</em> 发送给进程组 <em>pgid</em>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.killpg</code>，附带参数 <code>pgid</code>、<code>sig</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.nice</code>(<em>increment</em>)</p><p>将进程的优先级（nice 值）增加 <em>increment</em>，返回新的 nice 值。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.plock</code>(<em>op</em>)</p><p>将程序段锁定到内存中。<em>op</em> 的值（定义在  中）决定了哪些段被锁定。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.popen</code>(<em>cmd</em>, <em>mode=’r’</em>, <em>buffering=-1</em>)</p><p>打开一个管道，它通往 / 接受自命令 <em>cmd</em>。返回值是连接到管道的文件对象，根据 <em>mode</em> 是 <code>&#39;r&#39;</code> （默认）还是 <code>&#39;w&#39;</code> 决定该对象可以读取还是写入。<em>buffering</em> 参数与内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 相应的参数含义相同。返回的文件对象只能读写文本字符串，不能是字节类型。</p><p>如果子进程成功退出，则 <code>close</code> 方法返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。如果发生错误，则返回子进程的返回码。在 POSIX 系统上，如果返回码为正，则它就是进程返回值左移一个字节后的值。如果返回码为负，则进程是被信号终止的，返回码取反后就是该信号。（例如，如果子进程被终止，则返回值可能是 <code>- signal.SIGKILL</code>。）在 Windows 系统上，返回值包含子进程的返回码（有符号整数）。</p><p>本方法是使用 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#subprocess.Popen" target="_blank" rel="noopener"><code>subprocess.Popen</code></a> 实现的，如需更强大的方法来管理和沟通子进程，请参阅该类的文档。</p></li><li><p><code>os.posix_spawn</code>(<em>path</em>, <em>argv</em>, <em>env</em>, <em>**, </em>file_actions=None<em>, </em>setpgroup=None<em>, </em>resetids=False<em>, </em>setsid=False<em>, </em>setsigmask=()<em>, </em>setsigdef=()<em>, </em>scheduler=None*)</p><p>包装 <code>posix_spawn()</code> C 库 API，使其可以从 Python 调用。</p><p>大多数用户应使用 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#subprocess.run" target="_blank" rel="noopener"><code>subprocess.run()</code></a> 代替 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_spawn" target="_blank" rel="noopener"><code>posix_spawn()</code></a>。</p><p>仅位置参数 (Positional-only arguments) <em>path</em>、<em>args</em> 和 <em>env</em> 与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 中的类似。</p><p><em>path</em> 参数是可执行文件的路径，<em>path</em> 中应该包含目录。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_spawnp" target="_blank" rel="noopener"><code>posix_spawnp()</code></a> 可直接传入可执行文件名称，不带有目录。</p><p><em>file_actions</em> 参数可以是由元组组成的序列，序列描述了对子进程中指定文件描述符采取的操作，这些操作会在 C 库实现的 <code>fork()</code> 和 <code>exec()</code> 步骤间完成。每个元组的第一个元素必须是下面列出的三个类型指示符之一，用于描述元组剩余的元素：</p><ul><li><p><code>os.POSIX_SPAWN_OPEN</code></p><p>(<code>os.POSIX_SPAWN_OPEN</code>, <em>fd</em>, <em>path</em>, <em>flags</em>, <em>mode</em>)执行 <code>os.dup2(os.open(path, flags, mode), fd)</code>。</p></li><li><p><code>os.POSIX_SPAWN_CLOSE</code></p><p>(<code>os.POSIX_SPAWN_CLOSE</code>, <em>fd</em>)执行 <code>os.close(fd)</code>。</p></li><li><p><code>os.POSIX_SPAWN_DUP2</code></p><p>(<code>os.POSIX_SPAWN_DUP2</code>, <em>fd</em>, <em>new_fd</em>)执行 <code>os.dup2(fd, new_fd)</code>。</p></li></ul><p>这些元组对应于 C 库 <code>posix_spawn_file_actions_addopen()</code>， <code>posix_spawn_file_actions_addclose()</code> 和 <code>posix_spawn_file_actions_adddup2()</code> API 调用，它们为调用 <code>posix_spawn()</code> 自身做准备。</p><p><em>setpgroup</em> 参数将子进程的进程组设置为指定值。如果指定值为 0，则子进程的进程组 ID 将与其进程 ID 相同。如果未设置 <em>setpgroup</em> 值，则子进程将继承父进程的进程组 ID。本参数对应于 C 库 <code>POSIX_SPAWN_SETPGROUP</code> 标志。</p><p>如果 <em>resetids</em> 参数为 <code>True</code>，则会将子进程的有效用户 ID 和有效组 ID 重置为父进程的实际用户 ID 和实际组 ID。如果该参数为 <code>False</code>，则子进程保留父进程的有效用户 ID 和有效组 ID。无论哪种情况，若在可执行文件上启用了 “设置用户 ID” 和 “设置组 ID” 权限位，它们将覆盖有效用户 ID 和有效组 ID 的设置。本参数对应于 C 库 <code>POSIX_SPAWN_RESETIDS</code> 标志。</p><p>如果 <em>setsid</em> 参数为 <code>True</code>，它将为 posix_spawn 新建一个会话 ID。<em>setsid</em> 需要 <code>POSIX_SPAWN_SETSID</code> 或 <code>POSIX_SPAWN_SETSID_NP</code> 标志，否则会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p><p><em>setsigmask</em> 参数将信号掩码设置为指定的信号集合。如果未使用该参数，则子进程将继承父进程的信号掩码。本参数对应于 C 库 <code>POSIX_SPAWN_SETSIGMASK</code> 标志。</p><p><em>sigdef</em> 参数将集合中所有信号的操作全部重置为默认。本参数对应于 C 库 <code>POSIX_SPAWN_SETSIGDEF</code> 标志。</p><p><em>scheduler</em> 参数必须是一个元组，其中包含调度器策略（可选）以及携带了调度器参数的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_param" target="_blank" rel="noopener"><code>sched_param</code></a> 实例。在调度器策略所在位置为 <code>None</code> 表示未提供该值。本参数是 C 库 <code>POSIX_SPAWN_SETSCHEDPARAM</code> 和 <code>POSIX_SPAWN_SETSCHEDULER</code> 标志的组合。</p><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.posix_spawn</code>，附带参数 <code>path</code>、<code>argv</code>、<code>env</code>。</p><p><em>3.8 新版功能.</em></p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.posix_spawnp</code>(<em>path</em>, <em>argv</em>, <em>env</em>, <em>**, </em>file_actions=None<em>, </em>setpgroup=None<em>, </em>resetids=False<em>, </em>setsid=False<em>, </em>setsigmask=()<em>, </em>setsigdef=()<em>, </em>scheduler=None*)</p><p>包装 <code>posix_spawnp()</code> C 库 API，使其可以从 Python 调用。</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_spawn" target="_blank" rel="noopener"><code>posix_spawn()</code></a> 相似，但是系统会在 <code>PATH</code> 环境变量指定的目录列表中搜索可执行文件 <em>executable</em> （与 <code>execvp(3)</code> 相同）。</p><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.posix_spawn</code>，附带参数 <code>path</code>、<code>argv</code>、<code>env</code>。</p><p><em>3.8 新版功能.</em></p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_spawn" target="_blank" rel="noopener"><code>posix_spawn()</code></a> 文档。</p></li><li><p><code>os.register_at_fork</code>(<em>**, </em>before=None<em>, </em>after_in_parent=None<em>, </em>after_in_child=None*)</p><p>注册可调用对象，在使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>os.fork()</code></a> 或类似的进程克隆 API 派生新的子进程时，这些对象会运行。参数是可选的，且为仅关键字 (Keyword-only) 参数。每个参数指定一个不同的调用点。</p><ul><li><em>before</em> 是一个函数，在 fork 子进程前调用。</li><li><em>after_in_parent</em> 是一个函数，在 fork 子进程后从父进程调用。</li><li><em>after_in_child</em> 是一个函数，从子进程中调用。</li></ul><p>只有希望控制权回到 Python 解释器时，才进行这些调用。典型的 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>子进程</code></a> 启动时不会触发它们，因为子进程不会重新进入解释器。</p><p>在注册的函数中，用于 fork 前运行的函数将按与注册相反的顺序调用。用于 fork 后（从父进程或子进程）运行的函数按注册顺序调用。</p><p>注意，第三方 C 代码的 <code>fork()</code> 调用可能不会调用这些函数，除非它显式调用了 <a href="https://docs.python.org/zh-cn/3.8/c-api/sys.html#c.PyOS_BeforeFork" target="_blank" rel="noopener"><code>PyOS_BeforeFork()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/c-api/sys.html#c.PyOS_AfterFork_Parent" target="_blank" rel="noopener"><code>PyOS_AfterFork_Parent()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/c-api/sys.html#c.PyOS_AfterFork_Child" target="_blank" rel="noopener"><code>PyOS_AfterFork_Child()</code></a>。</p><p>函数注册后无法注销。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p><p><em>3.7 新版功能.</em></p></li><li><p><code>os.spawnl</code>(<em>mode</em>, <em>path</em>, <em>…</em>)</p></li><li><p><code>os.spawnle</code>(<em>mode</em>, <em>path</em>, <em>…</em>, <em>env</em>)</p></li><li><p><code>os.spawnlp</code>(<em>mode</em>, <em>file</em>, <em>…</em>)</p></li><li><p><code>os.spawnlpe</code>(<em>mode</em>, <em>file</em>, <em>…</em>, <em>env</em>)</p></li><li><p><code>os.spawnv</code>(<em>mode</em>, <em>path</em>, <em>args</em>)</p></li><li><p><code>os.spawnve</code>(<em>mode</em>, <em>path</em>, <em>args</em>, <em>env</em>)</p></li><li><p><code>os.spawnvp</code>(<em>mode</em>, <em>file</em>, <em>args</em>)</p></li><li><p><code>os.spawnvpe</code>(<em>mode</em>, <em>file</em>, <em>args</em>, <em>env</em>)<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener">¶</a></p><p>在新进程中执行程序 <em>path</em>。</p><p>（注意，<a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 模块提供了更强大的工具来生成新进程并跟踪执行结果，使用该模块比使用这些函数更好。尤其应当检查 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#subprocess-replacements" target="_blank" rel="noopener">Replacing Older Functions with the subprocess Module</a> 部分。）</p><p><em>mode</em> 为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_NOWAIT" target="_blank" rel="noopener"><code>P_NOWAIT</code></a> 时，本函数返回新进程的进程号。<em>mode</em> 为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_WAIT" target="_blank" rel="noopener"><code>P_WAIT</code></a> 时，如果进程正常退出，返回退出代码，如果被终止，返回 <code>-signal</code>，其中 <em>signal</em> 是终止进程的信号。在 Windows 上，进程号实际上是进程句柄，因此可以与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 函数一起使用。</p><p>注意在 VxWorks 上，新进程被终止时，本函数不会返回 <code>-signal</code>，而是会抛出 OSError 异常。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 函数的 “l” 和 “v” 变体不同在于命令行参数的传递方式。如果在编码时固定了参数数量，则 “l” 变体可能是最方便的，各参数作为 <code>spawnl*()</code> 函数的附加参数传入即可。当参数数量可变时，”v” 变体更方便，参数以列表或元组的形式作为 <em>args</em> 参数传递。在这两种情况下，子进程的第一个参数都必须是即将运行的命令名称。</p><p>结尾包含第二个 “p” 的变体（<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlp" target="_blank" rel="noopener"><code>spawnlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlpe" target="_blank" rel="noopener"><code>spawnlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvp" target="_blank" rel="noopener"><code>spawnvp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener"><code>spawnvpe()</code></a>）将使用 <code>PATH</code> 环境变量来查找程序 <em>file</em>。当环境被替换时（使用下一段讨论的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*e</code></a> 变体之一），<code>PATH</code> 变量将来自于新环境。其他变体 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawnl()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnle" target="_blank" rel="noopener"><code>spawnle()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnv" target="_blank" rel="noopener"><code>spawnv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnve" target="_blank" rel="noopener"><code>spawnve()</code></a> 不使用 <code>PATH</code> 变量来查找程序，因此 <em>path</em> 必须包含正确的绝对或相对路径。</p><p>对于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnle" target="_blank" rel="noopener"><code>spawnle()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlpe" target="_blank" rel="noopener"><code>spawnlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnve" target="_blank" rel="noopener"><code>spawnve()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener"><code>spawnvpe()</code></a> （都以 “e” 结尾），<em>env</em> 参数是一个映射，用于定义新进程的环境变量（代替当前进程的环境变量）。而函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawnl()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlp" target="_blank" rel="noopener"><code>spawnlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnv" target="_blank" rel="noopener"><code>spawnv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvp" target="_blank" rel="noopener"><code>spawnvp()</code></a> 会将当前进程的环境变量过继给新进程。注意，<em>env</em> 字典中的键和值必须是字符串。无效的键或值将导致函数出错，返回值为 <code>127</code>。</p><p>例如，以下对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlp" target="_blank" rel="noopener"><code>spawnlp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener"><code>spawnvpe()</code></a> 的调用是等效的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">  os.spawnlp(os.P_WAIT, <span class="string">'cp'</span>, <span class="string">'cp'</span>, <span class="string">'index.html'</span>, <span class="string">'/dev/null'</span>)</span><br><span class="line"></span><br><span class="line">  L = [<span class="string">'cp'</span>, <span class="string">'index.html'</span>, <span class="string">'/dev/null'</span>]</span><br><span class="line">os.spawnvpe(os.P_WAIT, <span class="string">'cp'</span>, L, os.environ)</span><br></pre></td></tr></table></figure><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.spawn</code>，附带参数 <code>mode</code>、<code>path</code>、<code>args</code>、<code>env</code>。</p></li></ul><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlp" target="_blank" rel="noopener"><code>spawnlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlpe" target="_blank" rel="noopener"><code>spawnlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvp" target="_blank" rel="noopener"><code>spawnvp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener"><code>spawnvpe()</code></a> 在 Windows 上不可用。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnle" target="_blank" rel="noopener"><code>spawnle()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnve" target="_blank" rel="noopener"><code>spawnve()</code></a> 在 Windows 上不是线程安全的，建议使用 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 模块替代。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><ul><li><p><code>os.P_NOWAIT</code></p></li><li><p><code>os.P_NOWAITO</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 系列函数的 <em>mode</em> 参数的可取值。如果给出这些值中的任何一个，则 <code>spawn*()</code> 函数将在创建新进程后立即返回，且返回值为进程号。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><code>os.P_WAIT</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 系列函数的 <em>mode</em> 参数的可取值。如果将 <em>mode</em> 指定为该值，则 <code>spawn*()</code> 函数将在新进程运行完毕后返回，运行成功则返回进程的退出代码，被信号终止则返回 <code>-signal</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><code>os.P_DETACH</code></p></li><li><p><code>os.P_OVERLAY</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 系列函数的 <em>mode</em> 参数的可取值。它们比上面列出的值可移植性差。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_DETACH" target="_blank" rel="noopener"><code>P_DETACH</code></a> 与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_NOWAIT" target="_blank" rel="noopener"><code>P_NOWAIT</code></a> 相似，但是新进程会与父进程的控制台脱离。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_OVERLAY" target="_blank" rel="noopener"><code>P_OVERLAY</code></a> 则会替换当前进程，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 函数将不会返回。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。</p></li><li><p><code>os.startfile</code>(<em>path</em>[, <em>operation</em>])</p><p>使用已关联的应用程序打开文件。当 <em>operation</em> 未指定或指定为 <code>&#39;open&#39;</code> 时，这类似于在 Windows 资源管理器中双击文件，或在交互式命令行中将文件名作为 <strong>start</strong> 命令的参数：通过扩展名相关联的应用程序（如果有）打开文件。当指定另一个 <em>operation</em> 时，它必须是一个“命令动词” (“command verb”)，该词指定对文件执行的操作。Microsoft 文档中的常用动词有 <code>&#39;print&#39;</code> 和 <code>&#39;edit&#39;</code> （用于文件），以及 <code>&#39;explore&#39;</code> 和 <code>&#39;find&#39;</code> （用于目录）。关联的应用程序启动后 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.startfile" target="_blank" rel="noopener"><code>startfile()</code></a> 就会立即返回。本函数没有等待应用程序关闭的选项，也没有办法检索应用程序的退出状态。<em>path</em> 参数是基于当前目录的相对路径。如果要使用绝对路径，请确保第一个字符不是斜杠 (<code>&#39;/&#39;</code>)，是斜杠的话底层的 Win32 <code>ShellExecute()</code> 函数将失效。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.normpath" target="_blank" rel="noopener"><code>os.path.normpath()</code></a> 函数确保路径已针对 Win32 正确编码。为了减少解释器的启动开销，直到第一次调用本函数后，才解析 Win32 <code>ShellExecute()</code> 函数。如果无法解析该函数，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.startfile</code>，附带参数 <code>path</code>、<code>operation</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。</p></li><li><p><code>os.system</code>(<em>command</em>)</p><p>在子 shell 中执行命令（字符串）。这是调用标准 C 函数 <code>system()</code> 来实现的，因此限制条件与该函数相同。对 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a> 等的更改不会反映在执行命令的环境中。<em>command</em> 产生的任何输出将被发送到解释器标准输出流。在 Unix 上，返回值是进程的退出状态，编码格式与为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait" target="_blank" rel="noopener"><code>wait()</code></a> 指定的格式相同。注意，POSIX 没有指定 C 函数 <code>system()</code> 返回值的含义，因此 Python 函数的返回值与系统有关。在 Windows 上，返回值是运行 <em>command</em> 后系统 Shell 返回的值。该 Shell 由 Windows 环境变量 <code>COMSPEC</code>: 给出：通常是 <strong>cmd.exe</strong>，它会返回命令的退出状态。在使用非原生 Shell 的系统上，请查阅 Shell 的文档。<a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 模块提供了更强大的工具来生成新进程并跟踪执行结果，使用该模块比使用本函数更好。参阅 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 文档中的 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#subprocess-replacements" target="_blank" rel="noopener">Replacing Older Functions with the subprocess Module</a> 部分以获取有用的帮助。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.system</code>，附带参数 <code>command</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><code>os.times</code>()</p><p>返回当前的全局进程时间。返回值是一个有 5 个属性的对象：<code>user</code> - 用户时间<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>system</code></a> - 系统时间<code>children_user</code> - 所有子进程的用户时间<code>children_system</code> - 所有子进程的系统时间<code>elapsed</code> - 从过去的固定时间点起，经过的真实时间为了向后兼容，该对象的行为也类似于五元组，按照 <code>user</code>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>system</code></a>，<code>children_user</code>，<code>children_system</code> 和 <code>elapsed</code> 顺序组成。在 Unix 上请参阅 <em><a href="https://manpages.debian.org/times(2" target="_blank" rel="noopener">times(2)</a>)</em> 和 <em><a href="https://manpages.debian.org/times(3" target="_blank" rel="noopener">times(3)</a>)</em> 手册页，在 Windows 上请参阅 <a href="https://docs.microsoft.com/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocesstimes" target="_blank" rel="noopener">the GetProcessTimes MSDN</a> 。在 Windows 上，只有 <code>user</code> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>system</code></a> 是已知的，其他属性均为零。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.3 版更改:</em> 返回结果的类型由元组变成一个类似元组的对象，同时具有命名的属性。</p></li><li><p><code>os.wait</code>()</p><p>等待子进程执行完毕，返回一个元组，包含其 pid 和退出状态指示：一个 16 位数字，其低字节是终止该进程的信号编号，高字节是退出状态码（信号编号为零的情况下），如果生成了核心文件，则低字节的高位会置位。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.waitid</code>(<em>idtype</em>, <em>id</em>, <em>options</em>)</p><p>等待一个或多个子进程执行完毕。<em>idtype</em> 可以是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_PID" target="_blank" rel="noopener"><code>P_PID</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_PGID" target="_blank" rel="noopener"><code>P_PGID</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_ALL" target="_blank" rel="noopener"><code>P_ALL</code></a>。<em>id</em> 指定要等待的 pid。<em>options</em> 是由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WEXITED" target="_blank" rel="noopener"><code>WEXITED</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WSTOPPED" target="_blank" rel="noopener"><code>WSTOPPED</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WCONTINUED" target="_blank" rel="noopener"><code>WCONTINUED</code></a> 中的一个或多个进行或运算构造的，且额外可以与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WNOHANG" target="_blank" rel="noopener"><code>WNOHANG</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WNOWAIT" target="_blank" rel="noopener"><code>WNOWAIT</code></a> 进行或运算。返回值是一个对象，对应着 <code>siginfo_t</code> 结构体中的数据，即： <code>si_pid</code>, <code>si_uid</code>, <code>si_signo</code>, <code>si_status</code>, <code>si_code</code> 或 <code>None</code> （如果指定了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WNOHANG" target="_blank" rel="noopener"><code>WNOHANG</code></a> 且没有子进程处于等待状态）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.P_PID</code></p></li><li><p><code>os.P_PGID</code></p></li><li><p><code>os.P_ALL</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitid" target="_blank" rel="noopener"><code>waitid()</code></a> 的 <em>idtype</em> 参数的可取值。它们影响 <em>id</em> 的解释方式。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.WEXITED</code></p></li><li><p><code>os.WSTOPPED</code></p></li><li><p><code>os.WNOWAIT</code></p><p>用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitid" target="_blank" rel="noopener"><code>waitid()</code></a> 的 <em>options</em> 参数的标志位，指定要等待的子进程信号。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.CLD_EXITED</code></p></li><li><p><code>os.CLD_DUMPED</code></p></li><li><p><code>os.CLD_TRAPPED</code></p></li><li><p><code>os.CLD_CONTINUED</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitid" target="_blank" rel="noopener"><code>waitid()</code></a> 返回的结果中，<code>si_code</code> 的可取值。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.waitpid</code>(<em>pid</em>, <em>options</em>)</p><p>本函数的细节在 Unix 和 Windows 上有不同之处。</p><p>在 Unix 上：等待进程号为 <em>pid</em> 的子进程执行完毕，返回一个元组，内含其进程 ID 和退出状态指示（编码与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait" target="_blank" rel="noopener"><code>wait()</code></a> 相同）。调用的语义受整数 <em>options</em> 的影响，常规操作下该值应为 <code>0</code>。</p><p>如果 <em>pid</em> 大于 <code>0</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 会获取该指定进程的状态信息。如果 <em>pid</em> 为 <code>0</code>，则获取当前进程所在进程组中的所有子进程的状态。如果 <em>pid</em> 为 <code>-1</code>，则获取当前进程的子进程状态。如果 <em>pid</em> 小于 <code>-1</code>，则获取进程组 <code>-pid</code> （ <em>pid</em> 的绝对值）中所有进程的状态。</p><p>当系统调用返回 -1 时，将抛出带有错误码的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p><p>在 Windows 上：等待句柄为 <em>pid</em> 的进程执行完毕，返回一个元组，内含 <em>pid</em> 以及左移 8 位后的退出状态码（移位简化了跨平台使用本函数）。小于或等于 <code>0</code> 的 <em>pid</em> 在 Windows 上没有特殊含义，且会抛出异常。整数值 <em>options</em> 无效。<em>pid</em> 可以指向任何 ID 已知的进程，不一定是子进程。调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 函数时传入 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_NOWAIT" target="_blank" rel="noopener"><code>P_NOWAIT</code></a> 将返回合适的进程句柄。</p><p><em>在 3.5 版更改:</em> 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p></li><li><p><code>os.wait3</code>(<em>options</em>)</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 相似，差别在于没有进程 ID 参数，且返回一个 3 元组，其中包括子进程 ID，退出状态指示和资源使用信息。关于资源使用信息的详情，请参考 <a href="https://docs.python.org/zh-cn/3.8/library/resource.html#module-resource" target="_blank" rel="noopener"><code>resource</code></a>.<a href="https://docs.python.org/zh-cn/3.8/library/resource.html#resource.getrusage" target="_blank" rel="noopener"><code>getrusage()</code></a>。option 参数与传入 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait4" target="_blank" rel="noopener"><code>wait4()</code></a> 的相同。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.wait4</code>(<em>pid</em>, <em>options</em>)</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 相似，差别在本方法返回一个 3 元组，其中包括子进程 ID，退出状态指示和资源使用信息。关于资源使用信息的详情，请参考 <a href="https://docs.python.org/zh-cn/3.8/library/resource.html#module-resource" target="_blank" rel="noopener"><code>resource</code></a>.<a href="https://docs.python.org/zh-cn/3.8/library/resource.html#resource.getrusage" target="_blank" rel="noopener"><code>getrusage()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait4" target="_blank" rel="noopener"><code>wait4()</code></a> 的参数与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 的参数相同。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WNOHANG</code></p><p>用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 的选项，如果没有立即可用的子进程状态，则立即返回。在这种情况下，函数返回 <code>(0, 0)</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WCONTINUED</code></p><p>被任务控制 (job control) 停止的子进程，如果上次报告状态后已恢复运行，则此选项将报告这些子进程。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 部分 Unix 系统。</p></li><li><p><code>os.WUNTRACED</code></p><p>已停止的子进程，如果自停止以来尚未报告其当前状态，则此选项将报告这些子进程。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li></ul><p>下列函数采用进程状态码作为参数，状态码由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>system()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait" target="_blank" rel="noopener"><code>wait()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 返回。它们可用于确定进程上发生的操作。</p><ul><li><p><code>os.WCOREDUMP</code>(<em>status</em>)</p><p>如果为该进程生成了核心转储，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WIFCONTINUED</code>(<em>status</em>)</p><p>如果进程被任务控制 (job control) 停止后，又重新继续运行，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WIFSTOPPED</code>(<em>status</em>)</p><p>如果进程已停止，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WIFSIGNALED</code>(<em>status</em>)</p><p>如果进程由于信号而退出，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WIFEXITED</code>(<em>status</em>)</p><p>如果进程使用 <em><a href="https://manpages.debian.org/exit(2" target="_blank" rel="noopener">exit(2)</a>)</em> 系统调用退出，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WEXITSTATUS</code>(<em>status</em>)</p><p>如果 <code>WIFEXITED(status)</code> 为值，则将整数形参返回给 <em><a href="https://manpages.debian.org/exit(2" target="_blank" rel="noopener">exit(2)</a>)</em> 系统调用。 否则，返回值将没有任何意义。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WSTOPSIG</code>(<em>status</em>)</p><p>返回导致进程停止的信号。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WTERMSIG</code>(<em>status</em>)</p><p>返回导致进程退出的信号。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li></ul><h2 id="调度器接口"><a href="#调度器接口" class="headerlink" title="调度器接口"></a>调度器接口</h2><p>这些函数控制操作系统如何为进程分配 CPU 时间。 它们仅在某些 Unix 平台上可用。 更多细节信息请查阅你所用 Unix 的指南页面。</p><p><em>3.3 新版功能.</em></p><p>以下调度策略如果被操作系统支持就会对外公开。</p><ul><li><p><code>os.SCHED_OTHER</code></p><p>默认调度策略。</p></li><li><p><code>os.SCHED_BATCH</code></p><p>用于 CPU 密集型进程的调度策略，它会尽量为计算机中的其余任务保留交互性。</p></li><li><p><code>os.SCHED_IDLE</code></p><p>用于极低优先级的后台任务的调度策略。</p></li><li><p><code>os.SCHED_SPORADIC</code></p><p>用于偶发型服务程序的调度策略。</p></li><li><p><code>os.SCHED_FIFO</code></p><p>先进先出的调度策略。</p></li><li><p><code>os.SCHED_RR</code></p><p>循环式的调度策略。</p></li><li><p><code>os.SCHED_RESET_ON_FORK</code></p><p>此旗标可与任何其他调度策略进行 OR 运算。 当带有此旗标的进程设置分叉时，其子进程的调度策略和优先级会被重置为默认值。</p></li><li><p><em>class</em> <code>os.sched_param</code>(<em>sched_priority</em>)</p><p>这个类表示在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_setparam" target="_blank" rel="noopener"><code>sched_setparam()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_setscheduler" target="_blank" rel="noopener"><code>sched_setscheduler()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_getparam" target="_blank" rel="noopener"><code>sched_getparam()</code></a> 中使用的可修改调度形参。 它属于不可变对象。目前它只有一个可能的形参：<code>sched_priority</code>一个调度策略的调度优先级。</p></li><li><p><code>os.sched_get_priority_min</code>(<em>policy</em>)</p><p>获取 <em>policy</em> 的最小优先级数值。 <em>policy</em> 是以上调度策略常量之一。</p></li><li><p><code>os.sched_get_priority_max</code>(<em>policy</em>)</p><p>获取 <em>policy</em> 的最高优先级数值。 <em>policy</em> 是以上调度策略常量之一。</p></li><li><p><code>os.sched_setscheduler</code>(<em>pid</em>, <em>policy</em>, <em>param</em>)</p><p>设置 PID 为 <em>pid</em> 的进程的调度策略。<em>pid</em> 为 0 指的是调用本方法的进程。<em>policy</em> 是以上调度策略常量之一。<em>param</em> 是一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_param" target="_blank" rel="noopener"><code>sched_param</code></a> 实例。</p></li><li><p><code>os.sched_getscheduler</code>(<em>pid</em>)</p><p>返回 PID 为 <em>pid</em> 的进程的调度策略。<em>pid</em> 为 0 指的是调用本方法的进程。返回的结果是以上调度策略常量之一。</p></li><li><p><code>os.sched_setparam</code>(<em>pid</em>, <em>param</em>)</p><p>设置 PID 为 <em>pid</em> 的进程的某个调度参数。<em>pid</em> 为 0 指的是调用本方法的进程。<em>param</em> 是一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_param" target="_blank" rel="noopener"><code>sched_param</code></a> 实例。</p></li><li><p><code>os.sched_getparam</code>(<em>pid</em>)</p><p>返回 PID 为 <em>pid</em> 的进程的调度参数为一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_param" target="_blank" rel="noopener"><code>sched_param</code></a> 实例。<em>pid</em> 为 0 指的是调用本方法的进程。</p></li><li><p><code>os.sched_rr_get_interval</code>(<em>pid</em>)</p><p>返回 PID 为 <em>pid</em> 的进程在时间片轮转调度下的时间片长度（单位为秒）。<em>pid</em> 为 0 指的是调用本方法的进程。</p></li><li><p><code>os.sched_yield</code>()</p><p>自愿放弃 CPU。</p></li><li><p><code>os.sched_setaffinity</code>(<em>pid</em>, <em>mask</em>)</p><p>将 PID 为 <em>pid</em> 的进程（为零则为当前进程）限制到一组 CPU 上。<em>mask</em> 是整数的可迭代对象，表示应将进程限制在其中的一组 CPU。</p></li><li><p><code>os.sched_getaffinity</code>(<em>pid</em>)</p><p>返回 PID 为 <em>pid</em> 的进程（为零则为当前进程）被限制到的那一组 CPU。</p></li></ul><h2 id="其他系统信息"><a href="#其他系统信息" class="headerlink" title="其他系统信息"></a>其他系统信息</h2><ul><li><p><code>os.confstr</code>(<em>name</em>)</p><p>返回字符串格式的系统配置信息。<em>name</em> 指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 <code>confstr_names</code> 字典的键中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 <em>name</em>。</p><p>如果 <em>name</em> 指定的配置值未定义，返回 <code>None</code>。</p><p>如果 <em>name</em> 是一个字符串且不是已定义的名称，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。如果当前系统不支持 <em>name</em> 指定的配置名称，即使该名称存在于 <code>confstr_names</code>，也会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，错误码为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EINVAL" target="_blank" rel="noopener"><code>errno.EINVAL</code></a>。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>s.confstr_names</code></p><p>字典，表示映射关系，为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.confstr" target="_blank" rel="noopener"><code>confstr()</code></a> 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.cpu_count</code>()</p><p>返回系统的 CPU 数量。不确定则返回 <code>None</code>。该数量不同于当前进程可以使用的CPU数量。可用的CPU数量可以由 <code>len(os.sched_getaffinity(0))</code> 方法获得。<em>3.4 新版功能.</em></p></li><li><p><code>os.getloadavg</code>()</p><p>返回系统运行队列中最近 1、5 和 15 分钟内的平均进程数。无法获得平均负载则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.sysconf</code>(<em>name</em>)</p><p>返回整数格式的系统配置信息。如果 <em>name</em> 指定的配置值未定义，返回 <code>-1</code>。对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.confstr" target="_blank" rel="noopener"><code>confstr()</code></a> 的 <em>name</em> 参数的注释在此处也适用。当前已知的配置名称在 <code>sysconf_names</code> 字典中提供。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.sysconf_names</code></p><p>字典，表示映射关系，为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li></ul><p>以下数据值用于支持对路径本身的操作。所有平台都有定义。</p><p>对路径的高级操作在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 模块中定义。</p><ul><li><p><code>os.curdir</code></p><p>操作系统用来表示当前目录的常量字符串。在 Windows 和 POSIX 上是 <code>&#39;.&#39;</code>。在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 中也可用。</p></li></ul><ul><li><p><code>os.pardir</code></p><p>操作系统用来表示父目录的常量字符串。在 Windows 和 POSIX 上是 <code>&#39;..&#39;</code>。在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 中也可用。</p></li></ul><ul><li><p><code>os.defpath</code></p><p>在环境变量没有 <code>&#39;PATH&#39;</code> 键的情况下，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*p*</code></a> and <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*p*</code></a> 使用的默认搜索路径。在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 中也可用。</p></li><li><p><code>os.linesep</code></p><p>当前平台用于分隔（或终止）行的字符串。它可以是单个字符，如 POSIX 上是 <code>&#39;\n&#39;</code>，也可以是多个字符，如 Windows 上是 <code>&#39;\r\n&#39;</code>。在写入以文本模式（默认模式）打开的文件时，请不要使用 <em>os.linesep</em> 作为行终止符，请在所有平台上都使用一个 <code>&#39;\n&#39;</code> 代替。</p></li><li><p><code>os.devnull</code></p><p>空设备的文件路径。如 POSIX 上为 <code>&#39;/dev/null&#39;</code>，Windows 上为 <code>&#39;nul&#39;</code>。在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 中也可用。</p></li><li><p><code>os.RTLD_LAZY</code></p></li><li><p><code>os.RTLD_NOW</code></p></li><li><p><code>os.RTLD_GLOBAL</code></p></li><li><p><code>os.RTLD_LOCAL</code></p></li><li><p><code>os.RTLD_NODELETE</code></p></li><li><p><code>os.RTLD_NOLOAD</code></p></li><li><p><code>os.RTLD_DEEPBIND</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.setdlopenflags" target="_blank" rel="noopener"><code>setdlopenflags()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getdlopenflags" target="_blank" rel="noopener"><code>getdlopenflags()</code></a> 函数所使用的标志。请参阅 Unix 手册页 <em><a href="https://manpages.debian.org/dlopen(3" target="_blank" rel="noopener">dlopen(3)</a>)</em> 获取不同标志的含义。<em>3.3 新版功能.</em></p></li></ul><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><ul><li><p><code>os.getrandom</code>(<em>size</em>, <em>flags=0</em>)</p><p>获得最多为 <em>size</em> 的随机字节。本函数返回的字节数可能少于请求的字节数。</p><p>这些字节可用于为用户空间的随机数生成器提供种子，或用于加密目的。</p><p><code>getrandom()</code> 依赖于从设备驱动程序和其他环境噪声源收集的熵。不必要地读取大量数据将对使用 <code>/dev/random</code> 和 <code>/dev/urandom</code> 设备的其他用户产生负面影响。</p><p>flags 参数是一个位掩码，可以是零个或多个下列值以或运算组合： <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.GRND_RANDOM" target="_blank" rel="noopener"><code>os.GRND_RANDOM</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.GRND_NONBLOCK" target="_blank" rel="noopener"><code>GRND_NONBLOCK</code></a>。</p><p>另请参阅 <a href="http://man7.org/linux/man-pages/man2/getrandom.2.html" target="_blank" rel="noopener">Linux getrandom() 手册页</a> 。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 3.17 或更高版本。</p><p><em>3.6 新版功能.</em></p></li><li><p><code>os.urandom</code>(<em>size</em>)</p><p>返回大小为 <em>size</em> 的字符串，它是适合加密使用的随机字节。本函数从系统指定的随机源获取随机字节。对于加密应用程序，返回的数据应有足够的不可预测性，尽管其确切的品质取决于操作系统的实现。在 Linux 上，如果 <code>getrandom()</code> 系统调用可用，它将以阻塞模式使用：阻塞直到系统的 urandom 熵池初始化完毕（内核收集了 128 位熵）。原理请参阅 <a href="https://www.python.org/dev/peps/pep-0524" target="_blank" rel="noopener"><strong>PEP 524</strong></a>。在 Linux 上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getrandom" target="_blank" rel="noopener"><code>getrandom()</code></a> 可以以非阻塞模式（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.GRND_NONBLOCK" target="_blank" rel="noopener"><code>GRND_NONBLOCK</code></a> 标志）获取随机字节，或者轮询直到系统的 urandom 熵池初始化完毕。在类 Unix 系统上，随机字节是从 <code>/dev/urandom</code> 设备读取的。如果 <code>/dev/urandom</code> 设备不可用或不可读，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。在 Windows 上将使用 <code>CryptGenRandom()</code>。参见 <a href="https://docs.python.org/zh-cn/3.8/library/secrets.html#module-secrets" target="_blank" rel="noopener"><code>secrets</code></a> 模块提供了更高级的功能。所在平台会提供随机数生成器，有关其易于使用的接口，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/random.html#random.SystemRandom" target="_blank" rel="noopener"><code>random.SystemRandom</code></a>。<em>在 3.6.0 版更改:</em> 在 Linux 上，<code>getrandom()</code> 现在以阻塞模式使用，以提高安全性。<em>在 3.5.2 版更改:</em> 在 Linux 上，如果 <code>getrandom()</code> 系统调用阻塞（urandom 熵池尚未初始化完毕），则退回一步读取 <code>/dev/urandom</code>。<em>在 3.5 版更改:</em> 在 Linux 3.17 和更高版本上，现在使用 <code>getrandom()</code> 系统调用（如果可用）。在 OpenBSD 5.6 和更高版本上，现在使用 <code>getentropy()</code> C 函数。这些函数避免了使用内部文件描述符。</p></li><li><p><code>os.GRND_NONBLOCK</code></p><p>默认情况下，从 <code>/dev/random</code> 读取时，如果没有可用的随机字节，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getrandom" target="_blank" rel="noopener"><code>getrandom()</code></a> 会阻塞；从 <code>/dev/urandom</code> 读取时，如果熵池尚未初始化，则会阻塞。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.GRND_NONBLOCK" target="_blank" rel="noopener"><code>GRND_NONBLOCK</code></a> 标志，则这些情况下 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getrandom" target="_blank" rel="noopener"><code>getrandom()</code></a> 不会阻塞，而是立即抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BlockingIOError" target="_blank" rel="noopener"><code>BlockingIOError</code></a> 异常。<em>3.6 新版功能.</em></p></li><li><p><code>os.GRND_RANDOM</code></p><p>如果设置了此标志位，那么将从 <code>/dev/random</code> 池而不是 <code>/dev/urandom</code> 池中提取随机字节。</p><p><em>3.6 新版功能.</em></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-os&quot;&gt;&lt;a href=&quot;#python-标准库-os&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 os&quot;&gt;&lt;/a&gt;python 标准库 os&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200220_os.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="os" scheme="https://pinghailinfeng.gitee.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>python standard library shutil</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/19/python-standard-library-shutil/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/19/python-standard-library-shutil/</id>
    <published>2020-02-19T13:24:47.000Z</published>
    <updated>2020-02-19T13:44:39.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-shutil-高阶文件操作"><a href="#python-标准库-shutil-高阶文件操作" class="headerlink" title="python 标准库 shutil 高阶文件操作"></a>python 标准库 shutil 高阶文件操作</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200219python3_sheet.png?raw=true" alt></p><a id="more"></a><p>收集了一些网上找到的学习python的资源,分享给大家。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/shutil.py" target="_blank" rel="noopener">Lib/shutil.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 模块提供了一系列对文件和文件集合的高阶操作。 特别是提供了一些支持文件拷贝和删除的函数。 对于单个文件的操作，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块。</p><blockquote><p>警告：即便是高阶文件拷贝函数 (<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>shutil.copy()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>shutil.copy2()</code></a>) 也无法拷贝所有的文件元数据。</p><p>在 POSIX 平台上，这意味着将丢失文件所有者和组以及 ACL 数据。 在 Mac OS 上，资源钩子和其他元数据不被使用。 这意味着将丢失这些资源并且文件类型和创建者代码将不正确。 在 Windows 上，将不会拷贝文件所有者、ACL 和替代数据流。</p></blockquote><h2 id="目录和文件操作"><a href="#目录和文件操作" class="headerlink" title="目录和文件操作"></a>目录和文件操作</h2><ul><li><p><code>shutil.copyfileobj</code>(<em>fsrc</em>, <em>fdst</em>[, <em>length</em>])</p><p>将文件类对象 <em>fsrc</em> 的内容拷贝到文件类对象 <em>fdst</em>。 整数值 <em>length</em> 如果给出则为缓冲区大小。 特别地， <em>length</em> 为负值表示拷贝数据时不对源数据进行分块循环处理；默认情况下会分块读取数据以避免不受控制的内存消耗。 请注意如果 <em>fsrc</em> 对象的当前文件位置不为 0，则只有从当前文件位置到文件末尾的内容会被拷贝。</p></li><li><p><code>shutil.copyfile</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>将名为 <em>src</em> 的文件的内容（不包括元数据）拷贝到名为 <em>dst</em> 的文件并以尽可能高效的方式返回 <em>dst</em>。 <em>src</em> 和 <em>dst</em> 均为路径类对象或以字符串形式给出的路径名。<em>dst</em> 必须是完整的目标文件名；对于接受目标目录路径的拷贝请参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a>。 如果 <em>src</em> 和 <em>dst</em> 指定了同一个文件，则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.SameFileError" target="_blank" rel="noopener"><code>SameFileError</code></a>。目标位置必须是可写的；否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。 如果 <em>dst</em> 已经存在，它将被替换。 特殊文件如字符或块设备以及管道无法用此函数来拷贝。如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则将创建一个新的符号链接而不是拷贝 <em>src</em> 所指向的文件。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 曾经是引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IOError" target="_blank" rel="noopener"><code>IOError</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>。 增加了 <em>follow_symlinks</em> 参数。 现在是返回 <em>dst</em>。<em>在 3.4 版更改:</em> 引发 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.SameFileError" target="_blank" rel="noopener"><code>SameFileError</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.Error" target="_blank" rel="noopener"><code>Error</code></a>。 由于前者是后者的子类，此改变是向后兼容的。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p></li><li><p><em>exception</em> <code>shutil.SameFileError</code></p><p>此异常会在 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfile" target="_blank" rel="noopener"><code>copyfile()</code></a> 中的源和目标为同一文件时被引发。<em>3.4 新版功能.</em></p></li><li><p><code>shutil.copymode</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>从 <em>src</em> 拷贝权限位到 <em>dst</em>。 文件的内容、所有者和分组将不受影响。 <em>src</em> 和 <em>dst</em> 均为路径类对象或字符串形式的路径名。 如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均为符号链接，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copymode" target="_blank" rel="noopener"><code>copymode()</code></a> 将尝试修改 <em>dst</em> 本身的模式（而非它所指向的文件）。 此功能并不是在所有平台上均可用；请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 了解详情。 如果 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copymode" target="_blank" rel="noopener"><code>copymode()</code></a> 无法修改本机平台上的符号链接，而它被要求这样做，它将不做任何操作即返回。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copymode</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 加入 <em>follow_symlinks</em> 参数。</p></li><li><p><code>shutil.copystat</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>从 <em>src</em> 拷贝权限位、最近访问时间、最近修改时间以及旗标到 <em>dst</em>。 在 Linux上，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 还会在可能的情况下拷贝“扩展属性”。 文件的内容、所有者和分组将不受影响。 <em>src</em> 和 <em>dst</em> 均为路径类对象或字符串形式的路径名。如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均指向符号链接，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 将作用于符号链接本身而非该符号链接所指向的文件 — 从 <em>src</em> 符号链接读取信息，并将信息写入 <em>dst</em> 符号链接。</p><blockquote><p>注解:</p><p>并非所有平台者提供检查和修改符号链接的功能。 Python 本身可以告诉你哪些功能是在本机上可用的。</p><ul><li>如果 <code>os.chmod in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 可以修改符号链接的权限位。</li><li>如果 <code>os.utime in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 可以修改符号链接的最近访问和修改时间。</li><li>如果 <code>os.chflags in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 可以修改符号链接的旗标。 (<code>os.chflags</code> 不是在所有平台上均可用。)</li></ul><p>在此功能部分或全部不可用的平台上，当被要求修改一个符号链接时，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 将尽量拷贝所有内容。 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 一定不会返回失败信息。</p><p>更多信息请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_follow_symlinks" target="_blank" rel="noopener"><code>os.supports_follow_symlinks</code></a>。</p></blockquote><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copystat</code> 附带参数 <code>src</code>, <code>dst</code>。</p><p><em>在 3.3 版更改:</em> 添加了 <em>follow_symlinks</em> 参数并且支持 Linux 扩展属性。</p></li><li><p><code>shutil.copy</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>将文件 <em>src</em> 拷贝到文件或目录 <em>dst</em>。 <em>src</em> 和 <em>dst</em> 应为字符串。 如果 <em>dst</em> 指定了一个目录，文件将使用 <em>src</em> 中的基准文件名拷贝到 <em>dst</em>。 返回新创建文件的路径。如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则 <em>dst</em> 也将被创建为符号链接。 如果 <em>follow_symlinks</em> 为真值且 <em>src</em> 为符号链接，<em>dst</em> 将成为 <em>src</em> 所指向的文件的一个副本。<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a> 会拷贝文件数据和文件的权限模式 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>os.chmod()</code></a>)。 其他元数据，例如文件的创建和修改时间不会被保留。 要保留所有原有的元数据，请改用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copymode</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 添加了 <em>follow_symlinks</em> 参数。 现在会返回新创建文件的路径。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p></li><li><p><code>shutil.copy2</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a>，区别在于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 还会尝试保留文件的元数据。当 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接时，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 会尝试将来自 <em>src</em> 符号链接的所有元数据拷贝到新创建的 <em>dst</em> 符号链接。 但是，此功能不是在所有平台上均可用。 在此功能部分或全部不可用的平台上，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 将尽量保留所有元数据；<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 一定不会由于无法保留文件元数据而引发异常。<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 会使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 来拷贝文件元数据。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 了解有关修改符号链接元数据的平台支持的更多信息。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copystat</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 添加了 <em>follow_symlinks</em> 参数，还会尝试拷贝扩展文件系统属性（目前仅限 Linux）。 现在会返回新创建文件的路径。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p></li><li><p><code>shutil.ignore_patterns</code>(*<em>patterns</em>)</p><p>这个工厂函数会创建一个函数，它可被用作 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 的 <em>ignore</em> 可调用对象参数，以忽略那些匹配所提供的 glob 风格的 <em>patterns</em> 之一的文件和目录。 参见以下示例。</p></li><li><p><code>shutil.copytree</code>(<em>src</em>, <em>dst</em>, <em>symlinks=False</em>, <em>ignore=None</em>, <em>copy_function=copy2</em>, <em>ignore_dangling_symlinks=False</em>, <em>dirs_exist_ok=False</em>)</p><p>将以 <em>src</em> 为根起点的整个目录树拷贝到名为 <em>dst</em> 的目录并返回目标目录。 <em>dirs_exist_ok</em> 指明是否要在 <em>dst</em> 或任何丢失的父目录已存在的情况下引发异常。目录的权限和时间会通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 来拷贝，单个文件则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 来拷贝。如果 <em>symlinks</em> 为真值，源目录树中的符号链接会在新目录树中表示为符号链接，并且原链接的元数据在平台允许的情况下也会被拷贝；如果为假值或省略，则会将被链接文件的内容和元数据拷贝到新目录树。当 <em>symlinks</em> 为假值时，如果符号链接所指向的文件不存在，则会在拷贝进程的末尾将一个异常添加到 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.Error" target="_blank" rel="noopener"><code>Error</code></a> 异常中的错误列表。 如果你希望屏蔽此异常那就将可选的 <em>ignore_dangling_symlinks</em> 旗标设为真值。 请注意此选项在不支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.symlink" target="_blank" rel="noopener"><code>os.symlink()</code></a> 的平台上将不起作用。如果给出了 <em>ignore</em>，它必须是一个可调用对象，该对象将接受 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 所访问的目录以及 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>os.listdir()</code></a> 所返回的目录内容列表作为其参数。 由于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 是递归地被调用的，<em>ignore</em> 可调用对象对于每个被拷贝目录都将被调用一次。 该可调用对象必须返回一个相对于当前目录的目录和文件名序列（即其第二个参数的子集）；随后这些名称将在拷贝进程中被忽略。 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.ignore_patterns" target="_blank" rel="noopener"><code>ignore_patterns()</code></a> 可被用于创建这种基于 glob 风格模式来忽略特定名称的可调用对象。如果发生了（一个或多个）异常，将引发一个附带原因列表的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.Error" target="_blank" rel="noopener"><code>Error</code></a>。如果给出了 <em>copy_function</em>，它必须是一个将被用来拷贝每个文件的可调用对象。 它在被调用时会将源路径和目标路径作为参数传入。 默认情况下，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 将被使用，但任何支持同样签名（与 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a> 一致）都可以使用。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copytree</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 当 <em>symlinks</em> 为假值时拷贝元数据。 现在会返回 <em>dst</em>。<em>在 3.2 版更改:</em> 添加了 <em>copy_function</em> 参数以允许提供定制的拷贝函数。 添加了 <em>ignore_dangling_symlinks</em> 参数以便在 <em>symlinks</em> 为假值时屏蔽符号链接错误。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。<em>3.8 新版功能:</em> <em>dirs_exist_ok</em> 形参。</p></li><li><p><code>shutil.rmtree</code>(<em>path</em>, <em>ignore_errors=False</em>, <em>onerror=None</em>)</p><p>删除一个完整的目录树；<em>path</em> 必须指向一个目录（但不能是一个目录的符号链接）。 如果 <em>ignore_errors</em> 为真值，删除失败导致的错误将被忽略；如果为假值或是省略，此类错误将通过调用由 <em>onerror</em> 所指定的处理程序来处理，或者如果此参数被省略则将引发一个异常。</p><blockquote><p>注解:</p><p>在支持必要的基于 fd 的函数的平台上，默认会使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree" target="_blank" rel="noopener"><code>rmtree()</code></a> 的可防御符号链接攻击的版本。 在其他平台上，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree" target="_blank" rel="noopener"><code>rmtree()</code></a> 较易遭受符号链接攻击：给定适当的时间和环境，攻击者可以操纵文件系统中的符号链接来删除他们在其他情况下无法访问的文件。 应用程序可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree.avoids_symlink_attacks" target="_blank" rel="noopener"><code>rmtree.avoids_symlink_attacks</code></a> 函数属性来确定此类情况具体是哪一些。</p></blockquote></li></ul><ul><li><p><code>shutil.move</code>(<em>src</em>, <em>dst</em>, <em>copy_function=copy2</em>)</p><p>递归地将一个文件或目录 (<em>src</em>) 移至另一位置 (<em>dst</em>) 并返回目标位置。如果目标是已存在的目录，则 <em>src</em> 会被移至该目录下。 如果目标已存在但不是目录，它可能会被覆盖，具体取决于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a> 的语义。如果目标是在当前文件系统中，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a>。 在其他情况下，<em>src</em> 将被拷贝至 <em>dst</em>，使用的函数为 <em>copy_function</em>，然后目标会被移除。 对于符号链接，则将在 <em>dst</em> 之下或以其本身为名称创建一个指向 <em>src</em> 目标的新符号链接，并且 <em>src</em> 将被移除。如果给出了 <em>copy_function</em>，则它必须为接受两个参数 <em>src</em> 和 <em>dst</em> 的可调用对象，并会在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a> 无法使用时被用来将 <em>src</em> 拷贝到 <em>dest</em>。 如果源位置是一个目录，则会调用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a>，并向它传入 <code>copy_function()</code>。 默认的 <em>copy_function</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a>。 使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a> 作为 <em>copy_function</em> 允许在无法附带拷贝元数据时让移动操作成功执行，但其代价是不拷贝任何元数据。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.move</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 为异类文件系统添加了显式的符号链接处理，以便使它适应 GNU 的 <strong>mv</strong> 的行为。 现在会返回 <em>dst</em>。<em>在 3.5 版更改:</em> 增加了 <em>copy_function</em> 关键字参数。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p></li><li><p><code>shutil.disk_usage</code>(<em>path</em>)</p><p>返回给定路径的磁盘使用统计数据，形式为一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-named-tuple" target="_blank" rel="noopener">named tuple</a>，其中包含 <em>total</em>, <em>used</em> 和 <em>free</em> 属性，分别表示总计、已使用和未使用空间的字节数。 <em>path</em> 可以是一个文件或是一个目录。<em>3.3 新版功能.**在 3.8 版更改:</em> 在 Windows 上，<em>path</em> 现在可以是一个文件或目录。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><code>shutil.chown</code>(<em>path</em>, <em>user=None</em>, <em>group=None</em>)</p><p>修改给定 <em>path</em> 的所有者 <em>user</em> 和/或 <em>group</em>。<em>user</em> 可以是一个系统用户名或 uid；<em>group</em> 同样如此。 要求至少有一个参数。另请参阅下层的函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chown" target="_blank" rel="noopener"><code>os.chown()</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.chown</code> 附带参数 <code>path</code>, <code>user</code>, <code>group</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">Availability</a>: Unix.<em>3.3 新版功能.</em></p></li><li><p><code>shutil.which</code>(<em>cmd</em>, <em>mode=os.F_OK | os.X_OK</em>, <em>path=None</em>)</p><p>返回当给定的 <em>cmd</em> 被调用时将要运行的可执行文件的路径。 如果没有 <em>cmd</em> 会被调用则返回 <code>None</code>。<em>mode</em> 是一个传递给 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>os.access()</code></a> 的权限掩码，在默认情况下将确定文件是否存在并且为可执行文件。当未指定 <em>path</em> 时，将会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>os.environ()</code></a> 的结果，返回 “PATH” 的值或回退为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.defpath" target="_blank" rel="noopener"><code>os.defpath</code></a>。在 Windows 上当前目录总是会被添加为 <em>path</em> 的第一项，无论你是否使用默认值或提供你自己的路径，这是命令行终端在查找可执行文件时所采用的行为方式。 此外，当在 <em>path</em> 中查找 <em>cmd</em> 时，还会检查 <code>PATHEXT</code> 环境变量。 例如，如果你调用 <code>shutil.which(&quot;python&quot;)</code>，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.which" target="_blank" rel="noopener"><code>which()</code></a> 将搜索 <code>PATHEXT</code> 来确定它要在 <em>path</em> 目录中查找 <code>python.exe</code>。 例如，在 Windows 上:&gt;&gt;&gt;<code>&gt;&gt;&gt; shutil.which(&quot;python&quot;) &#39;C:\\Python33\\python.EXE&#39;</code><em>3.3 新版功能.**在 3.8 版更改:</em> 现在可以接受 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型。 如果 <em>cmd</em> 的类型为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>，结果的类型也将为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>。</p></li><li><p><em>exception</em> <code>shutil.Error</code></p><p>此异常会收集在多文件操作期间所引发的异常。 对于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a>，此异常参数将是一个由三元组 (<em>srcname</em>, <em>dstname</em>, <em>exception</em>) 构成的列表。</p></li></ul><h2 id="依赖于具体平台的高效拷贝操作"><a href="#依赖于具体平台的高效拷贝操作" class="headerlink" title="依赖于具体平台的高效拷贝操作"></a>依赖于具体平台的高效拷贝操作</h2><p>从 Python 3.8 开始，所有涉及文件拷贝的函数 (<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfile" target="_blank" rel="noopener"><code>copyfile()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#module-copy" target="_blank" rel="noopener"><code>copy()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a>, 以及 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.move" target="_blank" rel="noopener"><code>move()</code></a>) 将会使用平台专属的 “fast-copy” 系统调用以便更高效地拷贝文件 (参见 <a href="https://bugs.python.org/issue33671" target="_blank" rel="noopener">bpo-33671</a>)。 “fast-copy” 意味着拷贝操作将发生于内核之中，避免像在 “<code>outfd.write(infd.read())</code>“ 中那样使用用户空间的缓冲区。</p><p>在 macOS 上将会使用 <a href="http://www.manpagez.com/man/3/copyfile/" target="_blank" rel="noopener">fcopyfile</a> 来拷贝文件内容（不含元数据）。</p><p>在 Linux 上将会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sendfile" target="_blank" rel="noopener"><code>os.sendfile()</code></a>。</p><p>在 Windows 上 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfile" target="_blank" rel="noopener"><code>shutil.copyfile()</code></a> 将会使用更大的默认缓冲区（1 MiB 而非 64 KiB）并且会使用基于 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview()</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfileobj" target="_blank" rel="noopener"><code>shutil.copyfileobj()</code></a> 变种形式。</p><p>如果快速拷贝操作失败并且没有数据被写入目标文件，则 shutil 将在内部静默地回退到使用效率较低的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfileobj" target="_blank" rel="noopener"><code>copyfileobj()</code></a> 函数。</p><p><em>在 3.8 版更改.</em></p><h3 id="copytree-示例"><a href="#copytree-示例" class="headerlink" title="copytree 示例"></a>copytree 示例</h3><p>这个示例就是上面所描述的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 函数的实现，其中省略了文档字符串。 它还展示了此模块所提供的许多其他函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copytree</span><span class="params">(src, dst, symlinks=False)</span>:</span></span><br><span class="line">    names = os.listdir(src)</span><br><span class="line">    os.makedirs(dst)</span><br><span class="line">    errors = []</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        srcname = os.path.join(src, name)</span><br><span class="line">        dstname = os.path.join(dst, name)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> symlinks <span class="keyword">and</span> os.path.islink(srcname):</span><br><span class="line">                linkto = os.readlink(srcname)</span><br><span class="line">                os.symlink(linkto, dstname)</span><br><span class="line">            <span class="keyword">elif</span> os.path.isdir(srcname):</span><br><span class="line">                copytree(srcname, dstname, symlinks)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                copy2(srcname, dstname)</span><br><span class="line">            <span class="comment"># XXX What about devices, sockets etc.?</span></span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> why:</span><br><span class="line">            errors.append((srcname, dstname, str(why)))</span><br><span class="line">        <span class="comment"># catch the Error from the recursive copytree so that we can</span></span><br><span class="line">        <span class="comment"># continue with other files</span></span><br><span class="line">        <span class="keyword">except</span> Error <span class="keyword">as</span> err:</span><br><span class="line">            errors.extend(err.args[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        copystat(src, dst)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> why:</span><br><span class="line">        <span class="comment"># can't copy file access times on Windows</span></span><br><span class="line">        <span class="keyword">if</span> why.winerror <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            errors.extend((src, dst, str(why)))</span><br><span class="line">    <span class="keyword">if</span> errors:</span><br><span class="line">        <span class="keyword">raise</span> Error(errors)</span><br></pre></td></tr></table></figure><p>另一个使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.ignore_patterns" target="_blank" rel="noopener"><code>ignore_patterns()</code></a> 辅助函数的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree, ignore_patterns</span><br><span class="line"></span><br><span class="line">copytree(source, destination, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br></pre></td></tr></table></figure><p>这将会拷贝除 <code>.pyc</code> 文件和以 <code>tmp</code> 打头的文件或目录以外的所有条目.</p><p>另一个使用 <em>ignore</em> 参数来添加记录调用的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_logpath</span><span class="params">(path, names)</span>:</span></span><br><span class="line">    logging.info(<span class="string">'Working in %s'</span>, path)</span><br><span class="line">    <span class="keyword">return</span> []   <span class="comment"># nothing will be ignored</span></span><br><span class="line"></span><br><span class="line">copytree(source, destination, ignore=_logpath)</span><br></pre></td></tr></table></figure><h3 id="rmtree-示例"><a href="#rmtree-示例" class="headerlink" title="rmtree 示例"></a>rmtree 示例</h3><p>这个例子演示了如何在 Windows 上删除一个目录树，其中部分文件设置了只读属性位。 它会使用 onerror 回调函数来清除只读属性位并再次尝试删除。 任何后续的失败都将被传播。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, stat</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_readonly</span><span class="params">(func, path, _)</span>:</span></span><br><span class="line">    <span class="string">"Clear the readonly bit and reattempt the removal"</span></span><br><span class="line">    os.chmod(path, stat.S_IWRITE)</span><br><span class="line">    func(path)</span><br><span class="line"></span><br><span class="line">shutil.rmtree(directory, onerror=remove_readonly)</span><br></pre></td></tr></table></figure><h2 id="归档操作"><a href="#归档操作" class="headerlink" title="归档操作"></a>归档操作</h2><p><em>3.2 新版功能.</em></p><p><em>在 3.5 版更改:</em> 添加了对 <em>xztar</em> 格式的支持。</p><p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <a href="https://docs.python.org/zh-cn/3.8/library/zipfile.html#module-zipfile" target="_blank" rel="noopener"><code>zipfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tarfile.html#module-tarfile" target="_blank" rel="noopener"><code>tarfile</code></a> 模块。</p><ul><li><p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p><p>创建一个归档文件（例如 zip 或 tar）并返回其名称。<em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “tar”, “gztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “bztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用) 或 “xztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用) 中的一个。<em>root_dir</em> 是一个目录，它将作为归档文件的根目录；例如，我们通常会在创建归档文件之前用 chdir 命令切换到 <em>root_dir</em>。<em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档文件中所有文件和目录共有的路径前缀。<em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。<em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。<em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logging.Logger" target="_blank" rel="noopener"><code>logging.Logger</code></a> 的实例。<em>verbose</em> 参数已不再使用并进入弃用状态。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。<em>在 3.8 版更改:</em> 现在对于通过 <code>format=&quot;tar&quot;</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p></li><li><p><code>shutil.get_archive_formats</code>()</p><p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_archive_format" target="_blank" rel="noopener"><code>register_archive_format()</code></a> 注册新的格式或为任何现有格式提供你自己的归档器。</p></li><li><p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>为 <em>name</em> 格式注册一个归档器。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name</em>，再加上要归档内容的 <em>base_dir</em> (其默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.make_archive" target="_blank" rel="noopener"><code>make_archive()</code></a> 传入的参数一致)。如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。<em>description</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_archive_formats" target="_blank" rel="noopener"><code>get_archive_formats()</code></a> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p></li><li><p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p><p>从支持的格式中移除归档格式 <em>name</em>。</p></li><li><p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p><p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。<em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。<em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册的其他格式。 如果未提供，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.unpack_archive" target="_blank" rel="noopener"><code>unpack_archive()</code></a> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。<em>在 3.7 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a> 作为 <em>filename</em> 和 <em>extract_dir</em>。</p></li><li><p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。可以提供 <em>description</em> 来描述该格式，它将被 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_unpack_formats" target="_blank" rel="noopener"><code>get_unpack_formats()</code></a> 返回。</p></li><li><p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p><p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p></li><li><p><code>shutil.get_unpack_formats</code>()</p><p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。<em>tar</em>: 未压缩的 tar 文件。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册新的格式或为任何现有格式提供你自己的解包器。</p></li></ul><p><em>3.2 新版功能.</em></p><p><em>在 3.5 版更改:</em> 添加了对 <em>xztar</em> 格式的支持。</p><p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <a href="https://docs.python.org/zh-cn/3.8/library/zipfile.html#module-zipfile" target="_blank" rel="noopener"><code>zipfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tarfile.html#module-tarfile" target="_blank" rel="noopener"><code>tarfile</code></a> 模块。</p><ul><li><p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p><p>创建一个归档文件（例如 zip 或 tar）并返回其名称。<em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “tar”, “gztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “bztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用) 或 “xztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用) 中的一个。<em>root_dir</em> 是一个目录，它将作为归档文件的根目录；例如，我们通常会在创建归档文件之前用 chdir 命令切换到 <em>root_dir</em>。<em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档文件中所有文件和目录共有的路径前缀。<em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。<em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。<em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logging.Logger" target="_blank" rel="noopener"><code>logging.Logger</code></a> 的实例。<em>verbose</em> 参数已不再使用并进入弃用状态。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。<em>在 3.8 版更改:</em> 现在对于通过 <code>format=&quot;tar&quot;</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p></li><li><p><code>shutil.get_archive_formats</code>()</p><p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_archive_format" target="_blank" rel="noopener"><code>register_archive_format()</code></a> 注册新的格式或为任何现有格式提供你自己的归档器。</p></li><li><p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>为 <em>name</em> 格式注册一个归档器。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name</em>，再加上要归档内容的 <em>base_dir</em> (其默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.make_archive" target="_blank" rel="noopener"><code>make_archive()</code></a> 传入的参数一致)。如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。<em>description</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_archive_formats" target="_blank" rel="noopener"><code>get_archive_formats()</code></a> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p></li><li><p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p><p>从支持的格式中移除归档格式 <em>name</em>。</p></li><li><p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p><p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。<em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。<em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册的其他格式。 如果未提供，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.unpack_archive" target="_blank" rel="noopener"><code>unpack_archive()</code></a> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。<em>在 3.7 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a> 作为 <em>filename</em> 和 <em>extract_dir</em>。</p></li><li><p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。可以提供 <em>description</em> 来描述该格式，它将被 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_unpack_formats" target="_blank" rel="noopener"><code>get_unpack_formats()</code></a> 返回。</p></li><li><p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p><p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p></li><li><p><code>shutil.get_unpack_formats</code>()</p><p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。<em>tar</em>: 未压缩的 tar 文件。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册新的格式或为任何现有格式提供你自己的解包器。</p></li></ul><p><em>3.2 新版功能.</em></p><p><em>在 3.5 版更改:</em> 添加了对 <em>xztar</em> 格式的支持。</p><p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <a href="https://docs.python.org/zh-cn/3.8/library/zipfile.html#module-zipfile" target="_blank" rel="noopener"><code>zipfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tarfile.html#module-tarfile" target="_blank" rel="noopener"><code>tarfile</code></a> 模块。</p><ul><li><p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p><p>创建一个归档文件（例如 zip 或 tar）并返回其名称。<em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “tar”, “gztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “bztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用) 或 “xztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用) 中的一个。<em>root_dir</em> 是一个目录，它将作为归档文件的根目录；例如，我们通常会在创建归档文件之前用 chdir 命令切换到 <em>root_dir</em>。<em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档文件中所有文件和目录共有的路径前缀。<em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。<em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。<em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logging.Logger" target="_blank" rel="noopener"><code>logging.Logger</code></a> 的实例。<em>verbose</em> 参数已不再使用并进入弃用状态。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。<em>在 3.8 版更改:</em> 现在对于通过 <code>format=&quot;tar&quot;</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p></li><li><p><code>shutil.get_archive_formats</code>()</p><p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_archive_format" target="_blank" rel="noopener"><code>register_archive_format()</code></a> 注册新的格式或为任何现有格式提供你自己的归档器。</p></li><li><p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>为 <em>name</em> 格式注册一个归档器。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name</em>，再加上要归档内容的 <em>base_dir</em> (其默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.make_archive" target="_blank" rel="noopener"><code>make_archive()</code></a> 传入的参数一致)。如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。<em>description</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_archive_formats" target="_blank" rel="noopener"><code>get_archive_formats()</code></a> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p></li><li><p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p><p>从支持的格式中移除归档格式 <em>name</em>。</p></li><li><p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p><p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。<em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。<em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册的其他格式。 如果未提供，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.unpack_archive" target="_blank" rel="noopener"><code>unpack_archive()</code></a> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。<em>在 3.7 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a> 作为 <em>filename</em> 和 <em>extract_dir</em>。</p></li><li><p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。可以提供 <em>description</em> 来描述该格式，它将被 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_unpack_formats" target="_blank" rel="noopener"><code>get_unpack_formats()</code></a> 返回。</p></li><li><p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p><p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p></li><li><p><code>shutil.get_unpack_formats</code>()</p><p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。<em>tar</em>: 未压缩的 tar 文件。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册新的格式或为任何现有格式提供你自己的解包器。</p></li></ul><h3 id="归档程序示例"><a href="#归档程序示例" class="headerlink" title="归档程序示例"></a>归档程序示例</h3><p>在这个示例中，我们创建了一个 gzip 压缩的 tar 归档文件，其中包含用户的 <code>.ssh</code> 目录下的所有文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> shutil <span class="keyword">import</span> make_archive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>archive_name = os.path.expanduser(os.path.join(<span class="string">'~'</span>, <span class="string">'myarchive'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root_dir = os.path.expanduser(os.path.join(<span class="string">'~'</span>, <span class="string">'.ssh'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>make_archive(archive_name, <span class="string">'gztar'</span>, root_dir)</span><br><span class="line"><span class="string">'/Users/tarek/myarchive.tar.gz'</span></span><br></pre></td></tr></table></figure><p>结果归档文件中包含有:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tar -tzvf /Users/tarek/myarchive.tar.gz</span><br><span class="line">drwx------ tarek/staff       <span class="number">0</span> <span class="number">2010</span><span class="number">-02</span><span class="number">-01</span> <span class="number">16</span>:<span class="number">23</span>:<span class="number">40</span> ./</span><br><span class="line">-rw-r--r-- tarek/staff     <span class="number">609</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./authorized_keys</span><br><span class="line">-rwxr-xr-x tarek/staff      <span class="number">65</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./config</span><br><span class="line">-rwx------ tarek/staff     <span class="number">668</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_dsa</span><br><span class="line">-rwxr-xr-x tarek/staff     <span class="number">609</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_dsa.pub</span><br><span class="line">-rw------- tarek/staff    <span class="number">1675</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_rsa</span><br><span class="line">-rw-r--r-- tarek/staff     <span class="number">397</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_rsa.pub</span><br><span class="line">-rw-r--r-- tarek/staff   <span class="number">37192</span> <span class="number">2010</span><span class="number">-02</span><span class="number">-06</span> <span class="number">18</span>:<span class="number">23</span>:<span class="number">10</span> ./known_hosts</span><br></pre></td></tr></table></figure><h2 id="查询输出终端的尺寸"><a href="#查询输出终端的尺寸" class="headerlink" title="查询输出终端的尺寸"></a>查询输出终端的尺寸</h2><ul><li><p><code>shutil.get_terminal_size</code>(<em>fallback=(columns</em>, <em>lines)</em>)</p><p>获取终端窗口的尺寸。</p><p>对于两个维度中的每一个，会分别检查环境变量 <code>COLUMNS</code> 和 <code>LINES</code>。 如果定义了这些变量并且其值为正整数，则将使用这些值。</p><p>如果未定义 <code>COLUMNS</code> 或 <code>LINES</code>，这是通常的情况，则连接到 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.__stdout__" target="_blank" rel="noopener"><code>sys.__stdout__</code></a> 的终端将通过发起调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.get_terminal_size" target="_blank" rel="noopener"><code>os.get_terminal_size()</code></a> 被查询。</p><p>如果由于系统不支持查询，或是由于我们未连接到某个终端而导致查询终端尺寸不成功，则会使用在 <code>fallback</code> 形参中给出的值。 <code>fallback</code> 默认为 <code>(80, 24)</code>，这是许多终端模拟器所使用的默认尺寸。</p><p>返回的值是一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.terminal_size" target="_blank" rel="noopener"><code>os.terminal_size</code></a> 类型的具名元组。</p><p>另请参阅: The Single UNIX Specification, Version 2, <a href="http://pubs.opengroup.org/onlinepubs/7908799/xbd/envvar.html#tag_002_003" target="_blank" rel="noopener">Other Environment Variables</a>.</p><p><em>3.3 新版功能.</em></p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">shutil主要API:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  shutil.copyfileobj(fsrc, fdst[, length=<span class="number">16</span>*<span class="number">1024</span>])    <span class="comment">#copy文件内容到另一个文件，可以copy指定大小的内容</span></span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>  shutil.copyfile(src,dst)   <span class="comment">#copy文件内容，是不是感觉上面的文件复制很麻烦？还需要自己手动用open函数打开文件，在这里就不需要了，事实上，copyfile调用了copyfileobj</span></span><br><span class="line"> </span><br><span class="line"><span class="number">3</span>  shutil.copymode(src,dst)   <span class="comment">#仅copy权限，不更改文件内容，组和用户。</span></span><br><span class="line"> </span><br><span class="line"><span class="number">4</span>  shutil.copystat(src,dst)    <span class="comment">#复制所有的状态信息，包括权限，组，用户，时间等</span></span><br><span class="line"> </span><br><span class="line"><span class="number">5</span>  shutil.copy(src,dst)   <span class="comment">#复制文件的内容以及权限，先copyfile后copymode</span></span><br><span class="line"> </span><br><span class="line"><span class="number">6</span>  shutil.copy2(src,dst)    <span class="comment">#复制文件的内容以及文件的所有状态信息。先copyfile后copystat</span></span><br><span class="line"> </span><br><span class="line"><span class="number">7</span>  shutil.copytree(src, dst, symlinks=<span class="literal">False</span>, ignore=<span class="literal">None</span>, copy_function=copy2,ignore_dangling_symlinks=<span class="literal">False</span>)   <span class="comment">#递归的复制文件内容及状态信息</span></span><br><span class="line"> </span><br><span class="line"><span class="number">8</span>  shutil.rmtree(path, ignore_errors=<span class="literal">False</span>, onerror=<span class="literal">None</span>)   <span class="comment">#递归地删除文件</span></span><br><span class="line"> </span><br><span class="line"><span class="number">9</span>  shutil.move(src, dst)    <span class="comment">#递归的移动文件</span></span><br><span class="line"> </span><br><span class="line"><span class="number">10</span>  make_archive(base_name, format, root_dir=<span class="literal">None</span>, base_dir=<span class="literal">None</span>, verbose=<span class="number">0</span>,dry_run=<span class="number">0</span>, owner=<span class="literal">None</span>, group=<span class="literal">None</span>, logger=<span class="literal">None</span>)  <span class="comment">#压缩打包</span></span><br><span class="line"> </span><br><span class="line">base_name：    压缩打包后的文件名或者路径名</span><br><span class="line"></span><br><span class="line">format：          压缩或者打包格式    <span class="string">"zip"</span>, <span class="string">"tar"</span>, <span class="string">"bztar"</span><span class="keyword">or</span> <span class="string">"gztar"</span></span><br><span class="line"></span><br><span class="line">root_dir :         将哪个目录或者文件打包（也就是源文件）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-shutil-高阶文件操作&quot;&gt;&lt;a href=&quot;#python-标准库-shutil-高阶文件操作&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 shutil 高阶文件操作&quot;&gt;&lt;/a&gt;python 标准库 shutil 高阶文件操作&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200219python3_sheet.png?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="shutil" scheme="https://pinghailinfeng.gitee.io/tags/shutil/"/>
    
  </entry>
  
  <entry>
    <title>using ffmpeg download yizhibo m3u8 type playback video</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/18/using-ffmpeg-download-yizhibo-m3u8-type-playback-video/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/18/using-ffmpeg-download-yizhibo-m3u8-type-playback-video/</id>
    <published>2020-02-18T15:20:04.000Z</published>
    <updated>2020-02-19T01:07:40.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-ffmpe-下载一直播-回放视频"><a href="#使用-ffmpe-下载一直播-回放视频" class="headerlink" title="使用 ffmpe 下载一直播 回放视频"></a>使用 ffmpe 下载一直播 回放视频</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200218_JohnWill.jpeg?raw=true" alt></p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>想下载一直播上的直播视频到本地,但是发现没有直接下载的途径,只能回放。</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>下播后,通过分享链接到qq,得到了在线观看回放的视频地址。F12 发现m3u8格式的链接地址。</p><p>复制该链接地址。</p><p>本地已经搭建了ffmpeg的环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PS &gt; ffmpeg</span><br><span class="line">ffmpeg version git-2019-11-20-d73f062 Copyright (c) 2000-2019 the FFmpeg developers</span><br><span class="line">  built with gcc 9.2.1 (GCC) 20191010</span><br><span class="line">  configuration: --enable-gpl --enable-version3 --enable-sdl2 --enable-fontconfig --enable-gnutls --enable-iconv --enable-libass --enable-libdav1d --enable-libbluray --enable-libfreetype --enable-libmp3lame --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-libopus --enable-libshine --enable-libsnappy</span><br><span class="line">--enable-libsoxr --enable-libtheora --enable-libtwolame --enable-libvpx --enable-libwavpack --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxml2 --enable-libzimg --enable-lzma --enable-zlib --enable-gmp --enable-libvidstab --enable-libvorbis --enable-libvo-amrwbenc --enable-libmysofa --enable-libspeex --enable-libxvid --enable-libaom --enable-libmfx --enable-ffnvcodec --enable-cuvid --enable-d3d11va --enable-nvenc --enable-nvdec --enable-dxva2 --enable-avisynth --enable-libopenmpt --enable-amf</span><br><span class="line">  libavutil      56. 36.100 / 56. 36.100</span><br><span class="line">  libavcodec     58. 62.100 / 58. 62.100</span><br><span class="line">  libavformat    58. 35.100 / 58. 35.100</span><br><span class="line">  libavdevice    58.  9.101 / 58.  9.101</span><br><span class="line">  libavfilter     7. 66.100 /  7. 66.100</span><br><span class="line">  libswscale      5.  6.100 /  5.  6.100</span><br><span class="line">  libswresample   3.  6.100 /  3.  6.100</span><br><span class="line">  libpostproc    55.  6.100 / 55.  6.100</span><br><span class="line">Hyper fast Audio and Video encoder</span><br><span class="line">usage: ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...</span><br><span class="line"></span><br><span class="line">Use -h to get full help or, even better, run 'man ffmpeg'</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>接下来使用 ffmpeg 解析上面网址中含有 m3u8的链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i "https://test.test/test.m3u8" -vcodec copy -acodec copy -absf aac_adtstoasc test.mp4</span><br></pre></td></tr></table></figure><p>经过漫长的等待,终于解析成功。视频可以直接播放。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-ffmpe-下载一直播-回放视频&quot;&gt;&lt;a href=&quot;#使用-ffmpe-下载一直播-回放视频&quot; class=&quot;headerlink&quot; title=&quot;使用 ffmpe 下载一直播 回放视频&quot;&gt;&lt;/a&gt;使用 ffmpe 下载一直播 回放视频&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200218_JohnWill.jpeg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ffmpeg" scheme="https://pinghailinfeng.gitee.io/categories/ffmpeg/"/>
    
    
      <category term="ffmpeg" scheme="https://pinghailinfeng.gitee.io/tags/ffmpeg/"/>
    
      <category term="m3u8" scheme="https://pinghailinfeng.gitee.io/tags/m3u8/"/>
    
  </entry>
  
  <entry>
    <title>python standard library dbm</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/17/python-standard-library-dbm/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/17/python-standard-library-dbm/</id>
    <published>2020-02-17T03:20:01.000Z</published>
    <updated>2020-02-17T13:30:34.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-dbm"><a href="#python-标准库-dbm" class="headerlink" title="python 标准库 dbm"></a>python 标准库 dbm</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200217_haiwang.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>要使整个人生都过得舒适、愉快，这是不可能的，因为人类必须具备一种能应付逆境的态度。</p><p>​                                                                                                                                  ——卢梭</p></blockquote><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/__init__.py" target="_blank" rel="noopener">Lib/dbm/<strong>init</strong>.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm" target="_blank" rel="noopener"><code>dbm</code></a> 是一种泛用接口，针对各种 DBM 数据库 — 包括 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a>。 如果未安装这些模块中的任何一种，则将使用 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 模块中慢速但简单的实现。 还有一个适用于 Oracle Berkeley DB 的 <a href="https://www.jcea.es/programacion/pybsddb.htm" target="_blank" rel="noopener">第三方接口</a>。</p><ul><li><p><em>exception</em> <code>dbm.error</code></p><p>一个元组，其中包含每个受支持的模块可引发的异常，另外还有一个名为 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.error" target="_blank" rel="noopener"><code>dbm.error</code></a> 的特殊异常作为第一项 — 后者最在引发 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.error" target="_blank" rel="noopener"><code>dbm.error</code></a> 时被使用。</p></li><li><p><code>dbm.whichdb</code>(<em>filename</em>)</p><p>此函数会猜测各种简单数据库模块中的哪一个是可用的 — <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 还是 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> — 应该被用来打开给定的文件。返回下列值中的一个：如果文件由于不可读或不存在而无法打开则返回 <code>None</code>；如果文件的格式无法猜测则返回空字符串 (<code>&#39;&#39;</code>)；或是包含所需模块名称的字符串，例如 <code>&#39;dbm.ndbm&#39;</code> 或 <code>&#39;dbm.gnu&#39;</code>。</p></li><li><p><code>dbm.open</code>(<em>file</em>, <em>flag=’r’</em>, <em>mode=0o666</em>)</p><p>打开数据库文件 <em>file</em> 并返回一个相应的对象。如果数据库文件已存在，则使用 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.whichdb" target="_blank" rel="noopener"><code>whichdb()</code></a> 函数来确定其类型和要使用的适当模块；如果文件不存在，则会使用上述可导入模块中的第一个。可选的 <em>flag</em> 参数可以是：’’</p><p>| 值    | 意义                                     |<br>| —– | —————————————- |<br>| <code>&#39;r&#39;</code> | 以只读方式打开现有数据库（默认）         |<br>| <code>&#39;w&#39;</code> | 以读写方式打开现有数据库                 |<br>| <code>&#39;c&#39;</code> | 以读写方式打开数据库，如果不存在则创建它 |<br>| <code>&#39;n&#39;</code> | 始终创建一个新的空数据库，以读写方式打开 |</p><p>  <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.open" target="_blank" rel="noopener"><code>open()</code></a> 所返回的对象支持与字典相同的基本功能；可以存储、获取和删除键及其对应的值，并可使用 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a> 运算符和 <code>keys()</code> 方法，以及 <code>get()</code> 和 <code>setdefault()</code>。</p></li></ul><p><em>在 3.2 版更改:</em> 现在 <code>get()</code> 和 <code>setdefault()</code> 在所有数据库模块中均可用。</p><p><em>在 3.8 版更改:</em> 从只读数据库中删除键将引发数据库模块专属的错误而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。</p><p>键和值总是被存储为字节串。 这意味着当使用字符串时它们会在被存储之前隐式地转换至默认编码格式。</p><p>这些对象也支持在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中使用，当语句结束时将自动关闭它们。</p><p><em>在 3.4 版更改:</em> 向 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.open" target="_blank" rel="noopener"><code>open()</code></a> 所返回的对象添加了上下文管理协议的原生支持。</p><p>以下示例记录了一些主机名和对应的标题，随后将数据库的内容打印出来。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dbm</span><br><span class="line"></span><br><span class="line"><span class="comment"># Open database, creating it if necessary.</span></span><br><span class="line"><span class="keyword">with</span> dbm.open(<span class="string">'cache'</span>, <span class="string">'c'</span>) <span class="keyword">as</span> db:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Record some values</span></span><br><span class="line">    db[<span class="string">b'hello'</span>] = <span class="string">b'there'</span></span><br><span class="line">    db[<span class="string">'www.python.org'</span>] = <span class="string">'Python Website'</span></span><br><span class="line">    db[<span class="string">'www.cnn.com'</span>] = <span class="string">'Cable News Network'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Note that the keys are considered bytes now.</span></span><br><span class="line">    <span class="keyword">assert</span> db[<span class="string">b'www.python.org'</span>] == <span class="string">b'Python Website'</span></span><br><span class="line">    <span class="comment"># Notice how the value is now in bytes.</span></span><br><span class="line">    <span class="keyword">assert</span> db[<span class="string">'www.cnn.com'</span>] == <span class="string">b'Cable News Network'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Often-used methods of the dict interface work too.</span></span><br><span class="line">    print(db.get(<span class="string">'python.org'</span>, <span class="string">b'not present'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Storing a non-string key or value will raise an exception (most</span></span><br><span class="line">    <span class="comment"># likely a TypeError).</span></span><br><span class="line">    db[<span class="string">'www.yahoo.com'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># db is automatically closed when leaving the with statement.</span></span><br></pre></td></tr></table></figure><blockquote><p>参见:模块 <a href="https://docs.python.org/zh-cn/3.8/library/shelve.html#module-shelve" target="_blank" rel="noopener"><code>shelve</code></a></p><p>存储非字符串数据的持久化模块。</p></blockquote><p>以下部分描述了各个单独的子模块。</p><h2 id="dbm-gnu-—-GNU-对-dbm-的重解析"><a href="#dbm-gnu-—-GNU-对-dbm-的重解析" class="headerlink" title="dbm.gnu — GNU 对 dbm 的重解析"></a><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> — GNU 对 dbm 的重解析</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/gnu.py" target="_blank" rel="noopener">Lib/dbm/gnu.py</a></p><hr><p>此模块与 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm" target="_blank" rel="noopener"><code>dbm</code></a> 模块很相似，但是改用 GNU 库 <code>gdbm</code> 来提供某些附加功能。 请注意由 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 与 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 所创建的文件格式是不兼容的。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 模块提供了对 GNU DBM 库的接口。 <code>dbm.gnu.gdbm</code> 对象的行为类似于映射（字典），区别在于其键和值总是会在存储之前被转换为字节串。 打印 <code>gdbm</code> 对象不会打印出键和值，并且 <code>items()</code> 和 <code>values()</code> 等方法也不受支持。</p><ul><li><p><em>exception</em> <code>dbm.gnu.error</code></p><p>针对 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 专属错误例如 I/O 错误引发。 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 的引发则针对一般映射错误例如指定了不正确的键。</p></li><li><p><code>dbm.gnu.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p><p>打开一个 <code>gdbm</code> 数据库并返回 <code>gdbm</code> 对象。 <em>filename</em> 参数为数据库文件名称。</p><p>可选的 <em>flag</em> 参数可以是：</p><p>| 值    | 意义                                     |<br>| —– | —————————————- |<br>| <code>&#39;r&#39;</code> | 以只读方式打开现有数据库（默认）         |<br>| <code>&#39;w&#39;</code> | 以读写方式打开现有数据库                 |<br>| <code>&#39;c&#39;</code> | 以读写方式打开数据库，如果不存在则创建它 |<br>| <code>&#39;n&#39;</code> | 始终创建一个新的空数据库，以读写方式打开 |</p><p>下列附加字符可被添加至旗标以控制数据库的打开方式：</p><p>| 值    | 意义                                         |<br>| —– | ——————————————– |<br>| <code>&#39;f&#39;</code> | 以快速模式打开数据库。写入数据库将不会同步。 |<br>| <code>&#39;s&#39;</code> | 同步模式。这将导致数据库的更改立即写入文件。 |<br>| <code>&#39;u&#39;</code> | 不要锁定数据库。                             |</p><p>不是所有旗标都可用于所有版本的 <code>gdbm</code>。 模块常量 <code>open_flags</code> 为包含受支持旗标字符的字符串。 如果指定了无效的旗标则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.gnu.error" target="_blank" rel="noopener"><code>error</code></a>。</p><p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code>。</p><p>除了与字典类似的方法，<code>gdbm</code> 对象还有以下方法：</p></li><li><p><code>gdbm.firstkey</code>()</p><p>  使用此方法和 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.gnu.gdbm.nextkey" target="_blank" rel="noopener"><code>nextkey()</code></a> 方法可以循环遍历数据库中的每个键。 遍历的顺序是按照 <code>gdbm</code> 的内部哈希值，而不会根据键的值排序。 此方法将返回起始键。</p></li><li><p><code>gdbm.nextkey</code>(<em>key</em>)</p><p>  在遍历中返回 <em>key</em> 之后的的下一个键。 以下代码将打印数据库 <code>db</code> 中的每个键，而不会在内存中创建一个包含所有键的列表:<code>k = db.firstkey() while k != None:     print(k)     k = db.nextkey(k)</code></p></li><li><p><code>gdbm.reorganize</code>()</p><p>  如果你进行了大量删除操作并且想要缩减 <code>gdbm</code> 文件所使用的空间，此例程将可重新组织数据库。 除非使用此重组功能否则 <code>gdbm</code> 对象不会缩减数据库文件大小；在其他情况下，被删除的文件空间将会保留并在添加新的 (键, 值) 对时被重用。</p></li><li><p><code>gdbm.sync</code>()</p><p>  当以快速模式打开数据库时，此方法会将任何未写入数据强制写入磁盘。</p></li><li><p><code>gdbm.close</code>()<a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.gnu.gdbm.close" target="_blank" rel="noopener">¶</a></p><p>  关闭 <code>gdbm</code> 数据库。</p></li></ul><h2 id="dbm-ndbm-—-基于-ndbm-的接口"><a href="#dbm-ndbm-—-基于-ndbm-的接口" class="headerlink" title="dbm.ndbm — 基于 ndbm 的接口"></a><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> — 基于 ndbm 的接口</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/ndbm.py" target="_blank" rel="noopener">Lib/dbm/ndbm.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 模块提供了对 Unix “(n)dbm” 库的接口。 Dbm 对象的行为类似于映射（字典），区别在于其键和值总是被存储为字节串。 打印 <code>dbm</code> 对象不会打印出键和值，并且 <code>items()</code> 和 <code>values()</code> 等方法也不受支持。</p><p>此模块可与 “经典classic” ndbm 接口或 GNU GDBM 兼容接口一同使用。 在 Unix 上，<strong>configure</strong> 脚本将尝试定位适当的头文件来简化此模块的构建。</p><ul><li><p><em>exception</em> <code>dbm.ndbm.error</code></p><p>针对 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 专属错误例如 I/O 错误引发。 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 的引发则针对一般映射错误例如指定了不正确的键。</p></li><li><p><code>dbm.ndbm.library</code></p><p>所使用的 <code>ndbm</code> 实现库的名称。</p></li><li><p><code>dbm.ndbm.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p><p>打开一个 dbm 数据库并返回 <code>ndbm</code> 对象。 <em>filename</em> 参数为数据库文件名称（不带 <code>.dir</code> 或 <code>.pag</code> 扩展名）。可选的 <em>flag</em> 参数必须是下列值之一：值意义<code>&#39;r&#39;</code>以只读方式打开现有数据库（默认）<code>&#39;w&#39;</code>以读写方式打开现有数据库<code>&#39;c&#39;</code>以读写方式打开数据库，如果不存在则创建它<code>&#39;n&#39;</code>始终创建一个新的空数据库，以读写方式打开可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code> (并将被当前的 umask 所修改)。除了与字典类似的方法，<code>ndbm</code> 对象还有以下方法：<code>ndbm.close</code>()关闭 <code>ndbm</code> 数据库。</p></li></ul><h2 id="dbm-dumb-—-便携式-DBM-实现"><a href="#dbm-dumb-—-便携式-DBM-实现" class="headerlink" title="dbm.dumb — 便携式 DBM 实现"></a><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> — 便携式 DBM 实现</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/dumb.py" target="_blank" rel="noopener">Lib/dbm/dumb.py</a></p><blockquote><p>注解:<a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 模块的目的是在更健壮的模块不可用时作为 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm" target="_blank" rel="noopener"><code>dbm</code></a> 模块的最终回退项。 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 不是为高速运行而编写的，也不像其他数据库模块一样被经常使用。</p></blockquote><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 模块提供了一个完全以 Python 编写的持久化字典类接口。 不同于 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 等其他模块，它不需要外部库。 与其他持久化映射一样，它的键和值也总是被存储为字节串。</p><p>该模块定义以下内容：</p><ul><li><p><em>exception</em> <code>dbm.dumb.error</code></p><p>针对 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 专属错误例如 I/O 错误引发。 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 的引发则针对一般映射例如指定了不正确的键。</p></li><li><p><code>dbm.dumb.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p><p>打开一个 <code>dumbdbm</code> 数据库并返回 dumbdbm 对象。 <em>filename</em> 参数为数据库文件的主名称（不带任何特定扩展名）。 创建一个 dumbdbm 数据库时将创建多个带有 <code>.dat</code> 和 <code>.dir</code> 扩展名的文件。可选的 <em>flag</em> 参数可以是：</p><p>| 值    | 意义                                     |<br>| —– | —————————————- |<br>| <code>&#39;r&#39;</code> | 以只读方式打开现有数据库（默认）         |<br>| <code>&#39;w&#39;</code> | 以读写方式打开现有数据库                 |<br>| <code>&#39;c&#39;</code> | 以读写方式打开数据库，如果不存在则创建它 |<br>| <code>&#39;n&#39;</code> | 始终创建一个新的空数据库，以读写方式打开 |</p><p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code> (并将  被当前的 umask 所修改)。</p><p><em>在 3.5 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.dumb.open" target="_blank" rel="noopener"><code>open()</code></a> 在 flag 值为 <code>&#39;n&#39;</code> 时将总是创建一个新的数据库。</p><p><em>在 3.8 版更改:</em> 附带 <code>&#39;r&#39;</code> 旗标打开的数据库现在将是只读的。 附带 <code>&#39;r&#39;</code> 和 <code>&#39;w&#39;</code> 旗标的打开操作不会再创建数据库。</p><p>除了 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableMapping" target="_blank" rel="noopener"><code>collections.abc.MutableMapping</code></a> 类所提供的方法，<code>dumbdbm</code> 对象还提供了以下方法：</p></li><li><p><code>dumbdbm.sync</code>()</p><p>  同步磁盘上的目录和数据文件。 此方法会由 <code>Shelve.sync()</code> 方法来调用。</p></li><li><p><code>dumbdbm.close</code>()</p><p>  关闭 <code>dumbdbm</code> 数据库。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-dbm&quot;&gt;&lt;a href=&quot;#python-标准库-dbm&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 dbm&quot;&gt;&lt;/a&gt;python 标准库 dbm&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200217_haiwang.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="dbm" scheme="https://pinghailinfeng.gitee.io/tags/dbm/"/>
    
  </entry>
  
  <entry>
    <title>python standard library marshal</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/16/python-standard-library-marshal/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/16/python-standard-library-marshal/</id>
    <published>2020-02-16T01:24:24.000Z</published>
    <updated>2020-02-17T03:27:23.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="marshal-—-内部-Python-对象序列化"><a href="#marshal-—-内部-Python-对象序列化" class="headerlink" title="marshal — 内部 Python 对象序列化"></a><code>marshal</code> — 内部 Python 对象序列化</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200216_pijitailai.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词：</p><p>否极泰来( pi ji tai lai):</p><p> 否，读如痞(pǐ)又作“否极终泰”、“否去泰来”。天地相交，因而安泰。天与地不相交，叫做否。在这种情况下，君子应该收敛自己的才华，以避免小人陷害；不可追求荣誉富贵，以避免小人嫉妒。闭塞到了极点，则转向通泰。人们将这些观点概括为否极泰来或否极终泰。原指事物发展到一定程度，就要转化到它的对立面。后常以此形容情况从坏变好。</p><p>【出典】：</p><p>  《易·泰》：“天地交，泰。”《易·否》：“天地不交，否；君子以俭德辟难，不可荣以禄。”《易·杂卦》：“否泰反其类也。”</p><p>【例句】：</p><p>  《吴越春秋·句践入臣外传》：“时过于期，否终则泰。” 唐·白居易《遣怀诗》：“乐往必悲生，泰来犹否极。” 唐·韦庄《湘中作》：“否去泰来终可待。”</p><p>【英文】</p><p> after a storm comes a calm </p><p>【反义词】</p><p>乐极生悲  after joy comes sadness </p></blockquote><p>此模块包含一此能以二进制格式来读写 Python 值的函数。 这种格式是 Python 专属的，但是独立于特定的机器架构（即你可以在一台 PC 上写入某个 Python 值，将文件传到一台 Sun 上并在那里读取它）。 这种格式的细节有意不带文档说明；它可能在不同 Python 版本中发生改变（但这种情况极少发生）。 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#id2" target="_blank" rel="noopener">1</a></p><p>这不是一个通用的“持久化”模块。 对于通用的持久化以及通过 RPC 调用传递 Python 对象，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/shelve.html#module-shelve" target="_blank" rel="noopener"><code>shelve</code></a> 等模块。 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#module-marshal" target="_blank" rel="noopener"><code>marshal</code></a> 模块主要是为了支持读写 <code>.pyc</code> 文件形式“伪编译”代码的 Python 模块。 因此，Python 维护者保留在必要时以不向下兼容的方式修改 marshal 格式的权利。 如果你要序列化和反序列化 Python 对象，请改用 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块 – 其执行效率相当，版本独立性有保证，并且 pickle 还支持比 marshal 更多样的对象类型。</p><p>警告<br><a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#module-marshal" target="_blank" rel="noopener"><code>marshal</code></a> 模块对于错误或恶意构建的数据来说是不安全的。 永远不要 unmarshal 来自不受信任的或未经验证的来源的数据。</p><p>不是所有 Python 对象类型都受支持；一般来说，此模块只能写入和读取不依赖于特定 Python 调用的对象。 下列类型是受支持的：布尔值、整数、浮点数、复数、字符串、字节串、字节数组、元组、列表、集合、冻结集合、字典和代码对象，需要了解的一点是元组、列表、集合、冻结集合和字典只在其所包含的值也是这些值时才受支持。 单例对象 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#Ellipsis" target="_blank" rel="noopener"><code>Ellipsis</code></a> and <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 也可以被 marshal 和 unmarshal。 对于 <em>version</em> 低于 3 的格式，递归列表、集合和字典无法被写入（见下文）。</p><p>有些函数可以读/写文件，还有些函数可以操作字节类对象。</p><p>这个模块定义了以下函数：</p><ul><li><p><code>marshal.dump</code>(<em>value</em>, <em>file</em>[, <em>version</em>])</p><p>向打开的文件写入值。 值必须为受支持的类型。 文件必须为可写的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a>。如果值具有（或所包含的对象具有）不受支持的类型，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> — 但是将向文件写入垃圾数据。 对象也将不能正确地通过 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#marshal.load" target="_blank" rel="noopener"><code>load()</code></a> 重新读取。<em>version</em> 参数指明 <code>dump</code> 应当使用的数据格式（见下文）。</p></li><li><p><code>marshal.load</code>(<em>file</em>)</p><p>从打开的文件读取一个值并返回。 如果读不到有效的值（例如由于数据为不同 Python 版本的不兼容 marshal 格式），则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EOFError" target="_blank" rel="noopener"><code>EOFError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 文件必须为可读的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a>。注解 如果通过 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#marshal.dump" target="_blank" rel="noopener"><code>dump()</code></a> marshal 了一个包含不受支持类型的对象，<a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#marshal.load" target="_blank" rel="noopener"><code>load()</code></a> 将为不可 marshal 的类型替换 <code>None</code>。</p></li><li><p><code>marshal.dumps</code>(<em>value</em>[, <em>version</em>])</p><p>返回将通过 <code>dump(value, file)</code> 被写入一个文件的字节串对象。 值必须属于受支持的类型。 如果值属于（或包含的对象属于）不受支持的类型则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。<em>version</em> 参数指明 <code>dumps</code> 应当使用的数据类型（见下文）。</p></li><li><p><code>marshal.loads</code>(<em>bytes</em>)</p><p>将 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 转换为一个值。 如果找不到有效的值，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EOFError" target="_blank" rel="noopener"><code>EOFError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 输入的额外字节串会被忽略。</p></li></ul><p>此外，还定义了以下常量：</p><ul><li><p><code>marshal.version</code></p><p>指明模块所使用的格式。 第 0 版为历史格式，第 1 版为共享固化的字符串，第 2 版对浮点数使用二进制格式。 第 3 版添加了对于对象实例化和递归的支持。 目前使用的为第 4 版。</p></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> marshal</span><br><span class="line">data1 = [<span class="string">'abc'</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="string">'jb51'</span>]  <span class="comment">#几个测试数据</span></span><br><span class="line">data2 = &#123;<span class="number">1</span>:<span class="string">'aaa'</span>,<span class="string">"b"</span>:<span class="string">'dad'</span>&#125;</span><br><span class="line">data3 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">output_file = open(<span class="string">"a.txt"</span>,<span class="string">'wb'</span>)<span class="comment">#把这些数据序列化到文件中，注：文件必须以二进制模式打开</span></span><br><span class="line">marshal.dump(data1,output_file)</span><br><span class="line">marshal.dump(data2,output_file)</span><br><span class="line">marshal.dump(data3,output_file)</span><br><span class="line">output_file.close()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">input_file = open(<span class="string">'a.txt'</span>,<span class="string">'rb'</span>)<span class="comment">#从文件中读取序列化的数据</span></span><br><span class="line"><span class="comment">#data1 = []</span></span><br><span class="line">data1 = marshal.load(input_file)</span><br><span class="line">data2 = marshal.load(input_file)</span><br><span class="line">data3 = marshal.load(input_file)</span><br><span class="line"><span class="keyword">print</span> data1<span class="comment">#给同志们打印出结果看看</span></span><br><span class="line"><span class="keyword">print</span> data2</span><br><span class="line"><span class="keyword">print</span> data3</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">outstring = marshal.dumps(data1)<span class="comment">#marshal.dumps()返回是一个字节串，该字节串用于写入文件</span></span><br><span class="line">open(<span class="string">'out.txt'</span>,<span class="string">'wb'</span>).write(outstring)</span><br><span class="line"> </span><br><span class="line">file_data = open(<span class="string">'out.txt'</span>,<span class="string">'rb'</span>).read()</span><br><span class="line">real_data = marshal.loads(file_data)</span><br><span class="line">print(real_data)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;marshal-—-内部-Python-对象序列化&quot;&gt;&lt;a href=&quot;#marshal-—-内部-Python-对象序列化&quot; class=&quot;headerlink&quot; title=&quot;marshal — 内部 Python 对象序列化&quot;&gt;&lt;/a&gt;&lt;code&gt;marshal&lt;/code&gt; — 内部 Python 对象序列化&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200216_pijitailai.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python standard library os.path</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/15/python-standard-library-os-path/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/15/python-standard-library-os-path/</id>
    <published>2020-02-14T23:50:49.000Z</published>
    <updated>2020-02-17T13:18:03.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-os-path"><a href="#python-标准库-os-path" class="headerlink" title="python 标准库 os.path"></a>python 标准库 os.path</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200215_nixingzhe.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词</p><p> retrograde  [ˈrɛtrəɡreɪd] </p><p>v   directed or moving backwards. </p><p>n retrograder 逆行者</p><ol><li><p>倒行；不按正常方向行进。《孟子·滕文公下》：“当 尧 之时，水<a href="https://cidian.911cha.com/MjA1MXc=.html" target="_blank" rel="noopener">逆行</a>，氾滥於中国。”《史记·孝景本纪》：“彗星出东北。秋， 衡山 雨雹，大者五寸，深者二尺。荧惑<a href="https://cidian.911cha.com/MjA1MXc=.html" target="_blank" rel="noopener">逆行</a>，守北辰。”《后汉书·杨震传》：“ 丰 等闻，惶怖，会太史言星变<a href="https://cidian.911cha.com/MjA1MXc=.html" target="_blank" rel="noopener">逆行</a>，遂共譖 震 。”</p></li><li><p>指逆流而行。 </p></li></ol></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/posixpath.py" target="_blank" rel="noopener">Lib/posixpath.py</a> （用于 POSIX）和 <a href="https://github.com/python/cpython/tree/3.8/Lib/ntpath.py" target="_blank" rel="noopener">Lib/ntpath.py</a> （用于 Windows NT）</p><hr><p>该模块在路径名上实现了一些有用的功能：如需读取或写入文件，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> ；有关访问文件系统的信息，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块。路径参数可以字符串或字节形式传递。我们鼓励应用程序将文件名表示为（Unicode）字符串。不幸的是，某些文件名在Unix上可能无法用字符串表示，因此在Unix上平台上需要支持任意文件名的应用程序，应使用字节对象来表示路径名。反之亦然，在Windows平台上仅使用字节对象，不能表示的所有文件名（以标准 <code>mbcs</code> 编码），因此Windows应用程序应使用字符串对象来访问所有文件。</p><p>与unix shell不同，Python不执行任何 <em>自动</em> 路径扩展。当应用程序需要类似shell的路径扩展时，可以显式调用诸如 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.expanduser" target="_blank" rel="noopener"><code>expanduser()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.expandvars" target="_blank" rel="noopener"><code>expandvars()</code></a> 之类的函数。 （另请参见 <a href="https://docs.python.org/zh-cn/3.8/library/glob.html#module-glob" target="_blank" rel="noopener"><code>glob</code></a> 模块。）</p><blockquote><p>参见 <a href="https://docs.python.org/zh-cn/3.8/library/pathlib.html#module-pathlib" target="_blank" rel="noopener"><code>pathlib</code></a> 模块提供高级路径对象。</p></blockquote><blockquote><p>所有这些函数都仅接受字节或字符串对象作为其参数。如果返回路径或文件名，则结果是相同类型的对象。</p></blockquote><blockquote><p>由于不同的操作系统具有不同的路径名称约定，因此标准库中有此模块的几个版本。<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 模块始终是适合 Python 运行的操作系统的路径模块，因此可用于本地路径。但是，如果操作的路径 <em>总是</em> 以一种不同的格式显示，那么也可以分别导入和使用各个模块。它们都具有相同的接口：</p><ul><li><code>posixpath</code> 用于Unix 样式的路径</li><li><code>ntpath</code> 用于 Windows 路径</li></ul></blockquote><p><em>在 3.8 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>exists()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.lexists" target="_blank" rel="noopener"><code>lexists()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isdir" target="_blank" rel="noopener"><code>isdir()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isfile" target="_blank" rel="noopener"><code>isfile()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>islink()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.ismount" target="_blank" rel="noopener"><code>ismount()</code></a> 现在遇到系统层面上不可表示的字符或字节的路径时，会返回 <code>False</code>，而不是抛出异常。</p><ul><li><p><code>os.path.abspath</code>(<em>path</em>)</p><p>返回路径 <em>path</em> 的绝对路径（标准化的）。在大多数平台上，这等同于用 <code>normpath(join(os.getcwd(), path))</code> 的方式调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.normpath" target="_blank" rel="noopener"><code>normpath()</code></a> 函数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.basename</code>(<em>path</em>)</p><p>返回路径 <em>path</em> 的基本名称。这是将 <em>path</em> 传入函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.split" target="_blank" rel="noopener"><code>split()</code></a> 之后，返回的一对值中的第二个元素。请注意，此函数的结果与Unix <strong>basename</strong> 程序不同。<strong>basename</strong> 在 <code>&#39;/foo/bar/&#39;</code> 上返回 <code>&#39;bar&#39;</code>，而 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.basename" target="_blank" rel="noopener"><code>basename()</code></a> 函数返回一个空字符串 (<code>&#39;&#39;</code>)。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.commonpath</code>(<em>paths</em>)</p><p>接受包含多个路径的序列 <em>paths</em>，返回 <em>paths</em> 的最长公共子路径。如果 <em>paths</em> 同时包含绝对路径和相对路径，或 <em>paths</em> 在不同的驱动器上，或 <em>paths</em> 为空，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。与 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.commonprefix" target="_blank" rel="noopener"><code>commonprefix()</code></a> 不同，本方法返回有效路径。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>3.5 新版功能.**在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 序列。</p></li><li><p><code>os.path.commonprefix</code>(<em>list</em>)</p><p>接受包含多个路径的 <em>列表</em>，返回所有路径的最长公共前缀（逐字符比较）。如果 <em>列表</em> 为空，则返回空字符串 (<code>&#39;&#39;</code>)。</p><p>此函数是逐字符比较，因此可能返回无效路径。要获取有效路径，参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.commonpath" target="_blank" rel="noopener"><code>commonpath()</code></a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.commonprefix([<span class="string">'/usr/lib'</span>, <span class="string">'/usr/local/lib'</span>])</span><br><span class="line"><span class="string">'/usr/l'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.commonpath([<span class="string">'/usr/lib'</span>, <span class="string">'/usr/local/lib'</span>])</span><br><span class="line"><span class="string">'/usr'</span></span><br></pre></td></tr></table></figure><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.dirname</code>(<em>path</em>)</p><p>返回路径 <em>path</em> 的目录名称。这是将 <em>path</em> 传入函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.split" target="_blank" rel="noopener"><code>split()</code></a> 之后，返回的一对值中的第一个元素。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.exists</code>(<em>path</em>)</p><p>如果 <em>path</em> 指向一个已存在的路径或已打开的文件描述符，返回 <code>True</code>。对于失效的符号链接，返回 <code>False</code>。在某些平台上，如果使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 查询到目标文件没有执行权限，即使 <em>path</em> 确实存在，本函数也可能返回 <code>False</code>。<em>在 3.3 版更改:</em> <em>path</em> 现在可以是一个整数：如果该整数是一个已打开的文件描述符，返回 <code>True</code>，否则返回 <code>False</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.lexists</code>(<em>path</em>)</p><p>如果 <em>path</em> 指向一个已存在的路径，返回 <code>True</code>。对于失效的符号链接，也返回 <code>True</code>。在缺失 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>os.lstat()</code></a> 的平台上等同于 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>exists()</code></a>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.expanduser</code>(<em>path</em>)</p><p>在 Unix 和 Windows 上，将参数中开头部分的 <code>~</code> 或 <code>~user</code> 替换为当前 <em>用户</em> 的家目录并返回。在 Unix 上，开头的 <code>~</code> 会被环境变量 <code>HOME</code> 代替，如果变量未设置，则通过内置模块 <a href="https://docs.python.org/zh-cn/3.8/library/pwd.html#module-pwd" target="_blank" rel="noopener"><code>pwd</code></a> 在 password 目录中查找当前用户的主目录。以 <code>~user</code> 开头则直接在 password 目录中查找。在 Windows 上，如果设置了 <code>USERPROFILE</code>，就使用这个变量，否则会将 <code>HOMEPATH</code> 和 <code>HOMEDRIVE</code> 结合在一起使用。以 <code>~user</code> 开头则将上述方法生成路径的最后一截目录替换成 user。如果展开路径失败，或者路径不是以波浪号开头，则路径将保持不变。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>在 3.8 版更改:</em> Windows 不再使用 <code>HOME</code>。</p></li><li><p><code>os.path.expandvars</code>(<em>path</em>)</p><p>输入带有环境变量的路径作为参数，返回展开变量以后的路径。<code>$name</code> 或 <code>${name}</code> 形式的子字符串被环境变量 <em>name</em> 的值替换。格式错误的变量名称和对不存在变量的引用保持不变。在 Windows 上，除了 <code>$name</code> 和 <code>${name}</code> 外，还可以展开 <code>%name%</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.getatime</code>(<em>path</em>)</p><p>返回 <em>path</em> 的最后访问时间。返回值是一个浮点数，为纪元秒数（参见 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块）。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p></li><li><p><code>os.path.getmtime</code>(<em>path</em>)</p><p>返回 <em>path</em> 的最后修改时间。返回值是一个浮点数，为纪元秒数（参见 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块）。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.getctime</code>(<em>path</em>)</p><p>返回 <em>path</em> 在系统中的 ctime，在有些系统（比如 Unix）上，它是元数据的最后修改时间，其他系统（比如 Windows）上，它是 <em>path</em> 的创建时间。返回值是一个数，为纪元秒数（参见 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块）。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.getsize</code>(<em>path</em>)</p><p>返回 <em>path</em> 的大小，以字节为单位。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.isabs</code>(<em>path</em>)</p><p>如果 <em>path</em> 是一个绝对路径，则返回 <code>True</code>。在 Unix 上，它就是以斜杠开头，而在 Windows 上，它可以是去掉驱动器号后以斜杠（或反斜杠）开头。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.isfile</code>(<em>path</em>)</p><p>如果 <em>path</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>现有的</code></a> 常规文件，则返回 <code>True</code>。本方法会跟踪符号链接，因此，对于同一路径，<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>islink()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isfile" target="_blank" rel="noopener"><code>isfile()</code></a> 都可能为 <code>True</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.isdir</code>(<em>path</em>)</p><p>如果 <em>path</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>现有的</code></a> 目录，则返回 <code>True</code>。本方法会跟踪符号链接，因此，对于同一路径，<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>islink()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isdir" target="_blank" rel="noopener"><code>isdir()</code></a> 都可能为 <code>True</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.islink</code>(<em>path</em>)</p><p>如果 <em>path</em> 指向的 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>现有</code></a> 目录条目是一个符号链接，则返回 <code>True</code>。如果 Python 运行时不支持符号链接，则总是返回 <code>False</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.ismount</code>(<em>path</em>)</p><p>如果路径 <em>path</em> 是 <em>挂载点</em> （文件系统中挂载其他文件系统的点），则返回 <code>True</code>。在 POSIX 上，该函数检查 <em>path</em> 的父目录 <code>*path*/..</code> 是否在与 <em>path</em> 不同的设备上，或者 <code>*path*/..</code> 和 <em>path</em> 是否指向同一设备上的同一 inode（这一检测挂载点的方法适用于所有 Unix 和 POSIX 变体）。本方法不能可靠地检测同一文件系统上的绑定挂载 (bind mount)。在 Windows 上，盘符和共享 UNC 始终是挂载点，对于任何其他路径，将调用 <code>GetVolumePathName</code> 来查看它是否与输入的路径不同。<em>3.4 新版功能:</em> 支持在 Windows 上检测非根挂载点。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.join</code>(<em>path</em>, *<em>paths</em>)</p><p>合理地拼接一个或多个路径部分。返回值是 <em>path</em> 和 *<em>paths</em> 所有值的连接，每个非空部分后面都紧跟一个目录分隔符 (<code>os.sep</code>)，除了最后一部分。这意味着如果最后一部分为空，则结果将以分隔符结尾。如果参数中某个部分是绝对路径，则绝对路径前的路径都将被丢弃，并从绝对路径部分开始连接。在 Windows 上，遇到绝对路径部分（例如 <code>r&#39;\foo&#39;</code>）时，不会重置盘符。如果某部分路径包含盘符，则会丢弃所有先前的部分，并重置盘符。请注意，由于每个驱动器都有一个“当前目录”，所以 <code>os.path.join(&quot;c:&quot;, &quot;foo&quot;)</code> 表示驱动器 <code>C:</code> 上当前目录的相对路径 (<code>c:foo</code>)，而不是 <code>c:\foo</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 用于 <em>path</em> 和 <em>paths</em> 。</p></li><li><p><code>os.path.normcase</code>(<em>path</em>)</p><p>规范路径的大小写。在 Windows 上，将路径中的所有字符都转换为小写，并将正斜杠转换为反斜杠。在其他操作系统上返回原路径。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.normpath</code>(<em>path</em>)</p><p>通过折叠多余的分隔符和对上级目录的引用来标准化路径名，所以 <code>A//B</code>、<code>A/B/</code>、<code>A/./B</code> 和 <code>A/foo/../B</code> 都会转换成 <code>A/B</code>。这个字符串操作可能会改变带有符号链接的路径的含义。在 Windows 上，本方法将正斜杠转换为反斜杠。要规范大小写，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.normcase" target="_blank" rel="noopener"><code>normcase()</code></a>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.realpath</code>(<em>path</em>)</p><p>返回指定文件的规范路径，消除路径中存在的任何符号链接（如果操作系统支持）。注解 当发生符号链接循环时，返回的路径将是该循环的某个组成部分，但不能保证是哪个部分。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>在 3.8 版更改:</em> 在 Windows 上现在可以正确解析符号链接和交接点 (junction point)。</p></li><li><p><code>os.path.relpath</code>(<em>path</em>, <em>start=os.curdir</em>)</p><p>返回从当前目录或 <em>start</em> 目录（可选）到达 <em>path</em> 之间要经过的相对路径。这仅仅是对路径的计算，不会访问文件系统来确认 <em>path</em> 或 <em>start</em> 的存在性或属性。<em>start</em> 默认为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.samefile</code>(<em>path1</em>, <em>path2</em>)</p><p>如果两个路径都指向相同的文件或目录，则返回 <code>True</code>。这由设备号和 inode 号确定，在任一路径上调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 失败则抛出异常。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加了 Windows 支持。<em>在 3.4 版更改:</em> Windows现在使用与其他所有平台相同的实现。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.sameopenfile</code>(<em>fp1</em>, <em>fp2</em>)</p><p>如果文件描述符 <em>fp1</em> 和 <em>fp2</em> 指向相同文件，则返回 <code>True</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加了 Windows 支持。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.samestat</code>(<em>stat1</em>, <em>stat2</em>)</p><p>如果 stat 元组 <em>stat1</em> 和 <em>stat2</em> 指向相同文件，则返回 <code>True</code>。这些 stat 元组可能是由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fstat" target="_blank" rel="noopener"><code>os.fstat()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>os.lstat()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 返回的。本函数实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.samefile" target="_blank" rel="noopener"><code>samefile()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.sameopenfile" target="_blank" rel="noopener"><code>sameopenfile()</code></a> 底层所使用的比较过程。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.4 版更改:</em> 添加了 Windows 支持。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.split</code>(<em>path</em>)</p><p>将路径 <em>path</em> 拆分为一对，即 <code>(head, tail)</code>，其中，<em>tail</em> 是路径的最后一部分，而 <em>head</em> 里是除最后部分外的所有内容。<em>tail</em> 部分不会包含斜杠，如果 <em>path</em> 以斜杠结尾，则 <em>tail</em> 将为空。如果 <em>path</em> 中没有斜杠，<em>head</em> 将为空。如果 <em>path</em> 为空，则 <em>head</em> 和 <em>tail</em> 均为空。<em>head</em> 末尾的斜杠会被去掉，除非它是根目录（即它仅包含一个或多个斜杠）。在所有情况下，<code>join(head, tail)</code> 指向的位置都与 <em>path</em> 相同（但字符串可能不同）。另请参见函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.dirname" target="_blank" rel="noopener"><code>dirname()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.basename" target="_blank" rel="noopener"><code>basename()</code></a>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.splitdrive</code>(<em>path</em>)</p><p>将路径 <em>path</em> 拆分为一对，即 <code>(drive, tail)</code>，其中 <em>drive</em> 是挂载点或空字符串。在没有驱动器概念的系统上，<em>drive</em> 将始终为空字符串。在所有情况下，<code>drive + tail</code> 都与 <em>path</em> 相同。在 Windows 上，本方法将路径拆分为驱动器/UNC 根节点和相对路径。如果路径 path 包含盘符，则 drive 将包含冒号及冒号前面的所有内容。例如 <code>splitdrive(&quot;c:/dir&quot;)</code> 返回 <code>(&quot;c:&quot;, &quot;/dir&quot;)</code>。如果 path 是一个 UNC 路径，则 drive 将包含主机名和共享点，但不包括第四个分隔符。例如 <code>splitdrive(&quot;//host/computer/dir&quot;)</code> 返回 <code>(&quot;//host/computer&quot;, &quot;/dir&quot;)</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.splitext</code>(<em>path</em>)</p><p>将路径 <em>path</em> 拆分为一对，即 <code>(root, ext)</code>，使 <code>root + ext == path</code>，其中 <em>ext</em> 为空或以英文句点开头，且最多包含一个句点。路径前的句点将被忽略，例如 <code>splitext(&#39;.cshrc&#39;)</code> 返回 <code>(&#39;.cshrc&#39;, &#39;&#39;)</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.supports_unicode_filenames</code></p><p>如果（在文件系统限制下）允许将任意 Unicode 字符串用作文件名，则为 <code>True</code>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-os-path&quot;&gt;&lt;a href=&quot;#python-标准库-os-path&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 os.path&quot;&gt;&lt;/a&gt;python 标准库 os.path&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200215_nixingzhe.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="os.path" scheme="https://pinghailinfeng.gitee.io/tags/os-path/"/>
    
  </entry>
  
  <entry>
    <title>python standard library linecache</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/14/python-standard-library-linecache/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/14/python-standard-library-linecache/</id>
    <published>2020-02-14T12:20:03.000Z</published>
    <updated>2020-02-17T03:27:23.923Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200214_valentines.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>情人节快乐，愿有情人终成眷属!</p></blockquote><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/linecache.py" target="_blank" rel="noopener">Lib/linecache.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#module-linecache" target="_blank" rel="noopener"><code>linecache</code></a> 模块允许从一个 Python 源文件中获取任意的行，并会尝试使用缓存进行内部优化，常应用于从单个文件读取多行的场合。 此模块被 <a href="https://docs.python.org/zh-cn/3.8/library/traceback.html#module-traceback" target="_blank" rel="noopener"><code>traceback</code></a> 模块用来提取源码行以便包含在格式化的回溯中。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/tokenize.html#tokenize.open" target="_blank" rel="noopener"><code>tokenize.open()</code></a> 函数被用于打开文件。 此函数使用 <a href="https://docs.python.org/zh-cn/3.8/library/tokenize.html#tokenize.detect_encoding" target="_blank" rel="noopener"><code>tokenize.detect_encoding()</code></a> 来获取文件的编码格式；如果未指明编码格式，则默认编码为 UTF-8。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#module-linecache" target="_blank" rel="noopener"><code>linecache</code></a> 模块定义了下列函数：</p><ul><li><p><code>linecache.getline</code>(<em>filename</em>, <em>lineno</em>, <em>module_globals=None</em>)</p><p>从名为 <em>filename</em> 的文件中获取 <em>lineno</em> 行，此函数绝不会引发异常 — 出现错误时它将返回 <code>&#39;&#39;</code> (所有找到的行都将包含换行符作为结束)。如果找不到名为 <em>filename</em> 的文件，此函数会先在 <em>module_globals</em> 中检查 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a> <code>__loader__</code>。 如果存在这样的加载器并且它定义了 <code>get_source</code> 方法，则由该方法来确定源行 (如果 <code>get_source()</code> 返回 <code>None</code>，则该函数返回 <code>&#39;&#39;</code>)。 最后，如果 <em>filename</em> 是一个相对路径文件名，则它会在模块搜索路径 <code>sys.path</code> 中按条目的相对位置进行查找。</p></li><li><p><code>linecache.clearcache</code>()</p><p>清空缓存。 如果你不再需要之前使用 <a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#linecache.getline" target="_blank" rel="noopener"><code>getline()</code></a> 从文件读取的行即可使用此函数。</p></li><li><p><code>linecache.checkcache</code>(<em>filename=None</em>)</p><p>检查缓存有效性。 如果缓存中的文件在磁盘上发生了改变，而你需要更新后的版本即可使用此函数。 如果省略了 <em>filename</em>，它会检查缓存中的所有条目。</p></li><li><p><code>linecache.lazycache</code>(<em>filename</em>, <em>module_globals</em>)</p><p>捕获有关某个非基于文件的模块的足够细节信息，以允许稍后再通过 <a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#linecache.getline" target="_blank" rel="noopener"><code>getline()</code></a> 来获取其中的行，即使当稍后调用时 <em>module_globals</em> 为 <code>None</code>。 这可以避免在实际需要读取行之前执行 I/O，也不必始终保持模块全局变量。<em>3.5 新版功能.</em></p></li></ul><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> linecache</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>linecache.getline(linecache.__file__, <span class="number">8</span>)</span><br><span class="line"><span class="string">'import sys\n'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> linecache</span><br><span class="line"><span class="comment">## 获取指定前四条数据</span></span><br><span class="line">a = linecache.getlines(<span class="string">'aa.txt'</span>)[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">## 获取第四条数据</span></span><br><span class="line">a = linecache.getline(<span class="string">'aa.txt'</span>,<span class="number">4</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200214_valentines.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="linecache" scheme="https://pinghailinfeng.gitee.io/tags/linecache/"/>
    
  </entry>
  
  <entry>
    <title>python standard library tempfile</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/13/python-standard-library-tempfile/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/13/python-standard-library-tempfile/</id>
    <published>2020-02-13T09:17:49.000Z</published>
    <updated>2020-02-17T03:27:23.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-tempfile"><a href="#python-标准库-tempfile" class="headerlink" title="python 标准库 tempfile"></a>python 标准库 tempfile</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200213_car.jpeg?raw=true" alt></p><a id="more"></a><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/tempfile.py" target="_blank" rel="noopener">Lib/tempfile.py</a></p><hr><p>该模块用于创建临时文件和目录，它可以跨平台使用。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.NamedTemporaryFile" target="_blank" rel="noopener"><code>NamedTemporaryFile</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryDirectory" target="_blank" rel="noopener"><code>TemporaryDirectory</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.SpooledTemporaryFile" target="_blank" rel="noopener"><code>SpooledTemporaryFile</code></a> 是带有自动清理功能的高级接口，可用作上下文管理器。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 是低级函数，使用完毕需手动清理。</p><p>所有由用户调用的函数和构造函数都带有参数，这些参数可以设置临时文件和临时目录的路径和名称。该模块生成的文件名包括一串随机字符，在公共的临时目录中，这些字符可以让创建文件更加安全。为了保持向后兼容性，参数的顺序有些奇怪。所以为了代码清晰，建议使用关键字参数。</p><p>这个模块定义了以下内容供用户调用：</p><ul><li><p><code>tempfile.TemporaryFile</code>(<em>mode=’w+b’</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>**, </em>errors=None*)</p><p>返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-like-object" target="_blank" rel="noopener">file-like object</a> （文件类对象）作为临时存储区域。创建该文件使用了与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 相同的安全规则。它将在关闭后立即销毁（包括垃圾回收机制关闭该对象时）。在 Unix 下，该文件在目录中的条目根本不创建，或者创建文件后立即就被删除了，其他平台不支持此功能。您的代码不应依赖使用此功能创建的临时文件名称，因为它在文件系统中的名称可能是可见的，也可能是不可见的。</p><p>生成的对象可以用作上下文管理器（参见 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile-examples" target="_blank" rel="noopener">示例</a>）。完成上下文或销毁临时文件对象后，临时文件将从文件系统中删除。</p><p><em>mode</em> 参数默认值为 <code>&#39;w+b&#39;</code>，所以创建的文件不用关闭，就可以读取或写入。因为用的是二进制模式，所以无论存的是什么数据，它在所有平台上都表现一致。<em>buffering</em>、<em>encoding</em>、<em>errors</em> 和 <em>newline</em> 的含义与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 中的相同。</p><p>参数 <em>dir</em>、<em>prefix</em> 和 <em>suffix</em> 的含义和默认值都与它们在 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 中的相同。</p><p>在 POSIX 平台上，它返回的对象是真实的文件对象。在其他平台上，它是一个文件类对象 (file-like object)，它的 <code>file</code> 属性是底层的真实文件对象。</p><p>如果可用，则使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_TMPFILE" target="_blank" rel="noopener"><code>os.O_TMPFILE</code></a> 标志（仅限于 Linux，需要 3.11 及更高版本的内核）。</p><p>引发一个 <code>tempfile.mkstemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>在 3.5 版更改:</em> 如果可用，现在用的是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_TMPFILE" target="_blank" rel="noopener"><code>os.O_TMPFILE</code></a> 标志。</p><p><em>在 3.8 版更改:</em> 添加了 <em>errors</em> 参数。</p></li><li><p><code>tempfile.NamedTemporaryFile</code>(<em>mode=’w+b’</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>delete=True</em>, <em>**, </em>errors=None*) </p><p>此函数执行的操作与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 完全相同，但确保了该临时文件在文件系统中具有可见的名称（在 Unix 上表现为目录条目不取消链接）。从返回的文件类对象的 <code>name</code> 属性中可以检索到文件名。在临时文件仍打开时，是否允许用文件名第二次打开文件，在各个平台上是不同的（在 Unix 上可以，但在 Windows NT 或更高版本上不行）。如果 <em>delete</em> 为 true（默认值），则文件会在关闭后立即被删除。该函数返回的对象始终是文件类对象 (file-like object)，它的 <code>file</code> 属性是底层的真实文件对象。文件类对象可以像普通文件一样在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中使用。</p><p>引发一个 <code>tempfile.mkstemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>在 3.8 版更改:</em> 添加了 <em>errors</em> 参数。</p></li><li><p><code>tempfile.SpooledTemporaryFile</code>(<em>max_size=0</em>, <em>mode=’w+b’</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>**, </em>errors=None*) </p><p>此函数执行的操作与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 完全相同，但会将数据缓存在内存中，直到文件大小超过 <em>max_size</em>，或调用文件的 <code>fileno()</code> 方法为止，此时数据会被写入磁盘，并且写入操作与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 相同。</p><p>此函数生成的文件对象有一个额外的方法——<code>rollover()</code>，可以忽略文件大小，让文件立即写入磁盘。</p><p>返回的对象是文件类对象 (file-like object)，它的 <code>_file</code> 属性是 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.BytesIO" target="_blank" rel="noopener"><code>io.BytesIO</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.TextIOWrapper" target="_blank" rel="noopener"><code>io.TextIOWrapper</code></a> 对象（取决于指定的是二进制模式还是文本模式）或真实的文件对象（取决于是否已调用 <code>rollover()</code>）。文件类对象可以像普通文件一样在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中使用。</p><p><em>在 3.3 版更改:</em> 现在，文件的 truncate 方法可接受一个 <code>size</code> 参数。</p><p><em>在 3.8 版更改:</em> 添加了 <em>errors</em> 参数。</p></li><li><p><code>tempfile.TemporaryDirectory</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>) </p><p>此函数会安全地创建一个临时目录，且使用与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 相同的规则。此函数返回的对象可用作上下文管理器（参见 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile-examples" target="_blank" rel="noopener">示例</a>）。完成上下文或销毁临时目录对象后，新创建的临时目录及其所有内容将从文件系统中删除。</p><p>可以从返回对象的 <code>name</code> 属性中找到临时目录的名称。当返回的对象用作上下文管理器时，这个 <code>name</code> 会作为 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中 <code>as</code> 子句的目标（如果有 as 的话）。</p><p>可以调用 <code>cleanup()</code> 方法来手动清理目录。</p><p>引发一个 <code>tempfile.mkdtemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>3.2 新版功能.</em></p></li><li><p><code>tempfile.mkstemp</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>text=False</em>) </p><p>以最安全的方式创建一个临时文件。假设所在平台正确实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_EXCL" target="_blank" rel="noopener"><code>os.O_EXCL</code></a> 标志，则创建文件时不会有竞争的情况。该文件只能由创建者读写，如果所在平台用权限位来标记文件是否可执行，那么没有人有执行权。文件描述符不会过继给子进程。</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 不同，<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 用户用完临时文件后需要自行将其删除。</p><p>如果 <em>suffix</em> 不是 <code>None</code> 则文件名将以该后缀结尾，是 <code>None</code> 则没有后缀。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 不会在文件名和后缀之间加点，如果需要加一个点号，请将其放在 <em>suffix</em> 的开头。</p><p>如果 <em>prefix</em> 不是 <code>None</code>，则文件名将以该前缀开头，是 <code>None</code> 则使用默认前缀。默认前缀是 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefix" target="_blank" rel="noopener"><code>gettempprefix()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefixb" target="_blank" rel="noopener"><code>gettempprefixb()</code></a> 函数的返回值（自动调用合适的函数）。</p><p>如果 <em>dir</em> 不为 <code>None</code>，则在指定的目录创建文件，是 <code>None</code> 则使用默认目录。默认目录是从一个列表中选择出来的，这个列表不同平台不一样，但是用户可以设置 <em>TMPDIR</em>、<em>TEMP</em> 或 <em>TMP</em> 环境变量来设置目录的位置。因此，不能保证生成的临时文件路径很规范，比如，通过 <code>os.popen()</code> 将路径传递给外部命令时仍需要加引号。</p><p>如果 <em>suffix</em>、<em>prefix</em> 和 <em>dir</em> 中的任何一个不是 <code>None</code>，就要保证它们是同一数据类型。如果它们是 bytes，则返回的名称的类型就是 bytes 而不是 str。如果确实要用默认参数，但又想要返回值是 bytes 类型，请传入 <code>suffix=b&#39;&#39;</code>。</p><p>如果指定了 <em>text</em> 参数，它表示的是以二进制模式（默认）还是文本模式打开文件。在某些平台上，两种模式没有区别。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 返回一个元组，元组中第一个元素是句柄，它是一个系统级句柄，指向一个打开的文件（等同于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 的返回值），第二元素是该文件的绝对路径。</p><p>引发一个 <code>tempfile.mkstemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>在 3.5 版更改:</em> 现在，<em>suffix</em>、<em>prefix</em> 和 <em>dir</em> 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 str。<em>suffix</em> 和 <em>prefix</em> 现在可以接受 <code>None</code>，并且默认为 <code>None</code> 以使用合适的默认值。</p><p><em>在 3.6 版更改:</em> <em>dir</em> 参数现在可接受一个路径类对象 (<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a>)。</p></li><li><p><code>tempfile.mkdtemp</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>) </p><p>以最安全的方式创建一个临时目录，创建该目录时不会有竞争的情况。该目录只能由创建者读取、写入和搜索。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 用户用完临时目录后需要自行将其删除。</p><p><em>prefix</em>、<em>suffix</em> 和 <em>dir</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 中的相同。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 返回新目录的绝对路径。</p><p>引发一个 <code>tempfile.mkdtemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>在 3.5 版更改:</em> 现在，<em>suffix</em>、<em>prefix</em> 和 <em>dir</em> 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 str。<em>suffix</em> 和 <em>prefix</em> 现在可以接受 <code>None</code>，并且默认为 <code>None</code> 以使用合适的默认值。</p><p><em>在 3.6 版更改:</em> <em>dir</em> 参数现在可接受一个路径类对象 (<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a>)。</p></li><li><p><code>tempfile.gettempdir</code>() </p><p>返回放置临时文件的目录的名称。这个方法的返回值就是本模块所有函数的 <em>dir</em> 参数的默认值。</p><p>Python 搜索标准目录列表，以找到调用者可以在其中创建文件的目录。这个列表是：</p><ol><li><code>TMPDIR</code> 环境变量指向的目录。</li><li><code>TEMP</code> 环境变量指向的目录。</li><li><code>TMP</code> 环境变量指向的目录。</li><li>与平台相关的位置：<ul><li>在 Windows 上，依次为 <code>C:\TEMP</code>、<code>C:\TMP</code>、<code>\TEMP</code> 和 <code>\TMP</code>。</li><li>在所有其他平台上，依次为 <code>/tmp</code>、<code>/var/tmp</code> 和 <code>/usr/tmp</code>。</li></ul></li><li>不得已时，使用当前工作目录。</li></ol><p>搜索的结果会缓存起来，参见下面 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.tempdir" target="_blank" rel="noopener"><code>tempdir</code></a> 的描述。</p></li><li><p><code>tempfile.gettempdirb</code>()</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempdir" target="_blank" rel="noopener"><code>gettempdir()</code></a> 相同，但返回值为字节类型。<em>3.5 新版功能.</em></p></li><li><p><code>tempfile.gettempprefix</code>()</p><p>返回用于创建临时文件的文件名前缀，它不包含目录部分。</p></li><li><p><code>tempfile.gettempprefixb</code>()</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefix" target="_blank" rel="noopener"><code>gettempprefix()</code></a> 相同，但返回值为字节类型。<em>3.5 新版功能.</em></p></li></ul><p>本模块使用一个全局变量来存储由 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempdir" target="_blank" rel="noopener"><code>gettempdir()</code></a> 返回的临时文件目录路径。可以直接给它赋值，这样可以覆盖自动选择的路径，但是不建议这样做。本模块中的所有函数都带有一个 <em>dir</em> 参数，该参数可用于指定目录，这是推荐的方法。</p><ul><li><p><code>tempfile.tempdir</code></p><p>当设置为 <code>None</code> 以外的其他值时，此变量将决定本模块所有函数的 <em>dir</em> 参数的默认值。如果在调用除 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefix" target="_blank" rel="noopener"><code>gettempprefix()</code></a> 外的上述任何函数时 <code>tempdir</code> 为 <code>None</code> (默认值) 则它会按照 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempdir" target="_blank" rel="noopener"><code>gettempdir()</code></a> 中所描述的算法来初始化。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下是 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#module-tempfile" target="_blank" rel="noopener"><code>tempfile</code></a> 模块典型用法的一些示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> tempfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a temporary file and write some data to it</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp = tempfile.TemporaryFile()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.write(<span class="string">b'Hello world!'</span>)</span><br><span class="line"><span class="comment"># read data from file</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.seek(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.read()</span><br><span class="line"><span class="string">b'Hello world!'</span></span><br><span class="line"><span class="comment"># close the file, it will be removed</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a temporary file using a context manager</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> tempfile.TemporaryFile() <span class="keyword">as</span> fp:</span><br><span class="line"><span class="meta">... </span>    fp.write(<span class="string">b'Hello world!'</span>)</span><br><span class="line"><span class="meta">... </span>    fp.seek(<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span>    fp.read()</span><br><span class="line"><span class="string">b'Hello world!'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment"># file is now closed and removed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create a temporary directory using the context manager</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> tempfile.TemporaryDirectory() <span class="keyword">as</span> tmpdirname:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'created temporary directory'</span>, tmpdirname)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment"># directory and contents have been removed</span></span><br></pre></td></tr></table></figure><h2 id="已弃用的函数和变量"><a href="#已弃用的函数和变量" class="headerlink" title="已弃用的函数和变量"></a>已弃用的函数和变量</h2><p>创建临时文件有一种历史方法，首先使用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mktemp" target="_blank" rel="noopener"><code>mktemp()</code></a> 函数生成一个文件名，然后使用该文件名创建文件。不幸的是，这是不安全的，因为在调用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mktemp" target="_blank" rel="noopener"><code>mktemp()</code></a> 与随后尝试创建文件的进程之间的时间里，其他进程可能会使用该名称创建文件。解决方案是将两个步骤结合起来，立即创建文件。这个方案目前被 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 和上述其他函数所采用。</p><ul><li><p><code>tempfile.mktemp</code>(<em>suffix=’’</em>, <em>prefix=’tmp’</em>, <em>dir=None</em>)</p><p><em>2.3 版后已移除:</em> 使用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 来代替。返回一个绝对路径，这个路径指向的文件在调用本方法时不存在。<em>prefix</em>、<em>suffix</em> 和 <em>dir</em> 参数与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 中的同名参数类似，不同之处在于不支持字节类型的文件名，不支持 <code>suffix=None</code> 和 <code>prefix=None</code>。</p></li></ul><p>使用此功能可能会在程序中引入安全漏洞。当你开始使用本方法返回的文件执行任何操作时，可能有人已经捷足先登了。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mktemp" target="_blank" rel="noopener"><code>mktemp()</code></a> 的功能可以很轻松地用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.NamedTemporaryFile" target="_blank" rel="noopener"><code>NamedTemporaryFile()</code></a> 代替，当然需要传递 <code>delete=False</code> 参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = NamedTemporaryFile(delete=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.name</span><br><span class="line"><span class="string">'/tmp/tmptjujjt'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">b"Hello World!\n"</span>)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.unlink(f.name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exists(f.name)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-tempfile&quot;&gt;&lt;a href=&quot;#python-标准库-tempfile&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 tempfile&quot;&gt;&lt;/a&gt;python 标准库 tempfile&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200213_car.jpeg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="tempfile" scheme="https://pinghailinfeng.gitee.io/tags/tempfile/"/>
    
  </entry>
  
  <entry>
    <title>python standard library coroutines</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/12/python-standard-library-coroutines/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/12/python-standard-library-coroutines/</id>
    <published>2020-02-12T13:59:58.000Z</published>
    <updated>2020-02-17T03:27:23.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-coroutines-协程"><a href="#python-标准库-coroutines-协程" class="headerlink" title="python 标准库 coroutines 协程"></a>python 标准库 coroutines 协程</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200213_coroutine.jpg?raw=true" alt></p><a id="more"></a><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200213_writing.jpg?raw=true" alt></p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id2" target="_blank" rel="noopener">协程</a></h2><p> <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">Coroutines</a> declared with the async/await syntax is the preferred way of writing asyncio applications. For example, the following snippet of code (requires Python 3.7+) prints “hello”, waits 1 second, and then prints “world”: </p><p> <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">Coroutines</a> 通过 async/await 语法声明是编写异步应用程序的首选方式。例如下面的语法片段(需要Python 3.7+),我们实现了等待一秒,打印’’world“的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'hello'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>asyncio.run(main())</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><p> 注意：简单地调用一个协程并不会将其加入执行日程: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>main()</span><br><span class="line">&lt;coroutine object main at <span class="number">0x1053bb7c8</span>&gt;</span><br></pre></td></tr></table></figure><p>要真正运行一个协程，asyncio 提供了三种主要机制:</p><ul><li><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.run" target="_blank" rel="noopener"><code>asyncio.run()</code></a> 函数用来运行最高层级的入口点 “main()” 函数 (参见上面的示例。)</p></li><li><p>等待一个协程。以下代码段会在等待 1 秒后打印 “hello”，然后 <em>再次</em> 等待 2 秒后打印 “world”:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_after</span><span class="params">(delay, what)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    print(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>预期的输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">started at <span class="number">17</span>:<span class="number">13</span>:<span class="number">52</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finished at <span class="number">17</span>:<span class="number">13</span>:<span class="number">55</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>asyncio.create_task()</code></a> 函数用来并发运行作为 asyncio <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>任务</code></a> 的多个协程。 </p><p>让我们修改以上示例，<em>并发</em> 运行两个 <code>say_after</code> 协程:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task1 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">1</span>, <span class="string">'hello'</span>))</span><br><span class="line"></span><br><span class="line">    task2 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">2</span>, <span class="string">'world'</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait until both tasks are completed (should take</span></span><br><span class="line">    <span class="comment"># around 2 seconds.)</span></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><p>注意，预期的输出显示代码段的运行时间比之前快了 1 秒:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">started at <span class="number">17</span>:<span class="number">14</span>:<span class="number">32</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finished at <span class="number">17</span>:<span class="number">14</span>:<span class="number">34</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="可等待对象"><a href="#可等待对象" class="headerlink" title="可等待对象"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id3" target="_blank" rel="noopener">可等待对象</a></h2><p>如果一个对象可以在 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#await" target="_blank" rel="noopener"><code>await</code></a> 语句中使用，那么它就是 <strong>可等待</strong> 对象。许多 asyncio API 都被设计为接受可等待对象。</p><p><em>可等待</em> 对象有三种主要类型: <strong>协程</strong>, <strong>任务</strong> 和 <strong>Future</strong>.</p><p>协程</p><p>Python 协程属于 <em>可等待</em> 对象，因此可以在其他协程中被等待:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Nothing happens if we just call "nested()".</span></span><br><span class="line">    <span class="comment"># A coroutine object is created but not awaited,</span></span><br><span class="line">    <span class="comment"># so it *won't run at all*.</span></span><br><span class="line">    nested()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let's do it differently now and await it:</span></span><br><span class="line">    print(<span class="keyword">await</span> nested())  <span class="comment"># will print "42".</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>重要</p><p>在本文档中 “协程” 可用来表示两个紧密关联的概念:</p><ul><li><em>协程函数</em>: 定义形式为 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 的函数;</li><li><p><em>协程对象</em>: 调用 <em>协程函数</em> 所返回的对象。</p><p>asyncio 也支持旧式的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-generator-based-coro" target="_blank" rel="noopener">基于生成器的</a> 协程。 </p></li></ul><p>任务</p><p><em>任务</em> 被用来设置日程以便 <em>并发</em> 执行协程。</p><p>当一个协程通过 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>asyncio.create_task()</code></a> 等函数被打包为一个 <em>任务</em>，该协程将自动排入日程准备立即运行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Schedule nested() to run soon concurrently</span></span><br><span class="line">    <span class="comment"># with "main()".</span></span><br><span class="line">    task = asyncio.create_task(nested())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># "task" can now be used to cancel "nested()", or</span></span><br><span class="line">    <span class="comment"># can simply be awaited to wait until it is complete:</span></span><br><span class="line">    <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>Future 对象</p><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future</code></a> 是一种特殊的 <strong>低层级</strong> 可等待对象，表示一个异步操作的 <strong>最终结果</strong>。</p><p>当一个 Future 对象 <em>被等待</em>，这意味着协程将保持等待直到该 Future 对象在其他地方操作完毕。</p><p>在 asyncio 中需要 Future 对象以便允许通过 async/await 使用基于回调的代码。</p><p>通常情况下 <strong>没有必要</strong> 在应用层级的代码中创建 Future 对象。</p><p>Future 对象有时会由库和某些 asyncio API 暴露给用户，用作可等待对象:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> function_that_returns_a_future_object()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># this is also valid:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        function_that_returns_a_future_object(),</span><br><span class="line">        some_python_coroutine()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>一个很好的返回对象的低层级函数的示例是 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.loop.run_in_executor" target="_blank" rel="noopener"><code>loop.run_in_executor()</code></a>。</p><h2 id="运行-asyncio-程序"><a href="#运行-asyncio-程序" class="headerlink" title="运行 asyncio 程序"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id4" target="_blank" rel="noopener">运行 asyncio 程序</a></h2><p> <code>asyncio.run</code>(<em>coro</em>, <em>**, </em>debug=False*) </p><p>执行 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> <em>coro</em> 并返回结果。</p><p>此函数运行传入的协程，负责管理 asyncio 事件循环并 <em>完结异步生成器</em>。</p><p>当有其他 asyncio 事件循环在同一线程中运行时，此函数不能被调用。</p><p>如果 <em>debug</em> 为 <code>True</code>，事件循环将以调试模式运行。</p><p>此函数总是会创建一个新的事件循环并在结束时关闭之。它应当被用作 asyncio 程序的主入口点，理想情况下应当只被调用一次。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p> <em>3.7 新版功能.</em> </p><blockquote><p>  <code>asyncio.run()</code>源代码请移步至 <a href="https://github.com/python/cpython/tree/3.8/Lib/asyncio/runners.py" target="_blank" rel="noopener">Lib/asyncio/runners.py</a>.</p></blockquote><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id5" target="_blank" rel="noopener">创建任务</a></h2><ul><li><p><code>asyncio.create_task</code>(<em>coro</em>, <em>**, </em>name=None*)</p><p>将 <em>coro</em> <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程</a> 打包为一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 排入日程准备执行。返回 Task 对象。</p><p>If <em>name</em> is not <code>None</code>, it is set as the name of the task using <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.set_name" target="_blank" rel="noopener"><code>Task.set_name()</code></a>.</p><p>该任务会在 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener"><code>get_running_loop()</code></a> 返回的循环中执行，如果当前线程没有在运行的循环则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p><p>此函数 <strong>在 Python 3.7 中被加入</strong>。在 Python 3.7 之前，可以改用低层级的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.ensure_future" target="_blank" rel="noopener"><code>asyncio.ensure_future()</code></a> 函数。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># In Python 3.7+</span></span><br><span class="line">task = asyncio.create_task(coro())</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># This works in all Python versions but is less readable</span></span><br><span class="line">task = asyncio.ensure_future(coro())</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><em>3.7 新版功能.</em></p><p><em>在 3.8 版更改:</em> Added the <code>name</code> parameter.</p><h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id6" target="_blank" rel="noopener">休眠</a></h2><ul><li><p><em>coroutine</em> <code>asyncio.sleep</code>(<em>delay</em>, <em>result=None</em>, <em>**, </em>loop=None*)</p><p>阻塞 <em>delay</em> 指定的秒数。</p><p>如果指定了 <em>result</em>，则当协程完成时将其返回给调用者。</p><p><code>sleep()</code> 总是会挂起当前任务，以允许其他任务运行。</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><p>以下协程示例运行 5 秒，每秒显示一次当前日期:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">display_date</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    end_time = loop.time() + <span class="number">5.0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(datetime.datetime.now())</span><br><span class="line">        <span class="keyword">if</span> (loop.time() + <span class="number">1.0</span>) &gt;= end_time:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(display_date())</span><br></pre></td></tr></table></figure></li></ul><h2 id="并发运行任务"><a href="#并发运行任务" class="headerlink" title="并发运行任务"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id7" target="_blank" rel="noopener">并发运行任务</a></h2><ul><li><p><em>awaitable</em> <code>asyncio.gather</code>(*<em>aws</em>, <em>loop=None</em>, <em>return_exceptions=False</em>) </p><p><em>并发</em> 运行 <em>aws</em> 序列中的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a>。</p><p>如果 <em>aws</em> 中的某个可等待对象为协程，它将自动作为一个任务加入日程。</p><p>如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而成的列表。结果值的顺序与 <em>aws</em> 中可等待对象的顺序一致。</p><p>如果 <em>return_exceptions</em> 为 <code>False</code> (默认)，所引发的首个异常会立即传播给等待 <code>gather()</code> 的任务。<em>aws</em> 序列中的其他可等待对象 <strong>不会被取消</strong> 并将继续运行。</p><p>如果 <em>return_exceptions</em> 为 <code>True</code>，异常会和成功的结果一样处理，并聚合至结果列表。</p><p>如果 <code>gather()</code> <em>被取消</em>，所有被提交 (尚未完成) 的可等待对象也会 <em>被取消</em>。</p><p>如果 <em>aws</em> 序列中的任一 Task 或 Future 对象 <em>被取消</em>，它将被当作引发了 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 一样处理 – 在此情况下 <code>gather()</code> 调用 <strong>不会</strong> 被取消。这是为了防止一个已提交的 Task/Future 被取消导致其他 Tasks/Future 也被取消。</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(name, number)</span>:</span></span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: Compute factorial(<span class="subst">&#123;i&#125;</span>)..."</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        f *= i</span><br><span class="line">    print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: factorial(<span class="subst">&#123;number&#125;</span>) = <span class="subst">&#123;f&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        factorial(<span class="string">"A"</span>, <span class="number">2</span>),</span><br><span class="line">        factorial(<span class="string">"B"</span>, <span class="number">3</span>),</span><br><span class="line">        factorial(<span class="string">"C"</span>, <span class="number">4</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     Task A: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task A: factorial(2) = 2</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(3)...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(3)...</span></span><br><span class="line"><span class="comment">#     Task B: factorial(3) = 6</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(4)...</span></span><br><span class="line"><span class="comment">#     Task C: factorial(4) = 24</span></span><br></pre></td></tr></table></figure><p><em>在 3.7 版更改:</em> 如果 <em>gather</em> 本身被取消，则无论 <em>return_exceptions</em> 取值为何，消息都会被传播。</p></li></ul><h2 id="屏蔽取消操作"><a href="#屏蔽取消操作" class="headerlink" title="屏蔽取消操作"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id8" target="_blank" rel="noopener">屏蔽取消操作</a></h2><ul><li><p><em>awaitable</em> <code>asyncio.shield</code>(<em>aw</em>, <em>**, </em>loop=None*) </p><p>保护一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a> 防止其被 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>取消</code></a>。</p><p>如果 <em>aw</em> 是一个协程，它将自动作为任务加入日程。</p><p>以下语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = await shield(something())</span><br></pre></td></tr></table></figure><p>相当于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = await something()</span><br></pre></td></tr></table></figure><p><em>不同之处</em> 在于如果包含它的协程被取消，在 <code>something()</code> 中运行的任务不会被取消。从 <code>something()</code> 的角度看来，取消操作并没有发生。然而其调用者已被取消，因此 “await” 表达式仍然会引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a>。</p><p>如果通过其他方式取消 <code>something()</code> (例如在其内部操作) 则 <code>shield()</code> 也会取消。</p><p>如果希望完全忽略取消操作 (不推荐) 则 <code>shield()</code> 函数需要配合一个 try/except 代码段，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    res = await shield(something())</span><br><span class="line">except CancelledError:</span><br><span class="line">    res = None</span><br></pre></td></tr></table></figure><p>从 3.8版本加入，将于 3.10版本移除<em>loop</em> 形参。</p></li></ul><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id9" target="_blank" rel="noopener">超时</a></h2><ul><li><p><em>coroutine</em> <code>asyncio.wait_for</code>(<em>aw</em>, <em>timeout</em>, <em>**, </em>loop=None*) </p><p>等待 <em>aw</em> <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a> 完成，指定 timeout 秒数后超时。</p><p>如果 <em>aw</em> 是一个协程，它将自动作为任务加入日程。</p><p><em>timeout</em> 可以为 <code>None</code>，也可以为 float 或 int 型数值表示的等待秒数。如果 <em>timeout</em> 为 <code>None</code>，则等待直到完成。</p><p>如果发生超时，任务将取消并引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>.</p><p>要避免任务 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>取消</code></a>，可以加上 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.shield" target="_blank" rel="noopener"><code>shield()</code></a>。</p><p>函数将等待直到目标对象确实被取消，所以总等待时间可能超过 <em>timeout</em> 指定的秒数。</p><p>如果等待被取消，则 <em>aw</em> 指定的对象也会被取消。</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">eternity</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Sleep for one hour</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    print(<span class="string">'yay!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Wait for at most 1 second</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait_for(eternity(), timeout=<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">        print(<span class="string">'timeout!'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     timeout!</span></span><br></pre></td></tr></table></figure><p><em>在 3.7 版更改:</em> 当 <em>aw</em> 因超时被取消，<code>wait_for</code> 会等待 <em>aw</em> 被取消。之前版本则将立即引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>。</p></li></ul><h2 id="简单等待"><a href="#简单等待" class="headerlink" title="简单等待"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id10" target="_blank" rel="noopener">简单等待</a></h2><ul><li><p><em>coroutine</em> <code>asyncio.wait</code>(<em>aws</em>, <em>**, </em>loop=None<em>, </em>timeout=None<em>, </em>return_when=ALL_COMPLETED*) </p><p>并发运行 <em>aws</em> 指定的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a> 并阻塞线程直到满足 <em>return_when</em> 指定的条件。</p><p>返回两个 Task/Future 集合: <code>(done, pending)</code>。</p><p>用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">done, pending = await asyncio.wait(aws)</span><br></pre></td></tr></table></figure><p>如指定 <em>timeout</em> (float 或 int 类型) 则它将被用于控制返回之前等待的最长秒数。</p><p>请注意此函数不会引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>。当超时发生时，未完成的 Future 或 Task 将在指定秒数后被返回。</p><p><em>return_when</em> 指定此函数应在何时返回。它必须为以下常数之一:</p><p>| 常数              | 描述                                                         |<br>| :—————- | :———————————————————– |<br>| <code>FIRST_COMPLETED</code> | 函数将在任意可等待对象结束或取消时返回。                     |<br>| <code>FIRST_EXCEPTION</code> | 函数将在任意可等待对象因引发异常而结束时返回。当没有引发任何异常时它就相当于 <code>ALL_COMPLETED</code>。 |<br>| <code>ALL_COMPLETED</code>   | 函数将在所有可等待对象结束或取消时返回。                     |</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.wait_for" target="_blank" rel="noopener"><code>wait_for()</code></a> 不同，<code>wait()</code> 在超时发生时不会取消可等待对象。</p><p><em>3.8 版后已移除:</em> 如果 <em>aws</em> 中的某个可等待对象为协程，它将自动作为任务加入日程。直接向 <code>wait()</code> 传入协程对象已弃用，因为这会导致 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-example-wait-coroutine" target="_blank" rel="noopener">令人迷惑的行为</a>。</p><p>从 3.8版本加入，将于 3.10版本移除<em>loop</em> 形参。</p><blockquote><p>注解</p><p><code>wait()</code> 会自动将协程作为任务加入日程，以后将以 <code>(done, pending)</code> 集合形式返回显式创建的任务对象。因此以下代码并不会有预期的行为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; coro = foo()</span><br><span class="line">&gt; done, pending = <span class="keyword">await</span> asyncio.wait(&#123;coro&#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">if</span> coro <span class="keyword">in</span> done:</span><br><span class="line">&gt;     <span class="comment"># This branch will never be run!</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>以上代码段的修正方法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; task = asyncio.create_task(foo())</span><br><span class="line">&gt; done, pending = <span class="keyword">await</span> asyncio.wait(&#123;task&#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">if</span> task <span class="keyword">in</span> done:</span><br><span class="line">&gt;     <span class="comment"># Everything will work as expected now.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>​     <em>3.8 版后已移除:</em> 直接向 <code>wait()</code> 传入协程对象的方式已弃用。 </p><ul><li><p><code>asyncio.as_completed</code>(<em>aws</em>, <em>**, </em>loop=None<em>, </em>timeout=None*) </p><p>并发地运行 <em>aws</em> 集合中的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a>。返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future</code></a> 对象的迭代器。返回的每个 Future 对象代表来自剩余可等待对象集合的最早结果。</p><p>如果在所有 Future 对象完成前发生超时则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>。</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> as_completed(aws):</span><br><span class="line">    earliest_result = <span class="keyword">await</span> f</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="来自其他线程的日程安排"><a href="#来自其他线程的日程安排" class="headerlink" title="来自其他线程的日程安排"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id11" target="_blank" rel="noopener">来自其他线程的日程安排</a></h2><ul><li><p><code>asyncio.run_coroutine_threadsafe</code>(<em>coro</em>, <em>loop</em>)</p><p>向指定事件循环提交一个协程。线程安全。</p><p>返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>concurrent.futures.Future</code></a> 以等待来自其他 OS 线程的结果。</p><p>此函数应该从另一个 OS 线程中调用，而非事件循环运行所在线程。示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Create a coroutine</span><br><span class="line">coro = asyncio.sleep(1, result=3)</span><br><span class="line"></span><br><span class="line"># Submit the coroutine to a given loop</span><br><span class="line">future = asyncio.run_coroutine_threadsafe(coro, loop)</span><br><span class="line"></span><br><span class="line"># Wait for the result with an optional timeout argument</span><br><span class="line">assert future.result(timeout) == 3</span><br></pre></td></tr></table></figure><p>如果在协程内产生了异常，将会通知返回的 Future 对象。它也可被用来取消事件循环中的任务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    result = future.result(timeout)</span><br><span class="line">except asyncio.TimeoutError:</span><br><span class="line">    print(&apos;The coroutine took too long, cancelling the task...&apos;)</span><br><span class="line">    future.cancel()</span><br><span class="line">except Exception as exc:</span><br><span class="line">    print(f&apos;The coroutine raised an exception: &#123;exc!r&#125;&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(f&apos;The coroutine returned: &#123;result!r&#125;&apos;)</span><br></pre></td></tr></table></figure><p>查看 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-dev.html#asyncio-multithreading" target="_blank" rel="noopener">并发和多线程</a> 章节的文档。</p><p>不同与其他 asyncio 函数，此函数要求显式地传入 <em>loop</em> 参数。</p><p><em>3.5.1 新版功能.</em></p></li></ul><h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id12" target="_blank" rel="noopener">内省</a></h2><ul><li><p><code>asyncio.current_task</code>(<em>loop=None</em>)</p><p>返回当前运行的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 实例，如果没有正在运行的任务则返回 <code>None</code>。如果 <em>loop</em> 为 <code>None</code> 则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener"><code>get_running_loop()</code></a> 获取当前事件循环。<em>3.7 新版功能.</em></p></li><li><p><code>asyncio.all_tasks</code>(<em>loop=None</em>)</p><p>返回事件循环所运行的未完成的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 对象的集合。如果 <em>loop</em> 为 <code>None</code>，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener"><code>get_running_loop()</code></a> 获取当前事件循环。<em>3.7 新版功能.</em></p></li></ul><h2 id="Task-对象"><a href="#Task-对象" class="headerlink" title="Task 对象"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id13" target="_blank" rel="noopener">Task 对象</a></h2><ul><li><p><em>class</em> <code>asyncio.Task</code>(<em>coro</em>, <em>**, </em>loop=None<em>, </em>name=None*)</p><p>一个与 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future 类似</code></a> 的对象，可运行 Python <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程</a>。非线程安全。</p><p>Task 对象被用来在事件循环中运行协程。如果一个协程在等待一个 Future 对象，Task 对象会挂起该协程的执行并等待该 Future 对象完成。当该 Future 对象 <em>完成</em>，被打包的协程将恢复执行。</p><p>事件循环使用协同日程调度: 一个事件循环每次运行一个 Task 对象。而一个 Task 对象会等待一个 Future 对象完成，该事件循环会运行其他 Task、回调或执行 IO 操作。</p><p>使用高层级的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>asyncio.create_task()</code></a> 函数来创建 Task 对象，也可用低层级的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.loop.create_task" target="_blank" rel="noopener"><code>loop.create_task()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.ensure_future" target="_blank" rel="noopener"><code>ensure_future()</code></a> 函数。不建议手动实例化 Task 对象。</p><p>要取消一个正在运行的 Task 对象可使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>cancel()</code></a> 方法。调用此方法将使该 Task 对象抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常给打包的协程。如果取消期间一个协程正在等待一个 Future 对象，该 Future 对象也将被取消。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancelled" target="_blank" rel="noopener"><code>cancelled()</code></a> 可被用来检测 Task 对象是否被取消。如果打包的协程没有抑制 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常并且确实被取消，该方法将返回 <code>True</code>。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>asyncio.Task</code></a> 从 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future</code></a> 继承了其除 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_result" target="_blank" rel="noopener"><code>Future.set_result()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_exception" target="_blank" rel="noopener"><code>Future.set_exception()</code></a> 以外的所有 API。</p><p>Task 对象支持 <a href="https://docs.python.org/zh-cn/3.8/library/contextvars.html#module-contextvars" target="_blank" rel="noopener"><code>contextvars</code></a> 模块。当一个 Task 对象被创建，它将复制当前上下文，然后在复制的上下文中运行其协程。</p><p><em>在 3.7 版更改:</em> 加入对 <a href="https://docs.python.org/zh-cn/3.8/library/contextvars.html#module-contextvars" target="_blank" rel="noopener"><code>contextvars</code></a> 模块的支持。</p><p><em>在 3.8 版更改:</em> Added the <code>name</code> parameter.</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><ul><li><p><code>cancel</code>()</p><p>请求取消 Task 对象。这将安排在下一轮事件循环中抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常给被封包的协程。协程在之后有机会进行清理甚至使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> … … <code>except CancelledError</code> … <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 代码块抑制异常来拒绝请求。不同于 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.cancel" target="_blank" rel="noopener"><code>Future.cancel()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>Task.cancel()</code></a> 不保证 Task 会被取消，虽然抑制完全取消并不常见，也很不鼓励这样做。以下示例演示了协程是如何侦听取消请求的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel_me</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'cancel_me(): before sleep'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Wait for 1 hour</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        print(<span class="string">'cancel_me(): cancel sleep'</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'cancel_me(): after sleep'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Create a "cancel_me" Task</span></span><br><span class="line">    task = asyncio.create_task(cancel_me())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait for 1 second</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    task.cancel()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        print(<span class="string">"main(): cancel_me is cancelled now"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     cancel_me(): before sleep</span></span><br><span class="line"><span class="comment">#     cancel_me(): cancel sleep</span></span><br><span class="line"><span class="comment">#     cancel_me(): after sleep</span></span><br><span class="line"><span class="comment">#     main(): cancel_me is cancelled now</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>cancelled</code>()</p><p>如果 Task 对象 <em>被取消</em> 则返回 <code>True</code>。当使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>cancel()</code></a> 发出取消请求时 Task 会被 <em>取消</em>，其封包的协程将传播被抛入的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。</p></li><li><p><code>done</code>()</p><p>如果 Task 对象 <em>已完成</em> 则返回 <code>True</code>。当 Task 所封包的协程返回一个值、引发一个异常或 Task 本身被取消时，则会被认为 <em>已完成</em>。</p></li><li><p><code>result</code>()</p><p>返回 Task 的结果。如果 Task 对象 <em>已完成</em>，其封包的协程的结果会被返回 (或者当协程引发异常时，该异常会被重新引发。)如果 Task 对象 <em>被取消</em>，此方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。如果 Task 对象的结果还不可用，此方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 异常。</p></li><li><p><code>exception</code>()</p><p>返回 Task 对象的异常。如果所封包的协程引发了一个异常，该异常将被返回。如果所封包的协程正常返回则该方法将返回 <code>None</code>。如果 Task 对象 <em>被取消</em>，此方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。如果 Task 对象尚未 <em>完成</em>，此方法将引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 异常。</p></li><li><p><code>add_done_callback</code>(<em>callback</em>, <em>**, </em>context=None*)</p><p>添加一个回调，将在 Task 对象 <em>完成</em> 时被运行。此方法应该仅在低层级的基于回调的代码中使用。要了解更多细节请查看 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.add_done_callback" target="_blank" rel="noopener"><code>Future.add_done_callback()</code></a> 的文档。</p></li><li><p><code>remove_done_callback</code>(<em>callback</em>)</p><p>从回调列表中移除 <em>callback</em> 指定的回调。此方法应该仅在低层级的基于回调的代码中使用。要了解更多细节请查看 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.remove_done_callback" target="_blank" rel="noopener"><code>Future.remove_done_callback()</code></a> 的文档。</p></li><li><p><code>get_stack</code>(<em>**, </em>limit=None*)</p><p>返回此 Task 对象的栈框架列表。如果所封包的协程未完成，这将返回其挂起所在的栈。如果协程已成功完成或被取消，这将返回一个空列表。如果协程被一个异常终止，这将返回回溯框架列表。框架总是从按从旧到新排序。每个被挂起的协程只返回一个栈框架。可选的 <em>limit</em> 参数指定返回框架的数量上限；默认返回所有框架。返回列表的顺序要看是返回一个栈还是一个回溯：栈返回最新的框架，回溯返回最旧的框架。(这与 traceback 模块的行为保持一致。)</p></li><li><p><code>print_stack</code>(<em>**, </em>limit=None<em>, </em>file=None*)</p><p>打印此 Task 对象的栈或回溯。此方法产生的输出类似于 traceback 模块通过 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.get_stack" target="_blank" rel="noopener"><code>get_stack()</code></a> 所获取的框架。<em>limit</em> 参数会直接传递给 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.get_stack" target="_blank" rel="noopener"><code>get_stack()</code></a>。<em>file</em> 参数是输出所写入的 I/O 流；默认情况下输出会写入 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stderr" target="_blank" rel="noopener"><code>sys.stderr</code></a>。</p></li><li><p><code>get_coro</code>()</p><p>返回绑定到 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a>.的协程对象。<em>3.8 新版功能.</em></p></li><li><p><code>get_name</code>()</p><p>返回Task 名字。如果没有显式分配给Task一个名字,则默认的异步Task将分配给默认的生成的名字。<em>3.8 新版功能.</em></p></li><li><p><code>set_name</code>(<em>value</em>)</p><p>设置Task名字。参数值可以是任意数据类型,都将被转换成字符串。默认的Task实现，可以通过在task对象中实现 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a>函数显式输出。<em>3.8 新版功能.</em></p></li><li><p><em>classmethod</em> <code>all_tasks</code>(<em>loop=None</em>)</p><p>返回一个事件循环中所有任务的集合。默认情况下将返回当前事件循环中所有任务。如果 <em>loop</em> 为 <code>None</code>，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_event_loop" target="_blank" rel="noopener"><code>get_event_loop()</code></a> 函数来获取当前事件循环。从3.7版本就被废弃,3.9版本将会被移除。尽量不要作为一个task方法来使用,建议使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.all_tasks" target="_blank" rel="noopener"><code>asyncio.all_tasks()</code></a> 代替。</p></li><li><p><em>classmethod</em> <code>current_task</code>(<em>loop=None</em>)</p><p>返回当前运行任务或 <code>None</code>。如果 <em>loop</em> 为 <code>None</code>，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_event_loop" target="_blank" rel="noopener"><code>get_event_loop()</code></a> 函数来获取当前事件循环。</p><p>从3.7版本就被废弃,3.9版本将会被移除。尽量不要作为一个task方法来使用,建议使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.current_task" target="_blank" rel="noopener"><code>asyncio.current_task()</code></a> 代替。</p></li></ul><h2 id="基于生成器的协程"><a href="#基于生成器的协程" class="headerlink" title="基于生成器的协程"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id14" target="_blank" rel="noopener">基于生成器的协程</a></h2><blockquote><p>对基于生成器的协程的支持 <strong>已弃用</strong> 并计划在 Python 3.10 中移除。</p></blockquote><p>基于生成器的协程是 async/await 语法的前身。它们是使用 <code>yield from</code> 语句创建的 Python 生成器，可以等待 Future 和其他协程。</p><p>基于生成器的协程应该使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.coroutine" target="_blank" rel="noopener"><code>@asyncio.coroutine</code></a> 装饰，虽然这并非强制。</p><ul><li><p><a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a>`</p><p>用来标记基于生成器的协程的装饰器。此装饰器使得旧式的基于生成器的协程能与 async/await 代码相兼容:</p><p>此装饰器使得旧式的基于生成器的协程能与 async/await 代码相兼容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">old_style_coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> old_style_coroutine()</span><br></pre></td></tr></table></figure><p>此装饰器不应该被用于 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 协程。</p><p> 从3.8版本被废弃, 将于3.10版本移除:* 使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 代替。</p></li><li><p><code>asyncio.iscoroutine</code>(<em>obj</em>)</p><p>如果 <em>obj</em> 是一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程对象</a> 则返回 <code>True</code>。此方法不同于 <a href="https://docs.python.org/zh-cn/3.8/library/inspect.html#inspect.iscoroutine" target="_blank" rel="noopener"><code>inspect.iscoroutine()</code></a> 因为它对基于生成器的协程返回 <code>True</code>。</p></li><li><p><code>asyncio.iscoroutinefunction</code>(<em>func</em>)</p><p>如果 <em>func</em> 是一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程函数</a> 则返回 <code>True</code>。此方法不同于 <a href="https://docs.python.org/zh-cn/3.8/library/inspect.html#inspect.iscoroutinefunction" target="_blank" rel="noopener"><code>inspect.iscoroutinefunction()</code></a> 因为它对以 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.coroutine" target="_blank" rel="noopener"><code>@coroutine</code></a> 装饰的基于生成器的协程函数返回 <code>True</code>。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>转自 <a href="https://www.zhihu.com/question/35139020" target="_blank" rel="noopener">python协程</a></p><p>作者：侠三十六</p><p><strong>协程</strong></p><p>首先要明确，线程和进程都是系统帮咱们开辟的，不管是thread还是process他内部都是调用的系统的API,而对于协程来说它和系统毫无关系;</p><p>协程不同于线程的是，线程是抢占式的调度，而协程是协同式的调度，也就是说，协程需要自己做调度。</p><p>他就和程序员有关系，对于线程和进程来说，调度是由CPU来决定调度的;</p><p>对于协程来说，程序员就是上帝，你想让谁执行到哪里他就执行到哪里;</p><p>协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。</p><p><strong>适用场景：</strong>其实在其他语言中，协程的其实是意义不大的多线程即可已解决I/O的问题，但是在python因为他有GIL（Global Interpreter Lock 全局解释器锁 ）在同一时间只有一个线程在工作，所以：如果一个线程里面I/O操作特别多，协程就比较适用;</p><p>协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程。</p><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：</p><p>协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</p><p><strong>协程的好处：</strong></p><p>无需线程上下文切换的开销</p><p>无需原子操作锁定及同步的开销</p><p>方便切换控制流，简化编程模型</p><p>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</p><p><strong>缺点：</strong></p><p>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</p><p>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-coroutines-协程&quot;&gt;&lt;a href=&quot;#python-标准库-coroutines-协程&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 coroutines 协程&quot;&gt;&lt;/a&gt;python 标准库 coroutines 协程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200213_coroutine.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="coroutines" scheme="https://pinghailinfeng.gitee.io/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>python standard library weakref</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/11/python-standard-library-weakref/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/11/python-standard-library-weakref/</id>
    <published>2020-02-10T22:57:22.000Z</published>
    <updated>2020-02-11T13:27:57.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-weakref-弱引用"><a href="#python-标准库-weakref-弱引用" class="headerlink" title="python 标准库 weakref 弱引用"></a>python 标准库 weakref 弱引用</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/compress.jpg?raw=true" alt></p><a id="more"></a><p>通过<code>google Insights</code> 优化,我把图片进行了压缩,明显速度提升了15%，接下来压缩css和js.</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/weakref.py" target="_blank" rel="noopener">Lib/weakref.py</a> </p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块允许Python程序员创建对象的 <em>weak references</em> 。</p><p>在下文中，术语 <em>referent</em> 表示由弱引用引用的对象。</p><p>对对象的弱引用不能保证对象存活：当对像的引用只剩弱引用时， <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-garbage-collection" target="_blank" rel="noopener">garbage collection</a> 可以销毁引用并将其内存重用于其他内容。但是，在实际销毁对象之前，即使没有强引用，弱引用也一直能返回该对象。</p><p>弱引用的主要用途是实现保存大对象的高速缓存或映射，但又并希望大对象仅仅因为它出现在高速缓存或映射中而保持存活。</p><p>例如，如果您有许多大型二进制图像对象，则可能希望将名称与每个对象关联起来。如果您使用Python字典将名称映射到图像，或将图像映射到名称，则图像对象将保持活动状态，因为它们在字典中显示为值或键。 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块提供的 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 类可以替代Python字典，使用弱引用来构造映射，这些映射不会仅仅因为它们出现在映射对象中而使对象保持存活。例如，如果一个图像对象是 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 中的值，那么当对该图像对象的剩余引用是弱映射对象所持有的弱引用时，垃圾回收可以回收该对象并将其在弱映射对象中相应的条目删除。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 在它们的实现中使用弱引用，在弱引用上设置回调函数，当键或值被垃圾回收回收时通知弱字典。 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakSet" target="_blank" rel="noopener"><code>WeakSet</code></a> 实现了 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 接口，但像 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 一样，只持有其元素的弱引用。`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize" target="_blank" rel="noopener"><code>finalize</code></a> 提供了注册一个对象被垃圾收集时要调用的清理函数的方式。这比在原始弱引用上设置回调函数更简单，因为模块会自动确保对象被回收前终结器一直保持存活。</p><p>这些弱容器类型之一或者 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize" target="_blank" rel="noopener"><code>finalize</code></a> 就是大多数程序所需要的 - 通常不需要直接创建自己的弱引用。<a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块暴露了低级机制，以便于高级用途。</p><p>并非所有对象都可以被弱引用；可以被弱引用的对象包括类实例，用 Python（而不是用 C）编写的函数，实例方法、集合、冻结集合，某些 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">文件对象</a>，<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">生成器</a>，类型对象，套接字，数组，双端队列，正则表达式模式对象以及代码对象等。</p><p><em>在 3.2 版更改:</em> 添加了对thread.lock，threading.Lock和代码对象的支持。</p><p>几个内建类型如 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 不直接支持弱引用，但可以通过子类化添加支持:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">obj = Dict(red=<span class="number">1</span>, green=<span class="number">2</span>, blue=<span class="number">3</span>)   <span class="comment"># this object is weak referenceable</span></span><br></pre></td></tr></table></figure><p><strong>CPython implementation detail:</strong> 其他内置类型例如 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#tuple" target="_blank" rel="noopener"><code>tuple</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 不支持弱引用，即使通过子类化也不支持。</p><p>Extension types can easily be made to support weak references; see <a href="https://docs.python.org/zh-cn/3.8/extending/newtypes.html#weakref-support" target="_blank" rel="noopener">Weak Reference Support</a>.</p><ul><li><p><em>class</em> <code>weakref.`</code>ref`(<em>object</em>[, <em>callback</em>])</p><p>返回对 <em>对象</em> 的弱引用。如果原始对象仍然存活，则可以通过调用引用对象来检索原始对象；如果引用的原始对象不再存在，则调用引用对象将得到 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 。如果提供了 <em>回调</em> 而且值不是 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> ，并且返回的弱引用对象仍然存活，则在对象即将终结时将调用回调;弱引用对象将作为回调的唯一参数传递；指示物将不再可用。</p><p>许多弱引用也允许针对相同对象来构建。 为每个弱引用注册的回调将按从最近注册的回调到最早注册的回调的顺序被调用。</p><p>回调所引发的异常将记录于标准错误输出，但无法被传播；它们会按与对象的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法所引发的异常相同的方式被处理。</p><p>如果 <em>object</em> 可哈希，则弱引用也为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a>。 即使在 <em>object</em> 被删除之后它们仍将保持其哈希值。 如果 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#hash" target="_blank" rel="noopener"><code>hash()</code></a> 在 <em>object</em> 被删除之后才首次被调用，则该调用将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p><p>弱引用支持相等检测，但不支持排序比较。 如果被引用对象仍然存在，两个引用具有与它们的被引用对象一致的相等关系（无论 <em>callback</em> 是否相同）。 如果删除了任一被引用对象，则仅在两个引用对象为同一对象时两者才相等。</p><p>这是一个可子类化的类型而非一个工厂函数。</p><ul><li><p><strong><strong>callback</strong></strong> </p><p>这个只读属性会返回当前关联到弱引用的回调。 如果回调不存在或弱引用的被引用对象已不存在，则此属性的值为 <code>None</code>。 </p></li></ul></li><li><p><code>weakref.`</code>proxy`(<em>object</em>[, <em>callback</em>]) </p><p>返回 <em>object</em> 的一个使用弱引用的代理。 此函数支持在大多数上下文中使用代理，而不要求显式地对所使用的弱引用对象解除引用。 返回的对象类型将为 <code>ProxyType</code> 或 <code>CallableProxyType</code>，具体取决于 <em>object</em> 是否可调用。 Proxy 对象不是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a> 对象，无论被引用对象是否可哈希；这可避免与它们的基本可变性质相关的多种问题，并可防止它们被用作字典键。 <em>callback</em> 与 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref()</code></a> 函数的同名形参含义相同。</p><p><em>在 3.8 版更改:</em> 扩展代理对象所支持的运算符，包括矩阵乘法运算符 <code>@</code> 和 <code>@=</code>。</p></li><li><p><code>weakref.`</code>getweakrefcount`(<em>object</em>) </p><p>返回指向 <em>object</em> 的弱引用和代理的数量。 </p></li><li><p><code>weakref.`</code>getweakrefs`(<em>object</em>) </p><p>返回由指向 <em>object</em> 的所有弱引用和代理构成的列表。 </p></li><li><p><em>class</em> <code>weakref.`</code>WeakKeyDictionary`([<em>dict</em>]) </p><p>弱引用键的映射类。 当不再有对键的强引用时字典中的条目将被丢弃。 这可被用来将额外数据关联到一个应用中其他部分所拥有的对象而无需在那些对象中添加属性。 这对于重载了属性访问的对象来说特别有用。 </p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 对象具有一个额外方法可以直接公开内部引用。 这些引用不保证在它们被使用时仍然保持“存活”，因此这些引用的调用结果需要在使用前进行检测。 此方法可用于避免创建会导致垃圾回收器将保留键超出实际需要时长的引用。 </p></li><li><p><code>WeakKeyDictionary.`</code>keyrefs`() </p><p>返回包含对键的弱引用的可迭代对象。 </p></li><li><p><em>class</em> <code>weakref.`</code>WeakValueDictionary`([<em>dict</em>]) </p><p>弱引用值的映射类。 当不再有对键的强引用时字典中的条目将被丢弃。 </p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 对象具有一个额外方法，此方法存在与 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 对象的 <code>keyrefs()</code> 方法相同的问题。 </p></li><li><p><code>WeakValueDictionary.`</code>valuerefs`() </p><p> 返回包含对值的弱引用的可迭代对象。 </p></li><li><p><em>class</em> <code>weakref.`</code>WeakSet`([<em>elements</em>]) </p><p>保持对其元素弱引用的集合类。 当不再有对某个元素的强引用时元素将被丢弃。 </p></li><li><p><em>class</em> <code>weakref.`</code>WeakMethod`(<em>method</em>) </p><p>一个模拟对绑定方法（即在类中定义并在实例中查找的方法）进行弱引用的自定义 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref</code></a> 子类。 由于绑定方法是临时性的，标准弱引用无法保持它。 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakMethod" target="_blank" rel="noopener"><code>WeakMethod</code></a> 包含特别代码用来重新创建绑定方法，直到对象或初始函数被销毁: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"method called!"</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = weakref.ref(c.method)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = weakref.WeakMethod(c.method)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()</span><br><span class="line">&lt;bound method C.method of &lt;__main__.C object at <span class="number">0x7fc859830220</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()()</span><br><span class="line">method called!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> c</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.collect()</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p><em>class</em> <code>weakref.`</code>finalize`(<em>obj</em>, <em>func</em>, <strong>args<em>, </em></strong>kwargs*) </p><p>返回一个可调用的终结器对象，该对象将在 <em>obj</em> 作为垃圾回收时被调用。 与普通的弱引用不同，终结器将总是存活，直到引用对象被回收，这极大地简化了生存期管理。</p><p>终结器总是被视为 <em>存活</em> 直到它被调用（显式调用或在垃圾回收时隐式调用），调用之后它将 <em>死亡</em>。 调用存活的终结器将返回 <code>func(*arg, **kwargs)</code> 的求值结果，而调用死亡的终结器将返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p><p>在垃圾收集期间由终结器回调所引发异常将显示于标准错误输出，但无法被传播。 它们会按与对象的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法或弱引用的回调所引发异常相同的方式被处理。</p><p>当程序退出时，剩余的存活终结器会被调用，除非它们的 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 属性已被设为假值。 它们会按与创建时相反的顺序被调用。</p><p>终结器在 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-interpreter-shutdown" target="_blank" rel="noopener">interpreter shutdown</a> 的后期绝不会发起调用其回调函数，此时模块全局变量很可能已被替换为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p><ul><li><p><code>__call__</code>()</p><p>如果 <em>self</em> 为存活状态则将其标记为已死亡，并返回调用 <code>func(*args, **kwargs)</code> 的结果。 如果 <em>self</em> 已死亡则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p></li><li><p><code>detach</code>()</p><p>如果 <em>self</em> 为存活状态则将其标记为已死亡，并返回元组 <code>(obj, func, args, kwargs)</code>。 如果 <em>self</em> 已死亡则返 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p></li><li><p><code>peek</code>()</p><p>如果 <em>self</em> 为存活状态则返回元组 <code>(obj, func, args, kwargs)</code>。 如果 <em>self</em> 已死亡则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p></li><li><p><code>alive</code></p><p>如果终结器为存活状态则该特征属性为真值，否则为假值。</p></li><li><p><code>atexit</code></p><p>一个可写的布尔型特征属性，默认为真值。 当程序退出时，它会调用所有 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize.atexit" target="_blank" rel="noopener"><code>atexit</code></a> 为真值的剩余存活终结器。 它们会按与创建时相反的顺序被调用。</p></li></ul></li><li><p><code>weakref.`</code>ReferenceType`</p><p>弱引用对象的类型对象。</p></li><li><p><code>weakref.`</code>ProxyType`</p><p>不可调用对象的代理的类型对象。</p></li><li><p><code>weakref.`</code>CallableProxyType`</p><p>可调用对象的代理的类型对象。</p></li><li><p><code>weakref.`</code>ProxyTypes`</p><p>包含所有代理的类型对象的序列。 这可以用于更方便地检测一个对象是否是代理，而不必依赖于两种代理对象的名称。</p></li><li><p><em>exception</em> <code>weakref.`</code>ReferenceError`</p><p>当一个代理对象被使用但其下层的对象已被收集时所引发的异常。 这等价于标准的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ReferenceError" target="_blank" rel="noopener"><code>ReferenceError</code></a> 异常。</p></li></ul><blockquote><p><a href="https://www.python.org/dev/peps/pep-0205" target="_blank" rel="noopener"><strong>PEP 205</strong></a> - 弱引用</p><p>此特性的提议和理由，包括早期实现的链接和其他语言中类似特性的相关信息。</p></blockquote><h2 id="弱引用对象"><a href="#弱引用对象" class="headerlink" title="弱引用对象"></a>弱引用对象</h2><p>弱引用对象没有 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref.__callback__" target="_blank" rel="noopener"><code>ref.__callback__</code></a> 以外的方法和属性。 一个弱引用对象如果存在，就允许通过调用它来获取引用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Object</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = weakref.ref(o)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o2 = r()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o <span class="keyword">is</span> o2</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>如果引用已不存在，则调用引用对象将返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> o, o2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(r())</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><p>检测一个弱引用对象是否仍然存在应该使用表达式 <code>ref() is not None</code>。 通常，需要使用引用对象的应用代码应当遵循这样的模式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># r is a weak reference object</span></span><br><span class="line">o = r()</span><br><span class="line"><span class="keyword">if</span> o <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># referent has been garbage collected</span></span><br><span class="line">    print(<span class="string">"Object has been deallocated; can't frobnicate."</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Object is still live!"</span>)</span><br><span class="line">    o.do_something_useful()</span><br></pre></td></tr></table></figure><p>使用单独的“存活”测试会在多线程应用中制造竞争条件；其他线程可能导致某个弱引用在该弱引用被调用前就失效；上述的写法在多线程应用和单线程应用中都是安全的。</p><p>特别版本的 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref</code></a> 对象可以通过子类化来创建。 在 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 的实现中就使用了这种方式来减少映射中每个条目的内存开销。 这对于将附加信息关联到引用的情况最为适用，但也可以被用于在调用中插入额外处理来提取引用。</p><p>这个例子演示了如何将 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref</code></a> 的一个子类用于存储有关对象的附加信息并在引用被访问时影响其所返回的值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedRef</span><span class="params">(weakref.ref)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ob, callback=None, /, **annotations)</span>:</span></span><br><span class="line">        super(ExtendedRef, self).__init__(ob, callback)</span><br><span class="line">        self.__counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> annotations.items():</span><br><span class="line">            setattr(self, k, v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a pair containing the referent and the number of</span></span><br><span class="line"><span class="string">        times the reference has been called.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ob = super(ExtendedRef, self).__call__()</span><br><span class="line">        <span class="keyword">if</span> ob <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.__counter += <span class="number">1</span></span><br><span class="line">            ob = (ob, self.__counter)</span><br><span class="line">        <span class="keyword">return</span> ob</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这个简单的例子演示了一个应用如何使用对象 ID 来提取之前出现过的对象。 然后对象的 ID 可以在其它数据结构中使用，而无须强制对象保持存活，但处于存活状态的对象也仍然可以通过 ID 来提取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line">_id2obj_dict = weakref.WeakValueDictionary()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remember</span><span class="params">(obj)</span>:</span></span><br><span class="line">    oid = id(obj)</span><br><span class="line">    _id2obj_dict[oid] = obj</span><br><span class="line">    <span class="keyword">return</span> oid</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">id2obj</span><span class="params">(oid)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _id2obj_dict[oid]</span><br></pre></td></tr></table></figure><h2 id="终结器对象"><a href="#终结器对象" class="headerlink" title="终结器对象"></a>终结器对象</h2><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize" target="_blank" rel="noopener"><code>finalize</code></a> 的主要好处在于它能更简便地注册回调函数，而无须保留所返回的终结器对象。 例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Object</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kenny = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weakref.finalize(kenny, <span class="keyword">print</span>, <span class="string">"You killed Kenny!"</span>)  </span><br><span class="line">&lt;finalize object at ...; <span class="keyword">for</span> <span class="string">'Object'</span> at ...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> kenny</span><br><span class="line">You killed Kenny!</span><br></pre></td></tr></table></figure><p>终结器也可以被直接调用。 但是终结器最多只能对回调函数发起一次调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(x, y, z)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"CALLBACK"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y + z</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = weakref.finalize(obj, callback, <span class="number">1</span>, <span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> f.alive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> f() == <span class="number">6</span></span><br><span class="line">CALLBACK</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="keyword">not</span> f.alive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()                     <span class="comment"># callback not called because finalizer dead</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> obj                 <span class="comment"># callback not called because finalizer dead</span></span><br></pre></td></tr></table></figure><p>你可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize.detach" target="_blank" rel="noopener"><code>detach()</code></a> 方法来注销一个终结器。 该方法将销毁终结器并返回其被创建时传给构造器的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = weakref.finalize(obj, callback, <span class="number">1</span>, <span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.detach()                                           </span><br><span class="line">(&lt;...Object object ...&gt;, &lt;function callback ...&gt;, (<span class="number">1</span>, <span class="number">2</span>), &#123;<span class="string">'z'</span>: <span class="number">3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newobj, func, args, kwargs = _</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="keyword">not</span> f.alive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> newobj <span class="keyword">is</span> obj</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> func(*args, **kwargs) == <span class="number">6</span></span><br><span class="line">CALLBACK</span><br></pre></td></tr></table></figure><p>除非你将 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize.atexit" target="_blank" rel="noopener"><code>atexit</code></a> 属性设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>，否则终结器在程序退出时如果仍然存活就将被调用。 例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weakref.finalize(obj, <span class="keyword">print</span>, <span class="string">"obj dead or exiting"</span>)</span><br><span class="line">&lt;finalize object at ...; <span class="keyword">for</span> <span class="string">'Object'</span> at ...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exit()</span><br><span class="line">obj dead <span class="keyword">or</span> exiting</span><br></pre></td></tr></table></figure><h2 id="比较终结器与-del-方法"><a href="#比较终结器与-del-方法" class="headerlink" title="比较终结器与 __del__() 方法"></a>比较终结器与 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法</h2><p>假设我们想创建一个类，用它的实例来代表临时目录。 当以下事件中的某一个发生时，这个目录应当与其内容一起被删除：</p><ul><li>对象被作为垃圾回收，</li><li>对象的 <code>remove()</code> 方法被调用，或</li><li>程序退出。</li></ul><p>我们可以尝试使用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法来实现这个类，如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TempDir</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = tempfile.mkdtemp()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            shutil.rmtree(self.name)</span><br><span class="line">            self.name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removed</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.remove()</span><br></pre></td></tr></table></figure><p>从 Python 3.4 开始，<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法不会再阻止循环引用被作为垃圾回收，并且模块全局变量在 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-interpreter-shutdown" target="_blank" rel="noopener">interpreter shutdown</a> 期间不会被强制设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。 因此这段代码在 CPython 上应该会正常运行而不会出现任何问题。</p><p>然而，<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法的处理会严重地受到具体实现的影响，因为它依赖于解释器垃圾回收实现方式的内部细节。</p><p>更健壮的替代方式可以是定义一个终结器，只引用它所需要的特定函数和对象，而不是获取对整个对象状态的访问权:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TempDir</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = tempfile.mkdtemp()</span><br><span class="line">        self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._finalizer()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removed</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._finalizer.alive</span><br></pre></td></tr></table></figure><p>像这样定义后，我们的终结器将只接受一个对其完成正确清理目录任务所需细节的引用。 如果对象一直未被作为垃圾回收，终结器仍会在退出时被调用。</p><p>基于弱引用的终结器还具有另一项优势，就是它们可被用来为定义由第三方控制的类注册终结器，例如当一个模块被卸载时运行特定代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref, sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unloading_module</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># implicit reference to the module globals from the function body</span></span><br><span class="line">weakref.finalize(sys.modules[__name__], unloading_module)</span><br></pre></td></tr></table></figure><p><strong>备注</strong>:</p><p> 如果当程序退出时你恰好在守护线程中创建终结器对象，则有可能该终结器不会在退出时被调用。 但是，在一个守护线程中 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#atexit.register" target="_blank" rel="noopener"><code>atexit.register()</code></a>, <code>try: ... finally: ...</code> 和 <code>with: ...</code> 同样不能保证执行清理。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-weakref-弱引用&quot;&gt;&lt;a href=&quot;#python-标准库-weakref-弱引用&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 weakref 弱引用&quot;&gt;&lt;/a&gt;python 标准库 weakref 弱引用&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/compress.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="weakref" scheme="https://pinghailinfeng.gitee.io/tags/weakref/"/>
    
  </entry>
  
  <entry>
    <title>python standard library cmath</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/10/python-standard-library-cmath/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/10/python-standard-library-cmath/</id>
    <published>2020-02-10T04:21:53.000Z</published>
    <updated>2020-02-10T06:05:38.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-cmath"><a href="#python-标准库-cmath" class="headerlink" title="python 标准库 cmath"></a>python 标准库 cmath</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200210_butterfly.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>患难可以试验一个人的品格；非常的境遇方才可以显出非常的气节；风平浪静的海面，所有船只都可以并驱竞胜；命运的铁拳击中要害的时候，只有大勇大智的人才能够处之泰然。</p><p>​                                                                                                                                             –    莎士比亚</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>这一模块提供了一些关于复数的数学函数。 该模块的函数的参数为整数、浮点数或复数。 这些函数的参数也可为一个拥有 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__complex__" target="_blank" rel="noopener"><code>__complex__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__float__" target="_blank" rel="noopener"><code>__float__()</code></a> 方法的 Python 对象，这些方法分别用于将对象转换为复数和浮点数，这些函数作用于转换后的结果。</p><h2 id="到极坐标和从极坐标的转换"><a href="#到极坐标和从极坐标的转换" class="headerlink" title="到极坐标和从极坐标的转换"></a>到极坐标和从极坐标的转换</h2><p>使用 <em>矩形坐标</em> 或 <em>笛卡尔坐标</em> 在内部存储 Python 复数 <code>z</code>。 这完全取决于它的 <em>实部</em> <code>z.real</code> 和 <em>虚部</em> <code>z.imag</code>。 换句话说:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z == z.real + z.imag*<span class="number">1j</span></span><br></pre></td></tr></table></figure><p><em>极坐标</em> 提供了另一种复数的表示方法。在极坐标中，一个复数 <em>z</em> 由模量 <em>r</em> 和相位角 <em>phi</em> 来定义。模量 <em>r</em> 是从 <em>z</em> 到坐标原点的距离，而相位角 <em>phi</em> 是以弧度为单位的，逆时针的，从正X轴到连接原点和 <em>z</em> 的线段间夹角的角度。</p><p>下面的函数可用于原生直角坐标与极坐标的相互转换。</p><ul><li><p><code>cmath.phase</code>(<em>x</em>)</p><p>将 <em>x</em> 的相位 (也称为 <em>x</em> 的 <em>参数</em>) 返回为一个浮点数。<code>phase(x)</code> 相当于 <code>math.atan2(x.imag, x.real)</code>。 结果处于 [-<em>π</em>, <em>π</em>] 之间，以及这个操作的分支切断处于负实轴上，从上方连续。 在支持有符号零的系统上（这包涵大多数当前的常用系统），这意味着结果的符号与 <code>x.imag</code> 的符号相同，即使 <code>x.imag</code> 的值是 0:</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>phase(complex(<span class="number">-1.0</span>, <span class="number">0.0</span>))</span><br><span class="line"><span class="number">3.141592653589793</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phase(complex(<span class="number">-1.0</span>, <span class="number">-0.0</span>))</span><br><span class="line"><span class="number">-3.141592653589793</span></span><br></pre></td></tr></table></figure><ul><li><p><code>cmath.polar</code>(<em>x</em>)</p><p>在极坐标中返回 <em>x</em> 的表达方式。返回一个数对 <code>(r, phi)</code>，<em>r</em> 是 <em>x</em> 的模数，<em>phi</em> 是 <em>x</em> 的相位角。 <code>polar(x)</code> 相当于 <code>(abs(x), phase(x))</code>。</p></li><li><p><code>cmath.rect</code>(<em>r</em>, <em>phi</em>)</p><p>通过极坐标的 <em>r</em> 和 <em>phi</em> 返回复数 <em>x</em>。相当于 <code>r * (math.cos(phi) + math.sin(phi)*1j)</code>。</p></li></ul><h2 id="幂函数与对数函数"><a href="#幂函数与对数函数" class="headerlink" title="幂函数与对数函数"></a>幂函数与对数函数</h2><ul><li><p><code>cmath.exp</code>(<em>x</em>)</p><p>返回 <em>e</em> 的 <em>x</em> 次方，<em>e</em> 是自然对数的底数。</p></li><li><p><code>cmath.log</code>(<em>x</em>[, <em>base</em>])</p><p>返回给定 <em>base</em> 的 <em>x</em> 的对数。如果没有给定 <em>base</em>，返回 <em>x</em> 的自然对数。 从 0 到 -∞ 存在一个分歧点，沿负实轴之上连续。</p></li><li><p><code>cmath.log10</code>(<em>x</em>)</p><p>返回底数为 10 的 <em>x</em> 的对数。它具有与 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#cmath.log" target="_blank" rel="noopener"><code>log()</code></a> 相同的分歧点。</p></li><li><p><code>cmath.sqrt</code>(<em>x</em>)</p><p>返回 <em>x</em> 的平方根。 它具有与 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#cmath.log" target="_blank" rel="noopener"><code>log()</code></a> 相同的分歧点。</p></li></ul><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><ul><li><p><code>cmath.acos</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反余弦。这里有两个分歧点：一个沿着实轴从 1 向右延伸到 ∞，从下面连续延伸。另外一个沿着实轴从 -1 向左延伸到 -∞，从上面连续延伸。</p></li><li><p><code>cmath.asin</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反正弦。它与 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#cmath.acos" target="_blank" rel="noopener"><code>acos()</code></a> 有相同的分歧点。</p></li><li><p><code>cmath.atan</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反正切。它具有两个分歧点：一个沿着虚轴从 <code>1j</code> 延伸到 <code>∞j</code>，向右持续延伸。另一个是沿着虚轴从 <code>-1j</code> 延伸到 <code>-∞j</code> ，向左持续延伸。</p></li><li><p><code>cmath.cos</code>(<em>x</em>)</p><p>返回 <em>x</em> 的余弦。</p></li><li><p><code>cmath.sin</code>(<em>x</em>)</p><p>返回 <em>x</em> 的正弦。</p></li><li><p><code>cmath.tan</code>(<em>x</em>)</p><p>返回 <em>x</em> 的正切。</p></li></ul><h2 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h2><ul><li><p><code>cmath.acosh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反双曲余弦。它有一个分歧点沿着实轴从 1 到 -∞ 向左延伸，从上方持续延伸。</p></li><li><p><code>cmath.asinh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反双曲正弦。它有两个分歧点：一个沿着虚轴从 <code>1j</code> 向右持续延伸到 <code>∞j</code>。另一个是沿着虚轴从 <code>-1j</code> 向左持续延伸到 <code>-∞j</code>。</p></li><li><p><code>cmath.atanh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反双曲正切。它有两个分歧点：一个是沿着实轴从 <code>1</code> 延展到 <code>∞</code>，从下面持续延展。另一个是沿着实轴从 <code>-1</code> 延展到 <code>-∞</code>，从上面持续延展。</p></li><li><p><code>cmath.cosh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的双曲余弦值。</p></li><li><p><code>cmath.sinh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的双曲正弦值。</p></li><li><p><code>cmath.tanh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的双曲正切值。</p></li></ul><h2 id="分类函数"><a href="#分类函数" class="headerlink" title="分类函数"></a>分类函数</h2><ul><li><p><code>cmath.isfinite</code>(<em>x</em>)</p><p>如果 <em>x</em> 的实部和虚部都是有限的，则返回 <code>True</code>，否则返回 <code>False</code>。<em>3.2 新版功能.</em></p></li><li><p><code>cmath.isinf</code>(<em>x</em>)</p><p>如果 <em>x</em> 的实部或者虚部是无穷大的，则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p><code>cmath.isnan</code>(<em>x</em>)</p><p>如果 <em>x</em> 的实部或者虚部是 NaN，则返回 <code>True</code> ，否则返回 <code>False</code>。</p></li><li><p><code>cmath.isclose</code>(<em>a</em>, <em>b</em>, <em>**, </em>rel_tol=1e-09<em>, </em>abs_tol=0.0*)</p><p>若 <em>a</em> 和 <em>b</em> 的值比较接近则返回 <code>True</code>，否则返回 <code>False</code>。根据给定的绝对和相对容差确定两个值是否被认为是接近的。<em>rel_tol</em> 是相对容差 —— 它是 <em>a</em> 和 <em>b</em> 之间允许的最大差值，相对于 <em>a</em> 或 <em>b</em> 的较大绝对值。例如，要设置5％的容差，请传递 <code>rel_tol=0.05</code> 。默认容差为 <code>1e-09</code>，确保两个值在大约9位十进制数字内相同。 <em>rel_tol</em> 必须大于零。<em>abs_tol</em> 是最小绝对容差 —— 对于接近零的比较很有用。 <em>abs_tol</em> 必须至少为零。如果没有错误发生，结果将是： <code>abs(a-b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)</code> 。IEEE 754特殊值 <code>NaN</code> ， <code>inf</code> 和<code>-inf</code> 将根据IEEE规则处理。具体来说， <code>NaN</code> 不被认为接近任何其他值，包括 <code>NaN</code> 。 <code>inf</code> 和 <code>-inf</code> 只被认为接近自己。</p><blockquote><p><a href="https://www.python.org/dev/peps/pep-0485" target="_blank" rel="noopener"><strong>PEP 485</strong></a> —— 用于测试近似相等的函数</p></blockquote></li></ul><h2 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h2><ul><li><p><code>cmath.pi</code></p><p>数学常数 <em>π</em> ，作为一个浮点数。</p></li><li><p><code>cmath.e</code></p><p>数学常数 <em>e</em> ，作为一个浮点数。</p></li><li><p><code>cmath.tau</code></p><p>数学常数 <em>τ</em> ，作为一个浮点数。<em>3.6 新版功能.</em></p></li><li><p><code>cmath.inf</code></p><p>浮点正无穷大。相当于 <code>float(&#39;inf&#39;)</code>。<em>3.6 新版功能.</em></p></li><li><p><code>cmath.infj</code></p><p>具有零实部和正无穷虚部的复数。相当于 <code>complex(0.0, float(&#39;inf&#39;))</code>。<em>3.6 新版功能.</em></p></li><li><p><code>cmath.nan</code></p><p>浮点“非数字”（NaN）值。相当于 <code>float(&#39;nan&#39;)</code>。<em>3.6 新版功能.</em></p></li><li><p><code>cmath.nanj</code></p><p>具有零实部和 NaN 虚部的复数。相当于 <code>complex(0.0, float(&#39;nan&#39;))</code>。</p></li></ul><p>请注意，函数的选择与模块 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#module-math" target="_blank" rel="noopener"><code>math</code></a> 中的函数选择相似，但不完全相同。 拥有两个模块的原因是因为有些用户对复数不感兴趣，甚至根本不知道它们是什么。它们宁愿 <code>math.sqrt(-1)</code> 引发异常，也不想返回一个复数。 另请注意，被 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#module-cmath" target="_blank" rel="noopener"><code>cmath</code></a> 定义的函数始终会返回一个复数，尽管答案可以表示为一个实数（在这种情况下，复数的虚数部分为零）。</p><p>关于分歧点的注释：它们是沿着给定函数无法连续的曲线。它们是许多复杂函数的必要特征。假设您需要使用复杂函数进行计算，您将了解分歧点。请参阅几乎所有关于复杂变量的（不太基本）的书来进行启发。关于分歧点数值目的的正确选择信息，应提供以下良好参考.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-cmath&quot;&gt;&lt;a href=&quot;#python-标准库-cmath&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 cmath&quot;&gt;&lt;/a&gt;python 标准库 cmath&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200210_butterfly.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="cmath" scheme="https://pinghailinfeng.gitee.io/tags/cmath/"/>
    
  </entry>
  
  <entry>
    <title>python standard library fractions</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/09/python-standard-library-fractions/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/09/python-standard-library-fractions/</id>
    <published>2020-02-09T14:56:42.000Z</published>
    <updated>2020-02-10T03:35:04.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-fractions-分数"><a href="#python-标准库-fractions-分数" class="headerlink" title="python 标准库 fractions 分数"></a>python 标准库 fractions 分数</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200210_hope.jpg?raw=true" alt></p><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/fractions.py" target="_blank" rel="noopener">Lib/fractions.py</a></p><h2 id="模块概述"><a href="#模块概述" class="headerlink" title="模块概述"></a>模块概述</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#module-fractions" target="_blank" rel="noopener"><code>fractions</code></a> 模块支持分数运算。</p><p>分数实例可以由一对整数，一个分数，或者一个字符串构建而成。</p><ul><li><p><em>class</em> <code>fractions.Fraction</code>(<em>numerator=0</em>, <em>denominator=1</em>)</p></li><li><p><em>class</em> <code>fractions.Fraction</code>(<em>other_fraction</em>)</p></li><li><p><em>class</em> <code>fractions.Fraction</code>(<em>float</em>)</p></li><li><p><em>class</em> <code>fractions.Fraction</code>(<em>decimal</em>)</p></li><li><p><em>class</em> <code>fractions.Fraction</code>(<em>string</em>)</p><p>第一个版本要求 <em>numerator</em> 和 <em>denominator</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational" target="_blank" rel="noopener"><code>numbers.Rational</code></a> 的实例，并返回一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 实例，其值为 <code>numerator/denominator</code>。 如果 <em>denominator</em> 为 <code>0</code> 将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ZeroDivisionError" target="_blank" rel="noopener"><code>ZeroDivisionError</code></a>。 第二个版本要求 <em>other_fraction</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational" target="_blank" rel="noopener"><code>numbers.Rational</code></a> 的实例，并返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 实例且与传入值相等。 下两个版本接受 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>decimal.Decimal</code></a> 的实例，并返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 实例且与传入值完全相等。 请注意由于二进制浮点数通常存在的问题 (参见 <a href="https://docs.python.org/zh-cn/3.8/tutorial/floatingpoint.html#tut-fp-issues" target="_blank" rel="noopener">浮点算术：争议和限制</a>)，<code>Fraction(1.1)</code> 的参数并不会精确等于 11/10，因此 <code>Fraction(1.1)</code> 也 <em>不会</em> 返回用户所期望的 <code>Fraction(11, 10)</code>。 （请参阅下文中 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction.limit_denominator" target="_blank" rel="noopener"><code>limit_denominator()</code></a> 方法的文档。） 构造器的最后一个版本接受一个字符串或 unicode 实例。 此实例的通常形式为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sign] numerator [<span class="string">'/'</span> denominator]</span><br></pre></td></tr></table></figure><p>其中的可选项 <code>sign</code> 可以为 ‘+’ 或 ‘-‘ 并且 <code>numerator</code> 和 <code>denominator</code> (如果存在) 是十进制数码的字符串。 此外，<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 构造器所接受的任何表示一个有限值的字符串也都为 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 构造器所接受。 不论哪种形式的输入字符串也都可以带有前缀和/或后缀的空格符。 这里是一些示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">16</span>, <span class="number">-10</span>)</span><br><span class="line">Fraction(<span class="number">-8</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">123</span>)</span><br><span class="line">Fraction(<span class="number">123</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction()</span><br><span class="line">Fraction(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'3/7'</span>)</span><br><span class="line">Fraction(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">' -3/7 '</span>)</span><br><span class="line">Fraction(<span class="number">-3</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'1.414213 \t\n'</span>)</span><br><span class="line">Fraction(<span class="number">1414213</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'-.125'</span>)</span><br><span class="line">Fraction(<span class="number">-1</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'7e-6'</span>)</span><br><span class="line">Fraction(<span class="number">7</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">2.25</span>)</span><br><span class="line">Fraction(<span class="number">9</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">1.1</span>)</span><br><span class="line">Fraction(<span class="number">2476979795053773</span>, <span class="number">2251799813685248</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(Decimal(<span class="string">'1.1'</span>))</span><br><span class="line">Fraction(<span class="number">11</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 类继承自抽象基类 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational" target="_blank" rel="noopener"><code>numbers.Rational</code></a>，并实现了该类的所有方法和操作。 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 实例是可哈希的，并应当被视为不可变对象。 此外，<a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 还具有以下属性和方法：</p><ul><li><p><code>numerator</code></p><p>最简分数形式的分子。</p></li><li><p><code>denominator</code></p><p>最简分数形式的分母。</p></li><li><p><code>as_integer_ratio</code>()</p><p>返回由两个整数组成的元组，两数之比等于该分数的值且其分母为正数。<em>3.8 新版功能.</em></p></li><li><p><code>from_float</code>(<em>flt</em>) : classmethod</p><p>此类方法可构造一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 来表示 <em>flt</em> 的精确值，该参数必须是一个 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>。 请注意 <code>Fraction.from_float(0.3)</code> 的值并不等于 <code>Fraction(3, 10)</code>。</p></li><li><p><code>from_decimal</code>(<em>dec</em>) : classmethod</p><p>此类方法可构造一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 来表示 <em>dec</em> 的精确值，该参数必须是一个 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>decimal.Decimal</code></a> 实例。</p></li><li><p><code>limit_denominator</code>(<em>max_denominator=1000000</em>)</p><p>找到并返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 使得其值最接近 <code>self</code> 并且分母不大于 max_denominator。 此方法适用于找出给定浮点数的有理数近似值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'3.1415926535897932'</span>).limit_denominator(<span class="number">1000</span>)</span><br><span class="line">Fraction(<span class="number">355</span>, <span class="number">113</span>)</span><br></pre></td></tr></table></figure><p>或是用来恢复被表示为一个浮点数的有理数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi, cos</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(cos(pi/<span class="number">3</span>))</span><br><span class="line">Fraction(<span class="number">4503599627370497</span>, <span class="number">9007199254740992</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(cos(pi/<span class="number">3</span>)).limit_denominator()</span><br><span class="line">Fraction(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">1.1</span>).limit_denominator()</span><br><span class="line">Fraction(<span class="number">11</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>__floor__</code>()</p><p>返回最大的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> <code>&lt;= self</code>。 此方法也可通过 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.floor" target="_blank" rel="noopener"><code>math.floor()</code></a> 函数来使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> floor</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floor(Fraction(<span class="number">355</span>, <span class="number">113</span>))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p><code>__ceil__</code>()</p><p>返回最小的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> <code>&gt;= self</code>。 此方法也可通过 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.ceil" target="_blank" rel="noopener"><code>math.ceil()</code></a> 函数来使用。</p></li><li><p><code>__round__</code>()</p></li><li><p><code>__round__</code>(<em>ndigits</em>)</p><p>第一个版本返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 使得其值最接近 <code>self</code>，位值为二分之一时只对偶数舍入。第二个版本会将 <code>self</code> 舍入到最接近 <code>Fraction(1, 10**ndigits)</code> 的倍数（如果 <code>ndigits</code> 为负值则为逻辑运算），位值为二分之一时同样只对偶数舍入。 此方法也可通过 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#round" target="_blank" rel="noopener"><code>round()</code></a> 函数来使用</p></li></ul></li></ul><ul><li><p><code>fractions.gcd</code>(<em>a</em>, <em>b</em>)</p><p>返回整数 <em>a</em> 和 <em>b</em> 的最大公约数。如果 <em>a</em> 或 <em>b</em> 之一非零，则 <code>gcd(a, b)</code> 的绝对值是能同时整除 <em>a</em> 和 <em>b</em> 的最大整数。若 <em>b</em> 非零，则 <code>gcd(a,b)</code> 与 <em>b</em> 同号；否则返回值与 <em>a</em> 同号。<code>gcd(0, 0)</code> 返回 <code>0</code>。</p><p><em>3.5 版后已移除:</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.gcd" target="_blank" rel="noopener"><code>math.gcd()</code></a> 取代.</p></li></ul><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-fractions-分数&quot;&gt;&lt;a href=&quot;#python-标准库-fractions-分数&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 fractions 分数&quot;&gt;&lt;/a&gt;python 标准库 fractions 分数&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200210_hope.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="fractions" scheme="https://pinghailinfeng.gitee.io/tags/fractions/"/>
    
  </entry>
  
  <entry>
    <title>python standard library json</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/08/python-standard-library-json/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/08/python-standard-library-json/</id>
    <published>2020-02-08T03:53:06.000Z</published>
    <updated>2020-02-10T03:43:31.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-json"><a href="#python-标准库-json" class="headerlink" title="python 标准库 json"></a>python 标准库 json</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20191223_blog_6.jpg?raw=true" alt></p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=25706282&auto=0&height=66"></iframe><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/json/__init__.py" target="_blank" rel="noopener">Lib/json/<strong>init</strong>.py</a></p><p> <a href="http://json.org/" target="_blank" rel="noopener">JSON (JavaScript Object Notation)</a>，由 <a href="https://tools.ietf.org/html/rfc7159.html" target="_blank" rel="noopener"><strong>RFC 7159</strong></a> (which obsoletes <a href="https://tools.ietf.org/html/rfc4627.html" target="_blank" rel="noopener"><strong>RFC 4627</strong></a>) 和 <a href="http://www.ecma-international.org/publications/standards/Ecma-404.htm" target="_blank" rel="noopener">ECMA-404</a> 指定，是一个受 <a href="https://en.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a> 的对象字面量语法启发的轻量级数据交换格式，尽管它不仅仅是一个严格意义上的 JavaScript 的字集。</p><p> <a href="https://docs.python.org/zh-cn/3.8/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 提供了与标准库 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#module-marshal" target="_blank" rel="noopener"><code>marshal</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 相似的API接口。 </p><p> 对基本的 Python 对象层次结构进行编码： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps([<span class="string">'foo'</span>, &#123;<span class="string">'bar'</span>: (<span class="string">'baz'</span>, <span class="literal">None</span>, <span class="number">1.0</span>, <span class="number">2</span>)&#125;])</span><br><span class="line"><span class="string">'["foo", &#123;"bar": ["baz", null, 1.0, 2]&#125;]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(<span class="string">"\"foo\bar"</span>))</span><br><span class="line"><span class="string">"\"foo\bar"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(<span class="string">'\u1234'</span>))</span><br><span class="line"><span class="string">"\u1234"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(<span class="string">'\\'</span>))</span><br><span class="line"><span class="string">"\\"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(&#123;<span class="string">"c"</span>: <span class="number">0</span>, <span class="string">"b"</span>: <span class="number">0</span>, <span class="string">"a"</span>: <span class="number">0</span>&#125;, sort_keys=<span class="literal">True</span>))</span><br><span class="line">&#123;<span class="string">"a"</span>: <span class="number">0</span>, <span class="string">"b"</span>: <span class="number">0</span>, <span class="string">"c"</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io = StringIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dump([<span class="string">'streaming API'</span>], io)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io.getvalue()</span><br><span class="line"><span class="string">'["streaming API"]'</span></span><br></pre></td></tr></table></figure><p> 紧凑编码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="string">'4'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">7</span>&#125;], separators=(<span class="string">','</span>, <span class="string">':'</span>))</span><br><span class="line"><span class="string">'[1,2,3,&#123;"4":5,"6":7&#125;]'</span></span><br></pre></td></tr></table></figure><p>美化输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(&#123;<span class="string">'4'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">7</span>&#125;, sort_keys=<span class="literal">True</span>, indent=<span class="number">4</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"4"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">"6"</span>: <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON解码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'["foo", &#123;"bar":["baz", null, 1.0, 2]&#125;]'</span>)</span><br><span class="line">[<span class="string">'foo'</span>, &#123;<span class="string">'bar'</span>: [<span class="string">'baz'</span>, <span class="literal">None</span>, <span class="number">1.0</span>, <span class="number">2</span>]&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'"\\"foo\\bar"'</span>)</span><br><span class="line"><span class="string">'"foo\x08ar'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io = StringIO(<span class="string">'["streaming API"]'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.load(io)</span><br><span class="line">[<span class="string">'streaming API'</span>]</span><br></pre></td></tr></table></figure><p> 特殊JSON对象解码: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">as_complex</span><span class="params">(dct)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="string">'__complex__'</span> <span class="keyword">in</span> dct:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> complex(dct[<span class="string">'real'</span>], dct[<span class="string">'imag'</span>])</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> dct</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'&#123;"__complex__": true, "real": 1, "imag": 2&#125;'</span>,</span><br><span class="line"><span class="meta">... </span>    object_hook=as_complex)</span><br><span class="line">(<span class="number">1</span>+<span class="number">2j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'1.1'</span>, parse_float=decimal.Decimal)</span><br><span class="line">Decimal(<span class="string">'1.1'</span>)</span><br></pre></td></tr></table></figure><p>扩展 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder" target="_blank" rel="noopener"><code>JSONEncoder</code></a>: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ComplexEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, obj)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> isinstance(obj, complex):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> [obj.real, obj.imag]</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># Let the base class default method raise the TypeError</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> json.JSONEncoder.default(self, obj)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(<span class="number">2</span> + <span class="number">1j</span>, cls=ComplexEncoder)</span><br><span class="line"><span class="string">'[2.0, 1.0]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ComplexEncoder().encode(<span class="number">2</span> + <span class="number">1j</span>)</span><br><span class="line"><span class="string">'[2.0, 1.0]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ComplexEncoder().iterencode(<span class="number">2</span> + <span class="number">1j</span>))</span><br><span class="line">[<span class="string">'[2.0'</span>, <span class="string">', 1.0'</span>, <span class="string">']'</span>]</span><br></pre></td></tr></table></figure><p> 从命令行使用 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#module-json.tool" target="_blank" rel="noopener"><code>json.tool</code></a> 来验证并美化输出： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="string">'&#123;"json":"obj"&#125;'</span> | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"json"</span>: <span class="string">"obj"</span></span><br><span class="line">&#125;</span><br><span class="line">$ echo <span class="string">'&#123;1.2:3.4&#125;'</span> | python -m json.tool</span><br><span class="line">Expecting property name enclosed <span class="keyword">in</span> double quotes: line <span class="number">1</span> column <span class="number">2</span> (char <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p> 详细文档请参见 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json-commandline" target="_blank" rel="noopener">命令行界面</a>。 </p><blockquote><p> JSON 是 <a href="http://yaml.org/" target="_blank" rel="noopener">YAML</a> 1.2 的一个子集。由该模块的默认设置生成的 JSON （尤其是默认的 “分隔符” 设置值）也是 YAML 1.0 and 1.1 的一个子集。因此该模块也能够用于序列化为 YAML。 </p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li><p><code>json.dump</code>(<em>obj</em>, <em>fp</em>, <strong><em>, </em>skipkeys=False<em>, </em>ensure_ascii=True<em>, </em>check_circular=True<em>, </em>allow_nan=True<em>, </em>cls=None<em>, </em>indent=None<em>, </em>separators=None<em>, </em>default=None<em>, </em>sort_keys=False<em>, </em></strong>kw*) </p><p> 使用这个 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#py-to-json-table" target="_blank" rel="noopener">转换表</a> 将 <em>obj</em> 序列化为 JSON 格式化流形式的 <em>fp</em> (支持 <code>.write()</code> 的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-like-object" target="_blank" rel="noopener">file-like object</a>)。 </p><p>如果 <em>skipkeys</em> 是 true （默认为 <code>False</code>），那么那些不是基本对象（包括 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#bool" target="_blank" rel="noopener"><code>bool</code></a>、<code>None</code>）的字典的键会被跳过；否则引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 模块始终产生 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 对象而非 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 对象。因此，<code>fp.write()</code> 必须支持 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 输入。</p><p>如果 <em>ensure_ascii</em> 是 true （即默认值），输出保证将所有输入的非 ASCII 字符转义。如果 <em>ensure_ascii</em> 是 false，这些字符会原样输出。</p><p>如果 <em>check_circular</em> 是为假值 (默认为 <code>True</code>)，那么容器类型的循环引用检验会被跳过并且循环引用会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a> (或者更糟的情况)。</p><p>如果 <em>allow_nan</em> 是 false（默认为 <code>True</code>），那么在对严格 JSON 规格范围外的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 类型值（<code>nan</code>、<code>inf</code> 和 <code>-inf</code>）进行序列化时会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。如果 <em>allow_nan</em> 是 true，则使用它们的 JavaScript 等价形式（<code>NaN</code>、<code>Infinity</code> 和 <code>-Infinity</code>）。</p><p>如果 <em>indent</em> 是一个非负整数或者字符串，那么 JSON 数组元素和对象成员会被美化输出为该值指定的缩进等级。如果缩进等级为零、负数或者 <code>&quot;&quot;</code>，则只会添加换行符。<code>None（默认值）选择最紧凑的表达。使用一个正整数会让每一层缩进同样数量的空格。如果 *indent* 是一个字符串（比如 &quot;\t&quot;</code>），那个字符串会被用于缩进每一层。</p><p><em>在 3.2 版更改:</em> 允许使用字符串作为 <em>indent</em> 而不再仅仅是整数。</p><p>当指定时，<em>separators</em> 应当是一个 <code>(item_separator, key_separator)</code> 元组。当 <em>indent</em> 为 <code>None</code> 时，默认值取 <code>(&#39;, &#39;, &#39;: &#39;)</code>，否则取 <code>(&#39;,&#39;, &#39;: &#39;)</code>。为了得到最紧凑的 JSON 表达式，你应该指定其为 <code>(&#39;,&#39;, &#39;:&#39;)</code> 以消除空白字符。</p><p><em>在 3.4 版更改:</em> 现当 <em>indent</em> 不是 <code>None</code> 时，采用 <code>(&#39;,&#39;, &#39;: &#39;)</code> 作为默认值。</p><p>当 <em>default</em> 被指定时，其应该是一个函数，每当某个对象无法被序列化时它会被调用。它应该返回该对象的一个可以被 JSON 编码的版本或者引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。如果没有被指定，则会直接引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p><p>如果 <em>sort_keys</em> 是 true（默认为 <code>False</code>），那么字典的输出会以键的顺序排序。</p><p>为了使用一个自定义的 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder" target="_blank" rel="noopener"><code>JSONEncoder</code></a> 子类（比如：覆盖了 <code>default()</code> 方法来序列化额外的类型）， 通过 <em>cls</em> 关键字参数来指定；否则将使用 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder" target="_blank" rel="noopener"><code>JSONEncoder</code></a>。</p></li><li><p>json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)</p><p> 使用这个 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#py-to-json-table" target="_blank" rel="noopener">转换表</a> 将 <em>obj</em> 序列化为 JSON 格式的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>。 其参数的含义与 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.dump" target="_blank" rel="noopener"><code>dump()</code></a> 中的相同。 </p></li><li><p><code>json.load</code>(<em>fp</em>, <strong><em>, </em>cls=None<em>, </em>object_hook=None<em>, </em>parse_float=None<em>, </em>parse_int=None<em>, </em>parse_constant=None<em>, </em>object_pairs_hook=None<em>, </em></strong>kw*) </p><p>使用这个 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json-to-py-table" target="_blank" rel="noopener">转换表</a> 将 <em>fp</em> (一个支持 <code>.read()</code> 并包含一个 JSON 文档的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-text-file" target="_blank" rel="noopener">text file</a> 或者 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a>) 反序列化为一个 Python 对象。</p><p><em>object_hook</em> 是一个可选的函数，它会被调用于每一个解码出的对象字面量（即一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>）。<em>object_hook</em> 的返回值会取代原本的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>。这一特性能够被用于实现自定义解码器（如 <a href="http://www.jsonrpc.org/" target="_blank" rel="noopener">JSON-RPC</a> 的类型提示)。</p><p><em>object_pairs_hook</em> 是一个可选的函数，它会被调用于每一个有序列表对解码出的对象字面量。 <em>object_pairs_hook</em> 的返回值将会取代原本的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 。这一特性能够被用于实现自定义解码器。如果 <em>object_hook</em> 也被定义， <em>object_pairs_hook</em> 优先。</p><p><em>在 3.1 版更改:</em> 添加了对 <em>object_pairs_hook</em> 的支持。</p><p><em>parse_float</em> ，如果指定，将与每个要解码 JSON 浮点数的字符串一同调用。默认状态下，相当于 <code>float(num_str)</code> 。可以用于对 JSON 浮点数使用其它数据类型和语法分析程序 （比如 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>decimal.Decimal</code></a> ）。</p><p><em>parse_int</em> ，如果指定，将与每个要解码 JSON 整数的字符串一同调用。默认状态下，相当于 <code>int(num_str)</code> 。可以用于对 JSON 整数使用其它数据类型和语法分析程序 （比如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> ）。</p><p><em>parse_constant</em> ，如果指定，将要与以下字符串中的一个一同调用： <code>&#39;-Infinity&#39;</code> ， <code>&#39;Infinity&#39;</code> ， <code>&#39;NaN&#39;</code> 。如果遇到无效的 JSON 数字则可以使用它引发异常。</p><p><em>在 3.1 版更改:</em> <em>parse_constant</em> 不再调用 ‘null’ ， ‘true’ ， ‘false’ 。</p><p>要使用自定义的 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecoder" target="_blank" rel="noopener"><code>JSONDecoder</code></a> 子类，用 <code>cls</code> 指定他；否则使用 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecoder" target="_blank" rel="noopener"><code>JSONDecoder</code></a> 。额外的关键词参数会通过类的构造函数传递。</p><p>如果反序列化的数据不是有效 JSON 文档，引发 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecodeError" target="_blank" rel="noopener"><code>JSONDecodeError</code></a> 错误。</p><p><em>在 3.6 版更改:</em> 所有的可选参数现在是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#keyword-only-parameter" target="_blank" rel="noopener">keyword-only</a> 的了。</p><p><em>在 3.6 版更改:</em> <em>fp</em> 现在可以是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a> 。输入编码应当是 UTF-8 ， UTF-16 或者 UTF-32 。</p></li><li><p><code>json.loads</code>(<em>s</em>, <strong><em>, </em>cls=None<em>, </em>object_hook=None<em>, </em>parse_float=None<em>, </em>parse_int=None<em>, </em>parse_constant=None<em>, </em>object_pairs_hook=None<em>, </em></strong>kw*) </p><p>使用这个 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json-to-py-table" target="_blank" rel="noopener">转换表</a> 将 <em>s</em> (一个包含 JSON 文档的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 实例) 反序列化为 Python 对象。</p><p>除了<em>encoding</em>被忽略和弃用自 Python 3.1 以来，其他参数的含义与 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.load" target="_blank" rel="noopener"><code>load()</code></a> 中相同。</p><p>如果反序列化的数据不是有效 JSON 文档，引发 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecodeError" target="_blank" rel="noopener"><code>JSONDecodeError</code></a> 错误。</p><p><em>Deprecated since version 3.1, will be removed in version 3.9:</em> <em>encoding</em> 关键字参数。</p><p><em>在 3.6 版更改:</em> <em>s</em> 现在可以为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 类型。 输入编码应为 UTF-8, UTF-16 或 UTF-32。</p></li></ul><h2 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h2><ul><li><p><em>class</em> <code>json.JSONDecoder</code>(<em>**, </em>object_hook=None<em>, </em>parse_float=None<em>, </em>parse_int=None<em>, </em>parse_constant=None<em>, </em>strict=True<em>, </em>object_pairs_hook=None*) </p><p>简单的JSON解码器。</p><p>默认情况下，解码执行以下翻译:</p><p>| JSON          | Python |<br>| :———— | :—– |<br>| object        | dict   |<br>| array         | list   |<br>| string        | str    |<br>| number (int)  | int    |<br>| number (real) | float  |<br>| true          | True   |<br>| false         | False  |<br>| null          | None   |</p></li></ul><p>​      它还将“NaN”、“Infinity”和“-Infinity”理解为它们对应的“float”值，这超出了JSON规范。</p><p>​    <em>object_hook</em> ，如果指定，会被每个解码的 JSON 对象的结果调用，并且返回值会替代给定 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 。它可被用于提供自定义反序列化（比如去支持 JSON-RPC 类的暗示）。</p><p>如果指定了 <em>object_pairs_hook</em> 则它将被调用并传入以对照值有序列表进行解码的每个 JSON 对象的结果。 <em>object_pairs_hook</em> 的结果值将被用来替代 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>。 这一特性可被用于实现自定义解码器。 如果还定义了 <em>object_hook</em>，则 <em>object_pairs_hook</em> 的优先级更高。</p><p><em>在 3.1 版更改:</em> 添加了对 <em>object_pairs_hook</em> 的支持。</p><p><em>parse_float</em> ，如果指定，将与每个要解码 JSON 浮点数的字符串一同调用。默认状态下，相当于 <code>float(num_str)</code> 。可以用于对 JSON 浮点数使用其它数据类型和语法分析程序 （比如 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>decimal.Decimal</code></a> ）。</p><p><em>parse_int</em> ，如果指定，将与每个要解码 JSON 整数的字符串一同调用。默认状态下，相当于 <code>int(num_str)</code> 。可以用于对 JSON 整数使用其它数据类型和语法分析程序 （比如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> ）。</p><p><em>parse_constant</em> ，如果指定，将要与以下字符串中的一个一同调用： <code>&#39;-Infinity&#39;</code> ， <code>&#39;Infinity&#39;</code> ， <code>&#39;NaN&#39;</code> 。如果遇到无效的 JSON 数字则可以使用它引发异常。</p><p>如果 <em>strict</em> 为 false （默认为 <code>True</code> ），那么控制字符将被允许在字符串内。在此上下文中的控制字符编码在范围 0–31 内的字符，包括 <code>&#39;\t&#39;</code> (制表符）， <code>&#39;\n&#39;</code> ， <code>&#39;\r&#39;</code> 和 <code>&#39;\0&#39;</code> 。</p><p>如果反序列化的数据不是有效 JSON 文档，引发 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecodeError" target="_blank" rel="noopener"><code>JSONDecodeError</code></a> 错误。</p><p><em>在 3.6 版更改:</em> 所有形参现在都是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#keyword-only-parameter" target="_blank" rel="noopener">仅限关键字参数</a>。</p><ul><li><p><code>decode</code>(<em>s</em>) </p><p>返回 <em>s</em> 的 Python 表示形式（包含一个 JSON 文档的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 实例）。</p><p>如果给定的 JSON 文档无效则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecodeError" target="_blank" rel="noopener"><code>JSONDecodeError</code></a>。</p></li><li><p><code>raw_decode</code>(<em>s</em>) </p><p>从 <em>s</em> 中解码出 JSON 文档（以 JSON 文档开头的一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 对象）并返回一个 Python 表示形式为 2 元组以及指明该文档在 <em>s</em> 中结束位置的序号。</p><p>这可以用于从一个字符串解码JSON文档，该字符串的末尾可能有无关的数据。</p></li></ul><ul><li><p><em>lass</em> <code>json.JSONEncoder</code>(<em>**, </em>skipkeys=False<em>, </em>ensure_ascii=True<em>, </em>check_circular=True<em>, </em>allow_nan=True<em>, </em>sort_keys=False<em>, </em>indent=None<em>, </em>separators=None<em>, </em>default=None*) </p><p>用于Python数据结构的可扩展JSON编码器。</p><p>默认支持以下对象和类型：</p><p>| Python                              | JSON   |<br>| :———————————- | :—– |<br>| dict                                | object |<br>| list, tuple                         | array  |<br>| str                                 | string |<br>| int, float, int 和 float 派生的枚举 | number |<br>| True                                | true   |<br>| False                               | false  |<br>| None                                | null   |</p><p><em>在 3.4 版更改:</em> 添加了对 int 和 float 派生的枚举类的支持</p><p>为了将其拓展至识别其他对象，需要子类化并实现 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder.default" target="_blank" rel="noopener"><code>default()</code></a> 方法于另一种返回 <code>o</code> 的可序列化对象的方法如果可行，否则它应该调用超类实现（来引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> ）。</p><p>如果 <em>skipkeys</em> 为假值（默认），则尝试对不是 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 或 <code>None</code> 的键进行编码将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 如果 <em>skipkeys</em> 为真值，这些条目将被直接跳过。</p><p>如果 <em>ensure_ascii</em> 是 true （即默认值），输出保证将所有输入的非 ASCII 字符转义。如果 <em>ensure_ascii</em> 是 false，这些字符会原样输出。</p><p>如果 <em>check_circular</em> 为 true （默认），那么列表，字典，和自定义编码的对象在编码期间会被检查重复循环引用防止无限递归（无限递归将导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a> ）。否则，这样进行检查。</p><p>如果 <em>allow_nan</em> 为 true （默认），那么 <code>NaN</code> ， <code>Infinity</code> ，和 <code>-Infinity</code> 进行编码。此行为不符合 JSON 规范，但与大多数的基于 Javascript 的编码器和解码器一致。否则，它将是一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 来编码这些浮点数。</p><p>如果 <em>sort_keys</em> 为 true （默认为： <code>False</code> ），那么字典的输出是按照键排序；这对回归测试很有用，以确保可以每天比较 JSON 序列化。</p><p>如果 <em>indent</em> 是一个非负整数或者字符串，那么 JSON 数组元素和对象成员会被美化输出为该值指定的缩进等级。如果缩进等级为零、负数或者 <code>&quot;&quot;</code>，则只会添加换行符。<code>None（默认值）选择最紧凑的表达。使用一个正整数会让每一层缩进同样数量的空格。如果 *indent* 是一个字符串（比如 &quot;\t&quot;</code>），那个字符串会被用于缩进每一层。</p><p><em>在 3.2 版更改:</em> 允许使用字符串作为 <em>indent</em> 而不再仅仅是整数。</p><p>当指定时，<em>separators</em> 应当是一个 <code>(item_separator, key_separator)</code> 元组。当 <em>indent</em> 为 <code>None</code> 时，默认值取 <code>(&#39;, &#39;, &#39;: &#39;)</code>，否则取 <code>(&#39;,&#39;, &#39;: &#39;)</code>。为了得到最紧凑的 JSON 表达式，你应该指定其为 <code>(&#39;,&#39;, &#39;:&#39;)</code> 以消除空白字符。</p><p><em>在 3.4 版更改:</em> 现当 <em>indent</em> 不是 <code>None</code> 时，采用 <code>(&#39;,&#39;, &#39;: &#39;)</code> 作为默认值。</p><p>当 <em>default</em> 被指定时，其应该是一个函数，每当某个对象无法被序列化时它会被调用。它应该返回该对象的一个可以被 JSON 编码的版本或者引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。如果没有被指定，则会直接引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p><p><em>在 3.6 版更改:</em> 所有形参现在都是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#keyword-only-parameter" target="_blank" rel="noopener">仅限关键字参数</a>。</p><ul><li><p><code>default</code>(<em>o</em>) </p><p>在子类中实现这种方法使其返回 <em>o</em> 的可序列化对象，或者调用基础实现（引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> ）。</p><p>比如说，为了支持任意迭代器，你可以像这样实现默认设置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, o)</span>:</span></span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       iterable = iter(o)</span><br><span class="line">   <span class="keyword">except</span> TypeError:</span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       <span class="keyword">return</span> list(iterable)</span><br><span class="line">   <span class="comment"># Let the base class default method raise the TypeError</span></span><br><span class="line">   <span class="keyword">return</span> json.JSONEncoder.default(self, o)</span><br></pre></td></tr></table></figure></li><li><p><code>encode</code>(<em>o</em>) </p><p>返回 Python <em>o</em> 数据结构的 JSON 字符串表达方式。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.JSONEncoder().encode(&#123;<span class="string">"foo"</span>: [<span class="string">"bar"</span>, <span class="string">"baz"</span>]&#125;)</span><br><span class="line"><span class="string">'&#123;"foo": ["bar", "baz"]&#125;'</span></span><br></pre></td></tr></table></figure></li><li><p><code>iterencode</code>(<em>o</em>) </p><p>编码给定对象 <em>o</em> ，并且让每个可用的字符串表达方式。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> json.JSONEncoder().iterencode(bigobject):</span><br><span class="line">    mysocket.write(chunk)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><em>exception</em> <code>json.JSONDecodeError</code>(<em>msg</em>, <em>doc</em>, <em>pos</em>)</p><p>拥有以下附加属性的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 的子类：</p><ul><li><p><code>msg</code></p><p>未格式化的错误消息。</p></li><li><p><code>doc</code></p><p>正在解析的 JSON 文档。</p></li><li><p><code>pos</code></p><p>从文档开始解析失败的索引</p></li><li><p><code>lineno</code></p><p>定位的行号</p></li><li><p><code>colno</code></p><p>定位的列号</p></li></ul><h2 id="标准符合性和互操作性"><a href="#标准符合性和互操作性" class="headerlink" title="标准符合性和互操作性"></a>标准符合性和互操作性</h2><p>JSON 格式由 <a href="https://tools.ietf.org/html/rfc7159.html" target="_blank" rel="noopener"><strong>RFC 7159</strong></a> 和 <a href="http://www.ecma-international.org/publications/standards/Ecma-404.htm" target="_blank" rel="noopener">ECMA-404</a> 指定。此段落详细讲了这个模块符合 RFC 的级别。简单来说， <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder" target="_blank" rel="noopener"><code>JSONEncoder</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecoder" target="_blank" rel="noopener"><code>JSONDecoder</code></a> 子类，和明确提到的参数以外的参数，不作考虑。</p><p>此模块不严格遵循于 RFC ，它实现了一些扩展是有效的 Javascript 但不是有效的 JSON。尤其是：</p><ul><li>无限和 NaN 数值是被接受并输出；</li><li>对象内的重复名称是接受的，并且仅使用最后一对属性-值对的值。</li></ul><p>自从 RFC 允许符合 RFC 的语法分析程序接收 不符合 RFC 的输入文本以来，这个模块的解串器在默认状态下默认符合 RFC 。</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>RFC 要求使用 UTF-8 ， UTF-16 ，或 UTF-32 之一来表示 JSON ，为了最大互通性推荐使用 UTF-8 。</p><p>RFC允许，尽管不是必须的，这个模块的序列化默认设置为 <em>ensure_ascii=True</em> ，这样消除输出以便结果字符串至容纳 ASCII 字符。</p><p><em>ensure_ascii</em> 参数以外，此模块是严格的按照在 Python 对象和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>Unicode strings</code></a> 间的转换定义的，并且因此不能直接解决字符编码的问题。</p><p>RFC 禁止添加字符顺序标记（ BOM ）在 JSON 文本的开头，这个模块的序列化器不添加 BOM 标记在它的输出上。 RFC，准许 JSON 反序列化器忽略它们输入中的初始 BOM 标记，但不要求。此模块的反序列化器引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 当存在初始 BOM 标记。</p><p>RFC 不会明确禁止包含字节序列的 JSON 字符串这不对应有效的 Unicode 字符（比如 不成对的 UTF-16 的替代物），但是它确实指出它们可能会导致互操作性问题。默认下，模块对这样的序列接受和输出（当在原始 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 存在时）代码点。</p><h3 id="Infinite-和-NaN-数值"><a href="#Infinite-和-NaN-数值" class="headerlink" title="Infinite 和 NaN 数值"></a>Infinite 和 NaN 数值</h3><p>RFC 不允许 infinite 或者 NaN 数值的表达方式。尽管这样，默认情况下，此模块接受并且输出 <code>Infinity</code> ， <code>-Infinity</code>，和 <code>NaN</code> 好像它们是有效的JSON数字字面值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Neither of these calls raises an exception, but the results are not valid JSON</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(float(<span class="string">'-inf'</span>))</span><br><span class="line"><span class="string">'-Infinity'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(float(<span class="string">'nan'</span>))</span><br><span class="line"><span class="string">'NaN'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Same when deserializing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'-Infinity'</span>)</span><br><span class="line">-inf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'NaN'</span>)</span><br><span class="line">nan</span><br></pre></td></tr></table></figure><p>序列化器中， <em>allow_nan</em> 参数可用于替代这个行为。反序列化器中， <em>parse_constant</em> 参数，可用于替代这个行为。</p><h3 id="对象中的重复名称"><a href="#对象中的重复名称" class="headerlink" title="对象中的重复名称"></a>对象中的重复名称</h3><p>RFC 具体说明了 在 JSON对象里的名字应该是唯一的，但没有规定如何处理JSON对象中的重复名称。默认下，此模块不引发异常；作为替代，对于给定名它将忽略除姓-值对之外的所有对:</p><p>>&gt;&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; weird_json = &apos;&#123;&quot;x&quot;: 1, &quot;x&quot;: 2, &quot;x&quot;: 3&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; json.loads(weird_json)</span><br><span class="line">&#123;&apos;x&apos;: 3&#125;</span><br></pre></td></tr></table></figure><p>参数 <code>*object_pairs_hook*</code> 可以改变这个行为</p><h3 id="顶级非对象，非数组值"><a href="#顶级非对象，非数组值" class="headerlink" title="顶级非对象，非数组值"></a>顶级非对象，非数组值</h3><p>老版本的JSON声明遵循<a href="https://tools.ietf.org/html/rfc4627.html" target="_blank" rel="noopener"><strong>RFC 4627</strong></a> ,需要顶级的JSON 文本必须是JSON对象或数组(Python中的字典或列表),并且不能是null,boolean,number或字符串。<a href="https://tools.ietf.org/html/rfc7159.html" target="_blank" rel="noopener"><strong>RFC 7159</strong></a> 移除了这个限制,意味着无需在序列化和反序列化时实现该规范。</p><p>除此以外,为了获得最大限度的操作灵活性,你可以根据自己的实际情况选择是否遵循该规范。</p><h3 id="实现限制"><a href="#实现限制" class="headerlink" title="实现限制"></a>实现限制</h3><p>一些json 实现可能有下面的限制:</p><ul><li>可以接受的 JSON 文本大小 </li><li>对象和数组的最大层数</li><li>JSON numbers的范围以及小数位数。</li><li>JSON字符串的内容和最大长度</li></ul><p>json模块并不会强制这些限制,这取决于自定义Python数据类型自身的实现。</p><h2 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h2><p> <a href="https://docs.python.org/zh-cn/3.8/library/json.html#module-json.tool" target="_blank" rel="noopener"><code>json.tool</code></a> 模块实现了一个简易的命令行接口,用来验证和打印格式良好的JSON 对象。</p><p>如果没有设定可选参数<code>infile</code> and <code>outfile</code>,将会使用<a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a> and <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdout" target="_blank" rel="noopener"><code>sys.stdout</code></a> 标准输入输出代替。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="string">'&#123;"json": "obj"&#125;'</span> | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"json"</span>: <span class="string">"obj"</span></span><br><span class="line">&#125;</span><br><span class="line">$ echo <span class="string">'&#123;1.2:3.4&#125;'</span> | python -m json.tool</span><br><span class="line">Expecting property name enclosed <span class="keyword">in</span> double quotes: line <span class="number">1</span> column <span class="number">2</span> (char <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><p> <strong>infile</strong> </p><p>JSON 文件校验或美化打印。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python -m json.tool mp_films.json</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"And Now for Something Completely Different"</span>,</span><br><span class="line">        <span class="string">"year"</span>: <span class="number">1971</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"Monty Python and the Holy Grail"</span>,</span><br><span class="line">        <span class="string">"year"</span>: <span class="number">1975</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>If <em>infile</em> is not specified, read from <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a>.</p><p> <strong>outfile</strong> </p><p> Write the output of the <em>infile</em> to the given <em>outfile</em>. Otherwise, write it to </p><p>输出到文件,如果没有设置则使用<a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdout" target="_blank" rel="noopener"><code>sys.stdout</code></a>(标准输出)</p><p> <strong>–sort-keys</strong> </p><p>根据输出的字典的键根据字母顺序排序</p><p> <strong>–json-lines</strong> </p><p>解析每一行作为单独的JSON对象</p><p> <code>-h, --help</code> </p><p>显示帮助信息</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-json&quot;&gt;&lt;a href=&quot;#python-标准库-json&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 json&quot;&gt;&lt;/a&gt;python 标准库 json&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20191223_blog_6.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="json" scheme="https://pinghailinfeng.gitee.io/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>python standard library types</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/07/python-standard-library-types/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/07/python-standard-library-types/</id>
    <published>2020-02-07T12:10:40.000Z</published>
    <updated>2020-02-10T02:35:57.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-types"><a href="#python-标准库-types" class="headerlink" title="python 标准库 types"></a>python 标准库 types</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200207_RIP.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>今天心情很沉重,李文亮医生一路走好！R.I.P</p></blockquote><p><a href="https://v.youku.com/v_show/id_XNDQ1MTYyMDI4OA==.html" target="_blank" rel="noopener">https://v.youku.com/v_show/id_XNDQ1MTYyMDI4OA==.html</a></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/types.py" target="_blank" rel="noopener">Lib/types.py</a></p><hr><p>此模块定义了一些工具函数，用于协助动态创建新的类型。</p><p>它还为某些对象类型定义了名称，这些名称由标准 Python 解释器所使用，但并不像内置的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 那样对外公开。</p><p>最后，它还额外提供了一些类型相关但重要程度不足以作为内置对象的工具类和函数。</p><h2 id="动态类型创建"><a href="#动态类型创建" class="headerlink" title="动态类型创建"></a>动态类型创建</h2><ul><li><p><code>types.new_class</code>(<em>name</em>, <em>bases=()</em>, <em>kwds=None</em>, <em>exec_body=None</em>) </p><p>使用适当的元类动态地创建一个类对象。</p><p>前三个参数是组成类定义头的部件：类名称，基类 (有序排列)，关键字参数 (例如 <code>metaclass</code>)。</p><p><em>exec_body</em> 参数是一个回调函数，用于填充新创建类的命名空间。 它应当接受类命名空间作为其唯一的参数并使用类内容直接更新命名空间。 如果未提供回调函数，则它就等效于传入 <code>lambda ns: ns</code>。</p><p><em>3.3 新版功能.</em></p></li><li><p><code>types.prepare_class</code>(<em>name</em>, <em>bases=()</em>, <em>kwds=None</em>) </p><p>计算适当的元类并创建类命名空间。</p><p>参数是组成类定义头的部件：类名称，基类 (有序排列) 以及关键字参数 (例如 <code>metaclass</code>)。</p><p>返回值是一个 3 元组: <code>metaclass, namespace, kwds</code></p><p><em>metaclass</em> 是适当的元类，<em>namespace</em> 是预备好的类命名空间而 <em>kwds</em> 是所传入 <em>kwds</em> 参数移除每个 <code>&#39;metaclass&#39;</code> 条目后的已更新副本。 如果未传入 <em>kwds</em> 参数，这将为一个空字典。</p><p><em>3.3 新版功能.</em></p><p><em>在 3.6 版更改:</em> 所返回元组中 <code>namespace</code> 元素的默认值已被改变。 现在当元类没有 <code>__prepare__</code> 方法时将会使用一个保留插入顺序的映射。</p></li><li><p><code>types.resolve_bases</code>(<em>bases</em>) </p><p>动态地解析 MRO 条目，具体描述见 <a href="https://www.python.org/dev/peps/pep-0560" target="_blank" rel="noopener"><strong>PEP 560</strong></a>。</p><p>此函数会在 <em>bases</em> 中查找不是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#type" target="_blank" rel="noopener"><code>type</code></a> 的实例的项，并返回一个元组，其中每个具有 <code>__mro_entries__</code> 方法的此种对象对象将被替换为调用该方法解包后的结果。 如果一个 <em>bases</em> 项是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#type" target="_blank" rel="noopener"><code>type</code></a> 的实例，或它不具有 <code>__mro_entries__</code> 方法，则它将不加改变地被包含在返回的元组中。</p></li></ul><h2 id="标准解释器类型"><a href="#标准解释器类型" class="headerlink" title="标准解释器类型"></a>标准解释器类型</h2><p>此模块为许多类型提供了实现 Python 解释器所要求的名称。 它刻意地避免了包含某些仅在处理过程中偶然出现的类型，例如 <code>listiterator</code> 类型。</p><p>此种名称的典型应用如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#issubclass" target="_blank" rel="noopener"><code>issubclass()</code></a> 检测。</p><p>如果你要实例化这些类型中的任何一种，请注意其签名在不同 Python 版本之间可能出现变化。</p><p>以下类型有相应的标准名称定义：</p><ul><li><p><code>types.FunctionType</code></p></li><li><p><code>types.LambdaType</code> </p><p>用户自定义函数以及由 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#lambda" target="_blank" rel="noopener"><code>lambda</code></a> 表达式所创建函数的类型。 </p></li><li><p><code>types.GeneratorType</code> </p><p><a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 迭代器对象的类型，由生成器函数创建。 </p></li><li><p><code>types.CoroutineType</code> </p><p><a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 对象的类型，由 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 函数创建。 </p></li><li><p><code>types.AsyncGeneratorType</code>  </p><p><a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-generator" target="_blank" rel="noopener">asynchronous generator</a> 迭代器对象的类型，由异步生成器函数创建。 </p></li><li><p><em>class</em> <code>types.CodeType</code>(<strong><em>kwargs</em>) </strong></p><p>代码对象的类型，例如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#compile" target="_blank" rel="noopener"><code>compile()</code></a> 的返回值。</p><p>引发 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>code.__new__</code> 附带参数 <code>code</code>, <code>filename</code>, <code>name</code>, <code>argcount</code>, <code>posonlyargcount</code>, <code>kwonlyargcount</code>, <code>nlocals</code>, <code>stacksize</code>, <code>flags</code>。</p><p>请注意被审核参数可能不匹配初始化器所要求的名称或位置。</p><ul><li><p><strong><code>replace</code>(*</strong>kwargs*)</p><p>返回代码对象的一个副本，使用指定的新字段值。</p></li></ul></li><li><p><code>types.CellType</code> </p><p>单元对象的类型：这种对象被用作函数中自由变量的容器。 </p></li><li><p><code>types.MethodType</code> </p><p>用户自定义类实例方法的类型。 </p></li><li><p><code>types.BuiltinFunctionType</code> </p></li><li><p><code>types.BuiltinMethodType</code> </p><p>内置函数例如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 以及内置类方法的类型。 （这里所说的“内置”是指“以 C 语言编写”。） </p></li><li><p><code>types.WrapperDescriptorType</code> </p><p>某些内置数据类型和基类的方法的类型，例如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>object.__init__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__lt__" target="_blank" rel="noopener"><code>object.__lt__()</code></a>。 </p></li><li><p><code>types.MethodWrapperType</code> </p><p>某些内置数据类型和基类的 <em>绑定</em> 方法的类型。 例如 <code>object().__str__</code> 所属的类型。 </p></li><li><p><code>types.MethodDescriptorType</code> </p><p>某些内置数据类型方法例如 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str.join" target="_blank" rel="noopener"><code>str.join()</code></a> 的类型。 </p></li><li><p><code>types.MethodDescriptorType</code> </p><p>某些内置数据类型 <em>非绑定</em> 类方法例如 <code>dict.__dict__[&#39;fromkeys&#39;]</code> 的类型 </p></li><li><p><code>types.ClassMethodDescriptorType</code> </p><p>某些内置数据类型 <em>非绑定</em> 类方法例如 <code>dict.__dict__[&#39;fromkeys&#39;]</code> 的类型。 </p><p><em>class</em> <code>types.ModuleType</code>(<em>name</em>, <em>doc=None</em>) </p></li></ul><p><a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-module" target="_blank" rel="noopener">模块</a> 的类型。 构造器接受待创建模块的名称及其作为可选项 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-docstring" target="_blank" rel="noopener">docstring</a>。</p><p>如果你希望设置各种由导入控制的属性，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/importlib.html#importlib.util.module_from_spec" target="_blank" rel="noopener"><code>importlib.util.module_from_spec()</code></a> 来创建一个新模块。</p><ul><li><p><code>__doc__</code></p><p>模块的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-docstring" target="_blank" rel="noopener">docstring</a>。 默认为 <code>None</code>。</p></li><li><p><code>__loader__</code></p><p>用于加载模块的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-loader" target="_blank" rel="noopener">loader</a>。 默认为 <code>None</code>。<em>在 3.4 版更改:</em> 默认为 <code>None</code>。 之前该属性为可选项。</p></li><li><p><code>__name__</code></p><p>模块的名字</p></li><li><p><code>__package__</code></p><p>一个模块所属的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-package" target="_blank" rel="noopener">package</a>。 如果模块为最高层级的（即不是任何特定包的组成部分）则该属性应设为 <code>&#39;&#39;</code>，否则它应设为特定包的名称 (如果模块本身也是一个包则名称可以为 <a href="https://docs.python.org/zh-cn/3.8/reference/import.html#__name__" target="_blank" rel="noopener"><code>__name__</code></a>)。 默认为 <code>None</code>。</p><p><em>class</em> <code>types.TracebackType</code>(<em>tb_next</em>, <em>tb_frame</em>, <em>tb_lasti</em>, <em>tb_lineno</em>) </p></li></ul><p>回溯对象的类型，例如 <code>sys.exc_info()[2]</code> 中的对象。</p><p>请查看 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#traceback-objects" target="_blank" rel="noopener">语言参考</a> 了解可用属性和操作的细节，以及动态地创建回溯对象的指南。</p><ul><li><p><code>types.FrameType</code></p><p>帧对象的类型，例如 <code>tb.tb_frame</code> 中的对象，其中 <code>tb</code> 是一个回溯对象。请查看 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#frame-objects" target="_blank" rel="noopener">语言参考</a> 了解可用属性和操作的细节。</p></li><li><p><code>types.GetSetDescriptorType</code></p><p> 使用 <code>PyGetSetDef</code> 在扩展模块中定义的对象的类型，例如 <code>FrameType.f_locals</code> 或 <code>array.array.typecode</code>。 此类型被用作对象属性的描述器；它的目的与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#property" target="_blank" rel="noopener"><code>property</code></a> 类型相同，但专门针对在扩展模块中定义的类。 </p></li><li><p><code>types.MemberDescriptorType</code></p><p>使用 <code>PyMemberDef</code> 在扩展模块中定义的对象的类型，例如 <code>datetime.timedelta.days</code>。 此类型被用作使用标准转换函数的简单 C 数据成员的描述器；它的目的与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#property" target="_blank" rel="noopener"><code>property</code></a> 类型相同，但专门针对在扩展模块中定义的类。</p><p><strong>CPython implementation detail:</strong> 在 Python 的其它实现中，此类型可能与 <code>GetSetDescriptorType</code> 完全相同。</p></li><li><p><em>class</em> <code>types.MappingProxyType</code>(<em>mapping</em>)</p><p>一个映射的只读代理。 它提供了对映射条目的动态视图，这意味着当映射发生改变时，视图会反映这些改变。</p><p><em>3.3 新版功能.</em></p><ul><li><p><code>key in proxy</code></p><p>如果下层的映射中存在键 <em>key</em> 则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p><code>proxy[key]</code></p><p>返回下层的映射中以 <em>key</em> 为键的项。 如果下层的映射中不存在键 <em>key</em> 则引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。</p></li><li><p><code>iter(proxy)</code></p><p>返回由下层映射的键为元素的迭代器。 这是 <code>iter(proxy.keys())</code> 的快捷方式。</p></li><li><p><code>len(proxy)</code></p><p>返回下层映射中的项数。</p></li><li><p><code>copy</code>()</p><p>返回下层映射的浅拷贝。</p></li><li><p><code>get</code>(<em>key</em>[, <em>default</em>])</p><p>如果 <em>key</em> 存在于下层映射中则返回 <em>key</em> 的值，否则返回 <em>default</em>。 如果 <em>default</em> 未给出则默认为 <code>None</code>，因而此方法绝不会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。</p></li><li><p><code>items</code>()</p><p>返回由下层映射的项 (<code>(键, 值)</code> 对) 组成的一个新视图。</p></li><li><p><code>keys</code>()</p><p>返回由下层映射的键组成的一个新视图。</p></li><li><p><code>values</code>()</p><p>返回由下层映射的值组成的一个新视图。</p></li></ul></li></ul><h2 id="附加工具类和函数"><a href="#附加工具类和函数" class="headerlink" title="附加工具类和函数"></a>附加工具类和函数</h2><ul><li><p>class* <code>types.SimpleNamespace</code> </p><p>一个简单的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 子类，提供了访问其命名空间的属性，以及一个有意义的 repr。</p><p>不同于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a>，对于 <code>SimpleNamespace</code> 你可以添加和移除属性。 如果一个 <code>SimpleNamespace</code> 对象使用关键字参数进行初始化，这些参数会被直接加入下层命名空间。</p><p>此类型大致等价于以下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleNamespace</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, /, **kwargs)</span>:</span></span><br><span class="line">        self.__dict__.update(kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        keys = sorted(self.__dict__)</span><br><span class="line">        items = (<span class="string">"&#123;&#125;=&#123;!r&#125;"</span>.format(k, self.__dict__[k]) <span class="keyword">for</span> k <span class="keyword">in</span> keys)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;&#125;(&#123;&#125;)"</span>.format(type(self).__name__, <span class="string">", "</span>.join(items))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__dict__ == other.__dict__</span><br></pre></td></tr></table></figure><p> <code>SimpleNamespace</code> 可被用于替代 <code>class NS: pass</code>。 但是，对于结构化记录类型则应改用 <a href="https://docs.python.org/zh-cn/3.8/library/collections.html#collections.namedtuple" target="_blank" rel="noopener"><code>namedtuple()</code></a>。 </p></li><li><p><code>types.DynamicClassAttribute</code>(<em>fget=None</em>, <em>fset=None</em>, <em>fdel=None</em>, <em>doc=None</em>) </p></li></ul><p>在类上访问 <strong>getattr</strong> 的路由属性。</p><p>这是一个描述器，用于定义通过实例与通过类访问时具有不同行为的属性。 当实例访问时保持正常行为，但当类访问属性时将被路由至类的 <strong>getattr</strong> 方法；这是通过引发 AttributeError 来完成的。</p><p>这样就允许有在实例上激活的特征属性，同时又有在类上的同名虚拟属性（一个这样的例子是 Enum）。</p><h2 id="协程工具函数"><a href="#协程工具函数" class="headerlink" title="协程工具函数"></a>协程工具函数</h2><p> <code>types.coroutine</code>(<em>gen_func</em>) </p><p>此函数可将 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 函数转换为返回基于生成器的协程的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine-function" target="_blank" rel="noopener">coroutine function</a>。 基于生成器的协程仍然属于 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator-iterator" target="_blank" rel="noopener">generator iterator</a>，但同时又可被视为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 对象兼 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a>。 不过，它没有必要实现 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 方法。</p><p>如果 <em>gen_func</em> 是一个生成器函数，它将被原地修改。</p><p>如果 <em>gen_func</em> 不是一个生成器函数，则它会被包装。 如果它返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Generator" target="_blank" rel="noopener"><code>collections.abc.Generator</code></a> 的实例，该实例将被包装在一个 <em>awaitable</em> 代理对象中。 所有其他对象类型将被原样返回。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-types&quot;&gt;&lt;a href=&quot;#python-标准库-types&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 types&quot;&gt;&lt;/a&gt;python 标准库 types&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200207_RIP.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="types" scheme="https://pinghailinfeng.gitee.io/tags/types/"/>
    
  </entry>
  
  <entry>
    <title>python standard library statistics</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/06/python-standard-library-statistics/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/06/python-standard-library-statistics/</id>
    <published>2020-02-06T12:51:05.000Z</published>
    <updated>2020-02-11T13:27:57.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-statistics-数学统计函数"><a href="#python-标准库-statistics-数学统计函数" class="headerlink" title="python 标准库 statistics 数学统计函数"></a>python 标准库 statistics 数学统计函数</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200206update.jpg?raw=true" alt></p><a id="more"></a><blockquote><p> I have self-doubt. I have insecurity. I have fear of failure. I have nights when I show up at the arena and I’m like, ‘My back hurts, my feet hurt, my knees hurt. I don’t have it. I just want to chill.’ We all have self-doubt. You don’t deny it, but you also don’t capitulate to it. You embrace it.<br>我有自我怀疑。我有不安全感。我害怕失败。当我出现在竞技场的时候，我会说，‘我的背疼，我的脚疼，我的膝盖疼。我没有打赢的信心。我只是想冷静一下。’我们都有自我怀疑。你不要否认，但你也不屈服于它。你要拥抱它。 </p><p>​                                                                                                                                                  by   Kobe Bryant </p></blockquote><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27867449&auto=0&height=66"></iframe></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/statistics.py" target="_blank" rel="noopener">Lib/statistics.py</a></p><p><em>主要方法</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">==================  ==================================================</span><br><span class="line">Function            Description</span><br><span class="line">==================  ==================================================</span><br><span class="line">mean                Arithmetic mean (average) of data.</span><br><span class="line">fmean               Fast, floating point arithmetic mean.</span><br><span class="line">geometric_mean      Geometric mean of data.</span><br><span class="line">harmonic_mean       Harmonic mean of data.</span><br><span class="line">median              Median (middle value) of data.</span><br><span class="line">median_low          Low median of data.</span><br><span class="line">median_high         High median of data.</span><br><span class="line">median_grouped      Median, <span class="keyword">or</span> <span class="number">50</span>th percentile, of grouped data.</span><br><span class="line">mode                Mode (most common value) of data.</span><br><span class="line">multimode           List of modes (most common values of data).</span><br><span class="line">quantiles           Divide data into intervals <span class="keyword">with</span> equal probability.</span><br><span class="line">==================  ==================================================</span><br></pre></td></tr></table></figure><hr><p>该模块提供了用于计算数字 (<a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Real" target="_blank" rel="noopener"><code>Real</code></a>-valued) 数据的数理统计量的函数。</p><p>此模块并不是诸如 <a href="https://numpy.org/" target="_blank" rel="noopener">NumPy</a> ， <a href="https://www.scipy.org/" target="_blank" rel="noopener">SciPy</a> 等第三方库或者诸如 Minitab ， SAS ， Matlab 等针对专业统计学家的专有全功能统计软件包的竟品。此模块针对图形和科学计算器的水平。</p><p>除非明确注释，这些函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>Decimal</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 。当前不支持同其他类型（是否在数字塔中）的行为。混合类型的集合也是未定义的，并且依赖于实现。如果你输入的数据由混合类型组成，你应该能够使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 来确保一个一致的结果，比如： <code>map(float, input_data)</code> 。</p><h2 id="中心位置的平均值和度量"><a href="#中心位置的平均值和度量" class="headerlink" title="中心位置的平均值和度量"></a>中心位置的平均值和度量</h2><p> 这些函数计算一个整体或样本的平均值或者特定值 </p><table><thead><tr><th><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.mean" target="_blank" rel="noopener"><code>mean()</code></a></th><th>数据的算术平均数（“平均数”）。</th></tr></thead><tbody><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.fmean" target="_blank" rel="noopener"><code>fmean()</code></a></td><td>快速的，浮点算数平均数。</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.geometric_mean" target="_blank" rel="noopener"><code>geometric_mean()</code></a></td><td>数据的几何平均数</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.harmonic_mean" target="_blank" rel="noopener"><code>harmonic_mean()</code></a></td><td>数据的调和均值</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median" target="_blank" rel="noopener"><code>median()</code></a></td><td>数据的中位数（中间值）</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_low" target="_blank" rel="noopener"><code>median_low()</code></a></td><td>数据的低中位数</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_high" target="_blank" rel="noopener"><code>median_high()</code></a></td><td>数据的高中位数</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_grouped" target="_blank" rel="noopener"><code>median_grouped()</code></a></td><td>分组数据的中位数，即第50个百分点。</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.mode" target="_blank" rel="noopener"><code>mode()</code></a></td><td>离散的或标称的数据的单模（最常见的值）。</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.multimode" target="_blank" rel="noopener"><code>multimode()</code></a></td><td>离散的或标称的数据的模式列表（最常见的值）。</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.quantiles" target="_blank" rel="noopener"><code>quantiles()</code></a></td><td>将数据以相等的概率分为多个间隔。</td></tr></tbody></table><h2 id="传播措施"><a href="#传播措施" class="headerlink" title="传播措施"></a>传播措施</h2><p>这些函数计算多少总体或者样本偏离典型值或平均值的度量。</p><table><thead><tr><th><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.pstdev" target="_blank" rel="noopener"><code>pstdev()</code></a></th><th>数据的总体标准差</th></tr></thead><tbody><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.pvariance" target="_blank" rel="noopener"><code>pvariance()</code></a></td><td>数据的总体方差</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.stdev" target="_blank" rel="noopener"><code>stdev()</code></a></td><td>数据的样本标准差</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.variance" target="_blank" rel="noopener"><code>variance()</code></a></td><td>数据的样本方差</td></tr></tbody></table><h2 id="函数细节"><a href="#函数细节" class="headerlink" title="函数细节"></a>函数细节</h2><p>这些函数不需要对提供给它们的数据进行排序。但是，为了方便阅读，大多数例子展示的是已排序的序列。</p><ul><li><p><code>statistics.mean</code>(<em>data</em>)</p><p>返回 <em>data</em> 的样本算术平均数，形式为序列或迭代器。算术平均数是数据之和与数据点个数的商。通常称作“平均数”，尽管它指示诸多数学平均数之一。它是数据的中心位置的度量。若 <em>data</em> 为空，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。一些用法示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">2.8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean([<span class="number">-1.0</span>, <span class="number">2.5</span>, <span class="number">3.25</span>, <span class="number">5.75</span>])</span><br><span class="line"><span class="number">2.625</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction <span class="keyword">as</span> F</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean([F(<span class="number">3</span>, <span class="number">7</span>), F(<span class="number">1</span>, <span class="number">21</span>), F(<span class="number">5</span>, <span class="number">3</span>), F(<span class="number">1</span>, <span class="number">3</span>)])</span><br><span class="line">Fraction(<span class="number">13</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal <span class="keyword">as</span> D</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean([D(<span class="string">"0.5"</span>), D(<span class="string">"0.75"</span>), D(<span class="string">"0.625"</span>), D(<span class="string">"0.375"</span>)])</span><br><span class="line">Decimal(<span class="string">'0.5625'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>statistics.fmean</code>(<em>data</em>) </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将浮点数转换成 data 并且计算算术平均数。</span><br><span class="line"></span><br><span class="line">此函数的运行速度比 mean() 函数快并且它总是返回一个 float。 data 可以为序列或迭代器。 如果输入数据集为空，则会引发 StatisticsError。</span><br></pre></td></tr></table></figure></li><li><p><code>statistics.geometric_mean</code>(<em>data</em>) </p><p>返回 <em>data</em> 调和均值，该参数可以是序列或包含实数值的可迭代对象。</p><p>调和均值,也叫次相反均值，所有数据的倒数的算术平均数 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.mean" target="_blank" rel="noopener"><code>mean()</code></a> 的倒数。比如说，数据 <em>a</em> ， <em>b</em> ， <em>c</em> 的调和均值等于 <code>3/(1/a + 1/b + 1/c)</code> 。如果其中一个值为零，结果为零。</p><p>调和均值是一种均值类型，是数据中心位置的度量。它通常适合于求比率和比例的平均值，比如速率。</p><p>假设一辆车在 40 km/hr 的速度下行驶了 10 km ，然后又以 60 km/hr 的速度行驶了 10 km 。车辆的平均速率是多少？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>harmonic_mean([<span class="number">40</span>, <span class="number">60</span>])</span><br><span class="line"><span class="number">48.0</span></span><br></pre></td></tr></table></figure><p>假设一名投资者在三家公司各购买了等价值的股票，以 2.5， 3 ， 10 的 P/E (价格/收益) 率。投资者投资组合的平均市盈率是多少？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>harmonic_mean([<span class="number">2.5</span>, <span class="number">3</span>, <span class="number">10</span>])  <span class="comment"># For an equal investment portfolio.</span></span><br><span class="line"><span class="number">3.6</span></span><br></pre></td></tr></table></figure><p>如果 <em>data</em> 为空或者 任何一个元素的值小于零，会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a> 。</p><p>当前算法在输入中遇到零时会提前退出。这意味着不会测试后续输入的有效性。（此行为将来可能会更改。）</p></li><li><p><code>statistics.median</code>(<em>data</em>) </p><p>使用普通的“取中间两数平均值”方法返回数值数据的中位数（中间值）。 如果 <em>data</em> 为空，则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。 <em>data</em> 可以是序列或可迭代对象。</p><p>中位数是衡量中间位置的可靠方式，并且较少受到极端值的影响。 当数据点的总数为奇数时，将返回中间数据点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>当数据点的总数为偶数时，中位数将通过对两个中间值求平均进行插值得出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>])</span><br><span class="line"><span class="number">4.0</span></span><br></pre></td></tr></table></figure><p>这适用于当你的数据是离散的，并且你不介意中位数不是实际数据点的情况。</p><p>如果数据是有序的（支持排序操作）但不是数字（不支持加法），请考虑改用 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_low" target="_blank" rel="noopener"><code>median_low()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_high" target="_blank" rel="noopener"><code>median_high()</code></a>。</p></li><li><p><code>statistics.median_low</code>(<em>data</em>) </p><p>返回数值数据的低中位数。 如果 <em>data</em> 为空则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。 <em>data</em> 可以是序列或可迭代对象。</p><p>低中位数一定是数据集的成员。 当数据点总数为奇数时，将返回中间值。 当其为偶数时，将返回两个中间值中较小的那个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_low([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_low([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>])</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>当你的数据是离散的，并且你希望中位数是一个实际数据点而非插值结果时可以使用低中位数。</p></li><li><p><code>statistics.median_high</code>(<em>data</em>) </p><p>​    返回数据的高中位数。 如果 <em>data</em> 为空则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。 <em>data</em> 可以是序列或可迭代对象。</p><p>高中位数一定是数据集的成员。 当数据点总数为奇数时，将返回中间值。 当其为偶数时，将返回两个中间值中较大的那个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_high([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_high([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>])</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>当你的数据是离散的，并且你希望中位数是一个实际数据点而非插值结果时可以使用高中位数。</p></li><li><p><code>statistics.median_grouped</code>(<em>data</em>, <em>interval=1</em>) </p><p>返回分组的连续数据的中位数，根据第 50 个百分点的位置使用插值来计算。 如果 <em>data</em> 为空则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。 <em>data</em> 可以是序列或可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_grouped([<span class="number">52</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>])</span><br><span class="line"><span class="number">52.5</span></span><br></pre></td></tr></table></figure><p>在下面的示例中，数据已经过舍入，这样每个值都代表数据分类的中间点，例如 1 是 0.5–1.5 分类的中间点，2 是 1.5–2.5 分类的中间点，3 是 2.5–3.5 的中间点等待。 根据给定的数据，中间值应落在 3.5–4.5 分类之内，并可使用插值法来进行估算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_grouped([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">3.7</span></span><br></pre></td></tr></table></figure><p>可选参数 <em>interval</em> 表示分类间隔，默认值为 1。 改变分类间隔自然会改变插件结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_grouped([<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], interval=<span class="number">1</span>)</span><br><span class="line"><span class="number">3.25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_grouped([<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], interval=<span class="number">2</span>)</span><br><span class="line"><span class="number">3.5</span></span><br></pre></td></tr></table></figure><p>此函数不会检查数据点之间是否至少相隔 <em>interval</em> 的距离。</p></li><li><p><code>statistics.mode</code>(<em>data</em>) </p><p>根据离散或标称的 <em>data</em> 返回单个最觉的数据点。 此模式（如果存在）是最典型的值，并可用来度量中心的位置。</p><p>如果存在具有相同频率的多个模式，则返回在 <em>data</em> 中遇到的第一个。 如果想要其中最小或最大的一个，请使用 <code>min(multimode(data))</code> 或 <code>max(multimode(data))</code>。 如果输入的 <em>data</em> 为空，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p><p><code>mode</code> 将假定是离散数据并返回一个单一的值。 这是通常的学校教学中标准的处理方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mode([1, 1, 2, 3, 3, 3, 3, 4])</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>此模式的独特之处在于它是这个包中唯一还可应用于标称（非数字）数据的统计信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mode([&quot;red&quot;, &quot;blue&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;red&quot;, &quot;red&quot;])</span><br><span class="line">&apos;red&apos;</span><br></pre></td></tr></table></figure><p><em>在 3.8 版更改:</em> 现在会通过返回所遇到的第一个模式来处理多模数据集。 之前它会在遇到超过一个的模式时引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p></li><li><p><code>statistics.multimode</code>(<em>data</em>) </p><p>返回最频繁出现的值的列表，并按它们在 <em>data</em> 中首次出现的位置排序。 如果存在多种模式则将返回一个以上的模式，或者如果 <em>data</em> 为空则将返回空列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>multimode(<span class="string">'aabbbbccddddeeffffgg'</span>)</span><br><span class="line">[<span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'f'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>multimode(<span class="string">''</span>)</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p><em>3.8 新版功能.</em> </p></li><li><p><code>statistics.pstdev</code>(<em>data</em>, <em>mu=None</em>) </p><p>返回总体标准差（总体方差的平方根）。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.pvariance" target="_blank" rel="noopener"><code>pvariance()</code></a> 了解参数和其他细节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pstdev([<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">2.5</span>, <span class="number">2.75</span>, <span class="number">3.25</span>, <span class="number">4.75</span>])</span><br><span class="line"><span class="number">0.986893273527251</span></span><br></pre></td></tr></table></figure></li><li><p><code>statistics.pvariance</code>(<em>data</em>, <em>mu=None</em>) </p><p>返回非空序列或包含实数值的可迭代对象 <em>data</em> 的总体方差。 方差或称相对于均值的二阶距，是对数据变化幅度（延展度或分散度）的度量。 方差值较大表明数据的散布范围较大；方差值较小表明它紧密聚集于均值附近。</p><p>如果给出了可选的第二个参数 <em>mu</em>，它通常是 <em>data</em> 的均值。 它也可以被用来计算相对于一个非均值点的二阶距。 如果该参数省略或为 <code>None</code> (默认值)，则会自动进行算术均值的计算。</p><p>使用此函数可根据所有数值来计算方差。 要根据一个样本来估算方差，通常 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.variance" target="_blank" rel="noopener"><code>variance()</code></a> 函数是更好的选择。</p><p>如果 <em>data</em> 为空则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]</span><br><span class="line">&gt;&gt;&gt; pvariance(data)</span><br><span class="line">1.25</span><br></pre></td></tr></table></figure><p>如果你已经计算过数据的平均值，你可以将其作为可选的第二个参数 <em>mu</em> 传入以避免重复计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mu = mean(data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pvariance(data, mu)</span><br><span class="line"><span class="number">1.25</span></span><br></pre></td></tr></table></figure><p>同样也支持使用 Decimal 和 Fraction 值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal <span class="keyword">as</span> D</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pvariance([D(<span class="string">"27.5"</span>), D(<span class="string">"30.25"</span>), D(<span class="string">"30.25"</span>), D(<span class="string">"34.5"</span>), D(<span class="string">"41.75"</span>)])</span><br><span class="line">Decimal(<span class="string">'24.815'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction <span class="keyword">as</span> F</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pvariance([F(<span class="number">1</span>, <span class="number">4</span>), F(<span class="number">5</span>, <span class="number">4</span>), F(<span class="number">1</span>, <span class="number">2</span>)])</span><br><span class="line">Fraction(<span class="number">13</span>, <span class="number">72</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>statistics.stdev</code>(<em>data</em>, <em>xbar=None</em>) </p><p>返回样本标准差（样本方差的平方根）。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.variance" target="_blank" rel="noopener"><code>variance()</code></a> 了解参数和其他细节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>stdev([<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">2.5</span>, <span class="number">2.75</span>, <span class="number">3.25</span>, <span class="number">4.75</span>])</span><br><span class="line"><span class="number">1.0810874155219827</span></span><br></pre></td></tr></table></figure></li><li><p><code>statistics.variance</code>(<em>data</em>, <em>xbar=None</em>) </p><p>返回包含至少两个实数值的可迭代对象 <em>data</em> 的样本方差。 方差或称相对于均值的二阶矩，是对数据变化幅度（延展度或分散度）的度量。 方差值较大表明数据的散布范围较大；方差值较小表明它紧密聚集于均值附近。</p><p>如果给出了可选的第二个参数 <em>xbar</em>，它应当是 <em>data</em> 的均值。 如果该参数省略或为 <code>None</code> (默认值)，则会自动进行均值的计算。</p><p>当你的数据是总体数据的样本时请使用此函数。 要根据整个总体数据来计算方差，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.pvariance" target="_blank" rel="noopener"><code>pvariance()</code></a>。</p><p>如果 <em>data</em> 包含的值少于两个则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]</span><br><span class="line">&gt;&gt;&gt; variance(data)</span><br><span class="line">1.3720238095238095</span><br></pre></td></tr></table></figure><p>如果你已经计算过数据的平均值，你可以将其作为可选的第二个参数 <em>xbar</em> 传入以避免重复计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m = mean(data)</span><br><span class="line">&gt;&gt;&gt; variance(data, m)</span><br><span class="line">1.3720238095238095</span><br></pre></td></tr></table></figure><p>此函数不会试图检查你所传入的 <em>xbar</em> 是否为真实的平均值。 使用任意值作为 <em>xbar</em> 可能导致无效或不可能的结果。</p><p>同样也支持使用 Decimal 和 Fraction 值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal <span class="keyword">as</span> D</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>variance([D(<span class="string">"27.5"</span>), D(<span class="string">"30.25"</span>), D(<span class="string">"30.25"</span>), D(<span class="string">"34.5"</span>), D(<span class="string">"41.75"</span>)])</span><br><span class="line">Decimal(<span class="string">'31.01875'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction <span class="keyword">as</span> F</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>variance([F(<span class="number">1</span>, <span class="number">6</span>), F(<span class="number">1</span>, <span class="number">2</span>), F(<span class="number">5</span>, <span class="number">3</span>)])</span><br><span class="line">Fraction(<span class="number">67</span>, <span class="number">108</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>statistics.quantiles</code>(<em>data</em>, <em>**, </em>n=4<em>, </em>method=’exclusive’*) </p><p>将 <em>data</em> 分隔为具有相等概率的 <em>n</em> 个连续区间。 返回分隔这些区间的 <code>n - 1</code> 个分隔点的列表。</p><p>将 <em>n</em> 设为 4 以使用四分位（默认值）。 将 <em>n</em> 设为 10 以使用十分位。 将 <em>n</em> 设为 100 以使用百分位，即给出 99 个分隔点来将 <em>data</em> 分隔为 100 个大小相等的组。 如果 <em>n</em> 小于 1 则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p><p><em>data</em> 可以是包含样本数据的任意可迭代对象。 为了获得有意义的结果，<em>data</em> 中数据点的数量应当大于 <em>n</em>。 如果数据点的数量小于两个则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p><p>分隔点是通过对两个最接近的数据点进行线性插值得到的。 例如，如果一个分隔点落在两个样本值 <code>100</code> 和 <code>112</code> 之间距离三分之一的位置，则分隔点的取值将为 <code>104</code>。</p><p><em>method</em> 用于计算分位值，它会由于 <em>data</em> 是包含还是排除总体的最低和最高可能值而有所不同。</p><p>默认 <em>method</em> 是 “唯一的” 并且被用于在总体中数据采样这样可以有比样本中找到的更多的极端值。落在 <em>m</em> 个排序数据点的第 <em>i-th</em> 个以下的总体部分被计算为 <code>i / (m + 1)</code> 。给定九个样本值，方法排序它们并且分配一下的百分位： 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90% 。</p><p>将 <em>method</em> 设为 “inclusive” 可用于描述总体数据或已明确知道包含有总体数据中最极端值的样本。 <em>data</em> 中的最小值会被作为第 0 个百分位而最大值会被作为第 100 个百分位。 总体数据里处于 <em>m</em> 个已排序数据点中 <em>第 i 个</em> 以下的部分会以 <code>(i - 1) / (m - 1)</code> 来计算。 给定 11 个样本值，该方法会对它们进行排序并赋予以下百分位: 0%, 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90%, 100%。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Decile cut points for empirically sampled data</span><br><span class="line">&gt;&gt;&gt; data = [105, 129, 87, 86, 111, 111, 89, 81, 108, 92, 110,</span><br><span class="line">...         100, 75, 105, 103, 109, 76, 119, 99, 91, 103, 129,</span><br><span class="line">...         106, 101, 84, 111, 74, 87, 86, 103, 103, 106, 86,</span><br><span class="line">...         111, 75, 87, 102, 121, 111, 88, 89, 101, 106, 95,</span><br><span class="line">...         103, 107, 101, 81, 109, 104]</span><br><span class="line">&gt;&gt;&gt; [round(q, 1) for q in quantiles(data, n=10)]</span><br><span class="line">[81.0, 86.2, 89.0, 99.4, 102.5, 103.6, 106.0, 109.8, 111.0]</span><br></pre></td></tr></table></figure><p><em>3.8 新版功能.</em></p></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>只定义了一个异常：</p><ul><li><p><em>exception</em> <code>statistics.StatisticsError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 的子类，表示统计相关的异常。</p></li></ul><h2 id="NormalDist对象"><a href="#NormalDist对象" class="headerlink" title="NormalDist对象"></a><code>NormalDist</code>对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 工具可用于创建和操纵 <a href="http://www.stat.yale.edu/Courses/1997-98/101/ranvar.htm" target="_blank" rel="noopener">随机变量</a> 的正态分布。 这个类将数据度量值的平均值和标准差作为单一实体来处理。</p><p>正态分布的概念来自于 <a href="https://en.wikipedia.org/wiki/Central_limit_theorem" target="_blank" rel="noopener">中央极限定理</a> 并且在统计学中有广泛的应用。</p><ul><li><p><em>class</em> <code>statistics.NormalDist</code>(<em>mu=0.0</em>, <em>sigma=1.0</em></p><p>返回一个新的 <em>NormalDist</em> 对象，其中 <em>mu</em> 代表 <a href="https://en.wikipedia.org/wiki/Arithmetic_mean" target="_blank" rel="noopener">算术平均值</a> 而 <em>sigma</em> 代表 <a href="https://en.wikipedia.org/wiki/Standard_deviation" target="_blank" rel="noopener">标准差</a>。</p><p>若 <em>sigma</em> 为负数，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p><ul><li><p><code>mean</code></p><p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Arithmetic_mean" target="_blank" rel="noopener">算术平均值</a>。</p></li><li><p><code>median</code></p><p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Median" target="_blank" rel="noopener">中位数</a>。</p></li><li><p><code>mode</code></p><p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Mode_(statistics" target="_blank" rel="noopener">模式</a>)。</p></li><li><p><code>stdev</code></p><p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Standard_deviation" target="_blank" rel="noopener">标准差</a>。</p></li><li><p><code>variance</code><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist.variance" target="_blank" rel="noopener">¶</a></p><p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Variance" target="_blank" rel="noopener">方差</a>。 等于标准差的平方</p></li></ul></li><li><p><em>classmethod</em> <code>from_samples</code>(<em>data</em>)</p><p>传入使用 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.fmean" target="_blank" rel="noopener"><code>fmean()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.stdev" target="_blank" rel="noopener"><code>stdev()</code></a> 基于 <em>data</em> 估算出的 <em>mu</em> 和 <em>sigma</em> 形参创建一个正态分布实例。<em>data</em> 可以是任何 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterable" target="_blank" rel="noopener">iterable</a> 并且应当包含能被转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 类型的值。 如果 <em>data</em> 不包含至少两个元素，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>，因为估算中心值至少需要一个点而估算分散度至少需要两个点。</p></li><li><p><code>samples</code>(<em>n</em>, <em>**, </em>seed=None*)</p><p>对于给定的平均值和标准差生成 <em>n</em> 个随机样本。 返回一个由 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 值组成的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a>。当给定 <em>seed</em> 时，创建一个新的底层随机数生成器实例。 这适用于创建可重现的结果，即使对于多线程上下文也有效。</p></li><li><p><code>pdf</code>(<em>x</em>)</p><p>使用 <a href="https://en.wikipedia.org/wiki/Probability_density_function" target="_blank" rel="noopener">概率密度函数 (pdf)</a>，计算一个随机变量 <em>X</em> 趋向于给定值 <em>x</em> 的相对可能性。 在数学意义上，它是当 <em>dx</em> 趋向于零时比率 <code>P(x &lt;= X &lt; x+dx) / dx</code> 的极限。相对可能性的计算方法是用一个狭窄区间内某个样本出现的概率除以区间的宽度（因此使用“密度”一词）。 由于可能性是相对于其他点的，它的值可以大于 1.0。</p></li><li><p><code>cdf</code>(<em>x</em>)</p><p>使用 <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function" target="_blank" rel="noopener">累积分布函数 (cdf)</a>，计算一个随机变量 <em>X</em> 小于等于 <em>x</em> 的概率。 在数学上，它表示为 <code>P(X &lt;= x)</code>。</p></li><li><p><code>inv_cdf</code>(<em>p</em>)</p><p>计算反向累积分布函数，也称为 <a href="https://en.wikipedia.org/wiki/Quantile_function" target="_blank" rel="noopener">分位数函数</a> 或 <a href="https://www.statisticshowto.datasciencecentral.com/inverse-distribution-function/" target="_blank" rel="noopener">百分点</a> 函数。 在数学上，它表示为 <code>x : P(X &lt;= x) = p</code>。找出随机变量 <em>X</em> 的值 <em>x</em> 使得该变量小于等于该值的概率等于给定的概率 <em>p</em>。</p></li><li><p><code>overlap</code>(<em>other</em>)</p><p>测量两个正态概率分布之间的一致性。 返回介于 0.0 和 1.0 之间的值，给出 <a href="https://www.rasch.org/rmt/rmt101r.htm" target="_blank" rel="noopener">两个概率密度函数的重叠区域</a>。</p></li><li><p><code>quantiles</code>(<em>n=4</em>)</p><p>将指定正态分布划分为 <em>n</em> 个相等概率的连续分隔区。 返回这些分隔区对应的 (n - 1) 个分隔点的列表。将 <em>n</em> 设为 4 以使用四分位（默认值）。 将 <em>n</em> 设为 10 以使用十分位。将 <em>n</em> 设为 100 以使用百分位，即给出 99 个分隔点来将正态分布分隔为 100 个大小相等的组。</p></li></ul><p><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 的实例支持加上、减去、乘以或除以一个常量。 这些运算被用于转换和缩放。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; temperature_february = NormalDist(5, 2.5)             # Celsius</span><br><span class="line">&gt;&gt;&gt; temperature_february * (9/5) + 32                     # Fahrenheit</span><br><span class="line">NormalDist(mu=41.0, sigma=4.5)</span><br></pre></td></tr></table></figure><p>不允许一个常量除以 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 的实例，因为结果将不是正态分布。</p><p>由于正态分布是由独立变量的累加效应产生的，因此允许表示为 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 实例的 <a href="https://en.wikipedia.org/wiki/Sum_of_normally_distributed_random_variables" target="_blank" rel="noopener">两组独立正态分布的随机变量相加和相减</a>。 例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>birth_weights = NormalDist.from_samples([<span class="number">2.5</span>, <span class="number">3.1</span>, <span class="number">2.1</span>, <span class="number">2.4</span>, <span class="number">2.7</span>, <span class="number">3.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>drug_effects = NormalDist(<span class="number">0.4</span>, <span class="number">0.15</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined = birth_weights + drug_effects</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(combined.mean, <span class="number">1</span>)</span><br><span class="line"><span class="number">3.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(combined.stdev, <span class="number">1</span>)</span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure><h3 id="NormalDist-示例和用法"><a href="#NormalDist-示例和用法" class="headerlink" title="NormalDist 示例和用法"></a><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 示例和用法</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 适合用来解决经典概率问题。</p><p>举例来说，如果 <a href="https://nces.ed.gov/programs/digest/d17/tables/dt17_226.40.asp" target="_blank" rel="noopener">SAT 考试的历史数据</a> 显示分数呈平均值为 1060 且标准差为 195 的正态分布，则可以确定考试分数处于 1100 和 1200 之间的学生的百分比舍入到最接近的整数应为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sat = NormalDist(<span class="number">1060</span>, <span class="number">195</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fraction = sat.cdf(<span class="number">1200</span> + <span class="number">0.5</span>) - sat.cdf(<span class="number">1100</span> - <span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(fraction * <span class="number">100.0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">18.4</span></span><br></pre></td></tr></table></figure><p>求 SAT 分数的 <a href="https://en.wikipedia.org/wiki/Quartile" target="_blank" rel="noopener">四分位</a> 和 <a href="https://en.wikipedia.org/wiki/Decile" target="_blank" rel="noopener">十分位</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(round, sat.quantiles()))</span><br><span class="line">[<span class="number">928</span>, <span class="number">1060</span>, <span class="number">1192</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(round, sat.quantiles(n=<span class="number">10</span>)))</span><br><span class="line">[<span class="number">810</span>, <span class="number">896</span>, <span class="number">958</span>, <span class="number">1011</span>, <span class="number">1060</span>, <span class="number">1109</span>, <span class="number">1162</span>, <span class="number">1224</span>, <span class="number">1310</span>]</span><br></pre></td></tr></table></figure><p>为了估算一个不易解析的模型分布，<a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 可以生成用于 <a href="https://en.wikipedia.org/wiki/Monte_Carlo_method" target="_blank" rel="noopener">蒙特卡洛模拟</a> 的输入样本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(x, y, z)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> (<span class="number">3</span>*x + <span class="number">7</span>*x*y - <span class="number">5</span>*y) / (<span class="number">11</span> * z)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">100</span>_000</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = NormalDist(<span class="number">10</span>, <span class="number">2.5</span>).samples(n, seed=<span class="number">3652260728</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Y = NormalDist(<span class="number">15</span>, <span class="number">1.75</span>).samples(n, seed=<span class="number">4582495471</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = NormalDist(<span class="number">50</span>, <span class="number">1.25</span>).samples(n, seed=<span class="number">6582483453</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quantiles(map(model, X, Y, Z))       </span><br><span class="line">[<span class="number">1.4591308524824727</span>, <span class="number">1.8035946855390597</span>, <span class="number">2.175091447274739</span>]</span><br></pre></td></tr></table></figure><p>当样本量较大并且成功试验的可能性接近 50% 时，正态分布可以被用来模拟 <a href="http://mathworld.wolfram.com/BinomialDistribution.html" target="_blank" rel="noopener">二项分布</a>。</p><p>例如，一次开源会议有 750 名与会者和两个可分别容纳 500 人的会议厅。 会上有一场关于 Python 的演讲和一场关于 Ruby 的演讲。 在往届会议中，65% 的与会者更愿意去听关于 Python 的演讲。 假定人群的偏好没有发生改变，那么 Python 演讲的会议厅不超出其容量上限的可能性是多少？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">750</span>             <span class="comment"># Sample size</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = <span class="number">0.65</span>            <span class="comment"># Preference for Python</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = <span class="number">1.0</span> - p         <span class="comment"># Preference for Ruby</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k = <span class="number">500</span>             <span class="comment"># Room capacity</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Approximation using the cumulative normal distribution</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(NormalDist(mu=n*p, sigma=sqrt(n*p*q)).cdf(k + <span class="number">0.5</span>), <span class="number">4</span>)</span><br><span class="line"><span class="number">0.8402</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Solution using the cumulative binomial distribution</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> comb, fsum</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(fsum(comb(n, r) * p**r * q**(n-r) <span class="keyword">for</span> r <span class="keyword">in</span> range(k+<span class="number">1</span>)), <span class="number">4</span>)</span><br><span class="line"><span class="number">0.8402</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Approximation using a simulation</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> seed, choices</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seed(<span class="number">8675309</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">trial</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> choices((<span class="string">'Python'</span>, <span class="string">'Ruby'</span>), (p, q), k=n).count(<span class="string">'Python'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean(trial() &lt;= k <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>_000))</span><br><span class="line"><span class="number">0.8398</span></span><br></pre></td></tr></table></figure><p>在机器学习问题中也经常会出现正态分布。</p><p>Wikipedia 上有一个 <a href="https://en.wikipedia.org/wiki/Naive_Bayes_classifier#Sex_classification" target="_blank" rel="noopener">朴素贝叶斯分类器的好例子</a>。 挑战的问题是根据对多个正态分布的特征测量值包括身高、体重和足部尺码来预测一个人的性别。</p><p>我们得到了由八个人的测量值组成的训练数据集。 假定这些测量值是正态分布的，因此我们用 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 来总结数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>height_male = NormalDist.from_samples([<span class="number">6</span>, <span class="number">5.92</span>, <span class="number">5.58</span>, <span class="number">5.92</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>height_female = NormalDist.from_samples([<span class="number">5</span>, <span class="number">5.5</span>, <span class="number">5.42</span>, <span class="number">5.75</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weight_male = NormalDist.from_samples([<span class="number">180</span>, <span class="number">190</span>, <span class="number">170</span>, <span class="number">165</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weight_female = NormalDist.from_samples([<span class="number">100</span>, <span class="number">150</span>, <span class="number">130</span>, <span class="number">150</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foot_size_male = NormalDist.from_samples([<span class="number">12</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">10</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foot_size_female = NormalDist.from_samples([<span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>接下来，我们遇到一个特征测量值已知但性别未知的新人：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ht = <span class="number">6.0</span>        <span class="comment"># height</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wt = <span class="number">130</span>        <span class="comment"># weight</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fs = <span class="number">8</span>          <span class="comment"># foot size</span></span><br></pre></td></tr></table></figure><p>从是男是女各 50% 的 <a href="https://en.wikipedia.org/wiki/Prior_probability" target="_blank" rel="noopener">先验概率</a> 出发，我们通过将该先验概率乘以给定性别的特征度量值的可能性累积值来计算后验概率：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; prior_male = 0.5</span><br><span class="line">&gt;&gt;&gt; prior_female = 0.5</span><br><span class="line">&gt;&gt;&gt; posterior_male = (prior_male * height_male.pdf(ht) *</span><br><span class="line">...                   weight_male.pdf(wt) * foot_size_male.pdf(fs))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; posterior_female = (prior_female * height_female.pdf(ht) *</span><br><span class="line">...                     weight_female.pdf(wt) * foot_size_female.pdf(fs))</span><br></pre></td></tr></table></figure><p>最终预测值应为最大后验概率值。 这种算法被称为 <a href="https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation" target="_blank" rel="noopener">maximum a posteriori</a> 或 MAP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'male'</span> <span class="keyword">if</span> posterior_male &gt; posterior_female <span class="keyword">else</span> <span class="string">'female'</span></span><br><span class="line"><span class="string">'female'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-statistics-数学统计函数&quot;&gt;&lt;a href=&quot;#python-标准库-statistics-数学统计函数&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 statistics 数学统计函数&quot;&gt;&lt;/a&gt;python 标准库 statistics 数学统计函数&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200206update.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_libray" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-libray/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="statistics" scheme="https://pinghailinfeng.gitee.io/tags/statistics/"/>
    
  </entry>
  
  <entry>
    <title>python standard library uuid</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/05/python-standard-library-uuid/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/05/python-standard-library-uuid/</id>
    <published>2020-02-05T14:07:38.000Z</published>
    <updated>2020-02-11T13:27:57.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-之-uuid"><a href="#python-标准库-之-uuid" class="headerlink" title="python 标准库 之 uuid"></a>python 标准库 之 uuid</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200205update.jpg?raw=true" alt></p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=413961275&auto=0&height=66"></iframe><h2 id="何谓UUID"><a href="#何谓UUID" class="headerlink" title="何谓UUID"></a>何谓UUID</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">UUID是<span class="number">128</span>位的全局唯一标识符，通常由<span class="number">32</span>字节的字符串表示。</span><br><span class="line">   它可以保证时间和空间的唯一性，也称为GUID，全称为：</span><br><span class="line">           UUID —— Universally Unique IDentifier      Python 中叫 UUID</span><br><span class="line">           UUID -- java.util.UUID                     Java 中也叫 UUID</span><br><span class="line">           GUID —— Globally Unique IDentifier         C<span class="comment">#  中叫 GUID</span></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">   它通过MAC地址、时间戳、命名空间、随机数、伪随机数来保证生成ID的唯一性。</span><br><span class="line">   UUID主要有五个算法，也就是五种方法来实现：</span><br><span class="line"></span><br><span class="line">      <span class="number">1</span>、uuid1()——基于时间戳</span><br><span class="line"></span><br><span class="line">              由MAC地址、当前时间戳、随机数生成。可以保证全球范围内的唯一性，</span><br><span class="line">              但MAC的使用同时带来安全性问题，局域网中可以使用IP来代替MAC。</span><br><span class="line"></span><br><span class="line">      <span class="number">2</span>、uuid2()——基于分布式计算环境DCE（Python中没有这个函数）</span><br><span class="line"></span><br><span class="line">               算法与uuid1相同，不同的是把时间戳的前<span class="number">4</span>位置换为POSIX的UID。</span><br><span class="line">               实际中很少用到该方法。</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span>、uuid3()——基于名字的MD5散列值</span><br><span class="line"></span><br><span class="line">               通过计算名字和命名空间的MD5散列值得到，保证了同一命名空间中不同名字的唯一性，</span><br><span class="line">               和不同命名空间的唯一性，但同一命名空间的同一名字生成相同的uuid。    </span><br><span class="line"></span><br><span class="line">      <span class="number">4</span>、uuid4()——基于随机数</span><br><span class="line"></span><br><span class="line">               由伪随机数得到，有一定的重复概率，该概率可以计算出来。</span><br><span class="line"></span><br><span class="line">      <span class="number">5</span>、uuid5()——基于名字的SHA<span class="number">-1</span>散列值</span><br><span class="line"></span><br><span class="line">               算法与uuid3相同，不同的是使用 Secure Hash Algorithm <span class="number">1</span> 算法</span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>Source code:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/uuid.py" target="_blank" rel="noopener">Lib/uuid.py</a> </p><p>  uuid模块包括：不可变对象UUID（UUID类）和函数uuid1()、uuid3()、uuid4()和uuid5()，后面的四个函数用于生成 <a href="http://tools.ietf.org/html/rfc4122.html" target="_blank" rel="noopener">RFC 4122</a> 规范中指定的第1、3、4、5版UUID。使用uuid1()或uuid4()可以获得一个唯一的ID，uuid1()包含了主机的网络名称，uuid4()不涉及网络主机名，仅生成一个随机UUID，因此从隐私保护角度uuid4()更加安全。 </p><h2 id="枚举类型的SafeUUID-类"><a href="#枚举类型的SafeUUID-类" class="headerlink" title="枚举类型的SafeUUID 类"></a>枚举类型的SafeUUID 类</h2><p> <em>class</em> <code>uuid.SafeUUID</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">safe = <span class="number">0</span></span><br><span class="line">unsafe = <span class="number">-1</span></span><br><span class="line">unknown = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="UUID-类-接口"><a href="#UUID-类-接口" class="headerlink" title="UUID 类(接口)"></a>UUID 类(接口)</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法:"></a>基本语法:</h3><p><em>class</em> <code>uuid.UUID</code>(<em>hex=None</em>, <em>bytes=None</em>, <em>bytes_le=None</em>, <em>fields=None</em>, <em>int=None</em>, <em>version=None</em>, <em>**, </em>is_safe=SafeUUID.unknown*) </p><p>下面的各种方法创建相同的UUID对象，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UUID(<span class="string">'&#123;12345678-1234-5678-1234-567812345678&#125;'</span>)</span><br><span class="line">UUID(<span class="string">'12345678123456781234567812345678'</span>)</span><br><span class="line">UUID(<span class="string">'urn:uuid:12345678-1234-5678-1234-567812345678'</span>)</span><br><span class="line">UUID(bytes=<span class="string">b'\x12\x34\x56\x78'</span>*<span class="number">4</span>)</span><br><span class="line">UUID(bytes_le=<span class="string">b'\x78\x56\x34\x12\x34\x12\x78\x56'</span> +</span><br><span class="line">              <span class="string">b'\x12\x34\x56\x78\x12\x34\x56\x78'</span>)</span><br><span class="line">UUID(fields=(<span class="number">0x12345678</span>, <span class="number">0x1234</span>, <span class="number">0x5678</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x567812345678</span>))</span><br><span class="line">UUID(int=<span class="number">0x12345678123456781234567812345678</span>)</span><br></pre></td></tr></table></figure><p>其中:</p><blockquote><p>如果尝试比较一个非UUID对象会引发<code>TypeError</code><br>使用str()函数强制转换一个uuid对象,将会生成一个从<code>12345678-1234-5678-1234-567812345678.</code>中创建的字符串</p></blockquote><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><ul><li><p><code>UUID.bytes</code></p><p>指定一个大端字节序的总长16字节的字节串来创建UUID对象；    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = uuid.UUID(<span class="string">'&#123;12345678-1234-5678-1234-567812345678&#125;'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.bytes</span><br><span class="line"><span class="string">b'\x124Vx\x124Vx\x124Vx\x124Vx'</span></span><br></pre></td></tr></table></figure></li><li><p><code>UUID.bytes_le</code></p><p>指定一个小端字节序的总长16字节的字节串来创建UUID对象；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.bytes_le</span><br><span class="line"><span class="string">b'xV4\x124\x12xV\x124Vx\x124Vx'</span></span><br></pre></td></tr></table></figure></li><li><p><code>UUID.fields</code></p><p>以元组形式存放的UUID的6个整数域，有六个单独的属性和两个派生属性：</p><p>| 域                                                           | 意义                   |<br>| :———————————————————– | :——————— |<br>| <code>time_low</code>                                                   | UUID的前32位           |<br>| <code>time_mid</code>                                                   | 接前一域的16位         |<br>| <code>time_hi_version</code>                                            | 接前一域的16位         |<br>| <code>clock_seq_hi_variant</code>                                       | 接前一域的8位          |<br>| <code>clock_seq_low</code>                                              | 接前一域的8位          |<br>| <code>node</code>                                                       | UUID的最后48位         |<br>| <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> | UUID的总长60位的时间戳 |<br>| <code>clock_seq</code>                                                  | 14位的序列号           |</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.fields</span><br><span class="line">(<span class="number">305419896</span>, <span class="number">4660</span>, <span class="number">22136</span>, <span class="number">18</span>, <span class="number">52</span>, <span class="number">95073701484152</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>UUID.hex</code></p><p> 以32个字符表示的UUID</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.hex</span><br><span class="line"><span class="string">'12345678123456781234567812345678'</span></span><br></pre></td></tr></table></figure></li><li><p><code>UUID.int</code></p><p> 以一个长度为128个二进制位的整数表示的UUID；</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.int</span><br><span class="line"><span class="number">24197857161011715162171839636988778104</span></span><br></pre></td></tr></table></figure></li><li><p><code>UUID.urn</code></p><p> 以 RFC 4122 中指定的URN形式表示的UUID；</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.urn</span><br><span class="line"><span class="string">'urn:uuid:12345678-1234-5678-1234-567812345678'</span></span><br></pre></td></tr></table></figure></li><li><p><code>UUID.variant</code></p><p>　UUID变体（variant），决定UUID内部的布局，已有的值为 RESERVED_NCS、RFC_4122、RESERVED_MICROSOFT 或 RESERVED_FUTURE；</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.variant</span><br><span class="line"><span class="string">'reserved for NCS compatibility'</span></span><br></pre></td></tr></table></figure><ul><li><p><code>UUID.version</code></p><p>返回UUID的版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.version</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>　这里由于u.variant == ‘reserved for NCS compatibility’，所以此处u.version为空。 </p></li><li><p><code>UUID.is_safe</code></p><p>枚举类型的<code>SafeUUID</code>对象,为了标识创建的UUID是否是线程安全的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.is_safe</span><br><span class="line">&lt;SafeUUID.unknown: <span class="literal">None</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3></li></ul><p><strong>关于属性variant，uuid模块定义了如下的常量</strong></p><p> uuid.RESERVED_NCS<br>　　该常量为兼容NCS而保留；<br>　　<br> uuid.RFC_4122<br>　　按照 RFC 4122 的规定来确定UUID的布局；<br>　　<br> uuid.RESERVED_MICROSOFT<br>　　该常量位兼容微软而保留<br> 　　<br> uuid.RESERVED_FUTURE<br>　　该常量为未来可能的定义保留 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以在Python中查看这些常量：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.RESERVED_NCS</span><br><span class="line"><span class="string">'reserved for NCS compatibility'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.RFC_4122</span><br><span class="line"><span class="string">'specified in RFC 4122'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.RESERVED_MICROSOFT</span><br><span class="line"><span class="string">'reserved for Microsoft compatibility'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.RESERVED_FUTURE</span><br><span class="line"><span class="string">'reserved for future definition'</span></span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p><code>uuid.getnode</code>() </p><p>  　获取硬件的地址并以48位二进制长度的正整数形式返回，这里所说的硬件地址是指网络接口的MAC地址，如果一个机器有多个网络接口，可能返回其中的任一个。如果获取失败，将按照RFC 4122的规定将随机返回的48位二进制整数的第8位设置成1。 </p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.getnode()</span><br><span class="line"><span class="number">202960192043486</span></span><br></pre></td></tr></table></figure></li><li><p><code>uuid.uuid1</code>(<em>node=None</em>, <em>clock_seq=None</em>) </p><p>  　利用主机ID、序列号和当前时间生成一个UUID，如果参数 <em>node</em> 没有给定，会调用 getnode() 来获取硬件地址。如果参数中指定了 <em>clock_seq</em> ，使用参数中给定的时钟序列作为序列号，否则使用一个随机的14位长的序列号。 </p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid1()</span><br><span class="line">UUID(<span class="string">'97344912-4827-11ea-9c91-b8975a2679de'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>uuid.uuid3</code>(<em>namespace</em>, <em>name</em>) </p><p> 基于命名空间标识符（实质上是一个UUID）和一个名称（实质上是一个字符串）的MD5哈希值生成UUID。 </p></li><li><p><code>uuid.uuid4</code>() </p><p>生成一个随机的UUID。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid4()</span><br><span class="line">UUID(<span class="string">'ff3c991e-df64-4cfc-900e-ef83c991b513'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>uuid.uuid5</code>(<em>namespace</em>, <em>name</em>) </p><p>基于命名空间标识符（实质上是一个UUID）和一个名称（实质上是一个字符串）的SHA-1哈希值生成UUID </p></li></ul><p>下面的几个标准uuid在使用<code>uuid3()</code> 或<code>uuid5()</code>的时候使用</p><ul><li><p><code>uuid.NAMESPACE_DNS</code></p><p> 　当指定该命名空间时，参数 <em>name</em> 是一个完全限定的（fully-qualified）域名 </p></li><li><p><code>uuid.NAMESPACE_URL</code> </p><p> 当指定该命名空间时，参数 <em>name</em> 是一个URL </p></li><li><p><code>uuid.NAMESPACE_OID</code> </p><p> 当指定该命名空间时，参数 <em>name</em> 是一个ISO OID </p></li><li><p><code>uuid.NAMESPACE_X500</code> </p><p> 当指定该命名空间时，参数 <em>name</em> 是一个DER格式或文本格式的X.500 DN。 </p></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID based on the host ID and current time</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid1()</span><br><span class="line">UUID(<span class="string">'a8098c1a-f86e-11da-bd1a-00112444be1e'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID using an MD5 hash of a namespace UUID and a name</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid3(uuid.NAMESPACE_DNS, <span class="string">'python.org'</span>)</span><br><span class="line">UUID(<span class="string">'6fa459ea-ee8a-3ca4-894e-db77e160355e'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a random UUID</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid4()</span><br><span class="line">UUID(<span class="string">'16fd2706-8baf-433b-82eb-8c7fada847da'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID using a SHA-1 hash of a namespace UUID and a name</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid5(uuid.NAMESPACE_DNS, <span class="string">'python.org'</span>)</span><br><span class="line">UUID(<span class="string">'886313e1-3b8a-5372-9b90-0c9aee199e5d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID from a string of hex digits (braces and hyphens ignored)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = uuid.UUID(<span class="string">'&#123;00010203-0405-0607-0809-0a0b0c0d0e0f&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># convert a UUID to a string of hex digits in standard form</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(x)</span><br><span class="line"><span class="string">'00010203-0405-0607-0809-0a0b0c0d0e0f'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># get the raw 16 bytes of the UUID</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.bytes</span><br><span class="line"><span class="string">b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID from a 16-byte string</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.UUID(bytes=x.bytes)</span><br><span class="line">UUID(<span class="string">'00010203-0405-0607-0809-0a0b0c0d0e0f'</span>)</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="如何去除UUID字符串中的横杠"><a href="#如何去除UUID字符串中的横杠" class="headerlink" title="如何去除UUID字符串中的横杠"></a>如何去除UUID字符串中的横杠</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uid = str(uuid.uuid4())</span><br><span class="line">suid = <span class="string">''</span>.join(uid.split(<span class="string">'-'</span>))</span><br><span class="line"><span class="comment">## 等价于</span></span><br><span class="line">print(uuid.uuid1().hex)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-之-uuid&quot;&gt;&lt;a href=&quot;#python-标准库-之-uuid&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 之 uuid&quot;&gt;&lt;/a&gt;python 标准库 之 uuid&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200205update.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="uuid" scheme="https://pinghailinfeng.gitee.io/tags/uuid/"/>
    
  </entry>
  
</feed>
