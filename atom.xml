<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凭海临风的IT江湖</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pinghailinfeng.gitee.io/"/>
  <updated>2020-01-30T12:22:19.714Z</updated>
  <id>https://pinghailinfeng.gitee.io/</id>
  
  <author>
    <name>Jeff Sui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python standard library concurrent</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/30/python-standard-library-concurrent/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/30/python-standard-library-concurrent/</id>
    <published>2020-01-30T11:09:40.000Z</published>
    <updated>2020-01-30T12:22:19.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-concurrent"><a href="#python-标准库-concurrent" class="headerlink" title="python  标准库 concurrent"></a>python  标准库 concurrent</h1><p><img src="https://img3.doubanio.com/view/group_topic/l/public/p27474097.webp" alt></p><a id="more"></a><blockquote><p>what is love？ 也许一千个人有一千个人的说法。也许当你知道什么是爱的时候,我们已经忘记了曾经也爱过。一生都没弄明白什么是爱。学会爱别人,也学着如何去爱一个人,是一辈子的事。</p><p>​                                                                                                                                                     — 临风语录</p></blockquote><p>送给大家一首歌 How Long Will I Love You.在这个寒冷的季节里,唯有爱才是唯一可以温暖人们的东西吧。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29596326&auto=1&height=66"></iframe><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/concurrent/futures/thread.py" target="_blank" rel="noopener">Lib/concurrent/futures/thread.py</a> 和 <a href="https://github.com/python/cpython/tree/3.8/Lib/concurrent/futures/process.py" target="_blank" rel="noopener">Lib/concurrent/futures/process.py</a></p><p>concurrent模块层次结构如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">concurrent</span><br><span class="line">    |-- futures/</span><br><span class="line">    |-----|--__init__.py</span><br><span class="line">    |-----|--_base.py</span><br><span class="line">    |-----|--process.py</span><br><span class="line">    |-----|--thread.py</span><br><span class="line">    |-- __init__.py</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#module-concurrent.futures" target="_blank" rel="noopener"><code>concurrent.futures</code></a> 模块提供异步执行回调高层接口。</p><p>异步执行可以由 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener"><code>ThreadPoolExecutor</code></a> 使用线程或由 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 使用单独的进程来实现。 两者都是实现抽像类 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 定义的接口。</p><h2 id="Executor对象"><a href="#Executor对象" class="headerlink" title="Executor对象"></a>Executor对象</h2><p><em>class</em> <code>concurrent.futures.Executor</code></p><p>抽象类提供异步执行调用方法。要通过它的子类调用，而不是直接调用。</p><ul><li><p><code>submit</code>(<em>fn</em>, <strong>args<em>, </em></strong>kwargs*)</p><p>调度可调用对象 <em>fn</em>，以 <code>fn(*args **kwargs)</code> 方式执行并返回 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 对像代表可调用对象的执行。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">1</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    future = executor.submit(pow, <span class="number">323</span>, <span class="number">1235</span>)</span><br><span class="line">    print(future.result())</span><br></pre></td></tr></table></figure></li><li><p><code>map</code>(<em>func</em>, *<em>iterables</em>, <em>timeout=None</em>, <em>chunksize=1</em>)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map(func, *iterables)</code></a> 除去：</p><ul><li>应立即收集 <em>iterables</em> 不要延迟再收集;</li><li><em>func</em> 是异步执行的且对 <em>func</em> 的调用可以并发执行。</li></ul><p>如果 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 已被调用且返回的结果在对 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor.map" target="_blank" rel="noopener"><code>Executor.map()</code></a> 的原始调用经过 <em>timeout</em> 秒后还不可用，则已返回的迭代器将引发 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.TimeoutError" target="_blank" rel="noopener"><code>concurrent.futures.TimeoutError</code></a>。 <em>timeout</em> 可以为 int 或 float 类型。 如果 <em>timeout</em> 未指定或为 <code>None</code>，则不限制等待时间。</p><p>如果 <em>func</em> 调用引发一个异常，当从迭代器中取回它的值时这个异常将被引发。</p><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 时，这个方法会将 <em>iterables</em> 分割任务块并作为独立的任务并提交到执行池中。这些块的大概数量可以由 <em>chunksize</em> 指定正整数设置。 对很长的迭代器来说，使用大的 <em>chunksize</em> 值比默认值 1 能显著地提高性能。 <em>chunksize</em> 对 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener"><code>ThreadPoolExecutor</code></a> 没有效果。</p><p><em>在 3.5 版更改:</em> 加入 <em>chunksize</em> 参数。</p></li><li><p><code>shutdown</code>(<em>wait=True</em>)</p><p>当待执行的期程完成执行后向执行者发送信号，它就会释放正在使用的任何资源。调用 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor.submit" target="_blank" rel="noopener"><code>Executor.submit()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor.submit" target="_blank" rel="noopener"><code>Executor.submit()</code></a> 会在关闭后触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p><p>如果 <em>wait</em> 为 <code>True</code> 则此方法只有在所有待执行的期程完成执行且释放已分配的资源后才会返回。 如果 <em>wait</em> 为 <code>False</code>，方法立即返回，所有待执行的期程完成执行后会释放已分配的资源。 不管 <em>wait</em> 的值是什么，整个 Python 程序将等到所有待执行的期程完成执行后才退出。</p><p>如果使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句，你就可以避免显式调用这个方法，它将会停止 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> (就好像 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor.shutdown" target="_blank" rel="noopener"><code>Executor.shutdown()</code></a> 调用时 <em>wait</em> 设为 <code>True</code> 一样等待):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> e:</span><br><span class="line">    e.submit(shutil.copy, <span class="string">'src1.txt'</span>, <span class="string">'dest1.txt'</span>)</span><br><span class="line">    e.submit(shutil.copy, <span class="string">'src2.txt'</span>, <span class="string">'dest2.txt'</span>)</span><br><span class="line">    e.submit(shutil.copy, <span class="string">'src3.txt'</span>, <span class="string">'dest3.txt'</span>)</span><br><span class="line">    e.submit(shutil.copy, <span class="string">'src4.txt'</span>, <span class="string">'dest4.txt'</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener"><code>ThreadPoolExecutor</code></a> 是 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 的子类，它使用线程池来异步执行调用。</p><p>当回调已关联了一个 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 然后再等待另一个 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 的结果时就会发生死锁情况。 例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_on_b</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(b.result())  <span class="comment"># b will never complete because it is waiting on a.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_on_a</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(a.result())  <span class="comment"># a will never complete because it is waiting on b.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">a = executor.submit(wait_on_b)</span><br><span class="line">b = executor.submit(wait_on_a)</span><br></pre></td></tr></table></figure><p>和下面的情况:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_on_future</span><span class="params">()</span>:</span></span><br><span class="line">    f = executor.submit(pow, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># This will never complete because there is only one worker thread and</span></span><br><span class="line">    <span class="comment"># it is executing this function.</span></span><br><span class="line">    print(f.result())</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">1</span>)</span><br><span class="line">executor.submit(wait_on_future)</span><br></pre></td></tr></table></figure><p><em>class</em> <code>concurrent.futures.ThreadPoolExecutor</code>(<em>max_workers=None</em>, <em>thread_name_prefix=’’</em>, <em>initializer=None</em>, <em>initargs=()</em>)</p><p><a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 的一个子类，使用最多 <em>max_workers</em> 个线程的线程池来异步执行调用。</p><p><em>initializer</em> 是在每个工作者线程开始处调用的一个可选可调用对象。 <em>initargs</em> 是传递给初始化器的元组参数。任何向池提交更多工作的尝试， <em>initializer</em> 都将引发一个异常，当前所有等待的工作都会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.thread.BrokenThreadPool" target="_blank" rel="noopener"><code>BrokenThreadPool</code></a>。</p><p><em>在 3.5 版更改:</em> 如果 <em>max_workers</em> 为 <code>None</code> 或没有指定，将默认为机器处理器的个数，假如 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor" target="_blank" rel="noopener"><code>ThreadPoolExecutor</code></a> 则重于 I/O 操作而不是 CPU 运算，那么可以乘以 <code>5</code>，同时工作线程的数量可以比 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 的数量高。</p><p><em>3.6 新版功能:</em> 添加 <em>thread_name_prefix</em> 参数允许用户控制由线程池创建的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>threading.Thread</code></a> 工作线程名称以方便调试。</p><p><em>在 3.7 版更改:</em> 加入 <em>initializer</em> 和<em>initargs</em> 参数。</p><p><em>在 3.8 版更改:</em> <em>max_workers</em> 的默认值已改为 <code>min(32, os.cpu_count() + 4)</code>。 这个默认值会保留至少 5 个工作线程用于 I/O 密集型任务。 它会使用至多 32 个 CPU 核心用于 CPU 密集型任务并将释放 GIL。 它还会避免在多核机器上隐式地使用非常大量的资源。</p><p>现在 ThreadPoolExecutor 在启动 <em>max_workers</em> 个工作线程之前也会重用空闲的工作线程。</p><h3 id="ThreadPoolExecutor-例子"><a href="#ThreadPoolExecutor-例子" class="headerlink" title="ThreadPoolExecutor 例子"></a>ThreadPoolExecutor 例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">URLS = [<span class="string">'http://www.foxnews.com/'</span>,</span><br><span class="line">        <span class="string">'http://www.cnn.com/'</span>,</span><br><span class="line">        <span class="string">'http://europe.wsj.com/'</span>,</span><br><span class="line">        <span class="string">'http://www.bbc.co.uk/'</span>,</span><br><span class="line">        <span class="string">'http://some-made-up-domain.com/'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve a single page and report the URL and contents</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_url</span><span class="params">(url, timeout)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> urllib.request.urlopen(url, timeout=timeout) <span class="keyword">as</span> conn:</span><br><span class="line">        <span class="keyword">return</span> conn.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># We can use a with statement to ensure threads are cleaned up promptly</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># Start the load operations and mark each future with its URL</span></span><br><span class="line">    future_to_url = &#123;executor.submit(load_url, url, <span class="number">60</span>): url <span class="keyword">for</span> url <span class="keyword">in</span> URLS&#125;</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(future_to_url):</span><br><span class="line">        url = future_to_url[future]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = future.result()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            print(<span class="string">'%r generated an exception: %s'</span> % (url, exc))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'%r page is %d bytes'</span> % (url, len(data)))</span><br></pre></td></tr></table></figure><h2 id="ProcessPoolExecutor"><a href="#ProcessPoolExecutor" class="headerlink" title="ProcessPoolExecutor"></a>ProcessPoolExecutor</h2><p><a href="https://github.com/python/cpython/blob/3.8/Lib/concurrent/futures/process.py" target="_blank" rel="noopener">源码</a>中的图示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""Implements ProcessPoolExecutor.</span></span><br><span class="line"><span class="string">The following diagram and text describe the data-flow through the system:</span></span><br><span class="line"><span class="string">|======================= In-process =====================|== Out-of-process ==|</span></span><br><span class="line"><span class="string">+----------+     +----------+       +--------+     +-----------+    +---------+</span></span><br><span class="line"><span class="string">|          |  =&gt; | Work Ids |       |        |     | Call Q    |    | Process |</span></span><br><span class="line"><span class="string">|          |     +----------+       |        |     +-----------+    |  Pool   |</span></span><br><span class="line"><span class="string">|          |     | ...      |       |        |     | ...       |    +---------+</span></span><br><span class="line"><span class="string">|          |     | 6        |    =&gt; |        |  =&gt; | 5, call() | =&gt; |         |</span></span><br><span class="line"><span class="string">|          |     | 7        |       |        |     | ...       |    |         |</span></span><br><span class="line"><span class="string">| Process  |     | ...      |       | Local  |     +-----------+    | Process |</span></span><br><span class="line"><span class="string">|  Pool    |     +----------+       | Worker |                      |  #1..n  |</span></span><br><span class="line"><span class="string">| Executor |                        | Thread |                      |         |</span></span><br><span class="line"><span class="string">|          |     +----------- +     |        |     +-----------+    |         |</span></span><br><span class="line"><span class="string">|          | &lt;=&gt; | Work Items | &lt;=&gt; |        | &lt;=  | Result Q  | &lt;= |         |</span></span><br><span class="line"><span class="string">|          |     +------------+     |        |     +-----------+    |         |</span></span><br><span class="line"><span class="string">|          |     | 6: call()  |     |        |     | ...       |    |         |</span></span><br><span class="line"><span class="string">|          |     |    future  |     |        |     | 4, result |    |         |</span></span><br><span class="line"><span class="string">|          |     | ...        |     |        |     | 3, except |    |         |</span></span><br><span class="line"><span class="string">+----------+     +------------+     +--------+     +-----------+    +---------+</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 是 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 的子类，它使用进程池来实现异步执行调用。 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 使用 <a href="https://docs.python.org/zh-cn/3.8/library/multiprocessing.html#module-multiprocessing" target="_blank" rel="noopener"><code>multiprocessing</code></a> 回避 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-global-interpreter-lock" target="_blank" rel="noopener">Global Interpreter Lock</a> 但也意味着只可以处理和返回可序列化的对象。</p><p><code>__main__</code> 模块必须可以被工作者子进程导入。这意味着 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 不可以工作在交互式解释器中。</p><p>从提交给 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 的回调中调用 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 方法会导致死锁。</p><ul><li><p><em>class</em> <code>concurrent.futures.ProcessPoolExecutor</code>(<em>max_workers=None</em>, <em>mp_context=None</em>, <em>initializer=None</em>, <em>initargs=()</em>)</p><p>异步执行调用的 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 子类使用一个最多有 <em>max_workers</em> 个进程的进程池。 如果 <em>max_workers</em> 为 <code>None</code> 或未给出，它将默认为机器的处理器个数。 如果 <em>max_workers</em> 小于等于 <code>0</code>，则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。 在 Windows 上，<em>max_workers</em> 必须小于等于 <code>61</code>，否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。 如果 <em>max_workers</em> 为 <code>None</code>，则所选择的默认最多为 <code>61</code>，即使存在更多处理器。 <em>mp_context</em> 可以是一个多进程上下文或是 None。 它将被用来启动工作者。 如果 <em>mp_context</em> 为 <code>None</code> 或未给出，将使用默认的多进程上下文。</p><p><em>initializer</em> 是在每个工作者进程开始处调用的一个可选可调用对象。 <em>initargs</em> 是传递给初始化器的元组参数。任何向池提交更多工作的尝试， <em>initializer</em> 都将引发一个异常，当前所有等待的工作都会引发一个 <code>BrokenProcessPool</code>。</p><p><em>在 3.3 版更改:</em> 如果其中一个工作进程被突然终止，<code>BrokenProcessPool</code> 就会马上触发。可预计的行为没有定义，但执行器上的操作或它的期程会被冻结或死锁。</p><p><em>在 3.7 版更改:</em> 添加 <em>mp_context</em> 参数允许用户控制由进程池创建给工作者进程的开始方法 。</p><p>加入 <em>initializer</em> 和<em>initargs</em> 参数。</p></li></ul><h3 id="ProcessPoolExecutor-例子"><a href="#ProcessPoolExecutor-例子" class="headerlink" title="ProcessPoolExecutor 例子"></a>ProcessPoolExecutor 例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">PRIMES = [</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">112582705942171</span>,</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">115280095190773</span>,</span><br><span class="line">    <span class="number">115797848077099</span>,</span><br><span class="line">    <span class="number">1099726899285419</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    sqrt_n = int(math.floor(math.sqrt(n)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, sqrt_n + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="keyword">for</span> number, prime <span class="keyword">in</span> zip(PRIMES, executor.map(is_prime, PRIMES)):</span><br><span class="line">            print(<span class="string">'%d is prime: %s'</span> % (number, prime))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="Future对象"><a href="#Future对象" class="headerlink" title="Future对象"></a>Future对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 类将可调用对象封装为异步执行。<a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 实例由 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor.submit" target="_blank" rel="noopener"><code>Executor.submit()</code></a> 创建。</p><p><em>class</em> <code>concurrent.futures.Future</code></p><p>将可调用对象封装为异步执行。<a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 实例由 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor.submit" target="_blank" rel="noopener"><code>Executor.submit()</code></a> 创建，除非测试，不应直接创建。</p><blockquote><ul><li><p><code>cancel</code>()</p><p>尝试取消调用。 如果调用正在执行或已结束运行不能被取消则该方法将返回 <code>False</code>，否则调用会被取消并且该方法将返回 <code>True</code>。</p></li><li><p><code>cancelled</code>()</p><p>如果调用成功取消返回 <code>True</code>。</p></li><li><p><code>running</code>()</p><p>如果调用正在执行而且不能被取消那么返回True。</p></li><li><p><code>done</code>()</p><p>如果调用已被取消或正常结束那么返回 <code>True</code>。</p></li><li><p><code>result</code>(<em>timeout=None</em>)</p><p>返回调用返回的值。如果调用还没完成那么这个方法将等待 <em>timeout</em> 秒。如果在 <em>timeout</em> 秒内没有执行完成，<a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.TimeoutError" target="_blank" rel="noopener"><code>concurrent.futures.TimeoutError</code></a> 将会被触发。<em>timeout</em> 可以是整数或浮点数。如果 <em>timeout</em> 没有指定或为 <code>None</code>，那么等待时间就没有限制。如果 futrue 在完成前被取消则 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 将被触发。如果调用引发了一个异常，这个方法也会引发同样的异常。</p></li><li><p><code>exception</code>(<em>timeout=None</em>)</p><p>返回由调用引发的异常。如果调用还没完成那么这个方法将等待 <em>timeout</em> 秒。如果在 <em>timeout</em> 秒内没有执行完成，<a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.TimeoutError" target="_blank" rel="noopener"><code>concurrent.futures.TimeoutError</code></a> 将会被触发。<em>timeout</em> 可以是整数或浮点数。如果 <em>timeout</em> 没有指定或为 <code>None</code>，那么等待时间就没有限制。如果 futrue 在完成前被取消则 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 将被触发。如果调用正常完成那么返回 <code>None</code>。</p></li><li><p><code>add_done_callback</code>(<em>fn</em>)</p><p>附加可调用 <em>fn</em> 到期程。当期程被取消或完成运行时，将会调用 <em>fn</em>，而这个期程将作为它唯一的参数。加入的可调用对象总被属于添加它们的进程中的线程按加入的顺序调用。如果可调用对象引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 子类，它会被记录下来并被忽略掉。如果可调用对象引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 子类，这个行为没有定义。如果期程已经完成或已取消，<em>fn</em> 会被立即调用。</p></li></ul></blockquote><p>下面这些 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 方法用于单元测试和 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 实现。</p><blockquote><ul><li><p><code>set_running_or_notify_cancel</code>()</p><p>这个方法只可以在执行关联 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 工作之前由 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 实现调用或由单测试调用。如果这个方法返回 <code>False</code> 那么 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 已被取消，即 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future.cancel" target="_blank" rel="noopener"><code>Future.cancel()</code></a> 已被调用并返回 <code>True</code> 。等待 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 完成 (即通过 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.as_completed" target="_blank" rel="noopener"><code>as_completed()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.wait" target="_blank" rel="noopener"><code>wait()</code></a>) 的线程将被唤醒。如果这个方法返回 <code>True</code> 那么 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 不会被取消并已将它变为正在运行状态，也就是说调用 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future.running" target="_blank" rel="noopener"><code>Future.running()</code></a> 时将返回 True。这个方法只可以被调用一次并且不能在调用 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future.set_result" target="_blank" rel="noopener"><code>Future.set_result()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future.set_exception" target="_blank" rel="noopener"><code>Future.set_exception()</code></a> 之后再调用。</p></li><li><p><code>set_result</code>(<em>result</em>)</p><p>设置将 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 关联工作的结果给 <em>result</em> 。这个方法只可以由 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 实现和单元测试使用。<em>在 3.8 版更改:</em> 如果 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 已经完成则此方法会引发 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.InvalidStateError" target="_blank" rel="noopener"><code>concurrent.futures.InvalidStateError</code></a>。</p></li><li><p><code>set_exception</code>(<em>exception</em>)</p><p>设置 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 关联工作的结果给 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> <em>exception</em> 。这个方法只可以由 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 实现和单元测试使用。<em>在 3.8 版更改:</em> 如果 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 已经完成则此方法会引发 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.InvalidStateError" target="_blank" rel="noopener"><code>concurrent.futures.InvalidStateError</code></a>。</p></li></ul></blockquote><h2 id="模块函数"><a href="#模块函数" class="headerlink" title="模块函数"></a>模块函数</h2><p><code>concurrent.futures.wait</code>(<em>fs</em>, <em>timeout=None</em>, <em>return_when=ALL_COMPLETED</em>)</p><p>等待 <em>fs</em> 指定的 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 实例（可能由不同的 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 实例创建）完成。 返回一个由集合构成的具名 2 元组。 第一个集合名称为 <code>done</code>，包含在等待完成之前已完成的期程（包括正常结束或被取消的期程）。 第二个集合名称为 <code>not_done</code>，包含未完成的期程（包括挂起的或正在运行的期程）。</p><p><em>timeout</em> 可以用来控制返回前最大的等待秒数。 <em>timeout</em> 可以为 int 或 float 类型。 如果 <em>timeout</em> 未指定或为 <code>None</code> ，则不限制等待时间。</p><p><em>return_when</em> 指定此函数应在何时返回。它必须为以下常数之一:</p><table><thead><tr><th>常数</th><th>描述</th></tr></thead><tbody><tr><td><code>FIRST_COMPLETED</code></td><td>函数将在任意可等待对象结束或取消时返回。</td></tr><tr><td><code>FIRST_EXCEPTION</code></td><td>函数将在任意可等待对象因引发异常而结束时返回。当没有引发任何异常时它就相当于 <code>ALL_COMPLETED</code>。</td></tr><tr><td><code>ALL_COMPLETED</code></td><td>函数将在所有可等待对象结束或取消时返回。</td></tr></tbody></table><p><code>concurrent.futures.as_completed</code>(<em>fs</em>, <em>timeout=None</em>)</p><p>返回一个包含 <em>fs</em> 所指定的 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>Future</code></a> 实例（可能由不同的 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Executor" target="_blank" rel="noopener"><code>Executor</code></a> 实例创建）的迭代器，这些实例会在完成时生成期程（包括正常结束或被取消的期程）。 任何由 <em>fs</em> 所指定的重复期程将只被返回一次。 任何在 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.as_completed" target="_blank" rel="noopener"><code>as_completed()</code></a> 被调用之前完成的期程将优先被生成。 如果 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 被调用并且在对 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.as_completed" target="_blank" rel="noopener"><code>as_completed()</code></a> 的原始调用 <em>timeout</em> 秒之后结果仍不可用，则返回的迭代器将引发 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.TimeoutError" target="_blank" rel="noopener"><code>concurrent.futures.TimeoutError</code></a>。 <em>timeout</em> 可以为整数或浮点数。 如果 <em>timeout</em> 未指定或为 <code>None</code>，则不限制等待时间。</p><blockquote><p><a href="https://www.python.org/dev/peps/pep-3148" target="_blank" rel="noopener"><strong>PEP 3148</strong></a> – futures - 异步执行指令。</p><p>该提案描述了Python标准库中包含的这个特性。</p></blockquote><h2 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h2><ul><li><p><em>exception</em> <code>concurrent.futures.CancelledError</code></p><p>future被取消时会触发。</p></li><li><p><em>exception</em> <code>concurrent.futures.TimeoutError</code></p><p>future运算超出给定的超时数值时触发。</p></li><li><p><em>exception</em> <code>concurrent.futures.BrokenExecutor</code></p><p>当执行器被某些原因中断而且不能用来提交或执行新任务时就会被引发派生于 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 的异常类。<em>3.7 新版功能.</em></p></li><li><p><em>exception</em> <code>concurrent.futures.InvalidStateError</code></p><p>当某个操作在一个当前状态所不允许的 future 上执行时将被引发。<em>3.8 新版功能.</em></p></li><li><p><em>exception</em> <code>concurrent.futures.thread.BrokenThreadPool</code></p><p>当 <code>ThreadPoolExecutor</code> 中的其中一个工作者初始化失败时会引发派生于 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.BrokenExecutor" target="_blank" rel="noopener"><code>BrokenExecutor</code></a> 的异常类。<em>3.7 新版功能.</em></p></li><li><p><em>exception</em> <code>concurrent.futures.process.BrokenProcessPool</code></p><p>当 <code>ThreadPoolExecutor</code> 中的其中一个工作者不完整终止时(比如，被外部杀死)会引发派生于 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.BrokenExecutor" target="_blank" rel="noopener"><code>BrokenExecutor</code></a> ( 原名 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> ) 的异常类。</p></li></ul><h2 id="补充例子"><a href="#补充例子" class="headerlink" title="补充例子"></a>补充例子</h2><h3 id="submit例子"><a href="#submit例子" class="headerlink" title="submit例子"></a><code>submit</code>例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#线程执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(n1,n2)</span>:</span></span><br><span class="line">    v = n1 + n2</span><br><span class="line">    print(<span class="string">'add :'</span>, v , <span class="string">', tid:'</span>,threading.currentThread().ident)</span><br><span class="line">    time.sleep(n1)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line"><span class="comment">#通过submit把需要执行的函数扔进线程池中.</span></span><br><span class="line"><span class="comment">#submit 直接返回一个future对象</span></span><br><span class="line">ex = ThreadPoolExecutor(max_workers=<span class="number">3</span>)      <span class="comment">#制定最多运行N个线程</span></span><br><span class="line">f1 = ex.submit(add,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">f2 = ex.submit(add,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">print(<span class="string">'main thread running'</span>)</span><br><span class="line">print(f1.done())                            <span class="comment">#done 看看任务结束了没</span></span><br><span class="line">print(f1.result())                          <span class="comment">#获取结果 ,阻塞方法</span></span><br></pre></td></tr></table></figure><h3 id="返回-map-例子"><a href="#返回-map-例子" class="headerlink" title="返回 map 例子"></a>返回 <code>map</code> 例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下面是map 方法的简单使用.  注意:map 返回是一个生成器 ,并且是*有序的*</span></span><br><span class="line">URLS = [<span class="string">'http://www.baidu.com'</span>, <span class="string">'http://www.qq.com'</span>, <span class="string">'http://www.sina.com.cn'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'thread id:'</span>,threading.currentThread().ident,<span class="string">' 访问了:'</span>,url)</span><br><span class="line">    <span class="keyword">return</span> requests.get(url)            <span class="comment">#这里使用了requests 模块</span></span><br><span class="line">ex = ThreadPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line">res_iter = ex.map(get_html,URLS)        <span class="comment">#内部迭代中, 每个url 开启一个线程</span></span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> res_iter:                    <span class="comment">#此时将阻塞 , 直到线程完成或异常</span></span><br><span class="line">    print(<span class="string">'url:%s ,len: %d'</span>%(res.url,len(res.text)))</span><br></pre></td></tr></table></figure><h3 id="as-complated-例子"><a href="#as-complated-例子" class="headerlink" title="as_complated 例子"></a><code>as_complated</code> 例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">URLS = [<span class="string">'http://www.baidu.com'</span>, <span class="string">'http://www.qq.com'</span>, <span class="string">'http://www.sina.com.cn'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'thread id:'</span>,threading.currentThread().ident,<span class="string">' 访问了:'</span>,url)</span><br><span class="line">    <span class="keyword">return</span> requests.get(url)            <span class="comment">#这里使用了requests 模块</span></span><br><span class="line">ex = ThreadPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line">f = ex.submit(get_html,URLS[<span class="number">0</span>])          <span class="comment">#提交一个任务,放入线程池中,准备执行</span></span><br><span class="line">print(<span class="string">'main thread running'</span>)</span><br><span class="line"><span class="keyword">for</span> future <span class="keyword">in</span> as_completed([f]):        <span class="comment">#as_completed()接受一个可迭代的Future序列,返回一个生成器,在完成或异常时返回这个Future对象</span></span><br><span class="line">    print(<span class="string">'一个任务完成.'</span>)</span><br><span class="line">    print(future.result())</span><br></pre></td></tr></table></figure><h3 id="as-complated-详细例子"><a href="#as-complated-详细例子" class="headerlink" title="as_complated 详细例子"></a><code>as_complated</code> 详细例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#as_completed 完整的例子</span></span><br><span class="line"><span class="comment">#as_completed 返回一个生成器，用于迭代， 一旦一个线程完成(或失败) 就返回</span></span><br><span class="line">URLS = [<span class="string">'http://www.baidu.com'</span>, <span class="string">'http://www.qq.com'</span>, <span class="string">'http://www.sina.com.cn'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread id:'</span>,threading.currentThread().ident,<span class="string">' 访问了:'</span>,url)</span><br><span class="line">    <span class="keyword">return</span> requests.get(url)            <span class="comment">#这里使用了requests 模块</span></span><br><span class="line">ex = ThreadPoolExecutor(max_workers=<span class="number">3</span>)   <span class="comment">#最多3个线程</span></span><br><span class="line">future_tasks = [ex.submit(get_html,url) <span class="keyword">for</span> url <span class="keyword">in</span> URLS]    <span class="comment">#创建3个future对象</span></span><br><span class="line"><span class="keyword">for</span> future <span class="keyword">in</span> as_completed(future_tasks):       <span class="comment">#迭代生成器</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = future.result()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'%s'</span>%e)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'%s has %d bytes!'</span>%(resp.url, len(resp.text)))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">thread id: 5160  访问了: http://www.baidu.com</span></span><br><span class="line"><span class="string">thread id: 7752  访问了: http://www.sina.com.cn</span></span><br><span class="line"><span class="string">thread id: 5928  访问了: http://www.qq.com</span></span><br><span class="line"><span class="string">http://www.qq.com/ has 240668 bytes!</span></span><br><span class="line"><span class="string">http://www.baidu.com/ has 2381 bytes!</span></span><br><span class="line"><span class="string">https://www.sina.com.cn/ has 577244 bytes!</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><ul><li><code>as_complated</code> 返回的是迭代器,在迭代过程中会阻塞</li><li>直到线程完成或者异常时,返回一个被 <code>set_result</code>的<code>Future</code>对象</li><li>map方法返回的是有序的,<code>as_complated</code> 是哪个线程先完成/失败时就返回</li></ul><h3 id="wait例子（阻塞"><a href="#wait例子（阻塞" class="headerlink" title="wait例子（阻塞)"></a>wait例子（阻塞)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">wait 例子</span></span><br><span class="line"><span class="string">参数:</span></span><br><span class="line"><span class="string">    FIRST_COMPLETED    当任何未来完成或被取消时，该函数将返回。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    FIRST_EXCEPTION    当任何未来通过提出异常完成时，函数将返回。如果没有未来引发异常，那么它等同于 ALL_COMPLETED。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    ALL_COMPLETED(默认)      当所有future完成或被取消时，函数将返回。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">URLS = [<span class="string">'http://www.baidu.com'</span>, <span class="string">'http://www.qq.com'</span>, <span class="string">'http://www.sina.com.cn'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'thread id:'</span>,threading.currentThread().ident,<span class="string">' 访问了:'</span>,url)</span><br><span class="line">    <span class="keyword">return</span> requests.get(url)            <span class="comment">#这里使用了requests 模块</span></span><br><span class="line">ex = ThreadPoolExecutor(max_workers=<span class="number">3</span>)   <span class="comment">#最多3个线程</span></span><br><span class="line">future_tasks = [ex.submit(get_html,url) <span class="keyword">for</span> url <span class="keyword">in</span> URLS]    <span class="comment">#创建3个future对象</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = wait(future_tasks,return_when = fu.FIRST_COMPLETED)</span><br><span class="line">    done_set = result[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> done_set:</span><br><span class="line">        resp = future.result()</span><br><span class="line">        print(<span class="string">'第一个网页任务完成 url:%s , len:%d bytes! '</span> % (resp.url, len(resp.text)))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'exception :'</span> , e)</span><br></pre></td></tr></table></figure><h3 id="add-done-callback-fn-例子"><a href="#add-done-callback-fn-例子" class="headerlink" title="add_done__callback(fn)例子"></a><code>add_done__callback(fn)</code>例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os,sys,time,requests,threading</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">URLS = [</span><br><span class="line">        <span class="string">'http://baidu.com'</span>,</span><br><span class="line">        <span class="string">'http://www.qq.com'</span>,</span><br><span class="line">        <span class="string">'http://www.sina.com.cn'</span></span><br><span class="line">        ]</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'tid:'</span>,threading.currentThread().ident,<span class="string">',url:'</span>,url)</span><br><span class="line">    <span class="keyword">with</span> requests.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">return</span> resp.content</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_back</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid:'</span>,threading.currentThread().ident, <span class="string">',obj:'</span>,obj)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> ex:</span><br><span class="line">    <span class="comment"># mp = &#123;ex.submit(load_url,url) : url for url in URLS&#125;</span></span><br><span class="line">    mp = dict()</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> URLS:</span><br><span class="line">        f = ex.submit(load_url,url)</span><br><span class="line">        mp[f] = url</span><br><span class="line">        f.add_done_callback(call_back)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> futures.as_completed(mp):</span><br><span class="line">        url = mp[f]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = f.result()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            print(exc, <span class="string">',url:'</span>,url)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'url:'</span>, url, <span class="string">',len:'</span>,len(data),<span class="string">',data[:20]:'</span>,data[:<span class="number">20</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">tid: 7128 ,url: http://baidu.com</span></span><br><span class="line"><span class="string">tid: 7892 ,url: http://www.qq.com</span></span><br><span class="line"><span class="string">tid: 3712 ,url: http://www.sina.com.cn</span></span><br><span class="line"><span class="string">-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid: 7892 ,obj: &lt;Future at 0x2dd64b0 state=finished returned bytes&gt;</span></span><br><span class="line"><span class="string">url: http://www.qq.com ,len: 251215 ,data[:20]: b'&lt;!DOCTYPE html&gt;\n&lt;htm'</span></span><br><span class="line"><span class="string">-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid: 3712 ,obj: &lt;Future at 0x2de07b0 state=finished returned bytes&gt;</span></span><br><span class="line"><span class="string">url: http://www.sina.com.cn ,len: 577333 ,data[:20]: b'&lt;!DOCTYPE html&gt;\n&lt;!--'</span></span><br><span class="line"><span class="string">-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid: 7128 ,obj: &lt;Future at 0x2d533d0 state=finished returned bytes&gt;</span></span><br><span class="line"><span class="string">url: http://baidu.com ,len: 81 ,data[:20]: b'&lt;html&gt;\n&lt;meta http-eq'</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="futures例子"><a href="#futures例子" class="headerlink" title="futures例子"></a>futures例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os,sys,time,requests,threading</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">URLS = [</span><br><span class="line">        <span class="string">'http://baidu.com'</span>,</span><br><span class="line">        <span class="string">'http://www.qq.com'</span>,</span><br><span class="line">        <span class="string">'http://www.sina.com.cn'</span></span><br><span class="line">        ]</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'tid:'</span>,threading.currentThread().ident,<span class="string">',url:'</span>,url)</span><br><span class="line">    <span class="keyword">with</span> requests.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">return</span> resp.content</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_back</span><span class="params">(obj)</span>:</span></span><br><span class="line">    print(<span class="string">'-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid:'</span>,threading.currentThread().ident, <span class="string">',obj:'</span>,obj)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> ex:</span><br><span class="line">    <span class="comment"># mp = &#123;ex.submit(load_url,url) : url for url in URLS&#125;</span></span><br><span class="line">    mp = dict()</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> URLS:</span><br><span class="line">        f = ex.submit(load_url,url)</span><br><span class="line">        mp[f] = url</span><br><span class="line">        f.add_done_callback(call_back)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> futures.as_completed(mp):</span><br><span class="line">        url = mp[f]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = f.result()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            print(exc, <span class="string">',url:'</span>,url)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'url:'</span>, url, <span class="string">',len:'</span>,len(data),<span class="string">',data[:20]:'</span>,data[:<span class="number">20</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">tid: 7128 ,url: http://baidu.com</span></span><br><span class="line"><span class="string">tid: 7892 ,url: http://www.qq.com</span></span><br><span class="line"><span class="string">tid: 3712 ,url: http://www.sina.com.cn</span></span><br><span class="line"><span class="string">-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid: 7892 ,obj: &lt;Future at 0x2dd64b0 state=finished returned bytes&gt;</span></span><br><span class="line"><span class="string">url: http://www.qq.com ,len: 251215 ,data[:20]: b'&lt;!DOCTYPE html&gt;\n&lt;htm'</span></span><br><span class="line"><span class="string">-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid: 3712 ,obj: &lt;Future at 0x2de07b0 state=finished returned bytes&gt;</span></span><br><span class="line"><span class="string">url: http://www.sina.com.cn ,len: 577333 ,data[:20]: b'&lt;!DOCTYPE html&gt;\n&lt;!--'</span></span><br><span class="line"><span class="string">-&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;call_back , tid: 7128 ,obj: &lt;Future at 0x2d533d0 state=finished returned bytes&gt;</span></span><br><span class="line"><span class="string">url: http://baidu.com ,len: 81 ,data[:20]: b'&lt;html&gt;\n&lt;meta http-eq'</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>切记一定要使用with，而不要使用for，如果你一定要用for，那么一定要手动进行executor.shutdown，而你使用了with方法的话，再with方法内部已经实现了wait(),在使用完毕之后可以自行关闭线程池，减少资源浪费。</li><li><code>ProcessPoolExecutor</code>类会利用multiprocessing模块所提供的底层机制，multiprocessing是基于进程的并行。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-concurrent&quot;&gt;&lt;a href=&quot;#python-标准库-concurrent&quot; class=&quot;headerlink&quot; title=&quot;python  标准库 concurrent&quot;&gt;&lt;/a&gt;python  标准库 concurrent&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://img3.doubanio.com/view/group_topic/l/public/p27474097.webp&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="concurrent" scheme="https://pinghailinfeng.gitee.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>python standard library html.parser</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/29/python-standard-library-html-parser/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/29/python-standard-library-html-parser/</id>
    <published>2020-01-29T12:24:57.000Z</published>
    <updated>2020-01-30T08:43:58.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-html-parser-简单HTML和XHTML解析器"><a href="#python-标准库-html-parser-简单HTML和XHTML解析器" class="headerlink" title="python 标准库  html.parser 简单HTML和XHTML解析器"></a>python 标准库  html.parser 简单HTML和XHTML解析器</h1><p><img src="https://cn.bing.com/th?id=OIP.cq-61gMRe77h_MW4ca_0egHaFj&amp;pid=Api&amp;rs=1" alt></p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=595024&auto=0&height=66"></iframe><h2 id="源代码：-Lib-html-parser-py"><a href="#源代码：-Lib-html-parser-py" class="headerlink" title="源代码： Lib/html/parser.py"></a><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/html/parser.py" target="_blank" rel="noopener">Lib/html/parser.py</a></h2><p>这个模块定义了一个 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser" target="_blank" rel="noopener"><code>HTMLParser</code></a> 类，为 HTML（超文本标记语言）和 XHTML 文本文件解析提供基础。</p><ul><li><p><em>class</em> <code>html.parser.HTMLParser</code>(<em>**, </em>convert_charrefs=True*)</p><p>创建一个能解析无效标记的解析器实例。如果 <em>convert_charrefs</em> 为 <code>True</code> (默认值)，则所有字符引用( <code>script</code>/<code>style</code> 元素中的除外)都会自动转换为相应的 Unicode 字符。一个 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser" target="_blank" rel="noopener"><code>HTMLParser</code></a> 类的实例用来接受 HTML 数据，并在标记开始、标记结束、文本、注释和其他元素标记出现的时候调用对应的方法。要实现具体的行为，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser" target="_blank" rel="noopener"><code>HTMLParser</code></a> 的子类并重载其方法。这个解析器不检查结束标记是否与开始标记匹配，也不会因外层元素完毕而隐式关闭了的元素引发结束标记处理。</p></li></ul><h2 id="HTML-解析器的示例程序"><a href="#HTML-解析器的示例程序" class="headerlink" title="HTML 解析器的示例程序"></a>HTML 解析器的示例程序</h2><p>下面是简单的 HTML 解析器的一个基本示例，使用 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser" target="_blank" rel="noopener"><code>HTMLParser</code></a> 类，当遇到开始标记、结束标记以及数据的时候将内容打印出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> html.parser <span class="keyword">import</span> HTMLParser</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHTMLParser</span><span class="params">(HTMLParser)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_starttag</span><span class="params">(self, tag, attrs)</span>:</span></span><br><span class="line">        print(<span class="string">"Encountered a start tag:"</span>, tag)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_endtag</span><span class="params">(self, tag)</span>:</span></span><br><span class="line">        print(<span class="string">"Encountered an end tag :"</span>, tag)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        print(<span class="string">"Encountered some data  :"</span>, data)</span><br><span class="line"></span><br><span class="line">parser = MyHTMLParser()</span><br><span class="line">parser.feed(<span class="string">'&lt;html&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;'</span></span><br><span class="line">            <span class="string">'&lt;body&gt;&lt;h1&gt;Parse me!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'</span>)</span><br></pre></td></tr></table></figure><p> 输出是: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Encountered a start tag: html</span><br><span class="line">Encountered a start tag: head</span><br><span class="line">Encountered a start tag: title</span><br><span class="line">Encountered some data  : Test</span><br><span class="line">Encountered an end tag : title</span><br><span class="line">Encountered an end tag : head</span><br><span class="line">Encountered a start tag: body</span><br><span class="line">Encountered a start tag: h1</span><br><span class="line">Encountered some data  : Parse me!</span><br><span class="line">Encountered an end tag : h1</span><br><span class="line">Encountered an end tag : body</span><br><span class="line">Encountered an end tag : html</span><br></pre></td></tr></table></figure><h2 id="HTMLParser-方法"><a href="#HTMLParser-方法" class="headerlink" title="HTMLParser 方法"></a><code>HTMLParser</code> 方法</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser" target="_blank" rel="noopener"><code>HTMLParser</code></a> 实例有下列方法：</p><ul><li><p><code>HTMLParser.feed</code>(<em>data</em>)</p><p>填充一些文本到解析器中。如果包含完整的元素，则被处理；如果数据不完整，将被缓冲直到更多的数据被填充，或者 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.close" target="_blank" rel="noopener"><code>close()</code></a> 被调用。<em>data</em> 必须为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 类型。</p></li><li><p><code>HTMLParser.close</code>()</p><p>如同后面跟着一个文件结束标记一样，强制处理所有缓冲数据。这个方法能被派生类重新定义，用于在输入的末尾定义附加处理，但是重定义的版本应当始终调用基类 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser" target="_blank" rel="noopener"><code>HTMLParser</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.close" target="_blank" rel="noopener"><code>close()</code></a> 方法。</p></li><li><p><code>HTMLParser.reset</code>()</p><p>重置实例。丢失所有未处理的数据。在实例化阶段被隐式调用。</p></li><li><p><code>HTMLParser.getpos</code>()</p><p>返回当前行号和偏移值。</p></li><li><p><code>HTMLParser.get_starttag_text</code>()</p><p>返回最近打开的开始标记中的文本。 结构化处理时通常应该不需要这个，但在处理“已部署”的 HTML 或是在以最小改变来重新生成输入时可能会有用处（例如可以保留属性间的空格等）。</p></li></ul><p>下列方法将在遇到数据或者标记元素的时候被调用。他们需要在子类中重载。基类的实现中没有任何实际操作（除了 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.handle_startendtag" target="_blank" rel="noopener"><code>handle_startendtag()</code></a> ）：</p><ul><li><p><code>HTMLParser.handle_starttag</code>(<em>tag</em>, <em>attrs</em>)</p><p>这个方法在标签开始的时候被调用（例如：  ）。<em>tag</em> 参数是小写的标记名。<em>attrs</em> 参数是一个 <code>(name, value)</code> 形式的列表，包含了所有在标记的 <code>&lt;&gt;</code> 括号中找到的属性。<em>name</em> 转换为小写，<em>value</em> 的引号被去除，字符和实体引用都会被替换。实例中，对于标签 ，这个方法将以下列形式被调用 <code>handle_starttag(&#39;a&#39;, [(&#39;href&#39;, &#39;https://www.cwi.nl/&#39;)])</code> 。<a href="https://docs.python.org/zh-cn/3.8/library/html.entities.html#module-html.entities" target="_blank" rel="noopener"><code>html.entities</code></a> 中的所有实体引用，会被替换为属性值。</p></li><li><p><code>HTMLParser.handle_endtag</code>(<em>tag</em>)</p><p>此方法被用来处理元素的结束标记（例如：  ）。<em>tag</em> 参数是小写的标签名。</p></li><li><p><code>HTMLParser.handle_startendtag</code>(<em>tag</em>, <em>attrs</em>)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.handle_starttag" target="_blank" rel="noopener"><code>handle_starttag()</code></a>, 只是在解析器遇到 XHTML 样式的空标记时被调用（ ）。这个方法能被需要这种特殊词法信息的子类重载；默认实现仅简单调用 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.handle_starttag" target="_blank" rel="noopener"><code>handle_starttag()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.handle_endtag" target="_blank" rel="noopener"><code>handle_endtag()</code></a> 。</p></li><li><p><code>HTMLParser.handle_data</code>(<em>data</em>)</p><p>这个方法被用来处理任意数据（例如：文本节点和 <code>...</code> 以及 <code>...</code> 中的内容）。</p></li><li><p><code>HTMLParser.handle_entityref</code>(<em>name</em>)</p><p>这个方法被用于处理 <code>&amp;name;</code> 形式的命名字符引用（例如 <code>&gt;</code>），其中 <em>name</em> 是通用的实体引用（例如： <code>&#39;gt&#39;</code>）。如果 <em>convert_charrefs</em> 为 <code>True</code>，该方法永远不会被调用。</p></li><li><p><code>HTMLParser.handle_charref</code>(<em>name</em>)</p><p>这个方法被用来处理 <code>&amp;#NNN;</code> 和 <code>&amp;#xNNN;</code> 形式的十进制和十六进制字符引用。例如，<code>&gt;</code> 等效的十进制形式为 <code>&gt;</code> ，而十六进制形式为 <code>&gt;</code> ；在这种情况下，方法将收到 <code>&#39;62&#39;</code> 或 <code>&#39;x3E&#39;</code> 。如果 <em>convert_charrefs</em> 为 <code>True</code> ，则该方法永远不会被调用。</p></li><li><p><code>HTMLParser.handle_comment</code>(<em>data</em>)</p><p>这个方法在遇到注释的时候被调用（例如：  ）。例如，  这个注释会用 <code>&#39; comment &#39;</code> 作为参数调用此方法。Internet Explorer 条件注释（condcoms）的内容也被发送到这个方法，因此，对于  ，这个方法将接收到 `’[if IE 9]&gt;IE9-specific content 。</p></li><li><p><code>HTMLParser.handle_decl</code>(<em>decl</em>)</p><p>这个方法用来处理 HTML doctype 申明（例如  ）。<em>decl</em> 形参为  标记中的所有内容（例如： <code>&#39;DOCTYPE html&#39;</code> ）。</p></li><li><p><code>HTMLParser.handle_pi</code>(<em>data</em>)</p><p>此方法在遇到处理指令的时候被调用。<em>data</em> 形参将包含整个处理指令。例如，对于处理指令  ，这个方法将以 <code>handle_pi(&quot;proc color=&#39;red&#39;&quot;)</code> 形式被调用。它旨在被派生类重载；基类实现中无任何实际操作。注解 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser" target="_blank" rel="noopener"><code>HTMLParser</code></a> 类使用 SGML 语法规则处理指令。使用 <code>&#39;?&#39;</code> 结尾的 XHTML 处理指令将导致 <code>&#39;?&#39;</code> 包含在 <em>data</em> 中。</p></li><li><p><code>HTMLParser.unknown_decl</code>(<em>data</em>)</p><p>当解析器读到无法识别的声明时，此方法被调用。<em>data</em> 形参为  标记中的所有内容。某些时候对派生类的重载很有用。基类实现中无任何实际操作。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面的类实现了一个解析器，用于更多示例的演示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> html.parser <span class="keyword">import</span> HTMLParser</span><br><span class="line"><span class="keyword">from</span> html.entities <span class="keyword">import</span> name2codepoint</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHTMLParser</span><span class="params">(HTMLParser)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_starttag</span><span class="params">(self, tag, attrs)</span>:</span></span><br><span class="line">        print(<span class="string">"Start tag:"</span>, tag)</span><br><span class="line">        <span class="keyword">for</span> attr <span class="keyword">in</span> attrs:</span><br><span class="line">            print(<span class="string">"     attr:"</span>, attr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_endtag</span><span class="params">(self, tag)</span>:</span></span><br><span class="line">        print(<span class="string">"End tag  :"</span>, tag)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        print(<span class="string">"Data     :"</span>, data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_comment</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        print(<span class="string">"Comment  :"</span>, data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_entityref</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        c = chr(name2codepoint[name])</span><br><span class="line">        print(<span class="string">"Named ent:"</span>, c)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_charref</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">'x'</span>):</span><br><span class="line">            c = chr(int(name[<span class="number">1</span>:], <span class="number">16</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c = chr(int(name))</span><br><span class="line">        print(<span class="string">"Num ent  :"</span>, c)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_decl</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        print(<span class="string">"Decl     :"</span>, data)</span><br><span class="line"></span><br><span class="line">parser = MyHTMLParser()</span><br></pre></td></tr></table></figure></li></ul><p>解析一个文档类型声明:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" '</span></span><br><span class="line"><span class="meta">... </span>            <span class="string">'"http://www.w3.org/TR/html4/strict.dtd"&gt;'</span>)</span><br><span class="line">Decl     : DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01//EN"</span> <span class="string">"http://www.w3.org/TR/html4/strict.dtd"</span></span><br></pre></td></tr></table></figure><p>解析一个具有一些属性和标题的元素:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;img src="python-logo.png" alt="The Python logo"&gt;'</span>)</span><br><span class="line">Start tag: img</span><br><span class="line">     attr: (<span class="string">'src'</span>, <span class="string">'python-logo.png'</span>)</span><br><span class="line">     attr: (<span class="string">'alt'</span>, <span class="string">'The Python logo'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;h1&gt;Python&lt;/h1&gt;'</span>)</span><br><span class="line">Start tag: h1</span><br><span class="line">Data     : Python</span><br><span class="line">End tag  : h1</span><br></pre></td></tr></table></figure><p><code>script</code> 和 <code>style</code> 元素中的内容原样返回，无需进一步解析:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;style type="text/css"&gt;#python &#123; color: green &#125;&lt;/style&gt;'</span>)</span><br><span class="line">Start tag: style</span><br><span class="line">     attr: (<span class="string">'type'</span>, <span class="string">'text/css'</span>)</span><br><span class="line">Data     : <span class="comment">#python &#123; color: green &#125;</span></span><br><span class="line">End tag  : style</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;script type="text/javascript"&gt;'</span></span><br><span class="line"><span class="meta">... </span>            <span class="string">'alert("&lt;strong&gt;hello!&lt;/strong&gt;");&lt;/script&gt;'</span>)</span><br><span class="line">Start tag: script</span><br><span class="line">     attr: (<span class="string">'type'</span>, <span class="string">'text/javascript'</span>)</span><br><span class="line">Data     : alert(<span class="string">"&lt;strong&gt;hello!&lt;/strong&gt;"</span>);</span><br><span class="line">End tag  : script</span><br></pre></td></tr></table></figure><p>解析注释:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;!-- a comment --&gt;'</span></span><br><span class="line"><span class="meta">... </span>            <span class="string">'&lt;!--[if IE 9]&gt;IE-specific content&lt;![endif]--&gt;'</span>)</span><br><span class="line">Comment  :  a comment</span><br><span class="line">Comment  : [<span class="keyword">if</span> IE <span class="number">9</span>]&gt;IE-specific content&lt;![endif]</span><br></pre></td></tr></table></figure><p>解析命名或数字形式的字符引用，并把他们转换到正确的字符（注意：这 3 种转义都是 <code>&#39;&gt;&#39;</code> ）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&amp;gt;&amp;#62;&amp;#x3E;'</span>)</span><br><span class="line">Named ent: &gt;</span><br><span class="line">Num ent  : &gt;</span><br><span class="line">Num ent  : &gt;</span><br></pre></td></tr></table></figure><p>填充不完整的块给 <a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.feed" target="_blank" rel="noopener"><code>feed()</code></a> 执行，<a href="https://docs.python.org/zh-cn/3.8/library/html.parser.html#html.parser.HTMLParser.handle_data" target="_blank" rel="noopener"><code>handle_data()</code></a> 可能会多次调用（除非 <em>convert_charrefs</em> 被设置为 <code>True</code> ）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> chunk <span class="keyword">in</span> [<span class="string">'&lt;sp'</span>, <span class="string">'an&gt;buff'</span>, <span class="string">'ered '</span>, <span class="string">'text&lt;/s'</span>, <span class="string">'pan&gt;'</span>]:</span><br><span class="line"><span class="meta">... </span>    parser.feed(chunk)</span><br><span class="line">...</span><br><span class="line">Start tag: span</span><br><span class="line">Data     : buff</span><br><span class="line">Data     : ered</span><br><span class="line">Data     : text</span><br><span class="line">End tag  : span</span><br></pre></td></tr></table></figure><p>解析无效的 HTML (例如：未引用的属性）也能正常运行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">'&lt;p&gt;&lt;a class=link href=#main&gt;tag soup&lt;/p &gt;&lt;/a&gt;'</span>)</span><br><span class="line">Start tag: p</span><br><span class="line">Start tag: a</span><br><span class="line">     attr: (<span class="string">'class'</span>, <span class="string">'link'</span>)</span><br><span class="line">     attr: (<span class="string">'href'</span>, <span class="string">'#main'</span>)</span><br><span class="line">Data     : tag soup</span><br><span class="line">End tag  : p</span><br><span class="line">End tag  : a</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-html-parser-简单HTML和XHTML解析器&quot;&gt;&lt;a href=&quot;#python-标准库-html-parser-简单HTML和XHTML解析器&quot; class=&quot;headerlink&quot; title=&quot;python 标准库  html.parser 简单HTML和XHTML解析器&quot;&gt;&lt;/a&gt;python 标准库  html.parser 简单HTML和XHTML解析器&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cn.bing.com/th?id=OIP.cq-61gMRe77h_MW4ca_0egHaFj&amp;amp;pid=Api&amp;amp;rs=1&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="html.parser" scheme="https://pinghailinfeng.gitee.io/tags/html-parser/"/>
    
  </entry>
  
  <entry>
    <title>python standard library enum</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/28/python-standard-library-enum/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/28/python-standard-library-enum/</id>
    <published>2020-01-27T23:22:58.000Z</published>
    <updated>2020-01-30T08:43:58.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-enum-枚举类型支持"><a href="#python-标准库-enum-枚举类型支持" class="headerlink" title="python 标准库 enum 枚举类型支持"></a>python 标准库 enum 枚举类型支持</h1><p><img src="https://cn.bing.com/th?id=OIP.MVQKeBgQJ2yG2rAwEJ5unQHaEK&amp;pid=Api&amp;rs=1" alt></p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=643982&auto=0&height=66"></iframe><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/enum.py" target="_blank" rel="noopener">Lib/enum.py</a></p><hr><p>枚举是一组符号名称（枚举成员）的集合，枚举成员应该是唯一的、不可变的。在枚举中，可以对成员进行恒等比较，并且枚举本身是可迭代的。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>此模块定义了四个枚举类，它们可被用来定义名称和值的不重复集合: <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a>。 此外还定义了一个装饰器 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.unique" target="_blank" rel="noopener"><code>unique()</code></a> 和一个辅助类 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a>。</p><ul><li><p><em>class</em> <code>enum.Enum</code></p><p>此基类用于创建枚举常量。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#functional-api" target="_blank" rel="noopener">Functional API</a> 小节了解另一种替代性的构建语法。</p></li><li><p><em>class</em> <code>enum.IntEnum</code></p><p>此基类用于创建属于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的子类的枚举常量。</p></li><li><p><em>class</em> <code>enum.IntFlag</code></p><p>此基类用于创建可使用按位运算符进行组合而不会丢失其 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员资格的枚举常量。 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员同样也是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的子类。</p></li><li><p><em>class</em> <code>enum.Flag</code></p><p>此基类用于创建枚举常量 可使用按位运算符进行组合而不会丢失其 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 成员资格的枚举常量。</p></li><li><p><code>enum.unique</code>()</p><p>此 Enum 类装饰器可确保只将一个名称绑定到任意一个值。</p></li><li><p><em>class</em> <code>enum.auto</code></p><p>实例会被替换为一个可作为 Enum 成员的适当的值。 初始值从 1 开始。</p></li></ul><h2 id="创建一个-Enum"><a href="#创建一个-Enum" class="headerlink" title="创建一个 Enum"></a>创建一个 Enum</h2><p> 枚举是使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#class" target="_blank" rel="noopener"><code>class</code></a> 语法来创建的，这使得它们易于读写。 另一种替代创建方法的描述见 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#functional-api" target="_blank" rel="noopener">Functional API</a>。 要定义一个枚举，可以对 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 进行如下的子类化: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    GREEN = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    BLUE = <span class="number">3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p> 成员值可以为任意类型: <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 等等。 如果具体的值不重要，你可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a> 实例，将为你选择适当的值。 但如果你混用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a> 与其他值则需要小心谨慎。 </p><p> 虽然我们使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#class" target="_blank" rel="noopener"><code>class</code></a> 语法来创建 Enum，但 Enum 并不是普通的 Python 类。 更多细节请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#how-are-enums-different" target="_blank" rel="noopener">How are Enums different</a> </p></blockquote><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ul><li>类 <code>Color</code> 是一个 <em>枚举</em> (或称 <em>enum</em>)</li><li>属性 <code>Color.RED</code>, <code>Color.GREEN</code> 等等是 <em>枚举成员</em> (或称 <em>enum 成员</em>) 并且被用作常量。</li><li><p>枚举成员具有 <em>名称</em> 和 <em>值</em> (<code>Color.RED</code> 的名称为 <code>RED</code>，<code>Color.BLUE</code> 的值为 <code>3</code> 等等。)</p><p>枚举成员具有适合人类阅读的表示形式: </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Color.RED)</span><br><span class="line">Color.RED</span><br></pre></td></tr></table></figure><p> .而它们的 <code>repr</code> 包含更多信息: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(repr(Color.RED))</span><br><span class="line">&lt;Color.RED: <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure><p> 一个枚举成员的 <em>type</em> 就是它所从属的枚举: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(Color.RED)</span><br><span class="line">&lt;enum <span class="string">'Color'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Color.GREEN, Color)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p> Enum 的成员还有一个包含其条目名称的特征属性: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Color.RED.name)</span><br><span class="line">RED</span><br></pre></td></tr></table></figure><p>枚举支持按照定义顺序进行迭代:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Shake</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    VANILLA = <span class="number">7</span></span><br><span class="line"><span class="meta">... </span>    CHOCOLATE = <span class="number">4</span></span><br><span class="line"><span class="meta">... </span>    COOKIES = <span class="number">9</span></span><br><span class="line"><span class="meta">... </span>    MINT = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> shake <span class="keyword">in</span> Shake:</span><br><span class="line"><span class="meta">... </span>    print(shake)</span><br><span class="line">...</span><br><span class="line">Shake.VANILLA</span><br><span class="line">Shake.CHOCOLATE</span><br><span class="line">Shake.COOKIES</span><br><span class="line">Shake.MINT</span><br></pre></td></tr></table></figure><p> 枚举成员是可哈希的，因此它们可在字典和集合中可用: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>apples = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>apples[Color.RED] = <span class="string">'red delicious'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>apples[Color.GREEN] = <span class="string">'granny smith'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>apples == &#123;Color.RED: <span class="string">'red delicious'</span>, Color.GREEN: <span class="string">'granny smith'</span>&#125;</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="对枚举成员及其属性的程序化访问"><a href="#对枚举成员及其属性的程序化访问" class="headerlink" title="对枚举成员及其属性的程序化访问"></a>对枚举成员及其属性的程序化访问</h2><p> 有时对枚举中的成员进行程序化访问是很有用的（例如在某些场合不能使用 <code>Color.RED</code> 因为在编程时并不知道要指定的确切颜色）。 <code>Enum</code> 允许这样的访问: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color(<span class="number">1</span>)</span><br><span class="line">&lt;Color.RED: <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color(<span class="number">3</span>)</span><br><span class="line">&lt;Color.BLUE: <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure><p> 如果你希望通过 <em>name</em> 来访问枚举成员，可使用条目访问: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color[<span class="string">'RED'</span>]</span><br><span class="line">&lt;Color.RED: <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color[<span class="string">'GREEN'</span>]</span><br><span class="line">&lt;Color.GREEN: <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><p> 如果你有一个枚举成员并且需要它的 <code>name</code> 或 <code>value</code>: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>member = Color.RED</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.name</span><br><span class="line"><span class="string">'RED'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>member.value</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="复制枚举成员和值"><a href="#复制枚举成员和值" class="headerlink" title="复制枚举成员和值"></a>复制枚举成员和值</h2><p> 不允许有同名的枚举成员: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Shape</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    SQUARE = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    SQUARE = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: Attempted to reuse key: <span class="string">'SQUARE'</span></span><br></pre></td></tr></table></figure><p> 但是，允许两个枚举成员有相同的值。 假定两个成员 A 和 B 有相同的值（且 A 先被定义），则 B 就是 A 的一个别名。 按值查找 A 和 B 的值将返回 A。 按名称查找 B 也将返回 A: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Shape</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    SQUARE = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    DIAMOND = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    CIRCLE = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    ALIAS_FOR_SQUARE = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Shape.SQUARE</span><br><span class="line">&lt;Shape.SQUARE: <span class="number">2</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Shape.ALIAS_FOR_SQUARE</span><br><span class="line">&lt;Shape.SQUARE: <span class="number">2</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Shape(<span class="number">2</span>)</span><br><span class="line">&lt;Shape.SQUARE: <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p> 试图创建具有与某个已定义的属性（另一个成员或方法等）相同名称的成员或者试图创建具有相同名称的属性也是不允许的 </p></blockquote><h2 id="确保唯一的枚举值"><a href="#确保唯一的枚举值" class="headerlink" title="确保唯一的枚举值"></a>确保唯一的枚举值</h2><p> 默认情况下，枚举允许有多个名称作为某个相同值的别名。 如果不想要这样的行为，可以使用以下装饰器来确保每个值在枚举中只被使用一次: </p><p> <a href="mailto:`@enum.unique" target="_blank" rel="noopener">`@enum.unique</a>` </p><p> 专用于枚举的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#class" target="_blank" rel="noopener"><code>class</code></a> 装饰器。 它会搜索一个枚举的 <code>__members__</code> 并收集所找到的任何别名；只要找到任何别名就会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 并附带相关细节信息: </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@unique</span><br><span class="line"><span class="meta">... </span><span class="class"><span class="keyword">class</span> <span class="title">Mistake</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    ONE = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    TWO = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    THREE = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    FOUR = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">ValueError: duplicate values found in &lt;enum 'Mistake'&gt;: FOUR -&gt; THREE</span><br></pre></td></tr></table></figure><h2 id="使用自动设定的值"><a href="#使用自动设定的值" class="headerlink" title="使用自动设定的值"></a>使用自动设定的值</h2><p> 如果确切的值不重要，你可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a>: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, auto</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = auto()</span><br><span class="line"><span class="meta">... </span>    BLUE = auto()</span><br><span class="line"><span class="meta">... </span>    GREEN = auto()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(Color)</span><br><span class="line">[&lt;Color.RED: <span class="number">1</span>&gt;, &lt;Color.BLUE: <span class="number">2</span>&gt;, &lt;Color.GREEN: <span class="number">3</span>&gt;]</span><br></pre></td></tr></table></figure><p> 值将由 <code>_generate_next_value_()</code> 来选择，该函数可以被重载: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">AutoName</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">_generate_next_value_</span><span class="params">(name, start, count, last_values)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Ordinal</span><span class="params">(AutoName)</span>:</span></span><br><span class="line"><span class="meta">... </span>    NORTH = auto()</span><br><span class="line"><span class="meta">... </span>    SOUTH = auto()</span><br><span class="line"><span class="meta">... </span>    EAST = auto()</span><br><span class="line"><span class="meta">... </span>    WEST = auto()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(Ordinal)</span><br><span class="line">[&lt;Ordinal.NORTH: <span class="string">'NORTH'</span>&gt;, &lt;Ordinal.SOUTH: <span class="string">'SOUTH'</span>&gt;, &lt;Ordinal.EAST: <span class="string">'EAST'</span>&gt;, &lt;Ordinal.WEST: <span class="string">'WEST'</span>&gt;]</span><br></pre></td></tr></table></figure><blockquote><p> 默认 <code>_generate_next_value_()</code> 方法的目标是提供所给出的最后一个 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 所在序列的下一个 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>，但这种行为方式属于实现细节并且可能发生改变。</p></blockquote><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p> 对枚举成员的迭代不会给出别名: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(Shape)</span><br><span class="line">[&lt;Shape.SQUARE: <span class="number">2</span>&gt;, &lt;Shape.DIAMOND: <span class="number">1</span>&gt;, &lt;Shape.CIRCLE: <span class="number">3</span>&gt;]</span><br></pre></td></tr></table></figure><p> 特殊属性 <code>__members__</code> 是一个从名称到成员的只读有序映射。 它包含枚举中定义的所有名称，包括别名: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, member <span class="keyword">in</span> Shape.__members__.items():</span><br><span class="line"><span class="meta">... </span>    name, member</span><br><span class="line">...</span><br><span class="line">(<span class="string">'SQUARE'</span>, &lt;Shape.SQUARE: <span class="number">2</span>&gt;)</span><br><span class="line">(<span class="string">'DIAMOND'</span>, &lt;Shape.DIAMOND: <span class="number">1</span>&gt;)</span><br><span class="line">(<span class="string">'CIRCLE'</span>, &lt;Shape.CIRCLE: <span class="number">3</span>&gt;)</span><br><span class="line">(<span class="string">'ALIAS_FOR_SQUARE'</span>, &lt;Shape.SQUARE: <span class="number">2</span>&gt;)</span><br></pre></td></tr></table></figure><p> <code>__members__</code> 属性可被用于对枚举成员进行详细的程序化访问。 例如，找出所有别名: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[name <span class="keyword">for</span> name, member <span class="keyword">in</span> Shape.__members__.items() <span class="keyword">if</span> member.name != name]</span><br><span class="line">[<span class="string">'ALIAS_FOR_SQUARE'</span>]</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p> 枚举成员是按标识号进行比较的: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.RED <span class="keyword">is</span> Color.RED</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.RED <span class="keyword">is</span> Color.BLUE</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.RED <span class="keyword">is</span> <span class="keyword">not</span> Color.BLUE</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p> 枚举值之间的排序比较 <em>不被</em> 支持。 Enum 成员不属于整数 (另请参阅下文的 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#intenum" target="_blank" rel="noopener">IntEnum</a>): </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.RED &lt; Color.BLUE</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'&lt;'</span> <span class="keyword">not</span> supported between instances of <span class="string">'Color'</span> <span class="keyword">and</span> <span class="string">'Color'</span></span><br></pre></td></tr></table></figure><p> 相等比较的定义如下: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.BLUE == Color.RED</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.BLUE != Color.RED</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.BLUE == Color.BLUE</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p> 与非枚举值的比较将总是不相等（同样地，<a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a> 被显式设计成不同的行为，参见下文）: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.BLUE == <span class="number">2</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="允许的枚举成员和属性"><a href="#允许的枚举成员和属性" class="headerlink" title="允许的枚举成员和属性"></a>允许的枚举成员和属性</h2><p>以上示例使用整数作为枚举值。 使用整数相当简洁方便（并由 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#functional-api" target="_blank" rel="noopener">Functional API</a> 默认提供），但并不强制要求使用。 在大部分用例中，开发者都关心枚举的实际值是什么。 但如果值 <em>确实</em> 重要，则枚举可以使用任意的值。</p><p>枚举属于 Python 的类，并可具有普通方法和特殊方法。 如果我们有这样一个枚举:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Mood</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    FUNKY = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    HAPPY = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">describe</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="comment"># self is the member here</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.name, self.value</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'my custom str! &#123;0&#125;'</span>.format(self.value)</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    @classmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">favorite_mood</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="comment"># cls here is the enumeration</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> cls.HAPPY</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p> 那么: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Mood.favorite_mood()</span><br><span class="line">&lt;Mood.HAPPY: <span class="number">3</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Mood.HAPPY.describe()</span><br><span class="line">(<span class="string">'HAPPY'</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(Mood.FUNKY)</span><br><span class="line"><span class="string">'my custom str! 1'</span></span><br></pre></td></tr></table></figure><p>对于允许内容的规则如下：以单下划线开头和结尾的名称是由枚举保留而不可使用；在枚举中定义的所有其他属性将成为该枚举的成员，例外项则包括特殊方法成员 (<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__str__" target="_blank" rel="noopener"><code>__str__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 等)，描述符 (方法也属于描述符) 以及在 <code>_ignore_</code> 中列出的变量名。</p><p>注意：如果你的枚举定义了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 和/或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 那么指定给枚举成员的任何值都会被传入这些方法。 请参阅示例 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#planet" target="_blank" rel="noopener">Planet</a>。</p><h2 id="受限的-Enum-子类化"><a href="#受限的-Enum-子类化" class="headerlink" title="受限的 Enum 子类化"></a>受限的 Enum 子类化</h2><p> 一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类必须基于一个 Enum 类，至多一个实体数据类型以及出于实际需要的任意多个基于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 的 mixin 类。 这些基类的顺序为: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumName</span><span class="params">([mix-in, ...,] [data-type,] base-enum)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p> 另外，仅当一个枚举未定义任何成员时才允许子类化该枚举。 因此禁止这样的写法: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MoreColor</span><span class="params">(Color)</span>:</span></span><br><span class="line"><span class="meta">... </span>    PINK = <span class="number">17</span></span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: Cannot extend enumerations</span><br></pre></td></tr></table></figure><p> 但是允许这样的写法: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">some_behavior</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(Foo)</span>:</span></span><br><span class="line"><span class="meta">... </span>    HAPPY = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    SAD = <span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p> 允许子类化定义了成员的枚举将会导致违反类型与实例的某些重要的不可变规则。 在另一方面，允许在一组枚举之间共享某些通用行为也是有意义的。 （请参阅示例 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#orderedenum" target="_blank" rel="noopener">OrderedEnum</a> 。） </p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p> 枚举可以被封装与解封:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> test.test_enum <span class="keyword">import</span> Fruit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pickle <span class="keyword">import</span> dumps, loads</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fruit.TOMATO <span class="keyword">is</span> loads(dumps(Fruit.TOMATO))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p> 封装的常规限制同样适用：可封存枚举必须在模块的最高层级中定义，因为解封操作要求它们可以从该模块导入。 </p><blockquote><p> 使用 pickle 协议版本 4 可以方便地封存嵌套在其他类中的枚举。 </p></blockquote><p> 通过在枚举类中定义 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#object.__reduce_ex__" target="_blank" rel="noopener"><code>__reduce_ex__()</code></a> 可以对 Enum 成员的封存/解封方式进行修改。 </p><h2 id="功能性-API"><a href="#功能性-API" class="headerlink" title="功能性 API"></a>功能性 API</h2><p> <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类属于可调用对象，它提供了以下功能性 API: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Animal = Enum(<span class="string">'Animal'</span>, <span class="string">'ANT BEE CAT DOG'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Animal</span><br><span class="line">&lt;enum <span class="string">'Animal'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Animal.ANT</span><br><span class="line">&lt;Animal.ANT: <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Animal.ANT.value</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(Animal)</span><br><span class="line">[&lt;Animal.ANT: <span class="number">1</span>&gt;, &lt;Animal.BEE: <span class="number">2</span>&gt;, &lt;Animal.CAT: <span class="number">3</span>&gt;, &lt;Animal.DOG: <span class="number">4</span>&gt;]</span><br></pre></td></tr></table></figure><p>该 API 的主义类似于 <a href="https://docs.python.org/zh-cn/3.8/library/collections.html#collections.namedtuple" target="_blank" rel="noopener"><code>namedtuple</code></a>。 调用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 的第一个参数是枚举的名称。</p><p>第二个参数是枚举成员名称的 <em>来源</em>。 它可以是一个用空格分隔的名称字符串、名称序列、键/值对 2 元组的序列，或者名称到值的映射（例如字典）。 最后两种选项使得可以为枚举任意赋值；其他选项会自动以从 1 开始递增的整数赋值（使用 <code>start</code> 形参可指定不同的起始值）。 返回值是一个派生自 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 的新类。 换句话说，以上对 <code>Animal</code> 的赋值就等价于:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    ANT = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    BEE = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    CAT = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    DOG = <span class="number">4</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>默认以 <code>1</code> 而以 <code>0</code> 作为起始数值的原因在于 <code>0</code> 的布尔值为 <code>False</code>，但所有枚举成员都应被求值为 <code>True</code>。</p><p>对使用功能性 API 创建的枚举执行封存可能会很麻烦，因为要使用帧堆栈的实现细节来尝试并找出枚举是在哪个模块中创建的（例如当你使用了另一个模块中的工具函数就可能失败，在 IronPython 或 Jython 上也可能无效）。 解决办法是显式地指定模块名称，如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Animal = Enum(<span class="string">'Animal'</span>, <span class="string">'ANT BEE CAT DOG'</span>, module=__name__)</span><br></pre></td></tr></table></figure><p> 新的 pickle 协议版本 4 在某些情况下同样依赖于 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#definition.__qualname__" target="_blank" rel="noopener"><code>__qualname__</code></a> 被设为特定位置以便 pickle 能够找到相应的类。 例如，类是否存在于全局作用域的 SomeData 类中: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Animal = Enum(<span class="string">'Animal'</span>, <span class="string">'ANT BEE CAT DOG'</span>, qualname=<span class="string">'SomeData.Animal'</span>)</span><br></pre></td></tr></table></figure><p> 完整的签名为: </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enum(value='NewEnumName', names=&lt;...&gt;, *, module='...', qualname='...', type=&lt;mixed-in class&gt;, start=1)</span><br></pre></td></tr></table></figure><h2 id="派生的枚举"><a href="#派生的枚举" class="headerlink" title="派生的枚举"></a>派生的枚举</h2><h3 id="IntEnum"><a href="#IntEnum" class="headerlink" title="IntEnum"></a>IntEnum</h3><p> 所提供的第一个变种 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 同时也是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的一个子类。 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a> 的成员可与整数进行比较；通过扩展，不同类型的整数枚举也可以相互进行比较: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> enum <span class="keyword">import</span> IntEnum</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Shape</span><span class="params">(IntEnum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    CIRCLE = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    SQUARE = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">(IntEnum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    POST = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    GET = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Shape == <span class="number">1</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Shape.CIRCLE == <span class="number">1</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Shape.CIRCLE == Request.POST</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p> 不过，它们仍然不可与标准 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 枚举进行比较: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Shape</span><span class="params">(IntEnum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    CIRCLE = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    SQUARE = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    GREEN = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Shape.CIRCLE == Color.RED</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p> <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a> 值在其他方面的行为都如你预期的一样类似于整数: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(Shape.CIRCLE)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>][Shape.CIRCLE]</span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i <span class="keyword">for</span> i <span class="keyword">in</span> range(Shape.SQUARE)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="IntFlag"><a href="#IntFlag" class="headerlink" title="IntFlag"></a>IntFlag</h3><p> 所提供的下一个 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 的变种 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 同样是基于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的，不同之处在于 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员可使用按位运算符 (&amp;, |, ^, ~) 进行组合且结果仍然为 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员。 如果，正如名称所表明的，<a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员同时也是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的子类，并能在任何使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的场合被使用。 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员进行除按位运算以外的其他运算都将导致失去 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员资格。 </p><p> 示例 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 类: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> enum <span class="keyword">import</span> IntFlag</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Perm</span><span class="params">(IntFlag)</span>:</span></span><br><span class="line"><span class="meta">... </span>    R = <span class="number">4</span></span><br><span class="line"><span class="meta">... </span>    W = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    X = <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Perm.R | Perm.W</span><br><span class="line">&lt;Perm.R|W: <span class="number">6</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Perm.R + Perm.W</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RW = Perm.R | Perm.W</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Perm.R <span class="keyword">in</span> RW</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p> 对于组合同样可以进行命名: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Perm</span><span class="params">(IntFlag)</span>:</span></span><br><span class="line"><span class="meta">... </span>    R = <span class="number">4</span></span><br><span class="line"><span class="meta">... </span>    W = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    X = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    RWX = <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Perm.RWX</span><br><span class="line">&lt;Perm.RWX: <span class="number">7</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>~Perm.RWX</span><br><span class="line">&lt;Perm.<span class="number">-8</span>: <span class="number">-8</span>&gt;</span><br></pre></td></tr></table></figure><p> <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 的另一个重要区别在于如果没有设置任何旗标（值为 0），则其布尔值为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Perm.R &amp; Perm.X</span><br><span class="line">&lt;Perm<span class="number">.0</span>: <span class="number">0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(Perm.R &amp; Perm.X)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p> 由于 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 成员同时也是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的子类，因此它们可以相互组合: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Perm.X | <span class="number">8</span></span><br><span class="line">&lt;Perm<span class="number">.8</span>|X: <span class="number">9</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h3><p> 最后一个变种是 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a>。 与 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 类似，<a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 成员可使用按位运算符 (&amp;, |, ^, ~) 进行组合，与 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 不同的是它们不可与任何其它 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 枚举或 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 进行组合或比较。 虽然可以直接指定值，但推荐使用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a> 作为值以便让 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 选择适当的值。 </p><p> 与 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 类似，如果 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 成员的某种组合导致没有设置任何旗标，则其布尔值为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> enum <span class="keyword">import</span> Flag, auto</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Flag)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = auto()</span><br><span class="line"><span class="meta">... </span>    BLUE = auto()</span><br><span class="line"><span class="meta">... </span>    GREEN = auto()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.RED &amp; Color.GREEN</span><br><span class="line">&lt;Color<span class="number">.0</span>: <span class="number">0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(Color.RED &amp; Color.GREEN)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p> 单个旗标的值应当为二的乘方 (1, 2, 4, 8, …)，旗标的组合则无此限制: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Flag)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = auto()</span><br><span class="line"><span class="meta">... </span>    BLUE = auto()</span><br><span class="line"><span class="meta">... </span>    GREEN = auto()</span><br><span class="line"><span class="meta">... </span>    WHITE = RED | BLUE | GREEN</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.WHITE</span><br><span class="line">&lt;Color.WHITE: <span class="number">7</span>&gt;</span><br></pre></td></tr></table></figure><p> 对 “no flags set” 条件指定一个名称并不会改变其布尔值: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Flag)</span>:</span></span><br><span class="line"><span class="meta">... </span>    BLACK = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    RED = auto()</span><br><span class="line"><span class="meta">... </span>    BLUE = auto()</span><br><span class="line"><span class="meta">... </span>    GREEN = auto()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.BLACK</span><br><span class="line">&lt;Color.BLACK: <span class="number">0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(Color.BLACK)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><blockquote><p> 对于大多数新代码，强烈推荐使用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a>，因为 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 打破了枚举的某些语义约定（例如可以同整数进行比较，并因而导致此行为被传递给其他无关的枚举）。 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 的使用应当仅限于 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 无法使用的场合；例如，当使用枚举替代整数常量时，或是与其他系统进行交互操作时。 </p></blockquote><h3 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h3><p> 虽然 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a> 是 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#module-enum" target="_blank" rel="noopener"><code>enum</code></a> 模块的一部分，但要独立实现也应该相当容易: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntEnum</span><span class="params">(int, Enum)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这里演示了如何定义类似的派生枚举；例如一个混合了 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 的 <code>StrEnum</code>。</p><p>几条规则：</p><ol><li>当子类化 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 时，在基类序列中的混合类型必须出现于 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 本身之前，如以上 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a> 的例子所示。</li><li>虽然 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 可以拥有任意类型的成员，不过一旦你混合了附加类型，则所有成员必须为相应类型的值，如在上面的例子中即为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>。 此限制不适用于仅添加方法而未指定另一数据类型如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 的混合类。</li><li>当混合了另一数据类型时，<code>value</code> 属性会 <em>不同于</em> 枚举成员自身，但它们仍保持等价且比较结果也相等。</li><li>%-style formatting: %s 和 %r 会分别调用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__str__" target="_blank" rel="noopener"><code>__str__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a>；其他代码 (例如表示 IntEnum 的 %i 或 %h) 会将枚举成员视为对应的混合类型。</li><li><a href="https://docs.python.org/zh-cn/3.8/reference/lexical_analysis.html#f-strings" target="_blank" rel="noopener">格式化字符串字面值</a>, <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str.format" target="_blank" rel="noopener"><code>str.format()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#format" target="_blank" rel="noopener"><code>format()</code></a> 将使用混合类型的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__format__" target="_blank" rel="noopener"><code>__format__()</code></a>。 如果需要 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a>，请使用 !s 或 !r 格式代码。</li></ol><h2 id="何时使用-init-与-new"><a href="#何时使用-init-与-new" class="headerlink" title="何时使用 __init__与__new__"></a>何时使用 <code>__init__</code>与<code>__new__</code></h2><p>当你想要定制 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 成员的实际值时必须使用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a>。 任何其他修改可以用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 也可以用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a>，应优先使用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a>。</p><p>举例来说，如果你要向构造器传入多个条目，但只希望将其中一个作为值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span><span class="params">(bytes, Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    Coordinate with binary codes that can be indexed by the int code.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    """</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, value, label, unit)</span>:</span></span><br><span class="line"><span class="meta">... </span>        obj = bytes.__new__(cls, [value])</span><br><span class="line"><span class="meta">... </span>        obj._value_ = value</span><br><span class="line"><span class="meta">... </span>        obj.label = label</span><br><span class="line"><span class="meta">... </span>        obj.unit = unit</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> obj</span><br><span class="line"><span class="meta">... </span>    PX = (<span class="number">0</span>, <span class="string">'P.X'</span>, <span class="string">'km'</span>)</span><br><span class="line"><span class="meta">... </span>    PY = (<span class="number">1</span>, <span class="string">'P.Y'</span>, <span class="string">'km'</span>)</span><br><span class="line"><span class="meta">... </span>    VX = (<span class="number">2</span>, <span class="string">'V.X'</span>, <span class="string">'km/s'</span>)</span><br><span class="line"><span class="meta">... </span>    VY = (<span class="number">3</span>, <span class="string">'V.Y'</span>, <span class="string">'km/s'</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Coordinate[<span class="string">'PY'</span>])</span><br><span class="line">Coordinate.PY</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Coordinate(<span class="number">3</span>))</span><br><span class="line">Coordinate.VY</span><br></pre></td></tr></table></figure><h2 id="有趣的示例"><a href="#有趣的示例" class="headerlink" title="有趣的示例"></a>有趣的示例</h2><p> 虽然 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntFlag" target="_blank" rel="noopener"><code>IntFlag</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Flag" target="_blank" rel="noopener"><code>Flag</code></a> 预期可覆盖大多数应用场景，但它们无法覆盖全部。 这里有一些不同类型枚举的方案，它们可以被直接使用，或是作为自行创建的参考示例。 </p><h3 id="省略值"><a href="#省略值" class="headerlink" title="省略值"></a>省略值</h3><p>在许多应用场景中人们都不关心枚举的实际值是什么。 有几个方式可以定义此种类型的简单枚举：</p><ul><li>使用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a> 的实例作为值</li><li>使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 的实例作为值</li><li>使用描述性的字符串作为值</li><li>使用元组作为值并用自定义的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 以一个 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 值来替代该元组</li></ul><p>使用以上任何一种方法均可向用户指明值并不重要，并且使人能够添加、移除或重排序成员而不必改变其余成员的数值。</p><p>无论你选择何种方法，你都应当提供一个 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 并且它也需要隐藏（不重要的）值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">NoValue</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'&lt;%s.%s&gt;'</span> % (self.__class__.__name__, self.name)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="使用auto"><a href="#使用auto" class="headerlink" title="使用auto"></a>使用<code>auto</code></h4><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a> 的形式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(NoValue)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = auto()</span><br><span class="line"><span class="meta">... </span>    BLUE = auto()</span><br><span class="line"><span class="meta">... </span>    GREEN = auto()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.GREEN</span><br><span class="line">&lt;Color.GREEN&gt;</span><br></pre></td></tr></table></figure><h4 id="使用-object"><a href="#使用-object" class="headerlink" title="使用 object"></a>使用 <code>object</code></h4><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 的形式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(NoValue)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = object()</span><br><span class="line"><span class="meta">... </span>    GREEN = object()</span><br><span class="line"><span class="meta">... </span>    BLUE = object()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.GREEN</span><br><span class="line">&lt;Color.GREEN&gt;</span><br></pre></td></tr></table></figure><h4 id="使用描述性字符串"><a href="#使用描述性字符串" class="headerlink" title="使用描述性字符串"></a>使用描述性字符串</h4><p>使用字符串作为值的形式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(NoValue)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = <span class="string">'stop'</span></span><br><span class="line"><span class="meta">... </span>    GREEN = <span class="string">'go'</span></span><br><span class="line"><span class="meta">... </span>    BLUE = <span class="string">'too fast!'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.GREEN</span><br><span class="line">&lt;Color.GREEN&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.GREEN.value</span><br><span class="line"><span class="string">'go'</span></span><br></pre></td></tr></table></figure><h4 id="使用自定义的-new"><a href="#使用自定义的-new" class="headerlink" title="使用自定义的__new__"></a>使用自定义的<code>__new__</code></h4><p>使用自动编号 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 的形式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">AutoNumber</span><span class="params">(NoValue)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="meta">... </span>        value = len(cls.__members__) + <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        obj = object.__new__(cls)</span><br><span class="line"><span class="meta">... </span>        obj._value_ = value</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> obj</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(AutoNumber)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = ()</span><br><span class="line"><span class="meta">... </span>    GREEN = ()</span><br><span class="line"><span class="meta">... </span>    BLUE = ()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.GREEN</span><br><span class="line">&lt;Color.GREEN&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color.GREEN.value</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><blockquote><p> 如果定义了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 则它会在创建 Enum 成员期间被使用；随后它将被 Enum 的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 所替换，该方法会在类创建后被用来查找现有成员</p></blockquote><h3 id="OrderedEnum"><a href="#OrderedEnum" class="headerlink" title="OrderedEnum"></a>OrderedEnum</h3><p> 一个有序枚举，它不是基于 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.IntEnum" target="_blank" rel="noopener"><code>IntEnum</code></a>，因此保持了正常的 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 不变特性（例如不可与其他枚举进行比较）: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">OrderedEnum</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__ge__</span><span class="params">(self, other)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> self.__class__ <span class="keyword">is</span> other.__class__:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.value &gt;= other.value</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> self.__class__ <span class="keyword">is</span> other.__class__:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.value &gt; other.value</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__le__</span><span class="params">(self, other)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> self.__class__ <span class="keyword">is</span> other.__class__:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.value &lt;= other.value</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> self.__class__ <span class="keyword">is</span> other.__class__:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.value &lt; other.value</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Grade</span><span class="params">(OrderedEnum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    A = <span class="number">5</span></span><br><span class="line"><span class="meta">... </span>    B = <span class="number">4</span></span><br><span class="line"><span class="meta">... </span>    C = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    D = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    F = <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Grade.C &lt; Grade.A</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="DuplicateFreeEnum"><a href="#DuplicateFreeEnum" class="headerlink" title="DuplicateFreeEnum"></a>DuplicateFreeEnum</h3><p> 如果发现重复的成员名称则将引发错误而不是创建别名: </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">DuplicateFreeEnum</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        cls = self.__class__</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> any(self.value == e.value <span class="keyword">for</span> e <span class="keyword">in</span> cls):</span><br><span class="line"><span class="meta">... </span>            a = self.name</span><br><span class="line"><span class="meta">... </span>            e = cls(self.value).name</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> ValueError(</span><br><span class="line"><span class="meta">... </span>                <span class="string">"aliases not allowed in DuplicateFreeEnum:  %r --&gt; %r"</span></span><br><span class="line"><span class="meta">... </span>                % (a, e))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(DuplicateFreeEnum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    GREEN = <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    BLUE = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    GRENE = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">ValueError: aliases not allowed in DuplicateFreeEnum:  'GRENE' --&gt; 'GREEN'</span><br></pre></td></tr></table></figure><h3 id="Planet"><a href="#Planet" class="headerlink" title="Planet"></a>Planet</h3><p>如果定义了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 则枚举成员的值将被传给这些方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Planet</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    MERCURY = (<span class="number">3.303e+23</span>, <span class="number">2.4397e6</span>)</span><br><span class="line"><span class="meta">... </span>    VENUS   = (<span class="number">4.869e+24</span>, <span class="number">6.0518e6</span>)</span><br><span class="line"><span class="meta">... </span>    EARTH   = (<span class="number">5.976e+24</span>, <span class="number">6.37814e6</span>)</span><br><span class="line"><span class="meta">... </span>    MARS    = (<span class="number">6.421e+23</span>, <span class="number">3.3972e6</span>)</span><br><span class="line"><span class="meta">... </span>    JUPITER = (<span class="number">1.9e+27</span>,   <span class="number">7.1492e7</span>)</span><br><span class="line"><span class="meta">... </span>    SATURN  = (<span class="number">5.688e+26</span>, <span class="number">6.0268e7</span>)</span><br><span class="line"><span class="meta">... </span>    URANUS  = (<span class="number">8.686e+25</span>, <span class="number">2.5559e7</span>)</span><br><span class="line"><span class="meta">... </span>    NEPTUNE = (<span class="number">1.024e+26</span>, <span class="number">2.4746e7</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mass, radius)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.mass = mass       <span class="comment"># in kilograms</span></span><br><span class="line"><span class="meta">... </span>        self.radius = radius   <span class="comment"># in meters</span></span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">surface_gravity</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="comment"># universal gravitational constant  (m3 kg-1 s-2)</span></span><br><span class="line"><span class="meta">... </span>        G = <span class="number">6.67300E-11</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> G * self.mass / (self.radius * self.radius)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Planet.EARTH.value</span><br><span class="line">(<span class="number">5.976e+24</span>, <span class="number">6378140.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Planet.EARTH.surface_gravity</span><br><span class="line"><span class="number">9.802652743337129</span></span><br></pre></td></tr></table></figure><h3 id="TimePeriod"><a href="#TimePeriod" class="headerlink" title="TimePeriod"></a>TimePeriod</h3><p> 一个演示如何使用 <code>_ignore_</code> 属性的例子: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Period</span><span class="params">(timedelta, Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"different lengths of time"</span></span><br><span class="line"><span class="meta">... </span>    _ignore_ = <span class="string">'Period i'</span></span><br><span class="line"><span class="meta">... </span>    Period = vars()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">367</span>):</span><br><span class="line"><span class="meta">... </span>        Period[<span class="string">'day_%d'</span> % i] = i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(Period)[:<span class="number">2</span>]</span><br><span class="line">[&lt;Period.day_0: datetime.timedelta(<span class="number">0</span>)&gt;, &lt;Period.day_1: datetime.timedelta(days=<span class="number">1</span>)&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(Period)[<span class="number">-2</span>:]</span><br><span class="line">[&lt;Period.day_365: datetime.timedelta(days=<span class="number">365</span>)&gt;, &lt;Period.day_366: datetime.timedelta(days=<span class="number">366</span>)&gt;]</span><br></pre></td></tr></table></figure><h2 id="各种枚举有何区别？"><a href="#各种枚举有何区别？" class="headerlink" title="各种枚举有何区别？"></a>各种枚举有何区别？</h2><p> 枚举具有自定义的元类，它会影响所派生枚举类及其实例（成员）的各个方面。 </p><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p> <code>EnumMeta</code> 元类负责提供 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__contains__" target="_blank" rel="noopener"><code>__contains__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__dir__" target="_blank" rel="noopener"><code>__dir__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 及其他方法以允许用户通过 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类来完成一般类做不到的事情，例如 list(Color) 或 some_enum_var in Color。 <code>EnumMeta</code> 会负责确保最终 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类中的各种其他方法是正确的 (例如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#object.__getnewargs__" target="_blank" rel="noopener"><code>__getnewargs__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__str__" target="_blank" rel="noopener"><code>__str__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a>)。 </p><h3 id="枚举成员（即实例）"><a href="#枚举成员（即实例）" class="headerlink" title="枚举成员（即实例）"></a>枚举成员（即实例）</h3><p> 有关枚举成员最有趣的特点是它们都是单例对象。 <code>EnumMeta</code> 会在创建 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类本身时将它们全部创建完成，然后准备好一个自定义的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a>，通过只返回现有的成员实例来确保不会再实例化新的对象。 </p><h3 id="细节要点"><a href="#细节要点" class="headerlink" title="细节要点"></a>细节要点</h3><h4 id="支持的-dunder-名称"><a href="#支持的-dunder-名称" class="headerlink" title="支持的 __dunder__ 名称"></a>支持的 <code>__dunder__</code> 名称</h4><p><code>__members__</code> 是一个 <code>member_name</code>:<code>member</code> 条目的只读有序映射。 它只在类上可用。</p><p>如果指定了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a>，它必须创建并返回枚举成员；相应地设定成员的 <code>_value_</code> 也是一个很好的主意。 一旦所有成员都创建完成它就不会再被使用。</p><h4 id="支持的-sunder-名称"><a href="#支持的-sunder-名称" class="headerlink" title="支持的 _sunder_ 名称"></a>支持的 <code>_sunder_</code> 名称</h4><ul><li><code>_name_</code> – 成员的名称</li><li><code>_value_</code> – 成员的值；可以在 <code>__new__</code> 中设置 / 修改</li><li><code>_missing_</code> – 当未发现某个值时所使用的查找函数；可被重载</li><li><code>_ignore_</code> – 一个名称列表，可以为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a>，它将不会被转化为成员，并会从最终类中被移除</li><li><code>_order_</code> – 用于 Python 2/3 代码以确保成员顺序一致（类属性，在类创建期间会被移除）</li><li><code>_generate_next_value_</code> – 用于 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#functional-api" target="_blank" rel="noopener">Functional API</a> 并通过 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.auto" target="_blank" rel="noopener"><code>auto</code></a> 为枚举成员获取适当的值；可被重载</li></ul><h3 id><a href="#" class="headerlink" title=" "></a> </h3><p> 用来帮助 Python 2 / Python 3 代码保持同步提供 <code>_order_</code> 属性。 它将与枚举的实际顺序进行对照检查，如果两者不匹配则会引发错误: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    _order_ = <span class="string">'RED GREEN BLUE'</span></span><br><span class="line"><span class="meta">... </span>    RED = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    BLUE = <span class="number">3</span></span><br><span class="line"><span class="meta">... </span>    GREEN = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: member order does <span class="keyword">not</span> match _order_</span><br></pre></td></tr></table></figure><h4 id="Enum-成员类型"><a href="#Enum-成员类型" class="headerlink" title="Enum 成员类型"></a><code>Enum</code> 成员类型</h4><p> <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 成员是其 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类的实例，一般通过 <code>EnumClass.member</code> 的形式来访问。 在特定情况下它们也可通过 <code>EnumClass.member.member</code> 的形式来访问，但你绝对不应这样做，因为查找可能失败，或者更糟糕地返回你所查找的 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 成员以外的对象（这也是成员应使用全大写名称的另一个好理由）: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">FieldTypes</span><span class="params">(Enum)</span>:</span></span><br><span class="line"><span class="meta">... </span>    name = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    value = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    size = <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FieldTypes.value.size</span><br><span class="line">&lt;FieldTypes.size: <span class="number">2</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FieldTypes.size.value</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="Enum-类和成员的布尔值"><a href="#Enum-类和成员的布尔值" class="headerlink" title="Enum 类和成员的布尔值"></a><code>Enum</code> 类和成员的布尔值</h4><p>混合了非 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类型（例如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 等）的 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 成员会按所混合类型的规则被求值；在其他情况下，所有成员都将被求值为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>。 要使你的自定义 Enum 的布尔值取决于成员的值，请在你的类中添加以下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> bool(self.value)</span><br></pre></td></tr></table></figure><p> <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 类总是会被求值为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>。 </p><h4 id="带有方法的-Enum-类"><a href="#带有方法的-Enum-类" class="headerlink" title="带有方法的 Enum 类"></a>带有方法的 <code>Enum</code> 类</h4><p>如果你为你的 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 子类添加了额外的方法，如同上述的 <a href="https://docs.python.org/zh-cn/3.8/library/enum.html#planet" target="_blank" rel="noopener">Planet</a> 类一样，这些方法将在对成员执行 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#dir" target="_blank" rel="noopener"><code>dir()</code></a> 时显示出来，但对类执行时则不会显示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(Planet)</span><br><span class="line">[<span class="string">'EARTH'</span>, <span class="string">'JUPITER'</span>, <span class="string">'MARS'</span>, <span class="string">'MERCURY'</span>, <span class="string">'NEPTUNE'</span>, <span class="string">'SATURN'</span>, <span class="string">'URANUS'</span>, <span class="string">'VENUS'</span>, <span class="string">'__class__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__members__'</span>, <span class="string">'__module__'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(Planet.EARTH)</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__module__'</span>, <span class="string">'name'</span>, <span class="string">'surface_gravity'</span>, <span class="string">'value'</span>]</span><br></pre></td></tr></table></figure><h4 id="组合-Flag-的成员"><a href="#组合-Flag-的成员" class="headerlink" title="组合 Flag 的成员"></a>组合 <code>Flag</code> 的成员</h4><p> 如果 Flag 成员的某种组合未被命名，则 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 将包含所有已命名的旗标和值中所有已命名的旗标组合: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Color</span><span class="params">(Flag)</span>:</span></span><br><span class="line"><span class="meta">... </span>    RED = auto()</span><br><span class="line"><span class="meta">... </span>    GREEN = auto()</span><br><span class="line"><span class="meta">... </span>    BLUE = auto()</span><br><span class="line"><span class="meta">... </span>    MAGENTA = RED | BLUE</span><br><span class="line"><span class="meta">... </span>    YELLOW = RED | GREEN</span><br><span class="line"><span class="meta">... </span>    CYAN = GREEN | BLUE</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color(<span class="number">3</span>)  <span class="comment"># named combination</span></span><br><span class="line">&lt;Color.YELLOW: <span class="number">3</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Color(<span class="number">7</span>)      <span class="comment"># not named combination</span></span><br><span class="line">&lt;Color.CYAN|MAGENTA|BLUE|YELLOW|GREEN|RED: <span class="number">7</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-enum-枚举类型支持&quot;&gt;&lt;a href=&quot;#python-标准库-enum-枚举类型支持&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 enum 枚举类型支持&quot;&gt;&lt;/a&gt;python 标准库 enum 枚举类型支持&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cn.bing.com/th?id=OIP.MVQKeBgQJ2yG2rAwEJ5unQHaEK&amp;amp;pid=Api&amp;amp;rs=1&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="enum" scheme="https://pinghailinfeng.gitee.io/tags/enum/"/>
    
  </entry>
  
  <entry>
    <title>python standard library pprint</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/27/python-standard-library-pprint/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/27/python-standard-library-pprint/</id>
    <published>2020-01-26T21:56:11.000Z</published>
    <updated>2020-01-30T08:43:58.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-pprint"><a href="#python-标准库-pprint" class="headerlink" title="python 标准库 pprint"></a>python 标准库 pprint</h1><p><img src="https://s.yimg.com/ny/api/res/1.2/U9YwDsQH7.4w06Tgw2pHJg--~A/YXBwaWQ9aGlnaGxhbmRlcjtzbT0xO3c9MTI4MDtoPTk2MA--/https://media.zenfs.com/zh-tw/nownews.com/e25e4ab4f7a980ccfcaca403eafb3a15" alt></p><a id="more"></a><p><img src="http://i3.sinaimg.cn/ty/nba/2014-12-17/U4933P6T12D7449800F44DT20141217031102.jpg" alt></p><p><img src="https://p9.pstatp.com/large/2a3500018a7a07e8a548" alt></p><p>今天凌晨,突闻噩耗, 「黑曼巴」 Kobe Bryant（科比） 永远离开了我们,永远的24号,最伟大的nba球员,没有之一,R.I.P。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=31719570&auto=1&height=66"></iframe><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/pprint.py" target="_blank" rel="noopener">Lib/pprint.py</a> </p><p>主要类和函数,节选自<a href="https://github.com/python/cpython/tree/3.8/Lib/pprint.py" target="_blank" rel="noopener">源码</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">"pprint"</span>,<span class="string">"pformat"</span>,<span class="string">"isreadable"</span>,<span class="string">"isrecursive"</span>,<span class="string">"saferepr"</span>,</span><br><span class="line">           <span class="string">"PrettyPrinter"</span>, <span class="string">"pp"</span>]</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#module-pprint" target="_blank" rel="noopener"><code>pprint</code></a> 模块提供了“美化打印”任意 Python 数据结构的功能，这种美化形式可用作对解释器的输入。 如果经格式化的结构包含非基本 Python 类型的对象，则其美化形式可能无法被加载。 包含文件、套接字或类对象，以及许多其他不能用 Python 字面值来表示的对象都有可能导致这样的结果。</p><p>格式化后的形式会在可能的情况下以单行来表示对象，并在无法在允许宽度内容纳对象的情况下将其分为多行。 如果你需要调整宽度限制则应显式地构造 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 对象。</p><p>字典在计算其显示形式前会先根据键来排序。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p> <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#module-pprint" target="_blank" rel="noopener"><code>pprint</code></a> 模块定义了一个类： </p><ul><li><p><em>class</em> <code>pprint.PrettyPrinter</code>(<em>indent=1</em>, <em>width=80</em>, <em>depth=None</em>, <em>stream=None</em>, <em>**, </em>compact=False<em>, </em>sort_dicts=True*) </p><p> 构造一个 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 实例。 此构造器接受几个关键字形参。 使用 <em>stream</em> 关键字可设置输出流；流对象使用的唯一方法是文件协议的 <code>write()</code> 方法。 如果未指定此关键字，则 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 会选择 <code>sys.stdout</code>。 每个递归层次的缩进量由 <em>indent</em> 指定；默认值为一。 其他值可导致输出看起来有些怪异，，但可使得嵌套结构更易区分。 可被打印的层级数量由 <em>depth</em> 控制；如果数据结构的层级被打印得过深，其所包含的下一层级会被替换为 <code>...</code>。 在默认情况下，对被格式化对象的层级深度没有限制。 希望的输出宽度可使用 <em>width</em> 形参来限制；默认值为 80 个字符。 如果一个结构无法在限定宽度内被格式化，则将做到尽可能接近。 如果 <em>compact</em> 为假值（默认）则长序列的每一项将被格式化为单独的行。 如果 <em>compact</em> 为真值，则将在 <em>width</em> 可容纳的的情况下把尽可能多的项放入每个输出行。 如果 <em>sort_dicts</em> 为真值（默认），字典将被格式化为按键排序，否则将按插入顺序显示。 </p><p><em>在 3.8 版更改:</em> 增加了 <em>sort_dicts</em> 形参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stuff = [<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>, <span class="string">'ni'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stuff.insert(<span class="number">0</span>, stuff[:])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp = pprint.PrettyPrinter(indent=<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp.pprint(stuff)</span><br><span class="line">[   [<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>, <span class="string">'ni'</span>],</span><br><span class="line">    <span class="string">'spam'</span>,</span><br><span class="line">    <span class="string">'eggs'</span>,</span><br><span class="line">    <span class="string">'lumberjack'</span>,</span><br><span class="line">    <span class="string">'knights'</span>,</span><br><span class="line">    <span class="string">'ni'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp = pprint.PrettyPrinter(width=<span class="number">41</span>, compact=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp.pprint(stuff)</span><br><span class="line">[[<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>,</span><br><span class="line">  <span class="string">'knights'</span>, <span class="string">'ni'</span>],</span><br><span class="line"> <span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>,</span><br><span class="line"> <span class="string">'ni'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup = (<span class="string">'spam'</span>, (<span class="string">'eggs'</span>, (<span class="string">'lumberjack'</span>, (<span class="string">'knights'</span>, (<span class="string">'ni'</span>, (<span class="string">'dead'</span>,</span><br><span class="line"><span class="meta">... </span>(<span class="string">'parrot'</span>, (<span class="string">'fresh fruit'</span>,))))))))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp = pprint.PrettyPrinter(depth=<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp.pprint(tup)</span><br><span class="line">(<span class="string">'spam'</span>, (<span class="string">'eggs'</span>, (<span class="string">'lumberjack'</span>, (<span class="string">'knights'</span>, (<span class="string">'ni'</span>, (<span class="string">'dead'</span>, (...)))))))</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p> <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#module-pprint" target="_blank" rel="noopener"><code>pprint</code></a> 模块还提供了一些快捷函数： </p><ul><li><p><code>pprint.pformat</code>(<em>object</em>, <em>indent=1</em>, <em>width=80</em>, <em>depth=None</em>, <em>**, </em>compact=False<em>, </em>sort_dicts=True*)</p><p><em>object</em> 的格式化表示作为字符串返回。 <em>indent</em>, <em>width</em>, <em>depth</em>, <em>compact</em> 和 <em>sort_dicts</em> 将作为格式化形参被传入 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 构造器。<em>在 3.4 版更改:</em> 增加了 <em>compact</em> 形参。<em>在 3.8 版更改:</em> 增加了 <em>sort_dicts</em> 形参。</p></li><li><p><code>pprint.pp</code>(<em>object</em>, <strong>args<em>, </em>sort_dicts=False<em>, </em></strong>kwargs*)</p><p>打印 <em>object</em> 的格式化表示并附带一个换行符。 如果 <em>sort_dicts</em> 为假值（默认），字典将按键的插入顺序显示，否则将按字典键排序。 <em>args</em> 和 <em>kwargs</em> 将作为格式化形参被传给 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#module-pprint" target="_blank" rel="noopener"><code>pprint()</code></a>。<em>3.8 新版功能.</em></p></li><li><p><code>pprint.pprint</code>(<em>object</em>, <em>stream=None</em>, <em>indent=1</em>, <em>width=80</em>, <em>depth=None</em>, <em>**, </em>compact=False<em>, </em>sort_dicts=True*)</p><p>在 <em>stream</em> 上打打印 <em>object</em> 的格式化表示，并附带一个换行符。 如果 <em>stream</em> 为 <code>None</code>，则使用 <code>sys.stdout</code>。 这可以替代 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 函数在交互式解释器中使用以查看值（你甚至可以执行重新赋值 <code>print = pprint.pprint</code> 以在特定作用域中使用）。 <em>indent</em>, <em>width</em>, <em>depth</em>, <em>compact</em> 和 <em>sort_dicts</em> 将作为格式化形参被传给 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 构造器。</p><p><em>在 3.8 版更改:</em> 增加了 <em>sort_dicts</em> 形参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stuff = [<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>, <span class="string">'ni'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stuff.insert(<span class="number">0</span>, stuff)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(stuff)</span><br><span class="line">[&lt;Recursion on list <span class="keyword">with</span> id=...&gt;,</span><br><span class="line"> <span class="string">'spam'</span>,</span><br><span class="line"> <span class="string">'eggs'</span>,</span><br><span class="line"> <span class="string">'lumberjack'</span>,</span><br><span class="line"> <span class="string">'knights'</span>,</span><br><span class="line"> <span class="string">'ni'</span>]</span><br></pre></td></tr></table></figure></li></ul><h2 id="PrettyPrinter-对象"><a href="#PrettyPrinter-对象" class="headerlink" title="PrettyPrinter 对象"></a>PrettyPrinter 对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 的实例具有下列方法：</p><ul><li><p><code>PrettyPrinter.pformat</code>(<em>object</em>)</p><p>返回 <em>object</em> 格式化表示。 这会将传给 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 构造器的选项纳入考虑。</p></li><li><p><code>PrettyPrinter.pprint</code>(<em>object</em>)</p><p>在所配置的流上打印 <em>object</em> 的格式化表示，并附加一个换行符。</p></li></ul><p>下列方法提供了与同名函数相对应的实现。 在实例上使用这些方法效率会更高一些，因为不需要创建新的 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 对象。</p><ul><li><p><code>PrettyPrinter.isreadable</code>(<em>object</em>)</p><p>确定对象的格式化表示是否“可读”，或者是否可使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 重建对象值。 请注意此方法对于递归对象将返回 <code>False</code>。 如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter" target="_blank" rel="noopener"><code>PrettyPrinter</code></a> 的 <em>depth</em> 形参并且对象深度超出允许范围，此方法将返回 <code>False</code>。</p></li><li><p><code>PrettyPrinter.isrecursive</code>(<em>object</em>)</p><p>确定对象是否需要递归表示。</p></li></ul><p>此方法作为一个钩子提供，允许子类修改将对象转换为字符串的方式。 默认实现使用 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.saferepr" target="_blank" rel="noopener"><code>saferepr()</code></a> 实现的内部方式。</p><ul><li><p><code>PrettyPrinter.format</code>(<em>object</em>, <em>context</em>, <em>maxlevels</em>, <em>level</em>)</p><p>返回三个值：字符串形式的 <em>object</em> 已格式化版本，指明结果是否可读的旗标，以及指明是否检测到递归的旗标。 第一个参数是要表示的对象。 第二个是以对象 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#id" target="_blank" rel="noopener"><code>id()</code></a> 为键的字典，这些对象是当前表示上下文的一部分（影响 <em>object</em> 表示的直接和间接容器）；如果需要呈现一个已经在 <em>context</em> 中表示的对象，则第三个返回值应当为 <code>True</code>。 对 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#pprint.PrettyPrinter.format" target="_blank" rel="noopener"><code>format()</code></a> 方法的递归调用应当将容器的附加条目添加到此字典中。 第三个参数 <em>maxlevels</em> 给出了对递归的请求限制；如果没有请求限制则其值将为 <code>0</code>。 此参数应当不加修改地传给递归调用。 第四个参数 <em>level</em> 给出于当前层级；传给递归调用的参数值应当小于当前调用的值。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>为了演示 <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#module-pprint" target="_blank" rel="noopener"><code>pprint()</code></a> 函数及其形参的几种用法，让我们从 <a href="https://pypi.org/" target="_blank" rel="noopener">PyPI</a> 获取关于某个项目的信息:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> urlopen(<span class="string">'https://pypi.org/pypi/sampleproject/json'</span>) <span class="keyword">as</span> resp:</span><br><span class="line"><span class="meta">... </span>    project_info = json.load(resp)[<span class="string">'info'</span>]</span><br></pre></td></tr></table></figure><p> <a href="https://docs.python.org/zh-cn/3.8/library/pprint.html#module-pprint" target="_blank" rel="noopener"><code>pprint()</code></a> 以其基本形式显示了整个对象: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(project_info)</span><br><span class="line">&#123;<span class="string">'author'</span>: <span class="string">'The Python Packaging Authority'</span>,</span><br><span class="line"> <span class="string">'author_email'</span>: <span class="string">'pypa-dev@googlegroups.com'</span>,</span><br><span class="line"> <span class="string">'bugtrack_url'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'classifiers'</span>: [<span class="string">'Development Status :: 3 - Alpha'</span>,</span><br><span class="line">                 <span class="string">'Intended Audience :: Developers'</span>,</span><br><span class="line">                 <span class="string">'License :: OSI Approved :: MIT License'</span>,</span><br><span class="line">                 <span class="string">'Programming Language :: Python :: 2'</span>,</span><br><span class="line">                 <span class="string">'Programming Language :: Python :: 2.6'</span>,</span><br><span class="line">                 <span class="string">'Programming Language :: Python :: 2.7'</span>,</span><br><span class="line">                 <span class="string">'Programming Language :: Python :: 3'</span>,</span><br><span class="line">                 <span class="string">'Programming Language :: Python :: 3.2'</span>,</span><br><span class="line">                 <span class="string">'Programming Language :: Python :: 3.3'</span>,</span><br><span class="line">                 <span class="string">'Programming Language :: Python :: 3.4'</span>,</span><br><span class="line">                 <span class="string">'Topic :: Software Development :: Build Tools'</span>],</span><br><span class="line"> <span class="string">'description'</span>: <span class="string">'A sample Python project\n'</span></span><br><span class="line">                <span class="string">'=======================\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'This is the description file for the project.\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'The file should use UTF-8 encoding and be written using '</span></span><br><span class="line">                <span class="string">'ReStructured Text. It\n'</span></span><br><span class="line">                <span class="string">'will be used to generate the project webpage on PyPI, and '</span></span><br><span class="line">                <span class="string">'should be written for\n'</span></span><br><span class="line">                <span class="string">'that purpose.\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'Typical contents for this file would include an overview of '</span></span><br><span class="line">                <span class="string">'the project, basic\n'</span></span><br><span class="line">                <span class="string">'usage examples, etc. Generally, including the project '</span></span><br><span class="line">                <span class="string">'changelog in here is not\n'</span></span><br><span class="line">                <span class="string">'a good idea, although a simple "What\'s New" section for the '</span></span><br><span class="line">                <span class="string">'most recent version\n'</span></span><br><span class="line">                <span class="string">'may be appropriate.'</span>,</span><br><span class="line"> <span class="string">'description_content_type'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'docs_url'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'download_url'</span>: <span class="string">'UNKNOWN'</span>,</span><br><span class="line"> <span class="string">'downloads'</span>: &#123;<span class="string">'last_day'</span>: <span class="number">-1</span>, <span class="string">'last_month'</span>: <span class="number">-1</span>, <span class="string">'last_week'</span>: <span class="number">-1</span>&#125;,</span><br><span class="line"> <span class="string">'home_page'</span>: <span class="string">'https://github.com/pypa/sampleproject'</span>,</span><br><span class="line"> <span class="string">'keywords'</span>: <span class="string">'sample setuptools development'</span>,</span><br><span class="line"> <span class="string">'license'</span>: <span class="string">'MIT'</span>,</span><br><span class="line"> <span class="string">'maintainer'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'maintainer_email'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'name'</span>: <span class="string">'sampleproject'</span>,</span><br><span class="line"> <span class="string">'package_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/'</span>,</span><br><span class="line"> <span class="string">'platform'</span>: <span class="string">'UNKNOWN'</span>,</span><br><span class="line"> <span class="string">'project_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/'</span>,</span><br><span class="line"> <span class="string">'project_urls'</span>: &#123;<span class="string">'Download'</span>: <span class="string">'UNKNOWN'</span>,</span><br><span class="line">                  <span class="string">'Homepage'</span>: <span class="string">'https://github.com/pypa/sampleproject'</span>&#125;,</span><br><span class="line"> <span class="string">'release_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/1.2.0/'</span>,</span><br><span class="line"> <span class="string">'requires_dist'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'requires_python'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'summary'</span>: <span class="string">'A sample Python project'</span>,</span><br><span class="line"> <span class="string">'version'</span>: <span class="string">'1.2.0'</span>&#125;</span><br></pre></td></tr></table></figure><p> 结果可以被限制到特定的 <em>depth</em> (更深层的内容将使用省略号): </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(project_info, depth=<span class="number">1</span>)</span><br><span class="line">&#123;<span class="string">'author'</span>: <span class="string">'The Python Packaging Authority'</span>,</span><br><span class="line"> <span class="string">'author_email'</span>: <span class="string">'pypa-dev@googlegroups.com'</span>,</span><br><span class="line"> <span class="string">'bugtrack_url'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'classifiers'</span>: [...],</span><br><span class="line"> <span class="string">'description'</span>: <span class="string">'A sample Python project\n'</span></span><br><span class="line">                <span class="string">'=======================\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'This is the description file for the project.\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'The file should use UTF-8 encoding and be written using '</span></span><br><span class="line">                <span class="string">'ReStructured Text. It\n'</span></span><br><span class="line">                <span class="string">'will be used to generate the project webpage on PyPI, and '</span></span><br><span class="line">                <span class="string">'should be written for\n'</span></span><br><span class="line">                <span class="string">'that purpose.\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'Typical contents for this file would include an overview of '</span></span><br><span class="line">                <span class="string">'the project, basic\n'</span></span><br><span class="line">                <span class="string">'usage examples, etc. Generally, including the project '</span></span><br><span class="line">                <span class="string">'changelog in here is not\n'</span></span><br><span class="line">                <span class="string">'a good idea, although a simple "What\'s New" section for the '</span></span><br><span class="line">                <span class="string">'most recent version\n'</span></span><br><span class="line">                <span class="string">'may be appropriate.'</span>,</span><br><span class="line"> <span class="string">'description_content_type'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'docs_url'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'download_url'</span>: <span class="string">'UNKNOWN'</span>,</span><br><span class="line"> <span class="string">'downloads'</span>: &#123;...&#125;,</span><br><span class="line"> <span class="string">'home_page'</span>: <span class="string">'https://github.com/pypa/sampleproject'</span>,</span><br><span class="line"> <span class="string">'keywords'</span>: <span class="string">'sample setuptools development'</span>,</span><br><span class="line"> <span class="string">'license'</span>: <span class="string">'MIT'</span>,</span><br><span class="line"> <span class="string">'maintainer'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'maintainer_email'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'name'</span>: <span class="string">'sampleproject'</span>,</span><br><span class="line"> <span class="string">'package_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/'</span>,</span><br><span class="line"> <span class="string">'platform'</span>: <span class="string">'UNKNOWN'</span>,</span><br><span class="line"> <span class="string">'project_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/'</span>,</span><br><span class="line"> <span class="string">'project_urls'</span>: &#123;...&#125;,</span><br><span class="line"> <span class="string">'release_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/1.2.0/'</span>,</span><br><span class="line"> <span class="string">'requires_dist'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'requires_python'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'summary'</span>: <span class="string">'A sample Python project'</span>,</span><br><span class="line"> <span class="string">'version'</span>: <span class="string">'1.2.0'</span>&#125;</span><br></pre></td></tr></table></figure><p> 此外，还可以设置建议的最大字符 <em>width</em>。 如果一个对象无法被拆分，则将超出指定宽度: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(project_info, depth=<span class="number">1</span>, width=<span class="number">60</span>)</span><br><span class="line">&#123;<span class="string">'author'</span>: <span class="string">'The Python Packaging Authority'</span>,</span><br><span class="line"> <span class="string">'author_email'</span>: <span class="string">'pypa-dev@googlegroups.com'</span>,</span><br><span class="line"> <span class="string">'bugtrack_url'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'classifiers'</span>: [...],</span><br><span class="line"> <span class="string">'description'</span>: <span class="string">'A sample Python project\n'</span></span><br><span class="line">                <span class="string">'=======================\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'This is the description file for the '</span></span><br><span class="line">                <span class="string">'project.\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'The file should use UTF-8 encoding and be '</span></span><br><span class="line">                <span class="string">'written using ReStructured Text. It\n'</span></span><br><span class="line">                <span class="string">'will be used to generate the project '</span></span><br><span class="line">                <span class="string">'webpage on PyPI, and should be written '</span></span><br><span class="line">                <span class="string">'for\n'</span></span><br><span class="line">                <span class="string">'that purpose.\n'</span></span><br><span class="line">                <span class="string">'\n'</span></span><br><span class="line">                <span class="string">'Typical contents for this file would '</span></span><br><span class="line">                <span class="string">'include an overview of the project, '</span></span><br><span class="line">                <span class="string">'basic\n'</span></span><br><span class="line">                <span class="string">'usage examples, etc. Generally, including '</span></span><br><span class="line">                <span class="string">'the project changelog in here is not\n'</span></span><br><span class="line">                <span class="string">'a good idea, although a simple "What\'s '</span></span><br><span class="line">                <span class="string">'New" section for the most recent version\n'</span></span><br><span class="line">                <span class="string">'may be appropriate.'</span>,</span><br><span class="line"> <span class="string">'description_content_type'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'docs_url'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'download_url'</span>: <span class="string">'UNKNOWN'</span>,</span><br><span class="line"> <span class="string">'downloads'</span>: &#123;...&#125;,</span><br><span class="line"> <span class="string">'home_page'</span>: <span class="string">'https://github.com/pypa/sampleproject'</span>,</span><br><span class="line"> <span class="string">'keywords'</span>: <span class="string">'sample setuptools development'</span>,</span><br><span class="line"> <span class="string">'license'</span>: <span class="string">'MIT'</span>,</span><br><span class="line"> <span class="string">'maintainer'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'maintainer_email'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'name'</span>: <span class="string">'sampleproject'</span>,</span><br><span class="line"> <span class="string">'package_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/'</span>,</span><br><span class="line"> <span class="string">'platform'</span>: <span class="string">'UNKNOWN'</span>,</span><br><span class="line"> <span class="string">'project_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/'</span>,</span><br><span class="line"> <span class="string">'project_urls'</span>: &#123;...&#125;,</span><br><span class="line"> <span class="string">'release_url'</span>: <span class="string">'https://pypi.org/project/sampleproject/1.2.0/'</span>,</span><br><span class="line"> <span class="string">'requires_dist'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'requires_python'</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">'summary'</span>: <span class="string">'A sample Python project'</span>,</span><br><span class="line"> <span class="string">'version'</span>: <span class="string">'1.2.0'</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="1-常用格式化"><a href="#1-常用格式化" class="headerlink" title="1. 常用格式化"></a>1. 常用格式化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [(<span class="number">1</span>,&#123;<span class="string">'a'</span>:<span class="string">'A'</span>,<span class="string">'b'</span>:<span class="string">'B'</span>,<span class="string">'c'</span>:<span class="string">'C'</span>,<span class="string">'d'</span>:<span class="string">'D'</span>&#125;),(<span class="number">2</span>,&#123;<span class="string">'e'</span>:<span class="string">'E'</span>,<span class="string">'f'</span>:<span class="string">'F'</span>,<span class="string">'g'</span>:<span class="string">'G'</span>,<span class="string">'h'</span>:<span class="string">'H'</span>,<span class="string">'i'</span>:<span class="string">'I'</span>,<span class="string">'j'</span>:<span class="string">'J'</span>,<span class="string">'k'</span>:<span class="string">'K'</span>,<span class="string">'l'</span>:<span class="string">'L'</span>&#125;),]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(data)</span><br><span class="line">[(<span class="number">1</span>, &#123;<span class="string">'a'</span>: <span class="string">'A'</span>, <span class="string">'b'</span>: <span class="string">'B'</span>, <span class="string">'c'</span>: <span class="string">'C'</span>, <span class="string">'d'</span>: <span class="string">'D'</span>&#125;),</span><br><span class="line"> (<span class="number">2</span>,</span><br><span class="line">  &#123;<span class="string">'e'</span>: <span class="string">'E'</span>,</span><br><span class="line">   <span class="string">'f'</span>: <span class="string">'F'</span>,</span><br><span class="line">   <span class="string">'g'</span>: <span class="string">'G'</span>,</span><br><span class="line">   <span class="string">'h'</span>: <span class="string">'H'</span>,</span><br><span class="line">   <span class="string">'i'</span>: <span class="string">'I'</span>,</span><br><span class="line">   <span class="string">'j'</span>: <span class="string">'J'</span>,</span><br><span class="line">   <span class="string">'k'</span>: <span class="string">'K'</span>,</span><br><span class="line">   <span class="string">'l'</span>: <span class="string">'L'</span>&#125;)]</span><br></pre></td></tr></table></figure><h3 id="2-格式化序列"><a href="#2-格式化序列" class="headerlink" title="2. 格式化序列"></a>2. 格式化序列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [(<span class="number">1</span>,&#123;<span class="string">'a'</span>:<span class="string">'A'</span>,<span class="string">'b'</span>:<span class="string">'B'</span>,<span class="string">'c'</span>:<span class="string">'C'</span>,<span class="string">'d'</span>:<span class="string">'D'</span>&#125;),(<span class="number">2</span>,&#123;<span class="string">'e'</span>:<span class="string">'E'</span>,<span class="string">'f'</span>:<span class="string">'F'</span>,<span class="string">'g'</span>:<span class="string">'G'</span>,<span class="string">'h'</span>:<span class="string">'H'</span>,<span class="string">'i'</span>:<span class="string">'I'</span>,<span class="string">'j'</span>:<span class="string">'J'</span>,<span class="string">'k'</span>:<span class="string">'K'</span>,<span class="string">'l'</span>:<span class="string">'L'</span>&#125;),]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result=pprint.pformat(data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> result.splitlines():</span><br><span class="line">print(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[(<span class="number">1</span>, &#123;<span class="string">'a'</span>: <span class="string">'A'</span>, <span class="string">'b'</span>: <span class="string">'B'</span>, <span class="string">'c'</span>: <span class="string">'C'</span>, <span class="string">'d'</span>: <span class="string">'D'</span>&#125;),</span><br><span class="line"> (<span class="number">2</span>,</span><br><span class="line">  &#123;<span class="string">'e'</span>: <span class="string">'E'</span>,</span><br><span class="line">   <span class="string">'f'</span>: <span class="string">'F'</span>,</span><br><span class="line">   <span class="string">'g'</span>: <span class="string">'G'</span>,</span><br><span class="line">   <span class="string">'h'</span>: <span class="string">'H'</span>,</span><br><span class="line">   <span class="string">'i'</span>: <span class="string">'I'</span>,</span><br><span class="line">   <span class="string">'j'</span>: <span class="string">'J'</span>,</span><br><span class="line">   <span class="string">'k'</span>: <span class="string">'K'</span>,</span><br><span class="line">   <span class="string">'l'</span>: <span class="string">'L'</span>&#125;)]</span><br></pre></td></tr></table></figure><h3 id="3-复杂的格式化-用于调试代码"><a href="#3-复杂的格式化-用于调试代码" class="headerlink" title="3. 复杂的格式化,用于调试代码"></a>3. 复杂的格式化,用于调试代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pprint;</span><br><span class="line"><span class="keyword">import</span> re;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pprintDemo</span><span class="params">()</span>:</span></span><br><span class="line">    varsList = [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="string">"ab"</span>, <span class="string">"c"</span>, <span class="string">"def"</span>],</span><br><span class="line">        re.compile(<span class="string">"\w+"</span>),</span><br><span class="line">        (<span class="string">"123"</span>, <span class="string">"abc"</span>),</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"key1"</span>:<span class="string">"value1"</span>,</span><br><span class="line">            <span class="string">"key2"</span>:<span class="string">"value2"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> varsList:</span><br><span class="line">        print(value);</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">"-"</span>*<span class="number">80</span>)</span><br><span class="line"> </span><br><span class="line">    pp = pprint.PrettyPrinter(indent=<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> varsList:</span><br><span class="line">        pp.pprint(value);</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">"-"</span>*<span class="number">80</span>)</span><br><span class="line">    stuff = [<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>, <span class="string">'ni'</span>];</span><br><span class="line">    stuff.insert(<span class="number">0</span>, stuff[:])</span><br><span class="line">    <span class="keyword">print</span> stuff;</span><br><span class="line">    print(<span class="string">"-"</span>*<span class="number">80</span>)</span><br><span class="line">    pp.pprint(stuff)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pprintDemo();</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="string">'ab'</span>, <span class="string">'c'</span>, <span class="string">'def'</span>]</span><br><span class="line">&lt;_sre.SRE_Pattern object at <span class="number">0x00000000030DD378</span>&gt;</span><br><span class="line">(<span class="string">'123'</span>, <span class="string">'abc'</span>)</span><br><span class="line">&#123;<span class="string">'key2'</span>: <span class="string">'value2'</span>, <span class="string">'key1'</span>: <span class="string">'value1'</span>&#125;</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="string">'ab'</span>, <span class="string">'c'</span>, <span class="string">'def'</span>]</span><br><span class="line">&lt;_sre.SRE_Pattern object at <span class="number">0x00000000030DD378</span>&gt;</span><br><span class="line">(<span class="string">'123'</span>, <span class="string">'abc'</span>)</span><br><span class="line">&#123;   <span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</span><br><span class="line">================================================================================</span><br><span class="line">[[<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>, <span class="string">'ni'</span>], <span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>, <span class="string">'ni'</span>]</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">[   [<span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'lumberjack'</span>, <span class="string">'knights'</span>, <span class="string">'ni'</span>],</span><br><span class="line">    <span class="string">'spam'</span>,</span><br><span class="line">    <span class="string">'eggs'</span>,</span><br><span class="line">    <span class="string">'lumberjack'</span>,</span><br><span class="line">    <span class="string">'knights'</span>,</span><br><span class="line">    <span class="string">'ni'</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-pprint&quot;&gt;&lt;a href=&quot;#python-标准库-pprint&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 pprint&quot;&gt;&lt;/a&gt;python 标准库 pprint&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s.yimg.com/ny/api/res/1.2/U9YwDsQH7.4w06Tgw2pHJg--~A/YXBwaWQ9aGlnaGxhbmRlcjtzbT0xO3c9MTI4MDtoPTk2MA--/https://media.zenfs.com/zh-tw/nownews.com/e25e4ab4f7a980ccfcaca403eafb3a15&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="pprint" scheme="https://pinghailinfeng.gitee.io/tags/pprint/"/>
    
  </entry>
  
  <entry>
    <title>python standard library reprlib</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/26/python-standard-library-reprlib/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/26/python-standard-library-reprlib/</id>
    <published>2020-01-26T00:52:32.000Z</published>
    <updated>2020-01-30T08:43:58.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-reprlib"><a href="#python-标准库-reprlib" class="headerlink" title="python 标准库 reprlib"></a>python 标准库 reprlib</h1><p><img src="https://n.sinaimg.cn/news/719/w600h919/20200126/eb39-innckcf7806867.png" alt></p><a id="more"></a><p><strong>武汉挺住！！！</strong></p><p><a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#module-reprlib" target="_blank" rel="noopener"><code>reprlib</code></a> 模块提供了一种对象表示的产生方式，它会对结果字符串的大小进行限制。 该方式被用于 Python 调试器，也适用于某些其他场景。</p><p>此模块提供了一个类、一个实例和一个函数：</p><ul><li><p><em>class</em> <code>reprlib.Repr</code> </p><p>该类提供了格式化服务 适用于实现与内置 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 相似的方法；其中附加了针对不同对象类型的大小限制，以避免生成超长的表示。 </p></li><li><p><code>reprlib.aRepr</code> </p><p>这是 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr" target="_blank" rel="noopener"><code>Repr</code></a> 的一个实例，用于提供如下所述的 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.repr" target="_blank" rel="noopener"><code>repr()</code></a> 函数。 改变此对象的属性将会影响 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.repr" target="_blank" rel="noopener"><code>repr()</code></a> 和 Python 调试器所使用的大小限制。 </p></li><li><p><code>reprlib.repr</code>(<em>obj</em>) </p><p>这是 <code>aRepr</code> 的 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.repr" target="_blank" rel="noopener"><code>repr()</code></a> 方法。 它会返回与同名内置函数所返回字符串相似的字符串，区别在于附带了对多数类型的大小限制。 </p><p>在大小限制工具以外，此模块还提供了一个装饰器，用于检测对 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> 的递归调用并改用一个占位符来替换。 </p></li><li><p><a href="mailto:`@reprlib.recursiv" target="_blank" rel="noopener">`@reprlib.recursiv</a>e_repr`(<em>fillvalue=”…”</em>) </p><p>用于为 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> 方法检测同一线程内部递归调用的装饰器。 如果执行了递归调用，则会返回 <em>fillvalue</em>，否则执行正常的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> 调用。 例如： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> reprlib <span class="keyword">import</span> recursive_repr</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list)</span>:</span></span><br><span class="line">---   @recursive_repr()</span><br><span class="line">---   <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">---        <span class="keyword">return</span> <span class="string">'&lt;'</span> + <span class="string">'|'</span>.join(map(repr, self)) + <span class="string">'&gt;'</span></span><br><span class="line">---</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = MyList(<span class="string">'abc'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.append(m)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.append(<span class="string">'x'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(m)</span><br><span class="line">&lt;<span class="string">'a'</span>|<span class="string">'b'</span>|<span class="string">'c'</span>|...|<span class="string">'x'</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Repr-对象"><a href="#Repr-对象" class="headerlink" title="Repr 对象"></a>Repr 对象</h2><p> <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr" target="_blank" rel="noopener"><code>Repr</code></a> 实例对象包含一些属性可以用于为不同对象类型的表示提供大小限制，还包含一些方法可以格式化特定的对象类型。 </p><ul><li><p><code>Repr.maxlevel</code></p><p>创建递归表示形式的深度限制。 默认为 <code>6</code>。</p></li><li><p><code>Repr.maxdict</code></p></li><li><p><code>Repr.maxlist</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reprlib  </span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line">reprlib.aRepr.maxlist = <span class="number">2</span>  </span><br><span class="line">print(reprlib.repr(a))  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, ...]</span><br></pre></td></tr></table></figure></li><li><p><code>Repr.maxtuple</code></p></li><li><p><code>Repr.maxset</code></p></li><li><p><code>Repr.maxfrozenset</code></p></li><li><p><code>Repr.maxdeque</code></p></li><li><p><code>Repr.maxarray</code></p><p>代表命名对象类型的条目数量限制。 对于 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.maxdict" target="_blank" rel="noopener"><code>maxdict</code></a> 的默认值为 <code>4</code>，对于 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.maxarray" target="_blank" rel="noopener"><code>maxarray</code></a> 为 <code>5</code>，对于其他则为 <code>6</code>。</p></li><li><p><code>Repr.maxlong</code></p><p>表示整数的最大字符数量。 数码会从中间被丢弃。 默认值为 <code>40</code>。</p></li><li><p><code>Repr.maxstring</code></p><p>表示字符串的字符数量限制。 请注意字符源会使用字符串的“正常”表示形式：如果表示中需要用到转义序列，在缩短表示时它们可能会被破坏。 默认值为 <code>30</code>。</p></li><li><p><code>Repr.maxother</code></p><p>此限制用于控制在 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr" target="_blank" rel="noopener"><code>Repr</code></a> 对象上没有特定的格式化方法可用的对象类型的大小。 它会以类似 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.maxstring" target="_blank" rel="noopener"><code>maxstring</code></a> 的方式被应用。 默认值为 <code>20</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">reprlib.aRepr.maxlevel = <span class="number">1</span></span><br><span class="line">print(reprlib.repr(a))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[...],<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>Repr.repr</code>(<em>obj</em>)</p><p>内置 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 的等价形式，它使用实例专属的格式化。</p></li><li><p><code>Repr.repr1</code>(<em>obj</em>, <em>level</em>)</p><p>供 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.repr" target="_blank" rel="noopener"><code>repr()</code></a> 使用的递归实现。 此方法使用 <em>obj</em> 的类型来确定要调用哪个格式化方法，并传入 <em>obj</em> 和 <em>level</em>。 类型专属的方法应当调用 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.repr1" target="_blank" rel="noopener"><code>repr1()</code></a> 来执行递归格式化，在递归调用中使用 <code>level - 1</code> 作为 <em>level</em> 的值。</p></li><li><p><code>Repr.repr_TYPE</code>(<em>obj</em>, <em>level</em>)</p><p>特定类型的格式化方法会被实现为基于类型名称来命名的方法。 在方法名称中，<strong>TYPE</strong> 会被替换为 <code>&#39;_&#39;.join(type(obj).__name__.split())</code>。 对这些方法的分派会由 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.repr1" target="_blank" rel="noopener"><code>repr1()</code></a> 来处理。 需要对值进行递归格式化的类型专属方法应当调用 <code>self.repr1(subobj, level - 1)</code>。</p></li></ul><h2 id="子类化-Repr-对象"><a href="#子类化-Repr-对象" class="headerlink" title="子类化 Repr 对象"></a>子类化 Repr 对象</h2><p> 通过 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr.repr1" target="_blank" rel="noopener"><code>Repr.repr1()</code></a> 使用动态分派允许 <a href="https://docs.python.org/zh-cn/3.8/library/reprlib.html#reprlib.Repr" target="_blank" rel="noopener"><code>Repr</code></a> 的子类添加对额外内置对象类型的支持，或是修改对已支持类型的处理。 这个例子演示了如何添加对文件对象的特殊支持: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRepr</span><span class="params">(reprlib.Repr)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repr_TextIOWrapper</span><span class="params">(self, obj, level)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> obj.name <span class="keyword">in</span> &#123;<span class="string">'&lt;stdin&gt;'</span>, <span class="string">'&lt;stdout&gt;'</span>, <span class="string">'&lt;stderr&gt;'</span>&#125;:</span><br><span class="line">            <span class="keyword">return</span> obj.name</span><br><span class="line">        <span class="keyword">return</span> repr(obj)</span><br><span class="line"></span><br><span class="line">aRepr = MyRepr()</span><br><span class="line">print(aRepr.repr(sys.stdin))         <span class="comment"># prints '&lt;stdin&gt;'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-reprlib&quot;&gt;&lt;a href=&quot;#python-标准库-reprlib&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 reprlib&quot;&gt;&lt;/a&gt;python 标准库 reprlib&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://n.sinaimg.cn/news/719/w600h919/20200126/eb39-innckcf7806867.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="reprlib" scheme="https://pinghailinfeng.gitee.io/tags/reprlib/"/>
    
  </entry>
  
  <entry>
    <title>python standard library dataclasses</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/25/python-standard-library-dataclasses/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/25/python-standard-library-dataclasses/</id>
    <published>2020-01-24T17:28:38.000Z</published>
    <updated>2020-01-30T08:43:58.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-dataclasses"><a href="#python-标准库-dataclasses" class="headerlink" title="python 标准库 dataclasses"></a>python 标准库 dataclasses</h1><p><img src="https://img.zcool.cn/community/01b9205e2af974a8012165188cc6ad.jpg@1280w_1l_2o_100sh.jpg" alt></p><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dataclasses.py" target="_blank" rel="noopener">Lib/dataclasses.py</a> </p><p>主要类结构层次,节选自<a href="[Lib/dataclasses.py](https://github.com/python/cpython/tree/3.8/Lib/dataclasses.py">源码</a> )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">'dataclass'</span>,</span><br><span class="line">           <span class="string">'field'</span>,</span><br><span class="line">           <span class="string">'Field'</span>,</span><br><span class="line">           <span class="string">'FrozenInstanceError'</span>,</span><br><span class="line">           <span class="string">'InitVar'</span>,</span><br><span class="line">           <span class="string">'MISSING'</span>,</span><br><span class="line"></span><br><span class="line">           <span class="comment"># Helper functions.</span></span><br><span class="line">           <span class="string">'fields'</span>,</span><br><span class="line">           <span class="string">'asdict'</span>,</span><br><span class="line">           <span class="string">'astuple'</span>,</span><br><span class="line">           <span class="string">'make_dataclass'</span>,</span><br><span class="line">           <span class="string">'replace'</span>,</span><br><span class="line">           <span class="string">'is_dataclass'</span>,</span><br><span class="line">           ]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DataclassParams</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'init'</span>,</span><br><span class="line">                 <span class="string">'repr'</span>,</span><br><span class="line">                 <span class="string">'eq'</span>,</span><br><span class="line">                 <span class="string">'order'</span>,</span><br><span class="line">                 <span class="string">'unsafe_hash'</span>,</span><br><span class="line">                 <span class="string">'frozen'</span>,</span><br><span class="line">                 )</span><br></pre></td></tr></table></figure><p> 这个模块提供了一个装饰器和一些函数，用于自动添加生成的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-special-method" target="_blank" rel="noopener">special method</a>s ，例如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> 到用户定义的类。 它最初描述于 <a href="https://www.python.org/dev/peps/pep-0557" target="_blank" rel="noopener"><strong>PEP 557</strong></a> 。 </p><p> 在这些生成的方法中使用的成员变量使用 <a href="https://www.python.org/dev/peps/pep-0526" target="_blank" rel="noopener"><strong>PEP 526</strong></a> 类型注释定义。例如这段代码: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryItem</span>:</span></span><br><span class="line">    <span class="string">'''Class for keeping track of an item in inventory.'''</span></span><br><span class="line">    name: str</span><br><span class="line">    unit_price: float</span><br><span class="line">    quantity_on_hand: int = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_cost</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">return</span> self.unit_price * self.quantity_on_hand</span><br></pre></td></tr></table></figure><p> 除其他事情外，将添加 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> ，其看起来像: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name: str, unit_price: float, quantity_on_hand: int=<span class="number">0</span>)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.unit_price = unit_price</span><br><span class="line">    self.quantity_on_hand = quantity_on_hand</span><br></pre></td></tr></table></figure><p> 请注意，此方法会自动添加到类中：它不会在上面显示的 <code>InventoryItem</code> 定义中直接指定。 </p><h2 id="模块级装饰器、类和函数"><a href="#模块级装饰器、类和函数" class="headerlink" title="模块级装饰器、类和函数"></a>模块级装饰器、类和函数</h2><ul><li><p><a href="mailto:`@dataclasses.dataclass" target="_blank" rel="noopener">`@dataclasses.dataclass</a>`(<em>**, </em>init=True<em>, </em>repr=True<em>, </em>eq=True<em>, </em>order=False<em>, </em>unsafe_hash=False<em>, </em>frozen=False*) </p><p>这个函数是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-decorator" target="_blank" rel="noopener">decorator</a> ，用于将生成的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-special-method" target="_blank" rel="noopener">special method</a> 添加到类中，如下所述。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 装饰器检查类以找到 <code>field</code>。 <code>field</code> 被定义为具有 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-variable-annotation" target="_blank" rel="noopener">类型标注</a> 的类变量。除了下面描述的两个例外，在 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 中没有任何内容检查变量标注中指定的类型。</p><p>所有生成的方法中的字段顺序是它们在类定义中出现的顺序。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 装饰器将向类中添加各种“dunder”方法，如下所述。如果类中已存在任何添加的方法，则行为取决于参数，如下所述。装饰器返回被调用的同一个类；没有创建新类。</p><p>如果 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 仅用作没有参数的简单装饰器，它就像它具有此签名中记录的默认值一样。也就是说，这三种 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 用法是等价的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 的参数有： </p><ul><li><p><code>init</code>: 如果为真值（默认），将生成一个 <code>__ init__()</code> 方法。 </p><p>如果类已定义 <code>__ init__()</code> ，则忽略此参数。 </p></li><li><p><code>repr</code> ：如果为真值（默认），将生成一个 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> 方法。 生成的 repr 字符串将具有类名以及每个字段的名称和 repr ，按照它们在类中定义的顺序。不包括标记为从 repr 中排除的字段。 例如：<code>InventoryItem(name=&#39;widget&#39;, unit_price=3.0, quantity_on_hand=10)</code>。 </p><p>如果类已定义 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> ，则忽略此参数。 </p></li><li><p><code>eq</code> ：如果为true（默认值），将生成 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> 方法。此方法将类作为其字段的元组按顺序比较。比较中的两个实例必须是相同的类型。 </p><p>如果类已定义 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> ，则忽略此参数。 </p></li><li><p><code>order</code> ：如果为真值（默认为 <code>False</code> ），则 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__lt__" target="_blank" rel="noopener"><code>__lt__()</code></a> 、 <code>__ le__()</code> 、 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__gt__" target="_blank" rel="noopener"><code>__gt__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__ge__" target="_blank" rel="noopener"><code>__ge__()</code></a> 方法将生成。 这将类作为其字段的元组按顺序比较。比较中的两个实例必须是相同的类型。如果 <code>order</code> 为真值并且 <code>eq</code> 为假值 ，则引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 。</p><p>如果类已经定义了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__lt__" target="_blank" rel="noopener"><code>__lt__()</code></a> 、 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__le__" target="_blank" rel="noopener"><code>__le__()</code></a> 、 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__gt__" target="_blank" rel="noopener"><code>__gt__()</code></a> 或者 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__ge__" target="_blank" rel="noopener"><code>__ge__()</code></a> 中的任意一个，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 。 </p></li><li><p><code>unsafe_hash</code> ：如果为 <code>False</code> （默认值），则根据 <code>eq</code> 和 <code>frozen</code> 的设置方式生成 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法。 </p><p><a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 由内置的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#hash" target="_blank" rel="noopener"><code>hash()</code></a> 使用，当对象被添加到散列集合（如字典和集合）时。有一个 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 意味着类的实例是不可变的。可变性是一个复杂的属性，取决于程序员的意图， <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> 的存在性和行为，以及 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 装饰器中 <code>eq</code> 和 <code>frozen</code> 标志的值。</p><p>默认情况下， <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 不会隐式添加 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法，除非这样做是安全的。 它也不会添加或更改现有的明确定义的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法。 设置类属性 <code>__hash__ = None</code> 对 Python 具有特定含义，如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 文档中所述。</p><p>如果 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 没有显式定义，或者它被设置为 <code>None</code> ，那么 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> <em>可以</em> 添加一个隐式 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法。虽然不推荐，但你可以强制 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 用 <code>unsafe_hash=True</code> 创建一个 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法。 如果你的类在逻辑上是不可变的但实际仍然可变，则可能就是这种情况。这是一个特殊的用例，应该仔细考虑。</p><p>以下是隐式创建 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法的规则。请注意，你不能在数据类中都使用显式的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法并设置 <code>unsafe_hash=True</code> ；这将导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 。</p><p>如果 <code>eq</code> 和 <code>frozen</code> 都是 true，默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 将为你生成一个 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法。如果 <code>eq</code> 为 true 且 <code>frozen</code> 为 false ，则 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 将被设置为 <code>None</code> ，标记它不可用（因为它是可变的）。如果 <code>eq</code> 为 false ，则 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 将保持不变，这意味着将使用超类的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法（如果超类是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> ，这意味着它将回到基于id的hash）。</p></li><li><p><code>frozen</code>: 如为真值 (默认值为 <code>False</code>)，则对字段赋值将会产生异常。 这模拟了只读的冻结实例。 如果在类中定义了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__setattr__" target="_blank" rel="noopener"><code>__setattr__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__delattr__" target="_blank" rel="noopener"><code>__delattr__()</code></a> 则将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 参见下文的讨论。 </p></li></ul><p><code>field</code>s 可以选择使用普通的 Python 语法指定默认值: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    a: int       <span class="comment"># 'a' has no default value</span></span><br><span class="line">    b: int = <span class="number">0</span>   <span class="comment"># assign a default value for 'b'</span></span><br></pre></td></tr></table></figure><p>在这个例子中， <code>a</code> 和 <code>b</code> 都将包含在添加的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法中，它们将被定义为: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a: int, b: int = <span class="number">0</span>)</span>:</span></span><br></pre></td></tr></table></figure><p>如果没有默认值的字段跟在具有默认值的字段后，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 。当这发生在单个类中时，或者作为类继承的结果时，都是如此。 </p></li><li><p><code>dataclasses.field</code>(<em>**, </em>default=MISSING<em>, </em>default_factory=MISSING<em>, </em>repr=True<em>, </em>hash=None<em>, </em>init=True<em>, </em>compare=True<em>, </em>metadata=None*) </p><p>对于常见和简单的用例，不需要其他功能。但是，有些数据类功能需要额外的每字段信息。为了满足这种对附加信息的需求，你可以通过调用提供的 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.field" target="_blank" rel="noopener"><code>field()</code></a> 函数来替换默认字段值。例如: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    mylist: List[int] = field(default_factory=list)</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.mylist += [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>如上所示， <code>MISSING</code> 值是一个 sentinel 对象，用于检测是否提供了 <code>default</code> 和 <code>default_factory</code> 参数。 使用此 sentinel 是因为 <code>None</code> 是 <code>default</code> 的有效值。没有代码应该直接使用 <code>MISSING</code> 值。 </p><p><a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.field" target="_blank" rel="noopener"><code>field()</code></a> 参数有： </p><ul><li><p><code>default</code> ：如果提供，这将是该字段的默认值。这是必需的，因为 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.field" target="_blank" rel="noopener"><code>field()</code></a> 调用本身会替换一般的默认值。 </p></li><li><p><code>default_factory</code> ：如果提供，它必须是一个零参数可调用对象，当该字段需要一个默认值时，它将被调用。除了其他目的之外，这可以用于指定具有可变默认值的字段，如下所述。 同时指定 <code>default</code> 和 <code>default_factory</code> 将产生错误。</p></li><li><p><code>init</code> ：如果为true（默认值），则该字段作为参数包含在生成的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法中。</p></li><li><p><code>repr</code> ：如果为true（默认值），则该字段包含在生成的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__repr__" target="_blank" rel="noopener"><code>__repr__()</code></a> 方法返回的字符串中。</p></li><li><p><code>compare</code> ：如果为true（默认值），则该字段包含在生成的相等性和比较方法中（ <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__gt__" target="_blank" rel="noopener"><code>__gt__()</code></a> 等等）。</p></li><li><p><code>hash</code> ：这可以是布尔值或 <code>None</code> 。如果为true，则此字段包含在生成的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 方法中。如果为 <code>None</code> （默认值），请使用 <code>compare</code> 的值，这通常是预期的行为。如果字段用于比较，则应在 hash 中考虑该字段。不鼓励将此值设置为 <code>None</code> 以外的任何值。</p><p>设置 <code>hash=False</code> 但 <code>compare=True</code> 的一个可能原因是，如果一个计算 hash 的代价很高的字段是检验等价性需要的，但还有其他字段可以计算类型的 hash 。 即使从 hash 中排除某个字段，它仍将用于比较。</p></li><li><p><code>metadata</code> ：这可以是映射或 None 。 None 被视为一个空的字典。这个值包含在 <code>MappingProxyType()</code> 中，使其成为只读，并暴露在 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.Field" target="_blank" rel="noopener"><code>Field</code></a> 对象上。数据类根本不使用它，它是作为第三方扩展机制提供的。多个第三方可以各自拥有自己的键值，以用作元数据中的命名空间。</p></li></ul><p>如果通过调用 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.field" target="_blank" rel="noopener"><code>field()</code></a> 指定字段的默认值，则该字段的类属性将替换为指定的 <code>default</code> 值。如果没有提供 <code>default</code> ，那么将删除类属性。目的是在 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 装饰器运行之后，类属性将包含字段的默认值，就像指定了默认值一样。例如，之后: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    x: int</span><br><span class="line">    y: int = field(repr=<span class="literal">False</span>)</span><br><span class="line">    z: int = field(repr=<span class="literal">False</span>, default=<span class="number">10</span>)</span><br><span class="line">    t: int = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>类属性 <code>C.z</code> 将是 <code>10</code> ，类属性 <code>C.t</code> 将是 <code>20</code>，类属性 <code>C.x</code> 和 <code>C.y</code> 将不设置。 </p></li><li><p><em>class</em> <code>dataclasses.Field</code> </p><p><a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.Field" target="_blank" rel="noopener"><code>Field</code></a> 对象描述每个定义的字段。这些对象在内部创建，并由 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.fields" target="_blank" rel="noopener"><code>fields()</code></a> 模块级方法返回（见下文）。用户永远不应该直接实例化 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.Field" target="_blank" rel="noopener"><code>Field</code></a> 对象。 其有文档的属性是： </p><ul><li><code>name</code> ：字段的名字。</li><li><code>type</code> ：字段的类型。</li><li><code>default</code> 、 <code>default_factory</code> 、 <code>init</code> 、 <code>repr</code> 、 <code>hash</code> 、 <code>compare</code> 以及 <code>metadata</code> 与具有和 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.field" target="_blank" rel="noopener"><code>field()</code></a> 声明中相同的意义和值。</li></ul><p>可能存在其他属性，但它们是私有的，不能被审查或依赖。 </p></li><li><p><code>dataclasses.fields</code>(<em>class_or_instance</em>) </p><p>返回 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.Field" target="_blank" rel="noopener"><code>Field</code></a> 对象的元组，用于定义此数据类的字段。 接受数据类或数据类的实例。如果没有传递一个数据类或实例将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 。 不返回 <code>ClassVar</code> 或 <code>InitVar</code> 的伪字段。 </p></li><li><p><code>dataclasses.asdict</code>(<em>instance</em>, <em>**, </em>dict_factory=dict*) </p><p>将数据类 <code>instance</code> 转换为字典（使用工厂函数 <code>dict_factory</code> ）。每个数据类都转换为其字段的字典，如 <code>name: value</code> 对。数据类、字典、列表和元组被递归。例如: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">     x: int</span><br><span class="line">     y: int</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">     mylist: List[Point]</span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">assert</span> asdict(p) == &#123;<span class="string">'x'</span>: <span class="number">10</span>, <span class="string">'y'</span>: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">c = C([Point(<span class="number">0</span>, <span class="number">0</span>), Point(<span class="number">10</span>, <span class="number">4</span>)])</span><br><span class="line"><span class="keyword">assert</span> asdict(c) == &#123;<span class="string">'mylist'</span>: [&#123;<span class="string">'x'</span>: <span class="number">0</span>, <span class="string">'y'</span>: <span class="number">0</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">10</span>, <span class="string">'y'</span>: <span class="number">4</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><p>引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 如果 <code>instance</code> 不是数据类实例。 </p></li><li><p><code>dataclasses.astuple</code>(<em>instance</em>, <em>**, </em>tuple_factory=tuple*) </p><p>将数据类 <code>instance</code> 转换为元组（通过使用工厂函数 <code>tuple_factory</code> ）。每个数据类都转换为其字段值的元组。数据类、字典、列表和元组被递归。</p><p>继续前一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> astuple(p) == (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">assert</span> astuple(c) == ([(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">10</span>, <span class="number">4</span>)],)</span><br></pre></td></tr></table></figure><p>引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 如果 <code>instance</code> 不是数据类实例。 </p></li><li><p><code>dataclasses.make_dataclass</code>(<em>cls_name</em>, <em>fields</em>, <em>**, </em>bases=()<em>, </em>namespace=None<em>, </em>init=True<em>, </em>repr=True<em>, </em>eq=True<em>, </em>order=False<em>, </em>unsafe_hash=False<em>, </em>frozen=False*) </p><p>创建一个名为 <code>cls_name</code> 的新数据类，字段为 <code>fields</code> 中定义的字段，基类为 <code>bases</code> 中给出的基类，并使用 <code>namespace</code> 中给出的命名空间进行初始化。 <code>fields</code> 是一个可迭代的元素，每个元素都是 <code>name</code> 、 <code>(name, type)</code> 或 <code>(name, type, Field)</code> 。 如果只提供name ， <code>type</code> 为 <code>typing.Any</code> 。 <code>init</code> 、 <code>repr</code> 、 <code>eq</code> 、 <code>order</code> 、 <code>unsafe_hash</code> 和 <code>frozen</code> 的值与它们在 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 中的含义相同。</p><p>此函数不是严格要求的，因为用于任何创建带有 <code>__annotations__</code> 的新类的 Python 机制都可以应用 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 函数将该类转换为数据类。提供此功能是为了方便。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C = make_dataclass(<span class="string">'C'</span>,</span><br><span class="line">                   [(<span class="string">'x'</span>, int),</span><br><span class="line">                     <span class="string">'y'</span>,</span><br><span class="line">                    (<span class="string">'z'</span>, int, field(default=<span class="number">5</span>))],</span><br><span class="line">                   namespace=&#123;<span class="string">'add_one'</span>: <span class="keyword">lambda</span> self: self.x + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>等价于 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    x: int</span><br><span class="line">    y: <span class="string">'typing.Any'</span></span><br><span class="line">    z: int = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x + <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>dataclasses.replace</code>(<em>instance</em>, <em>**changes</em>) </p><p>创建一个 <code>instance</code> 相同类型的新对象，用 <code>changes</code> 中的值替换字段。如果 <code>instance</code> 不是数据类，则引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 。如果 <code>changes</code> 中的值没有指定字段，则引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 。</p><p>新返回的对象通过调用数据类的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法创建。这确保了如果存在 <code>__post_init__()</code> ，其也被调用。</p><p>如果存在没有默认值的仅初始化变量，必须在调用 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.replace" target="_blank" rel="noopener"><code>replace()</code></a> 时指定，以便它们可以传递给 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 和 <code>__post_init__()</code> 。</p><p><code>changes</code> 包含任何定义为 <code>init=False</code> 的字段是错误的。在这种情况下会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 。</p><p>提前提醒 <code>init=False</code> 字段在调用 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.replace" target="_blank" rel="noopener"><code>replace()</code></a> 时的工作方式。如果它们完全被初始化的话，它们不是从源对象复制的，而是在 <code>__post_init__()</code> 中初始化。估计 <code>init=False</code> 字段很少能被正确地使用。如果使用它们，那么使用备用类构造函数或者可能是处理实例复制的自定义 <code>replace()</code> （或类似命名的）方法可能是明智的。</p></li><li><p><code>dataclasses.is_dataclass</code>(<em>class_or_instance</em>) </p><p>如果其形参为 dataclass 或其实例则返回 <code>True</code>，否则返回 <code>False</code>。</p><p>如果你需要知道一个类是否是一个数据类的实例（而不是一个数据类本身），那么再添加一个 <code>not isinstance(obj, type)</code> 检查:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_dataclass_instance</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> is_dataclass(obj) <span class="keyword">and</span> <span class="keyword">not</span> isinstance(obj, type)</span><br></pre></td></tr></table></figure></li></ul><h2 id="初始化后处理"><a href="#初始化后处理" class="headerlink" title="初始化后处理"></a>初始化后处理</h2><p>生成的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 代码将调用一个名为 <code>__post_init__()</code> 的方法，如果在类上已经定义了 <code>__post_init__()</code> 。它通常被称为 <code>self.__post_init__()</code> 。但是，如果定义了任何 <code>InitVar</code> 字段，它们也将按照它们在类中定义的顺序传递给 <code>__post_init__()</code> 。 如果没有 <code>__ init__()</code> 方法生成，那么 <code>__post_init__()</code> 将不会被自动调用。</p><p>在其他用途中，这允许初始化依赖于一个或多个其他字段的字段值。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    a: float</span><br><span class="line">    b: float</span><br><span class="line">    c: float = field(init=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__post_init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.c = self.a + self.b</span><br></pre></td></tr></table></figure><p> 有关将参数传递给 <code>__post_init__()</code> 的方法，请参阅下面有关仅初始化变量的段落。另请参阅关于 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.replace" target="_blank" rel="noopener"><code>replace()</code></a> 处理 <code>init=False</code> 字段的警告。 </p><h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><p> 两个地方 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 实际检查字段类型的之一是确定字段是否是如 <a href="https://www.python.org/dev/peps/pep-0526" target="_blank" rel="noopener"><strong>PEP 526</strong></a> 所定义的类变量。它通过检查字段的类型是否为 <code>typing.ClassVar</code> 来完成此操作。如果一个字段是一个 <code>ClassVar</code> ，它将被排除在考虑范围之外，并被数据类机制忽略。这样的 <code>ClassVar</code> 伪字段不会由模块级的 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.fields" target="_blank" rel="noopener"><code>fields()</code></a> 函数返回。 </p><h2 id="仅初始化变量"><a href="#仅初始化变量" class="headerlink" title="仅初始化变量"></a>仅初始化变量</h2><p>另一个 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 检查类型注解地方是为了确定一个字段是否是一个仅初始化变量。它通过查看字段的类型是否为 <code>dataclasses.InitVar</code> 类型来实现。如果一个字段是一个 <code>InitVar</code> ，它被认为是一个称为仅初始化字段的伪字段。因为它不是一个真正的字段，所以它不会被模块级的 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.fields" target="_blank" rel="noopener"><code>fields()</code></a> 函数返回。仅初始化字段作为参数添加到生成的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法中，并传递给可选的 <code>__post_init__()</code> 方法。数据类不会使用它们。</p><p>例如，假设一个字段将从数据库初始化，如果在创建类时未提供其值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    i: int</span><br><span class="line">    j: int = <span class="literal">None</span></span><br><span class="line">    database: InitVar[DatabaseType] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__post_init__</span><span class="params">(self, database)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.j <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> database <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.j = database.lookup(<span class="string">'j'</span>)</span><br><span class="line"></span><br><span class="line">c = C(<span class="number">10</span>, database=my_database)</span><br></pre></td></tr></table></figure><p> 在这种情况下， <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.fields" target="_blank" rel="noopener"><code>fields()</code></a> 将返回 <code>i</code> 和 <code>j</code> 的 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.Field" target="_blank" rel="noopener"><code>Field</code></a> 对象，但不包括 <code>database</code>  。</p><h2 id="冻结的实例"><a href="#冻结的实例" class="headerlink" title="冻结的实例"></a>冻结的实例</h2><p>无法创建真正不可变的 Python 对象。但是，通过将 <code>frozen=True</code> 传递给 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 装饰器，你可以模拟不变性。在这种情况下，数据类将向类添加 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__setattr__" target="_blank" rel="noopener"><code>__setattr__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__delattr__" target="_blank" rel="noopener"><code>__delattr__()</code></a> 方法。 些方法在调用时会引发 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.FrozenInstanceError" target="_blank" rel="noopener"><code>FrozenInstanceError</code></a> 。</p><p>使用 <code>frozen=True</code> 时会有很小的性能损失： <code>__ init__()</code> 不能使用简单的赋值来初始化字段，并必须使用 <code>object.__ setattr__()</code> 。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p> 当数组由 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.dataclass" target="_blank" rel="noopener"><code>dataclass()</code></a> 装饰器创建时，它会查看反向 MRO 中的所有类的基类（即从 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 开始 ），并且对于它找到的每个数据类， 将该基类中的字段添加到字段的有序映射中。添加完所有基类字段后，它会将自己的字段添加到有序映射中。所有生成的方法都将使用这种组合的，计算的有序字段映射。由于字段是按插入顺序排列的，因此派生类会重载基类。一个例子: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@dataclass</span><br><span class="line">class Base:</span><br><span class="line">    x: Any = 15.0</span><br><span class="line">    y: int = 0</span><br><span class="line"></span><br><span class="line">@dataclass</span><br><span class="line">class C(Base):</span><br><span class="line">    z: int = 10</span><br><span class="line">    x: int = 15</span><br></pre></td></tr></table></figure><p>最后的字段列表依次是 <code>x</code> 、 <code>y</code> 、 <code>z</code> 。 <code>x</code> 的最终类型是 <code>int</code> ，如类 <code>C</code> 中所指定的那样。</p><p>为 <code>C</code> 生成的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法看起来像:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x: int = <span class="number">15</span>, y: int = <span class="number">0</span>, z: int = <span class="number">10</span>)</span>:</span></span><br></pre></td></tr></table></figure><h2 id="默认工厂函数"><a href="#默认工厂函数" class="headerlink" title="默认工厂函数"></a>默认工厂函数</h2><p> 如果一个 <a href="https://docs.python.org/zh-cn/3.8/library/dataclasses.html#dataclasses.field" target="_blank" rel="noopener"><code>field()</code></a> 指定了一个 <code>default_factory</code> ，当需要该字段的默认值时，将使用零参数调用它。例如，要创建列表的新实例，请使用: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mylist: list = field(default_factory=list)</span><br></pre></td></tr></table></figure><p> 如果一个字段被排除在 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 之外（使用 <code>init=False</code> ）并且字段也指定 <code>default_factory</code> ，则默认的工厂函数将始终从生成的 <code>__ init__()</code> 函数调用。发生这种情况是因为没有其他方法可以为字段提供初始值。 </p><h2 id="可变的默认值"><a href="#可变的默认值" class="headerlink" title="可变的默认值"></a>可变的默认值</h2><p> Python 在类属性中存储默认成员变量值。思考这个例子，不使用数据类: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    x = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, element)</span>:</span></span><br><span class="line">        self.x.append(element)</span><br><span class="line"></span><br><span class="line">o1 = C()</span><br><span class="line">o2 = C()</span><br><span class="line">o1.add(<span class="number">1</span>)</span><br><span class="line">o2.add(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">assert</span> o1.x == [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">assert</span> o1.x <span class="keyword">is</span> o2.x</span><br></pre></td></tr></table></figure><p>请注意，类 <code>C</code> 的两个实例共享相同的类变量 <code>x</code> ，如预期的那样。</p><p>使用数据类， <em>如果</em> 此代码有效:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span></span><br><span class="line">    x: List = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, element)</span>:</span></span><br><span class="line">        self.x += element</span><br></pre></td></tr></table></figure><p> 它生成的代码类似于: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span></span><br><span class="line">    x = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=x)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, element)</span>:</span></span><br><span class="line">        self.x += element</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> D().x <span class="keyword">is</span> D().x</span><br></pre></td></tr></table></figure><p>这与使用类 <code>C</code> 的原始示例具有相同的问题。也就是说，在创建类实例时没有为 <code>x</code> 指定值的类 <code>D</code> 的两个实例将共享相同的 <code>x</code> 副本。由于数据类只使用普通的 Python 类创建，因此它们也会共享此行为。数据类没有通用的方法来检测这种情况。相反，如果数据类检测到类型为 <code>list</code> 、 <code>dict</code> 或 <code>set</code> 的默认参数，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 。这是一个部分解决方案，但它可以防止许多常见错误。</p><p>使用默认工厂函数是一种创建可变类型新实例的方法，并将其作为字段的默认值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span></span><br><span class="line">    x: list = field(default_factory=list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> D().x <span class="keyword">is</span> <span class="keyword">not</span> D().x</span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><p><em>exception</em> <code>dataclasses.FrozenInstanceError</code> </p><p>在使用 <code>frozen=True</code> 定义的数据类上调用隐式定义的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__setattr__" target="_blank" rel="noopener"><code>__setattr__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__delattr__" target="_blank" rel="noopener"><code>__delattr__()</code></a> 时引发。 </p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们经常会遇到这样的情况:</p><p>比如我们设计一个商品类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id=None, author_id=None, category_id=None, brand_id=None, spu_id=None, </span></span></span><br><span class="line"><span class="function"><span class="params">                 title=None, item_id=None, n_comments=None, creation_time=None, update_time=None, </span></span></span><br><span class="line"><span class="function"><span class="params">                 source=<span class="string">''</span>, parent_id=<span class="number">0</span>, ancestor_id=<span class="number">0</span>)</span>:</span> </span><br><span class="line">        self.id = id</span><br><span class="line">        self.author_id = author_id</span><br><span class="line">        self.category_id = category_id</span><br><span class="line">        self.brand_id = brand_id</span><br><span class="line">        self.spu_id = spu_id</span><br><span class="line">        self.title = title</span><br><span class="line">        self.item_id = item_id</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p><code>__init__</code>方法包含了众多参数,</p><h3 id="应用一"><a href="#应用一" class="headerlink" title="应用一"></a>应用一</h3><p><strong>我们在打印的时候不希望打印所有的参数</strong></p><p>通常的做法是,重写<code>__repr__</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(id=&#123;&#125;, author_id=&#123;&#125;, category_id=&#123;&#125;, brand_id=&#123;&#125;)'</span>.format(</span><br><span class="line">        self.__class__.__name__, self.id, self.author_id, self.category_id, </span><br><span class="line">        self.brand_id)</span><br><span class="line"><span class="comment">#对象打印</span></span><br><span class="line">p = Product()</span><br><span class="line">print(p)   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Product(id=<span class="number">1</span>, author_id=<span class="number">100001</span>, category_id=<span class="number">2003</span>, brand_id=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>问题来了,我需要在每个类里重写这个方法,那该怎么处理？</p><h3 id="应用二"><a href="#应用二" class="headerlink" title="应用二"></a>应用二</h3><p> <strong>对象比较</strong>，有时候需要判断2个对象是否相等甚至大小（例如用于展示顺序） </p><p>通常的做法是 重写对应的<code>__eq__</code>,<code>__lt__</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(other, self.__class__):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    <span class="keyword">return</span> (self.id, self.author_id, self.category_id, self.brand_id) == (</span><br><span class="line">        other.id, other.author_id, other.category_id, other.brand_id)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(other, self.__class__):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    <span class="keyword">return</span> (self.id, self.author_id, self.category_id, self.brand_id) &lt; (</span><br><span class="line">        other.id, other.author_id, other.category_id, other.brand_id)</span><br></pre></td></tr></table></figure><h3 id="应用三"><a href="#应用三" class="headerlink" title="应用三"></a>应用三</h3><p><strong>对象去重</strong>,重写<code>__hash__</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hash((self.id, self.author_id, self.category_id, self.brand_id))</span><br></pre></td></tr></table></figure><h3 id="应用四"><a href="#应用四" class="headerlink" title="应用四"></a>应用四</h3><p><strong>导出字典格式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'id'</span>: self.id,</span><br><span class="line">        <span class="string">'author_id'</span>: self.author_id,</span><br><span class="line">        <span class="string">'category_id'</span>: self.category_id,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是我并不想打印所有的属性,于是有下面的做法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span></span><br><span class="line">    self._a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> vars(self)</span><br></pre></td></tr></table></figure><p>等等,python难道没有解决方案。</p><p>答案是肯定的,当然有,那就是<code>dataclasses</code></p><h3 id="用dataclasses解决上面的问题"><a href="#用dataclasses解决上面的问题" class="headerlink" title="用dataclasses解决上面的问题"></a>用<code>dataclasses</code>解决上面的问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass(unsafe_hash=True, order=True)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(object)</span>:</span></span><br><span class="line">    id: int</span><br><span class="line">    author_id: int</span><br><span class="line">    brand_id: int</span><br><span class="line">    spu_id: int</span><br><span class="line">    title: str = field(hash=<span class="literal">False</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>)</span><br><span class="line">    item_id: int = field(hash=<span class="literal">False</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>)</span><br><span class="line">    n_comments: int = field(hash=<span class="literal">False</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>)</span><br><span class="line">    creation_time: datetime = field(default=<span class="literal">None</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>,hash=<span class="literal">False</span>)</span><br><span class="line">    update_time: datetime = field(default=<span class="literal">None</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>, hash=<span class="literal">False</span>)</span><br><span class="line">    source: str = field(default=<span class="string">''</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>, hash=<span class="literal">False</span>)</span><br><span class="line">    parent_id: int = field(default=<span class="number">0</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>, hash=<span class="literal">False</span>)</span><br><span class="line">    ancestor_id: int = field(default=<span class="number">0</span>, repr=<span class="literal">False</span>, compare=<span class="literal">False</span>, hash=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Product(<span class="number">1</span>, <span class="number">100001</span>, <span class="number">2003</span>, <span class="number">20</span>, <span class="number">1002393002</span>, <span class="string">'这是一个测试商品1'</span>, <span class="number">2000001</span>, <span class="number">100</span>, <span class="literal">None</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p2 = Product(<span class="number">1</span>, <span class="number">100001</span>, <span class="number">2003</span>, <span class="number">20</span>, <span class="number">1002393002</span>, <span class="string">'这是一个测试商品2'</span>, <span class="number">2000001</span>, <span class="number">100</span>, <span class="literal">None</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p3 = Product(<span class="number">3</span>, <span class="number">100001</span>, <span class="number">2003</span>, <span class="number">20</span>, <span class="number">1002393002</span>, <span class="string">'这是一个测试商品3'</span>, <span class="number">2000001</span>, <span class="number">100</span>, <span class="literal">None</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">print(p1)</span><br><span class="line"></span><br><span class="line">print(p1 == p2)</span><br><span class="line"></span><br><span class="line">print(p1 &gt; p2)</span><br><span class="line"></span><br><span class="line">print(&#123;p1, p2, p3&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> asdict</span><br><span class="line">asdict(p1)</span><br></pre></td></tr></table></figure><p>想了解更多的使用方法,强烈建议阅读源码。</p><p>最后,希望武汉的兄弟们能保护好自己,健康才是最重要的。加油!!!</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-dataclasses&quot;&gt;&lt;a href=&quot;#python-标准库-dataclasses&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 dataclasses&quot;&gt;&lt;/a&gt;python 标准库 dataclasses&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://img.zcool.cn/community/01b9205e2af974a8012165188cc6ad.jpg@1280w_1l_2o_100sh.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="dataclasses" scheme="https://pinghailinfeng.gitee.io/tags/dataclasses/"/>
    
  </entry>
  
  <entry>
    <title>python standard library bisect</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/24/python-standard-library-bisect/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/24/python-standard-library-bisect/</id>
    <published>2020-01-24T01:48:18.000Z</published>
    <updated>2020-01-30T08:43:58.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-bisect-二分查找"><a href="#python-标准库-bisect-二分查找" class="headerlink" title="python 标准库 bisect 二分查找"></a>python 标准库 bisect 二分查找</h1><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20200122/b1c38585d3a8429eaf0fee473dbcae7e.jpeg" alt></p><a id="more"></a><h2 id="何谓二分查找"><a href="#何谓二分查找" class="headerlink" title="何谓二分查找"></a>何谓二分查找</h2><p><img src="https://img-blog.csdn.net/20150821221951219" alt></p><h2 id="对比顺序查找"><a href="#对比顺序查找" class="headerlink" title="对比顺序查找"></a>对比顺序查找</h2><p><img src="http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/53%E9%80%92%E5%BD%92-%E4%BA%8C%E5%88%8623.gif" alt></p><p>通常我们实现二分查找是酱紫的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(li,find)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(li)<span class="number">-1</span> <span class="comment">## 需要减一否则会下标越界</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        middle = (low + high) /<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[middle] ==  find :</span><br><span class="line">            <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">elif</span> li[middle] &gt; find:</span><br><span class="line">            high = middle - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> li[middle] &lt; find:</span><br><span class="line">            low = middle + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    li = [x <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>,<span class="number">101</span>)]</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">102</span>):</span><br><span class="line">        <span class="keyword">print</span> binary_search(li,x)</span><br></pre></td></tr></table></figure><p>python标准库中已经实现了二分查找。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p> <strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/bisect.py" target="_blank" rel="noopener">Lib/bisect.py</a> </p><p> 这个模块对有序列表提供了支持，使得他们可以在插入新数据仍然保持有序。对于长列表，如果其包含元素的比较操作十分昂贵的话，这可以是对更常见方法的改进。这个模块叫做 <a href="https://docs.python.org/zh-cn/3.8/library/bisect.html#module-bisect" target="_blank" rel="noopener"><code>bisect</code></a> 因为其使用了基本的二分（bisection）算法。源代码也可以作为很棒的算法示例（边界判断也做好啦！） </p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><code>bisect.bisect_left</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>) </li></ul><p>在 <em>a</em> 中找到 <em>x</em> 合适的插入点以维持有序。参数 <em>lo</em> 和 <em>hi</em> 可以被用于确定需要考虑的子集；默认情况下整个列表都会被使用。如果 <em>x</em> 已经在 <em>a</em> 里存在，那么插入点会在已存在元素之前（也就是左边）。如果 <em>a</em> 是列表（list）的话，返回值是可以被放在 <code>list.insert()</code> 的第一个参数的。</p><p>返回的插入点 <em>i</em> 可以将数组 <em>a</em> 分成两部分。左侧是 <code>all(val &lt; x for val in a[lo:i])</code> ，右侧是 <code>all(val &gt;= x for val in a[i:hi])</code> 。</p><ul><li><p><code>bisect.bisect_right</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>) </p></li><li><p><code>bisect.bisect</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>) </p><p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/bisect.html#bisect.bisect_left" target="_blank" rel="noopener"><code>bisect_left()</code></a>，但是返回的插入点是 <em>a</em> 中已存在元素 <em>x</em> 的右侧。</p><p>返回的插入点 <em>i</em> 可以将数组 <em>a</em> 分成两部分。左侧是 <code>all(val &lt;= x for val in a[lo:i])</code>，右侧是 <code>all(val &gt; x for val in a[i:hi])</code> for the right side。</p></li><li><p><code>bisect.insort_left</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>) </p><p>将 <em>x</em> 插入到一个有序序列 <em>a</em> 里，并维持其有序。如果 <em>a</em> 有序的话，这相当于 <code>a.insert(bisect.bisect_left(a, x, lo, hi), x)</code>。要注意搜索是 O(log n) 的，插入却是 O(n) 的。 </p></li><li><p><code>bisect.insort_right</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>) </p></li><li><p><code>bisect.insort</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>) </p><p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/bisect.html#bisect.insort_left" target="_blank" rel="noopener"><code>insort_left()</code></a>，但是把 <em>x</em> 插入到 <em>a</em> 中已存在元素 <em>x</em> 的右侧。 </p><blockquote><p> <a href="https://code.activestate.com/recipes/577197-sortedcollection/" target="_blank" rel="noopener">SortedCollection recipe</a> 使用 bisect 构造了一个功能完整的集合类，提供了直接的搜索方法和对用于搜索的 key 方法的支持。所有用于搜索的键都是预先计算的，以避免在搜索时对 key 方法的不必要调用。</p></blockquote></li></ul><h2 id="搜索有序列表"><a href="#搜索有序列表" class="headerlink" title="搜索有序列表"></a>搜索有序列表</h2><p> 上面的 <a href="https://docs.python.org/zh-cn/3.8/library/bisect.html#module-bisect" target="_blank" rel="noopener"><code>bisect()</code></a> 函数对于找到插入点是有用的，但在一般的搜索任务中可能会有点尴尬。下面 5 个函数展示了如何将其转变成有序列表中的标准查找函数 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'Locate the leftmost value exactly equal to x'</span></span><br><span class="line">    i = bisect_left(a, x)</span><br><span class="line">    <span class="keyword">if</span> i != len(a) <span class="keyword">and</span> a[i] == x:</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_lt</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'Find rightmost value less than x'</span></span><br><span class="line">    i = bisect_left(a, x)</span><br><span class="line">    <span class="keyword">if</span> i:</span><br><span class="line">        <span class="keyword">return</span> a[i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_le</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'Find rightmost value less than or equal to x'</span></span><br><span class="line">    i = bisect_right(a, x)</span><br><span class="line">    <span class="keyword">if</span> i:</span><br><span class="line">        <span class="keyword">return</span> a[i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_gt</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'Find leftmost value greater than x'</span></span><br><span class="line">    i = bisect_right(a, x)</span><br><span class="line">    <span class="keyword">if</span> i != len(a):</span><br><span class="line">        <span class="keyword">return</span> a[i]</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_ge</span><span class="params">(a, x)</span>:</span></span><br><span class="line">    <span class="string">'Find leftmost item greater than or equal to x'</span></span><br><span class="line">    i = bisect_left(a, x)</span><br><span class="line">    <span class="keyword">if</span> i != len(a):</span><br><span class="line">        <span class="keyword">return</span> a[i]</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br></pre></td></tr></table></figure><h2 id="其他示例"><a href="#其他示例" class="headerlink" title="其他示例"></a>其他示例</h2><p> 函数 <a href="https://docs.python.org/zh-cn/3.8/library/bisect.html#module-bisect" target="_blank" rel="noopener"><code>bisect()</code></a> 还可以用于数字表查询。这个例子是使用 <a href="https://docs.python.org/zh-cn/3.8/library/bisect.html#module-bisect" target="_blank" rel="noopener"><code>bisect()</code></a> 从一个给定的考试成绩集合里，通过一个有序数字表，查出其对应的字母等级：90 分及以上是 ‘A’，80 到 89 是 ‘B’，以此类推 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(score, breakpoints=[<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>], grades=<span class="string">'FDCBA'</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    i = bisect(breakpoints, score)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> grades[i]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[grade(score) <span class="keyword">for</span> score <span class="keyword">in</span> [<span class="number">33</span>, <span class="number">99</span>, <span class="number">77</span>, <span class="number">70</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">100</span>]]</span><br><span class="line">[<span class="string">'F'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'A'</span>]</span><br></pre></td></tr></table></figure><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> 函数不同，对于 <a href="https://docs.python.org/zh-cn/3.8/library/bisect.html#module-bisect" target="_blank" rel="noopener"><code>bisect()</code></a> 函数来说，<em>key</em> 或者 <em>reversed</em> 参数并没有什么意义。因为这会导致设计效率低下（连续调用 bisect 函数时，是不会 “记住” 过去查找过的键的）。</p><p>正相反，最好去搜索预先计算好的键列表，来查找相关记录的索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [(<span class="string">'red'</span>, <span class="number">5</span>), (<span class="string">'blue'</span>, <span class="number">1</span>), (<span class="string">'yellow'</span>, <span class="number">8</span>), (<span class="string">'black'</span>, <span class="number">0</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.sort(key=<span class="keyword">lambda</span> r: r[<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keys = [r[<span class="number">1</span>] <span class="keyword">for</span> r <span class="keyword">in</span> data]         <span class="comment"># precomputed list of keys</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[bisect_left(keys, <span class="number">0</span>)]</span><br><span class="line">(<span class="string">'black'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[bisect_left(keys, <span class="number">1</span>)]</span><br><span class="line">(<span class="string">'blue'</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[bisect_left(keys, <span class="number">5</span>)]</span><br><span class="line">(<span class="string">'red'</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[bisect_left(keys, <span class="number">8</span>)]</span><br><span class="line">(<span class="string">'yellow'</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-bisect-二分查找&quot;&gt;&lt;a href=&quot;#python-标准库-bisect-二分查找&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 bisect 二分查找&quot;&gt;&lt;/a&gt;python 标准库 bisect 二分查找&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://5b0988e595225.cdn.sohucs.com/images/20200122/b1c38585d3a8429eaf0fee473dbcae7e.jpeg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="bisect" scheme="https://pinghailinfeng.gitee.io/tags/bisect/"/>
    
  </entry>
  
  <entry>
    <title>python standard library timeit</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/23/python-standard-library-timeit/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/23/python-standard-library-timeit/</id>
    <published>2020-01-23T00:55:19.000Z</published>
    <updated>2020-01-30T08:43:58.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-timeit"><a href="#python-标准库-timeit" class="headerlink" title="python 标准库 timeit"></a>python 标准库 timeit</h1><p>每日一词:</p><blockquote><p>Pneumonia </p><p>n 肺炎</p><p> 2019 Novel coronavirus    (2019-nCoV)， 世界卫生组织定义, 又名<strong>武汉冠状病毒</strong>（Wuhan coronavirus）、<strong>武汉肺炎</strong>（Wuhan pneumonia） </p><p> <strong>冠状病毒属</strong>的病毒是具外套膜（envelope） </p><p>例句:</p><p> The doctor diagnosed the illness as pneumonia .<br>医生诊断这病为肺炎。 </p><p> The doctor has cured her of pneumonia .<br>大夫把她的肺炎看好了。 </p><p> Fatalities usually come from pneumonia .<br>通常肺炎可引起死亡。 </p></blockquote><p><img src="http://mmbiz.qpic.cn/sz_mmbiz_png/lgiauavhKmWSjlr6p2MHyib92PkOQBJRp7iaonfnG9p30Sg8P5Eb7VVluibibXVUcXIkqwF0rcsQgqzJjvD8rw8FXiaQ/640?wx_fmt=png" alt></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/MERS-CoV_electron_micrograph1.jpg/220px-MERS-CoV_electron_micrograph1.jpg" alt></p><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/timeit.py" target="_blank" rel="noopener">Lib/timeit.py</a> </p><p> 该模块提供了一种简单的方法来计算一小段 Python 代码的耗时。它有 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#timeit-command-line-interface" target="_blank" rel="noopener">命令行界面</a> 以及一个 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#python-interface" target="_blank" rel="noopener">可调用</a> 方法。它避免了许多用于测量执行时间的常见陷阱。另见 Tim Peters 对 O’Reilly 出版的 <em>Python Cookbook</em> 中“算法”章节的介绍。 </p><h2 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h2><p> 以下示例显示了如何使用 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#timeit-command-line-interface" target="_blank" rel="noopener">命令行界面</a> 来比较三个不同的表达式： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m timeit <span class="string">'"-".join(str(n) for n in range(100))'</span></span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">5</span>: <span class="number">30.2</span> usec per loop</span><br><span class="line">$ python3 -m timeit <span class="string">'"-".join([str(n) for n in range(100)])'</span></span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">5</span>: <span class="number">27.5</span> usec per loop</span><br><span class="line">$ python3 -m timeit <span class="string">'"-".join(map(str, range(100)))'</span></span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">5</span>: <span class="number">23.2</span> usec per loop</span><br></pre></td></tr></table></figure><p> 这可以通过 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#python-interface" target="_blank" rel="noopener">Python 接口</a> 实现 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="string">'"-".join(str(n) for n in range(100))'</span>, number=<span class="number">10000</span>)</span><br><span class="line"><span class="number">0.3018611848820001</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="string">'"-".join([str(n) for n in range(100)])'</span>, number=<span class="number">10000</span>)</span><br><span class="line"><span class="number">0.2727368790656328</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="string">'"-".join(map(str, range(100)))'</span>, number=<span class="number">10000</span>)</span><br><span class="line"><span class="number">0.23702679807320237</span></span><br></pre></td></tr></table></figure><p> 从 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#python-interface" target="_blank" rel="noopener">Python 接口</a> 还可以传出一个可调用对象: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="keyword">lambda</span>: <span class="string">"-"</span>.join(map(str, range(<span class="number">100</span>))), number=<span class="number">10000</span>)</span><br><span class="line"><span class="number">0.19665591977536678</span></span><br></pre></td></tr></table></figure><p> 但请注意 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#timeit.timeit" target="_blank" rel="noopener"><code>timeit()</code></a> 仅在使用命令行界面时会自动确定重复次数。 在 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#timeit-examples" target="_blank" rel="noopener">示例</a> 一节你可以找到更多的进阶示例。 </p><h2 id="python接口"><a href="#python接口" class="headerlink" title="python接口"></a>python接口</h2><p> 该模块定义了三个便利函数和一个公共类： </p><ul><li><code>timeit.timeit</code>(<em>stmt=’pass’</em>, <em>setup=’pass’</em>, <em>timer=</em>, <em>number=1000000</em>, <em>globals=None</em>) </li><li><code>timeit.repeat</code>(<em>stmt=’pass’</em>, <em>setup=’pass’</em>, <em>timer=</em>, <em>repeat=5</em>, <em>number=1000000</em>, <em>globals=None</em>) </li><li><code>timeit.default_timer</code>() </li><li><em>class</em> <code>timeit.Timer</code>(<em>stmt=’pass’</em>, <em>setup=’pass’</em>, <em>timer=</em>, <em>globals=None</em>) <ul><li><code>timeit</code>(<em>number=1000000</em>) </li><li><code>autorange</code>(<em>callback=None</em>) </li><li><code>repeat</code>(<em>repeat=5</em>, <em>number=1000000</em>) </li><li><code>print_exc</code>(<em>file=None</em>) </li></ul></li></ul><h2 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h2><p> 从命令行调用程序时，使用以下表单: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m timeit [-n N] [-r N] [-u U] [-s S] [-h] [statement ...]</span><br></pre></td></tr></table></figure><p>如果了解以下选项：</p><ul><li><p><code>-n N, --number=N</code></p><p>执行 ‘语句’ 多少次</p></li><li><p><code>-r N, --repeat=N</code></p><p>重复计时器的次数（默认为5）</p></li><li><p><code>-s S, --setup=S</code></p><p>最初要执行一次的语句（默认为 <code>pass</code> ）</p></li><li><p>`-p, –process<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  测量进程时间，而不是 wallclock 时间，使用 [`time.process_time()`](https://docs.python.org/zh-cn/3.8/library/time.html#time.process_time) 而不是 [`time.perf_counter()`](https://docs.python.org/zh-cn/3.8/library/time.html#time.perf_counter) ，这是默认值*3.3 新版功能.*</span><br><span class="line"></span><br><span class="line">- `-u````, ``--unit``=U`</span><br><span class="line"></span><br><span class="line">  指定定时器输出的时间单位；可以选择 nsec，usec，msec或sec*3.5 新版功能.*</span><br><span class="line"></span><br><span class="line">- `-v````, ``--verbose</span><br></pre></td></tr></table></figure></p><p>打印原始计时结果；重复更多位数精度</p></li><li><p><code>-h```</code>, <code>--help`</code></p><p>打印一条简短的使用信息并退出</p></li></ul><p>可以通过将每一行指定为单独的语句参数来给出多行语句；通过在引号中包含参数并使用前导空格可以缩进行。多个 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#cmdoption-timeit-s" target="_blank" rel="noopener"><code>-s</code></a> 选项的处理方式相似。</p><p>如果 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#cmdoption-timeit-n" target="_blank" rel="noopener"><code>-n</code></a> 未给出，则通过尝试10的连续幂次来计算合适数量的循环，直到总时间至少为 0.2 秒。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#timeit.default_timer" target="_blank" rel="noopener"><code>default_timer()</code></a> 测量可能受到在同一台机器上运行的其他程序的影响，因此在需要精确计时时最好的做法是重复几次计时并使用最佳时间。 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#cmdoption-timeit-r" target="_blank" rel="noopener"><code>-r</code></a> 选项对此有利；在大多数情况下，默认的 5 次重复可能就足够了。 你可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#time.process_time" target="_blank" rel="noopener"><code>time.process_time()</code></a> 来测量CPU时间。</p><blockquote><p>执行 pass 语句会产生一定的基线开销。这里的代码不会试图隐藏它，但你应该知道它。可以通过不带参数调用程序来测量基线开销，并且Python版本之间可能会有所不同。</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p> 可以提供一个在开头只执行一次的 setup 语句： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python -m timeit -s <span class="string">'text = "sample string"; char = "g"'</span>  <span class="string">'char in text'</span></span><br><span class="line"><span class="number">5000000</span> loops, best of <span class="number">5</span>: <span class="number">0.0877</span> usec per loop</span><br><span class="line">$ python -m timeit -s <span class="string">'text = "sample string"; char = "g"'</span>  <span class="string">'text.find(char)'</span></span><br><span class="line"><span class="number">1000000</span> loops, best of <span class="number">5</span>: <span class="number">0.342</span> usec per loop</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="string">'char in text'</span>, setup=<span class="string">'text = "sample string"; char = "g"'</span>)</span><br><span class="line"><span class="number">0.41440500499993504</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="string">'text.find(char)'</span>, setup=<span class="string">'text = "sample string"; char = "g"'</span>)</span><br><span class="line"><span class="number">1.7246671520006203</span></span><br></pre></td></tr></table></figure><p> 使用 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#timeit.Timer" target="_blank" rel="noopener"><code>Timer</code></a> 类及其方法可以完成同样的操作: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = timeit.Timer(<span class="string">'char in text'</span>, setup=<span class="string">'text = "sample string"; char = "g"'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.timeit()</span><br><span class="line"><span class="number">0.3955516149999312</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.repeat()</span><br><span class="line">[<span class="number">0.40183617287970225</span>, <span class="number">0.37027556854118704</span>, <span class="number">0.38344867356679524</span>, <span class="number">0.3712595970846668</span>, <span class="number">0.37866875250654886</span>]</span><br></pre></td></tr></table></figure><p> 以下示例显示如何计算包含多行的表达式。 在这里我们对比使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#hasattr" target="_blank" rel="noopener"><code>hasattr()</code></a> 与 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a>/<a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 的开销来测试缺失与提供对象属性: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python -m timeit <span class="string">'try:'</span> <span class="string">'  str.__bool__'</span> <span class="string">'except AttributeError:'</span> <span class="string">'  pass'</span></span><br><span class="line"><span class="number">20000</span> loops, best of <span class="number">5</span>: <span class="number">15.7</span> usec per loop</span><br><span class="line">$ python -m timeit <span class="string">'if hasattr(str, "__bool__"): pass'</span></span><br><span class="line"><span class="number">50000</span> loops, best of <span class="number">5</span>: <span class="number">4.26</span> usec per loop</span><br><span class="line"></span><br><span class="line">$ python -m timeit <span class="string">'try:'</span> <span class="string">'  int.__bool__'</span> <span class="string">'except AttributeError:'</span> <span class="string">'  pass'</span></span><br><span class="line"><span class="number">200000</span> loops, best of <span class="number">5</span>: <span class="number">1.43</span> usec per loop</span><br><span class="line">$ python -m timeit <span class="string">'if hasattr(int, "__bool__"): pass'</span></span><br><span class="line"><span class="number">100000</span> loops, best of <span class="number">5</span>: <span class="number">2.23</span> usec per loop</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># attribute is missing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"""\</span></span><br><span class="line"><span class="string"><span class="meta">... </span>try:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    str.__bool__</span></span><br><span class="line"><span class="string"><span class="meta">... </span>except AttributeError:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    pass</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(stmt=s, number=<span class="number">100000</span>)</span><br><span class="line"><span class="number">0.9138244460009446</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"if hasattr(str, '__bool__'): pass"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(stmt=s, number=<span class="number">100000</span>)</span><br><span class="line"><span class="number">0.5829014980008651</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># attribute is present</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"""\</span></span><br><span class="line"><span class="string"><span class="meta">... </span>try:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    int.__bool__</span></span><br><span class="line"><span class="string"><span class="meta">... </span>except AttributeError:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    pass</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(stmt=s, number=<span class="number">100000</span>)</span><br><span class="line"><span class="number">0.04215312199994514</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"if hasattr(int, '__bool__'): pass"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit.timeit(stmt=s, number=<span class="number">100000</span>)</span><br><span class="line"><span class="number">0.08588060699912603</span></span><br></pre></td></tr></table></figure><p> 要让 <a href="https://docs.python.org/zh-cn/3.8/library/timeit.html#module-timeit" target="_blank" rel="noopener"><code>timeit</code></a> 模块访问你定义的函数，你可以传递一个包含 import 语句的 <em>setup</em> 参数: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Stupid test function"""</span></span><br><span class="line">    L = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> timeit</span><br><span class="line">    print(timeit.timeit(<span class="string">"test()"</span>, setup=<span class="string">"from __main__ import test"</span>))</span><br></pre></td></tr></table></figure><p> 另一种选择是将 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#globals" target="_blank" rel="noopener"><code>globals()</code></a> 传递给 <em>globals</em> 参数，这将导致代码在当前的全局命名空间中执行。这比单独指定 import 更方便 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line">print(timeit.timeit(<span class="string">'[func(42) for func in (f,g,h)]'</span>, globals=globals()))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-timeit&quot;&gt;&lt;a href=&quot;#python-标准库-timeit&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 timeit&quot;&gt;&lt;/a&gt;python 标准库 timeit&lt;/h1&gt;&lt;p&gt;每日一词:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pneumonia &lt;/p&gt;
&lt;p&gt;n 肺炎&lt;/p&gt;
&lt;p&gt; 2019 Novel coronavirus    (2019-nCoV)， 世界卫生组织定义, 又名&lt;strong&gt;武汉冠状病毒&lt;/strong&gt;（Wuhan coronavirus）、&lt;strong&gt;武汉肺炎&lt;/strong&gt;（Wuhan pneumonia） &lt;/p&gt;
&lt;p&gt; &lt;strong&gt;冠状病毒属&lt;/strong&gt;的病毒是具外套膜（envelope） &lt;/p&gt;
&lt;p&gt;例句:&lt;/p&gt;
&lt;p&gt; The doctor diagnosed the illness as pneumonia .&lt;br&gt;医生诊断这病为肺炎。 &lt;/p&gt;
&lt;p&gt; The doctor has cured her of pneumonia .&lt;br&gt;大夫把她的肺炎看好了。 &lt;/p&gt;
&lt;p&gt; Fatalities usually come from pneumonia .&lt;br&gt;通常肺炎可引起死亡。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/lgiauavhKmWSjlr6p2MHyib92PkOQBJRp7iaonfnG9p30Sg8P5Eb7VVluibibXVUcXIkqwF0rcsQgqzJjvD8rw8FXiaQ/640?wx_fmt=png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/MERS-CoV_electron_micrograph1.jpg/220px-MERS-CoV_electron_micrograph1.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="timeit" scheme="https://pinghailinfeng.gitee.io/tags/timeit/"/>
    
  </entry>
  
  <entry>
    <title>python standard library filecmp</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/22/python-standard-library-filecmp/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/22/python-standard-library-filecmp/</id>
    <published>2020-01-22T00:07:01.000Z</published>
    <updated>2020-01-30T08:43:58.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-filecmp"><a href="#python-标准库-filecmp" class="headerlink" title="python 标准库 filecmp"></a>python 标准库 filecmp</h1><p>每日一词:</p><blockquote><p>病毒</p><p> germs、bacteria 還是 viruses </p><h3 id="Germ-微生物"><a href="#Germ-微生物" class="headerlink" title="Germ: 微生物"></a><strong>Germ</strong>: 微生物</h3><h3 id="Bacterium-這是「細菌」的意思，它是微小且單細胞的有機體。注意喔這個字的單數是-bacterium，複數要寫作-bacteria"><a href="#Bacterium-這是「細菌」的意思，它是微小且單細胞的有機體。注意喔這個字的單數是-bacterium，複數要寫作-bacteria" class="headerlink" title="Bacterium: 這是「細菌」的意思，它是微小且單細胞的有機體。注意喔這個字的單數是 bacterium，複數要寫作 bacteria"></a><strong>Bacterium</strong>: 這是「細菌」的意思，它是微小且單細胞的有機體。注意喔這個字的單數是 bacterium，複數要寫作 bacteria</h3><h3 id="Virus-病菌"><a href="#Virus-病菌" class="headerlink" title="Virus:病菌"></a><strong>Virus</strong>:病菌</h3><p> 茲卡病毒（Zika virus）、諾羅病毒（Norovirus）、愛滋病毒（Human Immunodeficiency Virus，縮寫即是 HIV）、輪狀病毒（Rotavirus）等。 </p></blockquote><p><img src="http://a1.att.hudong.com/20/29/01300000333999124281293520625.jpg" alt></p><a id="more"></a><p>继续学习关于文件操作的模块 filecmp</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p> <strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/filecmp.py" target="_blank" rel="noopener">Lib/filecmp.py</a> </p><p> <a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#module-filecmp" target="_blank" rel="noopener"><code>filecmp</code></a> 模块定义了用于比较文件及目录的函数，并且可以选取多种关于时间和准确性的折衷方案。对于文件的比较，另见 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#module-difflib" target="_blank" rel="noopener"><code>difflib</code></a> 模块。 </p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p> <a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#module-filecmp" target="_blank" rel="noopener"><code>filecmp</code></a> 模块定义了如下函数： </p><ul><li><code>filecmp.`</code>cmp`(<em>f1</em>, <em>f2</em>, <em>shallow=True</em>) </li><li><code>filecmp.`</code>cmpfiles`(<em>dir1</em>, <em>dir2</em>, <em>common</em>, <em>shallow=True</em>) </li><li><code>filecmp.`</code>clear_cache`() </li></ul><h2 id="dircmp-类"><a href="#dircmp-类" class="headerlink" title="dircmp 类"></a><a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.dircmp" target="_blank" rel="noopener"><code>dircmp</code></a> 类</h2><p> <em>class</em> <code>filecmp.`</code>dircmp`(<em>a</em>, <em>b</em>, <em>ignore=None</em>, <em>hide=None</em>) </p><p>创建一个用于比较目录 <em>a</em> 和 <em>b</em> 的新的目录比较对象。 <em>ignore</em> 是需要忽略的文件名列表，且默认为 <a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.DEFAULT_IGNORES" target="_blank" rel="noopener"><code>filecmp.DEFAULT_IGNORES</code></a> 。 <em>hide</em> 是需要隐藏的文件名列表，且默认为 <code>[os.curdir, os.pardir]</code> 。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.dircmp" target="_blank" rel="noopener"><code>dircmp</code></a> 类如 <a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.cmp" target="_blank" rel="noopener"><code>filecmp.cmp()</code></a> 中所描述的那样对文件进行 <em>shallow</em> 比较。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.dircmp" target="_blank" rel="noopener"><code>dircmp</code></a> 类提供以下方法：</p><ul><li><p><code>report</code>()</p><p>将 <em>a</em> 与 <em>b</em> 之间的比较打印（到 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdout" target="_blank" rel="noopener"><code>sys.stdout</code></a> ）。</p></li><li><p><code>report_partial_closure</code>()</p><p>打印 <em>a</em> 与 <em>b</em> 及共同直接子目录的比较结果。</p></li><li><p><code>report_full_closure</code>()</p><p>打印 <em>a</em> 与 <em>b</em> 及共同子目录比较结果（递归地）。</p></li></ul><p><a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.dircmp" target="_blank" rel="noopener"><code>dircmp</code></a> 类提供了一些有趣的属性，用以得到关于参与比较的目录树的各种信息。</p><p>需要注意，通过 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getattr__" target="_blank" rel="noopener"><code>__getattr__()</code></a> 钩子，所有的属性将会惰性求值，因此如果只使用那些计算简便的属性，将不会有速度损失。</p><ul><li><p><code>left</code></p><p>目录 <em>a</em> 。</p></li><li><p><code>right</code></p><p>目录 <em>b</em> 。</p></li><li><p><code>left_list</code></p><p>经 <em>hide</em> 和 <em>ignore</em> 过滤，目录 <em>a</em> 中的文件与子目录。</p></li><li><p><code>right_list</code></p><p>经 <em>hide</em> 和 <em>ignore</em> 过滤，目录 <em>b</em> 中的文件与子目录。</p></li><li><p><code>common</code></p><p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的文件和子目录。</p></li><li><p><code>left_only</code></p><p>仅在目录 <em>a</em> 中的文件和子目录。</p></li><li><p><code>right_only</code></p><p>仅在目录 <em>b</em> 中的文件和子目录。</p></li><li><p><code>common_dirs</code></p><p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的子目录。</p></li><li><p><code>common_files</code></p><p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的文件。</p></li><li><p><code>common_funny</code></p><p>在目录 <em>a</em> 和 <em>b</em> 中类型不同的名字，或者那些 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 报告错误的名字。</p></li><li><p><code>same_files</code></p><p>在目录 <em>a</em> 和 <em>b</em> 中使用类的文件比较操作符相等的文件。</p></li><li><p><code>diff_files</code></p><p>在目录 <em>a</em> 和 <em>b</em> 中，根据类的文件比较操作符判定内容不等的文件。</p></li><li><p><code>funny_files</code></p><p>在目录 <em>a</em> 和 <em>b</em> 中无法比较的文件。</p></li><li><p><code>subdirs</code></p><p>一个将 <a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.dircmp.common_dirs" target="_blank" rel="noopener"><code>common_dirs</code></a> 中名称映射为 <a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#filecmp.dircmp" target="_blank" rel="noopener"><code>dircmp</code></a> 对象的字典。</p></li></ul><p><code>filecmp.`</code>DEFAULT_IGNORES` </p><p>下面是一个简单的例子，使用 <code>subdirs</code> 属性递归搜索两个目录以显示公共差异文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> filecmp <span class="keyword">import</span> dircmp</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_diff_files</span><span class="params">(dcmp)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> name <span class="keyword">in</span> dcmp.diff_files:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"diff_file %s found in %s and %s"</span> % (name, dcmp.left,</span><br><span class="line"><span class="meta">... </span>              dcmp.right))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> sub_dcmp <span class="keyword">in</span> dcmp.subdirs.values():</span><br><span class="line"><span class="meta">... </span>        print_diff_files(sub_dcmp)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dcmp = dircmp(<span class="string">'dir1'</span>, <span class="string">'dir2'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_diff_files(dcmp)</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> os,sys</span><br><span class="line"><span class="keyword">import</span> filecmp</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    校验源与备份目录的差异</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line">holderlist = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compareme</span><span class="params">(dir1,dir2)</span>:</span>    <span class="comment">#递归获取更新项函数</span></span><br><span class="line">    dircomp = filecmp.dircmp(dir1,dir2)</span><br><span class="line">    only_in_one = dircomp.left_only      <span class="comment">#源目录新文件或目录 </span></span><br><span class="line">    diff_in_one = dircomp.diff_files     <span class="comment">#不匹配文件，源目录文件已发生变化</span></span><br><span class="line">    dirpath = os.path.abspath(dir1)      <span class="comment">#定义源目录绝对路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#将更新文件或目录追加到holderlist</span></span><br><span class="line">    [ holderlist.append(os.path.abspath(os.path.join(dir1,x))) <span class="keyword">for</span> x <span class="keyword">in</span> only_in_one ]</span><br><span class="line">    [ holderlist.append(os.path.abspath(os.path.join(dir1,x))) <span class="keyword">for</span> x <span class="keyword">in</span> diff_in_one ]</span><br><span class="line">    <span class="keyword">if</span> len(dircomp.common_dirs) &gt; <span class="number">0</span>:  <span class="comment">#判断是否存在相同子目录，以便递归</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> dircomp.common_dirs:   <span class="comment">#递归子目录</span></span><br><span class="line">            compareme(os.path.abspath(os.path.join(dir1,item)),os.path.abspath(os.path.join(dir2,item)))</span><br><span class="line">    <span class="keyword">return</span> holderlist</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">2</span>:    <span class="comment">#输入源目录与备份目录</span></span><br><span class="line">        dir1 = sys.argv[<span class="number">1</span>]</span><br><span class="line">        dir2 = sys.argv[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        print(<span class="string">'Usage:'</span>,sys.argv[<span class="number">0</span>],<span class="string">'datadir backdir'</span>)</span><br><span class="line">        sys.exit()</span><br><span class="line">    source_files = compareme(dir1,dir2)    <span class="comment">#对比源目录与备份目录</span></span><br><span class="line">    dir1 = os.path.abspath(dir1)    <span class="comment">#取绝对路径后，后面不会自动加上'/'</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> dir2.endswith(<span class="string">'/'</span>):</span><br><span class="line">        dir2 = dir2+<span class="string">'/'</span>            <span class="comment">#备份目录路径加'/'</span></span><br><span class="line">    </span><br><span class="line">    dir2 = os.path.abspath(dir2)</span><br><span class="line">    destination_files = []</span><br><span class="line">    createdir_bool = <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> source_files:     <span class="comment">#遍历返回的差异文件或目录清单</span></span><br><span class="line">        destination_dir = re.sub(dir1,dir2,item)    <span class="comment">#将源目录差异路径清单对应替换成备份目录,即需要在dir2中创建的差异目录和文件</span></span><br><span class="line">        destination_files.append(destination_dir)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(item):      <span class="comment">#如果差异路径为目录且不存在，则在备份目录中创建</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(destination_dir):</span><br><span class="line">                os.makedirs(destination_dir)</span><br><span class="line">                createdir_bool = <span class="literal">True</span>   <span class="comment">#再次调用copareme函数标记</span></span><br><span class="line">    <span class="keyword">if</span> createdir_bool :       <span class="comment">#重新调用compareme函数，重新遍历新创建目录的内容</span></span><br><span class="line">        destination_files = []</span><br><span class="line">        source_files = []</span><br><span class="line">        source_files = compareme(dir1,dir2)    <span class="comment">#调用compareme函数</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> source_files:           <span class="comment">#获取源目录差异路径清单，对应替换成备份目录</span></span><br><span class="line">            destination_dir = re.sub(dir1,dir2,item)</span><br><span class="line">            destination_files.append(destination_dir)</span><br><span class="line">            </span><br><span class="line">    print(<span class="string">'update item:'</span>)</span><br><span class="line">    print(source_files)     <span class="comment">#输出更新项列表清单</span></span><br><span class="line">    copy_pair = zip(source_files,destination_files)  <span class="comment">#将源目录与备份目录文件清单拆分成元组</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> copy_pair:</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(item[<span class="number">0</span>]):        <span class="comment">#判断是否为文件，是则进行复制操作</span></span><br><span class="line">            shutil.copyfile(item[<span class="number">0</span>],item[<span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span> :</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-filecmp&quot;&gt;&lt;a href=&quot;#python-标准库-filecmp&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 filecmp&quot;&gt;&lt;/a&gt;python 标准库 filecmp&lt;/h1&gt;&lt;p&gt;每日一词:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;病毒&lt;/p&gt;
&lt;p&gt; germs、bacteria 還是 viruses &lt;/p&gt;
&lt;h3 id=&quot;Germ-微生物&quot;&gt;&lt;a href=&quot;#Germ-微生物&quot; class=&quot;headerlink&quot; title=&quot;Germ: 微生物&quot;&gt;&lt;/a&gt;&lt;strong&gt;Germ&lt;/strong&gt;: 微生物&lt;/h3&gt;&lt;h3 id=&quot;Bacterium-這是「細菌」的意思，它是微小且單細胞的有機體。注意喔這個字的單數是-bacterium，複數要寫作-bacteria&quot;&gt;&lt;a href=&quot;#Bacterium-這是「細菌」的意思，它是微小且單細胞的有機體。注意喔這個字的單數是-bacterium，複數要寫作-bacteria&quot; class=&quot;headerlink&quot; title=&quot;Bacterium: 這是「細菌」的意思，它是微小且單細胞的有機體。注意喔這個字的單數是 bacterium，複數要寫作 bacteria&quot;&gt;&lt;/a&gt;&lt;strong&gt;Bacterium&lt;/strong&gt;: 這是「細菌」的意思，它是微小且單細胞的有機體。注意喔這個字的單數是 bacterium，複數要寫作 bacteria&lt;/h3&gt;&lt;h3 id=&quot;Virus-病菌&quot;&gt;&lt;a href=&quot;#Virus-病菌&quot; class=&quot;headerlink&quot; title=&quot;Virus:病菌&quot;&gt;&lt;/a&gt;&lt;strong&gt;Virus&lt;/strong&gt;:病菌&lt;/h3&gt;&lt;p&gt; 茲卡病毒（Zika virus）、諾羅病毒（Norovirus）、愛滋病毒（Human Immunodeficiency Virus，縮寫即是 HIV）、輪狀病毒（Rotavirus）等。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://a1.att.hudong.com/20/29/01300000333999124281293520625.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="filecmp" scheme="https://pinghailinfeng.gitee.io/tags/filecmp/"/>
    
  </entry>
  
  <entry>
    <title>python standard library difflib</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/21/python-standard-library-difflib/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/21/python-standard-library-difflib/</id>
    <published>2020-01-21T01:17:59.000Z</published>
    <updated>2020-01-21T02:10:05.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库学习-difflib"><a href="#python-标准库学习-difflib" class="headerlink" title="python 标准库学习  difflib"></a>python 标准库学习  difflib</h1><p>每日一词:</p><blockquote><p>wink </p><p>US[wɪŋk]  UK[wɪŋk]</p><p>n.眼色；眨一只眼；眨眼示意</p><p>v.闪烁；眨眼示意（尤指使眼色或表示开玩笑）；明灭</p><p>网络瞬间；眨眼睛；你眨了眨眼</p><p>推荐一个电影：</p><p>记忆碎片👴</p><p>又是诺兰的大作,强烈推荐</p><p>推荐指数： 🌟🌟🌟🌟🌟</p></blockquote><p><img src="https://pic2.zhimg.com/2af9e3d253beebcab32903659da092d7_r.jpg" alt></p><a id="more"></a><p>马上就要过年了,尽量少去人流密集场所吧。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/difflib.py" target="_blank" rel="noopener">Lib/difflib.py</a></p><p>此模块提供用于比较序列的类和函数。 例如，它可以用于比较文件，并可以产生各种格式的不同信息，包括 HTML 和上下文以及统一格式的差异点。 有关目录和文件的比较，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/filecmp.html#module-filecmp" target="_blank" rel="noopener"><code>filecmp</code></a> 模块。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><em>class</em> <code>difflib.SequenceMatcher</code></p><p>这是一个灵活的类，可用于比较任何类型的序列对，只要序列元素为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a> 对象。 其基本算法要早于由 Ratcliff 和 Obershelp 于 1980 年代末期发表并以“格式塔模式匹配”的夸张名称命名的算法，并且更加有趣一些。 其思路是找到不包含“垃圾”元素的最长连续匹配子序列；所谓“垃圾”元素是指其在某种意义上没有价值，例如空白行或空白符。 （处理垃圾元素是对 Ratcliff 和 Obershelp 算法的一个扩展。） 然后同样的思路将递归地应用于匹配序列的左右序列片段。 这并不能产生最小编辑序列，但确实能产生在人们看来“正确”的匹配。</p><p><strong>耗时:</strong> 基本 Ratcliff-Obershelp 算法在最坏情况下为立方时间而在一般情况下为平方时间。 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher" target="_blank" rel="noopener"><code>SequenceMatcher</code></a> 在最坏情况下为平方时间而在一般情况下的行为受到序列中有多少相同元素这一因素的微妙影响；在最佳情况下则为线性时间。</p><p><strong>自动垃圾启发式计算:</strong> <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher" target="_blank" rel="noopener"><code>SequenceMatcher</code></a> 支持使用启发式计算来自动将特定序列项视为垃圾。 这种启发式计算会统计每个单独项在序列中出现的次数。 如果某一项（在第一项之后）的重复次数超过序列长度的 1% 并且序列长度至少有 200 项，该项会被标记为“热门”并被视为序列匹配中的垃圾。 这种启发式计算可以通过在创建 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher" target="_blank" rel="noopener"><code>SequenceMatcher</code></a> 时将 <code>autojunk</code> 参数设为 <code>False</code> 来关闭。</p><p><em>class</em> <code>difflib.Differ</code></p><p>这个类的作用是比较由文本行组成的序列，并产生可供人阅读的差异或增量信息。 Differ 统一使用 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher" target="_blank" rel="noopener"><code>SequenceMatcher</code></a> 来完成行序列的比较以及相似（接近匹配）行内部字符序列的比较。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ" target="_blank" rel="noopener"><code>Differ</code></a> 增量的每一行均以双字母代码打头：</p><table><thead><tr><th>双字母代码</th><th>意义</th></tr></thead><tbody><tr><td><code>&#39;- &#39;</code></td><td>行为序列 1 所独有</td></tr><tr><td><code>&#39;+ &#39;</code></td><td>行为序列 2 所独有</td></tr><tr><td><code>&#39;  &#39;</code></td><td>行在两序列中相同</td></tr><tr><td><code>&#39;? &#39;</code></td><td>行不存在于任一输入序列</td></tr></tbody></table><p>以 ‘<code>?</code>‘ 打头的行尝试将视线引至行以外而不存在于任一输入序列的差异。 如果序列包含制表符则这些行可能会令人感到迷惑。</p><p><em>class</em> <code>difflib.HtmlDiff</code></p><p>这个类可用于创建 HTML 表格（或包含表格的完整 HTML 文件）以并排地逐行显示文本比较，行间与行外的更改将突出显示。 此表格可以基于完全或上下文差异模式来生成。</p><p>这个类的构造函数：</p><ul><li><p><code>__init__</code>(<em>tabsize=8</em>, <em>wrapcolumn=None</em>, <em>linejunk=None</em>, <em>charjunk=IS_CHARACTER_JUNK</em>)</p><p>初始化 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.HtmlDiff" target="_blank" rel="noopener"><code>HtmlDiff</code></a> 的实例。</p><p><em>tabsize</em> 是一个可选关键字参数，指定制表位的间隔，默认值为 <code>8</code>。</p><p><em>wrapcolumn</em> 是一个可选关键字参数，指定行文本自动打断并换行的列位置，默认值为 <code>None</code> 表示不自动换行。</p><p><em>linejunk</em> 和 <em>charjunk</em> 均是可选关键字参数，会传入 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.ndiff" target="_blank" rel="noopener"><code>ndiff()</code></a> (被 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.HtmlDiff" target="_blank" rel="noopener"><code>HtmlDiff</code></a> 用来生成并排显示的 HTML 差异)。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.ndiff" target="_blank" rel="noopener"><code>ndiff()</code></a> 文档了解参数默认值及其说明。</p></li><li><p><code>make_file</code>(<em>fromlines</em>, <em>tolines</em>, <em>fromdesc=’’</em>, <em>todesc=’’</em>, <em>context=False</em>, <em>numlines=5</em>, <em>**, </em>charset=’utf-8’*)</p><p>比较 <em>fromlines</em> 和 <em>tolines</em> (字符串列表) 并返回一个字符串，表示一个完整 HTML 文件，其中包含各行差异的表格，行间与行外的更改将突出显示。</p><p><em>fromdesc</em> 和 <em>todesc</em> 均是可选关键字参数，指定来源/目标文件的列标题字符串（默认均为空白字符串）。</p><p><em>context</em> 和 <em>numlines</em> 均是可选关键字参数。 当只要显示上下文差异时就将 <em>context</em> 设为 <code>True</code>，否则默认值 <code>False</code> 为显示完整文件。 <em>numlines</em> 默认为 <code>5</code>。 当 <em>context</em> 为 <code>True</code> 时 <em>numlines</em> 将控制围绕突出显示差异部分的上下文行数。 当 <em>context</em> 为 <code>False</code> 时 <em>numlines</em> 将控制在使用 “next” 超链接时突出显示差异部分之前所显示的行数（设为零则会导致 “next” 超链接将下一个突出显示差异部分放在浏览器顶端，不添加任何前导上下文）。</p><blockquote><p><em>fromdesc</em> 和 <em>todesc</em> 会被当作未转义的 HTML 来解读，当接收不可信来源的输入时应该适当地进行转义。</p></blockquote></li><li><p><code>make_table</code>(<em>fromlines</em>, <em>tolines</em>, <em>fromdesc=’’</em>, <em>todesc=’’</em>, <em>context=False</em>, <em>numlines=5</em>)</p><p>比较 <em>fromlines</em> 和 <em>tolines</em> (字符串列表) 并返回一个字符串，表示一个包含各行差异的完整 HTML 表格，行间与行外的更改将突出显示。</p><p>此方法的参数与 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.HtmlDiff.make_file" target="_blank" rel="noopener"><code>make_file()</code></a> 方法的相同。</p><p><code>Tools/scripts/diff.py</code> 是这个类的命令行前端，其中包含一个很好的使用示例。</p></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>difflib.context_diff</code>(<em>a</em>, <em>b</em>, <em>fromfile=’’</em>, <em>tofile=’’</em>, <em>fromfiledate=’’</em>, <em>tofiledate=’’</em>, <em>n=3</em>, <em>lineterm=’\n’</em>)</p><p>比较 <em>a</em> 和 <em>b</em> (字符串列表)；返回上下文差异格式的增量信息 (一个产生增量行的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a>)。</p><p>所谓上下文差异是一种只显示有更改的行再加几个上下文行的紧凑形式。 更改被显示为之前/之后的样式。 上下文行数由 <em>n</em> 设定，默认为三行。</p><p>默认情况下，差异控制行（以 <code>***</code> or <code>---</code> 表示）是通过末尾换行符来创建的。 这样做的好处是从 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.readlines" target="_blank" rel="noopener"><code>io.IOBase.readlines()</code></a> 创建的输入将得到适用于 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.writelines" target="_blank" rel="noopener"><code>io.IOBase.writelines()</code></a> 的差异信息，因为输入和输出都带有末尾换行符。</p><p>对于没有末尾换行符的输入，应将 <em>lineterm</em> 参数设为 <code>&quot;&quot;</code>，这样输出内容将统一不带换行符。</p><p>上下文差异格式通常带有一个记录文件名和修改时间的标头。 这些信息的部分或全部可以使用字符串 <em>fromfile</em>, <em>tofile</em>, <em>fromfiledate</em> 和 <em>tofiledate</em> 来指定。 修改时间通常以 ISO 8601 格式表示。 如果未指定，这些字符串默认为空。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = [<span class="string">'bacon\n'</span>, <span class="string">'eggs\n'</span>, <span class="string">'ham\n'</span>, <span class="string">'guido\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = [<span class="string">'python\n'</span>, <span class="string">'eggy\n'</span>, <span class="string">'hamster\n'</span>, <span class="string">'guido\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.writelines(context_diff(s1, s2, fromfile=<span class="string">'before.py'</span>,tofile=<span class="string">'after.py'</span>))</span><br><span class="line">*** before.py</span><br><span class="line">--- after.py</span><br><span class="line">***************</span><br><span class="line">*** <span class="number">1</span>,<span class="number">4</span> ****</span><br><span class="line">! bacon</span><br><span class="line">! eggs</span><br><span class="line">! ham</span><br><span class="line">  guido</span><br><span class="line">--- <span class="number">1</span>,<span class="number">4</span> ----</span><br><span class="line">! python</span><br><span class="line">! eggy</span><br><span class="line">! hamster</span><br><span class="line">  guido</span><br></pre></td></tr></table></figure><p><code>difflib.get_close_matches</code>(<em>word</em>, <em>possibilities</em>, <em>n=3</em>, <em>cutoff=0.6</em>)</p><p>返回由最佳“近似”匹配构成的列表。 <em>word</em> 为一个指定目标近似匹配的序列（通常为字符串），<em>possibilities</em> 为一个由用于匹配 <em>word</em> 的序列构成的列表（通常为字符串列表）。</p><p>可选参数 <em>n</em> (默认为 <code>3</code>) 指定最多返回多少个近似匹配； <em>n</em> 必须大于 <code>0</code>.</p><p>可选参数 <em>cutoff</em> (默认为 <code>0.6</code>) 是一个 [0, 1] 范围内的浮点数。 与 <em>word</em> 相似度得分未达到该值的候选匹配将被忽略。</p><p>候选匹配中（不超过 <em>n</em> 个）的最佳匹配将以列表形式返回，按相似度得分排序，最相似的排在最前面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_close_matches(<span class="string">'appel'</span>, [<span class="string">'ape'</span>, <span class="string">'apple'</span>, <span class="string">'peach'</span>, <span class="string">'puppy'</span>])</span><br><span class="line">[<span class="string">'apple'</span>, <span class="string">'ape'</span>]</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> keyword</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_close_matches(<span class="string">'wheel'</span>, keyword.kwlist)</span><br><span class="line">[<span class="string">'while'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_close_matches(<span class="string">'pineapple'</span>, keyword.kwlist)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_close_matches(<span class="string">'accept'</span>, keyword.kwlist)</span><br><span class="line">[<span class="string">'except'</span>]</span><br></pre></td></tr></table></figure><p><code>difflib.ndiff</code>(<em>a</em>, <em>b</em>, <em>linejunk=None</em>, <em>charjunk=IS_CHARACTER_JUNK</em>)</p><p>比较 <em>a</em> 和 <em>b</em> (字符串列表)；返回 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ" target="_blank" rel="noopener"><code>Differ</code></a> 形式的增量信息 (一个产生增量行的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a>)。</p><p>可选关键字形参 <em>linejunk</em> 和 <em>charjunk</em> 均为过滤函数 (或为 <code>None</code>)：</p><p><em>linejunk</em>: 此函数接受单个字符串参数，如果其为垃圾字符串则返回真值，否则返回假值。 默认为 <code>None</code>。 此外还有一个模块层级的函数 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.IS_LINE_JUNK" target="_blank" rel="noopener"><code>IS_LINE_JUNK()</code></a>，它会过滤掉没有可见字符的行，除非该行添加了至多一个井号符 (<code>&#39;#&#39;</code>) – 但是下层的 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher" target="_blank" rel="noopener"><code>SequenceMatcher</code></a> 类会动态分析哪些行的重复频繁到足以形成噪音，这通常会比使用此函数的效果更好。</p><p><em>charjunk</em>: 此函数接受一个字符（长度为 1 的字符串)，如果其为垃圾字符则返回真值，否则返回假值。 默认为模块层级的函数 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.IS_CHARACTER_JUNK" target="_blank" rel="noopener"><code>IS_CHARACTER_JUNK()</code></a>，它会过滤掉空白字符（空格符或制表符；但包含换行符可不是个好主意！）。</p><p><code>Tools/scripts/ndiff.py</code> 是这个函数的命令行前端。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>diff = ndiff(<span class="string">'one\ntwo\nthree\n'</span>.splitlines(keepends=<span class="literal">True</span>),</span><br><span class="line"><span class="meta">... </span>            <span class="string">'ore\ntree\nemu\n'</span>.splitlines(keepends=<span class="literal">True</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">''</span>.join(diff), end=<span class="string">""</span>)</span><br><span class="line">- one</span><br><span class="line">?  ^</span><br><span class="line">+ ore</span><br><span class="line">?  ^</span><br><span class="line">- two</span><br><span class="line">- three</span><br><span class="line">?  -</span><br><span class="line">+ tree</span><br><span class="line">+ emu</span><br></pre></td></tr></table></figure><p><code>difflib.restore</code>(<em>sequence</em>, <em>which</em>)</p><p>返回两个序列中产生增量的那一个。</p><p>给出一个由 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ.compare" target="_blank" rel="noopener"><code>Differ.compare()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.ndiff" target="_blank" rel="noopener"><code>ndiff()</code></a> 产生的 <em>序列</em>，提取出来自文件 1 或 2 (<em>which</em> 形参) 的行，去除行前缀。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>diff = ndiff(<span class="string">'one\ntwo\nthree\n'</span>.splitlines(keepends=<span class="literal">True</span>),</span><br><span class="line"><span class="meta">... </span>            <span class="string">'ore\ntree\nemu\n'</span>.splitlines(keepends=<span class="literal">True</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>diff = list(diff) <span class="comment"># materialize the generated delta into a list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">''</span>.join(restore(diff, <span class="number">1</span>)), end=<span class="string">""</span>)</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">''</span>.join(restore(diff, <span class="number">2</span>)), end=<span class="string">""</span>)</span><br><span class="line">ore</span><br><span class="line">tree</span><br><span class="line">emu</span><br></pre></td></tr></table></figure><p><code>difflib.unified_diff</code>(<em>a</em>, <em>b</em>, <em>fromfile=’’</em>, <em>tofile=’’</em>, <em>fromfiledate=’’</em>, <em>tofiledate=’’</em>, <em>n=3</em>, <em>lineterm=’\n’</em>)</p><p>比较 <em>a</em> 和 <em>b</em> (字符串列表)；返回统一差异格式的增量信息 (一个产生增量行的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a>)。</p><p>所以统一差异是一种只显示有更改的行再加几个上下文行的紧凑形式。 更改被显示为内联的样式（而不是分开的之前/之后文本块）。 上下文行数由 <em>n</em> 设定，默认为三行。</p><p>默认情况下，差异控制行 (以 <code>---</code>, <code>+++</code> 或 <code>@@</code> 表示) 是通过末尾换行符来创建的。 这样做的好处是从 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.readlines" target="_blank" rel="noopener"><code>io.IOBase.readlines()</code></a> 创建的输入将得到适用于 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.writelines" target="_blank" rel="noopener"><code>io.IOBase.writelines()</code></a> 的差异信息，因为输入和输出都带有末尾换行符。</p><p>对于没有末尾换行符的输入，应将 <em>lineterm</em> 参数设为 <code>&quot;&quot;</code>，这样输出内容将统一不带换行符。</p><p>上下文差异格式通常带有一个记录文件名和修改时间的标头。 这些信息的部分或全部可以使用字符串 <em>fromfile</em>, <em>tofile</em>, <em>fromfiledate</em> 和 <em>tofiledate</em> 来指定。 修改时间通常以 ISO 8601 格式表示。 如果未指定，这些字符串默认为空。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = [<span class="string">'bacon\n'</span>, <span class="string">'eggs\n'</span>, <span class="string">'ham\n'</span>, <span class="string">'guido\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = [<span class="string">'python\n'</span>, <span class="string">'eggy\n'</span>, <span class="string">'hamster\n'</span>, <span class="string">'guido\n'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.writelines(unified_diff(s1, s2, fromfile=<span class="string">'before.py'</span>,tofile=<span class="string">'after.py'</span>))</span><br><span class="line">--- before.py</span><br><span class="line">+++ after.py</span><br><span class="line"><span class="meta">@@ -1,4 +1,4 @@</span></span><br><span class="line">-bacon</span><br><span class="line">-eggs</span><br><span class="line">-ham</span><br><span class="line">+python</span><br><span class="line">+eggy</span><br><span class="line">+hamster</span><br><span class="line"> guido</span><br></pre></td></tr></table></figure><p><code>difflib.diff_bytes</code>(<em>dfunc</em>, <em>a</em>, <em>b</em>, <em>fromfile=b’’</em>, <em>tofile=b’’</em>, <em>fromfiledate=b’’</em>, <em>tofiledate=b’’</em>, <em>n=3</em>, <em>lineterm=b’\n’</em>)</p><p>使用 <em>dfunc</em> 比较 <em>a</em> 和 <em>b</em> (字节串对象列表)；产生以 <em>dfunc</em> 所返回格式表示的差异行列表（也是字节串）。 <em>dfunc</em> 必须是可调用对象，通常为 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.unified_diff" target="_blank" rel="noopener"><code>unified_diff()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.context_diff" target="_blank" rel="noopener"><code>context_diff()</code></a>。</p><p>允许你比较编码未知或不一致的数据。 除 <em>n</em> 之外的所有输入都必须为字节串对象而非字符串。 作用方式为无损地将所有输入 (除 <em>n</em> 之外) 转换为字符串，并调用 <code>dfunc(a, b, fromfile, tofile, fromfiledate, tofiledate, n, lineterm)</code>。 <em>dfunc</em> 的输出会被随即转换回字节串，这样你所得到的增量行将具有与 <em>a</em> 和 <em>b</em> 相同的未知/不一致编码。</p><p><code>difflib.IS_LINE_JUNK</code>(<em>line</em>)</p><p>对于可忽略的行返回 <code>True</code>。 如果 <em>line</em> 为空行或只包含单个 <code>&#39;#&#39;</code> 则 <em>line</em> 行就是可忽略的，否则就是不可忽略的。 此函数被用作较旧版本 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.ndiff" target="_blank" rel="noopener"><code>ndiff()</code></a> 中 <em>linejunk</em> 形参的默认值。    </p><p><code>difflib.IS_CHARACTER_JUNK</code></p><p>对于可忽略的字符返回 <code>True</code>。 字符 <em>ch</em> 如果为空格符或制表符则 <em>ch</em> 就是可忽略的，否则就是不可忽略的。 此函数被用作 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.ndiff" target="_blank" rel="noopener"><code>ndiff()</code></a> 中 <em>charjunk</em> 形参的默认值。</p><h2 id="SequenceMatcher-对象"><a href="#SequenceMatcher-对象" class="headerlink" title="SequenceMatcher 对象"></a>SequenceMatcher 对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher" target="_blank" rel="noopener"><code>SequenceMatcher</code></a> 类具有这样的构造器：</p><p><em>class</em> <code>difflib.SequenceMatcher</code>(<em>isjunk=None</em>, <em>a=’’</em>, <em>b=’’</em>, <em>autojunk=True</em>)</p><p>可选参数 <em>isjunk</em> 必须为 <code>None</code> (默认值) 或为接受一个序列元素并当且仅当其为应忽略的“垃圾”元素时返回真值的单参数函数。 传入 <code>None</code> 作为 <em>isjunk</em> 的值就相当于传入 <code>lambda x: False</code>；也就是说不忽略任何值。 例如，传入:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x: x <span class="keyword">in</span> <span class="string">" \t"</span></span><br></pre></td></tr></table></figure><p>如果你以字符序列的形式对行进行比较，并且不希望区分空格符或硬制表符。</p><p>可选参数 <em>a</em> 和 <em>b</em> 为要比较的序列；两者默认为空字符串。 两个序列的元素都必须为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a>。</p><p>可选参数 <em>autojunk</em> 可用于启用自动垃圾启发式计算。</p><p>SequenceMatcher 对象接受三个数据属性: <em>bjunk</em> 是 <em>b</em> 当中 <em>isjunk</em> 为 <code>True</code> 的元素集合；<em>bpopular</em> 是被启发式计算（如果其未被禁用）视为热门候选的非垃圾元素集合；<em>b2j</em> 是将 <em>b</em> 当中剩余元素映射到一个它们出现位置列表的字典。 所有三个数据属性将在 <em>b</em> 通过 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.set_seqs" target="_blank" rel="noopener"><code>set_seqs()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.set_seq2" target="_blank" rel="noopener"><code>set_seq2()</code></a> 重置时被重置。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><code>set_seqs</code>(<em>a</em>, <em>b</em>)</li></ul><p>设置要比较的两个序列。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher" target="_blank" rel="noopener"><code>SequenceMatcher</code></a> 计算并缓存有关第二个序列的详细信息，这样如果你想要将一个序列与多个序列进行比较，可使用 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.set_seq2" target="_blank" rel="noopener"><code>set_seq2()</code></a> 一次性地设置该常用序列并重复地对每个其他序列各调用一次 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.set_seq1" target="_blank" rel="noopener"><code>set_seq1()</code></a>。</p><ul><li><p><code>set_seq1</code>(<em>a</em>)</p><p>设置要比较的第一个序列。 要比较的第二个序列不会改变。</p></li><li><p><code>set_seq2</code>(<em>b</em>)</p><p>设置要比较的第二个序列。 要比较的第一个序列不会改变。</p></li><li><p><code>find_longest_match</code>(<em>alo</em>, <em>ahi</em>, <em>blo</em>, <em>bhi</em>)</p><p>找出 <code>a[alo:ahi]</code> 和 <code>b[blo:bhi]</code> 中的最长匹配块。</p><p>如果 <em>isjunk</em> 被省略或为 <code>None</code>，<a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.find_longest_match" target="_blank" rel="noopener"><code>find_longest_match()</code></a> 将返回 <code>(i, j, k)</code> 使得 <code>a[i:i+k]</code> 等于 <code>b[j:j+k]</code>，其中 <code>alo &lt;= i &lt;= i+k &lt;= ahi</code> 并且 <code>blo &lt;= j &lt;= j+k &lt;= bhi</code>。 对于所有满足这些条件的 <code>(i&#39;, j&#39;, k&#39;)</code>，如果 <code>i == i&#39;</code>, <code>j &lt;= j&#39;</code> 也被满足，则附加条件 <code>k &gt;= k&#39;</code>, <code>i &lt;= i&#39;</code>。 换句话说，对于所有最长匹配块，返回在 <em>a</em> 当中最先出现的一个，而对于在 <em>a</em> 当中最先出现的所有最长匹配块，则返回在 <em>b</em> 当中最先出现的一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SequenceMatcher(<span class="literal">None</span>, <span class="string">" abcd"</span>, <span class="string">"abcd abcd"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.find_longest_match(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">Match(a=<span class="number">0</span>, b=<span class="number">4</span>, size=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>如果提供了 <em>isjunk</em>，将按上述规则确定第一个最长匹配块，但额外附加不允许块内出现垃圾元素的限制。 然后将通过（仅）匹配两边的垃圾元素来尽可能地扩展该块。 这样结果块绝对不会匹配垃圾元素，除非同样的垃圾元素正好与有意义的匹配相邻。</p><p>这是与之前相同的例子，但是将空格符视为垃圾。 这将防止 <code>&#39; abcd&#39;</code> 直接与第二个序列末尾的 <code>&#39; abcd&#39;</code> 相匹配。 而只可以匹配 <code>&#39;abcd&#39;</code>，并且是匹配第二个序列最左边的 <code>&#39;abcd&#39;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SequenceMatcher(<span class="keyword">lambda</span> x: x==<span class="string">" "</span>, <span class="string">" abcd"</span>, <span class="string">"abcd abcd"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.find_longest_match(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">Match(a=<span class="number">1</span>, b=<span class="number">0</span>, size=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>如果未找到匹配块，此方法将返回 <code>(alo, blo, 0)</code>。</p><p>此方法将返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-named-tuple" target="_blank" rel="noopener">named tuple</a> <code>Match(a, b, size)</code>。</p></li><li><p><code>get_matching_blocks</code>()</p></li></ul><p>返回描述非重叠匹配子序列的三元组列表。 每个三元组的形式为 <code>(i, j, n)</code>，其含义为 <code>a[i:i+n] == b[j:j+n]</code>。 这些三元组按 <em>i</em> 和 <em>j</em> 单调递增排列。</p><p>最后一个三元组用于占位，其值为 <code>(len(a), len(b), 0)</code>。 它是唯一 <code>n == 0</code> 的三元组。 如果 <code>(i, j, n)</code> 和 <code>(i&#39;, j&#39;, n&#39;)</code> 是在列表中相邻的三元组，且后者不是列表中的最后一个三元组，则 <code>i+n &lt; i&#39;</code> 或 <code>j+n &lt; j&#39;</code>；换句话说，相邻的三元组总是描述非相邻的相等块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SequenceMatcher(<span class="literal">None</span>, <span class="string">"abxcd"</span>, <span class="string">"abcd"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.get_matching_blocks()</span><br><span class="line">[Match(a=<span class="number">0</span>, b=<span class="number">0</span>, size=<span class="number">2</span>), Match(a=<span class="number">3</span>, b=<span class="number">2</span>, size=<span class="number">2</span>), Match(a=<span class="number">5</span>, b=<span class="number">4</span>, size=<span class="number">0</span>)]</span><br></pre></td></tr></table></figure><ul><li><code>get_opcodes</code>()</li></ul><p>返回描述如何将 <em>a</em> 变为 <em>b</em> 的 5 元组列表，每个元组的形式为 <code>(tag, i1, i2, j1, j2)</code>。 在第一个元组中 <code>i1 == j1 == 0</code>，而在其余的元组中 <em>i1</em> 等于前一个元组的 <em>i2</em>，并且 <em>j1</em> 也等于前一个元组的 <em>j2</em>。</p><p><em>tag</em> 值为字符串，其含义如下：</p><table><thead><tr><th>值</th><th>意义</th></tr></thead><tbody><tr><td><code>&#39;replace&#39;</code></td><td><code>a[i1:i2]</code> 应由 <code>b[j1:j2]</code> 替换。</td></tr><tr><td><code>&#39;delete&#39;</code></td><td><code>a[i1:i2]</code> 应被删除。 请注意在此情况下 <code>j1 == j2</code>。</td></tr><tr><td><code>&#39;insert&#39;</code></td><td><code>b[j1:j2]</code> 应插入到 <code>a[i1:i1]</code>。 请注意在此情况下 <code>i1 == i2</code>。</td></tr><tr><td><code>&#39;equal&#39;</code></td><td><code>a[i1:i2] == b[j1:j2]</code> (两个子序列相同)。</td></tr></tbody></table><p>例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"qabxcd"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"abycdf"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SequenceMatcher(<span class="literal">None</span>, a, b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> tag, i1, i2, j1, j2 <span class="keyword">in</span> s.get_opcodes():</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'&#123;:7&#125;   a[&#123;&#125;:&#123;&#125;] --&gt; b[&#123;&#125;:&#123;&#125;] &#123;!r:&gt;8&#125; --&gt; &#123;!r&#125;'</span>.format(</span><br><span class="line"><span class="meta">... </span>        tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2]))</span><br><span class="line">delete    a[0:1] --&gt; b[0:0]      'q' --&gt; ''</span><br><span class="line">equal     a[1:3] --&gt; b[0:2]     'ab' --&gt; 'ab'</span><br><span class="line">replace   a[3:4] --&gt; b[2:3]      'x' --&gt; 'y'</span><br><span class="line">equal     a[4:6] --&gt; b[3:5]     'cd' --&gt; 'cd'</span><br><span class="line">insert    a[6:6] --&gt; b[5:6]       '' --&gt; 'f'</span><br></pre></td></tr></table></figure><ul><li><p><code>get_grouped_opcodes</code>(<em>n=3</em>)</p><p>返回一个带有最多 <em>n</em> 行上下文的分组的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a>。从 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.get_opcodes" target="_blank" rel="noopener"><code>get_opcodes()</code></a> 所返回的组开始，此方法会拆分出较小的更改簇并消除没有更改的间隔区域。这些分组以与 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.get_opcodes" target="_blank" rel="noopener"><code>get_opcodes()</code></a> 相同的格式返回。</p></li><li><p><code>ratio</code>()</p><p>返回一个取值范围 [0, 1] 的浮点数作为序列相似性度量。其中 T 是两个序列中元素的总数量，M 是匹配的数量，即 2.0*M / T。 请注意如果两个序列完全相同则该值为 <code>1.0</code>，如果两者完全不同则为 <code>0.0</code>。如果 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.get_matching_blocks" target="_blank" rel="noopener"><code>get_matching_blocks()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.get_opcodes" target="_blank" rel="noopener"><code>get_opcodes()</code></a> 尚未被调用则此方法运算消耗较大，在此情况下你可能需要先调用 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.quick_ratio" target="_blank" rel="noopener"><code>quick_ratio()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.real_quick_ratio" target="_blank" rel="noopener"><code>real_quick_ratio()</code></a> 来获取一个上界。</p></li></ul><blockquote><p>注意: <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.ratio" target="_blank" rel="noopener"><code>ratio()</code></a> 调用的结果可能会取决于参数的顺序。 例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; SequenceMatcher(<span class="literal">None</span>, <span class="string">'tide'</span>, <span class="string">'diet'</span>).ratio()</span><br><span class="line">&gt; <span class="number">0.25</span></span><br><span class="line">&gt; &gt;&gt;&gt; SequenceMatcher(<span class="literal">None</span>, <span class="string">'diet'</span>, <span class="string">'tide'</span>).ratio()</span><br><span class="line">&gt; <span class="number">0.5</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><p><code>quick_ratio</code>()</p><p>相对快速地返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.ratio" target="_blank" rel="noopener"><code>ratio()</code></a> 的上界。</p></li><li><p><code>real_quick_ratio</code>()</p><p>非常快速地返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.ratio" target="_blank" rel="noopener"><code>ratio()</code></a> 的上界。</p><p>这三个返回匹配部分占字符总数的比率的方法可能由于不同的近似级别而给出不一样的结果，但是 <code>quick_ratio()</code> 和 <code>real_quick_ratio()</code> 总是会至少与 <code>ratio()</code> 一样大：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SequenceMatcher(<span class="literal">None</span>, <span class="string">"abcd"</span>, <span class="string">"bcde"</span>)</span><br><span class="line">s.ratio()</span><br><span class="line"><span class="number">0.75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.quick_ratio()</span><br><span class="line"><span class="number">0.75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.real_quick_ratio()</span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure><h2 id="SequenceMatcher-的示例"><a href="#SequenceMatcher-的示例" class="headerlink" title="SequenceMatcher 的示例"></a>SequenceMatcher 的示例</h2><p>以下示例比较两个字符串，并将空格视为“垃圾”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SequenceMatcher(<span class="keyword">lambda</span> x: x == <span class="string">" "</span>,</span><br><span class="line"><span class="meta">... </span>                   <span class="string">"private Thread currentThread;"</span>,</span><br><span class="line"><span class="meta">... </span>                   <span class="string">"private volatile Thread currentThread;"</span>)</span><br></pre></td></tr></table></figure><p><code>ratio()</code> 返回一个 [0, 1] 范围内的整数作为两个序列相似性的度量。 根据经验，<code>ratio()</code> 值超过 0.6 就意味着两个序列是近似匹配的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(round(s.ratio(), <span class="number">3</span>))</span><br><span class="line"><span class="number">0.866</span></span><br></pre></td></tr></table></figure><p>如果你只对两个序列相匹配的位置感兴趣，则 <code>get_matching_blocks()</code> 就很方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> block <span class="keyword">in</span> s.get_matching_blocks():</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"a[%d] and b[%d] match for %d elements"</span> % block)</span><br><span class="line">a[<span class="number">0</span>] <span class="keyword">and</span> b[<span class="number">0</span>] match <span class="keyword">for</span> <span class="number">8</span> elements</span><br><span class="line">a[<span class="number">8</span>] <span class="keyword">and</span> b[<span class="number">17</span>] match <span class="keyword">for</span> <span class="number">21</span> elements</span><br><span class="line">a[<span class="number">29</span>] <span class="keyword">and</span> b[<span class="number">38</span>] match <span class="keyword">for</span> <span class="number">0</span> elements</span><br></pre></td></tr></table></figure><p>请注意 <code>get_matching_blocks()</code> 返回的最后一个元组总是只用于占位的 <code>(len(a), len(b), 0)</code>，这也是元组末尾元素（匹配的元素数量）为 <code>0</code> 的唯一情况。</p><p>如果你想要知道如何将第一个序列转成第二个序列，可以使用 <code>get_opcodes()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> opcode <span class="keyword">in</span> s.get_opcodes():</span><br><span class="line"><span class="meta">... </span>   print(<span class="string">"%6s a[%d:%d] b[%d:%d]"</span> % opcode)</span><br><span class="line"> equal a[<span class="number">0</span>:<span class="number">8</span>] b[<span class="number">0</span>:<span class="number">8</span>]</span><br><span class="line">insert a[<span class="number">8</span>:<span class="number">8</span>] b[<span class="number">8</span>:<span class="number">17</span>]</span><br><span class="line"> equal a[<span class="number">8</span>:<span class="number">29</span>] b[<span class="number">17</span>:<span class="number">38</span>]</span><br></pre></td></tr></table></figure><h2 id="Differ-对象"><a href="#Differ-对象" class="headerlink" title="Differ 对象"></a>Differ 对象</h2><p>请注意 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ" target="_blank" rel="noopener"><code>Differ</code></a> 所生成的增量并不保证是 <strong>最小</strong> 差异。 相反，最小差异往往是违反直觉的，因为它们会同步任何可能的地方，有时甚至意外产生相距 100 页的匹配。 将同步点限制为连续匹配保留了一些局部性概念，这偶尔会带来产生更长差异的代价。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ" target="_blank" rel="noopener"><code>Differ</code></a> 类具有这样的构造器：</p><p><em>class</em> <code>difflib.Differ</code>(<em>linejunk=None</em>, <em>charjunk=None</em>)</p><p>可选关键字形参 <em>linejunk</em> 和 <em>charjunk</em> 均为过滤函数 (或为 <code>None</code>)：</p><p><em>linejunk</em>: 接受单个字符串作为参数的函数，如果其为垃圾字符串则返回真值。 默认值为 <code>None</code>，意味着没有任何行会被视为垃圾行。</p><p><em>charjunk</em>: 接受单个字符（长度为 1 的字符串）作为参数的函数，如果其为垃圾字符则返回真值。 默认值为 <code>None</code>，意味着没有任何字符会被视为垃圾字符。</p><p>这些垃圾过滤函数可加快查找差异的匹配速度，并且不会导致任何差异行或字符被忽略。 请阅读 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.SequenceMatcher.find_longest_match" target="_blank" rel="noopener"><code>find_longest_match()</code></a> 方法的 <em>isjunk</em> 形参的描述了解详情。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ" target="_blank" rel="noopener"><code>Differ</code></a> 对象是通过一个单独方法来使用（生成增量）的：</p><ul><li><p><code>compare</code>(<em>a</em>, <em>b</em>)</p><p>比较两个由行组成的序列，并生成增量（一个由行组成的序列）。每个序列必须包含一个以换行符结尾的单行字符串。 这样的序列可以通过文件类对象的 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.readlines" target="_blank" rel="noopener"><code>readlines()</code></a> 方法来获取。 所生成的增量同样由以换行符结尾的字符串构成，可以通过文件类对象的 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.writelines" target="_blank" rel="noopener"><code>writelines()</code></a> 方法原样打印出来。</p></li></ul><h2 id="Differ-示例"><a href="#Differ-示例" class="headerlink" title="Differ 示例"></a>Differ 示例</h2><p>此示例比较两段文本。 首先我们设置文本为以换行符结尾的单行字符串构成的序列（这样的序列也可以通过文件类对象的 <code>readlines()</code> 方法来获取）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text1 = <span class="string">'''  1. Beautiful is better than ugly.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  2. Explicit is better than implicit.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  3. Simple is better than complex.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  4. Complex is better than complicated.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>'''</span>.splitlines(keepends=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(text1)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text1[<span class="number">0</span>][<span class="number">-1</span>]</span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text2 = <span class="string">'''  1. Beautiful is better than ugly.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  3.   Simple is better than complex.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  4. Complicated is better than complex.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  5. Flat is better than nested.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>'''</span>.splitlines(keepends=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>接下来我们实例化一个 Differ 对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Differ()</span><br></pre></td></tr></table></figure><p>请注意在实例化 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ" target="_blank" rel="noopener"><code>Differ</code></a> 对象时我们可以传入函数来过滤掉“垃圾”行和字符。 详情参见 <a href="https://docs.python.org/zh-cn/3.8/library/difflib.html#difflib.Differ" target="_blank" rel="noopener"><code>Differ()</code></a> 构造器说明。</p><p>最后，我们比较两个序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = list(d.compare</span><br></pre></td></tr></table></figure><p><code>result</code> 是一个字符串列表，让我们将其美化打印出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint(result)</span><br><span class="line">[<span class="string">'    1. Beautiful is better than ugly.\n'</span>,</span><br><span class="line"> <span class="string">'-   2. Explicit is better than implicit.\n'</span>,</span><br><span class="line"> <span class="string">'-   3. Simple is better than complex.\n'</span>,</span><br><span class="line"> <span class="string">'+   3.   Simple is better than complex.\n'</span>,</span><br><span class="line"> <span class="string">'?     ++\n'</span>,</span><br><span class="line"> <span class="string">'-   4. Complex is better than complicated.\n'</span>,</span><br><span class="line"> <span class="string">'?            ^                     ---- ^\n'</span>,</span><br><span class="line"> <span class="string">'+   4. Complicated is better than complex.\n'</span>,</span><br><span class="line"> <span class="string">'?           ++++ ^                      ^\n'</span>,</span><br><span class="line"> <span class="string">'+   5. Flat is better than nested.\n'</span>]</span><br></pre></td></tr></table></figure><p>作为单独的多行字符串显示出来则是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.writelines(result)</span><br><span class="line">    <span class="number">1.</span> Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line">-   <span class="number">2.</span> Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line">-   <span class="number">3.</span> Simple <span class="keyword">is</span> better than complex.</span><br><span class="line">+   <span class="number">3.</span>   Simple <span class="keyword">is</span> better than complex.</span><br><span class="line">?     ++</span><br><span class="line">-   <span class="number">4.</span> Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">?            ^                     ---- ^</span><br><span class="line">+   <span class="number">4.</span> Complicated <span class="keyword">is</span> better than complex.</span><br><span class="line">?           ++++ ^                      ^</span><br><span class="line">+   <span class="number">5.</span> Flat <span class="keyword">is</span> better than nested.</span><br></pre></td></tr></table></figure><h2 id="difflib-的命令行接口"><a href="#difflib-的命令行接口" class="headerlink" title="difflib 的命令行接口"></a>difflib 的命令行接口</h2><p>这个实例演示了如何使用 difflib 来创建一个类似于 <code>diff</code> 的工具。 它同样包含在 Python 源码发布包中，文件名为 <code>Tools/scripts/diff.py</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">""" Command line interface to difflib.py providing diffs in four formats:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* ndiff:    lists every line and highlights interline changes.</span></span><br><span class="line"><span class="string">* context:  highlights clusters of changes in a before/after format.</span></span><br><span class="line"><span class="string">* unified:  highlights clusters of changes in an inline format.</span></span><br><span class="line"><span class="string">* html:     generates side by side comparison with change highlights.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, os, difflib, argparse</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timezone</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_mtime</span><span class="params">(path)</span>:</span></span><br><span class="line">    t = datetime.fromtimestamp(os.stat(path).st_mtime,</span><br><span class="line">                               timezone.utc)</span><br><span class="line">    <span class="keyword">return</span> t.astimezone().isoformat()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'-c'</span>, action=<span class="string">'store_true'</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        help=<span class="string">'Produce a context format diff (default)'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-u'</span>, action=<span class="string">'store_true'</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        help=<span class="string">'Produce a unified format diff'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-m'</span>, action=<span class="string">'store_true'</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        help=<span class="string">'Produce HTML side by side diff '</span></span><br><span class="line">                             <span class="string">'(can use -c and -l in conjunction)'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-n'</span>, action=<span class="string">'store_true'</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        help=<span class="string">'Produce a ndiff format diff'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-l'</span>, <span class="string">'--lines'</span>, type=int, default=<span class="number">3</span>,</span><br><span class="line">                        help=<span class="string">'Set number of context lines (default 3)'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'fromfile'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'tofile'</span>)</span><br><span class="line">    options = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    n = options.lines</span><br><span class="line">    fromfile = options.fromfile</span><br><span class="line">    tofile = options.tofile</span><br><span class="line"></span><br><span class="line">    fromdate = file_mtime(fromfile)</span><br><span class="line">    todate = file_mtime(tofile)</span><br><span class="line">    <span class="keyword">with</span> open(fromfile) <span class="keyword">as</span> ff:</span><br><span class="line">        fromlines = ff.readlines()</span><br><span class="line">    <span class="keyword">with</span> open(tofile) <span class="keyword">as</span> tf:</span><br><span class="line">        tolines = tf.readlines()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> options.u:</span><br><span class="line">        diff = difflib.unified_diff(fromlines, tolines, fromfile, tofile, fromdate, todate, n=n)</span><br><span class="line">    <span class="keyword">elif</span> options.n:</span><br><span class="line">        diff = difflib.ndiff(fromlines, tolines)</span><br><span class="line">    <span class="keyword">elif</span> options.m:</span><br><span class="line">        diff = difflib.HtmlDiff().make_file(fromlines,tolines,fromfile,tofile,context=options.c,numlines=n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        diff = difflib.context_diff(fromlines, tolines, fromfile, tofile, fromdate, todate, n=n)</span><br><span class="line"></span><br><span class="line">    sys.stdout.writelines(diff)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="补充关于HtmlDiff类用法"><a href="#补充关于HtmlDiff类用法" class="headerlink" title="补充关于HtmlDiff类用法"></a>补充关于<code>HtmlDiff</code>类用法</h2><p>结合webbrowser创建差异比较页面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> difflib</span><br><span class="line"><span class="keyword">import</span> webbrowser</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_diff</span><span class="params">(self, index, wrapcolumn)</span>:</span></span><br><span class="line">       file1, file2 = self.differing[index]</span><br><span class="line">       <span class="keyword">with</span> open(file1, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">           content1 = f.read().splitlines()</span><br><span class="line">       <span class="keyword">with</span> open(file2, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">           content2 = f.read().splitlines()</span><br><span class="line">       htmlDiff = HtmlDiff(tabsize=<span class="number">2</span>,wrapcolumn=wrapcolumn)</span><br><span class="line">       <span class="keyword">with</span> open(<span class="string">'tmp.html'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">           f.write(htmlDiff.make_file(content1, content2, fromdesc=self.dir1, todesc=self.dir2))</span><br><span class="line">       webbrowser.open(<span class="string">'tmp.html'</span>)</span><br></pre></td></tr></table></figure><p>对比Nginx配置文件差异脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> difflib</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    textfile1 = sys.argv[<span class="number">1</span>]</span><br><span class="line">    textfile2 = sys.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    print(<span class="string">"Error:"</span> + str(e))</span><br><span class="line">    print(<span class="string">"Usage: xxxx.py filename1 filename2"</span>)</span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readfile</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fileHandle = open(filename,<span class="string">'r'</span>)</span><br><span class="line">        text = fileHandle.read().splitlines()</span><br><span class="line">        fileHandle.close()</span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line">    <span class="keyword">except</span> IOError <span class="keyword">as</span> error:</span><br><span class="line">        print(<span class="string">'Read file Error:'</span> + str(error))</span><br><span class="line">        sys.exit()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> textfile1 == <span class="string">""</span> <span class="keyword">or</span> textfile2 == <span class="string">""</span>:</span><br><span class="line">    print(<span class="string">"Usage:test.py filename1 filename2"</span>)</span><br><span class="line">    sys.exit()</span><br><span class="line"> </span><br><span class="line">text1_lines = readfile(textfile1)</span><br><span class="line">text2_lines = readfile(textfile2)</span><br><span class="line"> </span><br><span class="line">d = difflib.HtmlDiff()</span><br><span class="line">print(d.make_file(text1_lines,text2_lines))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库学习-difflib&quot;&gt;&lt;a href=&quot;#python-标准库学习-difflib&quot; class=&quot;headerlink&quot; title=&quot;python 标准库学习  difflib&quot;&gt;&lt;/a&gt;python 标准库学习  difflib&lt;/h1&gt;&lt;p&gt;每日一词:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;wink &lt;/p&gt;
&lt;p&gt;US[wɪŋk]  UK[wɪŋk]&lt;/p&gt;
&lt;p&gt;n.眼色；眨一只眼；眨眼示意&lt;/p&gt;
&lt;p&gt;v.闪烁；眨眼示意（尤指使眼色或表示开玩笑）；明灭&lt;/p&gt;
&lt;p&gt;网络瞬间；眨眼睛；你眨了眨眼&lt;/p&gt;
&lt;p&gt;推荐一个电影：&lt;/p&gt;
&lt;p&gt;记忆碎片👴&lt;/p&gt;
&lt;p&gt;又是诺兰的大作,强烈推荐&lt;/p&gt;
&lt;p&gt;推荐指数： 🌟🌟🌟🌟🌟&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/2af9e3d253beebcab32903659da092d7_r.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="difflib" scheme="https://pinghailinfeng.gitee.io/tags/difflib/"/>
    
  </entry>
  
  <entry>
    <title>python standard library sqlite3</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/20/python-standard-library-sqlite3/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/20/python-standard-library-sqlite3/</id>
    <published>2020-01-20T00:51:23.000Z</published>
    <updated>2020-01-20T06:29:02.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-sqlite3"><a href="#python-标准库-sqlite3" class="headerlink" title="python 标准库 sqlite3"></a>python 标准库 sqlite3</h1><p>今天是二十四节气的大寒</p><blockquote><p>大寒，是<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8D%81%E5%9B%9B%E8%8A%82%E6%B0%94/191597" target="_blank" rel="noopener">二十四节气</a>中的最后一个节气。斗指丑；太阳<a href="https://baike.baidu.com/item/%E9%BB%84%E7%BB%8F/8303112" target="_blank" rel="noopener">黄经</a>为300°；公历1月20－21日交节。同小寒一样，大寒也是表示天气寒冷程度的节气。在我国部分地区，大寒不如小寒冷，但在某些年份和沿海少数地方，全年最低气温仍然会出现在大寒节气内。小寒、大寒是一年中雨水最少的时段。</p><p>兹大寒一过，新一年的节气就又轮回来了，正所谓冬去春来。大寒虽然寒冷，但因为已近春天，所以不会像大雪到冬至期间那样酷寒。这时节，人们开始忙着除旧饰新、腌制年肴、准备年货和各种祭祀供品、扫尘洁物，因为中国人最重要的节日——春节就要到了。</p><p>每日一词：</p><p>Cold </p><p>adj 冷,寒冷</p><p>例句：</p><p>  It is the last one in January 20th of each year twenty-four solar term solar term, before and after the sun reaches 300 degrees for it”. It is cold weather, meaning extreme.</p><p> 大寒是二十四节气中最后一个节气，每年1月20日前后太阳到达黄经300°时为”大寒”。大寒，是天气寒冷到极点的意思。</p></blockquote><p><img src="http://photos.tuchong.com/350832/f/4959845.jpg" alt></p><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/sqlite3/" target="_blank" rel="noopener">Lib/sqlite3/</a></p><p>SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL 查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再迁移到更大的数据库，比如 PostgreSQL 或 Oracle。</p><p>sqlite3 模块由 Gerhard Häring 编写。它提供了符合 DB-API 2.0 规范的接口，这个规范是 <a href="https://www.python.org/dev/peps/pep-0249" target="_blank" rel="noopener"><strong>PEP 249</strong></a>。</p><p>要使用这个模块，必须先创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象，它代表数据库。下面例子中，数据将存储在 <code>example.db</code> 文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line">conn = sqlite3.connect(<span class="string">'example.db'</span>)</span><br></pre></td></tr></table></figure><p>你也可以使用 <code>:memory:</code> 来创建一个内存中的数据库</p><p>当有了 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象后，你可以创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 游标对象，然后调用它的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> 方法来执行 SQL 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">c = conn.cursor()</span><br><span class="line"></span><br><span class="line"># Create table</span><br><span class="line">c.execute(&apos;&apos;&apos;CREATE TABLE stocks</span><br><span class="line">             (date text, trans text, symbol text, qty real, price real)&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line"># Insert a row of data</span><br><span class="line">c.execute(&quot;INSERT INTO stocks VALUES (&apos;2006-01-05&apos;,&apos;BUY&apos;,&apos;RHAT&apos;,100,35.14)&quot;)</span><br><span class="line"></span><br><span class="line"># Save (commit) the changes</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"># We can also close the connection if we are done with it.</span><br><span class="line"># Just be sure any changes have been committed or they will be lost.</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><p>这些数据被持久化保存了，而且可以在之后的会话中使用它们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line">conn = sqlite3.connect(<span class="string">'example.db'</span>)</span><br><span class="line">c = conn.cursor()</span><br></pre></td></tr></table></figure><p>通常你的 SQL 操作需要使用一些 Python 变量的值。你不应该使用 Python 的字符串操作来创建你的查询语句，因为那样做不安全；它会使你的程序容易受到 SQL 注入攻击（在 <a href="https://xkcd.com/327/" target="_blank" rel="noopener">https://xkcd.com/327/</a> 上有一个搞笑的例子，看看有什么后果）</p><p>推荐另外一种方法：使用 DB-API 的参数替换。在你的 SQL 语句中，使用 <code>?</code> 占位符来代替值，然后把对应的值组成的元组做为 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> 方法的第二个参数。（其他数据库可能会使用不同的占位符，比如 <code>%s</code> 或者 <code>:1</code>）例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Never do this -- insecure!</span></span><br><span class="line">symbol = <span class="string">'RHAT'</span></span><br><span class="line">c.execute(<span class="string">"SELECT * FROM stocks WHERE symbol = '%s'"</span> % symbol)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Do this instead</span></span><br><span class="line">t = (<span class="string">'RHAT'</span>,)</span><br><span class="line">c.execute(<span class="string">'SELECT * FROM stocks WHERE symbol=?'</span>, t)</span><br><span class="line">print(c.fetchone())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Larger example that inserts many records at a time</span></span><br><span class="line">purchases = [(<span class="string">'2006-03-28'</span>, <span class="string">'BUY'</span>, <span class="string">'IBM'</span>, <span class="number">1000</span>, <span class="number">45.00</span>),</span><br><span class="line">             (<span class="string">'2006-04-05'</span>, <span class="string">'BUY'</span>, <span class="string">'MSFT'</span>, <span class="number">1000</span>, <span class="number">72.00</span>),</span><br><span class="line">             (<span class="string">'2006-04-06'</span>, <span class="string">'SELL'</span>, <span class="string">'IBM'</span>, <span class="number">500</span>, <span class="number">53.00</span>),</span><br><span class="line">            ]</span><br><span class="line">c.executemany(<span class="string">'INSERT INTO stocks VALUES (?,?,?,?,?)'</span>, purchases)</span><br></pre></td></tr></table></figure><p>要在执行 SELECT 语句后获取数据，你可以把游标作为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a>，然后调用它的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.fetchone" target="_blank" rel="noopener"><code>fetchone()</code></a> 方法来获取一条匹配的行，也可以调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.fetchall" target="_blank" rel="noopener"><code>fetchall()</code></a> 来得到包含多个匹配行的列表。</p><p>下面是一个使用迭代器形式的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> c.execute(<span class="string">'SELECT * FROM stocks ORDER BY price'</span>):</span><br><span class="line">        print(row)</span><br><span class="line"></span><br><span class="line">(<span class="string">'2006-01-05'</span>, <span class="string">'BUY'</span>, <span class="string">'RHAT'</span>, <span class="number">100</span>, <span class="number">35.14</span>)</span><br><span class="line">(<span class="string">'2006-03-28'</span>, <span class="string">'BUY'</span>, <span class="string">'IBM'</span>, <span class="number">1000</span>, <span class="number">45.0</span>)</span><br><span class="line">(<span class="string">'2006-04-06'</span>, <span class="string">'SELL'</span>, <span class="string">'IBM'</span>, <span class="number">500</span>, <span class="number">53.0</span>)</span><br><span class="line">(<span class="string">'2006-04-05'</span>, <span class="string">'BUY'</span>, <span class="string">'MSFT'</span>, <span class="number">1000</span>, <span class="number">72.0</span>)</span><br></pre></td></tr></table></figure><h2 id="模块函数和常量"><a href="#模块函数和常量" class="headerlink" title="模块函数和常量"></a>模块函数和常量</h2><ul><li><code>sqlite3.version</code></li></ul><p>​       这个模块的版本号，是一个字符串。不是 SQLite 库的版本号。</p><ul><li><p><code>sqlite3.version_info</code></p><p>这个模块的版本号，是一个由整数组成的元组。不是 SQLite 库的版本号。</p></li><li><p><code>sqlite3.sqlite_version</code></p><p>使用中的 SQLite 库的版本号，是一个字符串。</p></li><li><p><code>sqlite3.sqlite_version_info</code></p><p>使用中的 SQLite 库的版本号，是一个整数组成的元组。</p></li><li><p><code>sqlite3.PARSE_DECLTYPES</code></p><p>这个常量可以作为 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.connect" target="_blank" rel="noopener"><code>connect()</code></a> 函数的 <em>detect_types</em> 参数。</p><p>设置这个参数后，<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块将解析它返回的每一列申明的类型。它会申明的类型的第一个单词，比如“integer primary key”，它会解析出“integer”，再比如“number(10)”，它会解析出“number”。然后，它会在转换器字典里查找那个类型注册的转换器函数，并调用它。</p></li><li><p><code>sqlite3.PARSE_COLNAMES</code></p></li><li><p><code>sqlite3.connect</code>(<em>database</em>[, <em>timeout</em>, <em>detect_types</em>, <em>isolation_level</em>, <em>check_same_thread</em>, <em>factory</em>, <em>cached_statements</em>, <em>uri</em>])</p></li></ul><p>连接 SQLite 数据库 <em>database</em>。默认返回 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象，除非使用了自定义的 <em>factory</em> 参数。</p><p><em>database</em> 是准备打开的数据库文件的路径（绝对路径或相对于当前目录的相对路径），它是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a>。你也可以用 <code>&quot;:memory:&quot;</code> 在内存中打开一个数据库。</p><p>当一个数据库被多个连接访问的时候，如果其中一个进程修改这个数据库，在这个事务提交之前，这个 SQLite 数据库将会被一直锁定。<em>timeout</em> 参数指定了这个连接等待锁释放的超时时间，超时之后会引发一个异常。这个超时时间默认是 5.0（5秒）。</p><p><em>isolation_level</em> 参数，请查看 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.isolation_level" target="_blank" rel="noopener"><code>isolation_level</code></a> 属性。</p><p>SQLite 原生只支持5种类型：TEXT，INTEGER，REAL，BLOB 和 NULL。如果你想用其它类型，你必须自己添加相应的支持。使用 <em>detect_types</em> 参数和模块级别的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.register_converter" target="_blank" rel="noopener"><code>register_converter()</code></a> 函数注册<strong>转换器</strong> 可以简单的实现。</p><p><em>detect_types</em> 默认为0（即关闭，没有类型检测）。你也可以组合 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.PARSE_DECLTYPES" target="_blank" rel="noopener"><code>PARSE_DECLTYPES</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.PARSE_COLNAMES" target="_blank" rel="noopener"><code>PARSE_COLNAMES</code></a> 来开启类型检测。</p><p>默认情况下，<em>check_same_thread</em> 为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>，只有当前的线程可以使用该连接。 如果设置为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>，则多个线程可以共享返回的连接。 当多个线程使用同一个连接的时候，用户应该把写操作进行序列化，以避免数据损坏。</p><p>默认情况下，当调用 connect 方法的时候，<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块使用了它的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 类。当然，你也可以创建 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 类的子类，然后创建提供了 <em>factory</em> 参数的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.connect" target="_blank" rel="noopener"><code>connect()</code></a> 方法。</p><p>详情请查阅当前手册的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3-types" target="_blank" rel="noopener">SQLite 与 Python 类型</a> 部分。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块在内部使用语句缓存来避免 SQL 解析开销。 如果要显式设置当前连接可以缓存的语句数，可以设置 <em>cached_statements</em> 参数。 当前实现的默认值是缓存100条语句。</p><p>如果 <em>uri</em> 为真，则 <em>database</em> 被解释为 URI。 它允许您指定选项。 例如，以只读模式打开数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db = sqlite3.connect(<span class="string">'file:path/to/database?mode=ro'</span>, uri=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>有关此功能的更多信息，包括已知选项的列表，可以在 <code>SQLite URI 文档 &lt;&lt;https://www.sqlite.org/uri.html&gt;&gt;</code>_ 中找到。</p><ul><li><p><code>sqlite3.register_converter</code>(<em>typename</em>, <em>callable</em>)</p><p>注册一个回调对象 <em>callable</em>, 用来转换数据库中的字节串为自定的 Python 类型。所有类型为 <em>typename</em> 的数据库的值在转换时，都会调用这个回调对象。通过指定 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.connect" target="_blank" rel="noopener"><code>connect()</code></a> 函数的 <em>detect-types</em> 参数来设置类型检测的方式。注意，<em>typename</em> 与查询语句中的类型名进行匹配时不区分大小写。</p></li><li><p><code>sqlite3.register_adapter</code>(<em>type</em>, <em>callable</em>)</p><p>注册一个回调对象 <em>callable</em>，用来转换自定义Python类型为一个 SQLite 支持的类型。 这个回调对象 <em>callable</em> 仅接受一个 Python 值作为参数，而且必须返回以下某个类型的值：int，float，str 或 bytes。</p></li><li><p><code>sqlite3.complete_statement</code>(<em>sql</em>)</p><p>如果字符串 <em>sql</em> 包含一个或多个完整的 SQL 语句（以分号结束）则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>。它不会验证 SQL 语法是否正确，仅会验证字符串字面上是否完整，以及是否以分号结束。</p><p>它可以用来构建一个 SQLite shell，下面是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A minimal SQLite shell for experiments</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.isolation_level = <span class="literal">None</span></span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">buffer = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Enter your SQL commands to execute in sqlite3."</span>)</span><br><span class="line">print(<span class="string">"Enter a blank line to exit."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = input()</span><br><span class="line">    <span class="keyword">if</span> line == <span class="string">""</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    buffer += line</span><br><span class="line">    <span class="keyword">if</span> sqlite3.complete_statement(buffer):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            buffer = buffer.strip()</span><br><span class="line">            cur.execute(buffer)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> buffer.lstrip().upper().startswith(<span class="string">"SELECT"</span>):</span><br><span class="line">                print(cur.fetchall())</span><br><span class="line">        <span class="keyword">except</span> sqlite3.Error <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">"An error occurred:"</span>, e.args[<span class="number">0</span>])</span><br><span class="line">        buffer = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p><code>sqlite3.enable_callback_tracebacks</code>(<em>flag</em>)</p><p>默认情况下，您不会获得任何用户定义函数中的回溯消息，比如聚合，转换器，授权器回调等。如果要调试它们，可以设置 <em>flag</em> 参数为 <code>True</code> 并调用此函数。 之后，回调中的回溯信息将会输出到 <code>sys.stderr</code>。 再次使用 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a> 来禁用该功能。</p><h2 id="连接对象（Connection）"><a href="#连接对象（Connection）" class="headerlink" title="连接对象（Connection）"></a>连接对象（Connection）</h2></li></ul><p><em>class</em> <code>sqlite3.Connection</code></p><p>SQLite 数据库连接对象有如下的属性和方法：</p><ul><li><p><code>isolation_level</code></p><p>获取或设置当前默认的隔离级别。 表示自动提交模式的 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 以及 “DEFERRED”, “IMMEDIATE” 或 “EXCLUSIVE” 其中之一。 详细描述请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3-controlling-transactions" target="_blank" rel="noopener">控制事务</a>。</p></li><li><p><code>in_transaction</code></p><p>如果是在活动事务中（还没有提交改变），返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>，否则，返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>。它是一个只读属性。<em>3.2 新版功能.</em></p></li><li><p><code>cursor</code>(<em>factory=Cursor</em>)</p><p>这个方法接受一个可选参数 <em>factory</em>，如果要指定这个参数，它必须是一个可调用对象，而且必须返回 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 类的一个实例或者子类。</p></li><li><p><code>commit</code>()</p><p>这个方法提交当前事务。如果没有调用这个方法，那么从上一次提交 <code>commit()</code> 以来所有的变化在其他数据库连接上都是不可见的。如果你往数据库里写了数据，但是又查询不到，请检查是否忘记了调用这个方法。</p></li><li><p><code>rollback</code>()</p><p>这个方法回滚从上一次调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.commit" target="_blank" rel="noopener"><code>commit()</code></a> 以来所有数据库的改变。</p></li><li><p><code>close</code>()</p><p>关闭数据库连接。注意，它不会自动调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.commit" target="_blank" rel="noopener"><code>commit()</code></a> 方法。如果在关闭数据库连接之前没有调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.commit" target="_blank" rel="noopener"><code>commit()</code></a>，那么你的修改将会丢失！</p></li><li><p><code>execute</code>(<em>sql</em>[, <em>parameters</em>])</p><p>这是一个非标准的快捷方法，它会调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.cursor" target="_blank" rel="noopener"><code>cursor()</code></a> 方法来创建一个游标对象，并使用给定的 <em>parameters</em> 参数来调用游标对象的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> 方法，最后返回这个游标对象。</p></li><li><p><code>executemany</code>(<em>sql</em>[, <em>parameters</em>])</p><p>这是一个非标准的快捷方法，它会调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.cursor" target="_blank" rel="noopener"><code>cursor()</code></a> 方法来创建一个游标对象，并使用给定的 <em>parameters</em> 参数来调用游标对象的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executemany" target="_blank" rel="noopener"><code>executemany()</code></a> 方法，最后返回这个游标对象。</p></li><li><p><code>executescript</code>(<em>sql_script</em>)</p><p>这是一个非标准的快捷方法，它会调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.cursor" target="_blank" rel="noopener"><code>cursor()</code></a> 方法来创建一个游标对象，并使用给定的 <em>sql_script</em> 参数来调用游标对象的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executescript" target="_blank" rel="noopener"><code>executescript()</code></a> 方法，最后返回这个游标对象。</p></li><li><p><code>create_function</code>(<em>name</em>, <em>num_params</em>, <em>func</em>, <em>**, </em>deterministic=False*)</p><p>创建一个可以在 SQL 语句中使用的用户自定义函数，函数名为 <em>name</em>。 <em>num_params</em> 为该函数所接受的形参个数（如果 <em>num_params</em> 为 -1，则该函数可接受任意数量的参数）， <em>func</em> 是一个 Python 可调用对象，它将作为 SQL 函数被调用。 如果 <em>deterministic</em> 为真值，则所创建的函数将被标记为 <a href="https://sqlite.org/deterministic.html" target="_blank" rel="noopener">deterministic</a>，这允许 SQLite 执行额外的优化。 此旗标在 SQLite 3.8.3 或更高版本中受到支持，如果在旧版本中使用将引发 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.NotSupportedError" target="_blank" rel="noopener"><code>NotSupportedError</code></a>。此函数可返回任何 SQLite 所支持的类型: bytes, str, int, float 和 <code>None</code>。<em>在 3.8 版更改:</em> 增加了 <em>deterministic</em> 形参。示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5sum</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(t).hexdigest()</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.create_function(<span class="string">"md5"</span>, <span class="number">1</span>, md5sum)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"select md5(?)"</span>, (<span class="string">b"foo"</span>,))</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p><code>create_aggregate</code>(<em>name</em>, <em>num_params</em>, <em>aggregate_class</em>)</p><p>创建一个自定义的聚合函数。</p><p>参数中 <em>aggregate_class</em> 类必须实现两个方法：<code>step</code> 和 <code>finalize</code>。<code>step</code> 方法接受 <em>num_params</em> 个参数（如果 <em>num_params</em> 为 -1，那么这个函数可以接受任意数量的参数）；<code>finalize</code> 方法返回最终的聚合结果。</p><p><code>finalize</code> 方法可以返回任何 SQLite 支持的类型：bytes，str，int，float 和 <code>None</code>。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySum</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.count += value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finalize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.create_aggregate(<span class="string">"mysum"</span>, <span class="number">1</span>, MySum)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(i)"</span>)</span><br><span class="line">cur.execute(<span class="string">"insert into test(i) values (1)"</span>)</span><br><span class="line">cur.execute(<span class="string">"insert into test(i) values (2)"</span>)</span><br><span class="line">cur.execute(<span class="string">"select mysum(i) from test"</span>)</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p><code>create_collation</code>(<em>name</em>, <em>callable</em>)</p><p>使用 <em>name</em> 和 <em>callable</em> 创建排序规则。这个 <em>callable</em> 接受两个字符串对象，如果第一个小于第二个则返回 -1， 如果两个相等则返回 0，如果第一个大于第二个则返回 1。注意，这是用来控制排序的（SQL 中的 ORDER BY），所以它不会影响其它的 SQL 操作。</p><p>注意，这个 <em>callable</em> 可调用对象会把它的参数作为 Python 字节串，通常会以 UTF-8 编码格式对它进行编码。</p><p>以下示例显示了使用“错误方式”进行排序的自定义排序规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collate_reverse</span><span class="params">(string1, string2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> string1 == string2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> string1 &lt; string2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.create_collation(<span class="string">"reverse"</span>, collate_reverse)</span><br><span class="line"></span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(x)"</span>)</span><br><span class="line">cur.executemany(<span class="string">"insert into test(x) values (?)"</span>, [(<span class="string">"a"</span>,), (<span class="string">"b"</span>,)])</span><br><span class="line">cur.execute(<span class="string">"select x from test order by x collate reverse"</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cur:</span><br><span class="line">    print(row)</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><p>要移除一个排序规则，需要调用 <code>create_collation</code> 并设置 callable 参数为 <code>None</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.create_collation(<span class="string">"reverse"</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><ul><li><p><code>interrupt</code>()</p><p>可以从不同的线程调用这个方法来终止所有查询操作，这些查询操作可能正在连接上执行。此方法调用之后， 查询将会终止，而且查询的调用者会获得一个异常。</p></li><li><p><code>set_authorizer</code>(<em>authorizer_callback</em>)</p><p>此方法注册一个授权回调对象。每次在访问数据库中某个表的某一列的时候，这个回调对象将会被调用。如果要允许访问，则返回 <code>SQLITE_OK</code>，如果要终止整个 SQL 语句，则返回 <code>SQLITE_DENY</code>，如果这一列需要当做 NULL 值处理，则返回 <code>SQLITE_IGNORE</code>。这些常量可以在 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块中找到。回调的第一个参数表示要授权的操作类型。 第二个和第三个参数将是参数或 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>，具体取决于第一个参数的值。 第 4 个参数是数据库的名称（“main”，“temp”等），如果需要的话。 第 5 个参数是负责访问尝试的最内层触发器或视图的名称，或者如果此访问尝试直接来自输入 SQL 代码，则为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。请参阅 SQLite 文档，了解第一个参数的可能值以及第二个和第三个参数的含义，具体取决于第一个参数。 所有必需的常量都可以在 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块中找到。</p></li><li><p><code>set_progress_handler</code>(<em>handler</em>, <em>n</em>)</p><p>此例程注册回调。 对SQLite虚拟机的每个多指令调用回调。 如果要在长时间运行的操作期间从SQLite调用（例如更新用户界面），这非常有用。如果要清除以前安装的任何进度处理程序，调用该方法时请将 <em>handler</em> 参数设置为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。从处理函数返回非零值将终止当前正在执行的查询并导致它引发 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.OperationalError" target="_blank" rel="noopener"><code>OperationalError</code></a> 异常。</p></li><li><p><code>set_trace_callback</code>(<em>trace_callback</em>)</p><p>为每个 SQLite 后端实际执行的 SQL 语句注册要调用的 <em>trace_callback</em>。传递给回调的唯一参数是正在执行的语句（作为字符串）。 回调的返回值将被忽略。 请注意，后端不仅运行传递给 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>Cursor.execute()</code></a> 方法的语句。 其他来源包括 Python 模块的事务管理和当前数据库中定义的触发器的执行。将传入的 <em>trace_callback</em> 设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 将禁用跟踪回调。</p></li><li><p><code>enable_load_extension</code>(<em>enabled</em>)</p><p>此例程允许/禁止SQLite引擎从共享库加载SQLite扩展。 SQLite扩展可以定义新功能，聚合或全新的虚拟表实现。 一个众所周知的扩展是与SQLite一起分发的全文搜索扩展。</p><p>默认情况下禁用可加载扩展。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable extension loading</span></span><br><span class="line">con.enable_load_extension(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load the fulltext search extension</span></span><br><span class="line">con.execute(<span class="string">"select load_extension('./fts3.so')"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># alternatively you can load the extension using an API call:</span></span><br><span class="line"><span class="comment"># con.load_extension("./fts3.so")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># disable extension loading again</span></span><br><span class="line">con.enable_load_extension(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># example from SQLite wiki</span></span><br><span class="line">con.execute(<span class="string">"create virtual table recipe using fts3(name, ingredients)"</span>)</span><br><span class="line">con.executescript(<span class="string">"""</span></span><br><span class="line"><span class="string">    insert into recipe (name, ingredients) values ('broccoli stew', 'broccoli peppers cheese tomatoes');</span></span><br><span class="line"><span class="string">    insert into recipe (name, ingredients) values ('pumpkin stew', 'pumpkin onions garlic celery');</span></span><br><span class="line"><span class="string">    insert into recipe (name, ingredients) values ('broccoli pie', 'broccoli cheese onions flour');</span></span><br><span class="line"><span class="string">    insert into recipe (name, ingredients) values ('pumpkin pie', 'pumpkin sugar flour butter');</span></span><br><span class="line"><span class="string">    """</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> con.execute(<span class="string">"select rowid, name, ingredients from recipe where name match 'pie'"</span>):</span><br><span class="line">    print(row)</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p><code>load_extension</code>(<em>path</em>)</p><p>此例程从共享库加载SQLite扩展。 在使用此例程之前，必须使用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.enable_load_extension" target="_blank" rel="noopener"><code>enable_load_extension()</code></a> 启用扩展加载。</p><p>默认情况下禁用可加载扩展。</p></li><li><p>row_factory<br>您可以将此属性更改为可接受游标和原始行作为元组的可调用对象，并将返回实际结果行。 这样，您可以实现更高级的返回结果的方法，例如返回一个可以按名称访问列的对象。<br>示例:   </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict_factory</span><span class="params">(cursor, row)</span>:</span></span><br><span class="line">   d = &#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> idx, col <span class="keyword">in</span> enumerate(cursor.description):</span><br><span class="line">       d[col[<span class="number">0</span>]] = row[idx]</span><br><span class="line">   <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.row_factory = dict_factory</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"select 1 as a"</span>)</span><br><span class="line">print(cur.fetchone()[<span class="string">"a"</span>])</span><br><span class="line"></span><br><span class="line">  con.close()</span><br></pre></td></tr></table></figure><p>如果返回一个元组是不够的，并且你想要对列进行基于名称的访问，你应该考虑将 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.row_factory" target="_blank" rel="noopener"><code>row_factory</code></a> 设置为高度优化的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Row" target="_blank" rel="noopener"><code>sqlite3.Row</code></a> 类型。 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Row" target="_blank" rel="noopener"><code>Row</code></a> 提供基于索引和不区分大小写的基于名称的访问，几乎没有内存开销。 它可能比您自己的基于字典的自定义方法甚至基于 db_row 的解决方案更好。</p><ul><li><p><strong>text_factory</strong></p><p>使用此属性可以控制为 <code>TEXT</code> 数据类型返回的对象。 默认情况下，此属性设置为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块将返回 <code>TEXT</code> 的 Unicode 对象。 如果要返回字节串，可以将其设置为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>。</p><p>您还可以将其设置为接受单个 bytestring 参数的任何其他可调用对象，并返回结果对象。</p><p>请参阅以下示例代码以进行说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">AUSTRIA = <span class="string">"\xd6sterreich"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># by default, rows are returned as Unicode</span></span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (AUSTRIA,))</span><br><span class="line">row = cur.fetchone()</span><br><span class="line"><span class="keyword">assert</span> row[<span class="number">0</span>] == AUSTRIA</span><br><span class="line"></span><br><span class="line"><span class="comment"># but we can make sqlite3 always return bytestrings ...</span></span><br><span class="line">con.text_factory = bytes</span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (AUSTRIA,))</span><br><span class="line">row = cur.fetchone()</span><br><span class="line"><span class="keyword">assert</span> type(row[<span class="number">0</span>]) <span class="keyword">is</span> bytes</span><br><span class="line"><span class="comment"># the bytestrings will be encoded in UTF-8, unless you stored garbage in the</span></span><br><span class="line"><span class="comment"># database ...</span></span><br><span class="line"><span class="keyword">assert</span> row[<span class="number">0</span>] == AUSTRIA.encode(<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we can also implement a custom text_factory ...</span></span><br><span class="line"><span class="comment"># here we implement one that appends "foo" to all strings</span></span><br><span class="line">con.text_factory = <span class="keyword">lambda</span> x: x.decode(<span class="string">"utf-8"</span>) + <span class="string">"foo"</span></span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (<span class="string">"bar"</span>,))</span><br><span class="line">row = cur.fetchone()</span><br><span class="line"><span class="keyword">assert</span> row[<span class="number">0</span>] == <span class="string">"barfoo"</span></span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p>total_changes</p><p>返回自打开数据库连接以来已修改，插入或删除的数据库行的总数。</p></li><li><p><code>iterdump</code>()</p><p>返回以SQL文本格式转储数据库的迭代器。 保存内存数据库以便以后恢复时很有用。 此函数提供与 <strong>sqlite3</strong> shell 中的 .dump 命令相同的功能。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Convert file existing_db.db to SQL dump file dump.sql</span></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">'existing_db.db'</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dump.sql'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> con.iterdump():</span><br><span class="line">        f.write(<span class="string">'%s\n'</span> % line)</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>backup</code>(<em>target</em>, <em>**, </em>pages=0<em>, </em>progress=None<em>, </em>name=”main”<em>, </em>sleep=0.250*)</p><p>即使在 SQLite 数据库被其他客户端访问时，或者同时由同一连接访问，该方法也会对其进行备份。 该副本将写入强制参数 <em>target</em>，该参数必须是另一个 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 实例。</p><p>默认情况下，或者当 <em>pages</em> 为 <code>0</code> 或负整数时，整个数据库将在一个步骤中复制；否则该方法一次循环复制 <em>pages</em> 规定数量的页面。</p><p>示例一，将现有数据库复制到另一个数据库中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">progress</span><span class="params">(status, remaining, total)</span>:</span></span><br><span class="line">    print(<span class="string">f'Copied <span class="subst">&#123;total-remaining&#125;</span> of <span class="subst">&#123;total&#125;</span> pages...'</span>)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">'existing_db.db'</span>)</span><br><span class="line">bck = sqlite3.connect(<span class="string">'backup.db'</span>)</span><br><span class="line"><span class="keyword">with</span> bck:</span><br><span class="line">    con.backup(bck, pages=<span class="number">1</span>, progress=progress)</span><br><span class="line">bck.close()</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p>示例二，将现有数据库复制到临时副本中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">source = sqlite3.connect(<span class="string">'existing_db.db'</span>)</span><br><span class="line">dest = sqlite3.connect(<span class="string">':memory:'</span>)</span><br><span class="line">source.backup(dest)</span><br></pre></td></tr></table></figure><p>可用性：SQLite 3.6.11 或以上版本</p></li></ul><h2 id="Cursor-对象"><a href="#Cursor-对象" class="headerlink" title="Cursor 对象"></a>Cursor 对象</h2><ul><li><p><em>class</em> <code>sqlite3.Cursor</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 游标实例具有以下属性和方法。</p><ul><li><p><code>execute</code>(<em>sql</em>[, <em>parameters</em>])</p><p>执行SQL语句。 可以是参数化 SQL 语句（即，在 SQL 语句中使用占位符）。<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块支持两种占位符：问号（qmark风格）和命名占位符（命名风格）。以下是两种风格的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table people (name_last, age)"</span>)</span><br><span class="line"></span><br><span class="line">who = <span class="string">"Yeltsin"</span></span><br><span class="line">age = <span class="number">72</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is the qmark style:</span></span><br><span class="line">cur.execute(<span class="string">"insert into people values (?, ?)"</span>, (who, age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># And this is the named style:</span></span><br><span class="line">cur.execute(<span class="string">"select * from people where name_last=:who and age=:age"</span>, &#123;<span class="string">"who"</span>: who, <span class="string">"age"</span>: age&#125;)</span><br><span class="line"></span><br><span class="line">print(cur.fetchone())</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> will only execute a single SQL statement. If you try to execute more than one statement with it, it will raise a <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Warning" target="_blank" rel="noopener"><code>Warning</code></a>. Use <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executescript" target="_blank" rel="noopener"><code>executescript()</code></a> if you want to execute multiple SQL statements with one call.</p></li></ul></li><li><p><code>executemany</code>(<em>sql</em>, <em>seq_of_parameters</em>)</p><p>通过所有参数序列或者映射参数 执行SQL 命令,同时支持使用<code>iterator</code>(可迭代对象) yield类型生成参数代替序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IterChars</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = ord(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.count &gt; ord(<span class="string">'z'</span>):</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (chr(self.count - <span class="number">1</span>),) <span class="comment"># this is a 1-tuple</span></span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table characters(c)"</span>)</span><br><span class="line"></span><br><span class="line">theIter = IterChars()</span><br><span class="line">cur.executemany(<span class="string">"insert into characters(c) values (?)"</span>, theIter)</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"select c from characters"</span>)</span><br><span class="line">print(cur.fetchall())</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><p>这是一个使用生成器 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 的简短示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">char_generator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> string.ascii_lowercase:</span><br><span class="line">        <span class="keyword">yield</span> (c,)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table characters(c)"</span>)</span><br><span class="line"></span><br><span class="line">cur.executemany(<span class="string">"insert into characters(c) values (?)"</span>, char_generator())</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"select c from characters"</span>)</span><br><span class="line">print(cur.fetchall())</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p><code>executescript</code>(<em>sql_script</em>)</p><p>这是一个非标准方式执行sql语句的方法,它首先执行<code>COMMIT</code>语句,然后执行作为参数传递而来的SQL语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.executescript(<span class="string">"""</span></span><br><span class="line"><span class="string">    create table person(</span></span><br><span class="line"><span class="string">        firstname,</span></span><br><span class="line"><span class="string">        lastname,</span></span><br><span class="line"><span class="string">        age</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    create table book(</span></span><br><span class="line"><span class="string">        title,</span></span><br><span class="line"><span class="string">        author,</span></span><br><span class="line"><span class="string">        published</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    insert into book(title, author, published)</span></span><br><span class="line"><span class="string">    values (</span></span><br><span class="line"><span class="string">        'Dirk Gently''s Holistic Detective Agency',</span></span><br><span class="line"><span class="string">        'Douglas Adams',</span></span><br><span class="line"><span class="string">        1987</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">    """</span>)</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure></li><li><p><code>fetchone</code>()</p><p>获取查询语句结果中的一条记录集,返回一个单独的序列,当没有数据时返回<code>None</code>。</p></li><li><p><code>fetchmany</code>(<em>size=cursor.arraysize</em>)</p><p>提取查询结果的下一组行，返回列表。当没有更多行可用时，将返回一个空列表。每个调用要提取的行数由 [size] 参数指定。如果未提供，则游标的数组大小确定要提取的行数。该方法应尝试提取大小参数指示的行数。如果由于指定的行数不可用而无法这样做，则返回的行数可能更少。请注意，[size] 参数涉及性能注意事项。为了获得最佳性能，通常最好使用数组大小属性。如果使用 [size] 参数，则最好将其保留从<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.fetchmany" target="_blank" rel="noopener"><code>fetchmany()</code></a> 方法调用到下一个相同的值。</p></li></ul><p>​        返回list类型存储的所有结果的行。如果没有记录返回,返回一个空的list。</p><ul><li><p><code>close</code>()</p><p>立即关闭游标(无论<code>__del__</code>方法是否被调用)。当前游标无法再获取上下文对象,如果尝试访问该游标,则会引发<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.ProgrammingError" target="_blank" rel="noopener"><code>ProgrammingError</code></a> 异常。</p></li><li><p><code>rowcount</code></p><p>对于  <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executemany" target="_blank" rel="noopener"><code>executemany()</code></a> 语句，修改次数汇总为 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.rowcount" target="_blank" rel="noopener"><code>rowcount</code></a>.根据 Python DB API 规范的要求，<code>rowcount</code> 属性在游标上未执行<code>executeXX()</code>或最后一个操作的行计数无法由接口决定的情况下为 -1。这包括<code>SELECT</code>语句，因为我们无法确定在提取所有行之前生成的查询的行数。</p></li><li><p><code>lastrowid</code></p><p>这是一个只读属性取得最后一条修改记录的rowid。仅当使用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.execute" target="_blank" rel="noopener"><code>execute()</code></a> 方法执行<code>INSERT</code> or a <code>REPLACE</code> 语句时设置该属性。或者 当执行<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.executemany" target="_blank" rel="noopener"><code>executemany()</code></a> 方法时,该属性设置为<code>None</code>。如果<code>INSERT</code> 或 <code>REPLACE</code> 语句执行失败时,则返回最近一次成功执行的rowid。</p></li><li><p><code>arraysize</code></p><p>该属性可读写,主要控制 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.fetchmany" target="_blank" rel="noopener"><code>fetchmany()</code></a>方法返回的记录数量。默认值是1意味着返回一行结果。</p></li><li><p><code>description</code></p><p>此只读属性提供最后一次查询的列名称。为了保持与 Python DB API 的兼容，它为每个列返回一个 7 元组，其中每个元组的最后六个项为 <code>None</code>.</p></li><li><p><code>connection</code></p><p>此只读属性提供SQLite数据库的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 使用的游标对象。</p></li></ul><h2 id="行对象"><a href="#行对象" class="headerlink" title="行对象"></a>行对象</h2><p><em>class</em> <code>sqlite3.Row</code></p><ul><li><p><code>keys</code>()</p><p>该方法返回列名构成的列表。查询后,在 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor.description" target="_blank" rel="noopener"><code>Cursor.description</code></a> 中元组数据的第一个元素.</p></li></ul><p>接下来我们在上面的例子中初始化一个table：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">conn = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">c = conn.cursor()</span><br><span class="line">c.execute(<span class="string">'''create table stocks</span></span><br><span class="line"><span class="string">(date text, trans text, symbol text,</span></span><br><span class="line"><span class="string"> qty real, price real)'''</span>)</span><br><span class="line">c.execute(<span class="string">"""insert into stocks</span></span><br><span class="line"><span class="string">          values ('2006-01-05','BUY','RHAT',100,35.14)"""</span>)</span><br><span class="line">conn.commit()</span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure><p>我们使用<code>Row</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn.row_factory = sqlite3.Row</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = conn.cursor()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.execute(<span class="string">'select * from stocks'</span>)</span><br><span class="line">&lt;sqlite3.Cursor object at <span class="number">0x7f4e7dd8fa80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = c.fetchone()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(r)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">sqlite3</span>.<span class="title">Row</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">tuple</span><span class="params">(r)</span></span></span><br><span class="line"><span class="class"><span class="params">(<span class="string">'2006-01-05'</span>, <span class="string">'BUY'</span>, <span class="string">'RHAT'</span>, <span class="number">100.0</span>, <span class="number">35.14</span>)</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">len</span><span class="params">(r)</span></span></span><br><span class="line"><span class="class">5</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">r</span>[2]</span></span><br><span class="line"><span class="class">'<span class="title">RHAT</span>'</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">r</span>.<span class="title">keys</span><span class="params">()</span></span></span><br><span class="line">['date', 'trans', 'symbol', 'qty', 'price']</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r[<span class="string">'qty'</span>]</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> member <span class="keyword">in</span> r:</span><br><span class="line"><span class="meta">... </span>    print(member)</span><br><span class="line">...</span><br><span class="line"><span class="number">2006</span><span class="number">-01</span><span class="number">-05</span></span><br><span class="line">BUY</span><br><span class="line">RHAT</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="number">35.14</span></span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><p><em>exception</em> <code>sqlite3.Warning</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>sqlite3.Error</code></p><p>此模块中其他异常的基类。 它是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>sqlite3.DatabaseError</code></p><p>抛出和数据库有关异常。</p></li><li><p><em>exception</em> <code>sqlite3.IntegrityError</code></p><p>抛出和关联标识符有关异常,例如外键检查失败,是<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.DatabaseError" target="_blank" rel="noopener"><code>DatabaseError</code></a>的一个子类。</p></li><li><p><em>exception</em> <code>sqlite3.ProgrammingError</code></p><p>抛出和程序有关的异常,例如：table未找到,或已经存在,SQL 语句异常,参数不正确, 是<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.DatabaseError" target="_blank" rel="noopener"><code>DatabaseError</code></a>的一个子类。</p></li><li><p><em>exception</em> <code>sqlite3.OperationalError</code></p><p>抛出和程序无法控制的数据库操作的异常,例如: 不可预料的数据库连接错误,数据源名字未找到,事务没有被执行,是<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.DatabaseError" target="_blank" rel="noopener"><code>DatabaseError</code></a>的一个子类。</p></li><li><p><em>exception</em> <code>sqlite3.NotSupportedError</code></p><p>抛出当一个方法对当前数据库不支持的异常,例如:调用 <code>rollback()</code>时,数据库事务不支持或者事务被关闭。是<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.DatabaseError" target="_blank" rel="noopener"><code>DatabaseError</code></a>的一个子类</p></li></ul><h2 id="SQLite-与-Python-类型"><a href="#SQLite-与-Python-类型" class="headerlink" title="SQLite 与 Python 类型"></a>SQLite 与 Python 类型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>SQLite 原生支持如下的类型： <code>NULL</code>，<code>INTEGER</code>，<code>REAL</code>，<code>TEXT</code>，<code>BLOB</code>。</p><table><thead><tr><th>Python 类型</th><th>SQLite 类型</th></tr></thead><tbody><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a></td><td><code>NULL</code></td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a></td><td><code>INTEGER</code></td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a></td><td><code>REAL</code></td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a></td><td><code>TEXT</code></td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a></td><td><code>BLOB</code></td></tr></tbody></table><p>这是SQLite类型默认转换为Python类型的方式：</p><table><thead><tr><th>SQLite 类型</th><th>Python 类型</th></tr></thead><tbody><tr><td><code>NULL</code></td><td><a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a></td></tr><tr><td><code>INTEGER</code></td><td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a></td></tr><tr><td><code>REAL</code></td><td><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a></td></tr><tr><td><code>TEXT</code></td><td>取决于 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.text_factory" target="_blank" rel="noopener"><code>text_factory</code></a> , 默认为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a></td></tr><tr><td><code>BLOB</code></td><td><a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a></td></tr></tbody></table><p> <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 中数据类型的扩展有两种途径: 一种是使用SQLite对象适配器扩展附加的Python数据类型；另一种是使用Python类型转换函数转换SQLite类型。</p><h3 id="使用适配器在SQLite中存储附加的python数据类型"><a href="#使用适配器在SQLite中存储附加的python数据类型" class="headerlink" title="使用适配器在SQLite中存储附加的python数据类型"></a>使用适配器在SQLite中存储附加的python数据类型</h3><p>正如之前描述的转换方法中说明的,SQLite只支持有限的几种数据类型。如果想在SQLite中使用Python的相关数据类型,你必须通过适配器,让SQLite的模块让SQLite支持诸如:  one of NoneType, int, float, str, bytes等类型。请看下面的例子:</p><h4 id="让对象自行调整"><a href="#让对象自行调整" class="headerlink" title="让对象自行调整"></a>让对象自行调整</h4><p>如果自己编写类，这是一种很好的方法。假设有这样的类：：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x, self.y = x, y</span><br></pre></td></tr></table></figure><p>我们想在SQLite中存储,首先选择何种数据类型存储这个<code>Point</code>类。</p><p>接下来使用类方法 <code>__conform__</code>返回转换后的值, 参数是 <code>PrepareProtocol</code>类型的<code>protocol</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__conform__</span><span class="params">(self, protocol)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> protocol <span class="keyword">is</span> sqlite3.PrepareProtocol:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"%f;%f"</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">4.0</span>, <span class="number">-3.2</span>)</span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (p,))</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><h4 id="注册可调用的适配器"><a href="#注册可调用的适配器" class="headerlink" title="注册可调用的适配器"></a>注册可调用的适配器</h4><p>另一个可行的方法时创建一个可以转换string和其他类型的函数,使用<a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.register_adapter" target="_blank" rel="noopener"><code>register_adapter()</code></a>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adapt_point</span><span class="params">(point)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"%f;%f"</span> % (point.x, point.y)</span><br><span class="line"></span><br><span class="line">sqlite3.register_adapter(Point, adapt_point)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">4.0</span>, <span class="number">-3.2</span>)</span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (p,))</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><p>对于Python中的内置数据类型 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.datetime" target="_blank" rel="noopener"><code>datetime.datetime</code></a> ,我们可以存储 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.datetime" target="_blank" rel="noopener"><code>datetime.datetime</code></a> 使用ISO 实现而非 Unix 时间戳。请参考下面的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adapt_datetime</span><span class="params">(ts)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> time.mktime(ts.timetuple())</span><br><span class="line"></span><br><span class="line">sqlite3.register_adapter(datetime.datetime, adapt_datetime)</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">cur.execute(<span class="string">"select ?"</span>, (now,))</span><br><span class="line">print(cur.fetchone()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><h3 id="将SQLite-值转换为自定义Python-类型"><a href="#将SQLite-值转换为自定义Python-类型" class="headerlink" title="将SQLite 值转换为自定义Python 类型"></a>将SQLite 值转换为自定义Python 类型</h3><p>让我们回到刚才定义的<code>Point</code> 类,在SQLite中存储<code>x</code>,<code>y</code>字符串类型参数。</p><p>首先我们定义一个转换函数,接收字符串类型的参数,转换为<code>Point</code>类的对象。</p><blockquote><p>转换函数通常处理的是<code>byte</code>类型对象,无论你传入的是什么类型 数据。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_point</span><span class="params">(s)</span>:</span></span><br><span class="line">    x, y = map(float, s.split(<span class="string">b";"</span>))</span><br><span class="line">    <span class="keyword">return</span> Point(x, y)</span><br></pre></td></tr></table></figure><p>现在我们需要让 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块知道你查询的是一个<code>point</code>对象，有两种方式实现:</p><ul><li>隐式的声明类型</li><li>显式的通过列名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"(%f;%f)"</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adapt_point</span><span class="params">(point)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"%f;%f"</span> % (point.x, point.y)).encode(<span class="string">'ascii'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_point</span><span class="params">(s)</span>:</span></span><br><span class="line">    x, y = list(map(float, s.split(<span class="string">b";"</span>)))</span><br><span class="line">    <span class="keyword">return</span> Point(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register the adapter</span></span><br><span class="line">sqlite3.register_adapter(Point, adapt_point)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register the converter</span></span><br><span class="line">sqlite3.register_converter(<span class="string">"point"</span>, convert_point)</span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">4.0</span>, <span class="number">-3.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#########################</span></span><br><span class="line"><span class="comment"># 1) Using declared types</span></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>, detect_types=sqlite3.PARSE_DECLTYPES)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(p point)"</span>)</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"insert into test(p) values (?)"</span>, (p,))</span><br><span class="line">cur.execute(<span class="string">"select p from test"</span>)</span><br><span class="line">print(<span class="string">"with declared types:"</span>, cur.fetchone()[<span class="number">0</span>])</span><br><span class="line">cur.close()</span><br><span class="line">con.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################</span></span><br><span class="line"><span class="comment"># 1) Using column names</span></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>, detect_types=sqlite3.PARSE_COLNAMES)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(p)"</span>)</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"insert into test(p) values (?)"</span>, (p,))</span><br><span class="line">cur.execute(<span class="string">'select p as "p [point]" from test'</span>)</span><br><span class="line">print(<span class="string">"with column names:"</span>, cur.fetchone()[<span class="number">0</span>])</span><br><span class="line">cur.close()</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><h3 id="默认适配器和转换器"><a href="#默认适配器和转换器" class="headerlink" title="默认适配器和转换器"></a>默认适配器和转换器</h3><p>对于时间和 日期时间类型, sqlite模块已经做了自动转换。</p><p>下面的示例演示了这一点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>, detect_types=sqlite3.PARSE_DECLTYPES|sqlite3.PARSE_COLNAMES)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"create table test(d date, ts timestamp)"</span>)</span><br><span class="line"></span><br><span class="line">today = datetime.date.today()</span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">"insert into test(d, ts) values (?, ?)"</span>, (today, now))</span><br><span class="line">cur.execute(<span class="string">"select d, ts from test"</span>)</span><br><span class="line">row = cur.fetchone()</span><br><span class="line">print(today, <span class="string">"=&gt;"</span>, row[<span class="number">0</span>], type(row[<span class="number">0</span>]))</span><br><span class="line">print(now, <span class="string">"=&gt;"</span>, row[<span class="number">1</span>], type(row[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">cur.execute(<span class="string">'select current_date as "d [date]", current_timestamp as "ts [timestamp]"'</span>)</span><br><span class="line">row = cur.fetchone()</span><br><span class="line">print(<span class="string">"current_date"</span>, row[<span class="number">0</span>], type(row[<span class="number">0</span>]))</span><br><span class="line">print(<span class="string">"current_timestamp"</span>, row[<span class="number">1</span>], type(row[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><h2 id="控制事务"><a href="#控制事务" class="headerlink" title="控制事务"></a>控制事务</h2><p>默认<code>sqlite3</code>中对于<code>autocommit</code> 默认是开启的,但是Python中的<code>sqlite3</code>模块默认并没有开启。</p><p><code>autocommit</code> 模式意味着当修改数据库时对数据库影响立即生效。一个<code>BEGIN</code> 和 <code>SAVEPOINT</code>的语句禁止<code>automode</code>,如果是<code>COMMIT</code>，<code>ROLLBACK</code> 或<code>RELASE</code> 语句执行后,<code>autocommit</code>模式才设置成启用。</p><p>Python  <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a>  默认在DDL 语句( (例如: <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>/<code>REPLACE</code>).)执行前执行<code>BEGIN</code> 语句。</p><p>你可以通过控制 <code>BEGIN</code> 语句,隐式执行<code>connect()</code>方法的 <em>isolation_level</em> 参数,或是connections的 <em>isolation_level</em> 属性来实现。如果你没有声明 isolation_level,那么使用的就是普通的<code>BEGIN</code>使用,和<code>DEFERRED</code>是一样的。其他可能的值还有<code>IMMEDIATE</code> 和 <code>EXCLUSIVE</code>。</p><p>你可以在代码中通过禁止 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块中设定 control the transaction state 的值为<code>BEGIN</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code>, and <code>RELEASE</code> 语句实现事务处理。</p><h2 id="有效使用-sqlite3"><a href="#有效使用-sqlite3" class="headerlink" title="有效使用 sqlite3"></a>有效使用 <code>sqlite3</code></h2><h3 id="使用快捷方式"><a href="#使用快捷方式" class="headerlink" title="使用快捷方式"></a>使用快捷方式</h3><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象的非标准 <code>execute()</code>, <code>executemany()</code> 和 <code>executescript()</code> 方法，可以更简洁地编写代码，因为不必显式创建（通常是多余的） <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 对象。相反， <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Cursor" target="_blank" rel="noopener"><code>Cursor</code></a> 对象是隐式创建的，这些快捷方法返回游标对象。这样，只需对 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection" target="_blank" rel="noopener"><code>Connection</code></a> 对象调用一次，就能直接执行 <code>SELECT</code> 语句并遍历对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">persons = [</span><br><span class="line">    (<span class="string">"Hugo"</span>, <span class="string">"Boss"</span>),</span><br><span class="line">    (<span class="string">"Calvin"</span>, <span class="string">"Klein"</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the table</span></span><br><span class="line">con.execute(<span class="string">"create table person(firstname, lastname)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the table</span></span><br><span class="line">con.executemany(<span class="string">"insert into person(firstname, lastname) values (?, ?)"</span>, persons)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the table contents</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> con.execute(<span class="string">"select firstname, lastname from person"</span>):</span><br><span class="line">    print(row)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"I just deleted"</span>, con.execute(<span class="string">"delete from person"</span>).rowcount, <span class="string">"rows"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># close is not a shortcut method and it's not called automatically,</span></span><br><span class="line"><span class="comment"># so the connection object should be closed manually</span></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><h3 id="通过名称而不是索引访问索引"><a href="#通过名称而不是索引访问索引" class="headerlink" title="通过名称而不是索引访问索引"></a>通过名称而不是索引访问索引</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#module-sqlite3" target="_blank" rel="noopener"><code>sqlite3</code></a> 模块的一个有用功能是内置的 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Row" target="_blank" rel="noopener"><code>sqlite3.Row</code></a> 类，该类旨在用作行工厂。</p><p>该类的行装饰器可以用索引（如元组）和不区分大小写的名称访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.row_factory = sqlite3.Row</span><br><span class="line"></span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">"select 'John' as name, 42 as age"</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cur:</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="number">0</span>] == row[<span class="string">"name"</span>]</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="string">"name"</span>] == row[<span class="string">"nAmE"</span>]</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="number">1</span>] == row[<span class="string">"age"</span>]</span><br><span class="line">    <span class="keyword">assert</span> row[<span class="number">1</span>] == row[<span class="string">"AgE"</span>]</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><h3 id="使用连接作为上下文管理器"><a href="#使用连接作为上下文管理器" class="headerlink" title="使用连接作为上下文管理器"></a>使用连接作为上下文管理器</h3><p>连接对象可以用来作为上下文管理器，它可以自动提交或者回滚事务。如果出现异常，事务会被回滚；否则，事务会被提交。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line">con = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">con.execute(<span class="string">"create table person (id integer primary key, firstname varchar unique)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Successful, con.commit() is called automatically afterwards</span></span><br><span class="line"><span class="keyword">with</span> con:</span><br><span class="line">    con.execute(<span class="string">"insert into person(firstname) values (?)"</span>, (<span class="string">"Joe"</span>,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># con.rollback() is called after the with block finishes with an exception, the</span></span><br><span class="line"><span class="comment"># exception is still raised and must be caught</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> con:</span><br><span class="line">        con.execute(<span class="string">"insert into person(firstname) values (?)"</span>, (<span class="string">"Joe"</span>,))</span><br><span class="line"><span class="keyword">except</span> sqlite3.IntegrityError:</span><br><span class="line">    print(<span class="string">"couldn't add Joe twice"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connection object used as context manager only commits or rollbacks transactions,</span></span><br><span class="line"><span class="comment"># so the connection object should be closed manually</span></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>较老版本的 SQLite 在共享线程之间存在连接问题。这就是Python模块不允许线程之间共享连接和游标的原因。如果仍然尝试这样做，则在运行时会出现异常。</p><p>唯一的例外是调用 <a href="https://docs.python.org/zh-cn/3.8/library/sqlite3.html#sqlite3.Connection.interrupt" target="_blank" rel="noopener"><code>interrupt()</code></a> 方法，该方法仅在从其他线程进行调用时才有意义。</p><h2 id="关于事务的补充说明"><a href="#关于事务的补充说明" class="headerlink" title="关于事务的补充说明"></a>关于事务的补充说明</h2><p><code>isolation_level</code> 到底控制的是什么,下图摘自SQLite官网。</p><p><img src="http://static.oschina.net/uploads/img/201607/27151258_jtqf.gif" alt></p><p>下面是一个在connect()中不传入 isolation_level的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">'''sqlite3事务总结:</span></span><br><span class="line"><span class="string">在connect()中不传入 isolation_level</span></span><br><span class="line"><span class="string">事务处理:</span></span><br><span class="line"><span class="string">    使用connection.commit()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">分析:</span></span><br><span class="line"><span class="string">    智能commit状态:</span></span><br><span class="line"><span class="string">        生成方式: 在connect()中不传入 isolation_level, 此时isolation_level==''</span></span><br><span class="line"><span class="string">            在进行 执行Data Modification Language (DML) 操作(INSERT/UPDATE/DELETE/REPLACE)时, 会自动打开一个事务,</span></span><br><span class="line"><span class="string">            在执行 非DML, 非query (非 SELECT 和上面提到的)语句时, 会隐式执行commit</span></span><br><span class="line"><span class="string">            可以使用 connection.commit()方法来进行提交</span></span><br><span class="line"><span class="string">        注意:</span></span><br><span class="line"><span class="string">            不能和cur.execute("COMMIT")共用</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    自动commit状态:</span></span><br><span class="line"><span class="string">        生成方式: 在connect()中传入 isolation_level=None</span></span><br><span class="line"><span class="string">            这样,在任何DML操作时,都会自动提交</span></span><br><span class="line"><span class="string">        事务处理</span></span><br><span class="line"><span class="string">            connection.execute("BEGIN TRANSACTION")</span></span><br><span class="line"><span class="string">            connection.execute("COMMIT")</span></span><br><span class="line"><span class="string">        如果不使用事务, 批量添加数据非常缓慢</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数据对比:</span></span><br><span class="line"><span class="string">    两种方式, 事务耗时差别不大</span></span><br><span class="line"><span class="string">    count = 100000</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.621</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.601</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.588</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.581</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.598</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.588</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.589</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.602</span></span><br><span class="line"><span class="string">        智能commit即时提交耗时: 0.588</span></span><br><span class="line"><span class="string">        自动commit耗时: 0.622</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Elapse_time</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''耗时统计工具'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, prompt=<span class="string">''</span>)</span>:</span></span><br><span class="line">        self.prompt = prompt</span><br><span class="line">        self.start = time.time()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s耗时: %.3f'</span> % (self.prompt, time.time() - self.start))</span><br><span class="line">CElapseTime = Elapse_time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">'e:/temp/a.db'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepare</span><span class="params">(isolation_level = <span class="string">''</span>)</span>:</span></span><br><span class="line">    connection = sqlite3.connect(filename, isolation_level = isolation_level)</span><br><span class="line">    connection.execute(<span class="string">"create table IF NOT EXISTS  people (num, age)"</span>)</span><br><span class="line">    connection.execute(<span class="string">'delete from people'</span>)</span><br><span class="line">    connection.commit()</span><br><span class="line">    <span class="keyword">return</span> connection, connection.cursor()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">db_insert_values</span><span class="params">(cursor, count)</span>:</span></span><br><span class="line">    num = <span class="number">1</span> </span><br><span class="line">    age = <span class="number">2</span> * num </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> num &lt;= count:</span><br><span class="line">        cursor.execute(<span class="string">"insert into people values (?, ?)"</span>, (num, age))</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        age = <span class="number">2</span> * num </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">study_case1_intelligent_commit</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    在智能commit状态下, 不能和cur.execute("COMMIT")共用</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    connection, cursor = prepare()</span><br><span class="line">    </span><br><span class="line">    elapse_time = Elapse_time(<span class="string">'  智能commit'</span>)</span><br><span class="line">    db_insert_values(cursor, count)</span><br><span class="line">    <span class="comment">#cursor.execute("COMMIT")  #产生异常</span></span><br><span class="line">    </span><br><span class="line">    cursor.execute(<span class="string">"select count(*) from people"</span>)</span><br><span class="line">    <span class="keyword">print</span> (cursor.fetchone())</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">study_case2_autocommit</span><span class="params">(count)</span>:</span></span><br><span class="line">    connection, cursor = prepare(isolation_level = <span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    elapse_time = Elapse_time(<span class="string">'  自动commit'</span>)</span><br><span class="line">    db_insert_values(cursor, count)</span><br><span class="line">    </span><br><span class="line">    cursor.execute(<span class="string">"select count(*) from people"</span>)    </span><br><span class="line">    <span class="keyword">print</span> (cursor.fetchone())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">study_case3_intelligent_commit_manual</span><span class="params">(count)</span>:</span></span><br><span class="line">    connection, cursor = prepare()</span><br><span class="line">    </span><br><span class="line">    elapse_time = Elapse_time(<span class="string">'  智能commit即时提交'</span>)</span><br><span class="line">    db_insert_values(cursor, count)</span><br><span class="line">    connection.commit()</span><br><span class="line">    </span><br><span class="line">    cursor.execute(<span class="string">"select count(*) from people"</span>)</span><br><span class="line">    <span class="keyword">print</span> (cursor.fetchone())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">study_case4_autocommit_transaction</span><span class="params">(count)</span>:</span></span><br><span class="line">    connection, cursor = prepare(isolation_level = <span class="literal">None</span>)</span><br><span class="line">    </span><br><span class="line">    elapse_time = Elapse_time(<span class="string">'  自动commit'</span>)</span><br><span class="line">    connection.execute(<span class="string">"BEGIN TRANSACTION;"</span>) <span class="comment"># 关键点</span></span><br><span class="line">    db_insert_values(cursor, count)</span><br><span class="line">    connection.execute(<span class="string">"COMMIT;"</span>)  <span class="comment">#关键点</span></span><br><span class="line">    </span><br><span class="line">    cursor.execute(<span class="string">"select count(*) from people;"</span>)</span><br><span class="line">    <span class="keyword">print</span> (cursor.fetchone())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    count = <span class="number">10000</span></span><br><span class="line">    prepare()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="comment">#study_case1_intelligent_commit(count) #不提交数据</span></span><br><span class="line">        <span class="comment">#study_case2_autocommit(count)  #非常缓慢</span></span><br><span class="line">        study_case3_intelligent_commit_manual(count)</span><br><span class="line">        study_case4_autocommit_transaction(count)</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://my.oschina.net/tinyhare/blog/719039" target="_blank" rel="noopener">python sqlite3 事务控制</a></p><p><a href="https://www.cnblogs.com/yaoyu126/p/6413423.html" target="_blank" rel="noopener">python sqlite3 事务总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-sqlite3&quot;&gt;&lt;a href=&quot;#python-标准库-sqlite3&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 sqlite3&quot;&gt;&lt;/a&gt;python 标准库 sqlite3&lt;/h1&gt;&lt;p&gt;今天是二十四节气的大寒&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大寒，是&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%8C%E5%8D%81%E5%9B%9B%E8%8A%82%E6%B0%94/191597&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二十四节气&lt;/a&gt;中的最后一个节气。斗指丑；太阳&lt;a href=&quot;https://baike.baidu.com/item/%E9%BB%84%E7%BB%8F/8303112&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;黄经&lt;/a&gt;为300°；公历1月20－21日交节。同小寒一样，大寒也是表示天气寒冷程度的节气。在我国部分地区，大寒不如小寒冷，但在某些年份和沿海少数地方，全年最低气温仍然会出现在大寒节气内。小寒、大寒是一年中雨水最少的时段。&lt;/p&gt;
&lt;p&gt;兹大寒一过，新一年的节气就又轮回来了，正所谓冬去春来。大寒虽然寒冷，但因为已近春天，所以不会像大雪到冬至期间那样酷寒。这时节，人们开始忙着除旧饰新、腌制年肴、准备年货和各种祭祀供品、扫尘洁物，因为中国人最重要的节日——春节就要到了。&lt;/p&gt;
&lt;p&gt;每日一词：&lt;/p&gt;
&lt;p&gt;Cold &lt;/p&gt;
&lt;p&gt;adj 冷,寒冷&lt;/p&gt;
&lt;p&gt;例句：&lt;/p&gt;
&lt;p&gt;  It is the last one in January 20th of each year twenty-four solar term solar term, before and after the sun reaches 300 degrees for it”. It is cold weather, meaning extreme.&lt;/p&gt;
&lt;p&gt; 大寒是二十四节气中最后一个节气，每年1月20日前后太阳到达黄经300°时为”大寒”。大寒，是天气寒冷到极点的意思。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://photos.tuchong.com/350832/f/4959845.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="sqlite3" scheme="https://pinghailinfeng.gitee.io/tags/sqlite3/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
  </entry>
  
  <entry>
    <title>Understand Python GIL</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/19/Understand-Python-GIL/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/19/Understand-Python-GIL/</id>
    <published>2020-01-19T01:32:12.000Z</published>
    <updated>2020-01-30T08:43:58.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-threading"><a href="#python-标准库-threading" class="headerlink" title="python 标准库 threading"></a>python 标准库 threading</h1><p>每日一词:</p><blockquote><p>US[‘weðər]  UK[‘weðə(r)]</p><p>n.天气；气象；气象预报</p><p>v.变形；经受住</p><p>气候；天气预报；风化</p><p>给大家推荐一部电影: 气象先生</p></blockquote><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200119_weather_man.jpg?raw=tru" alt></p><blockquote><p>This shit life,we must chuck some things</p></blockquote><a id="more"></a><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/threading.py" target="_blank" rel="noopener">Lib/threading.py</a></p><h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><ul><li><p><code>threading.active_count</code>()</p><p>返回当前存活的线程类 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>Thread</code></a> 对象。返回的计数等于 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a> 返回的列表长度。</p></li><li><p><code>threading.current_thread</code>()</p><p>返回当前对应调用者的控制线程的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>Thread</code></a> 对象。如果调用者的控制线程不是利用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#module-threading" target="_blank" rel="noopener"><code>threading</code></a> 创建，会返回一个功能受限的虚拟线程对象。</p></li><li><p><code>threading.excepthook</code>(<em>args</em>, <em>/</em>)</p><p>参数可以是下面任意一种类型</p><ul><li><em>exc_type</em>: 异常类型</li><li><em>exc_value</em>: 异常值，可以是 <code>None</code>.</li><li><em>exc_traceback</em>: 异常回溯，可以是 <code>None</code>.</li><li><em>thread</em>: 线程跑出的异常 可以是<code>None</code>.</li></ul></li><li><p><code>threading.get_ident</code>()</p><p>返回当前线程的 “线程标识符”。它是一个非零的整数。它的值没有直接含义，主要是用作 magic cookie，比如作为含有线程相关数据的字典的索引。线程标识符可能会在线程退出，新线程创建时被复用。<em>3.3 新版功能.</em></p></li><li><p><code>threading.get_native_id</code>()</p><p>返回内核分配给当前线程的原生集成线程 ID。 这是一个非负整数。 它的值可被用来在整个系统中唯一地标识这个特定线程（直到线程终结，在那之后该值可能会被 OS 回收再利用）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows, FreeBSD, Linux, macOS, OpenBSD, NetBSD, AIX。<em>3.8 新版功能.</em></p></li><li><p><code>threading.enumerate</code>()</p><p>以列表形式返回当前所有存活的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>Thread</code></a> 对象。 该列表包含守护线程，<a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.current_thread" target="_blank" rel="noopener"><code>current_thread()</code></a> 创建的虚拟线程对象和主线程。它不包含已终结的线程和尚未开始的线程。</p></li><li><p><code>threading.main_thread</code>()</p><p>返回主 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>Thread</code></a> 对象。一般情况下，主线程是Python解释器开始时创建的线程。<em>3.4 新版功能.</em></p></li><li><p><code>threading.settrace</code>(<em>func</em>)</p><p>为所有 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#module-threading" target="_blank" rel="noopener"><code>threading</code></a> 模块开始的线程设置追踪函数。在每个线程的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法被调用前，<em>func</em> 会被传递给 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.settrace" target="_blank" rel="noopener"><code>sys.settrace()</code></a> 。</p></li><li><p><code>threading.setprofile</code>(<em>func</em>)</p><p>为所有 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#module-threading" target="_blank" rel="noopener"><code>threading</code></a> 模块开始的线程设置性能测试函数。在每个线程的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法被调用前，<em>func</em> 会被传递给 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.setprofile" target="_blank" rel="noopener"><code>sys.setprofile()</code></a> 。</p></li><li><p><code>threading.stack_size</code>([<em>size</em>])</p><p>返回创建线程时用的堆栈大小。可选参数 <em>size</em> 指定之后新建的线程的堆栈大小，而且一定要是0（根据平台或者默认配置）或者最小是32,768(32KiB)的一个正整数。如果 <em>size</em> 没有指定，默认是0。如果不支持改变线程堆栈大小，会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 错误。如果指定的堆栈大小不合法，会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 错误并且不会修改堆栈大小。32KiB是当前最小的能保证解释器有足够堆栈空间的堆栈大小。需要注意的是部分平台对于堆栈大小会有特定的限制，例如要求大于32KiB的堆栈大小或者需要根据系统内存页面的整数倍进行分配 - 应当查阅平台文档有关详细信息（4KiB页面比较普遍，在没有更具体信息的情况下，建议的方法是使用4096的倍数作为堆栈大小）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">适用于</a>: Windows，具有 POSIX 线程的系统。</p></li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><code>threading.TIMEOUT_MAX</code><a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.TIMEOUT_MAX" target="_blank" rel="noopener">¶</a></p><p>  阻塞函数（ <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>Lock.acquire()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock.acquire" target="_blank" rel="noopener"><code>RLock.acquire()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>Condition.wait()</code></a>, …）中形参 <em>timeout</em> 允许的最大值。传入超过这个值的 timeout 会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a> 异常。</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="线程本地数据"><a href="#线程本地数据" class="headerlink" title="线程本地数据"></a>线程本地数据</h3><p>线程本地数据是特定线程的数据。管理线程本地数据，只需要创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.local" target="_blank" rel="noopener"><code>local</code></a> （或者一个子类型）的实例并在实例中储存属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mydata = threading.local()</span><br><span class="line">mydata.x = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在不同的线程中，实例的值会不同。</p><ul><li><p><em>class</em> <code>threading.local</code></p><p>一个代表线程本地数据的类。更多相关细节和大量示例，参见 <code>_threading_local</code> 模块的文档。</p></li></ul><h3 id="线程对象"><a href="#线程对象" class="headerlink" title="线程对象"></a>线程对象</h3><p>当线程对象一但被创建，其活动一定会因调用线程的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.start" target="_blank" rel="noopener"><code>start()</code></a> 方法开始。这会在独立的控制线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法。</p><p>一旦线程活动开始，该线程会被认为是 ‘存活的’ 。当它的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法终结了（不管是正常的还是抛出未被处理的异常），就不是’存活的’。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.is_alive" target="_blank" rel="noopener"><code>is_alive()</code></a> 方法用于检查线程是否存活。</p><p>其他线程可以调用一个线程的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 方法。这会阻塞调用该方法的线程，直到被调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 方法的线程终结。</p><p>线程有名字。名字可以传递给构造函数，也可以通过 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.name" target="_blank" rel="noopener"><code>name</code></a> 属性读取或者修改。</p><p>如果运行线程中的 <code>run()</code>抛出了异常, <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.excepthook" target="_blank" rel="noopener">threading.excepthook()`</a> 方法就会被调用,默认情况下,忽略 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SystemExit" target="_blank" rel="noopener"><code>SystemExit</code></a>.</p><p>一个线程可以被标记成一个“守护线程”。 这个标志的意义是，当剩下的线程都是守护线程时，整个 Python 程序将会退出。 初始值继承于创建线程。 这个标志可以通过 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.daemon" target="_blank" rel="noopener"><code>daemon</code></a> 特征属性或者 <em>daemon</em> 构造器参数来设置。</p><blockquote><p>守护线程在程序关闭时会突然关闭。他们的资源（例如已经打开的文档，数据库事务等等）可能没有被正确释放。如果你想你的线程正常停止，设置他们成为非守护模式并且使用合适的信号机制，例如： <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event" target="_blank" rel="noopener"><code>Event</code></a>。</p></blockquote><p>有个 “主线程” 对象；这对应Python程序里面初始的控制线程。它不是一个守护线程。</p><p>“虚拟线程对象” 是可以被创建的。这些是对应于“外部线程”的线程对象，它们是在线程模块外部启动的控制线程，例如直接来自C代码。虚拟线程对象功能受限；他们总是被认为是存活的和守护模式，不能被 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 。因为无法检测外来线程的终结，它们永远不会被删除。</p><p><em>class</em> <code>threading.Thread</code>(<em>group=None</em>, <em>target=None</em>, <em>name=None</em>, <em>args=()</em>, <em>kwargs={}</em>, <em>**, </em>daemon=None*)</p><p>调用这个构造函数时，必需带有关键字参数。参数如下：</p><p><em>group</em> 应该为 <code>None</code>；为了日后扩展 <code>ThreadGroup</code> 类实现而保留。</p><p><em>target</em> 是用于 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法调用的可调用对象。默认是 <code>None</code>，表示不需要调用任何方法。</p><p><em>name</em> 是线程名称。默认情况下，由 “Thread-<em>N</em>“ 格式构成一个唯一的名称，其中 <em>N</em> 是小的十进制数。</p><p><em>args</em> 是用于调用目标函数的参数元组。默认是 <code>()</code>。</p><p><em>kwargs</em> 是用于调用目标函数的关键字参数字典。默认是 <code>{}</code>。</p><ul><li><p><code>start</code>()</p><p>开始线程活动。它在一个线程里最多只能被调用一次。它安排对象的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法在一个独立的控制进程中调用。如果同一个线程对象中调用这个方法的次数大于一次，会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 。</p></li><li><p><code>run</code>()</p><p>代表线程活动的方法。你可以在子类型里重载这个方法。 标准的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法会对作为 <em>target</em> 参数传递给该对象构造器的可调用对象（如果存在）发起调用，并附带从 <em>args</em> 和 <em>kwargs</em> 参数分别获取的位置和关键字参数。</p></li><li><p><code>join</code>(<em>timeout=None</em>)</p><p>等待，直到线程终结。这会阻塞调用这个方法的线程，直到被调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 的线程终结 – 不管是正常终结还是抛出未处理异常 – 或者直到发生超时，超时选项是可选的。当 <em>timeout</em> 参数存在而且不是 <code>None</code> 时，它应该是一个用于指定操作超时的以秒为单位的浮点数（或者分数）。因为 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 总是返回 <code>None</code> ，所以你一定要在 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 后调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.is_alive" target="_blank" rel="noopener"><code>is_alive()</code></a> 才能判断是否发生超时 – 如果线程仍然存货，则 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 超时。当 <em>timeout</em> 参数不存在或者是 <code>None</code> ，这个操作会阻塞直到线程终结。一个线程可以被 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 很多次。如果尝试加入当前线程会导致死锁， <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 会引起 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常。如果尝试 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.join" target="_blank" rel="noopener"><code>join()</code></a> 一个尚未开始的线程，也会抛出相同的异常。</p></li><li><p><code>name</code></p><p>只用于识别的字符串。它没有语义。多个线程可以赋予相同的名称。 初始名称由构造函数设置。</p></li><li><p><code>getName</code>()</p></li><li><p><code>setName</code>()</p><p>旧的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.name" target="_blank" rel="noopener"><code>name</code></a> 取值/设值 API；直接当做特征属性使用它。</p></li><li><p><code>ident</code></p><p>这个线程的 ‘线程标识符’，如果线程尚未开始则为 <code>None</code> 。这是个非零整数。参见 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.get_ident" target="_blank" rel="noopener"><code>get_ident()</code></a> 函数。当一个线程退出而另外一个线程被创建，线程标识符会被复用。即使线程退出后，仍可得到标识符。</p></li><li><p><strong>native_id</strong></p><p>内部生成的线程id,一个非负的整数,如果为<code>None</code>意味着线程还没有启动。</p></li><li><p><code>is_alive</code>()</p><p>返回线程是否存活。当 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法刚开始直到 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.run" target="_blank" rel="noopener"><code>run()</code></a> 方法刚结束，这个方法返回 <code>True</code> 。模块函数 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.enumerate" target="_blank" rel="noopener"><code>enumerate()</code></a> 返回包含所有存活线程的列表。</p></li><li><p><code>daemon</code></p><p>一个表示这个线程是（True）否（False）守护线程的布尔值。一定要在调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.start" target="_blank" rel="noopener"><code>start()</code></a> 前设置好，不然会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 。初始值继承于创建线程；主线程不是守护线程，因此主线程创建的所有线程默认都是 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.daemon" target="_blank" rel="noopener"><code>daemon</code></a> = <code>False</code>。当没有存活的非守护线程时，整个Python程序才会退出。</p></li><li><p><code>isDaemon</code>()</p></li><li><p><code>setDaemon</code>()</p><p>旧的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread.name" target="_blank" rel="noopener"><code>name</code></a> 取值/设值 API；建议直接当做特征属性使用它。</p></li></ul><p><strong>CPython implementation detail:</strong> CPython下，因为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-global-interpreter-lock" target="_blank" rel="noopener">Global Interpreter Lock</a>，一个时刻只有一个线程可以执行Python代码（尽管如此，某些性能导向的库可能会克服这个限制）。如果你想让你的应用更好的利用多核计算机的计算性能，推荐你使用 <a href="https://docs.python.org/zh-cn/3.8/library/multiprocessing.html#module-multiprocessing" target="_blank" rel="noopener"><code>multiprocessing</code></a> 或者 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" target="_blank" rel="noopener"><code>concurrent.futures.ProcessPoolExecutor</code></a> 。但是如果你想同时运行多个I/O绑定任务，线程仍然是一个合适的模型。</p><h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3><p>原始锁是一个在锁定时不属于特定线程的同步基元组件。在Python中，它是能用的最低级的同步基元组件，由 <a href="https://docs.python.org/zh-cn/3.8/library/_thread.html#module-_thread" target="_blank" rel="noopener"><code>_thread</code></a> 扩展模块直接实现。</p><p>原始锁处于 “锁定” 或者 “非锁定” 两种状态之一。它被创建时为非锁定状态。它有两个基本方法， <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> 。当状态为非锁定时， <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 将状态改为 锁定 并立即返回。当状态是锁定时， <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 将阻塞至其他线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> 将其改为非锁定状态，然后 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 调用重置其为锁定状态并返回。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> 只在锁定状态下调用； 它将状态改为非锁定并立即返回。如果尝试释放一个非锁定的锁，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>  异常。</p><p>锁同样支持 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#with-locks" target="_blank" rel="noopener">上下文管理协议</a>。</p><p>当多个线程在 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 等待状态转变为未锁定被阻塞，然后 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> 重置状态为未锁定时，只有一个线程能继续执行；至于哪个等待线程继续执行没有定义，并且会根据实现而不同。</p><p>所有方法的执行都是原子性的。</p><p><em>class</em> <code>threading.Lock</code></p><p>实现原始锁对象的类。一旦一个线程获得一个锁，会阻塞随后尝试获得锁的线程，直到它被释放；任何线程都可以释放它。</p><p>需要注意的是 <code>Lock</code> 其实是一个工厂函数，返回平台支持的具体锁类中最有效的版本的实例。</p><ul><li><p><code>acquire</code>(<em>blocking=True</em>, <em>timeout=-1</em>)</p><p>可以阻塞或非阻塞地获得锁。当调用时参数 <em>blocking</em> 设置为 <code>True</code> （缺省值），阻塞直到锁被释放，然后将锁锁定并返回 <code>True</code> 。在参数 <em>blocking</em> 被设置为 <code>False</code> 的情况下调用，将不会发生阻塞。如果调用时 <em>blocking</em> 设为 <code>True</code> 会阻塞，并立即返回 <code>False</code> ；否则，将锁锁定并返回 <code>True</code>。当浮点型 <em>timeout</em> 参数被设置为正值调用时，只要无法获得锁，将最多阻塞 <em>timeout</em> 设定的秒数。<em>timeout</em> 参数被设置为 <code>-1</code> 时将无限等待。当 <em>blocking</em> 为 false 时，<em>timeout</em> 指定的值将被忽略。如果成功获得锁，则返回 <code>True</code>，否则返回 <code>False</code> (例如发生 <em>超时</em> 的时候)。<em>在 3.2 版更改:</em> 新的 <em>timeout</em> 形参。<em>在 3.2 版更改:</em> 现在如果底层线程实现支持，则可以通过POSIX上的信号中断锁的获取。</p></li><li><p><code>release</code>()</p><p>释放一个锁。这个方法可以在任何线程中调用，不单指获得锁的线程。当锁被锁定，将它重置为未锁定，并返回。如果其他线程正在等待这个锁解锁而被阻塞，只允许其中一个允许。在未锁定的锁调用时，会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常。没有返回值。</p></li><li><p><code>locked</code>()</p><p>Return true if the lock is acquired.</p></li></ul><h3 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h3><p>重入锁是一个可以被同一个线程多次获取的同步基元组件。在内部，它在基元锁的锁定/非锁定状态上附加了 “所属线程” 和 “递归等级” 的概念。在锁定状态下，某些线程拥有锁 ； 在非锁定状态下， 没有线程拥有它。</p><p>若要锁定锁，线程调用其 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 方法；一旦线程拥有了锁，方法将返回。若要解锁，线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> 方法。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a>/<a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> 对可以嵌套；只有最终 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> (最外面一对的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.release" target="_blank" rel="noopener"><code>release()</code></a> ) 将锁解开，才能让其他线程继续处理 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 阻塞。</p><p>递归锁也支持 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#with-locks" target="_blank" rel="noopener">上下文管理协议</a>。</p><p><em>class</em> <code>threading.RLock</code></p><p>此类实现了重入锁对象。重入锁必须由获取它的线程释放。一旦线程获得了重入锁，同一个线程再次获取它将不阻塞；线程必须在每次获取它时释放一次。需要注意的是 <code>RLock</code> 其实是一个工厂函数，返回平台支持的具体递归锁类中最有效的版本的实例。</p><ul><li><p><code>acquire</code>(<em>blocking=True</em>, <em>timeout=-1</em>)</p><p>可以阻塞或非阻塞地获得锁。</p><p>当无参数调用时： 如果这个线程已经拥有锁，递归级别增加一，并立即返回。否则，如果其他线程拥有该锁，则阻塞至该锁解锁。一旦锁被解锁(不属于任何线程)，则抢夺所有权，设置递归等级为一，并返回。如果多个线程被阻塞，等待锁被解锁，一次只有一个线程能抢到锁的所有权。在这种情况下，没有返回值。</p><p>当发起调用时将 <em>blocking</em> 参数设为真值，则执行与无参数调用时一样的操作，然后返回 <code>True</code>。</p><p>当发起调用时将 <em>blocking</em> 参数设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 <code>False</code>；在其他情况下，执行与无参数调用时一样的操作，然后返回 <code>True</code>。</p><p>当发起调用时将浮点数的 <em>timeout</em> 参数设为正值时，只要无法获得锁，将最多阻塞 <em>timeout</em> 所指定的秒数。 如果已经获得锁则返回 <code>True</code>，如果超时则返回假值。</p></li><li><p><code>release</code>()</p><p>释放锁，自减递归等级。如果减到零，则将锁重置为非锁定状态(不被任何线程拥有)，并且，如果其他线程正被阻塞着等待锁被解锁，则仅允许其中一个线程继续。如果自减后，递归等级仍然不是零，则锁保持锁定，仍由调用线程拥有。</p><p>只有当前线程拥有锁才能调用这个方法。如果锁被释放后调用这个方法，会引起 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常。</p><p>没有返回值。</p></li></ul><h3 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h3><p>条件变量总是与某种类型的锁对象相关联，锁对象可以通过传入获得，或者在缺省的情况下自动创建。当多个条件变量需要共享同一个锁时，传入一个锁很有用。锁是条件对象的一部分，你不必单独地跟踪它。</p><p>条件变量服从 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#with-locks" target="_blank" rel="noopener">上下文管理协议</a>：使用 <code>with</code> 语句会在它包围的代码块内获取关联的锁。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.release" target="_blank" rel="noopener"><code>release()</code></a> 方法也能调用关联锁的相关方法。</p><p>其它方法必须在持有关联的锁的情况下调用。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法释放锁，然后阻塞直到其它线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 方法或 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all" target="_blank" rel="noopener"><code>notify_all()</code></a> 方法唤醒它。一旦被唤醒， <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法重新获取锁并返回。它也可以指定超时时间。</p><p>The <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> method wakes up one of the threads waiting for the condition variable, if any are waiting. The <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all" target="_blank" rel="noopener"><code>notify_all()</code></a> method wakes up all threads waiting for the condition variable.</p><p>注意： <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 方法和 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all" target="_blank" rel="noopener"><code>notify_all()</code></a> 方法并不会释放锁，这意味着被唤醒的线程不会立即从它们的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法调用中返回，而是会在调用了 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 方法或 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all" target="_blank" rel="noopener"><code>notify_all()</code></a> 方法的线程最终放弃了锁的所有权后返回。</p><p>使用条件变量的典型编程风格是将锁用于同步某些共享状态的权限，那些对状态的某些特定改变感兴趣的线程，它们重复调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法，直到看到所期望的改变发生；而对于修改状态的线程，它们将当前状态改变为可能是等待者所期待的新状态后，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 方法或者 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all" target="_blank" rel="noopener"><code>notify_all()</code></a> 方法。例如，下面的代码是一个通用的无限缓冲区容量的生产者-消费者情形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Consume one item</span><br><span class="line">with cv:</span><br><span class="line">    while not an_item_is_available():</span><br><span class="line">        cv.wait()</span><br><span class="line">    get_an_available_item()</span><br><span class="line"></span><br><span class="line"># Produce one item</span><br><span class="line">with cv:</span><br><span class="line">    make_an_item_available()</span><br><span class="line">    cv.notify()</span><br></pre></td></tr></table></figure><p>使用 <code>while</code> 循环检查所要求的条件成立与否是有必要的，因为 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法可能要经过不确定长度的时间后才会返回，而此时导致 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 方法调用的那个条件可能已经不再成立。这是多线程编程所固有的问题。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait_for" target="_blank" rel="noopener"><code>wait_for()</code></a> 方法可自动化条件检查，并简化超时计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Consume an item</span></span><br><span class="line"><span class="keyword">with</span> cv:</span><br><span class="line">    cv.wait_for(an_item_is_available)</span><br><span class="line">    get_an_available_item()</span><br></pre></td></tr></table></figure><p>选择 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 还是 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all" target="_blank" rel="noopener"><code>notify_all()</code></a> ，取决于一次状态改变是只能被一个还是能被多个等待线程所用。例如在一个典型的生产者-消费者情形中，添加一个项目到缓冲区只需唤醒一个消费者线程。</p><p><em>class</em> <code>threading.Condition</code>(<em>lock=None</em>)</p><p>实现条件变量对象的类。一个条件变量对象允许一个或多个线程在被其它线程所通知之前进行等待。</p><p>如果给出了非 <code>None</code> 的 <em>lock</em> 参数，则它必须为 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Lock" target="_blank" rel="noopener"><code>Lock</code></a> 或者 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock" target="_blank" rel="noopener"><code>RLock</code></a> 对象，并且它将被用作底层锁。否则，将会创建新的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock" target="_blank" rel="noopener"><code>RLock</code></a> 对象，并将其用作底层锁。</p><p><em>在 3.3 版更改:</em> 从工厂函数变为类。</p><ul><li><p><code>acquire</code>(*<em>args</em>)</p><p>请求底层锁。此方法调用底层锁的相应方法，返回值是底层锁相应方法的返回值。</p></li><li><p><code>release</code>()</p><p>释放底层锁。此方法调用底层锁的相应方法。没有返回值。</p></li><li><p><code>wait</code>(<em>timeout=None</em>)</p><p>等待直到被通知或发生超时。如果线程在调用此方法时没有获得锁，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常。这个方法释放底层锁，然后阻塞，直到在另外一个线程中调用同一个条件变量的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify_all" target="_blank" rel="noopener"><code>notify_all()</code></a> 唤醒它，或者直到可选的超时发生。一旦被唤醒或者超时，它重新获得锁并返回。当提供了 <em>timeout</em> 参数且不是 <code>None</code> 时，它应该是一个浮点数，代表操作的超时时间，以秒为单位（可以为小数）。当底层锁是个 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock" target="_blank" rel="noopener"><code>RLock</code></a> ，不会使用它的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.release" target="_blank" rel="noopener"><code>release()</code></a> 方法释放锁，因为当它被递归多次获取时，实际上可能无法解锁。相反，使用了 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.RLock" target="_blank" rel="noopener"><code>RLock</code></a> 类的内部接口，即使多次递归获取它也能解锁它。 然后，在重新获取锁时，使用另一个内部接口来恢复递归级别。返回 <code>True</code> ，除非提供的 <em>timeout</em> 过期，这种情况下返回 <code>False</code>。<em>在 3.2 版更改:</em> 很明显，方法总是返回 <code>None</code>。</p></li><li><p><code>wait_for</code>(<em>predicate</em>, <em>timeout=None</em>)</p><p>等待，直到条件计算为真。 <em>predicate</em> 应该是一个可调用对象而且它的返回值可被解释为一个布尔值。可以提供 <em>timeout</em> 参数给出最大等待时间。这个实用方法会重复地调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> 直到满足判断式或者发生超时。返回值是判断式最后一个返回值，而且如果方法发生超时会返回 <code>False</code> 。忽略超时功能，调用此方法大致相当于编写:<code>while not predicate():     cv.wait()</code>因此，规则同样适用于 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> ：锁必须在被调用时保持获取，并在返回时重新获取。 随着锁定执行判断式。<em>3.2 新版功能.</em></p></li><li><p><code>notify</code>(<em>n=1</em>)</p><p>默认唤醒一个等待这个条件的线程。如果调用线程在没有获得锁的情况下调用这个方法，会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常。这个方法唤醒最多 <em>n</em> 个正在等待这个条件变量的线程；如果没有线程在等待，这是一个空操作。当前实现中，如果至少有 <em>n</em> 个线程正在等待，准确唤醒 <em>n</em> 个线程。但是依赖这个行为并不安全。未来，优化的实现有时会唤醒超过 <em>n</em> 个线程。注意：被唤醒的线程实际上不会返回它调用的 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.wait" target="_blank" rel="noopener"><code>wait()</code></a> ，直到它可以重新获得锁。因为 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 不会释放锁，只有它的调用者应该这样做。</p></li><li><p><code>notify_all</code>()</p><p>唤醒所有正在等待这个条件的线程。这个方法行为与 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Condition.notify" target="_blank" rel="noopener"><code>notify()</code></a> 相似，但并不只唤醒单一线程，而是唤醒所有等待线程。如果调用线程在调用这个方法时没有获得锁，会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常。</p></li></ul><h3 id="信号量对象"><a href="#信号量对象" class="headerlink" title="信号量对象"></a>信号量对象</h3><p>这是计算机科学史上最古老的同步原语之一，早期的荷兰科学家 Edsger W. Dijkstra 发明了它。（他使用名称 <code>P()</code> 和 <code>V()</code> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release" target="_blank" rel="noopener"><code>release()</code></a> ）。</p><p>一个信号量管理一个内部计数器，该计数器因 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 方法的调用而递减，因 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release" target="_blank" rel="noopener"><code>release()</code></a> 方法的调用而递增。 计数器的值永远不会小于零；当 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 方法发现计数器为零时，将会阻塞，直到其它线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release" target="_blank" rel="noopener"><code>release()</code></a> 方法。</p><p>信号量对象也支持 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#with-locks" target="_blank" rel="noopener">上下文管理协议</a> 。</p><ul><li><p><em>class</em> <code>threading.Semaphore</code>(<em>value=1</em>)</p><p>该类实现信号量对象。信号量对象管理一个原子性的计数器，代表 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release" target="_blank" rel="noopener"><code>release()</code></a> 方法的调用次数减去 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 的调用次数再加上一个初始值。如果需要， <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.acquire" target="_blank" rel="noopener"><code>acquire()</code></a> 方法将会阻塞直到可以返回而不会使得计数器变成负数。在没有显式给出 <em>value</em> 的值时，默认为1。</p><p>可选参数 <em>value</em> 赋予内部计数器初始值，默认值为 <code>1</code> 。如果 <em>value</em> 被赋予小于0的值，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。</p><ul><li><p><code>acquire</code>(<em>blocking=True</em>, <em>timeout=None</em>)</p><p>获取一个信号量。在不带参数的情况下调用时：如果在进入时内部计数器的值大于零，则将其减一并立即返回 <code>True</code>.如果在进入时内部计数器的值为零，则将会阻塞直到被对 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release" target="_blank" rel="noopener"><code>release()</code></a> 的调用唤醒。 一旦被唤醒（并且计数器的值大于 0），则将计数器减 1 并返回 <code>True</code>。 每次对 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Semaphore.release" target="_blank" rel="noopener"><code>release()</code></a> 的调用将只唤醒一个线程。 线程被唤醒的次序是不可确定的。当发起调用时将 <em>blocking</em> 设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 <code>False</code>；在其他情况下，执行与无参数调用时一样的操作，然后返回 <code>True</code>。当发起调用时如果 <em>timeout</em> 不为 <code>None</code>，则它将阻塞最多 <em>timeout</em> 秒。 请求在此时段时未能成功完成获取则将返回 <code>False</code>。 在其他情况下返回 <code>True</code>。<em>在 3.2 版更改:</em> 新的 <em>timeout</em> 形参。</p></li><li><p><code>release</code>()</p><p>释放一个信号量，将内部计数器的值增加1。当计数器原先的值为0且有其它线程正在等待它再次大于0时，唤醒正在等待的线程。</p></li></ul></li><li><p><em>class</em> <code>threading.BoundedSemaphore</code>(<em>value=1</em>)</p><p>该类实现有界信号量。有界信号量通过检查以确保它当前的值不会超过初始值。如果超过了初始值，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。在大多情况下，信号量用于保护数量有限的资源。如果信号量被释放的次数过多，则表明出现了错误。没有指定时， <em>value</em> 的值默认为1。<em>在 3.3 版更改:</em> 从工厂函数变为类。</p></li></ul><h4 id="Semaphore例子"><a href="#Semaphore例子" class="headerlink" title="Semaphore例子"></a><code>Semaphore</code>例子</h4><p>信号量通常用于保护数量有限的资源，例如数据库服务器。在资源数量固定的任何情况下，都应该使用有界信号量。在生成任何工作线程前，应该在主线程中初始化信号量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maxconnections = <span class="number">5</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">pool_sema = BoundedSemaphore(value=maxconnections)</span><br></pre></td></tr></table></figure><p>工作线程生成后，当需要连接服务器时，这些线程将调用信号量的 acquire 和 release 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conn = connectdb()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># ... use connection ...</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure><p>使用有界信号量能减少这种编程错误：信号量的释放次数多于其请求次数。</p><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>这是线程之间通信的最简单机制之一：一个线程发出事件信号，而其他线程等待该信号。</p><p>一个事件对象管理一个内部标志，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.set" target="_blank" rel="noopener"><code>set()</code></a> 方法可将其设置为true，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.clear" target="_blank" rel="noopener"><code>clear()</code></a> 方法可将其设置为false，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法将进入阻塞直到标志为true。</p><ul><li><p><em>class</em> <code>threading.Event</code></p><p>实现事件对象的类。事件对象管理一个内部标志，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.set" target="_blank" rel="noopener"><code>set()</code></a> 方法可将其设置为true。调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.clear" target="_blank" rel="noopener"><code>clear()</code></a> 方法可将其设置为false。调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法将进入阻塞直到标志为true。这个标志初始时为false。<em>在 3.3 版更改:</em> 从工厂函数变为类。<code>is_set</code>()当且仅当内部旗标为时返回 <code>True</code>。<code>set</code>()将内部标志设置为true。所有正在等待这个事件的线程将被唤醒。当标志为true时，调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法的线程不会被被阻塞。<code>clear</code>()将内部标志设置为false。之后调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法的线程将会被阻塞，直到调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.set" target="_blank" rel="noopener"><code>set()</code></a> 方法将内部标志再次设置为true。<code>wait</code>(<em>timeout=None</em>)阻塞线程直到内部变量为true。如果调用时内部标志为true，将立即返回。否则将阻塞线程，直到调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Event.set" target="_blank" rel="noopener"><code>set()</code></a> 方法将标志设置为true或者发生可选的超时。当提供了timeout参数且不是 <code>None</code> 时，它应该是一个浮点数，代表操作的超时时间，以秒为单位（可以为小数）。当且仅当内部旗标在等待调用之前或者等待开始之后被设为真值时此方法将返回 <code>True</code>，也就是说，它将总是返回 <code>True</code> 除非设定了超时且操作发生了超时。</p></li></ul><h3 id="定时器对象"><a href="#定时器对象" class="headerlink" title="定时器对象"></a>定时器对象</h3><p>此类表示一个操作应该在等待一定的时间之后运行 — 相当于一个定时器。 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Timer" target="_blank" rel="noopener"><code>Timer</code></a> 类是 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Thread" target="_blank" rel="noopener"><code>Thread</code></a> 类的子类，因此可以像一个自定义线程一样工作。</p><p>与线程一样，通过调用 <code>start()</code> 方法启动定时器。而 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Timer.cancel" target="_blank" rel="noopener"><code>cancel()</code></a> 方法可以停止计时器（在计时结束前）， 定时器在执行其操作之前等待的时间间隔可能与用户指定的时间间隔不完全相同。</p><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello, world"</span>)</span><br><span class="line"></span><br><span class="line">t = Timer(<span class="number">30.0</span>, hello)</span><br><span class="line">t.start()  <span class="comment"># after 30 seconds, "hello, world" will be printed</span></span><br></pre></td></tr></table></figure><p><em>class</em> <code>threading.Timer</code>(<em>interval</em>, <em>function</em>, <em>args=None</em>, <em>kwargs=None</em>)</p><p>创建一个定时器，在经过 <em>interval</em> 秒的间隔事件后，将会用参数 <em>args</em> 和关键字参数 <em>kwargs</em> 调用 <em>function</em>。如果 <em>args</em> 为 <code>None</code> （默认值），则会使用一个空列表。如果 <em>kwargs</em> 为 <code>None</code> （默认值），则会使用一个空字典。</p><ul><li><code>cancel</code>()<a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Timer.cancel" target="_blank" rel="noopener">¶</a></li></ul><p>停止定时器并取消执行计时器将要执行的操作。仅当计时器仍处于等待状态时有效。</p><h3 id="栅栏对象"><a href="#栅栏对象" class="headerlink" title="栅栏对象"></a>栅栏对象</h3><p>栅栏类提供一个简单的同步原语，用于应对固定数量的线程需要彼此相互等待的情况。线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法后将阻塞，直到所有线程都调用了 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法。此时所有线程将被同时释放。</p><p>栅栏对象可以被多次使用，但进程的数量不能改变。</p><p>这是一个使用简便的方法实现客户端进程与服务端进程同步的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">b = Barrier(<span class="number">2</span>, timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">()</span>:</span></span><br><span class="line">    start_server()</span><br><span class="line">    b.wait()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        connection = accept_connection()</span><br><span class="line">        process_server_connection(connection)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">()</span>:</span></span><br><span class="line">    b.wait()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        connection = make_connection()</span><br><span class="line">        process_client_connection(connection)</span><br></pre></td></tr></table></figure><p><em>class</em> <code>threading.Barrier</code>(<em>parties</em>, <em>action=None</em>, <em>timeout=None</em>)</p><p>创建一个需要 <em>parties</em> 个线程的栅栏对象。如果提供了可调用的 <em>action</em> 参数，它会在所有线程被释放时在其中一个线程中自动调用。 <em>timeout</em> 是默认的超时时间，如果没有在 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier.wait" target="_blank" rel="noopener"><code>wait()</code></a> 方法中指定超时时间的话。</p><ul><li><p><code>wait</code>(<em>timeout=None</em>)</p><p>冲出栅栏。当栅栏中所有线程都已经调用了这个函数，它们将同时被释放。如果提供了 <em>timeout</em> 参数，这里的 <em>timeout</em> 参数优先于创建栅栏对象时提供的 <em>timeout</em> 参数。函数返回值是一个整数，取值范围在0到 <em>parties</em> – 1，在每个线程中的返回值不相同。可用于从所有线程中选择唯一的一个线程执行一些特别的工作。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = barrier.wait()</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># Only one thread needs to print this</span></span><br><span class="line">    print(<span class="string">"passed the barrier"</span>)</span><br></pre></td></tr></table></figure><p>如果创建栅栏对象时在构造函数中提供了 <em>action</em> 参数，它将在其中一个线程释放前被调用。如果此调用引发了异常，栅栏对象将进入损坏态。</p><p>如果发生了超时，栅栏对象将进入破损态。</p><p>如果栅栏对象进入破损态，或重置栅栏时仍有线程等待释放，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.BrokenBarrierError" target="_blank" rel="noopener"><code>BrokenBarrierError</code></a> 异常。</p></li><li><p><code>reset</code>()</p><p>重置栅栏为默认的初始态。如果栅栏中仍有线程等待释放，这些线程将会收到 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.BrokenBarrierError" target="_blank" rel="noopener"><code>BrokenBarrierError</code></a> 异常。</p></li><li><p><code>abort</code>()</p><p>Put the barrier into a broken state. This causes any active or future calls to <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier.wait" target="_blank" rel="noopener"><code>wait()</code></a> to fail with the <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.BrokenBarrierError" target="_blank" rel="noopener"><code>BrokenBarrierError</code></a>. Use this for example if one of the threads needs to abort, to avoid deadlocking the application.更好的方式是：创建栅栏时提供一个合理的超时时间，来自动避免某个线程出错。</p></li><li><p><code>parties</code></p><p>冲出栅栏所需要的线程数量。</p></li><li><p><code>n_waiting</code></p><p>当前时刻正在栅栏中阻塞的线程数量。</p></li><li><p><code>broken</code></p><p>一个布尔值，值为 <code>True</code> 表明栅栏为破损态。</p></li></ul><p><em>exception</em> <code>threading.BrokenBarrierError</code></p><p>异常类，是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常的子类，在 <a href="https://docs.python.org/zh-cn/3.8/library/threading.html#threading.Barrier" target="_blank" rel="noopener"><code>Barrier</code></a> 对象重置时仍有线程阻塞时和对象进入破损态时被引发。</p><h3 id="在-with-语句中使用锁、条件和信号量"><a href="#在-with-语句中使用锁、条件和信号量" class="headerlink" title="在 with 语句中使用锁、条件和信号量"></a>在 <code>with</code> 语句中使用锁、条件和信号量</h3><p>这个模块提供的带有 <code>acquire()</code> 和 <code>release()</code> 方法的对象，可以被用作 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的上下文管理器。当进入语句块时 <code>acquire()</code> 方法会被调用，退出语句块时 <code>release()</code> 会被调用。因此，以下片段:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> some_lock:</span><br><span class="line">    <span class="comment"># do something...</span></span><br></pre></td></tr></table></figure><p>相当于:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">some_lock.acquire()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># do something...</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    some_lock.release()</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="GIL-原理"><a href="#GIL-原理" class="headerlink" title="GIL 原理"></a>GIL 原理</h3><p>参考 <a href="https://stackoverflow.com/questions/1294382/what-is-the-global-interpreter-lock-gil-in-cpython" target="_blank" rel="noopener">stackoverflow</a>上 大神的解释</p><blockquote><p>Python’s GIL is intended to serialize access to interpreter internals from different threads. On multi-core systems, it means that multiple threads can’t effectively make use of multiple cores. (If the GIL didn’t lead to this problem, most people wouldn’t care about the GIL - it’s only being raised as an issue because of the increasing prevalence of multi-core systems.) If you want to understand it in detail, you can view <a href="https://www.youtube.com/watch?v=ph374fJqFPE" target="_blank" rel="noopener">this video</a> or look at <a href="http://www.dabeaz.com/python/GIL.pdf" target="_blank" rel="noopener">this set of slides</a>. It might be too much information, but then you did ask for details :-)</p><p>Note that Python’s GIL is only really an issue for CPython, the reference implementation. Jython and IronPython don’t have a GIL. As a Python developer, you don’t generally come across the GIL unless you’re writing a C extension. C extension writers need to release the GIL when their extensions do blocking I/O, so that other threads in the Python process get a chance to run.</p></blockquote><p>简单说 所谓的全局线程锁,就是同步线程间信号的一种处理方式。</p><p>在多线程系统中,并不能充分利用多线程,来提高整体的性能。所以才有了 GIL。</p><p>根据我的理解,GIL的一个应用场景是<strong>在同一时刻只能跑一个线程，这样在跑多线程的情况下，只有当线程获取到全局解释器锁后才能运行，而全局解释器锁只有一个，因此即使在多核的情况下也只能发挥出单核的功能。</strong></p><p>如下图所示:</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200119_cpu_bound_tasks.png?raw=tru" alt></p><p><code>GIL</code>仅仅对cpython实现和扩展的模块起作用,jython或者ironpython没有GIL的概念。</p><p>到底是并行还是多线程,在很多场景中都有争论。</p><h3 id="GIL-对线程执行的影响："><a href="#GIL-对线程执行的影响：" class="headerlink" title="GIL 对线程执行的影响："></a>GIL 对线程执行的影响：</h3><p>首先理解什么是interval时间,和操作系统绑定:</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># The interval is set to 100 instructions:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getcheckinterval()</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>多线程环境中，python虚拟机按照以下方式执行：</p><ul><li>设置GIL</li><li>切换到一个线程去执行</li><li>运行代码，这里有两种机制： q<ul><li>指定数量的字节码指令（100个）</li><li>固定时间15ms线程主动让出控制</li></ul></li><li>把线程设置为睡眠状态</li><li>解锁GIL</li><li>再次重复以上步骤</li></ul><h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><p><strong>Code 1: CPU bound program that perform simple countdown</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread </span><br><span class="line">  </span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span> </span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>: </span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">start = time.time() </span><br><span class="line">countdown(COUNT) </span><br><span class="line">end = time.time() </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'Time taken in seconds -'</span>, end - start) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Time taken <span class="keyword">in</span> seconds - <span class="number">2.5236213207244873</span></span><br></pre></td></tr></table></figure><p><strong>Code 2: Two threads running parallel</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread </span><br><span class="line">  </span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span> </span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>: </span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">t1 = Thread(target = countdown, args =(COUNT//<span class="number">2</span>, )) </span><br><span class="line">t2 = Thread(target = countdown, args =(COUNT//<span class="number">2</span>, )) </span><br><span class="line">  </span><br><span class="line">start = time.time() </span><br><span class="line">t1.start() </span><br><span class="line">t2.start() </span><br><span class="line">t1.join() </span><br><span class="line">t2.join() </span><br><span class="line">end = time.time() </span><br><span class="line">  </span><br><span class="line">print(<span class="string">'Time taken in seconds -'</span>, end - start) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Time taken <span class="keyword">in</span> seconds - <span class="number">2.183610439300537</span></span><br></pre></td></tr></table></figure><p><strong>python的解决方案</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing  </span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line">  </span><br><span class="line">COUNT = <span class="number">50000000</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span> </span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>: </span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: </span><br><span class="line">    <span class="comment"># creating processes  </span></span><br><span class="line">    start = time.time() </span><br><span class="line">    p1 = multiprocessing.Process(target = countdown, args =(COUNT//<span class="number">2</span>, )) </span><br><span class="line">    p2 = multiprocessing.Process(target = countdown, args =(COUNT//<span class="number">2</span>, )) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># starting process 1  </span></span><br><span class="line">    p1.start() </span><br><span class="line">    <span class="comment"># starting process 2  </span></span><br><span class="line">    p2.start()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># wait until process 1 is finished  </span></span><br><span class="line">    p1.join()  </span><br><span class="line">    <span class="comment"># wait until process 2 is finished  </span></span><br><span class="line">    p2.join() </span><br><span class="line">    end = time.time() </span><br><span class="line">    print(<span class="string">'Time taken in seconds -'</span>, end - start) </span><br><span class="line">    &gt;&gt;&gt; Time taken <span class="keyword">in</span> seconds - <span class="number">2.5148496627807617</span></span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.dabeaz.com/python/UnderstandingGIL.pdf" target="_blank" rel="noopener">UnderstandingGIL</a></p><p><a href="https://callhub.io/understanding-python-gil/" target="_blank" rel="noopener">understanding-python-gil</a></p><p><a href="https://www.geeksforgeeks.org/what-is-the-python-global-interpreter-lock-gil/" target="_blank" rel="noopener">what is the python interpreter lock gil</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-threading&quot;&gt;&lt;a href=&quot;#python-标准库-threading&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 threading&quot;&gt;&lt;/a&gt;python 标准库 threading&lt;/h1&gt;&lt;p&gt;每日一词:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;US[‘weðər]  UK[‘weðə(r)]&lt;/p&gt;
&lt;p&gt;n.天气；气象；气象预报&lt;/p&gt;
&lt;p&gt;v.变形；经受住&lt;/p&gt;
&lt;p&gt;气候；天气预报；风化&lt;/p&gt;
&lt;p&gt;给大家推荐一部电影: 气象先生&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200119_weather_man.jpg?raw=tru&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This shit life,we must chuck some things&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="thread" scheme="https://pinghailinfeng.gitee.io/tags/thread/"/>
    
      <category term="GIL" scheme="https://pinghailinfeng.gitee.io/tags/GIL/"/>
    
  </entry>
  
  <entry>
    <title>python standard library numbers</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/18/python-standard-library-numbers/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/18/python-standard-library-numbers/</id>
    <published>2020-01-18T01:02:31.000Z</published>
    <updated>2020-01-18T02:19:26.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库数字的抽象基类-numbers"><a href="#python-标准库数字的抽象基类-numbers" class="headerlink" title="python 标准库数字的抽象基类 numbers"></a>python 标准库数字的抽象基类 numbers</h1><p>昨天深夜 红薯 一篇博文 <a href="https://my.oschina.net/javayou/blog/3159653" target="_blank" rel="noopener">悼 @宏哥</a> ,让我久久不能平静。</p><p>时间定格在了2020年1月16号。</p><p>还依稀记得几年前和宏哥聊天,听说他去创业了。</p><p>还记得那时意气风发,舌战群儒,没想到如今阴阳两隔。</p><p>创业这条路,真的不好走。</p><p>愿天堂没有代码。</p><p>大家都好好活着吧。</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200118_hongge_blog.PNG?raw=true" alt></p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200118_sad.jpg?raw=tru" alt></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1398821876&auto=0&height=66"></iframe><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/numbers.py" target="_blank" rel="noopener">Lib/numbers.py</a></p><p><a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#module-numbers" target="_blank" rel="noopener"><code>numbers</code></a> 模块 (<a href="https://www.python.org/dev/peps/pep-3141" target="_blank" rel="noopener"><strong>PEP 3141</strong></a>) 定义了数字 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class" target="_blank" rel="noopener">抽象基类</a> 的层次结构，其中逐级定义了更多操作。 此模块中所定义的类型都不可被实例化。</p><h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><p><em>class</em> <code>numbers.Number</code></p><blockquote><p>数字的层次结构的基础。如果你只想确认参数 <em>x</em> 是不是数字而不关心其类型，则使用isinstance(x, Number)。</p></blockquote><a id="more"></a><h2 id="数字的层次"><a href="#数字的层次" class="headerlink" title="数字的层次"></a>数字的层次</h2><ul><li><p><em>class</em> <code>numbers.Complex</code></p><p>内置在类型 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#complex" target="_blank" rel="noopener"><code>complex</code></a> 里的子类描述了复数和它的运算操作。这些操作有：转化至 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#complex" target="_blank" rel="noopener"><code>complex</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#bool" target="_blank" rel="noopener"><code>bool</code></a>， <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.real" target="_blank" rel="noopener"><code>real</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.imag" target="_blank" rel="noopener"><code>imag</code></a>、<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#abs" target="_blank" rel="noopener"><code>abs()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.conjugate" target="_blank" rel="noopener"><code>conjugate()</code></a>、 <code>==</code> 和 <code>!=</code>。 所有的异常，<code>-</code> 和 <code>!=</code> ，都是抽象的。<code>real</code>抽象的。得到该数字的实数部分。<code>imag</code>抽象的。得到该数字的虚数部分。<em>abstractmethod</em> <code>conjugate</code>()抽象的。返回共轭复数。例如 <code>(1+3j).conjugate() == (1-3j)</code>。</p></li><li><p><em>class</em> <code>numbers.Real</code></p><p>相对于 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex" target="_blank" rel="noopener"><code>Complex</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Real" target="_blank" rel="noopener"><code>Real</code></a> 加入了只有实数才能进行的操作。简单的说，它们是：转化至 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.trunc" target="_blank" rel="noopener"><code>math.trunc()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#round" target="_blank" rel="noopener"><code>round()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.floor" target="_blank" rel="noopener"><code>math.floor()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.ceil" target="_blank" rel="noopener"><code>math.ceil()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#divmod" target="_blank" rel="noopener"><code>divmod()</code></a>、 <code>//</code>、 <code>%</code>、 <code>&lt;</code>、 <code>&lt;=</code>、 <code>&gt;</code>、 和 <code>&gt;=</code>。实数同样默认支持 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#complex" target="_blank" rel="noopener"><code>complex()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.real" target="_blank" rel="noopener"><code>real</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.imag" target="_blank" rel="noopener"><code>imag</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex.conjugate" target="_blank" rel="noopener"><code>conjugate()</code></a>。</p></li><li><p><em>class</em> <code>numbers.Rational</code></p><p>子类型 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Real" target="_blank" rel="noopener"><code>Real</code></a> 并加入 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational.numerator" target="_blank" rel="noopener"><code>numerator</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational.denominator" target="_blank" rel="noopener"><code>denominator</code></a> 两种属性，这两种属性应该属于最低的级别。加入后，这默认支持 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float()</code></a>。<code>numerator</code>摘要。<code>denominator</code>摘要。</p></li><li><p><em>class</em> <code>numbers.Integral</code></p><p>子类型 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational" target="_blank" rel="noopener"><code>Rational</code></a> 加上转化至 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>。 默认支持 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float()</code></a>、 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational.numerator" target="_blank" rel="noopener"><code>numerator</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational.denominator" target="_blank" rel="noopener"><code>denominator</code></a>。 在 <code>**</code> 中加入抽象方法和比特字符串的操作： <code>&lt;&lt;</code>、 <code>&gt;&gt;</code>、 <code>&amp;</code>、 <code>^</code>、 <code>|</code>、 <code>~</code>。</p></li></ul><h2 id="类型接口注解"><a href="#类型接口注解" class="headerlink" title="类型接口注解"></a>类型接口注解</h2><p>实现者需要注意使相等的数字相等并拥有同样的值。当这两个数使用不同的扩展模块时，这其中的差异是很微妙的。例如，用 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>fractions.Fraction</code></a> 实现 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#hash" target="_blank" rel="noopener"><code>hash()</code></a> 如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.denominator == <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># Get integers right.</span></span><br><span class="line">        <span class="keyword">return</span> hash(self.numerator)</span><br><span class="line">    <span class="comment"># Expensive check, but definitely correct.</span></span><br><span class="line">    <span class="keyword">if</span> self == float(self):</span><br><span class="line">        <span class="keyword">return</span> hash(float(self))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Use tuple's hash to avoid a high collision rate on</span></span><br><span class="line">        <span class="comment"># simple fractions.</span></span><br><span class="line">        <span class="keyword">return</span> hash((self.numerator, self.denominator))</span><br></pre></td></tr></table></figure><h3 id="添加更多数字的ABC-创造自定义的数字子类"><a href="#添加更多数字的ABC-创造自定义的数字子类" class="headerlink" title="添加更多数字的ABC(创造自定义的数字子类)"></a>添加更多数字的ABC(创造自定义的数字子类)</h3><p>当然，这里有更多支持数字的ABC，如果不加入这些，就将缺少层次感。你可以用如下方法在 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex" target="_blank" rel="noopener"><code>Complex</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Real" target="_blank" rel="noopener"><code>Real</code></a> 中加入MyFoo：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFoo</span><span class="params">(Complex)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">MyFoo.register(Real)</span><br></pre></td></tr></table></figure><h3 id="实现算数运算"><a href="#实现算数运算" class="headerlink" title="实现算数运算"></a>实现算数运算</h3><p>我们希望实现计算，因此，混合模式操作要么调用一个作者知道参数类型的实现，要么转变成为最接近的内置类型并对这个执行操作。对于子类 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Integral" target="_blank" rel="noopener"><code>Integral</code></a>，这意味着 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__radd__" target="_blank" rel="noopener"><code>__radd__()</code></a> 必须用如下方式定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIntegral</span><span class="params">(Integral)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(other, MyIntegral):</span><br><span class="line">            <span class="keyword">return</span> do_my_adding_stuff(self, other)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, OtherTypeIKnowAbout):</span><br><span class="line">            <span class="keyword">return</span> do_my_other_adding_stuff(self, other)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(other, MyIntegral):</span><br><span class="line">            <span class="keyword">return</span> do_my_adding_stuff(other, self)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, OtherTypeIKnowAbout):</span><br><span class="line">            <span class="keyword">return</span> do_my_other_adding_stuff(other, self)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, Integral):</span><br><span class="line">            <span class="keyword">return</span> int(other) + int(self)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, Real):</span><br><span class="line">            <span class="keyword">return</span> float(other) + float(self)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(other, Complex):</span><br><span class="line">            <span class="keyword">return</span> complex(other) + complex(self)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure><p>复数的子类上的混合操作有五种情况。前述的代码中除去MyIntegral和OtherTypeIKnow的文本将作为下面描述的样板。a是A的实例，并且使复数的子类（a：A&lt;：Complex），b是B的实例，也是复数的子类。我们以a+b做如下讨论：</p><ol><li>如果 <code>A</code> 被定义成一个承认b 的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a>，一切都没有问题。</li><li>如果 <code>A</code> 转回成“模板”失败，它将返回一个属于 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 的值，我们需要避免 <code>B</code> 定义了一个更加智能的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__radd__" target="_blank" rel="noopener"><code>__radd__()</code></a>，因此模板需要返回一个属于 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#NotImplemented" target="_blank" rel="noopener"><code>NotImplemented</code></a> 。（或者 <code>A</code> 可能完全不实现 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__add__" target="_blank" rel="noopener"><code>__add__()</code></a> 。）</li><li>接着看 <code>B</code> 的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__radd__" target="_blank" rel="noopener"><code>__radd__()</code></a> 。如果它接受<code>a</code> ，一切都将完美。</li><li>如果没有成功回退到模板，就没有更多的方法可以去尝试，因此这里将使用默认的实现。</li><li>如果 <code>B &lt;: A</code> ， Python 在 <code>A.__add__</code> 之前尝试 <code>B.__radd__</code> 。 这是可行的，是通过对 <code>A</code> 的认识实现的，因此这可以在交给 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Complex" target="_blank" rel="noopener"><code>Complex</code></a> 处理之前处理这些实例。</li></ol><p>如果 <code>A &lt;: Complex</code> 和 <code>B &lt;: Real</code> 没有共享任何资源，那么适当的共享操作涉及内置的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#complex" target="_blank" rel="noopener"><code>complex</code></a> ，并且分别获得 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__radd__" target="_blank" rel="noopener"><code>__radd__()</code></a> ，因此 <code>a+b == b+a</code>。</p><p>由于对任何一直类型的大部分操作是十分相似的，可以定义一个帮助函数，即一个生成后续或相反的实例的生成器。例如，使用 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>fractions.Fraction</code></a> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_operator_fallbacks</span><span class="params">(monomorphic_operator, fallback_operator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(b, (int, Fraction)):</span><br><span class="line">            <span class="keyword">return</span> monomorphic_operator(a, b)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(b, float):</span><br><span class="line">            <span class="keyword">return</span> fallback_operator(float(a), b)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(b, complex):</span><br><span class="line">            <span class="keyword">return</span> fallback_operator(complex(a), b)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    forward.__name__ = <span class="string">'__'</span> + fallback_operator.__name__ + <span class="string">'__'</span></span><br><span class="line">    forward.__doc__ = monomorphic_operator.__doc__</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(b, a)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(a, Rational):</span><br><span class="line">            <span class="comment"># Includes ints.</span></span><br><span class="line">            <span class="keyword">return</span> monomorphic_operator(a, b)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(a, numbers.Real):</span><br><span class="line">            <span class="keyword">return</span> fallback_operator(float(a), float(b))</span><br><span class="line">        <span class="keyword">elif</span> isinstance(a, numbers.Complex):</span><br><span class="line">            <span class="keyword">return</span> fallback_operator(complex(a), complex(b))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    reverse.__name__ = <span class="string">'__r'</span> + fallback_operator.__name__ + <span class="string">'__'</span></span><br><span class="line">    reverse.__doc__ = monomorphic_operator.__doc__</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> forward, reverse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""a + b"""</span></span><br><span class="line">    <span class="keyword">return</span> Fraction(a.numerator * b.denominator +</span><br><span class="line">                    b.numerator * a.denominator,</span><br><span class="line">                    a.denominator * b.denominator)</span><br><span class="line"></span><br><span class="line">__add__, __radd__ = _operator_fallbacks(_add, operator.add)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库数字的抽象基类-numbers&quot;&gt;&lt;a href=&quot;#python-标准库数字的抽象基类-numbers&quot; class=&quot;headerlink&quot; title=&quot;python 标准库数字的抽象基类 numbers&quot;&gt;&lt;/a&gt;python 标准库数字的抽象基类 numbers&lt;/h1&gt;&lt;p&gt;昨天深夜 红薯 一篇博文 &lt;a href=&quot;https://my.oschina.net/javayou/blog/3159653&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;悼 @宏哥&lt;/a&gt; ,让我久久不能平静。&lt;/p&gt;
&lt;p&gt;时间定格在了2020年1月16号。&lt;/p&gt;
&lt;p&gt;还依稀记得几年前和宏哥聊天,听说他去创业了。&lt;/p&gt;
&lt;p&gt;还记得那时意气风发,舌战群儒,没想到如今阴阳两隔。&lt;/p&gt;
&lt;p&gt;创业这条路,真的不好走。&lt;/p&gt;
&lt;p&gt;愿天堂没有代码。&lt;/p&gt;
&lt;p&gt;大家都好好活着吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200118_hongge_blog.PNG?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200118_sad.jpg?raw=tru&quot; alt&gt;&lt;/p&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=1398821876&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;源代码&quot;&gt;&lt;a href=&quot;#源代码&quot; class=&quot;headerlink&quot; title=&quot;源代码&quot;&gt;&lt;/a&gt;源代码&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;源代码：&lt;/strong&gt; &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/numbers.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lib/numbers.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/numbers.html#module-numbers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;numbers&lt;/code&gt;&lt;/a&gt; 模块 (&lt;a href=&quot;https://www.python.org/dev/peps/pep-3141&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;PEP 3141&lt;/strong&gt;&lt;/a&gt;) 定义了数字 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;抽象基类&lt;/a&gt; 的层次结构，其中逐级定义了更多操作。 此模块中所定义的类型都不可被实例化。&lt;/p&gt;
&lt;h2 id=&quot;核心类&quot;&gt;&lt;a href=&quot;#核心类&quot; class=&quot;headerlink&quot; title=&quot;核心类&quot;&gt;&lt;/a&gt;核心类&lt;/h2&gt;&lt;p&gt;&lt;em&gt;class&lt;/em&gt; &lt;code&gt;numbers.Number&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数字的层次结构的基础。如果你只想确认参数 &lt;em&gt;x&lt;/em&gt; 是不是数字而不关心其类型，则使用isinstance(x, Number)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
  </entry>
  
  <entry>
    <title>python standard libary heapq</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/17/python-standard-library-heapq/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/17/python-standard-library-heapq/</id>
    <published>2020-01-17T01:10:06.000Z</published>
    <updated>2020-01-17T02:18:48.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python-标准库-堆队列算法-heapq"><a href="#python-标准库-堆队列算法-heapq" class="headerlink" title="python 标准库  堆队列算法 heapq"></a>python 标准库  堆队列算法 heapq</h2><p>每日一词:</p><blockquote><p>Pollen </p><p>n 花粉</p><p>例句:</p><p>Good news for all you hay fever and asthma sufferers<br>对于花粉症和哮喘病患者是个好消息</p></blockquote><p>今天是小年,祝大家心想事成</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200117_happiness.jpg?raw=true" alt></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><strong>源码：</strong><a href="https://github.com/python/cpython/tree/3.8/Lib/heapq.py" target="_blank" rel="noopener">Lib/heapq.py</a></p><p>主要模块和方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">'heappush'</span>, <span class="string">'heappop'</span>, <span class="string">'heapify'</span>, <span class="string">'heapreplace'</span>, <span class="string">'merge'</span>,</span><br><span class="line">           <span class="string">'nlargest'</span>, <span class="string">'nsmallest'</span>, <span class="string">'heappushpop'</span>]</span><br></pre></td></tr></table></figure><p>这个模块提供了堆队列算法的实现，也称为优先队列算法。</p><p>堆是一个二叉树，它的每个父节点的值都只会小于或大于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的 <em>k</em> ，都有 <code>heap[k] &lt;= heap[2*k+1]</code> 和 <code>heap[k] &lt;= heap[2*k+2]</code>。 为了便于比较，不存在的元素被认为是无限大。 堆最有趣的特性在于最小的元素总是在根结点：<code>heap[0]</code>。</p><a id="more"></a><p>这个API与教材的堆算法实现有所不同，具体区别有两方面：（a）我们使用了从零开始的索引。这使得节点和其孩子节点索引之间的关系不太直观但更加适合，因为 Python 使用从零开始的索引。 （b）我们的 pop 方法返回最小的项而不是最大的项（这在教材中称为“最小堆”；而“最大堆”在教材中更为常见，因为它更适用于原地排序）。</p><p>基于这两方面，把堆看作原生的Python list也没什么奇怪的： <code>heap[0]</code> 表示最小的元素，同时 <code>heap.sort()</code> 维护了堆的不变性！</p><p>要创建一个堆，可以使用list来初始化为 <code>[]</code> ，或者你可以通过一个函数 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heapify" target="_blank" rel="noopener"><code>heapify()</code></a> ，来把一个list转换成堆。</p><p>定义了以下函数：</p><ul><li><p><code>heapq.heappush</code>(<em>heap</em>, <em>item</em>)</p><p>将 <em>item</em> 的值加入 <em>heap</em> 中，保持堆的不变性。</p></li><li><p><code>heapq.heappop</code>(<em>heap</em>)</p><p>弹出并返回 <em>heap</em> 的最小的元素，保持堆的不变性。如果堆为空，抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 。使用 <code>heap[0]</code> ，可以只访问最小的元素而不弹出它。</p></li><li><p><code>heapq.heappushpop</code>(<em>heap</em>, <em>item</em>)</p><p>将 <em>item</em> 放入堆中，然后弹出并返回 <em>heap</em> 的最小元素。该组合操作比先调用  <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappush" target="_blank" rel="noopener"><code>heappush()</code></a> 再调用 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappop" target="_blank" rel="noopener"><code>heappop()</code></a> 运行起来更有效率。</p></li><li><p><code>heapq.heapify</code>(<em>x</em>)</p><p>将list <em>x</em> 转换成堆，原地，线性时间内。</p></li><li><p><code>heapq.heapreplace</code>(<em>heap</em>, <em>item</em>)</p><p>弹出并返回 <em>heap</em> 中最小的一项，同时推入新的 <em>item</em>。 堆的大小不变。 如果堆为空则引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a>。这个单步骤操作比 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappop" target="_blank" rel="noopener"><code>heappop()</code></a> 加 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappush" target="_blank" rel="noopener"><code>heappush()</code></a> 更高效，并且在使用固定大小的堆时更为适宜。 pop/push 组合总是会从堆中返回一个元素并将其替换为 <em>item</em>。返回的值可能会比添加的 <em>item</em> 更大。 如果不希望如此，可考虑改用 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.heappushpop" target="_blank" rel="noopener"><code>heappushpop()</code></a>。 它的 push/pop 组合会返回两个值中较小的一个，将较大的值留在堆中。</p></li></ul><p>该模块还提供了三个基于堆的通用功能函数。</p><ul><li><p><code>heapq.merge</code>(*<em>iterables</em>, <em>key=None</em>, <em>reverse=False</em>)</p><p>将多个已排序的输入合并为一个已排序的输出（例如，合并来自多个日志文件的带时间戳的条目）。 返回已排序值的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a>。类似于 <code>sorted(itertools.chain(*iterables))</code> 但返回一个可迭代对象，不会一次性地将数据全部放入内存，并假定每个输入流都是已排序的（从小到大）。具有两个可选参数，它们都必须指定为关键字参数。<em>key</em> 指定带有单个参数的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-key-function" target="_blank" rel="noopener">key function</a>，用于从每个输入元素中提取比较键。 默认值为 <code>None</code> (直接比较元素)。<em>reverse</em> 为一个布尔值。 如果设为 <code>True</code>，则输入元素将按比较结果逆序进行合并。 要达成与 <code>sorted(itertools.chain(*iterables), reverse=True)</code> 类似的行为，所有可迭代对象必须是已从大到小排序的。<em>在 3.5 版更改:</em> 添加了可选的 <em>key</em> 和 <em>reverse</em> 形参。</p></li><li><p><code>heapq.nlargest</code>(<em>n</em>, <em>iterable</em>, <em>key=None</em>)</p><p>从 <em>iterable</em> 所定义的数据集中返回前 <em>n</em> 个最大元素组成的列表。 如果提供了 <em>key</em> 则其应指定一个单参数的函数，用于从 <em>iterable</em> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key, reverse=True)[:n]</code>。</p></li><li><p><code>heapq.nsmallest</code>(<em>n</em>, <em>iterable</em>, <em>key=None</em>)</p><p>从 <em>iterable</em> 所定义的数据集中返回前 <em>n</em> 个最小元素组成的列表。 如果提供了 <em>key</em> 则其应指定一个单参数的函数，用于从 <em>iterable</em> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key)[:n]</code>。</p></li></ul><p>后两个函数在 <em>n</em> 值较小时性能最好。 对于更大的值，使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> 函数会更有效率。 此外，当 <code>n==1</code> 时，使用内置的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#min" target="_blank" rel="noopener"><code>min()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#max" target="_blank" rel="noopener"><code>max()</code></a> 函数会更有效率。 如果需要重复使用这些函数，请考虑将可迭代对象转为真正的堆。</p><h3 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h3><p><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">堆排序</a> 可以通过将所有值推入堆中然后每次弹出一个最小值项来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span><span class="params">(iterable)</span>:</span></span><br><span class="line"><span class="meta">... </span>    h = []</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line"><span class="meta">... </span>        heappush(h, value)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> [heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(h))]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapsort([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>])</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>这类似于 <code>sorted(iterable)</code>，但与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> 不同的是这个实现是不稳定的。</p><p>堆元素可以为元组。</p><p> 这适用于将比较值（例如任务优先级）与跟踪的主记录进行赋值的场合:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">5</span>, <span class="string">'write code'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">7</span>, <span class="string">'release product'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">1</span>, <span class="string">'write spec'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h, (<span class="number">3</span>, <span class="string">'create tests'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heappop(h)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'write spec'</span>)</span><br></pre></td></tr></table></figure><h3 id="优先队列实现说明"><a href="#优先队列实现说明" class="headerlink" title="优先队列实现说明"></a>优先队列实现说明</h3><p><a href="https://en.wikipedia.org/wiki/Priority_queue" target="_blank" rel="noopener">优先队列</a> 是堆的常用场合，并且它的实现包含了多个挑战：</p><ul><li>排序稳定性：你该如何令相同优先级的两个任务按它们最初被加入时的顺序返回？</li><li>如果优先级相同且任务没有默认比较顺序，则 (priority, task) 对的元组比较将会中断。</li><li>如果任务优先级发生改变，你该如何将其移至堆中的新位置？</li><li>或者如果一个挂起的任务需要被删除，你该如何找到它并将其移出队列？</li></ul><p>针对前两项挑战的一种解决方案是将条目保存为包含优先级、条目计数和任务对象 3 个元素的列表。 条目计数可用来打破平局，这样具有相同优先级的任务将按它们的添加顺序返回。 并且由于没有哪两个条目计数是相同的，元组比较将永远不会直接比较两个任务。</p><p>不可比较任务问题的另一种解决方案是创建一个忽略任务条目并且只比较优先级字段的包装器类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Any</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass(order=True)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrioritizedItem</span>:</span></span><br><span class="line">    priority: int</span><br><span class="line">    item: Any=field(compare=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>其余的挑战主要包括找到挂起的任务并修改其优先级或将其完全移除。 找到一个任务可使用一个指向队列中条目的字典来实现。</p><p>移除条目或改变其优先级的操作实现起来更为困难，因为它会破坏堆结构不变量。 因此，一种可能的解决方案是将条目标记为已移除，再添加一个改变了优先级的新条目:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pq = []                         <span class="comment"># list of entries arranged in a heap</span></span><br><span class="line">entry_finder = &#123;&#125;               <span class="comment"># mapping of tasks to entries</span></span><br><span class="line">REMOVED = <span class="string">'&lt;removed-task&gt;'</span>      <span class="comment"># placeholder for a removed task</span></span><br><span class="line">counter = itertools.count()     <span class="comment"># unique sequence count</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_task</span><span class="params">(task, priority=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'Add a new task or update the priority of an existing task'</span></span><br><span class="line">    <span class="keyword">if</span> task <span class="keyword">in</span> entry_finder:</span><br><span class="line">        remove_task(task)</span><br><span class="line">    count = next(counter)</span><br><span class="line">    entry = [priority, count, task]</span><br><span class="line">    entry_finder[task] = entry</span><br><span class="line">    heappush(pq, entry)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_task</span><span class="params">(task)</span>:</span></span><br><span class="line">    <span class="string">'Mark an existing task as REMOVED.  Raise KeyError if not found.'</span></span><br><span class="line">    entry = entry_finder.pop(task)</span><br><span class="line">    entry[<span class="number">-1</span>] = REMOVED</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pop_task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'Remove and return the lowest priority task. Raise KeyError if empty.'</span></span><br><span class="line">    <span class="keyword">while</span> pq:</span><br><span class="line">        priority, count, task = heappop(pq)</span><br><span class="line">        <span class="keyword">if</span> task <span class="keyword">is</span> <span class="keyword">not</span> REMOVED:</span><br><span class="line">            <span class="keyword">del</span> entry_finder[task]</span><br><span class="line">            <span class="keyword">return</span> task</span><br><span class="line">    <span class="keyword">raise</span> KeyError(<span class="string">'pop from an empty priority queue'</span>)</span><br></pre></td></tr></table></figure><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>堆是通过数组来实现的，其中的元素从 0 开始计数，对于所有的 <em>k</em> 都有 <code>a[k] &lt;= a[2*k+1]</code> 且 <code>a[k] &lt;= a[2*k+2]</code>。 为了便于比较，不存在的元素被视为无穷大。 堆最有趣的特性在于 <code>a[0]</code> 总是其中最小的元素。</p><p>上面的特殊不变量是用来作为一场锦标赛的高效内存表示。 下面的数字是 <em>k</em> 而不是 <code>a[k]</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">              <span class="number">1</span>                               <span class="number">2</span></span><br><span class="line"></span><br><span class="line">      <span class="number">3</span>               <span class="number">4</span>                <span class="number">5</span>               <span class="number">6</span></span><br><span class="line"></span><br><span class="line">  <span class="number">7</span>       <span class="number">8</span>       <span class="number">9</span>       <span class="number">10</span>      <span class="number">11</span>      <span class="number">12</span>      <span class="number">13</span>      <span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span> <span class="number">16</span>   <span class="number">17</span> <span class="number">18</span>   <span class="number">19</span> <span class="number">20</span>   <span class="number">21</span> <span class="number">22</span>   <span class="number">23</span> <span class="number">24</span>   <span class="number">25</span> <span class="number">26</span>   <span class="number">27</span> <span class="number">28</span>   <span class="number">29</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>在上面的树中，每个 <em>k</em> 单元都位于 <code>2*k+1</code> 和 <code>2*k+2</code> 之上。 体育运动中我们经常见到二元锦标赛模式，每个胜者单元都位于另两个单元之上，并且我们可以沿着树形图向下追溯胜者所遇到的所有对手。 但是，在许多采用这种锦标赛模式的计算机应用程序中，我们并不需要追溯胜者的历史。 为了获得更高的内存利用效率，当一个胜者晋级时，我们会用较低层级的另一条目来替代它，因此规则变为一个单元和它之下的两个单元包含三个不同条目，上方单元“胜过”了两个下方单元。</p><p>如果此堆的不变量始终受到保护，则序号 0 显然是最后的赢家。 删除它并找出“下一个”赢家的最简单算法方式是家某个输家（让我们假定是上图中的 30 号单元）移至 0 号位置，然后将这个新的 0 号沿树下行，不断进行值的交换，直到不变量重新建立。 这显然会是树中条目总数的对数。 通过迭代所有条目，你将得到一个 O(n log n) 复杂度的排序。</p><p>此排序有一个很好的特性就是你可以在排序进行期间高效地插入新条目，前提是插入的条目不比你最近取出的 0 号元素“更好”。 这在模拟上下文时特别有用，在这种情况下树保存的是所有传入事件，“胜出”条件是最小调度时间。 当一个事件将其他事件排入执行计划时，它们的调试时间向未来方向延长，这样它们可方便地入堆。 因此，堆结构很适宜用来实现调度器，我的 MIDI 音序器就是用的这个 :-)。</p><p>用于实现调度器的各种结构都得到了充分的研究，堆是非常适宜的一种，因为它们的速度相当快，并且几乎是恒定的，最坏的情况与平均情况没有太大差别。 虽然还存在其他总体而言更高效的实现方式，但其最坏的情况却可能非常糟糕。</p><p>堆在大磁盘排序中也非常有用。 你应该已经了解大规模排序会有多个“运行轮次”（即预排序的序列，其大小通常与 CPU 内存容量相关），随后这些轮次会进入合并通道，轮次合并的组织往往非常巧妙 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#id2" target="_blank" rel="noopener">1</a>。 非常重要的一点是初始排序应产生尽可能长的运行轮次。 锦标赛模式是达成此目标的好办法。 如果你使用全部有用内存来进行锦标赛，替换和安排恰好适合当前运行轮次的条目，你将可以对于随机输入生成两倍于内存大小的运行轮次，对于模糊排序的输入还会有更好的效果。</p><p>另外，如果你输出磁盘上的第 0 个条目并获得一个可能不适合当前锦标赛的输入（因为其值要“胜过”上一个输出值），它无法被放入堆中，因此堆的尺寸将缩小。 被释放的内存可以被巧妙地立即重用以逐步构建第二个堆，其增长速度与第一个堆的缩减速度正好相同。 当第一个堆完全消失时，你可以切换新堆并启动新的运行轮次。 这样做既聪明又高效！</p><p>总之，堆是值得了解的有用内存结构。 我在一些应用中用到了它们，并且认为保留一个 ‘heap’ 模块是很有意义的。 :-)</p><h3 id="堆排序图例"><a href="#堆排序图例" class="headerlink" title="堆排序图例"></a>堆排序图例</h3><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200117_heapq.gif?raw=true" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;python-标准库-堆队列算法-heapq&quot;&gt;&lt;a href=&quot;#python-标准库-堆队列算法-heapq&quot; class=&quot;headerlink&quot; title=&quot;python 标准库  堆队列算法 heapq&quot;&gt;&lt;/a&gt;python 标准库  堆队列算法 heapq&lt;/h2&gt;&lt;p&gt;每日一词:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pollen &lt;/p&gt;
&lt;p&gt;n 花粉&lt;/p&gt;
&lt;p&gt;例句:&lt;/p&gt;
&lt;p&gt;Good news for all you hay fever and asthma sufferers&lt;br&gt;对于花粉症和哮喘病患者是个好消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天是小年,祝大家心想事成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200117_happiness.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;源码：&lt;/strong&gt;&lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/heapq.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lib/heapq.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要模块和方法：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__all__ = [&lt;span class=&quot;string&quot;&gt;&#39;heappush&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;heappop&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;heapify&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;heapreplace&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;merge&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&#39;nlargest&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;nsmallest&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;heappushpop&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模块提供了堆队列算法的实现，也称为优先队列算法。&lt;/p&gt;
&lt;p&gt;堆是一个二叉树，它的每个父节点的值都只会小于或大于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的 &lt;em&gt;k&lt;/em&gt; ，都有 &lt;code&gt;heap[k] &amp;lt;= heap[2*k+1]&lt;/code&gt; 和 &lt;code&gt;heap[k] &amp;lt;= heap[2*k+2]&lt;/code&gt;。 为了便于比较，不存在的元素被认为是无限大。 堆最有趣的特性在于最小的元素总是在根结点：&lt;code&gt;heap[0]&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="heapq" scheme="https://pinghailinfeng.gitee.io/tags/heapq/"/>
    
  </entry>
  
  <entry>
    <title>python standard library calendar</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/16/python-standard-library-calendar/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/16/python-standard-library-calendar/</id>
    <published>2020-01-16T00:50:37.000Z</published>
    <updated>2020-01-19T00:52:18.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-calendar"><a href="#python-标准库-calendar" class="headerlink" title="python 标准库 calendar"></a>python 标准库 calendar</h1><p>每日一词:</p><blockquote><p>calendar</p><p> <strong>英</strong> [ˈkælɪndə(r)]    <strong>美</strong> [ˈkælɪndər] </p><ul><li>n. 日历；[天] 历法；日程表</li><li>vt. 将…列入表中；将…排入日程表</li></ul><p>短语</p><p><strong><a href="http://dict.youdao.com/w/eng/chinese_calendar/#keyfrom=dict.phrase.wordgroup" target="_blank" rel="noopener">chinese calendar</a></strong> 中国传统历法 ; 阴历 ; 中国农历</p><p><strong><a href="http://dict.youdao.com/w/eng/lunar_calendar/#keyfrom=dict.phrase.wordgroup" target="_blank" rel="noopener">lunar calendar</a></strong> 阴历 ; 夏历 ; 来自日月星辰的力量 ; 太阴历</p><p><strong><a href="http://dict.youdao.com/w/eng/solar_calendar/#keyfrom=dict.phrase.wordgroup" target="_blank" rel="noopener">solar calendar</a></strong> 太阳历 ; 公历 ; 阳历与阴历</p></blockquote><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200116_canlendar_3.png?raw=true" alt></p><p>还有几天就过年了,2020年充满了期待,你呢？</p><p>今天我们学习python 标准库 calendar 。</p><blockquote><p>输出像 Unix <strong>cal</strong> 那样的日历，它还提供了其它与日历相关的实用函数。 默认情况下，这些日历把星期一当作一周的第一天，星期天为一周的最后一天（按照欧洲惯例）。 可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.setfirstweekday" target="_blank" rel="noopener"><code>setfirstweekday()</code></a> 方法设置一周的第一天为星期天 (6) 或者其它任意一天。 使用整数作为指定日期的参数。 更多相关的函数，参见 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#module-datetime" target="_blank" rel="noopener"><code>datetime</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块。 </p></blockquote><p> 在这个模块中定义的函数和类都基于一个理想化的日历，现行公历向过去和未来两个方向无限扩展。这与 Dershowitz 和 Reingold 的书 “历法计算” 中所有计算的基本日历 – “proleptic Gregorian” 日历的定义相符合。 ISO 8601标准还规定了 0 和 负数年份。0年指公元前1年， -1年指公元前2年，依此类推 .</p><a id="more"></a><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p> <strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/calendar.py" target="_blank" rel="noopener">Lib/calendar.py</a> </p><p>主要类和方法,节选自源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">"IllegalMonthError"</span>, <span class="string">"IllegalWeekdayError"</span>, <span class="string">"setfirstweekday"</span>,</span><br><span class="line">           <span class="string">"firstweekday"</span>, <span class="string">"isleap"</span>, <span class="string">"leapdays"</span>, <span class="string">"weekday"</span>, <span class="string">"monthrange"</span>,</span><br><span class="line">           <span class="string">"monthcalendar"</span>, <span class="string">"prmonth"</span>, <span class="string">"month"</span>, <span class="string">"prcal"</span>, <span class="string">"calendar"</span>,</span><br><span class="line">           <span class="string">"timegm"</span>, <span class="string">"month_name"</span>, <span class="string">"month_abbr"</span>, <span class="string">"day_name"</span>, <span class="string">"day_abbr"</span>,</span><br><span class="line">           <span class="string">"Calendar"</span>, <span class="string">"TextCalendar"</span>, <span class="string">"HTMLCalendar"</span>, <span class="string">"LocaleTextCalendar"</span>,</span><br><span class="line">           <span class="string">"LocaleHTMLCalendar"</span>, <span class="string">"weekheader"</span>]</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="class-calendar-Calendar-firstweekday-0-¶"><a href="#class-calendar-Calendar-firstweekday-0-¶" class="headerlink" title="class calendar.Calendar(firstweekday=0)¶"></a><em>class</em> <code>calendar.Calendar</code>(<em>firstweekday=0</em>)<a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar" target="_blank" rel="noopener">¶</a></h3><p>创建一个 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar" target="_blank" rel="noopener"><code>Calendar</code></a> 对象。 <em>firstweekday</em> 是一个整数，用于指定一周的第一天。 <code>0</code> 是星期一（默认值），<code>6</code> 是星期天。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar" target="_blank" rel="noopener"><code>Calendar</code></a> 对象提供了一些可被用于准备日历数据格式化的方法。 这个类本身不执行任何格式化操作。 这部分任务应由子类来完成。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar" target="_blank" rel="noopener"><code>Calendar</code></a> 类的实例有下列方法：</p><ul><li><p><code>iterweekdays</code>()</p><p>返回一个迭代器，迭代器的内容为一星期的数字。迭代器的第一个值与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.firstweekday" target="_blank" rel="noopener"><code>firstweekday</code></a> 属性的值一至。</p></li><li><p><code>itermonthdates</code>(<em>year</em>, <em>month</em>)</p><p>返回一个迭代器，迭代器的内容为 <em>year</em> 年 <em>month</em> 月(1-12)的日期。这个迭代器返回当月的所有日期 ( <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 对象)，日期包含了本月头尾用于组成完整一周的日期。</p></li><li><p><code>itermonthdays</code>(<em>year</em>, <em>month</em>)</p><p>返回一个迭代器，迭代器的内容与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.itermonthdates" target="_blank" rel="noopener"><code>itermonthdates()</code></a> 类似，为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 范围限制。返回的日期为当月每一天的日期对应的天数。对于不在当月的日期，显示为 <code>0</code>。</p></li><li><p><code>itermonthdays2</code>(<em>year</em>, <em>month</em>)</p><p>返回一个迭代器，迭代器的内容与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.itermonthdates" target="_blank" rel="noopener"><code>itermonthdates()</code></a> 类似为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 范围的限制。迭代器中的元素为一个由日期和代表星期几的数字组成的的元组。</p></li><li><p><code>itermonthdays3</code>(<em>year</em>, <em>month</em>)</p><p>返回一个迭代器，迭代器的内容与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.itermonthdates" target="_blank" rel="noopener"><code>itermonthdates()</code></a> 类似为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 范围的限制。迭代器的元素为一个由年，月，日组成的元组。<em>3.7 新版功能.</em></p></li><li><p><code>itermonthdays4</code>(<em>year</em>, <em>month</em>)</p><p>返回一个迭代器，迭代器的内容与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.itermonthdates" target="_blank" rel="noopener"><code>itermonthdates()</code></a> 类似为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 范围的限制。迭代器的元素为一个由年，月，日和代表星期几的数字组成的元组。<em>3.7 新版功能.</em></p></li><li><p><code>monthdatescalendar</code>(<em>year</em>, <em>month</em>)</p><p>返回一个表示指定年月的周列表。周列表由七个 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 对象组成。</p></li><li><p><code>monthdays2calendar</code>(<em>year</em>, <em>month</em>)</p><p>返回一个表示指定年月的周列表。周列表由七个代表日期的数字和代表周几的数字组成的二元元组。</p></li><li><p><code>monthdayscalendar</code>(<em>year</em>, <em>month</em>)</p><p>返回一个表示指定年月的周列表。周列表由七个代表日期的数字组成。</p></li><li><p><code>yeardatescalendar</code>(<em>year</em>, <em>width=3</em>)</p><p>返回可以用来格式化的指定年月的数据。返回的值是一个列表，列表是月份组成的行。每一行包含了最多 <em>width</em> 个月(默认为3)。每个月包含了4到6周，每周包含1–7天。每一天使用 <a href="https://docs.python.org/zh-cn/3.8/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>datetime.date</code></a> 对象。</p></li><li><p><code>yeardays2calendar</code>(<em>year</em>, <em>width=3</em>)</p><p>返回可以用来模式化的指定年月的数据(与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.yeardatescalendar" target="_blank" rel="noopener"><code>yeardatescalendar()</code></a> 类似)。周列表的元素是由表示日期的数字和表示星期几的数字组成的元组。不在这个月的日子为0。</p></li><li><p><code>yeardayscalendar</code>(<em>year</em>, <em>width=3</em>)</p><p>返回可以用来模式化的指定年月的数据(与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.Calendar.yeardatescalendar" target="_blank" rel="noopener"><code>yeardatescalendar()</code></a> 类似)。周列表的元素是表示日期的数字。不在这个月的日子为0。</p></li></ul><h3 id="class-calendar-TextCalendar-firstweekday-0"><a href="#class-calendar-TextCalendar-firstweekday-0" class="headerlink" title="class calendar.TextCalendar(firstweekday=0)"></a><em>class</em> <code>calendar.TextCalendar</code>(<em>firstweekday=0</em>)</h3><p>可以使用这个类生成纯文本日历。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar" target="_blank" rel="noopener"><code>TextCalendar</code></a> 实例有以下方法：</p><ul><li><p><code>formatmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p><p>返回一个多行字符串来表示指定年月的日历。<em>w</em> 为日期的宽度，但始终保持日期居中。<em>l</em> 指定了每星期占用的行数。以上这些还依赖于构造器或者 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.setfirstweekday" target="_blank" rel="noopener"><code>setfirstweekday()</code></a> 方法指定的周的第一天是哪一天。</p></li><li><p><code>prmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar.formatmonth" target="_blank" rel="noopener"><code>formatmonth()</code></a> 方法一样，返回一个月的日历。</p></li><li><p><code>formatyear</code>(<em>theyear</em>, <em>w=2</em>, <em>l=1</em>, <em>c=6</em>, <em>m=3</em>)</p><p>返回一个多行字符串，这个字符串为一个 <em>m</em> 列日历。可选参数 <em>w</em>, <em>l</em>, 和 <em>c</em> 分别表示日期列数， 周的行数， 和月之间的间隔。同样，以上这些还依赖于构造器或者 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.setfirstweekday" target="_blank" rel="noopener"><code>setfirstweekday()</code></a> 指定哪一天为一周的第一天。日历的第一年由平台依赖于使用的平台。</p></li><li><p><code>pryear</code>(<em>theyear</em>, <em>w=2</em>, <em>l=1</em>, <em>c=6</em>, <em>m=3</em>)</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar.formatyear" target="_blank" rel="noopener"><code>formatyear()</code></a> 方法一样，返回一整年的日历。</p></li></ul><h3 id="class-calendar-HTMLCalendar-firstweekday-0"><a href="#class-calendar-HTMLCalendar-firstweekday-0" class="headerlink" title="class calendar.HTMLCalendar(firstweekday=0)"></a><em>class</em> <code>calendar.HTMLCalendar</code>(<em>firstweekday=0</em>)</h3><p>可以使用这个类生成 HTML 日历。<code>HTMLCalendar</code> 实例有以下方法：<code>formatmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>withyear=True</em>)返回一个 HTML 表格作为指定年月的日历。 <em>withyear</em> 为真，则年份将会包含在表头，否则只显示月份。<code>formatyear</code>(<em>theyear</em>, <em>width=3</em>)返回一个 HTML 表格作为指定年份的日历。 <em>width</em> (默认为3) 用于规定每一行显示月份的数量。<code>formatyearpage</code>(<em>theyear</em>, <em>width=3</em>, <em>css=’calendar.css’</em>, <em>encoding=None</em>)返回一个完整的 HTML 页面作为指定年份的日历。 <em>width\</em>(默认为3) 用于规定每一行显示的月份数量。 *css<em> 为层叠样式表的名字。如果不使用任何层叠样式表，可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 。 </em>encoding* 为输出页面的编码 (默认为系统的默认编码)。<code>HTMLCalendar</code> 有以下属性，你可以重载它们来自定义应用日历的样式。</p><ul><li><strong><code>cssclasses</code></strong>一个对应星期一到星期天的 CSS class 列表。默认列表为</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cssclasses = [<span class="string">"mon"</span>, <span class="string">"tue"</span>, <span class="string">"wed"</span>, <span class="string">"thu"</span>, <span class="string">"fri"</span>, <span class="string">"sat"</span>, <span class="string">"sun"</span>]</span><br></pre></td></tr></table></figure><p> 可以向每天加入其它样式 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cssclasses = [<span class="string">"mon text-bold"</span>, <span class="string">"tue"</span>, <span class="string">"wed"</span>, <span class="string">"thu"</span>, <span class="string">"fri"</span>, <span class="string">"sat"</span>, <span class="string">"sun red"</span>]</span><br></pre></td></tr></table></figure><p> 需要注意的是，列表的长度必须为7。 </p><ul><li><p><strong>cssclass_noday</strong> </p><p>工作日的 CSS 类在上个月或下个月发生。 </p></li><li><p><code>cssclasses_weekday_head</code></p><p>用于标题行中的工作日名称的 CSS 类 列表。默认值与 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.HTMLCalendar.cssclasses" target="_blank" rel="noopener"><code>cssclasses</code></a> 相同。<em>3.7 新版功能.</em></p></li><li><p><code>cssclass_month_head</code></p><p>月份的头 CSS 类（由 <code>formatmonthname()</code> 使用）。默认值为 <code>&quot;month&quot;</code> 。<em>3.7 新版功能.</em></p></li><li><p><code>cssclass_month</code></p><p>某个月的月历的 CSS 类（由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.HTMLCalendar.formatmonth" target="_blank" rel="noopener"><code>formatmonth()</code></a> 使用）。默认值为 <code>&quot;month&quot;</code> 。<em>3.7 新版功能.</em></p></li><li><p><code>cssclass_year</code></p><p>某年的年历的 CSS 类（由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.HTMLCalendar.formatyear" target="_blank" rel="noopener"><code>formatyear()</code></a> 使用）。默认值为 <code>&quot;year&quot;</code> 。<em>3.7 新版功能.</em></p></li><li><p><code>cssclass_year_head</code></p><p>年历的·表头 CSS 类（由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.HTMLCalendar.formatyear" target="_blank" rel="noopener"><code>formatyear()</code></a> 使用）。默认值为 <code>&quot;year&quot;</code> 。<em>3.7 新版功能.</em></p></li></ul><p>需要注意的是，尽管上面命名的样式类都是单独出现的(如： <code>cssclass_month</code> <code>cssclass_noday</code>), 但我们可以使用空格将样式类列表中的多个元素分隔开，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"text-bold text-red"</span></span><br></pre></td></tr></table></figure><p> 下面是一个如何自定义 <code>HTMLCalendar</code> 的示例 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLCal</span><span class="params">(calendar.HTMLCalendar)</span>:</span></span><br><span class="line">    cssclasses = [style + <span class="string">" text-nowrap"</span> <span class="keyword">for</span> style <span class="keyword">in</span></span><br><span class="line">                  calendar.HTMLCalendar.cssclasses]</span><br><span class="line">    cssclass_month_head = <span class="string">"text-center month-head"</span></span><br><span class="line">    cssclass_month = <span class="string">"text-center month"</span></span><br><span class="line">    cssclass_year = <span class="string">"text-italic lead"</span></span><br></pre></td></tr></table></figure><h3 id="class-calendar-LocaleTextCalendar-firstweekday-0-locale-None"><a href="#class-calendar-LocaleTextCalendar-firstweekday-0-locale-None" class="headerlink" title="class calendar.LocaleTextCalendar(firstweekday=0, locale=None)"></a><em>class</em> <code>calendar.LocaleTextCalendar</code>(<em>firstweekday=0</em>, <em>locale=None</em>)</h3><p>这个子类 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar" target="_blank" rel="noopener"><code>TextCalendar</code></a> 可以在构造函数中传递一个语言环境名称，并且返回月份和星期几的名称在特定语言环境中。如果此语言环境包含编码，则包含月份和工作日名称的所有字符串将作为 unicode 返回。</p><h3 id="class-calendar-LocaleHTMLCalendar-firstweekday-0-locale-None"><a href="#class-calendar-LocaleHTMLCalendar-firstweekday-0-locale-None" class="headerlink" title="class calendar.LocaleHTMLCalendar(firstweekday=0, locale=None)"></a><em>class</em> <code>calendar.LocaleHTMLCalendar</code>(<em>firstweekday=0</em>, <em>locale=None</em>)</h3><ul><li><p><code>calendar.setfirstweekday</code>(<em>weekday</em>)</p><p>设置每一周的开始(<code>0</code> 表示星期一，<code>6</code> 表示星期天)。calendar还提供了 <code>MONDAY</code>, <code>TUESDAY</code>, <code>WEDNESDAY</code>, <code>THURSDAY</code>, <code>FRIDAY</code>, <code>SATURDAY</code> 和 <code>SUNDAY</code> 几个常量方便使用。例如，设置每周的第一天为星期天</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line">calendar.setfirstweekday(calendar.SUNDAY)</span><br></pre></td></tr></table></figure></li><li><p><code>calendar.firstweekday</code>()</p><p>返回当前设置的每星期的第一天的数值。</p></li><li><p><code>calendar.isleap</code>(<em>year</em>)</p><p>如果 <em>year</em> 是闰年则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a> ,否则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>。</p></li><li><p><code>calendar.leapdays</code>(<em>y1</em>, <em>y2</em>)</p><p>返回在范围 <em>y1</em> 至 <em>y2</em> （包含 y1 和 y2 ）之间的闰年的年数，其中 <em>y1</em> 和 <em>y2</em> 是年份。此函数适用于跨越一个世纪变化的范围。</p></li><li><p><code>calendar.weekday</code>(<em>year</em>, <em>month</em>, <em>day</em>)</p><p>返回某年（ <code>1970</code> – …），某月（ <code>1</code> – <code>12</code> ），某日（ <code>1</code> – <code>31</code> ）是星期几（ <code>0</code> 是星期一）。</p></li><li><p><code>calendar.weekheader</code>(<em>n</em>)</p><p>返回一个包含星期几的缩写名的头。 <em>n</em> 指定星期几缩写的字符宽度。</p></li><li><p><code>calendar.monthrange</code>(<em>year</em>, <em>month</em>)</p><p>返回指定 <em>年份</em> 的指定 <em>月份</em> 的第一天是星期几和这个月的天数。</p></li><li><p><code>calendar.monthcalendar</code>(<em>year</em>, <em>month</em>)</p><p>返回表示一个月的日历的矩阵。每一行代表一周；此月份外的日子由零表示。除非由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.setfirstweekday" target="_blank" rel="noopener"><code>setfirstweekday()</code></a> 设置，否则每周以周一为始。</p></li><li><p><code>calendar.prmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p><p>打印由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.month" target="_blank" rel="noopener"><code>month()</code></a> 返回的一个月的日历。</p></li><li><p><code>calendar.month</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar" target="_blank" rel="noopener"><code>TextCalendar</code></a> 类的 <code>formatmonth()</code> 以多行字符串形式返回月份日历。</p></li><li><p><code>calendar.prcal</code>(<em>year</em>, <em>w=0</em>, <em>l=0</em>, <em>c=6</em>, <em>m=3</em>)</p><p>打印由 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#module-calendar" target="_blank" rel="noopener"><code>calendar()</code></a> 返回的整年的日历。</p></li><li><p><code>calendar.calendar</code>(<em>year</em>, <em>w=2</em>, <em>l=1</em>, <em>c=6</em>, <em>m=3</em>)</p><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.TextCalendar" target="_blank" rel="noopener"><code>TextCalendar</code></a> 类的 <code>formatyear()</code> 返回整年的3列的日历以多行字符串的形式。</p></li><li><p><code>calendar.timegm</code>(<em>tuple</em>)</p><p>一个不相关但很好用的函数，它接受一个时间元组例如 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块中的 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#time.gmtime" target="_blank" rel="noopener"><code>gmtime()</code></a> 函数的返回并返回相应的 Unix 时间戳值，假定 1970 年开始计数， POSIX 编码。实际上， <a href="https://docs.python.org/zh-cn/3.8/library/time.html#time.gmtime" target="_blank" rel="noopener"><code>time.gmtime()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.timegm" target="_blank" rel="noopener"><code>timegm()</code></a> 是彼此相反的。</p></li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li><p><code>calendar.day_name</code></p><p>在当前语言环境下表示星期几的数组。</p></li><li><p><code>calendar.day_abbr</code></p><p>在当前语言环境下表示星期几缩写的数组。</p></li><li><p><code>calendar.month_name</code></p><p>在当前语言环境下表示一年中月份的数组。这遵循一月的月号为 1 的通常惯例，所以它的长度为 13 且 <code>month_name[0]</code> 是空字符串。</p></li><li><p><code>calendar.month_abbr</code></p><p>在当前语言环境下表示月份简写的数组。这遵循一月的月号为 1 的通常惯例，所以它的长度为 13 且 <code>month_abbr[0]</code> 是空字符串。</p></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200116_canlendar_4.png?raw=true" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> 默认情况下，这些日历将星期一作为一周的第一天，将星期日作为一周的最后一天(欧洲惯例)。不过，我们可以使用<code>setfirstweekday()</code>方法来设置一周的第一天为星期日或h者其他工作日，指定的日期以整数形式给出。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-calendar&quot;&gt;&lt;a href=&quot;#python-标准库-calendar&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 calendar&quot;&gt;&lt;/a&gt;python 标准库 calendar&lt;/h1&gt;&lt;p&gt;每日一词:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;calendar&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;英&lt;/strong&gt; [ˈkælɪndə(r)]    &lt;strong&gt;美&lt;/strong&gt; [ˈkælɪndər] &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n. 日历；[天] 历法；日程表&lt;/li&gt;
&lt;li&gt;vt. 将…列入表中；将…排入日程表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;短语&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://dict.youdao.com/w/eng/chinese_calendar/#keyfrom=dict.phrase.wordgroup&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;chinese calendar&lt;/a&gt;&lt;/strong&gt; 中国传统历法 ; 阴历 ; 中国农历&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://dict.youdao.com/w/eng/lunar_calendar/#keyfrom=dict.phrase.wordgroup&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lunar calendar&lt;/a&gt;&lt;/strong&gt; 阴历 ; 夏历 ; 来自日月星辰的力量 ; 太阴历&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://dict.youdao.com/w/eng/solar_calendar/#keyfrom=dict.phrase.wordgroup&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;solar calendar&lt;/a&gt;&lt;/strong&gt; 太阳历 ; 公历 ; 阳历与阴历&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200116_canlendar_3.png?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;还有几天就过年了,2020年充满了期待,你呢？&lt;/p&gt;
&lt;p&gt;今天我们学习python 标准库 calendar 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输出像 Unix &lt;strong&gt;cal&lt;/strong&gt; 那样的日历，它还提供了其它与日历相关的实用函数。 默认情况下，这些日历把星期一当作一周的第一天，星期天为一周的最后一天（按照欧洲惯例）。 可以使用 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/calendar.html#calendar.setfirstweekday&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;setfirstweekday()&lt;/code&gt;&lt;/a&gt; 方法设置一周的第一天为星期天 (6) 或者其它任意一天。 使用整数作为指定日期的参数。 更多相关的函数，参见 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/datetime.html#module-datetime&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/time.html#module-time&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; 模块。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 在这个模块中定义的函数和类都基于一个理想化的日历，现行公历向过去和未来两个方向无限扩展。这与 Dershowitz 和 Reingold 的书 “历法计算” 中所有计算的基本日历 – “proleptic Gregorian” 日历的定义相符合。 ISO 8601标准还规定了 0 和 负数年份。0年指公元前1年， -1年指公元前2年，依此类推 .&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="calendar" scheme="https://pinghailinfeng.gitee.io/tags/calendar/"/>
    
  </entry>
  
  <entry>
    <title>python standard library iterator and generator</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/15/python-standard-library-iterator-and-generator/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/15/python-standard-library-iterator-and-generator/</id>
    <published>2020-01-14T22:30:45.000Z</published>
    <updated>2020-01-17T01:00:01.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-类型：-迭代器-和-生成器"><a href="#python-标准库-类型：-迭代器-和-生成器" class="headerlink" title="python 标准库 类型： 迭代器 和 生成器"></a>python 标准库 类型： 迭代器 和 生成器</h1><p>每日英语:</p><blockquote><p> miracle n </p><p> [英]   <strong>[</strong>ˈmɪrəkl<strong>]</strong>   [美] [ <strong>ˈmɪrəkəl</strong> ]</p><p> 奇迹，圣迹，神迹； 令人惊奇的人（或事） </p></blockquote><p>推荐一个老电影：</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200115_miracle.jpg?raw=true" alt></p><p>每个人终将都会踏上自己的绿色旅程,善恶就在一念之间。愿世界美好,温情以待。</p><p>先看一张图:</p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200115_python_iterator_generator.jpg?raw=true" alt></p><blockquote><p>1，迭代器协议：对象需要提供next()方法，它要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代。</p><p>2，可迭代对象：实现了迭代器协议对象。list、tuple、dict都是Iterable（可迭代对象），但不是Iterator（迭代器对象）。但可以使用内建函数iter()，把这些都变成Iterable（可迭代器对象）。</p><p>3，for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束</p></blockquote><a id="more"></a><h2 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h2><p>Python 支持在容器中进行迭代的概念。 这是通过使用两个单独方法来实现的；它们被用于允许用户自定义类对迭代的支持。 将在下文中详细描述的序列总是支持迭代方法。</p><p>容器对象要提供迭代支持，必须定义一个方法:</p><ul><li><p><code>container.__iter__</code>()</p><p>返回一个迭代器对象。 该对象需要支持下文所述的迭代器协议。 如果容器支持不同的迭代类型，则可以提供额外的方法来专门地请求不同迭代类型的迭代器。 （支持多种迭代形式的对象的例子有同时支持广度优先和深度优先遍历的树结构。） 此方法对应于 Python/C API 中 Python 对象类型结构体的 <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_iter" target="_blank" rel="noopener"><code>tp_iter</code></a> 槽位。</p></li></ul><p>迭代器对象自身需要支持以下两个方法，它们共同组成了 <em>迭代器协议</em>:</p><ul><li><p><code>iterator.__iter__</code>()</p><p>返回迭代器对象本身。 这是同时允许容器和迭代器配合 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#for" target="_blank" rel="noopener"><code>for</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a> 语句使用所必须的。 此方法对应于 Python/C API 中 Python 对象类型结构体的 <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_iter" target="_blank" rel="noopener"><code>tp_iter</code></a> 槽位。</p></li><li><p><code>iterator.__next__</code>()</p><p>从容器中返回下一项。 如果已经没有项可返回，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 异常。 此方法对应于 Python/C API 中 Python 对象类型结构体的 <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_iternext" target="_blank" rel="noopener"><code>tp_iternext</code></a> 槽位。</p></li></ul><p>Python 定义了几种迭代器对象以支持对一般和特定序列类型、字典和其他更特别的形式进行迭代。 除了迭代器协议的实现，特定类型的其他性质对迭代操作来说都不重要。</p><p>一旦迭代器的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法引发了 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a>，它必须一直对后续调用引发同样的异常。 不遵循此行为特性的实现将无法正常使用。</p><p>迭代器使用实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随便定义一个list</span></span><br><span class="line">listArray=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 使用iter()函数</span></span><br><span class="line">iterName=iter(listArray)</span><br><span class="line">print(iterName)</span><br><span class="line"><span class="comment"># 结果如下：是一个列表list的迭代器</span></span><br><span class="line"><span class="comment"># &lt;list_iterator object at 0x0000017B0D984278&gt;</span></span><br><span class="line"></span><br><span class="line">print(next(iterName))</span><br><span class="line">print(next(iterName))</span><br><span class="line">print(next(iterName))</span><br><span class="line">print(next(iterName))<span class="comment">#没有迭代到下一个元素，直接抛出异常</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File "python_iterator.py", line 32, in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure><p>自定义迭代器实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span></span><br><span class="line">        super(Fib, self).__init__()</span><br><span class="line">        self.max = max</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fib = self.a</span><br><span class="line">        <span class="keyword">if</span> fib &gt; self.max:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">return</span> fib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个main函数，循环遍历每一个菲波那切数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 20以内的数</span></span><br><span class="line">    fib = Fib(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fib:</span><br><span class="line">        print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="生成器类型"><a href="#生成器类型" class="headerlink" title="生成器类型"></a>生成器类型</h3><p>Python 的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 提供了一种实现迭代器协议的便捷方式。 如果容器对象 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 方法被实现为一个生成器，它将自动返回一个迭代器对象（从技术上说是一个生成器对象），该对象提供 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法。 有关生成器的更多信息可以参阅 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#yieldexpr" target="_blank" rel="noopener">yield 表达式的文档</a>。</p><h4 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 菲波那切数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fib</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'亲！没有数据了...'</span></span><br><span class="line"><span class="comment"># 调用方法，生成出10个数来</span></span><br><span class="line">f=Fib(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 使用一个循环捕获最后return 返回的值，保存在异常StopIteration的value中</span></span><br><span class="line"><span class="keyword">while</span>  <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x=next(f)</span><br><span class="line">        print(<span class="string">"f:"</span>,x)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"生成器最后的返回值是："</span>,e.value)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h4 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个列表</span></span><br><span class="line">xiaoke=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 生成器generator，类似于list，但是是把[]改为()</span></span><br><span class="line">gen=(a <span class="keyword">for</span> a  <span class="keyword">in</span> xiaoke)</span><br><span class="line"><span class="keyword">for</span>  i  <span class="keyword">in</span> gen:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment">#结果是：</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么要使用生成器？因为效率。</span></span><br><span class="line"><span class="comment"># 使用生成器表达式取代列表推导式可以同时节省 cpu 和 内存(RAM)。</span></span><br><span class="line"><span class="comment"># 如果你构造一个列表(list)的目的仅仅是传递给别的函数,</span></span><br><span class="line"><span class="comment"># 比如 传递给tuple()或者set(), 那就用生成器表达式替代吧!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本案例是直接把列表转化为元组</span></span><br><span class="line">kk=tuple(a <span class="keyword">for</span> a <span class="keyword">in</span> xiaoke)</span><br><span class="line">print(kk)</span><br><span class="line"><span class="comment">#结果是：</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python内置的一些函数，可以识别这是生成器表达式，外面有一对小括号，就是生成器</span></span><br><span class="line">result1=sum(a <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line">print(result1)</span><br><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">result2=sum([a <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">3</span>)])</span><br><span class="line">print(result2)</span><br></pre></td></tr></table></figure><h4 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h4><p>使用yield关键字实现生成器函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span>  </span><br><span class="line">    a, b = <span class="number">1</span>, <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">while</span> a &lt; max:  </span><br><span class="line">        <span class="keyword">yield</span> a <span class="comment">#这时a,b值分别为1,1，当然，程序也在执行到这时，返回  </span></span><br><span class="line">        a, b = b, a+b</span><br></pre></td></tr></table></figure><p>使用yield关键字实现自定义生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span>  </span><br><span class="line">        self.max = max  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        self.a = <span class="number">0</span>  </span><br><span class="line">        self.b = <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">return</span> self  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        fib = self.a  </span><br><span class="line">        <span class="keyword">if</span> fib &gt; self.max:  </span><br><span class="line">            <span class="keyword">raise</span> StopIteration  </span><br><span class="line">        self.a, self.b = self.b, self.a + self.b  </span><br><span class="line">        <span class="keyword">return</span> fib  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> Fib(<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">print</span> f</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-类型：-迭代器-和-生成器&quot;&gt;&lt;a href=&quot;#python-标准库-类型：-迭代器-和-生成器&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 类型： 迭代器 和 生成器&quot;&gt;&lt;/a&gt;python 标准库 类型： 迭代器 和 生成器&lt;/h1&gt;&lt;p&gt;每日英语:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; miracle n &lt;/p&gt;
&lt;p&gt; [英]   &lt;strong&gt;[&lt;/strong&gt;ˈmɪrəkl&lt;strong&gt;]&lt;/strong&gt;   [美] [ &lt;strong&gt;ˈmɪrəkəl&lt;/strong&gt; ]&lt;/p&gt;
&lt;p&gt; 奇迹，圣迹，神迹； 令人惊奇的人（或事） &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐一个老电影：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200115_miracle.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;每个人终将都会踏上自己的绿色旅程,善恶就在一念之间。愿世界美好,温情以待。&lt;/p&gt;
&lt;p&gt;先看一张图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200115_python_iterator_generator.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1，迭代器协议：对象需要提供next()方法，它要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代。&lt;/p&gt;
&lt;p&gt;2，可迭代对象：实现了迭代器协议对象。list、tuple、dict都是Iterable（可迭代对象），但不是Iterator（迭代器对象）。但可以使用内建函数iter()，把这些都变成Iterable（可迭代器对象）。&lt;/p&gt;
&lt;p&gt;3，for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="iterator" scheme="https://pinghailinfeng.gitee.io/tags/iterator/"/>
    
      <category term="generator" scheme="https://pinghailinfeng.gitee.io/tags/generator/"/>
    
  </entry>
  
  <entry>
    <title>python standard library pickle</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/14/python-standard-library-pickle/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/14/python-standard-library-pickle/</id>
    <published>2020-01-14T02:48:51.000Z</published>
    <updated>2020-01-14T03:44:09.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-pickle"><a href="#python-标准库-pickle" class="headerlink" title="python 标准库 pickle"></a>python 标准库 pickle</h1><p>快过年了,准备了一些过节用的英语</p><blockquote><ol><li><p>传统中国节日：traditional Chinese festival</p></li><li><p>农历：lunar calendar</p></li><li><p>腊八节：Laba Festival</p></li><li><p>小年：Little New Year</p></li><li><p>除夕：Lunar New Year’s Eve</p></li><li><p>春节：the Spring Festival</p></li><li><p>正月初一：the lunar New Year’s Day</p></li><li><p>元宵节：the Lantern Festival</p></li><li><p>正月：the first month of the lunar year</p></li><li><p>二月二：Dragon Heads-raising Day</p></li></ol></blockquote><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200114_guonian1.jpg?raw=true" alt></p><p>时间过得好快,又是一年过去了。</p><h2 id="python-标准库学习之-pickle"><a href="#python-标准库学习之-pickle" class="headerlink" title="python 标准库学习之 pickle"></a>python 标准库学习之 pickle</h2><p>常用的文本处理 除了文件,数据库,json,xml 以外,python还提供了一种存储方案,这就是<code>pickle</code>。</p><blockquote><p>模块 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 实现了对一个 Python 对象结构的二进制序列化和反序列化。<em>“pickling”</em> 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 <em>“unpickling”</em> 是相反的操作，会将（来自一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a> 或者 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 的）字节流转化回一个对象层次结构。 pickling（和 unpickling）也被称为“序列化”, “编组” 或者 “平面化”。而为了避免混乱，此处采用术语 “封存 (pickling)” 和 “解封 (unpickling)”。</p></blockquote><blockquote><p><em>警告</em> :  <code>pickle</code> 模块<strong>并不安全</strong>。你只应该对你信任的数据进行unpickle操作。构建恶意的 pickle 数据来<strong>在解封时执行任意代码</strong>是可能的。绝对不要对不信任来源的数据和可能被篡改过的数据进行解封。请考虑使用 <a href="https://docs.python.org/zh-cn/3/library/hmac.html#module-hmac" target="_blank" rel="noopener"><code>hmac</code></a> 来对数据进行签名，确保数据没有被篡改。在你处理不信任数据时，更安全的序列化格式如 <a href="https://docs.python.org/zh-cn/3/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 可能更为适合。参见 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#comparison-with-json" target="_blank" rel="noopener">与 json 模块的比较</a> </p></blockquote><h3 id="源代码：-Lib-pickle-py"><a href="#源代码：-Lib-pickle-py" class="headerlink" title="源代码： Lib/pickle.py"></a><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/pickle.py" target="_blank" rel="noopener">Lib/pickle.py</a></h3><p>本节内容比较多,先看下类层次结构,有一个大体的概念(节选自源码)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Classes:</span><br><span class="line">    Pickler</span><br><span class="line">    Unpickler</span><br><span class="line">Functions:</span><br><span class="line">    dump(object, file)</span><br><span class="line">    dumps(object) -&gt; string</span><br><span class="line">    load(file) -&gt; object</span><br><span class="line">    loads(string) -&gt; object</span><br><span class="line">Misc variables:</span><br><span class="line">    __version__</span><br><span class="line">    format_version</span><br><span class="line">    compatible_formats</span><br><span class="line">    </span><br><span class="line">__all__ = [<span class="string">"PickleError"</span>, <span class="string">"PicklingError"</span>, <span class="string">"UnpicklingError"</span>, <span class="string">"Pickler"</span>,</span><br><span class="line">           <span class="string">"Unpickler"</span>, <span class="string">"dump"</span>, <span class="string">"dumps"</span>, <span class="string">"load"</span>, <span class="string">"loads"</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="数据流格式"><a href="#数据流格式" class="headerlink" title="数据流格式"></a>数据流格式</h3><p><a href="https://docs.python.org/zh-cn/3/library/pickletools.html#module-pickletools" target="_blank" rel="noopener"><code>pickletools</code></a> 模块包含了相应的工具用于分析 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 生成的数据流。<a href="https://docs.python.org/zh-cn/3/library/pickletools.html#module-pickletools" target="_blank" rel="noopener"><code>pickletools</code></a> 源码中包含了对 pickle 协议使用的操作码的大量注释。</p><p>当前共有 6 种不同的协议可用于封存操作。 使用的协议版本越高，读取所生成 pickle 对象所需的 Python 版本就要越新。</p><ul><li>v0 版协议是原始的“人类可读”协议，并且向后兼容早期版本的 Python。</li><li>v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容。</li><li>v2 版协议是在 Python 2.3 中引入的。它为存储 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-new-style-class" target="_blank" rel="noopener">new-style class</a> 提供了更高效的机制。欲了解有关第 2 版协议带来的改进，请参阅 <a href="https://www.python.org/dev/peps/pep-0307" target="_blank" rel="noopener"><strong>PEP 307</strong></a>。</li><li>v3 版协议是在 Python 3.0 中引入的。 它显式地支持 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 字节对象，不能使用 Python 2.x 解封。这是 Python 3.0-3.7 的默认协议。</li><li>v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化。它是Python 3.8使用的默认协议。有关第 4 版协议带来改进的信息，请参阅 <a href="https://www.python.org/dev/peps/pep-3154" target="_blank" rel="noopener"><strong>PEP 3154</strong></a>。</li><li>第 5 版协议是在 Python 3.8 中加入的。 它增加了对带外数据的支持，并可加速带内数据处理。 请参阅 <a href="https://www.python.org/dev/peps/pep-0574" target="_blank" rel="noopener"><strong>PEP 574</strong></a> 了解第 5 版协议所带来的改进的详情。</li></ul><h3 id="模块接口"><a href="#模块接口" class="headerlink" title="模块接口"></a>模块接口</h3><p>要序列化某个包含层次结构的对象，只需调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dumps" target="_blank" rel="noopener"><code>dumps()</code></a> 函数即可。同样，要反序列化数据流，可以调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.loads" target="_blank" rel="noopener"><code>loads()</code></a> 函数。但是，如果要对序列化和反序列化加以更多的控制，可以分别创建 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> 对象。</p><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块包含了以下常量：</p><ul><li><p><code>pickle.HIGHEST_PROTOCOL</code></p><p>整数，可用的最高 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-protocols" target="_blank" rel="noopener">协议版本</a>。此值可以作为 <em>协议</em> 值传递给 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dump" target="_blank" rel="noopener"><code>dump()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dumps" target="_blank" rel="noopener"><code>dumps()</code></a> 函数，以及 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的构造函数。</p></li><li><p><code>pickle.DEFAULT_PROTOCOL</code></p><p>整数，用于 pickle 数据的默认 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-protocols" target="_blank" rel="noopener">协议版本</a>。它可能小于 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.HIGHEST_PROTOCOL" target="_blank" rel="noopener"><code>HIGHEST_PROTOCOL</code></a>。当前默认协议是 v4，它在 Python 3.4 中首次引入，与之前的版本不兼容。<em>在 3.8 版更改:</em> 默认协议版本还是 4。</p></li></ul><h3 id="模块方法"><a href="#模块方法" class="headerlink" title="模块方法"></a>模块方法</h3><ul><li><p><code>pickle.dump</code>(<em>obj</em>, <em>file</em>, <em>protocol=None</em>, <em>**, </em>fix_imports=True<em>, </em>buffer_callback=None*)</p><p>将对象 <em>obj</em> 封存以后的对象写入已打开的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> <em>file</em>。它等同于 <code>Pickler(file, protocol).dump(obj)</code>。参数 <em>file</em>、<em>protocol</em>、<em>fix_imports</em> 和 <em>buffer_callback</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的构造函数中的含义相同。<em>在 3.8 版更改:</em> 加入了 <em>buffer_callback</em> 参数。</p></li><li><p><code>pickle.dumps</code>(<em>obj</em>, <em>protocol=None</em>, <em>**, </em>fix_imports=True<em>, </em>buffer_callback=None*)</p><p>将 <em>obj</em> 封存以后的对象作为 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型直接返回，而不是将其写入到文件。参数 <em>protocol</em>、<em>fix_imports</em> 和 <em>buffer_callback</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的构造函数中的含义相同。<em>在 3.8 版更改:</em> 加入了 <em>buffer_callback</em> 参数。</p></li><li><p><code>pickle.load</code>(<em>file</em>, <em>**, </em>fix_imports=True<em>, </em>encoding=”ASCII”<em>, </em>errors=”strict”<em>, </em>buffers=None*)</p><p>从已打开的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> <em>文件</em> 中读取封存后的对象，重建其中特定对象的层次结构并返回。它相当于 <code>Unpickler(file).load()</code>。Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。封存对象以外的其他字节将被忽略。参数 <em>file</em>、<em>fix_imports</em>、<em>encoding</em>、<em>errors</em>、<em>strict</em> 和 <em>buffers</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> 的构造函数中的含义相同。<em>在 3.8 版更改:</em> 加入了 <em>buffers</em> 参数。</p></li><li><p><code>pickle.loads</code>(<em>bytes_object</em>, <em>**, </em>fix_imports=True<em>, </em>encoding=”ASCII”<em>, </em>errors=”strict”<em>, </em>buffers=None*)</p><p>对于封存生成的对象 <em>bytes_object</em>，还原出原对象的结构并返回。Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。封存对象以外的其他字节将被忽略。参数 <em>file</em>、<em>fix_imports</em>、<em>encoding</em>、<em>errors</em>、<em>strict</em> 和 <em>buffers</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> 的构造函数中的含义相同。</p></li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块定义了以下 3 个异常：</p><ul><li><p><em>exception</em> <code>pickle.PickleError</code></p><p>其他 pickle 异常的基类。它是 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>pickle.PicklingError</code></p><p>当 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 遇到无法解封的对象时抛出此错误。它是 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleError" target="_blank" rel="noopener"><code>PickleError</code></a> 的子类。参考 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-picklable" target="_blank" rel="noopener">可以被封存/解封的对象</a> 来了解哪些对象可以被封存。</p></li><li><p><em>exception</em> <code>pickle.UnpicklingError</code></p><p>当解封出错时抛出此异常，例如数据损坏或对象不安全。它是 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleError" target="_blank" rel="noopener"><code>PickleError</code></a> 的子类。注意，解封时可能还会抛出其他异常，包括（但不限于） AttributeError、EOFError、ImportError 和 IndexError。</p></li></ul><h3 id="模块中的类"><a href="#模块中的类" class="headerlink" title="模块中的类"></a>模块中的类</h3><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块包含了 3 个类，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a>、<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a>：</p><h4 id="Pickler"><a href="#Pickler" class="headerlink" title="Pickler"></a>Pickler</h4><p><em>class</em> <code>pickle.Pickler</code>(<em>file</em>, <em>protocol=None</em>, <em>**, </em>fix_imports=True<em>, </em>buffer_callback=None*)</p><p>它接受一个二进制文件用于写入 pickle 数据流。</p><p>可选参数 <em>protocol</em> 是一个整数，告知 pickler 使用指定的协议，可选择的协议范围从 0 到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.HIGHEST_PROTOCOL" target="_blank" rel="noopener"><code>HIGHEST_PROTOCOL</code></a>。如果没有指定，这一参数默认值为 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.DEFAULT_PROTOCOL" target="_blank" rel="noopener"><code>DEFAULT_PROTOCOL</code></a>。指定一个负数就相当于指定 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.HIGHEST_PROTOCOL" target="_blank" rel="noopener"><code>HIGHEST_PROTOCOL</code></a>。</p><p>参数 <em>file</em> 必须有一个 write() 方法，该 write() 方法要能接收字节作为其唯一参数。因此，它可以是一个打开的磁盘文件（用于写入二进制内容），也可以是一个 <a href="https://docs.python.org/zh-cn/3/library/io.html#io.BytesIO" target="_blank" rel="noopener"><code>io.BytesIO</code></a> 实例，也可以是满足这一接口的其他任何自定义对象。</p><p>如果 <em>fix_imports</em> 为 True 且 <em>protocol</em> 小于 3，pickle 将尝试将 Python 3 中的新名称映射到 Python 2 中的旧模块名称，因此 Python 2 也可以读取封存的数据流。</p><p>如果 <em>buffer_callback</em> 为 None（默认情况），缓冲区视图（buffer view）将会作为 pickle 流的一部分被序列化到 <em>file</em> 中。</p><p>如果 <em>buffer_callback</em> 不为 None，那它可以用缓冲区视图调用任意次。如果某次调用返回了 False 值（例如 None），则给定的缓冲区是 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-oob" target="_blank" rel="noopener">带外的</a>，否则缓冲区是带内的（例如保存在了 pickle 流里面）。</p><p>如果 <em>buffer_callback</em> 不是 None 且 <em>protocol</em> 是 None 或小于 5，就会出错。</p><p><em>在 3.8 版更改:</em> 加入了 <em>buffer_callback</em> 参数。</p><ul><li><p><code>dump</code>(<em>obj</em>)</p><p>将 <em>obj</em> 封存后的内容写入已打开的文件对象，该文件对象已经在构造函数中指定。</p></li><li><p><code>persistent_id</code>(<em>obj</em>)</p><p>默认无动作，子类继承重载时使用。如果 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.persistent_id" target="_blank" rel="noopener"><code>persistent_id()</code></a> 返回 <code>None</code>，<em>obj</em> 会被照常 pickle。如果返回其他值，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 会将这个函数的返回值作为 <em>obj</em> 的持久化 ID（Pickler 本应得到序列化数据流并将其写入文件，若此函数有返回值，则得到此函数的返回值并写入文件）。这个持久化 ID 的解释应当定义在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.persistent_load" target="_blank" rel="noopener"><code>Unpickler.persistent_load()</code></a> 中（该方法定义还原对象的过程，并返回得到的对象）。注意，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.persistent_id" target="_blank" rel="noopener"><code>persistent_id()</code></a> 的返回值本身不能拥有持久化 ID。参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-persistent" target="_blank" rel="noopener">持久化外部对象</a> 获取详情和使用示例。</p></li><li><p><code>dispatch_table</code></p><p>Pickler 对象的 dispatch 表是 <a href="https://docs.python.org/zh-cn/3/library/copyreg.html#copyreg.pickle" target="_blank" rel="noopener"><code>copyreg.pickle()</code></a> 中用到的 <em>reduction 函数</em> 的注册。dispatch 表本身是一个 class 到其 reduction 函数的映射键值对。一个 reduction 函数只接受一个参数，就是其关联的 class，函数行为应当遵守 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 接口规范。Pickler 对象默认并没有 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 属性，该对象默认使用 <a href="https://docs.python.org/zh-cn/3/library/copyreg.html#module-copyreg" target="_blank" rel="noopener"><code>copyreg</code></a> 模块中定义的全局 dispatch 表。如果要为特定 Pickler 对象自定义序列化过程，可以将 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 属性设置为类字典对象（dict-like object）。另外，如果 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的子类设置了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 属性，则该子类的实例会使用这个表作为默认的 dispatch 表。参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-dispatch" target="_blank" rel="noopener">Dispatch 表</a> 获取使用示例。<em>3.3 新版功能.</em></p></li><li><p><code>reducer_override</code>(<em>self</em>, <em>obj</em>)</p><p>可以在 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 的子类中定义的特殊 reducer。此方法的优先级高于 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 中的任何 reducer。它应该与 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 方法遵循相同的接口，它也可以返回 <code>NotImplemented</code>，这将使用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 里注册的 reducer 来封存 <code>obj</code>。</p></li></ul><h4 id="Unpickler"><a href="#Unpickler" class="headerlink" title="Unpickler"></a>Unpickler</h4><p><em>class</em> <code>pickle.Unpickler</code>(<em>file</em>, <em>**, </em>fix_imports=True<em>, </em>encoding=”ASCII”<em>, </em>errors=”strict”<em>, </em>buffers=None*)</p><p>它接受一个二进制文件用于读取 pickle 数据流。</p><p>Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。</p><p>参数 <em>file</em> 必须有三个方法，read() 方法接受一个整数参数，readinto() 方法接受一个缓冲区作为参数，readline() 方法不需要参数，这与 <a href="https://docs.python.org/zh-cn/3/library/io.html#io.BufferedIOBase" target="_blank" rel="noopener"><code>io.BufferedIOBase</code></a> 里定义的接口是相同的。因此 <em>file</em> 可以是一个磁盘上用于二进制读取的文件，也可以是一个 <a href="https://docs.python.org/zh-cn/3/library/io.html#io.BytesIO" target="_blank" rel="noopener"><code>io.BytesIO</code></a> 实例，也可以是满足这一接口的其他任何自定义对象。</p><p>可选的参数是 <em>fix_imports</em>, <em>encoding</em> 和 <em>errors</em>，用于控制由Python 2 生成的 pickle 流的兼容性。如果 <em>fix_imports</em> 为 True，则 pickle 将尝试将旧的 Python 2 名称映射到 Python 3 中对应的新名称。<em>encoding</em> 和 <em>errors</em> 参数告诉 pickle 如何解码 Python 2 存储的 8 位字符串实例；这两个参数默认分别为 ‘ASCII’ 和 ‘strict’。<em>encoding</em> 参数可置为 ‘bytes’ 来将这些 8 位字符串实例读取为字节对象。读取 NumPy array 和 Python 2 存储的 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.datetime" target="_blank" rel="noopener"><code>datetime</code></a>、<a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.date" target="_blank" rel="noopener"><code>date</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/datetime.html#datetime.time" target="_blank" rel="noopener"><code>time</code></a> 实例时，请使用 <code>encoding=&#39;latin1&#39;</code>。</p><p>如果 <em>buffers</em> 为 None（默认值），则反序列化所需的所有数据都必须包含在 pickle 流中。这意味着在实例化 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 时（或调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dump" target="_blank" rel="noopener"><code>dump()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dumps" target="_blank" rel="noopener"><code>dumps()</code></a> 时），参数 <em>buffer_callback</em> 为 None。</p><p>如果 <em>buffers</em> 不为 None，则每次 pickle 流引用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-oob" target="_blank" rel="noopener">带外</a> 缓冲区视图时，消耗的对象都应该是可迭代的启用缓冲区的对象。这样的缓冲区应该按顺序地提供给 Pickler 对象的 <em>buffer_callback</em> 方法。</p><p><em>在 3.8 版更改:</em> 加入了 <em>buffers</em> 参数。</p><ul><li><p><code>load</code>()</p><p>从构造函数中指定的文件对象里读取封存好的对象，重建其中特定对象的层次结构并返回。封存对象以外的其他字节将被忽略。</p></li><li><p><code>persistent_load</code>(<em>pid</em>)</p><p>默认抛出 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.UnpicklingError" target="_blank" rel="noopener"><code>UnpicklingError</code></a> 异常。如果定义了此方法，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.persistent_load" target="_blank" rel="noopener"><code>persistent_load()</code></a> 应当返回持久化 ID <em>pid</em> 所指定的对象。 如果遇到无效的持久化 ID，则应当引发 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.UnpicklingError" target="_blank" rel="noopener"><code>UnpicklingError</code></a>。参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-persistent" target="_blank" rel="noopener">持久化外部对象</a> 获取详情和使用示例。</p></li><li><p><code>find_class</code>(<em>module</em>, <em>name</em>)</p><p>如有必要，导入 <em>module</em> 模块并返回其中名叫 <em>name</em> 的对象，其中 <em>module</em> 和 <em>name</em> 参数都是 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 对象。注意，不要被这个函数的名字迷惑， <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.find_class" target="_blank" rel="noopener"><code>find_class()</code></a> 同样可以用来导入函数。子类可以重载此方法，来控制加载对象的类型和加载对象的方式，从而尽可能降低安全风险。参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-restrict" target="_blank" rel="noopener">限制全局变量</a> 获取更详细的信息。引发一个 <a href="https://docs.python.org/zh-cn/3/library/sys.html#auditing" target="_blank" rel="noopener">审核事件</a> <code>pickle.find_class</code> 附带参数 <code>module</code>、<code>name</code>。</p></li></ul><h4 id="PickleBuffer"><a href="#PickleBuffer" class="headerlink" title="PickleBuffer"></a>PickleBuffer</h4><p><em>class</em> <code>pickle.PickleBuffer</code>(<em>buffer</em>)</p><p>缓冲区的包装器 (wrapper)，缓冲区中包含着可封存的数据。<em>buffer</em> 必须是一个 <a href="https://docs.python.org/zh-cn/3/c-api/buffer.html#bufferobjects" target="_blank" rel="noopener">buffer-providing</a> 对象，比如 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 或多维数组。</p><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 本身就可以生成缓冲区对象，因此可以将其传递给需要缓冲区生成器的其他 API，比如 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview</code></a>。</p><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 对象只能用 pickle 版本 5 及以上协议进行序列化。它们符合 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-oob" target="_blank" rel="noopener">带外序列化</a> 的条件。</p><p><em>3.8 新版功能.</em></p><ul><li><p><code>raw</code>()</p><p>返回该缓冲区底层内存区域的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview</code></a>。 返回的对象是一维的、C 连续布局的 memoryview，格式为 <code>B</code> (无符号字节)。 如果缓冲区既不是 C 连续布局也不是 Fortran 连续布局的，则抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#BufferError" target="_blank" rel="noopener"><code>BufferError</code></a> 异常。</p></li><li><p><code>release</code>()</p><p>释放由 PickleBuffer 占用的底层缓冲区。</p></li></ul><h3 id="可以被封存-解封的对象"><a href="#可以被封存-解封的对象" class="headerlink" title="可以被封存/解封的对象"></a>可以被封存/解封的对象</h3><p>下列类型可以被封存：</p><ul><li><code>None</code>、<code>True</code> 和 <code>False</code></li><li>整数、浮点数、复数</li><li>str、byte、bytearray</li><li>只包含可封存对象的集合，包括 tuple、list、set 和 dict</li><li>定义在模块最外层的函数（使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#def" target="_blank" rel="noopener"><code>def</code></a> 定义，<a href="https://docs.python.org/zh-cn/3/reference/expressions.html#lambda" target="_blank" rel="noopener"><code>lambda</code></a> 函数则不可以）</li><li>定义在模块最外层的内置函数</li><li>定义在模块最外层的类</li><li>某些类实例，这些类的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 属性值或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a> 函数的返回值可以被封存（详情参阅 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle-inst" target="_blank" rel="noopener">封存类实例</a> 这一段）。</li></ul><p>尝试封存不能被封存的对象会抛出 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PicklingError" target="_blank" rel="noopener"><code>PicklingError</code></a> 异常，异常发生时，可能有部分字节已经被写入指定文件中。尝试封存递归层级很深的对象时，可能会超出最大递归层级限制，此时会抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#RecursionError" target="_blank" rel="noopener"><code>RecursionError</code></a> 异常，可以通过 <a href="https://docs.python.org/zh-cn/3/library/sys.html#sys.setrecursionlimit" target="_blank" rel="noopener"><code>sys.setrecursionlimit()</code></a> 调整递归层级，不过请谨慎使用这个函数，因为可能会导致解释器崩溃。</p><p><strong>注意</strong></p><ol><li><p>函数封存</p><blockquote><p>函数（内置函数或用户自定义函数）在被封存时，引用的是函数全名。<a href="https://docs.python.org/zh-cn/3/library/pickle.html#id8" target="_blank" rel="noopener">2</a> 这意味着只有函数所在的模块名，与函数名会被封存，函数体及其属性不会被封存。因此，在解封的环境中，函数所属的模块必须是可以被导入的，而且模块必须包含这个函数被封存时的名称，否则会抛出异常。</p></blockquote></li><li><p>类封存</p><blockquote><p>类也只封存名称，所以在解封环境中也有和函数相同的限制。注意，类体及其数据不会被封存，所以在下面的例子中类属性 <code>attr</code> 不会存在于解封后的环境中：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    attr = <span class="string">'A class attribute'</span></span><br><span class="line"></span><br><span class="line">picklestring = pickle.dumps(Foo)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>类的实例封存</p><blockquote><p>在封存类的实例时，其类体和类数据不会跟着实例一起被封存，只有实例数据会被封存。这样设计是有目的的，在将来修复类中的错误、给类增加方法之后，仍然可以载入原来版本类实例的封存数据来还原该实例。如果你准备长期使用一个对象，可能会同时存在较多版本的类体，可以为对象添加版本号，这样就可以通过类的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 方法将老版本转换成新版本</p></blockquote></li></ol><h3 id="封存类实例"><a href="#封存类实例" class="headerlink" title="封存类实例"></a>封存类实例</h3><blockquote><p>通常，使一个实例可被封存不需要附加任何代码。Pickle 默认会通过 Python 的内省机制获得实例的类及属性。而当实例解封时，它的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>__init__()</code></a> 方法通常 <em>不会</em> 被调用。其默认动作是：先创建一个未初始化的实例，然后还原其属性，下面的代码展示了这种行为的实现机制：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (obj.__class__, obj.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(cls, attributes)</span>:</span></span><br><span class="line">    obj = cls.__new__(cls)</span><br><span class="line">    obj.__dict__.update(attributes)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><p>类可以改变默认行为，只需定义以下一种或几种特殊方法：</p><ul><li><p><code>object.__getnewargs_ex__</code>()</p><p>对于使用第 2 版或更高版协议的 pickle，实现了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a> 方法的类可以控制在解封时传给 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 方法的参数。本方法必须返回一对 <code>(args, kwargs)</code> 用于构建对象，其中 <em>args</em> 是表示位置参数的 tuple，而 <em>kwargs</em> 是表示命名参数的 dict。它们会在解封时传递给 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 方法。如果类的 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 方法只接受关键字参数，则应当实现这个方法。否则，为了兼容性，更推荐实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs__" target="_blank" rel="noopener"><code>__getnewargs__()</code></a> 方法。<em>在 3.6 版更改:</em> <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a> 现在可用于第 2 和第 3 版协议。</p></li><li><p><code>object.__getnewargs__</code>()</p><p>这个方法与上一个 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a> 方法类似，但仅支持位置参数。它要求返回一个 tuple 类型的 <code>args</code>，用于解封时传递给 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__new__" target="_blank" rel="noopener"><code>__new__()</code></a> 方法。如果定义了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a>，那么 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs__" target="_blank" rel="noopener"><code>__getnewargs__()</code></a> 就不会被调用。<em>在 3.6 版更改:</em> 在 Python 3.6 前，第 2、3 版协议会调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs__" target="_blank" rel="noopener"><code>__getnewargs__()</code></a>，更高版本协议会调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getnewargs_ex__" target="_blank" rel="noopener"><code>__getnewargs_ex__()</code></a>。</p></li><li><p><code>object.__getstate__</code>()</p><p>类还可以进一步控制其实例的封存过程。如果类定义了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a>，它就会被调用，其返回的对象是被当做实例内容来封存的，否则封存的是实例的 <strong>dict</strong>。如果 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a> 未定义，实例的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 会被照常封存。</p></li><li><p><code>object.__setstate__</code>(<em>state</em>)</p><p>当解封时，如果类定义了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a>，就会在已解封状态下调用它。此时不要求实例的 state 对象必须是 dict。没有定义此方法的话，先前封存的 state 对象必须是 dict，且该 dict 内容会在解封时赋给新实例的 <strong>dict</strong>。</p><p>==备注==： 如果 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a> 返回 False，那么在解封时就不会调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 方法。 </p></li><li><p><code>object.__reduce__</code>()</p><p>该接口当前定义如下。<a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 方法不带任何参数，并且应返回字符串或最好返回一个元组（返回的对象通常称为“reduce 值”）。如果返回字符串，该字符串会被当做一个全局变量的名称。它应该是对象相对于其模块的本地名称，pickle 模块会搜索模块命名空间来确定对象所属的模块。这种行为常在单例模式使用。如果返回的是元组，则应当包含 2 到 6 个元素，可选元素可以省略或设置为 <code>None</code>。每个元素代表的意义如下：一个可调用对象，该对象会在创建对象的最初版本时调用。可调用对象的参数，是一个元组。如果可调用对象不接受参数，必须提供一个空元组。可选元素，用于表示对象的状态，将被传给前述的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 方法。 如果对象没有此方法，则这个元素必须是字典类型，并会被添加至 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__" target="_blank" rel="noopener"><code>__dict__</code></a> 属性中。可选元素，一个返回连续项的迭代器（而不是序列）。这些项会被 <code>obj.append(item)</code> 逐个加入对象，或被 <code>obj.extend(list_of_items)</code> 批量加入对象。这个元素主要用于 list 的子类，也可以用于那些正确实现了 <code>append()</code> 和 <code>extend()</code> 方法的类。（具体是使用 <code>append()</code> 还是 <code>extend()</code> 取决于 pickle 协议版本以及待插入元素的项数，所以这两个方法必须同时被类支持。）可选元素，一个返回连续键值对的迭代器（而不是序列）。这些键值对将会以 <code>obj[key] = value</code> 的方式存储于对象中。该元素主要用于 dict 子类，也可以用于那些实现了 <a href="https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__setitem__" target="_blank" rel="noopener"><code>__setitem__()</code></a> 的类。可选元素，一个带有 <code>(obj, state)</code> 签名的可调用对象。该可调用对象允许用户以编程方式控制特定对象的状态更新行为，而不是使用 <code>obj</code> 的静态 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 方法。如果此处不是 <code>None</code>，则此可调用对象的优先级高于 <code>obj</code> 的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a>。<em>3.8 新版功能:</em> 新增了元组的第 6 项，可选元素 <code>(obj, state)</code>。</p></li><li><p><code>object.__reduce_ex__</code>(<em>protocol</em>)</p><p>作为替代选项，也可以实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce_ex__" target="_blank" rel="noopener"><code>__reduce_ex__()</code></a> 方法。 此方法的唯一不同之处在于它应接受一个整型参数用于指定协议版本。 如果定义了这个函数，则会覆盖 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 的行为。 此外，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a> 方法会自动成为扩展版方法的同义词。 这个函数主要用于为以前的 Python 版本提供向后兼容的 reduce 值。</p></li></ul><h3 id="持久化外部对象"><a href="#持久化外部对象" class="headerlink" title="持久化外部对象"></a>持久化外部对象</h3><p>为了获取对象持久化的利益， <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块支持引用已封存数据流之外的对象。 这样的对象是通过一个持久化 ID 来引用的，它应当是一个由字母数字类字符组成的字符串 (对于第 0 版协议) <a href="https://docs.python.org/zh-cn/3/library/pickle.html#id11" target="_blank" rel="noopener">5</a> 或是一个任意对象 (用于任意新版协议)。</p><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块不提供对持久化 ID 的解析工作，它将解析工作分配给用户定义的方法，分别是 pickler 中的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.persistent_id" target="_blank" rel="noopener"><code>persistent_id()</code></a> 方法和 unpickler 中的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.persistent_load" target="_blank" rel="noopener"><code>persistent_load()</code></a> 方法。</p><p>要通过持久化 ID 将外部对象封存，必须在 pickler 中实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.persistent_id" target="_blank" rel="noopener"><code>persistent_id()</code></a> 方法，该方法接受需要被封存的对象作为参数，返回一个 <code>None</code> 或返回该对象的持久化 ID。如果返回 <code>None</code>，该对象会被按照默认方式封存为数据流。如果返回字符串形式的持久化 ID，则会封存这个字符串并加上一个标记，这样 unpickler 才能将其识别为持久化 ID。</p><p>要解封外部对象，Unpickler 必须实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.persistent_load" target="_blank" rel="noopener"><code>persistent_load()</code></a> 方法，接受一个持久化 ID 对象作为参数并返回一个引用的对象。</p><p>下面是一个全面的例子，展示了如何使用持久化 ID 来封存外部对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Simple example presenting how persistent ID can be used to pickle</span></span><br><span class="line"><span class="comment"># external objects by reference.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># Simple class representing a record in our database.</span></span><br><span class="line">MemoRecord = namedtuple(<span class="string">"MemoRecord"</span>, <span class="string">"key, task"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBPickler</span><span class="params">(pickle.Pickler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">persistent_id</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="comment"># Instead of pickling MemoRecord as a regular class instance, we emit a</span></span><br><span class="line">        <span class="comment"># persistent ID.</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, MemoRecord):</span><br><span class="line">            <span class="comment"># Here, our persistent ID is simply a tuple, containing a tag and a</span></span><br><span class="line">            <span class="comment"># key, which refers to a specific record in the database.</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="string">"MemoRecord"</span>, obj.key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># If obj does not have a persistent ID, return None. This means obj</span></span><br><span class="line">            <span class="comment"># needs to be pickled as usual.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBUnpickler</span><span class="params">(pickle.Unpickler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, file, connection)</span>:</span></span><br><span class="line">        super().__init__(file)</span><br><span class="line">        self.connection = connection</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">persistent_load</span><span class="params">(self, pid)</span>:</span></span><br><span class="line">        <span class="comment"># This method is invoked whenever a persistent ID is encountered.</span></span><br><span class="line">        <span class="comment"># Here, pid is the tuple returned by DBPickler.</span></span><br><span class="line">        cursor = self.connection.cursor()</span><br><span class="line">        type_tag, key_id = pid</span><br><span class="line">        <span class="keyword">if</span> type_tag == <span class="string">"MemoRecord"</span>:</span><br><span class="line">            <span class="comment"># Fetch the referenced record from the database and return it.</span></span><br><span class="line">            cursor.execute(<span class="string">"SELECT * FROM memos WHERE key=?"</span>, (str(key_id),))</span><br><span class="line">            key, task = cursor.fetchone()</span><br><span class="line">            <span class="keyword">return</span> MemoRecord(key, task)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Always raises an error if you cannot return the correct object.</span></span><br><span class="line">            <span class="comment"># Otherwise, the unpickler will think None is the object referenced</span></span><br><span class="line">            <span class="comment"># by the persistent ID.</span></span><br><span class="line">            <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">"unsupported persistent object"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> io</span><br><span class="line">    <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize and populate our database.</span></span><br><span class="line">    conn = sqlite3.connect(<span class="string">":memory:"</span>)</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(<span class="string">"CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)"</span>)</span><br><span class="line">    tasks = (</span><br><span class="line">        <span class="string">'give food to fish'</span>,</span><br><span class="line">        <span class="string">'prepare group meeting'</span>,</span><br><span class="line">        <span class="string">'fight with a zebra'</span>,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        cursor.execute(<span class="string">"INSERT INTO memos VALUES(NULL, ?)"</span>, (task,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Fetch the records to be pickled.</span></span><br><span class="line">    cursor.execute(<span class="string">"SELECT * FROM memos"</span>)</span><br><span class="line">    memos = [MemoRecord(key, task) <span class="keyword">for</span> key, task <span class="keyword">in</span> cursor]</span><br><span class="line">    <span class="comment"># Save the records using our custom DBPickler.</span></span><br><span class="line">    file = io.BytesIO()</span><br><span class="line">    DBPickler(file).dump(memos)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Pickled records:"</span>)</span><br><span class="line">    pprint.pprint(memos)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Update a record, just for good measure.</span></span><br><span class="line">    cursor.execute(<span class="string">"UPDATE memos SET task='learn italian' WHERE key=1"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load the records from the pickle data stream.</span></span><br><span class="line">    file.seek(<span class="number">0</span>)</span><br><span class="line">    memos = DBUnpickler(file, conn).load()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Unpickled records:"</span>)</span><br><span class="line">    pprint.pprint(memos)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="自定义封存-Dispatch-表"><a href="#自定义封存-Dispatch-表" class="headerlink" title="自定义封存 Dispatch 表"></a>自定义封存 Dispatch 表</h3><p>如果想对某些类进行自定义封存，而又不想在类中增加用于封存的代码，就可以创建带有特殊 dispatch 表的 pickler。</p><p>在 <a href="https://docs.python.org/zh-cn/3/library/copyreg.html#module-copyreg" target="_blank" rel="noopener"><code>copyreg</code></a> 模块的 <code>copyreg.dispatch_table</code> 中定义了全局 dispatch 表。因此，可以使用 <code>copyreg.dispatch_table</code> 修改后的副本作为自有 dispatch 表。</p><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = io.BytesIO()</span><br><span class="line">p = pickle.Pickler(f)</span><br><span class="line">p.dispatch_table = copyreg.dispatch_table.copy()</span><br><span class="line">p.dispatch_table[SomeClass] = reduce_SomeClass</span><br></pre></td></tr></table></figure><p>创建了一个带有自有 dispatch 表的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>pickle.Pickler</code></a> 实例，它可以对 <code>SomeClass</code> 类进行特殊处理。另外，下列代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPickler</span><span class="params">(pickle.Pickler)</span>:</span></span><br><span class="line">    dispatch_table = copyreg.dispatch_table.copy()</span><br><span class="line">    dispatch_table[SomeClass] = reduce_SomeClass</span><br><span class="line">f = io.BytesIO()</span><br><span class="line">p = MyPickler(f)</span><br></pre></td></tr></table></figure><p>完成了相同的操作，但所有 <code>MyPickler</code> 的实例都会共用同一份 dispatch 表。使用 <a href="https://docs.python.org/zh-cn/3/library/copyreg.html#module-copyreg" target="_blank" rel="noopener"><code>copyreg</code></a> 模块实现的等效代码是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copyreg.pickle(SomeClass, reduce_SomeClass)</span><br><span class="line">f = io.BytesIO()</span><br><span class="line">p = pickle.Pickler(f)</span><br></pre></td></tr></table></figure><h3 id="处理有状态的对象"><a href="#处理有状态的对象" class="headerlink" title="处理有状态的对象"></a>处理有状态的对象</h3><blockquote><p>下面的示例展示了如何修改类在封存时的行为。其中 <code>TextReader</code> 类打开了一个文本文件，每次调用其 <code>readline()</code> 方法则返回行号和该行的字符。 在封存这个 <code>TextReader</code> 的实例时，<em>除了</em> 文件对象，其他属性都会被保存。 当解封实例时，需要重新打开文件，然后从上次的位置开始继续读取。实现这些功能需要实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__setstate__" target="_blank" rel="noopener"><code>__setstate__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__getstate__" target="_blank" rel="noopener"><code>__getstate__()</code></a> 方法。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextReader</span>:</span></span><br><span class="line">    <span class="string">"""Print and number lines in a text file."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.file = open(filename)</span><br><span class="line">        self.lineno = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readline</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.lineno += <span class="number">1</span></span><br><span class="line">        line = self.file.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> line.endswith(<span class="string">'\n'</span>):</span><br><span class="line">            line = line[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"%i: %s"</span> % (self.lineno, line)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getstate__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Copy the object's state from self.__dict__ which contains</span></span><br><span class="line">        <span class="comment"># all our instance attributes. Always use the dict.copy()</span></span><br><span class="line">        <span class="comment"># method to avoid modifying the original state.</span></span><br><span class="line">        state = self.__dict__.copy()</span><br><span class="line">        <span class="comment"># Remove the unpicklable entries.</span></span><br><span class="line">        <span class="keyword">del</span> state[<span class="string">'file'</span>]</span><br><span class="line">        <span class="keyword">return</span> state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setstate__</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        <span class="comment"># Restore instance attributes (i.e., filename and lineno).</span></span><br><span class="line">        self.__dict__.update(state)</span><br><span class="line">        <span class="comment"># Restore the previously opened file's state. To do so, we need to</span></span><br><span class="line">        <span class="comment"># reopen it and read from it until the line count is restored.</span></span><br><span class="line">        file = open(self.filename)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.lineno):</span><br><span class="line">            file.readline()</span><br><span class="line">        <span class="comment"># Finally, save the file.</span></span><br><span class="line">        self.file = file</span><br></pre></td></tr></table></figure><p>使用方法如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reader = TextReader(<span class="string">"hello.txt"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reader.readline()</span><br><span class="line"><span class="string">'1: Hello world!'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reader.readline()</span><br><span class="line"><span class="string">'2: I am line number two.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_reader = pickle.loads(pickle.dumps(reader))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_reader.readline()</span><br><span class="line"><span class="string">'3: Goodbye!'</span></span><br></pre></td></tr></table></figure><h3 id="除了Dispatcher-类型和函数及其他对象自定义规约"><a href="#除了Dispatcher-类型和函数及其他对象自定义规约" class="headerlink" title="除了Dispatcher,类型和函数及其他对象自定义规约"></a>除了Dispatcher,类型和函数及其他对象自定义规约</h3><blockquote><p>有时，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 可能不够灵活。 特别是当我们想要基于对象类型以外的其他规则来对封存进行定制，或是当我们想要对函数和类的封存进行定制的时候。</p><p>对于那些情况，可能要基于 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> 类进行子类化并实现 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.reducer_override" target="_blank" rel="noopener"><code>reducer_override()</code></a> 方法。 此方法可返回任意的归约元组 (参见 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce__" target="_blank" rel="noopener"><code>__reduce__()</code></a>)。 它也可以选择返回 <code>NotImplemented</code> 来回退到传统行为。</p><p>如果同时定义了 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.dispatch_table" target="_blank" rel="noopener"><code>dispatch_table</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.reducer_override" target="_blank" rel="noopener"><code>reducer_override()</code></a>，则 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.reducer_override" target="_blank" rel="noopener"><code>reducer_override()</code></a> 方法具有优先权。</p></blockquote><p><strong>注解</strong>：出于性能理由，可能不会为以下对象调用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler.reducer_override" target="_blank" rel="noopener"><code>reducer_override()</code></a>: <code>None</code>, <code>True</code>, <code>False</code>, 以及 <a href="https://docs.python.org/zh-cn/3/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#frozenset" target="_blank" rel="noopener"><code>frozenset</code></a>, <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#tuple" target="_blank" rel="noopener"><code>tuple</code></a> 的具体实例。</p><p>以下是一个简单的例子，其中我们允许封存并重新构建一个给定的类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    my_attribute = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPickler</span><span class="params">(pickle.Pickler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reducer_override</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="string">"""Custom reducer for MyClass."""</span></span><br><span class="line">        <span class="keyword">if</span> getattr(obj, <span class="string">"__name__"</span>, <span class="literal">None</span>) == <span class="string">"MyClass"</span>:</span><br><span class="line">            <span class="keyword">return</span> type, (obj.__name__, obj.__bases__,</span><br><span class="line">                          &#123;<span class="string">'my_attribute'</span>: obj.my_attribute&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># For any other object, fallback to usual reduction</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line">f = io.BytesIO()</span><br><span class="line">p = MyPickler(f)</span><br><span class="line">p.dump(MyClass)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> MyClass</span><br><span class="line"></span><br><span class="line">unpickled_class = pickle.loads(f.getvalue())</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> isinstance(unpickled_class, type)</span><br><span class="line"><span class="keyword">assert</span> unpickled_class.__name__ == <span class="string">"MyClass"</span></span><br><span class="line"><span class="keyword">assert</span> unpickled_class.my_attribute == <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="外部缓冲区"><a href="#外部缓冲区" class="headerlink" title="外部缓冲区"></a>外部缓冲区</h3><p>在某些场景中，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块会被用来传输海量的数据。 因此，最小化内存复制次数以保证性能和节省资源是很重要的。 但是 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块的正常运作会将图类对象结构转换为字节序列流，因此在本质上就要从封存流中来回复制数据。</p><p>如果 <em>provider</em> (待传输对象类型的实现) 和 <em>consumer</em> (通信系统的实现) 都支持 pickle 第 5 版或更高版本所提供的外部传输功能，则此约束可以被撤销。</p><h3 id="提供方API"><a href="#提供方API" class="headerlink" title="提供方API"></a>提供方API</h3><p>大的待封存数据对象必须实现协议 5 及以上版本专属的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#object.__reduce_ex__" target="_blank" rel="noopener"><code>__reduce_ex__()</code></a> 方法，该方法将为任意大的数据返回一个 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 实例（而不是 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 对象等）。</p><p><a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 对象会 <em>表明</em> 底层缓冲区可被用于外部数据传输。 那些对象仍将保持与 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块的正常用法兼容。 但是，使用方也可以选择告知 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 它们将自行处理那些缓冲区。</p><h3 id="使用方API"><a href="#使用方API" class="headerlink" title="使用方API"></a>使用方API</h3><p>当序列化一个对象图时，通信系统可以启用对所生成 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 对象的定制处理。</p><p>发送端需要传递 <em>buffer_callback</em> 参数到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Pickler" target="_blank" rel="noopener"><code>Pickler</code></a> (或是到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dump" target="_blank" rel="noopener"><code>dump()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dumps" target="_blank" rel="noopener"><code>dumps()</code></a> 函数)，该回调函数将在封存对象图时附带每个所生成的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 被调用。 由 <em>buffer_callback</em> 所累积的缓冲区的数据将不会被拷贝到 pickle 流，而是仅插入一个简单的标记。</p><p>接收端需要传递 <em>buffers</em> 参数到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler" target="_blank" rel="noopener"><code>Unpickler</code></a> (或是到 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.load" target="_blank" rel="noopener"><code>load()</code></a> 或 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.loads" target="_blank" rel="noopener"><code>loads()</code></a> 函数)，其值是一个由缓冲区组成的可迭代对象，它会被传递给 <em>buffer_callback</em>。 该可迭代对象应当按其被传递给 <em>buffer_callback</em> 时的顺序产生缓冲区。 这些缓冲区将提供对象重构造器所期望的数据，对这些数据的封存产生了原本的 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.PickleBuffer" target="_blank" rel="noopener"><code>PickleBuffer</code></a> 对象。</p><p>在发送端和接受端之间，通信系统可以自由地实现它自己用于外部缓冲区的传输机制。 潜在的优化包括使用共享内存或基于特定数据类型的压缩等。</p><p>实例:下面是一个小例子，在其中我们实现了一个 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 的子类，能够用于外部缓冲区封存:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroCopyByteArray</span><span class="params">(bytearray)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce_ex__</span><span class="params">(self, protocol)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> protocol &gt;= <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> type(self)._reconstruct, (PickleBuffer(self),), <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># PickleBuffer is forbidden with pickle protocols &lt;= 4.</span></span><br><span class="line">            <span class="keyword">return</span> type(self)._reconstruct, (bytearray(self),)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_reconstruct</span><span class="params">(cls, obj)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> memoryview(obj) <span class="keyword">as</span> m:</span><br><span class="line">            <span class="comment"># Get a handle over the original buffer object</span></span><br><span class="line">            obj = m.obj</span><br><span class="line">            <span class="keyword">if</span> type(obj) <span class="keyword">is</span> cls:</span><br><span class="line">                <span class="comment"># Original buffer object is a ZeroCopyByteArray, return it</span></span><br><span class="line">                <span class="comment"># as-is.</span></span><br><span class="line">                <span class="keyword">return</span> obj</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> cls(obj)</span><br></pre></td></tr></table></figure><p>重构造器 (<code>_reconstruct</code> 类方法) 会在缓冲区的提供对象具有正确类型时返回该对象。 在此小示例中这是模拟零拷贝行为的便捷方式。</p><p>在使用方，我们可以按通常方式封存那些对象，它们在反序列化时将提供原始对象的一个副本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = ZeroCopyByteArray(<span class="string">b"abc"</span>)</span><br><span class="line">data = pickle.dumps(b, protocol=<span class="number">5</span>)</span><br><span class="line">new_b = pickle.loads(data)</span><br><span class="line">print(b == new_b)  <span class="comment"># True</span></span><br><span class="line">print(b <span class="keyword">is</span> new_b)  <span class="comment"># False: a copy was made</span></span><br></pre></td></tr></table></figure><p>但是如果我们传入 <em>buffer_callback</em> 然后在反序列化时给回累积的缓冲区，我们就能够取回原始对象:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b = ZeroCopyByteArray(<span class="string">b"abc"</span>)</span><br><span class="line">buffers = []</span><br><span class="line">data = pickle.dumps(b, protocol=<span class="number">5</span>, buffer_callback=buffers.append)</span><br><span class="line">new_b = pickle.loads(data, buffers=buffers)</span><br><span class="line">print(b == new_b)  <span class="comment"># True</span></span><br><span class="line">print(b <span class="keyword">is</span> new_b)  <span class="comment"># True: no copy was made</span></span><br></pre></td></tr></table></figure><p>这个例子受限于 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 会自行分配内存这一事实：你无法基于另一个对象的内存创建 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 的实例。 但是，第三方数据类型例如 NumPy 数组则没有这种限制，允许在单独进程或系统间传输时使用零拷贝的封存（或是尽可能少地拷贝） 。</p><blockquote><p>参见：<a href="https://www.python.org/dev/peps/pep-0574" target="_blank" rel="noopener"><strong>PEP 574</strong></a> – 带有外部数据缓冲区的 pickle 协议 5</p></blockquote><h3 id="限制全局变量"><a href="#限制全局变量" class="headerlink" title="限制全局变量"></a>限制全局变量</h3><p>默认情况下，解封将会导入在 pickle 数据中找到的任何类或函数。 对于许多应用来说，此行为是不可接受的，因为它会允许解封器导入并发起调用任意代码。 只须考虑当这个手工构建的 pickle 数据流被加载时会做什么:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.loads(<span class="string">b"cos\nsystem\n(S'echo hello world'\ntR."</span>)</span><br><span class="line">hello world</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>在这个例子里，解封器导入 <a href="https://docs.python.org/zh-cn/3/library/os.html#os.system" target="_blank" rel="noopener"><code>os.system()</code></a> 函数然后应用字符串参数 “echo hello world”。 虽然这个例子不具攻击性，但是不难想象别人能够通过此方式对你的系统造成损害。</p><p>出于这样的理由，你可能会希望通过定制 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.find_class" target="_blank" rel="noopener"><code>Unpickler.find_class()</code></a> 来控制要解封的对象。 与其名称所提示的不同，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.Unpickler.find_class" target="_blank" rel="noopener"><code>Unpickler.find_class()</code></a> 会在执行对任何全局对象（例如一个类或一个函数）的请求时被调用。 因此可以完全禁止全局对象或是将它们限制在一个安全的子集中。</p><p>下面的例子是一个解封器，它只允许某一些安全的来自 <a href="https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins" target="_blank" rel="noopener"><code>builtins</code></a> 模块的类被加载:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">safe_builtins = &#123;</span><br><span class="line">    <span class="string">'range'</span>,</span><br><span class="line">    <span class="string">'complex'</span>,</span><br><span class="line">    <span class="string">'set'</span>,</span><br><span class="line">    <span class="string">'frozenset'</span>,</span><br><span class="line">    <span class="string">'slice'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RestrictedUnpickler</span><span class="params">(pickle.Unpickler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_class</span><span class="params">(self, module, name)</span>:</span></span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">"builtins"</span> <span class="keyword">and</span> name <span class="keyword">in</span> safe_builtins:</span><br><span class="line">            <span class="keyword">return</span> getattr(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">"global '%s.%s' is forbidden"</span> %</span><br><span class="line">                                     (module, name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restricted_loads</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""Helper function analogous to pickle.loads()."""</span></span><br><span class="line">    <span class="keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</span><br></pre></td></tr></table></figure><p>我们这个解封器的一个示例用法所达成的目标:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>restricted_loads(pickle.dumps([<span class="number">1</span>, <span class="number">2</span>, range(<span class="number">15</span>)]))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, range(<span class="number">0</span>, <span class="number">15</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>restricted_loads(<span class="string">b"cos\nsystem\n(S'echo hello world'\ntR."</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">pickle.UnpicklingError: <span class="keyword">global</span> <span class="string">'os.system'</span> <span class="keyword">is</span> forbidden</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>restricted_loads(<span class="string">b'cbuiltins\neval\n'</span></span><br><span class="line"><span class="meta">... </span>                 <span class="string">b'(S\'getattr(__import__("os"), "system")'</span></span><br><span class="line"><span class="meta">... </span>                 <span class="string">b'("echo hello world")\'\ntR.'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">pickle.UnpicklingError: <span class="keyword">global</span> <span class="string">'builtins.eval'</span> <span class="keyword">is</span> forbidden</span><br></pre></td></tr></table></figure><p>正如我们这个例子所显示的，对于允许解封的对象你必须要保持谨慎。 因此如果要保证安全，你可以考虑其他选择例如 <a href="https://docs.python.org/zh-cn/3/library/xmlrpc.client.html#module-xmlrpc.client" target="_blank" rel="noopener"><code>xmlrpc.client</code></a> 中的编组 API 或是第三方解决方案。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>较新版本的 pickle 协议（第 2 版或更高）具有针对某些常见特性和内置类型的高效二进制编码格式。 此外，<a href="https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块还拥有一个以 C 编写的透明优化器。</p><p>实例</p><p>对于最简单的代码，请使用 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dump" target="_blank" rel="noopener"><code>dump()</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/pickle.html#pickle.load" target="_blank" rel="noopener"><code>load()</code></a> 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="comment"># An arbitrary collection of objects supported by pickle.</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'a'</span>: [<span class="number">1</span>, <span class="number">2.0</span>, <span class="number">3</span>, <span class="number">4</span>+<span class="number">6j</span>],</span><br><span class="line">    <span class="string">'b'</span>: (<span class="string">"character string"</span>, <span class="string">b"byte string"</span>),</span><br><span class="line">    <span class="string">'c'</span>: &#123;<span class="literal">None</span>, <span class="literal">True</span>, <span class="literal">False</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data.pickle'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># Pickle the 'data' dictionary using the highest protocol available.</span></span><br><span class="line">    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)</span><br></pre></td></tr></table></figure><p>以下示例读取之前封存的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data.pickle'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># The protocol version used is detected automatically, so we do not</span></span><br><span class="line">    <span class="comment"># have to specify it.</span></span><br><span class="line">    data = pickle.load(f)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-pickle&quot;&gt;&lt;a href=&quot;#python-标准库-pickle&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 pickle&quot;&gt;&lt;/a&gt;python 标准库 pickle&lt;/h1&gt;&lt;p&gt;快过年了,准备了一些过节用的英语&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;传统中国节日：traditional Chinese festival&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;农历：lunar calendar&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;腊八节：Laba Festival&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;小年：Little New Year&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除夕：Lunar New Year’s Eve&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;春节：the Spring Festival&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正月初一：the lunar New Year’s Day&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;元宵节：the Lantern Festival&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正月：the first month of the lunar year&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;二月二：Dragon Heads-raising Day&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200114_guonian1.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;时间过得好快,又是一年过去了。&lt;/p&gt;
&lt;h2 id=&quot;python-标准库学习之-pickle&quot;&gt;&lt;a href=&quot;#python-标准库学习之-pickle&quot; class=&quot;headerlink&quot; title=&quot;python 标准库学习之 pickle&quot;&gt;&lt;/a&gt;python 标准库学习之 pickle&lt;/h2&gt;&lt;p&gt;常用的文本处理 除了文件,数据库,json,xml 以外,python还提供了一种存储方案,这就是&lt;code&gt;pickle&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模块 &lt;a href=&quot;https://docs.python.org/zh-cn/3/library/pickle.html#module-pickle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; 实现了对一个 Python 对象结构的二进制序列化和反序列化。&lt;em&gt;“pickling”&lt;/em&gt; 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 &lt;em&gt;“unpickling”&lt;/em&gt; 是相反的操作，会将（来自一个 &lt;a href=&quot;https://docs.python.org/zh-cn/3/glossary.html#term-binary-file&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;binary file&lt;/a&gt; 或者 &lt;a href=&quot;https://docs.python.org/zh-cn/3/glossary.html#term-bytes-like-object&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bytes-like object&lt;/a&gt; 的）字节流转化回一个对象层次结构。 pickling（和 unpickling）也被称为“序列化”, “编组” 或者 “平面化”。而为了避免混乱，此处采用术语 “封存 (pickling)” 和 “解封 (unpickling)”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;警告&lt;/em&gt; :  &lt;code&gt;pickle&lt;/code&gt; 模块&lt;strong&gt;并不安全&lt;/strong&gt;。你只应该对你信任的数据进行unpickle操作。构建恶意的 pickle 数据来&lt;strong&gt;在解封时执行任意代码&lt;/strong&gt;是可能的。绝对不要对不信任来源的数据和可能被篡改过的数据进行解封。请考虑使用 &lt;a href=&quot;https://docs.python.org/zh-cn/3/library/hmac.html#module-hmac&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;hmac&lt;/code&gt;&lt;/a&gt; 来对数据进行签名，确保数据没有被篡改。在你处理不信任数据时，更安全的序列化格式如 &lt;a href=&quot;https://docs.python.org/zh-cn/3/library/json.html#module-json&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;json&lt;/code&gt;&lt;/a&gt; 可能更为适合。参见 &lt;a href=&quot;https://docs.python.org/zh-cn/3/library/pickle.html#comparison-with-json&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;与 json 模块的比较&lt;/a&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;源代码：-Lib-pickle-py&quot;&gt;&lt;a href=&quot;#源代码：-Lib-pickle-py&quot; class=&quot;headerlink&quot; title=&quot;源代码： Lib/pickle.py&quot;&gt;&lt;/a&gt;&lt;strong&gt;源代码：&lt;/strong&gt; &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/pickle.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lib/pickle.py&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;本节内容比较多,先看下类层次结构,有一个大体的概念(节选自源码)：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Classes:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Pickler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Unpickler&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Functions:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dump(object, file)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dumps(object) -&amp;gt; string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    load(file) -&amp;gt; object&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    loads(string) -&amp;gt; object&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Misc variables:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __version__&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    format_version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compatible_formats&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__all__ = [&lt;span class=&quot;string&quot;&gt;&quot;PickleError&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;PicklingError&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;UnpicklingError&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Pickler&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;Unpickler&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;dump&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;dumps&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;load&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;loads&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="pickle" scheme="https://pinghailinfeng.gitee.io/tags/pickle/"/>
    
  </entry>
  
  <entry>
    <title>python standard library array type</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/13/python-standard-library-array-type/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/13/python-standard-library-array-type/</id>
    <published>2020-01-13T03:04:53.000Z</published>
    <updated>2020-01-13T04:11:02.663Z</updated>
    
    <content type="html"><![CDATA[<p>每日一词: underdog</p><blockquote><p>英 [ˈʌndədɒg]   美 [ˈʌndərdɔg]</p><p>n.失败者； 退居下风的人； 受压迫者； 打败了的选手</p><p>复数： <a href="http://www.iciba.com/underdogs" target="_blank" rel="noopener">underdogs</a></p></blockquote><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200113underdogs.webp?raw=true" alt></p><blockquote><p> 这个词来自1887年出现，原指在斗狗比赛中战败的狗。后来词义引申至人，指的是各类竞赛和对碰中不被看好的一方，或是指处在逆境中的人和团体。</p><p>被看好的一方，即Topdog，从来不缺喝彩和支持。而Underdog的路则注定孤独许多。不被人看好，较少人支持。</p><p>所幸的是，正如倪匡先生感言：太多的时候，孤独最好。  </p><p>若能与孤独为师,又何须担心underdog呢？</p></blockquote><h2 id="python-标准库学习-array"><a href="#python-标准库学习-array" class="headerlink" title="python 标准库学习 array"></a>python 标准库学习 array</h2><p>此模块定义了一种对象类型，可以紧凑地表示基本类型值的数组：字符、整数、浮点数等。 数组属于序列类型，其行为与列表非常相似，不同之处在于其中存储的对象类型是受限的。 类型在对象创建时使用单个字符的 <em>类型码</em> 来指定。 已定义的类型码如下：</p><table><thead><tr><th>类型码</th><th>C 类型</th><th>Python 类型</th><th>以字节表示的最小尺寸</th><th>注释</th></tr></thead><tbody><tr><td><code>&#39;b&#39;</code></td><td>signed char</td><td>int</td><td>1</td><td></td></tr><tr><td><code>&#39;B&#39;</code></td><td>unsigned char</td><td>int</td><td>1</td><td></td></tr><tr><td><code>&#39;u&#39;</code></td><td>Py_UNICODE</td><td>Unicode 字符</td><td>2</td><td>(1)</td></tr><tr><td><code>&#39;h&#39;</code></td><td>signed short</td><td>int</td><td>2</td><td></td></tr><tr><td><code>&#39;H&#39;</code></td><td>unsigned short</td><td>int</td><td>2</td><td></td></tr><tr><td><code>&#39;i&#39;</code></td><td>signed int</td><td>int</td><td>2</td><td></td></tr><tr><td><code>&#39;I&#39;</code></td><td>无符号整型</td><td>int</td><td>2</td><td></td></tr><tr><td><code>&#39;l&#39;</code></td><td>signed long</td><td>int</td><td>4</td><td></td></tr><tr><td><code>&#39;L&#39;</code></td><td>无符号长整型</td><td>int</td><td>4</td><td></td></tr><tr><td><code>&#39;q&#39;</code></td><td>signed long long</td><td>int</td><td>8</td><td></td></tr><tr><td><code>&#39;Q&#39;</code></td><td>无符号 long long</td><td>int</td><td>8</td><td></td></tr><tr><td><code>&#39;f&#39;</code></td><td>float</td><td>float</td><td>4</td><td></td></tr><tr><td><code>&#39;d&#39;</code></td><td>double</td><td>float</td><td>8</td></tr></tbody></table><p>==注释== </p><blockquote><p>‘u’类型码在<code>python3</code>已经被废除,默认python的字符串就是<code>unicode</code>字符</p></blockquote><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li><p><em>class</em> <code>array.array</code>(<em>typecode</em>[, <em>initializer</em>])</p><p>一个包含由 <em>typecode</em> 限制类型的条目的新数组，并由可选的 <em>initializer</em> 值进行初始化，该值必须为一个列表、<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 或包含正确类型元素的可迭代对象。如果给定一个列表或字符串，该 initializer 会被传给新数组的 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromlist" target="_blank" rel="noopener"><code>fromlist()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.frombytes" target="_blank" rel="noopener"><code>frombytes()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromunicode" target="_blank" rel="noopener"><code>fromunicode()</code></a> 方法（见下文）以将初始条目添加到数组中。 否则会将可迭代对象作为 initializer 传给 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.extend" target="_blank" rel="noopener"><code>extend()</code></a> 方法。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审核事件</a> <code>array.__new__</code> 附带参数 <code>typecode</code>, <code>initializer</code>。</p></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p><code>array.typecodes</code></p><p>包含所有可用类型码的字符串。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import array</span><br><span class="line">&gt;&gt;&gt; array.typecodes</span><br><span class="line">&apos;bBuhHiIlLqQfd&apos;</span><br></pre></td></tr></table></figure><p>数组对象支持普通的序列操作如索引、切片、拼接和重复等。 当使用切片赋值时，所赋的值必须为具有相同类型码的数组对象；所有其他情况都将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 数组对象也实现了缓冲区接口，可以用于所有支持 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 的场合。</p><a id="more"></a><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>以下数据项和方法也受到支持：</p><ul><li><p><code>array.typecode</code></p><p>用于创建数组的类型码字符。</p></li><li><p><code>array.itemsize</code></p><p>在内部表示中一个数组项的字节长度。</p></li><li><p><code>array.append</code>(<em>x</em>)</p><p>添加一个值为 <em>x</em> 的新项到数组末尾。</p></li><li><p><code>array.buffer_info</code>()</p><p>返回一个元组 <code>(address, length)</code> 以给出用于存放数组内容的缓冲区元素的当前内存地址和长度。 以字节表示的内存缓冲区大小可通过 <code>array.buffer_info()[1] * array.itemsize</code> 来计算。 这在使用需要内存地址的低层级（因此不够安全） I/O 接口时会很有用，例如某些 <code>ioctl()</code> 操作。 只要数组存在并且没有应用改变长度的操作，返回数值就是有效的。注解 当在 C 或 C++ 编写的代码中使用数组对象时（这是有效使用此类信息的唯一方式），使用数组对象所支持的缓冲区接口更为适宜。 此方法仅保留用作向下兼容，应避免在新代码中使用。 缓冲区接口的文档参见 <a href="https://docs.python.org/zh-cn/3.8/c-api/buffer.html#bufferobjects" target="_blank" rel="noopener">缓冲协议</a>。</p></li><li><p><code>array.byteswap</code>()</p><p>“字节对调”所有数组项。 此方法只支持大小为 1, 2, 4 或 8 字节的值；对于其他值类型将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 它适用于从不同字节序机器所生成的文件中读取数据的情况。</p></li><li><p><code>array.count</code>(<em>x</em>)</p><p>返回 <em>x</em> 在数组中的出现次数。</p></li><li><p><code>array.extend</code>(<em>iterable</em>)</p><p>将来自 <em>iterable</em> 的项添加到数组末尾。 如果 <em>iterable</em> 是另一个数组，它必须具有 <em>完全</em> 相同的类型码；否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 如果 <em>iterable</em> 不是一个数组，则它必须为可迭代对象并且其元素必须为可添加到数组的适当类型。</p></li><li><p><code>array.frombytes</code>(<em>s</em>)</p><p>添加来自字符串的项，将字符串解读为机器值的数组（相当于使用 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromfile" target="_blank" rel="noopener"><code>fromfile()</code></a> 方法从文件中读取数据）。<em>3.2 新版功能:</em> <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromstring" target="_blank" rel="noopener"><code>fromstring()</code></a> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.frombytes" target="_blank" rel="noopener"><code>frombytes()</code></a> 以使其含义更清晰。</p></li><li><p><code>array.fromfile</code>(<em>f</em>, <em>n</em>)</p><p>从 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> <em>f</em> 中读取 <em>n</em> 项（解读为机器值）并将它们添加到数组末尾。 如果可读取数据少于 <em>n</em> 项则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EOFError" target="_blank" rel="noopener"><code>EOFError</code></a>，但有效的项仍然会被插入数组。 <em>f</em> 必须为一个真实的内置文件对象；不支持带有 <code>read()</code> 方法的其它对象。</p></li><li><p><code>array.fromlist</code>(<em>list</em>)</p><p>添加来自 list 的项。 这等价于 <code>for x in list: a.append(x)</code>，区别在于如果发生类型错误，数组将不会被改变。</p></li><li><p><code>array.fromstring</code>()</p><p><a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.frombytes" target="_blank" rel="noopener"><code>frombytes()</code></a> 的已弃用别名。<em>Deprecated since version 3.2, will be removed in version 3.9.</em></p></li><li><p><code>array.fromunicode</code>(<em>s</em>)</p><p>使用来自给定 Unicode 字符串的数组扩展数组。 数组必须是类型为 <code>&#39;u&#39;</code> 的数组；否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。 请使用 <code>array.frombytes(unicodestring.encode(enc))</code> 来将 Unicode 数据添加到其他类型的数组。</p></li><li><p><code>array.index</code>(<em>x</em>)</p><p>返回最小的 <em>i</em> 使得 <em>i</em> 为 <em>x</em> 在数组中首次出现的序号。</p></li><li><p><code>array.insert</code>(<em>i</em>, <em>x</em>)</p><p>将值 <em>x</em> 作为新项插入数组的 <em>i</em> 位置之前。 负值将被视为相对于数组末尾的位置。</p></li><li><p><code>array.pop</code>([<em>i</em>])</p><p>从数组中移除序号为 <em>i</em> 的项并将其返回。 可选参数值默认为 <code>-1</code>，因此默认将移除并返回末尾项。</p></li><li><p><code>array.remove</code>(<em>x</em>)</p><p>从数组中移除首次出现的 <em>x</em>。</p></li><li><p><code>array.reverse</code>()</p><p>反转数组中各项的顺序。</p></li><li><p><code>array.tobytes</code>()</p><p>将数组转换为一个机器值数组并返回其字节表示（即相当与通过 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.tofile" target="_blank" rel="noopener"><code>tofile()</code></a> 方法写入到文件的字节序列。）<em>3.2 新版功能:</em> <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.tostring" target="_blank" rel="noopener"><code>tostring()</code></a> 被重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.tobytes" target="_blank" rel="noopener"><code>tobytes()</code></a> 以使其含义更清晰。</p></li><li><p><code>array.tofile</code>(<em>f</em>)</p><p>将所有项（作为机器值）写入到 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> <em>f</em>。</p></li><li><p><code>array.tolist</code>()</p><p>将数组转换为包含相同项的普通列表。</p></li><li><p><code>array.tostring</code>()</p><p><a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array.tobytes" target="_blank" rel="noopener"><code>tobytes()</code></a> 的已弃用别名。<em>Deprecated since version 3.2, will be removed in version 3.9.</em></p></li><li><p><code>array.tounicode</code>()</p><p>将数组转换为一个 Unicode 字符串。 数组必须是类型为 <code>&#39;u&#39;</code> 的数组；否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。 请使用 <code>array.tobytes().decode(enc)</code> 来从其他类型的数组生成 Unicode 字符串。</p></li></ul><p>当一个数组对象被打印或转换为字符串时，它会表示为 <code>array(typecode, initializer)</code>。 如果数组为空则 <em>initializer</em> 会被省略，否则如果 <em>typecode</em> 为 <code>&#39;u&#39;</code> 则它是一个字符串，否则它是一个数字列表。 使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 保证能将字符串转换回具有相同类型和值的数组，只要 <a href="https://docs.python.org/zh-cn/3.8/library/array.html#array.array" target="_blank" rel="noopener"><code>array</code></a> 类已通过 <code>from array import array</code> 被引入。 例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line">array(<span class="string">'l'</span>)</span><br><span class="line">array(<span class="string">'u'</span>, <span class="string">'hello \u2641'</span>)</span><br><span class="line">array(<span class="string">'l'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">array(<span class="string">'d'</span>, [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.14</span>])</span><br></pre></td></tr></table></figure><p>更高效数组处理的可以详见 <a href="https://docs.scipy.org/doc/" target="_blank" rel="noopener">numpy</a> 库</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原来python标准库里就有专门操作array对象的方法,这里我理解array和list的区别在于,list里包含的元素可以是任意数据类型,处理数据的时候不是很方便,而array里的数据类型是一致的,这样处理数据效率更高。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每日一词: underdog&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;英 [ˈʌndədɒg]   美 [ˈʌndərdɔg]&lt;/p&gt;
&lt;p&gt;n.失败者； 退居下风的人； 受压迫者； 打败了的选手&lt;/p&gt;
&lt;p&gt;复数： &lt;a href=&quot;http://www.iciba.com/underdogs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;underdogs&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200113underdogs.webp?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 这个词来自1887年出现，原指在斗狗比赛中战败的狗。后来词义引申至人，指的是各类竞赛和对碰中不被看好的一方，或是指处在逆境中的人和团体。&lt;/p&gt;
&lt;p&gt;被看好的一方，即Topdog，从来不缺喝彩和支持。而Underdog的路则注定孤独许多。不被人看好，较少人支持。&lt;/p&gt;
&lt;p&gt;所幸的是，正如倪匡先生感言：太多的时候，孤独最好。  &lt;/p&gt;
&lt;p&gt;若能与孤独为师,又何须担心underdog呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;python-标准库学习-array&quot;&gt;&lt;a href=&quot;#python-标准库学习-array&quot; class=&quot;headerlink&quot; title=&quot;python 标准库学习 array&quot;&gt;&lt;/a&gt;python 标准库学习 array&lt;/h2&gt;&lt;p&gt;此模块定义了一种对象类型，可以紧凑地表示基本类型值的数组：字符、整数、浮点数等。 数组属于序列类型，其行为与列表非常相似，不同之处在于其中存储的对象类型是受限的。 类型在对象创建时使用单个字符的 &lt;em&gt;类型码&lt;/em&gt; 来指定。 已定义的类型码如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型码&lt;/th&gt;
&lt;th&gt;C 类型&lt;/th&gt;
&lt;th&gt;Python 类型&lt;/th&gt;
&lt;th&gt;以字节表示的最小尺寸&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;b&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;signed char&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;B&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;unsigned char&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;u&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Py_UNICODE&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;h&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;signed short&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;H&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;unsigned short&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;i&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;signed int&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;I&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号整型&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;l&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;signed long&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;L&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号长整型&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;q&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;signed long long&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;Q&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无符号 long long&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;f&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;#39;d&amp;#39;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;==注释== &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;‘u’类型码在&lt;code&gt;python3&lt;/code&gt;已经被废除,默认python的字符串就是&lt;code&gt;unicode&lt;/code&gt;字符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;class&lt;/em&gt; &lt;code&gt;array.array&lt;/code&gt;(&lt;em&gt;typecode&lt;/em&gt;[, &lt;em&gt;initializer&lt;/em&gt;])&lt;/p&gt;
&lt;p&gt;一个包含由 &lt;em&gt;typecode&lt;/em&gt; 限制类型的条目的新数组，并由可选的 &lt;em&gt;initializer&lt;/em&gt; 值进行初始化，该值必须为一个列表、&lt;a href=&quot;https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bytes-like object&lt;/a&gt; 或包含正确类型元素的可迭代对象。如果给定一个列表或字符串，该 initializer 会被传给新数组的 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromlist&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;fromlist()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/array.html#array.array.frombytes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;frombytes()&lt;/code&gt;&lt;/a&gt; 或 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/array.html#array.array.fromunicode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;fromunicode()&lt;/code&gt;&lt;/a&gt; 方法（见下文）以将初始条目添加到数组中。 否则会将可迭代对象作为 initializer 传给 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/array.html#array.array.extend&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;extend()&lt;/code&gt;&lt;/a&gt; 方法。引发一个 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/sys.html#auditing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;审核事件&lt;/a&gt; &lt;code&gt;array.__new__&lt;/code&gt; 附带参数 &lt;code&gt;typecode&lt;/code&gt;, &lt;code&gt;initializer&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;array.typecodes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;包含所有可用类型码的字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; import array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; array.typecodes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;apos;bBuhHiIlLqQfd&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;数组对象支持普通的序列操作如索引、切片、拼接和重复等。 当使用切片赋值时，所赋的值必须为具有相同类型码的数组对象；所有其他情况都将引发 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;。 数组对象也实现了缓冲区接口，可以用于所有支持 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;字节类对象&lt;/a&gt; 的场合。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="array" scheme="https://pinghailinfeng.gitee.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>python standard library collections.abc</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/12/python-standard-library-collections-abc/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/12/python-standard-library-collections-abc/</id>
    <published>2020-01-12T00:49:16.000Z</published>
    <updated>2020-01-13T02:57:53.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-之-collections-abc"><a href="#python-标准库-之-collections-abc" class="headerlink" title="python 标准库 之 collections.abc"></a>python 标准库 之 collections.abc</h1><p>每日一词: wrong</p><blockquote><p><em>adj.</em> 不道德的, 不正当的, 不义的</p><p>不确实的, 不正确的, 错误的</p><p>不合要求的, 不适合的, 并非合意的</p><p>有故障, 有毛病</p><p><em>adv.</em> 方式或方向错误地; 错误地; 结果错误地</p><p><em>n.</em> 罪过, 过失, 罪恶</p><p>不义的行为, 不公正的事</p><p>时 态: wronged, wronging, wrongs<br>名 词: wronger<br>副 词: wrongly<br>名 词: wrongness</p><p> 词语：</p><p><em>confound right and wrong</em></p><p>混淆是非，黑白不分</p><p><em>get one wrong</em></p><p>误会某人；误会</p><p> <em>right or wrong</em><br><em>adv.</em> 不管如何 </p><p><em>something wrong with</em></p><p>…出了毛病；…有问题；…不对头</p></blockquote><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200112update1.jpg?raw=true" alt></p><h2 id="python-标准库学习之-抽象基类-collection-abc"><a href="#python-标准库学习之-抽象基类-collection-abc" class="headerlink" title="python 标准库学习之 抽象基类 collection.abc"></a>python 标准库学习之 抽象基类 collection.abc</h2><p>众所周知,python3中所有类默认继承自object类,意味着父类中所有的方法,子类都继承了。</p><p>我个人理解,抽象基类是无法被实例化的,只能子类实现</p><p> <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html" target="_blank" rel="noopener">参考文档</a></p><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/_collections_abc.py" target="_blank" rel="noopener">Lib/_collections_abc.py</a> </p><p> 该模块定义了一些 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class" target="_blank" rel="noopener">抽象基类</a>，它们可用于判断一个具体类是否具有某一特定的接口；例如，这个类是否可哈希，或其是否为映射类。 </p><p>模块里方法一览,摘自源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">"Awaitable"</span>, <span class="string">"Coroutine"</span>,</span><br><span class="line">           <span class="string">"AsyncIterable"</span>, <span class="string">"AsyncIterator"</span>, <span class="string">"AsyncGenerator"</span>,</span><br><span class="line">           <span class="string">"Hashable"</span>, <span class="string">"Iterable"</span>, <span class="string">"Iterator"</span>, <span class="string">"Generator"</span>, <span class="string">"Reversible"</span>,</span><br><span class="line">           <span class="string">"Sized"</span>, <span class="string">"Container"</span>, <span class="string">"Callable"</span>, <span class="string">"Collection"</span>,</span><br><span class="line">           <span class="string">"Set"</span>, <span class="string">"MutableSet"</span>,</span><br><span class="line">           <span class="string">"Mapping"</span>, <span class="string">"MutableMapping"</span>,</span><br><span class="line">           <span class="string">"MappingView"</span>, <span class="string">"KeysView"</span>, <span class="string">"ItemsView"</span>, <span class="string">"ValuesView"</span>,</span><br><span class="line">           <span class="string">"Sequence"</span>, <span class="string">"MutableSequence"</span>,</span><br><span class="line">           <span class="string">"ByteString"</span>,</span><br><span class="line">           ]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="容器抽象基类"><a href="#容器抽象基类" class="headerlink" title="容器抽象基类"></a>容器抽象基类</h2><p> 这个容器模块提供了以下 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class" target="_blank" rel="noopener">ABCs</a>: </p><table><thead><tr><th style="text-align:left">抽象基类</th><th style="text-align:left">继承自</th><th style="text-align:left">抽象方法</th><th style="text-align:left">Mixin 方法</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Container" target="_blank" rel="noopener"><code>Container</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__contains__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Hashable" target="_blank" rel="noopener"><code>Hashable</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__hash__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__iter__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterator" target="_blank" rel="noopener"><code>Iterator</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a></td><td style="text-align:left"><code>__next__</code></td><td style="text-align:left"><code>__iter__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Reversible" target="_blank" rel="noopener"><code>Reversible</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a></td><td style="text-align:left"><code>__reversed__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Generator" target="_blank" rel="noopener"><code>Generator</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterator" target="_blank" rel="noopener"><code>Iterator</code></a></td><td style="text-align:left"><code>send</code>, <code>throw</code></td><td style="text-align:left"><code>close</code>, <code>__iter__</code>, <code>__next__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sized" target="_blank" rel="noopener"><code>Sized</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__len__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Callable" target="_blank" rel="noopener"><code>Callable</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__call__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sized" target="_blank" rel="noopener"><code>Sized</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Container" target="_blank" rel="noopener"><code>Container</code></a></td><td style="text-align:left"><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Reversible" target="_blank" rel="noopener"><code>Reversible</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td><td style="text-align:left"><code>__getitem__</code>, <code>__len__</code></td><td style="text-align:left"><code>__contains__</code>, <code>__iter__</code>, <code>__reversed__</code>, <code>index</code>, and <code>count</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableSequence" target="_blank" rel="noopener"><code>MutableSequence</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a></td><td style="text-align:left"><code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__len__</code>, <code>insert</code></td><td style="text-align:left">继承自 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a> 的方法，以及 <code>append</code>, <code>reverse</code>, <code>extend</code>, <code>pop</code>, <code>remove</code>，和 <code>__iadd__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.ByteString" target="_blank" rel="noopener"><code>ByteString</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a></td><td style="text-align:left"><code>__getitem__</code>, <code>__len__</code></td><td style="text-align:left">继承自 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sequence" target="_blank" rel="noopener"><code>Sequence</code></a> 的方法</td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td><td style="text-align:left"><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code></td><td style="text-align:left"><code>__le__</code>, <code>__lt__</code>, <code>__eq__</code>, <code>__ne__</code>, <code>__gt__</code>, <code>__ge__</code>, <code>__and__</code>, <code>__or__</code>, <code>__sub__</code>, <code>__xor__</code>, and <code>isdisjoint</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableSet" target="_blank" rel="noopener"><code>MutableSet</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a></td><td style="text-align:left"><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code>, <code>add</code>, <code>discard</code></td><td style="text-align:left">继承自 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> 的方法以及 <code>clear</code>, <code>pop</code>, <code>remove</code>, <code>__ior__</code>, <code>__iand__</code>, <code>__ixor__</code>，和 <code>__isub__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Mapping" target="_blank" rel="noopener"><code>Mapping</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td><td style="text-align:left"><code>__getitem__</code>, <code>__iter__</code>, <code>__len__</code></td><td style="text-align:left"><code>__contains__</code>, <code>keys</code>, <code>items</code>, <code>values</code>, <code>get</code>, <code>__eq__</code>, and <code>__ne__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableMapping" target="_blank" rel="noopener"><code>MutableMapping</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Mapping" target="_blank" rel="noopener"><code>Mapping</code></a></td><td style="text-align:left"><code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__iter__</code>, <code>__len__</code></td><td style="text-align:left">继承自 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Mapping" target="_blank" rel="noopener"><code>Mapping</code></a> 的方法以及 <code>pop</code>, <code>popitem</code>, <code>clear</code>, <code>update</code>，和 <code>setdefault</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MappingView" target="_blank" rel="noopener"><code>MappingView</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Sized" target="_blank" rel="noopener"><code>Sized</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__len__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.ItemsView" target="_blank" rel="noopener"><code>ItemsView</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MappingView" target="_blank" rel="noopener"><code>MappingView</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__contains__</code>, <code>__iter__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.KeysView" target="_blank" rel="noopener"><code>KeysView</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MappingView" target="_blank" rel="noopener"><code>MappingView</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__contains__</code>, <code>__iter__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.ValuesView" target="_blank" rel="noopener"><code>ValuesView</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MappingView" target="_blank" rel="noopener"><code>MappingView</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Collection" target="_blank" rel="noopener"><code>Collection</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__contains__</code>, <code>__iter__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Awaitable" target="_blank" rel="noopener"><code>Awaitable</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__await__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Coroutine" target="_blank" rel="noopener"><code>Coroutine</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Awaitable" target="_blank" rel="noopener"><code>Awaitable</code></a></td><td style="text-align:left"><code>send</code>, <code>throw</code></td><td style="text-align:left"><code>close</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncIterable" target="_blank" rel="noopener"><code>AsyncIterable</code></a></td><td style="text-align:left"></td><td style="text-align:left"><code>__aiter__</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncIterator" target="_blank" rel="noopener"><code>AsyncIterator</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncIterable" target="_blank" rel="noopener"><code>AsyncIterable</code></a></td><td style="text-align:left"><code>__anext__</code></td><td style="text-align:left"><code>__aiter__</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncGenerator" target="_blank" rel="noopener"><code>AsyncGenerator</code></a></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.AsyncIterator" target="_blank" rel="noopener"><code>AsyncIterator</code></a></td><td style="text-align:left"><code>asend</code>, <code>athrow</code></td><td style="text-align:left"><code>aclose</code>, <code>__aiter__</code>, <code>__anext__</code></td></tr></tbody></table><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li><p><em>class</em> <code>collections.abc.Container</code></p></li><li><p><em>class</em> <code>collections.abc.Hashable</code></p></li><li><p><em>class</em> <code>collections.abc.Sized</code></p></li><li><p><em>class</em> <code>collections.abc.Callable</code></p><p>分别提供了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__contains__" target="_blank" rel="noopener"><code>__contains__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__len__" target="_blank" rel="noopener"><code>__len__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__call__" target="_blank" rel="noopener"><code>__call__()</code></a> 方法的抽象基类。</p></li><li><p><em>class</em> <code>collections.abc.Iterable</code></p><p>提供了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 方法的抽象基类。使用 <code>isinstance(obj, Iterable)</code> 可以检测一个类是否已经注册到了 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Iterable" target="_blank" rel="noopener"><code>Iterable</code></a> 或者实现了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 函数，但是无法检测这个类是否能够使用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法进行迭代。检测一个对象是否是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterable" target="_blank" rel="noopener">iterable</a> 的唯一可信赖的方法是调用 <code>iter(obj)</code>。</p></li><li><p><em>class</em> <code>collections.abc.Collection</code></p><p>集合了 Sized 和 Iterable 类的抽象基类。</p></li><li><p><em>class</em> <code>collections.abc.Iterator</code></p><p>提供了 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法的抽象基类。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a> 的定义。</p></li><li><p><em>class</em> <code>collections.abc.Reversible</code></p><p>为可迭代类提供了 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__reversed__" target="_blank" rel="noopener"><code>__reversed__()</code></a> 方法的抽象基类。<em>3.6 新版功能.</em></p></li><li><p><em>class</em> <code>collections.abc.Generator</code></p><p>生成器类，实现了 <a href="https://www.python.org/dev/peps/pep-0342" target="_blank" rel="noopener"><strong>PEP 342</strong></a> 中定义的协议，继承并扩展了迭代器，提供了 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.send" target="_blank" rel="noopener"><code>send()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.throw" target="_blank" rel="noopener"><code>throw()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.close" target="_blank" rel="noopener"><code>close()</code></a> 方法。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 的定义。<em>3.5 新版功能.</em></p></li><li><p><em>class</em> <code>collections.abc.Sequence</code></p></li><li><p><em>class</em> <code>collections.abc.MutableSequence</code></p></li><li><p><em>class</em> <code>collections.abc.ByteString</code></p><p>只读且可变的序列 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-sequence" target="_blank" rel="noopener">sequences</a> 的抽象基类。实现笔记：一些混入（Maxin）方法比如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__reversed__" target="_blank" rel="noopener"><code>__reversed__()</code></a> 和 <code>index()</code> 会重复调用底层的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 方法。因此，如果实现的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__getitem__" target="_blank" rel="noopener"><code>__getitem__()</code></a> 是常数级访问速度，那么相应的混入方法会有一个线性的表现；然而，如果底层方法是线性实现（例如链表），那么混入方法将会是平方级的表现，这也许就需要被重构了。<em>在 3.5 版更改:</em> index() 方法支持 <em>stop</em> 和 <em>start</em> 参数。</p></li><li><p><em>class</em> <code>collections.abc.Set</code></p></li><li><p><em>class</em> <code>collections.abc.MutableSet</code></p><p>只读且可变的集合的抽象基类。</p></li><li><p><em>class</em> <code>collections.abc.Mapping</code></p></li><li><p><em>class</em> <code>collections.abc.MutableMapping</code></p><p>只读且可变的映射 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-mapping" target="_blank" rel="noopener">mappings</a> 的抽象基类。</p></li><li><p><em>class</em> <code>collections.abc.MappingView</code></p></li><li><p><em>class</em> <code>collections.abc.ItemsView</code></p></li><li><p><em>class</em> <code>collections.abc.KeysView</code></p></li><li><p><em>class</em> <code>collections.abc.ValuesView</code></p><p>映射及其键和值的视图 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-dictionary-view" target="_blank" rel="noopener">views</a> 的抽象基类。</p></li><li><p><em>class</em> <code>collections.abc.Awaitable</code></p><p>为可等待对象 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a> 提供的类，可以被用于 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#await" target="_blank" rel="noopener"><code>await</code></a> 表达式中。习惯上必须实现 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 方法。协程对象 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">Coroutine</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Coroutine" target="_blank" rel="noopener"><code>Coroutine</code></a> 抽象基类的实例都是这个抽象基类的实例。</p></li><li><p><em>class</em> <code>collections.abc.Coroutine</code></p><p>用于协程兼容类的抽象基类。实现了如下定义在 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine-objects" target="_blank" rel="noopener">协程对象</a>: 里的方法： <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine.send" target="_blank" rel="noopener"><code>send()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine.throw" target="_blank" rel="noopener"><code>throw()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine.close" target="_blank" rel="noopener"><code>close()</code></a>。通常的实现里还需要实现 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 方法。所有的 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Coroutine" target="_blank" rel="noopener"><code>Coroutine</code></a> 实例都必须是 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Awaitable" target="_blank" rel="noopener"><code>Awaitable</code></a> 实例。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 的定义。注解 在 CPython 里，基于生成器的协程（使用 <a href="https://docs.python.org/zh-cn/3.8/library/types.html#types.coroutine" target="_blank" rel="noopener"><code>types.coroutine()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.coroutine" target="_blank" rel="noopener"><code>asyncio.coroutine()</code></a> 包装的生成器）都是 <em>可等待对象</em>，即使他们不含有 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 方法。使用 <code>isinstance(gencoro, Coroutine)</code> 来检测他们会返回 <code>False</code>。要使用 <a href="https://docs.python.org/zh-cn/3.8/library/inspect.html#inspect.isawaitable" target="_blank" rel="noopener"><code>inspect.isawaitable()</code></a> 来检测他们。</p></li><li><p><em>class</em> <code>collections.abc.AsyncIterable</code></p><p>提供了 <code>__aiter__</code> 方法的抽象基类。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterable" target="_blank" rel="noopener">asynchronous iterable</a> 的定义。<em>3.5 新版功能.</em></p></li><li><p><em>class</em> <code>collections.abc.AsyncIterator</code></p><p>提供了 <code>__aiter__</code> 和 <code>__anext__</code> 方法的抽象基类。参见 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterator" target="_blank" rel="noopener">asynchronous iterator</a> 的定义。<em>3.5 新版功能.</em></p></li><li><p><em>class</em> <code>collections.abc.AsyncGenerator</code></p><p>为异步生成器类提供的抽象基类，这些类实现了定义在 <a href="https://www.python.org/dev/peps/pep-0525" target="_blank" rel="noopener"><strong>PEP 525</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 里的协议。</p><p>这些抽象基类让我们可以确定类和示例拥有某些特定的函数，例如： </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> isinstance(myvar, collections.abc.Sized):</span><br><span class="line">    size = len(myvar)</span><br></pre></td></tr></table></figure><p> 有些抽象基类也可以用作混入类（mixin），这可以更容易地开发支持容器 API 的类。例如，要写一个支持完整 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> API 的类，只需要提供下面这三个方法： <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__contains__" target="_blank" rel="noopener"><code>__contains__()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__iter__" target="_blank" rel="noopener"><code>__iter__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__len__" target="_blank" rel="noopener"><code>__len__()</code></a>。抽象基类会补充上其余的方法，比如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__and__" target="_blank" rel="noopener"><code>__and__()</code></a> 和 <code>isdisjoint()</code>: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListBasedSet</span><span class="params">(collections.abc.Set)</span>:</span></span><br><span class="line">    <span class="string">''' Alternate set implementation favoring space over speed</span></span><br><span class="line"><span class="string">        and not requiring the set elements to be hashable. '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self.elements = lst = []</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> iterable:</span><br><span class="line">            <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> lst:</span><br><span class="line">                lst.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.elements)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> value <span class="keyword">in</span> self.elements</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.elements)</span><br><span class="line"></span><br><span class="line">s1 = ListBasedSet(<span class="string">'abcdef'</span>)</span><br><span class="line">s2 = ListBasedSet(<span class="string">'defghi'</span>)</span><br><span class="line">overlap = s1 &amp; s2            <span class="comment"># The __and__() method is supported automatically</span></span><br></pre></td></tr></table></figure><p>当把 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableSet" target="_blank" rel="noopener"><code>MutableSet</code></a> 用作混入类时需注意：</p><ol><li>由于某些集合操作会创建新集合，默认的混入方法需要一种从可迭代对象里创建新实例的方法。假如其类构造函数签名形如 <code>ClassName(iterable)</code> ，则其会调用一个内部的类方法 <code>_from_iterable()</code>，其中调用了 <code>cls(iterable)</code> 来生成一个新集合。如果这个 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> 混入类在类中被使用，但其构造函数的签名却是不同的形式，那么你就需要重载 <code>_from_iterable()</code> 方法，将其编写成一个类方法，并且它能够从可迭代对象参数中构造一个新实例。</li><li>重载比较符时时（想必是为了速度，因为其语义都是固定的），只需要重定义 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__le__" target="_blank" rel="noopener"><code>__le__()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__ge__" target="_blank" rel="noopener"><code>__ge__()</code></a> 函数，然后其他的操作会自动跟进。</li><li>混入集合类 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> 提供了一个 <code>_hash()</code> 方法为集合计算哈希值，然而， <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__hash__" target="_blank" rel="noopener"><code>__hash__()</code></a> 函数却没有被定义，因为并不是所有集合都是可哈希并且不可变的。为了使用混入类为集合添加哈希能力，可以同时继承 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Set" target="_blank" rel="noopener"><code>Set()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Hashable" target="_blank" rel="noopener"><code>Hashable()</code></a> 类，然后定义 <code>__hash__ = Set._hash</code>。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我看了官方文档的描述,一头雾水。下面就我个人理解谈谈这个模块。</p><p>abc模块应用的场景</p><h3 id="1-判定某个对象的类型"><a href="#1-判定某个对象的类型" class="headerlink" title="1. 判定某个对象的类型"></a>1. 判定某个对象的类型</h3><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200112_collection_abc1.png?raw=true" alt></p><h3 id="2-强制子类实现某些父类方法"><a href="#2-强制子类实现某些父类方法" class="headerlink" title="2. 强制子类实现某些父类方法"></a>2. 强制子类实现某些父类方法</h3><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200112_collection_abc1.png?raw=true" alt></p><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200112_collection_abc2.png?raw=true" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-之-collections-abc&quot;&gt;&lt;a href=&quot;#python-标准库-之-collections-abc&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 之 collections.abc&quot;&gt;&lt;/a&gt;python 标准库 之 collections.abc&lt;/h1&gt;&lt;p&gt;每日一词: wrong&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;adj.&lt;/em&gt; 不道德的, 不正当的, 不义的&lt;/p&gt;
&lt;p&gt;不确实的, 不正确的, 错误的&lt;/p&gt;
&lt;p&gt;不合要求的, 不适合的, 并非合意的&lt;/p&gt;
&lt;p&gt;有故障, 有毛病&lt;/p&gt;
&lt;p&gt;&lt;em&gt;adv.&lt;/em&gt; 方式或方向错误地; 错误地; 结果错误地&lt;/p&gt;
&lt;p&gt;&lt;em&gt;n.&lt;/em&gt; 罪过, 过失, 罪恶&lt;/p&gt;
&lt;p&gt;不义的行为, 不公正的事&lt;/p&gt;
&lt;p&gt;时 态: wronged, wronging, wrongs&lt;br&gt;名 词: wronger&lt;br&gt;副 词: wrongly&lt;br&gt;名 词: wrongness&lt;/p&gt;
&lt;p&gt; 词语：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;confound right and wrong&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;混淆是非，黑白不分&lt;/p&gt;
&lt;p&gt;&lt;em&gt;get one wrong&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;误会某人；误会&lt;/p&gt;
&lt;p&gt; &lt;em&gt;right or wrong&lt;/em&gt;&lt;br&gt;&lt;em&gt;adv.&lt;/em&gt; 不管如何 &lt;/p&gt;
&lt;p&gt;&lt;em&gt;something wrong with&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;…出了毛病；…有问题；…不对头&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200112update1.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;python-标准库学习之-抽象基类-collection-abc&quot;&gt;&lt;a href=&quot;#python-标准库学习之-抽象基类-collection-abc&quot; class=&quot;headerlink&quot; title=&quot;python 标准库学习之 抽象基类 collection.abc&quot;&gt;&lt;/a&gt;python 标准库学习之 抽象基类 collection.abc&lt;/h2&gt;&lt;p&gt;众所周知,python3中所有类默认继承自object类,意味着父类中所有的方法,子类都继承了。&lt;/p&gt;
&lt;p&gt;我个人理解,抽象基类是无法被实例化的,只能子类实现&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/collections.abc.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源代码：&lt;/strong&gt; &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/_collections_abc.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lib/_collections_abc.py&lt;/a&gt; &lt;/p&gt;
&lt;p&gt; 该模块定义了一些 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;抽象基类&lt;/a&gt;，它们可用于判断一个具体类是否具有某一特定的接口；例如，这个类是否可哈希，或其是否为映射类。 &lt;/p&gt;
&lt;p&gt;模块里方法一览,摘自源码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__all__ = [&lt;span class=&quot;string&quot;&gt;&quot;Awaitable&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Coroutine&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;AsyncIterable&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;AsyncIterator&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;AsyncGenerator&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;Hashable&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Iterable&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Iterator&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Generator&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Reversible&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;Sized&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Container&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Callable&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Collection&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;Set&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;MutableSet&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;Mapping&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;MutableMapping&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;MappingView&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;KeysView&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;ItemsView&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;ValuesView&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;Sequence&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;MutableSequence&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;string&quot;&gt;&quot;ByteString&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           ]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="collections.abc" scheme="https://pinghailinfeng.gitee.io/tags/collections-abc/"/>
    
  </entry>
  
  <entry>
    <title>python standard library context-manager-types</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/11/python-standard-library-context-manager-types/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/11/python-standard-library-context-manager-types/</id>
    <published>2020-01-11T01:37:04.000Z</published>
    <updated>2020-01-11T02:54:51.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-上下文管理类型"><a href="#python-标准库-上下文管理类型" class="headerlink" title="python 标准库 上下文管理类型"></a>python 标准库 上下文管理类型</h1><p>每日一词:</p><blockquote><p>intresting : </p><p>US [‘ɪntrəstɪŋ]  UK [‘ɪntrəstɪŋ]</p><ul><li><strong>adj.</strong>有趣的；有吸引力的</li><li><strong>v.</strong>“interest”的现在分词</li><li><strong>Web</strong>有意思的；令人感兴趣的；引人入胜的</li></ul><p>比较级：more interesting<br>最高级：most interesting</p></blockquote><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200111_heihei.jpg?raw=true" alt></p><blockquote><p> 大部分时候,你都是一个人在默默努力,这样,距离成功才会更进一步。</p><p>​                                                        – 凭海临风语录</p></blockquote><h2 id="python-标准库学习-上下文管理"><a href="#python-标准库学习-上下文管理" class="headerlink" title="python 标准库学习  上下文管理"></a>python 标准库学习  上下文管理</h2><p>什么是上下文管理器？上下文管理器就是一个用装饰器实现上下文协议管理的对象。主要用于保存和恢复各种全局状态,例如关闭文件等。下面我们来了解具体的内容。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p><code>contextmanager.__enter__()</code></p><p>进入运行时上下文并返回此对象或关联到该运行时上下文的其他对象。 此方法的返回值会绑定到使用此上下文管理器的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的 <code>as</code> 子句中的标识符。一个返回其自身的上下文管理器的例子是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a>。 文件对象会从 <strong>enter</strong>() 返回其自身，以允许 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 被用作 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中的上下文表达式。一个返回关联对象的上下文管理器的例子是 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.localcontext" target="_blank" rel="noopener"><code>decimal.localcontext()</code></a> 所返回的对象。 此种管理器会将活动的 decimal 上下文设为原始 decimal 上下文的一个副本并返回该副本。 这允许对 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的语句体中的当前 decimal 上下文进行更改，而不会影响 <code>with</code> 语句以外的代码。</p></li><li><p><code>contextmanager.__exit__(*exc_type*, *exc_val*, *exc_tb*)</code></p><p>退出运行时上下文并返回一个布尔值旗标来表明所发生的任何异常是否应当被屏蔽。 如果在执行 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的语句体期间发生了异常，则参数会包含异常的类型、值以及回溯信息。 在其他情况下三个参数均为 <code>None</code>。自此方法返回一个真值将导致 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句屏蔽异常并继续执行紧随在 <code>with</code> 语句之后的语句。 否则异常将在此方法结束执行后继续传播。 在此方法执行期间发生的异常将会取代 <code>with</code> 语句的语句体中发生的任何异常。传入的异常绝对不应当被显式地重新引发 —— 相反地，此方法应当返回一个假值以表明方法已成功完成并且不希望屏蔽被引发的异常。 这允许上下文管理代码方便地检测 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#contextmanager.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 方法是否确实已失败。</p></li></ul><h4 id="一个文件操作实例"><a href="#一个文件操作实例" class="headerlink" title="一个文件操作实例"></a>一个文件操作实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">"/etc/hosts"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> file:</span><br><span class="line"><span class="meta">... </span>    dir(file)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__enter__'</span>, <span class="string">'__exit__'</span>, <span class="string">'__format__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'close'</span>, <span class="string">'closed'</span>, <span class="string">'encoding'</span>, <span class="string">'errors'</span>, <span class="string">'fileno'</span>, <span class="string">'flush'</span>, <span class="string">'isatty'</span>, <span class="string">'mode'</span>, <span class="string">'name'</span>, <span class="string">'newlines'</span>, <span class="string">'next'</span>, <span class="string">'read'</span>, <span class="string">'readinto'</span>, <span class="string">'readline'</span>, <span class="string">'readlines'</span>, <span class="string">'seek'</span>, <span class="string">'softspace'</span>, <span class="string">'tell'</span>, <span class="string">'truncate'</span>, <span class="string">'write'</span>, <span class="string">'writelines'</span>, <span class="string">'xreadlines'</span>]</span><br></pre></td></tr></table></figure><p>此时的open返回的对象file,就实现了管理打开文件、关闭文件的上下文管理协议。</p><a id="more"></a><h3 id="with-语句上下文管理器"><a href="#with-语句上下文管理器" class="headerlink" title="with 语句上下文管理器"></a>with 语句上下文管理器</h3><p><em>上下文管理器</em> 是一个对象，它定义了在执行 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句时要建立的运行时上下文。 上下文管理器处理进入和退出所需运行时上下文以执行代码块。 通常使用 <code>with</code> 语句（在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener">with 语句</a> 中描述），但是也可以通过直接调用它们的方法来使用。</p><p>上下文管理器的典型用法包括保存和恢复各种全局状态，锁定和解锁资源，关闭打开的文件等等。</p><p>要了解上下文管理器的更多信息，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#typecontextmanager" target="_blank" rel="noopener">上下文管理器类型</a>。</p><ul><li><p><code>object.__enter__</code>(<em>self</em>)</p><p>进入与此对象相关的运行时上下文。 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句将会绑定这个方法的返回值到 <code>as</code> 子句中指定的目标，如果有的话。</p></li><li><p><code>object.__exit__</code>(<em>self</em>, <em>exc_type</em>, <em>exc_value</em>, <em>traceback</em>)</p><p>退出关联到此对象的运行时上下文。 各个参数描述了导致上下文退出的异常。 如果上下文是无异常地退出的，三个参数都将为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。如果提供了异常，并且希望方法屏蔽此异常（即避免其被传播），则应当返回真值。 否则的话，异常将在退出此方法时按正常流程处理。请注意 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> 方法不应该重新引发被传入的异常，这是调用者的责任。</p></li></ul><blockquote><p>可以参考</p><ul><li><p><a href="https://www.python.org/dev/peps/pep-0343" target="_blank" rel="noopener"><strong>PEP 343</strong></a> - “with” 语句</p><p>Python <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句的规范描述、背景和示例。</p></li></ul></blockquote><h3 id="自定义上下文管理"><a href="#自定义上下文管理" class="headerlink" title="自定义上下文管理"></a>自定义上下文管理</h3><p>实现<code>__enter__</code> 和 <code>__exit__</code> 方法就是一个实现了上下文管理的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'__init__()'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'__enter__()'</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"__exit__()"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ContextManager():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"OK, we can do something here~~"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">__init__()</span><br><span class="line">__enter__()</span><br><span class="line">OK, we can do something here~~</span><br><span class="line">__exit__()</span><br></pre></td></tr></table></figure><p>另一个不返回当前类的上下文管理器的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerContext</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'InnerContext.__init__(%s)'</span> % obj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'InnerContext.do_something()'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'InnerContext.__del__()'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__init__()'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__enter__()'</span></span><br><span class="line">        <span class="keyword">return</span> InnerContext(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"ContextManager.__exit__()"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ContextManager() <span class="keyword">as</span> obj:</span><br><span class="line">    obj.do_something()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"OK, we can do something here~~"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">ContextManager.__init__()</span><br><span class="line">ContextManager.__enter__()</span><br><span class="line">InnerContext.__init__(&lt;__main__.ContextManager object at <span class="number">0x1012f95d0</span>&gt;)</span><br><span class="line">InnerContext.do_something()</span><br><span class="line">OK, we can do something here~~</span><br><span class="line">ContextManager.__exit__()</span><br><span class="line">InnerContext.__del__()</span><br></pre></td></tr></table></figure><p>异常处理的例子 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, flag)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__init__(%s)'</span> % flag</span><br><span class="line">        self.flag = flag</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__enter__()'</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ContextManager.__exit__(%s, %s, %s)'</span> % (exc_type, exc_val, exc_tb)</span><br><span class="line">        <span class="keyword">return</span> self.flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ContextManager(<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">'error message handled'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">with</span> ContextManager(<span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">'error message propagated'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">ContextManager.__init__(<span class="literal">True</span>)</span><br><span class="line">ContextManager.__enter__()</span><br><span class="line">ContextManager.__exit__(&lt;type <span class="string">'exceptions.RuntimeError'</span>&gt;, error message handled, &lt;traceback object at <span class="number">0x10d69dbd8</span>&gt;)</span><br><span class="line"></span><br><span class="line">ContextManager.__init__(<span class="literal">False</span>)</span><br><span class="line">ContextManager.__enter__()</span><br><span class="line">ContextManager.__exit__(&lt;type <span class="string">'exceptions.RuntimeError'</span>&gt;, error message propagated, &lt;traceback object at <span class="number">0x109e0fbd8</span>&gt;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"ContextManager.py"</span>, line <span class="number">19</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">'error message propagated'</span>)</span><br><span class="line">RuntimeError: error message propagated</span><br></pre></td></tr></table></figure><h3 id="contextlib-模块"><a href="#contextlib-模块" class="headerlink" title="contextlib 模块"></a>contextlib 模块</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/contextlib.html#contextlib.contextmanager" target="_blank" rel="noopener">参考文档</a></p><p>源代码 <a href="https://github.com/python/cpython/tree/3.8/Lib/contextlib.py" target="_blank" rel="noopener">Lib/contextlib.py</a></p><p>这个内置模块实现了上下文管理,使用<code>with</code>关键字。</p><p>主要方法如下(节选自源码):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">"asynccontextmanager"</span>, <span class="string">"contextmanager"</span>, <span class="string">"closing"</span>, <span class="string">"nullcontext"</span>,</span><br><span class="line">           <span class="string">"AbstractContextManager"</span>, <span class="string">"AbstractAsyncContextManager"</span>,</span><br><span class="line">           <span class="string">"AsyncExitStack"</span>, <span class="string">"ContextDecorator"</span>, <span class="string">"ExitStack"</span>,</span><br><span class="line">           <span class="string">"redirect_stdout"</span>, <span class="string">"redirect_stderr"</span>, <span class="string">"suppress"</span>]</span><br></pre></td></tr></table></figure><h4 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h4><p><em>class</em> <code>contextlib.AbstractContextManager</code></p><blockquote><p>同步的上下文管理类</p></blockquote><p><em>class</em> <code>contextlib.AbstractAsyncContextManager</code></p><blockquote><p>异步的上下文管理类</p></blockquote><h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><ul><li><p><a href="mailto:`@contextlib.contextmanager" target="_blank" rel="noopener">`@contextlib.contextmanager</a>`</p><p>一个实现了上下文资源管理的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">managed_resource</span><span class="params">(*args, **kwds)</span>:</span></span><br><span class="line">    <span class="comment"># Code to acquire resource, e.g.:</span></span><br><span class="line">    resource = acquire_resource(*args, **kwds)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> resource</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># Code to release resource, e.g.:</span></span><br><span class="line">        release_resource(resource)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> managed_resource(timeout=<span class="number">3600</span>) <span class="keyword">as</span> resource:</span><br><span class="line"><span class="meta">... </span>    <span class="comment"># Resource is released at the end of this block,</span></span><br><span class="line"><span class="meta">... </span>    <span class="comment"># even if code in the block raises an exception</span></span><br></pre></td></tr></table></figure><p>==tips== : 注意这里 返回的是generator对象，每次迭代器只会yield一个对象出来,这个值会用在<code>with</code>语句中,绑定到<code>as</code> 后的对象上。 </p></li><li><p>@contextlib.asynccontextmanager`</p><p>下面是一个实现了异步上下文管理器的实例,关于操作数据库对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> asynccontextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_connection</span><span class="params">()</span>:</span></span><br><span class="line">    conn = <span class="keyword">await</span> acquire_db_connection()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> conn</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">await</span> release_db_connection(conn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_all_users</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> get_connection() <span class="keyword">as</span> conn:</span><br><span class="line">        <span class="keyword">return</span> conn.query(<span class="string">'SELECT ...'</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li><p><code>contextlib.closing</code>(<em>thing</em>)</p><p>返回一个上下文管理对象,在语句结束之前被调用</p><p>相当于下面的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closing</span><span class="params">(thing)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> thing</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        thing.close()</span><br></pre></td></tr></table></figure><p>也可以这样实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> closing</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> closing(urlopen(<span class="string">'http://www.python.org'</span>)) <span class="keyword">as</span> page:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> page:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>contextlib.nullcontext</code></p><blockquote><p>返回一个上下文管理对象( 实现了<code>__enter__</code>方法)</p></blockquote><p>一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunction</span><span class="params">(arg, ignore_exceptions=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> ignore_exceptions:</span><br><span class="line">        <span class="comment"># Use suppress to ignore all exceptions.</span></span><br><span class="line">        cm = contextlib.suppress(Exception)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Do not ignore any exceptions, cm has no effect.</span></span><br><span class="line">        cm = contextlib.nullcontext()</span><br><span class="line">    <span class="keyword">with</span> cm:</span><br><span class="line">        <span class="comment"># Do something</span></span><br></pre></td></tr></table></figure></li></ul><p>  另一个例子</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_file</span><span class="params">(file_or_path)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(file_or_path, str):</span><br><span class="line">        <span class="comment"># If string, open file</span></span><br><span class="line">        cm = open(file_or_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Caller is responsible for closing file</span></span><br><span class="line">        cm = nullcontext(file_or_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> cm <span class="keyword">as</span> file:</span><br><span class="line">        <span class="comment"># Perform processing on the file</span></span><br></pre></td></tr></table></figure><ul><li><p><code>contextlib.suppress</code></p><blockquote><p>返回一个声明的异常对象的上下文管理</p></blockquote><p>一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> suppress</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> suppress(FileNotFoundError):</span><br><span class="line">    os.remove(<span class="string">'somefile.tmp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> suppress(FileNotFoundError):</span><br><span class="line">    os.remove(<span class="string">'someotherfile.tmp'</span>)</span><br></pre></td></tr></table></figure><p>和下面的代码等价</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.remove(<span class="string">'somefile.tmp'</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os.remove(<span class="string">'someotherfile.tmp'</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>contextlib.redirect_stdout</code></p><blockquote><p>临时输出标准输出的上下文管理器</p></blockquote></li><li><p><code>contextlib.redirect_stderr</code></p><blockquote><p>临时输出标准错误的上下文管理器</p></blockquote></li><li><p><em>class</em> <code>contextlib.ContextDecorator</code></p></li></ul><blockquote><p>允许一个类像装饰器那样使用,<code>ContextDecorator</code> 正好实现了<code>__enter__</code> and <code>__exit__</code> 方法。</p><p>使用contextlib就自动调用这个装饰器。</p></blockquote><p> 一个实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> ContextDecorator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontext</span><span class="params">(ContextDecorator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Starting'</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *exc)</span>:</span></span><br><span class="line">        print(<span class="string">'Finishing'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@mycontext()</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'The bit in the middle'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>function()</span><br><span class="line">Starting</span><br><span class="line">The bit <span class="keyword">in</span> the middle</span><br><span class="line">Finishing</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> mycontext():</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'The bit in the middle'</span>)</span><br><span class="line">...</span><br><span class="line">Starting</span><br><span class="line">The bit <span class="keyword">in</span> the middle</span><br><span class="line">Finishing</span><br></pre></td></tr></table></figure><p>其实本质上就是实现了语法糖</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> cm():</span><br><span class="line">        <span class="comment"># Do stuff</span></span><br></pre></td></tr></table></figure><p><code>ContextDecorator</code> 允许你这样使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@cm()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Do stuff</span></span><br></pre></td></tr></table></figure><p>允许你通过继承ContextBaseClass和ContextDecorator,实现Mixin class(我也不知道该如何翻译,姑且翻译成混合继承吧)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> ContextDecorator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontext</span><span class="params">(ContextBaseClass, ContextDecorator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *exc)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li><em>class</em> <code>contextlib.ExitStack</code></li></ul><blockquote><p>一个上下文管理器可以被设计成自动合并其他上下文管理器,清除方法(栈),尤其是那些需要输入数据的功能实现。</p><p>这里我看了源码,通过一个栈结构管理上下文管理， 其实就是实现了一个上下文管理器栈</p><p>下面是一个例子:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ExitStack() <span class="keyword">as</span> stack:</span><br><span class="line">    files = [stack.enter_context(open(fname)) <span class="keyword">for</span> fname <span class="keyword">in</span> filenames]</span><br><span class="line">    <span class="comment"># All opened files will automatically be closed at the end of</span></span><br><span class="line">    <span class="comment"># the with statement, even if attempts to open files later</span></span><br><span class="line">    <span class="comment"># in the list raise an exception</span></span><br></pre></td></tr></table></figure><blockquote><p>个人理解这是一个低级的api,内部实现了,你无需关心何时该调用该方法,由python内部去处理。</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p>最近恰好看flask的源码,flask的生命周期管理也是使用上下文管理装饰器实现。</p><p>等有空再更新一篇吧。</p><p>今天就到这里,祝大家周末愉快！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-上下文管理类型&quot;&gt;&lt;a href=&quot;#python-标准库-上下文管理类型&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 上下文管理类型&quot;&gt;&lt;/a&gt;python 标准库 上下文管理类型&lt;/h1&gt;&lt;p&gt;每日一词:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;intresting : &lt;/p&gt;
&lt;p&gt;US [‘ɪntrəstɪŋ]  UK [‘ɪntrəstɪŋ]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;adj.&lt;/strong&gt;有趣的；有吸引力的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;v.&lt;/strong&gt;“interest”的现在分词&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web&lt;/strong&gt;有意思的；令人感兴趣的；引人入胜的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较级：more interesting&lt;br&gt;最高级：most interesting&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200111_heihei.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 大部分时候,你都是一个人在默默努力,这样,距离成功才会更进一步。&lt;/p&gt;
&lt;p&gt;​                                                        – 凭海临风语录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;python-标准库学习-上下文管理&quot;&gt;&lt;a href=&quot;#python-标准库学习-上下文管理&quot; class=&quot;headerlink&quot; title=&quot;python 标准库学习  上下文管理&quot;&gt;&lt;/a&gt;python 标准库学习  上下文管理&lt;/h2&gt;&lt;p&gt;什么是上下文管理器？上下文管理器就是一个用装饰器实现上下文协议管理的对象。主要用于保存和恢复各种全局状态,例如关闭文件等。下面我们来了解具体的内容。&lt;/p&gt;
&lt;h3 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;contextmanager.__enter__()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进入运行时上下文并返回此对象或关联到该运行时上下文的其他对象。 此方法的返回值会绑定到使用此上下文管理器的 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; 语句的 &lt;code&gt;as&lt;/code&gt; 子句中的标识符。一个返回其自身的上下文管理器的例子是 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;file object&lt;/a&gt;。 文件对象会从 &lt;strong&gt;enter&lt;/strong&gt;() 返回其自身，以允许 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/functions.html#open&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; 被用作 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; 语句中的上下文表达式。一个返回关联对象的上下文管理器的例子是 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.localcontext&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;decimal.localcontext()&lt;/code&gt;&lt;/a&gt; 所返回的对象。 此种管理器会将活动的 decimal 上下文设为原始 decimal 上下文的一个副本并返回该副本。 这允许对 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; 语句的语句体中的当前 decimal 上下文进行更改，而不会影响 &lt;code&gt;with&lt;/code&gt; 语句以外的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;contextmanager.__exit__(*exc_type*, *exc_val*, *exc_tb*)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;退出运行时上下文并返回一个布尔值旗标来表明所发生的任何异常是否应当被屏蔽。 如果在执行 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; 语句的语句体期间发生了异常，则参数会包含异常的类型、值以及回溯信息。 在其他情况下三个参数均为 &lt;code&gt;None&lt;/code&gt;。自此方法返回一个真值将导致 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; 语句屏蔽异常并继续执行紧随在 &lt;code&gt;with&lt;/code&gt; 语句之后的语句。 否则异常将在此方法结束执行后继续传播。 在此方法执行期间发生的异常将会取代 &lt;code&gt;with&lt;/code&gt; 语句的语句体中发生的任何异常。传入的异常绝对不应当被显式地重新引发 —— 相反地，此方法应当返回一个假值以表明方法已成功完成并且不希望屏蔽被引发的异常。 这允许上下文管理代码方便地检测 &lt;a href=&quot;https://docs.python.org/zh-cn/3.8/library/stdtypes.html#contextmanager.__exit__&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; 方法是否确实已失败。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;一个文件操作实例&quot;&gt;&lt;a href=&quot;#一个文件操作实例&quot; class=&quot;headerlink&quot; title=&quot;一个文件操作实例&quot;&gt;&lt;/a&gt;一个文件操作实例&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; open(&lt;span class=&quot;string&quot;&gt;&quot;/etc/hosts&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;r&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; file:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    dir(file)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&#39;__class__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__delattr__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__doc__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__enter__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__exit__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__format__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__getattribute__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__hash__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__init__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__iter__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__new__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__reduce__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__reduce_ex__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__repr__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__setattr__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__sizeof__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__str__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;__subclasshook__&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;close&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;closed&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;encoding&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;errors&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;fileno&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;flush&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;isatty&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;mode&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;newlines&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;next&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;read&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;readinto&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;readline&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;readlines&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;seek&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;softspace&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;tell&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;truncate&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;write&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;writelines&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;xreadlines&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此时的open返回的对象file,就实现了管理打开文件、关闭文件的上下文管理协议。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="context-manager-types" scheme="https://pinghailinfeng.gitee.io/tags/context-manager-types/"/>
    
  </entry>
  
</feed>
