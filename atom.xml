<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凭海临风的IT江湖</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pinghailinfeng.gitee.io/"/>
  <updated>2020-02-19T13:44:39.751Z</updated>
  <id>https://pinghailinfeng.gitee.io/</id>
  
  <author>
    <name>Jeff Sui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python standard library shutil</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/19/python-standard-library-shutil/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/19/python-standard-library-shutil/</id>
    <published>2020-02-19T13:24:47.000Z</published>
    <updated>2020-02-19T13:44:39.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-shutil-高阶文件操作"><a href="#python-标准库-shutil-高阶文件操作" class="headerlink" title="python 标准库 shutil 高阶文件操作"></a>python 标准库 shutil 高阶文件操作</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200219python3_sheet.png?raw=true" alt></p><a id="more"></a><p>收集了一些网上找到的学习python的资源,分享给大家。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/shutil.py" target="_blank" rel="noopener">Lib/shutil.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 模块提供了一系列对文件和文件集合的高阶操作。 特别是提供了一些支持文件拷贝和删除的函数。 对于单个文件的操作，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块。</p><blockquote><p>警告：即便是高阶文件拷贝函数 (<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>shutil.copy()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>shutil.copy2()</code></a>) 也无法拷贝所有的文件元数据。</p><p>在 POSIX 平台上，这意味着将丢失文件所有者和组以及 ACL 数据。 在 Mac OS 上，资源钩子和其他元数据不被使用。 这意味着将丢失这些资源并且文件类型和创建者代码将不正确。 在 Windows 上，将不会拷贝文件所有者、ACL 和替代数据流。</p></blockquote><h2 id="目录和文件操作"><a href="#目录和文件操作" class="headerlink" title="目录和文件操作"></a>目录和文件操作</h2><ul><li><p><code>shutil.copyfileobj</code>(<em>fsrc</em>, <em>fdst</em>[, <em>length</em>])</p><p>将文件类对象 <em>fsrc</em> 的内容拷贝到文件类对象 <em>fdst</em>。 整数值 <em>length</em> 如果给出则为缓冲区大小。 特别地， <em>length</em> 为负值表示拷贝数据时不对源数据进行分块循环处理；默认情况下会分块读取数据以避免不受控制的内存消耗。 请注意如果 <em>fsrc</em> 对象的当前文件位置不为 0，则只有从当前文件位置到文件末尾的内容会被拷贝。</p></li><li><p><code>shutil.copyfile</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>将名为 <em>src</em> 的文件的内容（不包括元数据）拷贝到名为 <em>dst</em> 的文件并以尽可能高效的方式返回 <em>dst</em>。 <em>src</em> 和 <em>dst</em> 均为路径类对象或以字符串形式给出的路径名。<em>dst</em> 必须是完整的目标文件名；对于接受目标目录路径的拷贝请参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a>。 如果 <em>src</em> 和 <em>dst</em> 指定了同一个文件，则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.SameFileError" target="_blank" rel="noopener"><code>SameFileError</code></a>。目标位置必须是可写的；否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。 如果 <em>dst</em> 已经存在，它将被替换。 特殊文件如字符或块设备以及管道无法用此函数来拷贝。如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则将创建一个新的符号链接而不是拷贝 <em>src</em> 所指向的文件。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 曾经是引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IOError" target="_blank" rel="noopener"><code>IOError</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>。 增加了 <em>follow_symlinks</em> 参数。 现在是返回 <em>dst</em>。<em>在 3.4 版更改:</em> 引发 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.SameFileError" target="_blank" rel="noopener"><code>SameFileError</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.Error" target="_blank" rel="noopener"><code>Error</code></a>。 由于前者是后者的子类，此改变是向后兼容的。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p></li><li><p><em>exception</em> <code>shutil.SameFileError</code></p><p>此异常会在 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfile" target="_blank" rel="noopener"><code>copyfile()</code></a> 中的源和目标为同一文件时被引发。<em>3.4 新版功能.</em></p></li><li><p><code>shutil.copymode</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>从 <em>src</em> 拷贝权限位到 <em>dst</em>。 文件的内容、所有者和分组将不受影响。 <em>src</em> 和 <em>dst</em> 均为路径类对象或字符串形式的路径名。 如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均为符号链接，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copymode" target="_blank" rel="noopener"><code>copymode()</code></a> 将尝试修改 <em>dst</em> 本身的模式（而非它所指向的文件）。 此功能并不是在所有平台上均可用；请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 了解详情。 如果 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copymode" target="_blank" rel="noopener"><code>copymode()</code></a> 无法修改本机平台上的符号链接，而它被要求这样做，它将不做任何操作即返回。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copymode</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 加入 <em>follow_symlinks</em> 参数。</p></li><li><p><code>shutil.copystat</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>从 <em>src</em> 拷贝权限位、最近访问时间、最近修改时间以及旗标到 <em>dst</em>。 在 Linux上，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 还会在可能的情况下拷贝“扩展属性”。 文件的内容、所有者和分组将不受影响。 <em>src</em> 和 <em>dst</em> 均为路径类对象或字符串形式的路径名。如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均指向符号链接，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 将作用于符号链接本身而非该符号链接所指向的文件 — 从 <em>src</em> 符号链接读取信息，并将信息写入 <em>dst</em> 符号链接。</p><blockquote><p>注解:</p><p>并非所有平台者提供检查和修改符号链接的功能。 Python 本身可以告诉你哪些功能是在本机上可用的。</p><ul><li>如果 <code>os.chmod in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 可以修改符号链接的权限位。</li><li>如果 <code>os.utime in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 可以修改符号链接的最近访问和修改时间。</li><li>如果 <code>os.chflags in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 可以修改符号链接的旗标。 (<code>os.chflags</code> 不是在所有平台上均可用。)</li></ul><p>在此功能部分或全部不可用的平台上，当被要求修改一个符号链接时，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 将尽量拷贝所有内容。 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 一定不会返回失败信息。</p><p>更多信息请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_follow_symlinks" target="_blank" rel="noopener"><code>os.supports_follow_symlinks</code></a>。</p></blockquote><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copystat</code> 附带参数 <code>src</code>, <code>dst</code>。</p><p><em>在 3.3 版更改:</em> 添加了 <em>follow_symlinks</em> 参数并且支持 Linux 扩展属性。</p></li><li><p><code>shutil.copy</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>将文件 <em>src</em> 拷贝到文件或目录 <em>dst</em>。 <em>src</em> 和 <em>dst</em> 应为字符串。 如果 <em>dst</em> 指定了一个目录，文件将使用 <em>src</em> 中的基准文件名拷贝到 <em>dst</em>。 返回新创建文件的路径。如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则 <em>dst</em> 也将被创建为符号链接。 如果 <em>follow_symlinks</em> 为真值且 <em>src</em> 为符号链接，<em>dst</em> 将成为 <em>src</em> 所指向的文件的一个副本。<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a> 会拷贝文件数据和文件的权限模式 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>os.chmod()</code></a>)。 其他元数据，例如文件的创建和修改时间不会被保留。 要保留所有原有的元数据，请改用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copymode</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 添加了 <em>follow_symlinks</em> 参数。 现在会返回新创建文件的路径。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p></li><li><p><code>shutil.copy2</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a>，区别在于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 还会尝试保留文件的元数据。当 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接时，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 会尝试将来自 <em>src</em> 符号链接的所有元数据拷贝到新创建的 <em>dst</em> 符号链接。 但是，此功能不是在所有平台上均可用。 在此功能部分或全部不可用的平台上，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 将尽量保留所有元数据；<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 一定不会由于无法保留文件元数据而引发异常。<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 会使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 来拷贝文件元数据。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 了解有关修改符号链接元数据的平台支持的更多信息。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copystat</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 添加了 <em>follow_symlinks</em> 参数，还会尝试拷贝扩展文件系统属性（目前仅限 Linux）。 现在会返回新创建文件的路径。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p></li><li><p><code>shutil.ignore_patterns</code>(*<em>patterns</em>)</p><p>这个工厂函数会创建一个函数，它可被用作 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 的 <em>ignore</em> 可调用对象参数，以忽略那些匹配所提供的 glob 风格的 <em>patterns</em> 之一的文件和目录。 参见以下示例。</p></li><li><p><code>shutil.copytree</code>(<em>src</em>, <em>dst</em>, <em>symlinks=False</em>, <em>ignore=None</em>, <em>copy_function=copy2</em>, <em>ignore_dangling_symlinks=False</em>, <em>dirs_exist_ok=False</em>)</p><p>将以 <em>src</em> 为根起点的整个目录树拷贝到名为 <em>dst</em> 的目录并返回目标目录。 <em>dirs_exist_ok</em> 指明是否要在 <em>dst</em> 或任何丢失的父目录已存在的情况下引发异常。目录的权限和时间会通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 来拷贝，单个文件则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 来拷贝。如果 <em>symlinks</em> 为真值，源目录树中的符号链接会在新目录树中表示为符号链接，并且原链接的元数据在平台允许的情况下也会被拷贝；如果为假值或省略，则会将被链接文件的内容和元数据拷贝到新目录树。当 <em>symlinks</em> 为假值时，如果符号链接所指向的文件不存在，则会在拷贝进程的末尾将一个异常添加到 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.Error" target="_blank" rel="noopener"><code>Error</code></a> 异常中的错误列表。 如果你希望屏蔽此异常那就将可选的 <em>ignore_dangling_symlinks</em> 旗标设为真值。 请注意此选项在不支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.symlink" target="_blank" rel="noopener"><code>os.symlink()</code></a> 的平台上将不起作用。如果给出了 <em>ignore</em>，它必须是一个可调用对象，该对象将接受 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 所访问的目录以及 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>os.listdir()</code></a> 所返回的目录内容列表作为其参数。 由于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 是递归地被调用的，<em>ignore</em> 可调用对象对于每个被拷贝目录都将被调用一次。 该可调用对象必须返回一个相对于当前目录的目录和文件名序列（即其第二个参数的子集）；随后这些名称将在拷贝进程中被忽略。 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.ignore_patterns" target="_blank" rel="noopener"><code>ignore_patterns()</code></a> 可被用于创建这种基于 glob 风格模式来忽略特定名称的可调用对象。如果发生了（一个或多个）异常，将引发一个附带原因列表的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.Error" target="_blank" rel="noopener"><code>Error</code></a>。如果给出了 <em>copy_function</em>，它必须是一个将被用来拷贝每个文件的可调用对象。 它在被调用时会将源路径和目标路径作为参数传入。 默认情况下，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 将被使用，但任何支持同样签名（与 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a> 一致）都可以使用。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copytree</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 当 <em>symlinks</em> 为假值时拷贝元数据。 现在会返回 <em>dst</em>。<em>在 3.2 版更改:</em> 添加了 <em>copy_function</em> 参数以允许提供定制的拷贝函数。 添加了 <em>ignore_dangling_symlinks</em> 参数以便在 <em>symlinks</em> 为假值时屏蔽符号链接错误。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。<em>3.8 新版功能:</em> <em>dirs_exist_ok</em> 形参。</p></li><li><p><code>shutil.rmtree</code>(<em>path</em>, <em>ignore_errors=False</em>, <em>onerror=None</em>)</p><p>删除一个完整的目录树；<em>path</em> 必须指向一个目录（但不能是一个目录的符号链接）。 如果 <em>ignore_errors</em> 为真值，删除失败导致的错误将被忽略；如果为假值或是省略，此类错误将通过调用由 <em>onerror</em> 所指定的处理程序来处理，或者如果此参数被省略则将引发一个异常。</p><blockquote><p>注解:</p><p>在支持必要的基于 fd 的函数的平台上，默认会使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree" target="_blank" rel="noopener"><code>rmtree()</code></a> 的可防御符号链接攻击的版本。 在其他平台上，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree" target="_blank" rel="noopener"><code>rmtree()</code></a> 较易遭受符号链接攻击：给定适当的时间和环境，攻击者可以操纵文件系统中的符号链接来删除他们在其他情况下无法访问的文件。 应用程序可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree.avoids_symlink_attacks" target="_blank" rel="noopener"><code>rmtree.avoids_symlink_attacks</code></a> 函数属性来确定此类情况具体是哪一些。</p></blockquote></li></ul><ul><li><p><code>shutil.move</code>(<em>src</em>, <em>dst</em>, <em>copy_function=copy2</em>)</p><p>递归地将一个文件或目录 (<em>src</em>) 移至另一位置 (<em>dst</em>) 并返回目标位置。如果目标是已存在的目录，则 <em>src</em> 会被移至该目录下。 如果目标已存在但不是目录，它可能会被覆盖，具体取决于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a> 的语义。如果目标是在当前文件系统中，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a>。 在其他情况下，<em>src</em> 将被拷贝至 <em>dst</em>，使用的函数为 <em>copy_function</em>，然后目标会被移除。 对于符号链接，则将在 <em>dst</em> 之下或以其本身为名称创建一个指向 <em>src</em> 目标的新符号链接，并且 <em>src</em> 将被移除。如果给出了 <em>copy_function</em>，则它必须为接受两个参数 <em>src</em> 和 <em>dst</em> 的可调用对象，并会在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a> 无法使用时被用来将 <em>src</em> 拷贝到 <em>dest</em>。 如果源位置是一个目录，则会调用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a>，并向它传入 <code>copy_function()</code>。 默认的 <em>copy_function</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a>。 使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a> 作为 <em>copy_function</em> 允许在无法附带拷贝元数据时让移动操作成功执行，但其代价是不拷贝任何元数据。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.move</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 为异类文件系统添加了显式的符号链接处理，以便使它适应 GNU 的 <strong>mv</strong> 的行为。 现在会返回 <em>dst</em>。<em>在 3.5 版更改:</em> 增加了 <em>copy_function</em> 关键字参数。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p></li><li><p><code>shutil.disk_usage</code>(<em>path</em>)</p><p>返回给定路径的磁盘使用统计数据，形式为一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-named-tuple" target="_blank" rel="noopener">named tuple</a>，其中包含 <em>total</em>, <em>used</em> 和 <em>free</em> 属性，分别表示总计、已使用和未使用空间的字节数。 <em>path</em> 可以是一个文件或是一个目录。<em>3.3 新版功能.**在 3.8 版更改:</em> 在 Windows 上，<em>path</em> 现在可以是一个文件或目录。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><code>shutil.chown</code>(<em>path</em>, <em>user=None</em>, <em>group=None</em>)</p><p>修改给定 <em>path</em> 的所有者 <em>user</em> 和/或 <em>group</em>。<em>user</em> 可以是一个系统用户名或 uid；<em>group</em> 同样如此。 要求至少有一个参数。另请参阅下层的函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chown" target="_blank" rel="noopener"><code>os.chown()</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.chown</code> 附带参数 <code>path</code>, <code>user</code>, <code>group</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">Availability</a>: Unix.<em>3.3 新版功能.</em></p></li><li><p><code>shutil.which</code>(<em>cmd</em>, <em>mode=os.F_OK | os.X_OK</em>, <em>path=None</em>)</p><p>返回当给定的 <em>cmd</em> 被调用时将要运行的可执行文件的路径。 如果没有 <em>cmd</em> 会被调用则返回 <code>None</code>。<em>mode</em> 是一个传递给 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>os.access()</code></a> 的权限掩码，在默认情况下将确定文件是否存在并且为可执行文件。当未指定 <em>path</em> 时，将会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>os.environ()</code></a> 的结果，返回 “PATH” 的值或回退为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.defpath" target="_blank" rel="noopener"><code>os.defpath</code></a>。在 Windows 上当前目录总是会被添加为 <em>path</em> 的第一项，无论你是否使用默认值或提供你自己的路径，这是命令行终端在查找可执行文件时所采用的行为方式。 此外，当在 <em>path</em> 中查找 <em>cmd</em> 时，还会检查 <code>PATHEXT</code> 环境变量。 例如，如果你调用 <code>shutil.which(&quot;python&quot;)</code>，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.which" target="_blank" rel="noopener"><code>which()</code></a> 将搜索 <code>PATHEXT</code> 来确定它要在 <em>path</em> 目录中查找 <code>python.exe</code>。 例如，在 Windows 上:&gt;&gt;&gt;<code>&gt;&gt;&gt; shutil.which(&quot;python&quot;) &#39;C:\\Python33\\python.EXE&#39;</code><em>3.3 新版功能.**在 3.8 版更改:</em> 现在可以接受 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型。 如果 <em>cmd</em> 的类型为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>，结果的类型也将为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>。</p></li><li><p><em>exception</em> <code>shutil.Error</code></p><p>此异常会收集在多文件操作期间所引发的异常。 对于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a>，此异常参数将是一个由三元组 (<em>srcname</em>, <em>dstname</em>, <em>exception</em>) 构成的列表。</p></li></ul><h2 id="依赖于具体平台的高效拷贝操作"><a href="#依赖于具体平台的高效拷贝操作" class="headerlink" title="依赖于具体平台的高效拷贝操作"></a>依赖于具体平台的高效拷贝操作</h2><p>从 Python 3.8 开始，所有涉及文件拷贝的函数 (<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfile" target="_blank" rel="noopener"><code>copyfile()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#module-copy" target="_blank" rel="noopener"><code>copy()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a>, 以及 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.move" target="_blank" rel="noopener"><code>move()</code></a>) 将会使用平台专属的 “fast-copy” 系统调用以便更高效地拷贝文件 (参见 <a href="https://bugs.python.org/issue33671" target="_blank" rel="noopener">bpo-33671</a>)。 “fast-copy” 意味着拷贝操作将发生于内核之中，避免像在 “<code>outfd.write(infd.read())</code>“ 中那样使用用户空间的缓冲区。</p><p>在 macOS 上将会使用 <a href="http://www.manpagez.com/man/3/copyfile/" target="_blank" rel="noopener">fcopyfile</a> 来拷贝文件内容（不含元数据）。</p><p>在 Linux 上将会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sendfile" target="_blank" rel="noopener"><code>os.sendfile()</code></a>。</p><p>在 Windows 上 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfile" target="_blank" rel="noopener"><code>shutil.copyfile()</code></a> 将会使用更大的默认缓冲区（1 MiB 而非 64 KiB）并且会使用基于 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview()</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfileobj" target="_blank" rel="noopener"><code>shutil.copyfileobj()</code></a> 变种形式。</p><p>如果快速拷贝操作失败并且没有数据被写入目标文件，则 shutil 将在内部静默地回退到使用效率较低的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfileobj" target="_blank" rel="noopener"><code>copyfileobj()</code></a> 函数。</p><p><em>在 3.8 版更改.</em></p><h3 id="copytree-示例"><a href="#copytree-示例" class="headerlink" title="copytree 示例"></a>copytree 示例</h3><p>这个示例就是上面所描述的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 函数的实现，其中省略了文档字符串。 它还展示了此模块所提供的许多其他函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copytree</span><span class="params">(src, dst, symlinks=False)</span>:</span></span><br><span class="line">    names = os.listdir(src)</span><br><span class="line">    os.makedirs(dst)</span><br><span class="line">    errors = []</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        srcname = os.path.join(src, name)</span><br><span class="line">        dstname = os.path.join(dst, name)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> symlinks <span class="keyword">and</span> os.path.islink(srcname):</span><br><span class="line">                linkto = os.readlink(srcname)</span><br><span class="line">                os.symlink(linkto, dstname)</span><br><span class="line">            <span class="keyword">elif</span> os.path.isdir(srcname):</span><br><span class="line">                copytree(srcname, dstname, symlinks)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                copy2(srcname, dstname)</span><br><span class="line">            <span class="comment"># XXX What about devices, sockets etc.?</span></span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> why:</span><br><span class="line">            errors.append((srcname, dstname, str(why)))</span><br><span class="line">        <span class="comment"># catch the Error from the recursive copytree so that we can</span></span><br><span class="line">        <span class="comment"># continue with other files</span></span><br><span class="line">        <span class="keyword">except</span> Error <span class="keyword">as</span> err:</span><br><span class="line">            errors.extend(err.args[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        copystat(src, dst)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> why:</span><br><span class="line">        <span class="comment"># can't copy file access times on Windows</span></span><br><span class="line">        <span class="keyword">if</span> why.winerror <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            errors.extend((src, dst, str(why)))</span><br><span class="line">    <span class="keyword">if</span> errors:</span><br><span class="line">        <span class="keyword">raise</span> Error(errors)</span><br></pre></td></tr></table></figure><p>另一个使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.ignore_patterns" target="_blank" rel="noopener"><code>ignore_patterns()</code></a> 辅助函数的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree, ignore_patterns</span><br><span class="line"></span><br><span class="line">copytree(source, destination, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br></pre></td></tr></table></figure><p>这将会拷贝除 <code>.pyc</code> 文件和以 <code>tmp</code> 打头的文件或目录以外的所有条目.</p><p>另一个使用 <em>ignore</em> 参数来添加记录调用的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_logpath</span><span class="params">(path, names)</span>:</span></span><br><span class="line">    logging.info(<span class="string">'Working in %s'</span>, path)</span><br><span class="line">    <span class="keyword">return</span> []   <span class="comment"># nothing will be ignored</span></span><br><span class="line"></span><br><span class="line">copytree(source, destination, ignore=_logpath)</span><br></pre></td></tr></table></figure><h3 id="rmtree-示例"><a href="#rmtree-示例" class="headerlink" title="rmtree 示例"></a>rmtree 示例</h3><p>这个例子演示了如何在 Windows 上删除一个目录树，其中部分文件设置了只读属性位。 它会使用 onerror 回调函数来清除只读属性位并再次尝试删除。 任何后续的失败都将被传播。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, stat</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_readonly</span><span class="params">(func, path, _)</span>:</span></span><br><span class="line">    <span class="string">"Clear the readonly bit and reattempt the removal"</span></span><br><span class="line">    os.chmod(path, stat.S_IWRITE)</span><br><span class="line">    func(path)</span><br><span class="line"></span><br><span class="line">shutil.rmtree(directory, onerror=remove_readonly)</span><br></pre></td></tr></table></figure><h2 id="归档操作"><a href="#归档操作" class="headerlink" title="归档操作"></a>归档操作</h2><p><em>3.2 新版功能.</em></p><p><em>在 3.5 版更改:</em> 添加了对 <em>xztar</em> 格式的支持。</p><p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <a href="https://docs.python.org/zh-cn/3.8/library/zipfile.html#module-zipfile" target="_blank" rel="noopener"><code>zipfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tarfile.html#module-tarfile" target="_blank" rel="noopener"><code>tarfile</code></a> 模块。</p><ul><li><p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p><p>创建一个归档文件（例如 zip 或 tar）并返回其名称。<em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “tar”, “gztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “bztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用) 或 “xztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用) 中的一个。<em>root_dir</em> 是一个目录，它将作为归档文件的根目录；例如，我们通常会在创建归档文件之前用 chdir 命令切换到 <em>root_dir</em>。<em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档文件中所有文件和目录共有的路径前缀。<em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。<em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。<em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logging.Logger" target="_blank" rel="noopener"><code>logging.Logger</code></a> 的实例。<em>verbose</em> 参数已不再使用并进入弃用状态。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。<em>在 3.8 版更改:</em> 现在对于通过 <code>format=&quot;tar&quot;</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p></li><li><p><code>shutil.get_archive_formats</code>()</p><p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_archive_format" target="_blank" rel="noopener"><code>register_archive_format()</code></a> 注册新的格式或为任何现有格式提供你自己的归档器。</p></li><li><p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>为 <em>name</em> 格式注册一个归档器。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name</em>，再加上要归档内容的 <em>base_dir</em> (其默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.make_archive" target="_blank" rel="noopener"><code>make_archive()</code></a> 传入的参数一致)。如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。<em>description</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_archive_formats" target="_blank" rel="noopener"><code>get_archive_formats()</code></a> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p></li><li><p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p><p>从支持的格式中移除归档格式 <em>name</em>。</p></li><li><p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p><p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。<em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。<em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册的其他格式。 如果未提供，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.unpack_archive" target="_blank" rel="noopener"><code>unpack_archive()</code></a> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。<em>在 3.7 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a> 作为 <em>filename</em> 和 <em>extract_dir</em>。</p></li><li><p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。可以提供 <em>description</em> 来描述该格式，它将被 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_unpack_formats" target="_blank" rel="noopener"><code>get_unpack_formats()</code></a> 返回。</p></li><li><p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p><p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p></li><li><p><code>shutil.get_unpack_formats</code>()</p><p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。<em>tar</em>: 未压缩的 tar 文件。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册新的格式或为任何现有格式提供你自己的解包器。</p></li></ul><p><em>3.2 新版功能.</em></p><p><em>在 3.5 版更改:</em> 添加了对 <em>xztar</em> 格式的支持。</p><p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <a href="https://docs.python.org/zh-cn/3.8/library/zipfile.html#module-zipfile" target="_blank" rel="noopener"><code>zipfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tarfile.html#module-tarfile" target="_blank" rel="noopener"><code>tarfile</code></a> 模块。</p><ul><li><p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p><p>创建一个归档文件（例如 zip 或 tar）并返回其名称。<em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “tar”, “gztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “bztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用) 或 “xztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用) 中的一个。<em>root_dir</em> 是一个目录，它将作为归档文件的根目录；例如，我们通常会在创建归档文件之前用 chdir 命令切换到 <em>root_dir</em>。<em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档文件中所有文件和目录共有的路径前缀。<em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。<em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。<em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logging.Logger" target="_blank" rel="noopener"><code>logging.Logger</code></a> 的实例。<em>verbose</em> 参数已不再使用并进入弃用状态。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。<em>在 3.8 版更改:</em> 现在对于通过 <code>format=&quot;tar&quot;</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p></li><li><p><code>shutil.get_archive_formats</code>()</p><p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_archive_format" target="_blank" rel="noopener"><code>register_archive_format()</code></a> 注册新的格式或为任何现有格式提供你自己的归档器。</p></li><li><p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>为 <em>name</em> 格式注册一个归档器。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name</em>，再加上要归档内容的 <em>base_dir</em> (其默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.make_archive" target="_blank" rel="noopener"><code>make_archive()</code></a> 传入的参数一致)。如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。<em>description</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_archive_formats" target="_blank" rel="noopener"><code>get_archive_formats()</code></a> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p></li><li><p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p><p>从支持的格式中移除归档格式 <em>name</em>。</p></li><li><p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p><p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。<em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。<em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册的其他格式。 如果未提供，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.unpack_archive" target="_blank" rel="noopener"><code>unpack_archive()</code></a> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。<em>在 3.7 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a> 作为 <em>filename</em> 和 <em>extract_dir</em>。</p></li><li><p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。可以提供 <em>description</em> 来描述该格式，它将被 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_unpack_formats" target="_blank" rel="noopener"><code>get_unpack_formats()</code></a> 返回。</p></li><li><p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p><p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p></li><li><p><code>shutil.get_unpack_formats</code>()</p><p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。<em>tar</em>: 未压缩的 tar 文件。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册新的格式或为任何现有格式提供你自己的解包器。</p></li></ul><p><em>3.2 新版功能.</em></p><p><em>在 3.5 版更改:</em> 添加了对 <em>xztar</em> 格式的支持。</p><p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <a href="https://docs.python.org/zh-cn/3.8/library/zipfile.html#module-zipfile" target="_blank" rel="noopener"><code>zipfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tarfile.html#module-tarfile" target="_blank" rel="noopener"><code>tarfile</code></a> 模块。</p><ul><li><p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p><p>创建一个归档文件（例如 zip 或 tar）并返回其名称。<em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “tar”, “gztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “bztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用) 或 “xztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用) 中的一个。<em>root_dir</em> 是一个目录，它将作为归档文件的根目录；例如，我们通常会在创建归档文件之前用 chdir 命令切换到 <em>root_dir</em>。<em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档文件中所有文件和目录共有的路径前缀。<em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。<em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。<em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logging.Logger" target="_blank" rel="noopener"><code>logging.Logger</code></a> 的实例。<em>verbose</em> 参数已不再使用并进入弃用状态。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。<em>在 3.8 版更改:</em> 现在对于通过 <code>format=&quot;tar&quot;</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p></li><li><p><code>shutil.get_archive_formats</code>()</p><p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_archive_format" target="_blank" rel="noopener"><code>register_archive_format()</code></a> 注册新的格式或为任何现有格式提供你自己的归档器。</p></li><li><p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>为 <em>name</em> 格式注册一个归档器。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name</em>，再加上要归档内容的 <em>base_dir</em> (其默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.make_archive" target="_blank" rel="noopener"><code>make_archive()</code></a> 传入的参数一致)。如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。<em>description</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_archive_formats" target="_blank" rel="noopener"><code>get_archive_formats()</code></a> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p></li><li><p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p><p>从支持的格式中移除归档格式 <em>name</em>。</p></li><li><p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p><p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。<em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。<em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册的其他格式。 如果未提供，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.unpack_archive" target="_blank" rel="noopener"><code>unpack_archive()</code></a> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。<em>在 3.7 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a> 作为 <em>filename</em> 和 <em>extract_dir</em>。</p></li><li><p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。可以提供 <em>description</em> 来描述该格式，它将被 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_unpack_formats" target="_blank" rel="noopener"><code>get_unpack_formats()</code></a> 返回。</p></li><li><p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p><p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p></li><li><p><code>shutil.get_unpack_formats</code>()</p><p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。<em>tar</em>: 未压缩的 tar 文件。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册新的格式或为任何现有格式提供你自己的解包器。</p></li></ul><h3 id="归档程序示例"><a href="#归档程序示例" class="headerlink" title="归档程序示例"></a>归档程序示例</h3><p>在这个示例中，我们创建了一个 gzip 压缩的 tar 归档文件，其中包含用户的 <code>.ssh</code> 目录下的所有文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> shutil <span class="keyword">import</span> make_archive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>archive_name = os.path.expanduser(os.path.join(<span class="string">'~'</span>, <span class="string">'myarchive'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root_dir = os.path.expanduser(os.path.join(<span class="string">'~'</span>, <span class="string">'.ssh'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>make_archive(archive_name, <span class="string">'gztar'</span>, root_dir)</span><br><span class="line"><span class="string">'/Users/tarek/myarchive.tar.gz'</span></span><br></pre></td></tr></table></figure><p>结果归档文件中包含有:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tar -tzvf /Users/tarek/myarchive.tar.gz</span><br><span class="line">drwx------ tarek/staff       <span class="number">0</span> <span class="number">2010</span><span class="number">-02</span><span class="number">-01</span> <span class="number">16</span>:<span class="number">23</span>:<span class="number">40</span> ./</span><br><span class="line">-rw-r--r-- tarek/staff     <span class="number">609</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./authorized_keys</span><br><span class="line">-rwxr-xr-x tarek/staff      <span class="number">65</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./config</span><br><span class="line">-rwx------ tarek/staff     <span class="number">668</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_dsa</span><br><span class="line">-rwxr-xr-x tarek/staff     <span class="number">609</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_dsa.pub</span><br><span class="line">-rw------- tarek/staff    <span class="number">1675</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_rsa</span><br><span class="line">-rw-r--r-- tarek/staff     <span class="number">397</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_rsa.pub</span><br><span class="line">-rw-r--r-- tarek/staff   <span class="number">37192</span> <span class="number">2010</span><span class="number">-02</span><span class="number">-06</span> <span class="number">18</span>:<span class="number">23</span>:<span class="number">10</span> ./known_hosts</span><br></pre></td></tr></table></figure><h2 id="查询输出终端的尺寸"><a href="#查询输出终端的尺寸" class="headerlink" title="查询输出终端的尺寸"></a>查询输出终端的尺寸</h2><ul><li><p><code>shutil.get_terminal_size</code>(<em>fallback=(columns</em>, <em>lines)</em>)</p><p>获取终端窗口的尺寸。</p><p>对于两个维度中的每一个，会分别检查环境变量 <code>COLUMNS</code> 和 <code>LINES</code>。 如果定义了这些变量并且其值为正整数，则将使用这些值。</p><p>如果未定义 <code>COLUMNS</code> 或 <code>LINES</code>，这是通常的情况，则连接到 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.__stdout__" target="_blank" rel="noopener"><code>sys.__stdout__</code></a> 的终端将通过发起调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.get_terminal_size" target="_blank" rel="noopener"><code>os.get_terminal_size()</code></a> 被查询。</p><p>如果由于系统不支持查询，或是由于我们未连接到某个终端而导致查询终端尺寸不成功，则会使用在 <code>fallback</code> 形参中给出的值。 <code>fallback</code> 默认为 <code>(80, 24)</code>，这是许多终端模拟器所使用的默认尺寸。</p><p>返回的值是一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.terminal_size" target="_blank" rel="noopener"><code>os.terminal_size</code></a> 类型的具名元组。</p><p>另请参阅: The Single UNIX Specification, Version 2, <a href="http://pubs.opengroup.org/onlinepubs/7908799/xbd/envvar.html#tag_002_003" target="_blank" rel="noopener">Other Environment Variables</a>.</p><p><em>3.3 新版功能.</em></p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">shutil主要API:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  shutil.copyfileobj(fsrc, fdst[, length=<span class="number">16</span>*<span class="number">1024</span>])    <span class="comment">#copy文件内容到另一个文件，可以copy指定大小的内容</span></span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>  shutil.copyfile(src,dst)   <span class="comment">#copy文件内容，是不是感觉上面的文件复制很麻烦？还需要自己手动用open函数打开文件，在这里就不需要了，事实上，copyfile调用了copyfileobj</span></span><br><span class="line"> </span><br><span class="line"><span class="number">3</span>  shutil.copymode(src,dst)   <span class="comment">#仅copy权限，不更改文件内容，组和用户。</span></span><br><span class="line"> </span><br><span class="line"><span class="number">4</span>  shutil.copystat(src,dst)    <span class="comment">#复制所有的状态信息，包括权限，组，用户，时间等</span></span><br><span class="line"> </span><br><span class="line"><span class="number">5</span>  shutil.copy(src,dst)   <span class="comment">#复制文件的内容以及权限，先copyfile后copymode</span></span><br><span class="line"> </span><br><span class="line"><span class="number">6</span>  shutil.copy2(src,dst)    <span class="comment">#复制文件的内容以及文件的所有状态信息。先copyfile后copystat</span></span><br><span class="line"> </span><br><span class="line"><span class="number">7</span>  shutil.copytree(src, dst, symlinks=<span class="literal">False</span>, ignore=<span class="literal">None</span>, copy_function=copy2,ignore_dangling_symlinks=<span class="literal">False</span>)   <span class="comment">#递归的复制文件内容及状态信息</span></span><br><span class="line"> </span><br><span class="line"><span class="number">8</span>  shutil.rmtree(path, ignore_errors=<span class="literal">False</span>, onerror=<span class="literal">None</span>)   <span class="comment">#递归地删除文件</span></span><br><span class="line"> </span><br><span class="line"><span class="number">9</span>  shutil.move(src, dst)    <span class="comment">#递归的移动文件</span></span><br><span class="line"> </span><br><span class="line"><span class="number">10</span>  make_archive(base_name, format, root_dir=<span class="literal">None</span>, base_dir=<span class="literal">None</span>, verbose=<span class="number">0</span>,dry_run=<span class="number">0</span>, owner=<span class="literal">None</span>, group=<span class="literal">None</span>, logger=<span class="literal">None</span>)  <span class="comment">#压缩打包</span></span><br><span class="line"> </span><br><span class="line">base_name：    压缩打包后的文件名或者路径名</span><br><span class="line"></span><br><span class="line">format：          压缩或者打包格式    <span class="string">"zip"</span>, <span class="string">"tar"</span>, <span class="string">"bztar"</span><span class="keyword">or</span> <span class="string">"gztar"</span></span><br><span class="line"></span><br><span class="line">root_dir :         将哪个目录或者文件打包（也就是源文件）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-shutil-高阶文件操作&quot;&gt;&lt;a href=&quot;#python-标准库-shutil-高阶文件操作&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 shutil 高阶文件操作&quot;&gt;&lt;/a&gt;python 标准库 shutil 高阶文件操作&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200219python3_sheet.png?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="shutil" scheme="https://pinghailinfeng.gitee.io/tags/shutil/"/>
    
  </entry>
  
  <entry>
    <title>using ffmpeg download yizhibo m3u8 type playback video</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/18/using-ffmpeg-download-yizhibo-m3u8-type-playback-video/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/18/using-ffmpeg-download-yizhibo-m3u8-type-playback-video/</id>
    <published>2020-02-18T15:20:04.000Z</published>
    <updated>2020-02-19T01:07:40.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-ffmpe-下载一直播-回放视频"><a href="#使用-ffmpe-下载一直播-回放视频" class="headerlink" title="使用 ffmpe 下载一直播 回放视频"></a>使用 ffmpe 下载一直播 回放视频</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200218_JohnWill.jpeg?raw=true" alt></p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>想下载一直播上的直播视频到本地,但是发现没有直接下载的途径,只能回放。</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>下播后,通过分享链接到qq,得到了在线观看回放的视频地址。F12 发现m3u8格式的链接地址。</p><p>复制该链接地址。</p><p>本地已经搭建了ffmpeg的环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PS &gt; ffmpeg</span><br><span class="line">ffmpeg version git-2019-11-20-d73f062 Copyright (c) 2000-2019 the FFmpeg developers</span><br><span class="line">  built with gcc 9.2.1 (GCC) 20191010</span><br><span class="line">  configuration: --enable-gpl --enable-version3 --enable-sdl2 --enable-fontconfig --enable-gnutls --enable-iconv --enable-libass --enable-libdav1d --enable-libbluray --enable-libfreetype --enable-libmp3lame --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-libopus --enable-libshine --enable-libsnappy</span><br><span class="line">--enable-libsoxr --enable-libtheora --enable-libtwolame --enable-libvpx --enable-libwavpack --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxml2 --enable-libzimg --enable-lzma --enable-zlib --enable-gmp --enable-libvidstab --enable-libvorbis --enable-libvo-amrwbenc --enable-libmysofa --enable-libspeex --enable-libxvid --enable-libaom --enable-libmfx --enable-ffnvcodec --enable-cuvid --enable-d3d11va --enable-nvenc --enable-nvdec --enable-dxva2 --enable-avisynth --enable-libopenmpt --enable-amf</span><br><span class="line">  libavutil      56. 36.100 / 56. 36.100</span><br><span class="line">  libavcodec     58. 62.100 / 58. 62.100</span><br><span class="line">  libavformat    58. 35.100 / 58. 35.100</span><br><span class="line">  libavdevice    58.  9.101 / 58.  9.101</span><br><span class="line">  libavfilter     7. 66.100 /  7. 66.100</span><br><span class="line">  libswscale      5.  6.100 /  5.  6.100</span><br><span class="line">  libswresample   3.  6.100 /  3.  6.100</span><br><span class="line">  libpostproc    55.  6.100 / 55.  6.100</span><br><span class="line">Hyper fast Audio and Video encoder</span><br><span class="line">usage: ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...</span><br><span class="line"></span><br><span class="line">Use -h to get full help or, even better, run 'man ffmpeg'</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>接下来使用 ffmpeg 解析上面网址中含有 m3u8的链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i "https://test.test/test.m3u8" -vcodec copy -acodec copy -absf aac_adtstoasc test.mp4</span><br></pre></td></tr></table></figure><p>经过漫长的等待,终于解析成功。视频可以直接播放。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-ffmpe-下载一直播-回放视频&quot;&gt;&lt;a href=&quot;#使用-ffmpe-下载一直播-回放视频&quot; class=&quot;headerlink&quot; title=&quot;使用 ffmpe 下载一直播 回放视频&quot;&gt;&lt;/a&gt;使用 ffmpe 下载一直播 回放视频&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200218_JohnWill.jpeg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ffmpeg" scheme="https://pinghailinfeng.gitee.io/categories/ffmpeg/"/>
    
    
      <category term="ffmpeg" scheme="https://pinghailinfeng.gitee.io/tags/ffmpeg/"/>
    
      <category term="m3u8" scheme="https://pinghailinfeng.gitee.io/tags/m3u8/"/>
    
  </entry>
  
  <entry>
    <title>python standard library dbm</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/17/python-standard-library-dbm/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/17/python-standard-library-dbm/</id>
    <published>2020-02-17T03:20:01.000Z</published>
    <updated>2020-02-17T13:30:34.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-dbm"><a href="#python-标准库-dbm" class="headerlink" title="python 标准库 dbm"></a>python 标准库 dbm</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200217_haiwang.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>要使整个人生都过得舒适、愉快，这是不可能的，因为人类必须具备一种能应付逆境的态度。</p><p>​                                                                                                                                  ——卢梭</p></blockquote><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/__init__.py" target="_blank" rel="noopener">Lib/dbm/<strong>init</strong>.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm" target="_blank" rel="noopener"><code>dbm</code></a> 是一种泛用接口，针对各种 DBM 数据库 — 包括 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a>。 如果未安装这些模块中的任何一种，则将使用 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 模块中慢速但简单的实现。 还有一个适用于 Oracle Berkeley DB 的 <a href="https://www.jcea.es/programacion/pybsddb.htm" target="_blank" rel="noopener">第三方接口</a>。</p><ul><li><p><em>exception</em> <code>dbm.error</code></p><p>一个元组，其中包含每个受支持的模块可引发的异常，另外还有一个名为 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.error" target="_blank" rel="noopener"><code>dbm.error</code></a> 的特殊异常作为第一项 — 后者最在引发 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.error" target="_blank" rel="noopener"><code>dbm.error</code></a> 时被使用。</p></li><li><p><code>dbm.whichdb</code>(<em>filename</em>)</p><p>此函数会猜测各种简单数据库模块中的哪一个是可用的 — <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 还是 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> — 应该被用来打开给定的文件。返回下列值中的一个：如果文件由于不可读或不存在而无法打开则返回 <code>None</code>；如果文件的格式无法猜测则返回空字符串 (<code>&#39;&#39;</code>)；或是包含所需模块名称的字符串，例如 <code>&#39;dbm.ndbm&#39;</code> 或 <code>&#39;dbm.gnu&#39;</code>。</p></li><li><p><code>dbm.open</code>(<em>file</em>, <em>flag=’r’</em>, <em>mode=0o666</em>)</p><p>打开数据库文件 <em>file</em> 并返回一个相应的对象。如果数据库文件已存在，则使用 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.whichdb" target="_blank" rel="noopener"><code>whichdb()</code></a> 函数来确定其类型和要使用的适当模块；如果文件不存在，则会使用上述可导入模块中的第一个。可选的 <em>flag</em> 参数可以是：’’</p><p>| 值    | 意义                                     |<br>| —– | —————————————- |<br>| <code>&#39;r&#39;</code> | 以只读方式打开现有数据库（默认）         |<br>| <code>&#39;w&#39;</code> | 以读写方式打开现有数据库                 |<br>| <code>&#39;c&#39;</code> | 以读写方式打开数据库，如果不存在则创建它 |<br>| <code>&#39;n&#39;</code> | 始终创建一个新的空数据库，以读写方式打开 |</p><p>  <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.open" target="_blank" rel="noopener"><code>open()</code></a> 所返回的对象支持与字典相同的基本功能；可以存储、获取和删除键及其对应的值，并可使用 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a> 运算符和 <code>keys()</code> 方法，以及 <code>get()</code> 和 <code>setdefault()</code>。</p></li></ul><p><em>在 3.2 版更改:</em> 现在 <code>get()</code> 和 <code>setdefault()</code> 在所有数据库模块中均可用。</p><p><em>在 3.8 版更改:</em> 从只读数据库中删除键将引发数据库模块专属的错误而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。</p><p>键和值总是被存储为字节串。 这意味着当使用字符串时它们会在被存储之前隐式地转换至默认编码格式。</p><p>这些对象也支持在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中使用，当语句结束时将自动关闭它们。</p><p><em>在 3.4 版更改:</em> 向 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.open" target="_blank" rel="noopener"><code>open()</code></a> 所返回的对象添加了上下文管理协议的原生支持。</p><p>以下示例记录了一些主机名和对应的标题，随后将数据库的内容打印出来。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dbm</span><br><span class="line"></span><br><span class="line"><span class="comment"># Open database, creating it if necessary.</span></span><br><span class="line"><span class="keyword">with</span> dbm.open(<span class="string">'cache'</span>, <span class="string">'c'</span>) <span class="keyword">as</span> db:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Record some values</span></span><br><span class="line">    db[<span class="string">b'hello'</span>] = <span class="string">b'there'</span></span><br><span class="line">    db[<span class="string">'www.python.org'</span>] = <span class="string">'Python Website'</span></span><br><span class="line">    db[<span class="string">'www.cnn.com'</span>] = <span class="string">'Cable News Network'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Note that the keys are considered bytes now.</span></span><br><span class="line">    <span class="keyword">assert</span> db[<span class="string">b'www.python.org'</span>] == <span class="string">b'Python Website'</span></span><br><span class="line">    <span class="comment"># Notice how the value is now in bytes.</span></span><br><span class="line">    <span class="keyword">assert</span> db[<span class="string">'www.cnn.com'</span>] == <span class="string">b'Cable News Network'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Often-used methods of the dict interface work too.</span></span><br><span class="line">    print(db.get(<span class="string">'python.org'</span>, <span class="string">b'not present'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Storing a non-string key or value will raise an exception (most</span></span><br><span class="line">    <span class="comment"># likely a TypeError).</span></span><br><span class="line">    db[<span class="string">'www.yahoo.com'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># db is automatically closed when leaving the with statement.</span></span><br></pre></td></tr></table></figure><blockquote><p>参见:模块 <a href="https://docs.python.org/zh-cn/3.8/library/shelve.html#module-shelve" target="_blank" rel="noopener"><code>shelve</code></a></p><p>存储非字符串数据的持久化模块。</p></blockquote><p>以下部分描述了各个单独的子模块。</p><h2 id="dbm-gnu-—-GNU-对-dbm-的重解析"><a href="#dbm-gnu-—-GNU-对-dbm-的重解析" class="headerlink" title="dbm.gnu — GNU 对 dbm 的重解析"></a><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> — GNU 对 dbm 的重解析</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/gnu.py" target="_blank" rel="noopener">Lib/dbm/gnu.py</a></p><hr><p>此模块与 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm" target="_blank" rel="noopener"><code>dbm</code></a> 模块很相似，但是改用 GNU 库 <code>gdbm</code> 来提供某些附加功能。 请注意由 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 与 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 所创建的文件格式是不兼容的。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 模块提供了对 GNU DBM 库的接口。 <code>dbm.gnu.gdbm</code> 对象的行为类似于映射（字典），区别在于其键和值总是会在存储之前被转换为字节串。 打印 <code>gdbm</code> 对象不会打印出键和值，并且 <code>items()</code> 和 <code>values()</code> 等方法也不受支持。</p><ul><li><p><em>exception</em> <code>dbm.gnu.error</code></p><p>针对 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 专属错误例如 I/O 错误引发。 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 的引发则针对一般映射错误例如指定了不正确的键。</p></li><li><p><code>dbm.gnu.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p><p>打开一个 <code>gdbm</code> 数据库并返回 <code>gdbm</code> 对象。 <em>filename</em> 参数为数据库文件名称。</p><p>可选的 <em>flag</em> 参数可以是：</p><p>| 值    | 意义                                     |<br>| —– | —————————————- |<br>| <code>&#39;r&#39;</code> | 以只读方式打开现有数据库（默认）         |<br>| <code>&#39;w&#39;</code> | 以读写方式打开现有数据库                 |<br>| <code>&#39;c&#39;</code> | 以读写方式打开数据库，如果不存在则创建它 |<br>| <code>&#39;n&#39;</code> | 始终创建一个新的空数据库，以读写方式打开 |</p><p>下列附加字符可被添加至旗标以控制数据库的打开方式：</p><p>| 值    | 意义                                         |<br>| —– | ——————————————– |<br>| <code>&#39;f&#39;</code> | 以快速模式打开数据库。写入数据库将不会同步。 |<br>| <code>&#39;s&#39;</code> | 同步模式。这将导致数据库的更改立即写入文件。 |<br>| <code>&#39;u&#39;</code> | 不要锁定数据库。                             |</p><p>不是所有旗标都可用于所有版本的 <code>gdbm</code>。 模块常量 <code>open_flags</code> 为包含受支持旗标字符的字符串。 如果指定了无效的旗标则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.gnu.error" target="_blank" rel="noopener"><code>error</code></a>。</p><p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code>。</p><p>除了与字典类似的方法，<code>gdbm</code> 对象还有以下方法：</p></li><li><p><code>gdbm.firstkey</code>()</p><p>  使用此方法和 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.gnu.gdbm.nextkey" target="_blank" rel="noopener"><code>nextkey()</code></a> 方法可以循环遍历数据库中的每个键。 遍历的顺序是按照 <code>gdbm</code> 的内部哈希值，而不会根据键的值排序。 此方法将返回起始键。</p></li><li><p><code>gdbm.nextkey</code>(<em>key</em>)</p><p>  在遍历中返回 <em>key</em> 之后的的下一个键。 以下代码将打印数据库 <code>db</code> 中的每个键，而不会在内存中创建一个包含所有键的列表:<code>k = db.firstkey() while k != None:     print(k)     k = db.nextkey(k)</code></p></li><li><p><code>gdbm.reorganize</code>()</p><p>  如果你进行了大量删除操作并且想要缩减 <code>gdbm</code> 文件所使用的空间，此例程将可重新组织数据库。 除非使用此重组功能否则 <code>gdbm</code> 对象不会缩减数据库文件大小；在其他情况下，被删除的文件空间将会保留并在添加新的 (键, 值) 对时被重用。</p></li><li><p><code>gdbm.sync</code>()</p><p>  当以快速模式打开数据库时，此方法会将任何未写入数据强制写入磁盘。</p></li><li><p><code>gdbm.close</code>()<a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.gnu.gdbm.close" target="_blank" rel="noopener">¶</a></p><p>  关闭 <code>gdbm</code> 数据库。</p></li></ul><h2 id="dbm-ndbm-—-基于-ndbm-的接口"><a href="#dbm-ndbm-—-基于-ndbm-的接口" class="headerlink" title="dbm.ndbm — 基于 ndbm 的接口"></a><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> — 基于 ndbm 的接口</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/ndbm.py" target="_blank" rel="noopener">Lib/dbm/ndbm.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 模块提供了对 Unix “(n)dbm” 库的接口。 Dbm 对象的行为类似于映射（字典），区别在于其键和值总是被存储为字节串。 打印 <code>dbm</code> 对象不会打印出键和值，并且 <code>items()</code> 和 <code>values()</code> 等方法也不受支持。</p><p>此模块可与 “经典classic” ndbm 接口或 GNU GDBM 兼容接口一同使用。 在 Unix 上，<strong>configure</strong> 脚本将尝试定位适当的头文件来简化此模块的构建。</p><ul><li><p><em>exception</em> <code>dbm.ndbm.error</code></p><p>针对 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 专属错误例如 I/O 错误引发。 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 的引发则针对一般映射错误例如指定了不正确的键。</p></li><li><p><code>dbm.ndbm.library</code></p><p>所使用的 <code>ndbm</code> 实现库的名称。</p></li><li><p><code>dbm.ndbm.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p><p>打开一个 dbm 数据库并返回 <code>ndbm</code> 对象。 <em>filename</em> 参数为数据库文件名称（不带 <code>.dir</code> 或 <code>.pag</code> 扩展名）。可选的 <em>flag</em> 参数必须是下列值之一：值意义<code>&#39;r&#39;</code>以只读方式打开现有数据库（默认）<code>&#39;w&#39;</code>以读写方式打开现有数据库<code>&#39;c&#39;</code>以读写方式打开数据库，如果不存在则创建它<code>&#39;n&#39;</code>始终创建一个新的空数据库，以读写方式打开可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code> (并将被当前的 umask 所修改)。除了与字典类似的方法，<code>ndbm</code> 对象还有以下方法：<code>ndbm.close</code>()关闭 <code>ndbm</code> 数据库。</p></li></ul><h2 id="dbm-dumb-—-便携式-DBM-实现"><a href="#dbm-dumb-—-便携式-DBM-实现" class="headerlink" title="dbm.dumb — 便携式 DBM 实现"></a><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> — 便携式 DBM 实现</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/dumb.py" target="_blank" rel="noopener">Lib/dbm/dumb.py</a></p><blockquote><p>注解:<a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 模块的目的是在更健壮的模块不可用时作为 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm" target="_blank" rel="noopener"><code>dbm</code></a> 模块的最终回退项。 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 不是为高速运行而编写的，也不像其他数据库模块一样被经常使用。</p></blockquote><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 模块提供了一个完全以 Python 编写的持久化字典类接口。 不同于 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 等其他模块，它不需要外部库。 与其他持久化映射一样，它的键和值也总是被存储为字节串。</p><p>该模块定义以下内容：</p><ul><li><p><em>exception</em> <code>dbm.dumb.error</code></p><p>针对 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 专属错误例如 I/O 错误引发。 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 的引发则针对一般映射例如指定了不正确的键。</p></li><li><p><code>dbm.dumb.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p><p>打开一个 <code>dumbdbm</code> 数据库并返回 dumbdbm 对象。 <em>filename</em> 参数为数据库文件的主名称（不带任何特定扩展名）。 创建一个 dumbdbm 数据库时将创建多个带有 <code>.dat</code> 和 <code>.dir</code> 扩展名的文件。可选的 <em>flag</em> 参数可以是：</p><p>| 值    | 意义                                     |<br>| —– | —————————————- |<br>| <code>&#39;r&#39;</code> | 以只读方式打开现有数据库（默认）         |<br>| <code>&#39;w&#39;</code> | 以读写方式打开现有数据库                 |<br>| <code>&#39;c&#39;</code> | 以读写方式打开数据库，如果不存在则创建它 |<br>| <code>&#39;n&#39;</code> | 始终创建一个新的空数据库，以读写方式打开 |</p><p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code> (并将  被当前的 umask 所修改)。</p><p><em>在 3.5 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.dumb.open" target="_blank" rel="noopener"><code>open()</code></a> 在 flag 值为 <code>&#39;n&#39;</code> 时将总是创建一个新的数据库。</p><p><em>在 3.8 版更改:</em> 附带 <code>&#39;r&#39;</code> 旗标打开的数据库现在将是只读的。 附带 <code>&#39;r&#39;</code> 和 <code>&#39;w&#39;</code> 旗标的打开操作不会再创建数据库。</p><p>除了 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableMapping" target="_blank" rel="noopener"><code>collections.abc.MutableMapping</code></a> 类所提供的方法，<code>dumbdbm</code> 对象还提供了以下方法：</p></li><li><p><code>dumbdbm.sync</code>()</p><p>  同步磁盘上的目录和数据文件。 此方法会由 <code>Shelve.sync()</code> 方法来调用。</p></li><li><p><code>dumbdbm.close</code>()</p><p>  关闭 <code>dumbdbm</code> 数据库。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-dbm&quot;&gt;&lt;a href=&quot;#python-标准库-dbm&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 dbm&quot;&gt;&lt;/a&gt;python 标准库 dbm&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200217_haiwang.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="dbm" scheme="https://pinghailinfeng.gitee.io/tags/dbm/"/>
    
  </entry>
  
  <entry>
    <title>python standard library marshal</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/16/python-standard-library-marshal/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/16/python-standard-library-marshal/</id>
    <published>2020-02-16T01:24:24.000Z</published>
    <updated>2020-02-17T03:27:23.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="marshal-—-内部-Python-对象序列化"><a href="#marshal-—-内部-Python-对象序列化" class="headerlink" title="marshal — 内部 Python 对象序列化"></a><code>marshal</code> — 内部 Python 对象序列化</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200216_pijitailai.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词：</p><p>否极泰来( pi ji tai lai):</p><p> 否，读如痞(pǐ)又作“否极终泰”、“否去泰来”。天地相交，因而安泰。天与地不相交，叫做否。在这种情况下，君子应该收敛自己的才华，以避免小人陷害；不可追求荣誉富贵，以避免小人嫉妒。闭塞到了极点，则转向通泰。人们将这些观点概括为否极泰来或否极终泰。原指事物发展到一定程度，就要转化到它的对立面。后常以此形容情况从坏变好。</p><p>【出典】：</p><p>  《易·泰》：“天地交，泰。”《易·否》：“天地不交，否；君子以俭德辟难，不可荣以禄。”《易·杂卦》：“否泰反其类也。”</p><p>【例句】：</p><p>  《吴越春秋·句践入臣外传》：“时过于期，否终则泰。” 唐·白居易《遣怀诗》：“乐往必悲生，泰来犹否极。” 唐·韦庄《湘中作》：“否去泰来终可待。”</p><p>【英文】</p><p> after a storm comes a calm </p><p>【反义词】</p><p>乐极生悲  after joy comes sadness </p></blockquote><p>此模块包含一此能以二进制格式来读写 Python 值的函数。 这种格式是 Python 专属的，但是独立于特定的机器架构（即你可以在一台 PC 上写入某个 Python 值，将文件传到一台 Sun 上并在那里读取它）。 这种格式的细节有意不带文档说明；它可能在不同 Python 版本中发生改变（但这种情况极少发生）。 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#id2" target="_blank" rel="noopener">1</a></p><p>这不是一个通用的“持久化”模块。 对于通用的持久化以及通过 RPC 调用传递 Python 对象，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/shelve.html#module-shelve" target="_blank" rel="noopener"><code>shelve</code></a> 等模块。 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#module-marshal" target="_blank" rel="noopener"><code>marshal</code></a> 模块主要是为了支持读写 <code>.pyc</code> 文件形式“伪编译”代码的 Python 模块。 因此，Python 维护者保留在必要时以不向下兼容的方式修改 marshal 格式的权利。 如果你要序列化和反序列化 Python 对象，请改用 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块 – 其执行效率相当，版本独立性有保证，并且 pickle 还支持比 marshal 更多样的对象类型。</p><p>警告<br><a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#module-marshal" target="_blank" rel="noopener"><code>marshal</code></a> 模块对于错误或恶意构建的数据来说是不安全的。 永远不要 unmarshal 来自不受信任的或未经验证的来源的数据。</p><p>不是所有 Python 对象类型都受支持；一般来说，此模块只能写入和读取不依赖于特定 Python 调用的对象。 下列类型是受支持的：布尔值、整数、浮点数、复数、字符串、字节串、字节数组、元组、列表、集合、冻结集合、字典和代码对象，需要了解的一点是元组、列表、集合、冻结集合和字典只在其所包含的值也是这些值时才受支持。 单例对象 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#Ellipsis" target="_blank" rel="noopener"><code>Ellipsis</code></a> and <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 也可以被 marshal 和 unmarshal。 对于 <em>version</em> 低于 3 的格式，递归列表、集合和字典无法被写入（见下文）。</p><p>有些函数可以读/写文件，还有些函数可以操作字节类对象。</p><p>这个模块定义了以下函数：</p><ul><li><p><code>marshal.dump</code>(<em>value</em>, <em>file</em>[, <em>version</em>])</p><p>向打开的文件写入值。 值必须为受支持的类型。 文件必须为可写的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a>。如果值具有（或所包含的对象具有）不受支持的类型，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> — 但是将向文件写入垃圾数据。 对象也将不能正确地通过 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#marshal.load" target="_blank" rel="noopener"><code>load()</code></a> 重新读取。<em>version</em> 参数指明 <code>dump</code> 应当使用的数据格式（见下文）。</p></li><li><p><code>marshal.load</code>(<em>file</em>)</p><p>从打开的文件读取一个值并返回。 如果读不到有效的值（例如由于数据为不同 Python 版本的不兼容 marshal 格式），则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EOFError" target="_blank" rel="noopener"><code>EOFError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 文件必须为可读的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a>。注解 如果通过 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#marshal.dump" target="_blank" rel="noopener"><code>dump()</code></a> marshal 了一个包含不受支持类型的对象，<a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#marshal.load" target="_blank" rel="noopener"><code>load()</code></a> 将为不可 marshal 的类型替换 <code>None</code>。</p></li><li><p><code>marshal.dumps</code>(<em>value</em>[, <em>version</em>])</p><p>返回将通过 <code>dump(value, file)</code> 被写入一个文件的字节串对象。 值必须属于受支持的类型。 如果值属于（或包含的对象属于）不受支持的类型则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。<em>version</em> 参数指明 <code>dumps</code> 应当使用的数据类型（见下文）。</p></li><li><p><code>marshal.loads</code>(<em>bytes</em>)</p><p>将 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 转换为一个值。 如果找不到有效的值，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EOFError" target="_blank" rel="noopener"><code>EOFError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 输入的额外字节串会被忽略。</p></li></ul><p>此外，还定义了以下常量：</p><ul><li><p><code>marshal.version</code></p><p>指明模块所使用的格式。 第 0 版为历史格式，第 1 版为共享固化的字符串，第 2 版对浮点数使用二进制格式。 第 3 版添加了对于对象实例化和递归的支持。 目前使用的为第 4 版。</p></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> marshal</span><br><span class="line">data1 = [<span class="string">'abc'</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="string">'jb51'</span>]  <span class="comment">#几个测试数据</span></span><br><span class="line">data2 = &#123;<span class="number">1</span>:<span class="string">'aaa'</span>,<span class="string">"b"</span>:<span class="string">'dad'</span>&#125;</span><br><span class="line">data3 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">output_file = open(<span class="string">"a.txt"</span>,<span class="string">'wb'</span>)<span class="comment">#把这些数据序列化到文件中，注：文件必须以二进制模式打开</span></span><br><span class="line">marshal.dump(data1,output_file)</span><br><span class="line">marshal.dump(data2,output_file)</span><br><span class="line">marshal.dump(data3,output_file)</span><br><span class="line">output_file.close()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">input_file = open(<span class="string">'a.txt'</span>,<span class="string">'rb'</span>)<span class="comment">#从文件中读取序列化的数据</span></span><br><span class="line"><span class="comment">#data1 = []</span></span><br><span class="line">data1 = marshal.load(input_file)</span><br><span class="line">data2 = marshal.load(input_file)</span><br><span class="line">data3 = marshal.load(input_file)</span><br><span class="line"><span class="keyword">print</span> data1<span class="comment">#给同志们打印出结果看看</span></span><br><span class="line"><span class="keyword">print</span> data2</span><br><span class="line"><span class="keyword">print</span> data3</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">outstring = marshal.dumps(data1)<span class="comment">#marshal.dumps()返回是一个字节串，该字节串用于写入文件</span></span><br><span class="line">open(<span class="string">'out.txt'</span>,<span class="string">'wb'</span>).write(outstring)</span><br><span class="line"> </span><br><span class="line">file_data = open(<span class="string">'out.txt'</span>,<span class="string">'rb'</span>).read()</span><br><span class="line">real_data = marshal.loads(file_data)</span><br><span class="line">print(real_data)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;marshal-—-内部-Python-对象序列化&quot;&gt;&lt;a href=&quot;#marshal-—-内部-Python-对象序列化&quot; class=&quot;headerlink&quot; title=&quot;marshal — 内部 Python 对象序列化&quot;&gt;&lt;/a&gt;&lt;code&gt;marshal&lt;/code&gt; — 内部 Python 对象序列化&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200216_pijitailai.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python standard library os.path</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/15/python-standard-library-os-path/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/15/python-standard-library-os-path/</id>
    <published>2020-02-14T23:50:49.000Z</published>
    <updated>2020-02-17T13:18:03.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-os-path"><a href="#python-标准库-os-path" class="headerlink" title="python 标准库 os.path"></a>python 标准库 os.path</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200215_nixingzhe.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词</p><p> retrograde  [ˈrɛtrəɡreɪd] </p><p>v   directed or moving backwards. </p><p>n retrograder 逆行者</p><ol><li><p>倒行；不按正常方向行进。《孟子·滕文公下》：“当 尧 之时，水<a href="https://cidian.911cha.com/MjA1MXc=.html" target="_blank" rel="noopener">逆行</a>，氾滥於中国。”《史记·孝景本纪》：“彗星出东北。秋， 衡山 雨雹，大者五寸，深者二尺。荧惑<a href="https://cidian.911cha.com/MjA1MXc=.html" target="_blank" rel="noopener">逆行</a>，守北辰。”《后汉书·杨震传》：“ 丰 等闻，惶怖，会太史言星变<a href="https://cidian.911cha.com/MjA1MXc=.html" target="_blank" rel="noopener">逆行</a>，遂共譖 震 。”</p></li><li><p>指逆流而行。 </p></li></ol></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/posixpath.py" target="_blank" rel="noopener">Lib/posixpath.py</a> （用于 POSIX）和 <a href="https://github.com/python/cpython/tree/3.8/Lib/ntpath.py" target="_blank" rel="noopener">Lib/ntpath.py</a> （用于 Windows NT）</p><hr><p>该模块在路径名上实现了一些有用的功能：如需读取或写入文件，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> ；有关访问文件系统的信息，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块。路径参数可以字符串或字节形式传递。我们鼓励应用程序将文件名表示为（Unicode）字符串。不幸的是，某些文件名在Unix上可能无法用字符串表示，因此在Unix上平台上需要支持任意文件名的应用程序，应使用字节对象来表示路径名。反之亦然，在Windows平台上仅使用字节对象，不能表示的所有文件名（以标准 <code>mbcs</code> 编码），因此Windows应用程序应使用字符串对象来访问所有文件。</p><p>与unix shell不同，Python不执行任何 <em>自动</em> 路径扩展。当应用程序需要类似shell的路径扩展时，可以显式调用诸如 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.expanduser" target="_blank" rel="noopener"><code>expanduser()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.expandvars" target="_blank" rel="noopener"><code>expandvars()</code></a> 之类的函数。 （另请参见 <a href="https://docs.python.org/zh-cn/3.8/library/glob.html#module-glob" target="_blank" rel="noopener"><code>glob</code></a> 模块。）</p><blockquote><p>参见 <a href="https://docs.python.org/zh-cn/3.8/library/pathlib.html#module-pathlib" target="_blank" rel="noopener"><code>pathlib</code></a> 模块提供高级路径对象。</p></blockquote><blockquote><p>所有这些函数都仅接受字节或字符串对象作为其参数。如果返回路径或文件名，则结果是相同类型的对象。</p></blockquote><blockquote><p>由于不同的操作系统具有不同的路径名称约定，因此标准库中有此模块的几个版本。<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 模块始终是适合 Python 运行的操作系统的路径模块，因此可用于本地路径。但是，如果操作的路径 <em>总是</em> 以一种不同的格式显示，那么也可以分别导入和使用各个模块。它们都具有相同的接口：</p><ul><li><code>posixpath</code> 用于Unix 样式的路径</li><li><code>ntpath</code> 用于 Windows 路径</li></ul></blockquote><p><em>在 3.8 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>exists()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.lexists" target="_blank" rel="noopener"><code>lexists()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isdir" target="_blank" rel="noopener"><code>isdir()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isfile" target="_blank" rel="noopener"><code>isfile()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>islink()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.ismount" target="_blank" rel="noopener"><code>ismount()</code></a> 现在遇到系统层面上不可表示的字符或字节的路径时，会返回 <code>False</code>，而不是抛出异常。</p><ul><li><p><code>os.path.abspath</code>(<em>path</em>)</p><p>返回路径 <em>path</em> 的绝对路径（标准化的）。在大多数平台上，这等同于用 <code>normpath(join(os.getcwd(), path))</code> 的方式调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.normpath" target="_blank" rel="noopener"><code>normpath()</code></a> 函数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.basename</code>(<em>path</em>)</p><p>返回路径 <em>path</em> 的基本名称。这是将 <em>path</em> 传入函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.split" target="_blank" rel="noopener"><code>split()</code></a> 之后，返回的一对值中的第二个元素。请注意，此函数的结果与Unix <strong>basename</strong> 程序不同。<strong>basename</strong> 在 <code>&#39;/foo/bar/&#39;</code> 上返回 <code>&#39;bar&#39;</code>，而 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.basename" target="_blank" rel="noopener"><code>basename()</code></a> 函数返回一个空字符串 (<code>&#39;&#39;</code>)。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.commonpath</code>(<em>paths</em>)</p><p>接受包含多个路径的序列 <em>paths</em>，返回 <em>paths</em> 的最长公共子路径。如果 <em>paths</em> 同时包含绝对路径和相对路径，或 <em>paths</em> 在不同的驱动器上，或 <em>paths</em> 为空，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。与 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.commonprefix" target="_blank" rel="noopener"><code>commonprefix()</code></a> 不同，本方法返回有效路径。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>3.5 新版功能.**在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 序列。</p></li><li><p><code>os.path.commonprefix</code>(<em>list</em>)</p><p>接受包含多个路径的 <em>列表</em>，返回所有路径的最长公共前缀（逐字符比较）。如果 <em>列表</em> 为空，则返回空字符串 (<code>&#39;&#39;</code>)。</p><p>此函数是逐字符比较，因此可能返回无效路径。要获取有效路径，参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.commonpath" target="_blank" rel="noopener"><code>commonpath()</code></a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.commonprefix([<span class="string">'/usr/lib'</span>, <span class="string">'/usr/local/lib'</span>])</span><br><span class="line"><span class="string">'/usr/l'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.commonpath([<span class="string">'/usr/lib'</span>, <span class="string">'/usr/local/lib'</span>])</span><br><span class="line"><span class="string">'/usr'</span></span><br></pre></td></tr></table></figure><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.dirname</code>(<em>path</em>)</p><p>返回路径 <em>path</em> 的目录名称。这是将 <em>path</em> 传入函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.split" target="_blank" rel="noopener"><code>split()</code></a> 之后，返回的一对值中的第一个元素。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.exists</code>(<em>path</em>)</p><p>如果 <em>path</em> 指向一个已存在的路径或已打开的文件描述符，返回 <code>True</code>。对于失效的符号链接，返回 <code>False</code>。在某些平台上，如果使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 查询到目标文件没有执行权限，即使 <em>path</em> 确实存在，本函数也可能返回 <code>False</code>。<em>在 3.3 版更改:</em> <em>path</em> 现在可以是一个整数：如果该整数是一个已打开的文件描述符，返回 <code>True</code>，否则返回 <code>False</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.lexists</code>(<em>path</em>)</p><p>如果 <em>path</em> 指向一个已存在的路径，返回 <code>True</code>。对于失效的符号链接，也返回 <code>True</code>。在缺失 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>os.lstat()</code></a> 的平台上等同于 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>exists()</code></a>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.expanduser</code>(<em>path</em>)</p><p>在 Unix 和 Windows 上，将参数中开头部分的 <code>~</code> 或 <code>~user</code> 替换为当前 <em>用户</em> 的家目录并返回。在 Unix 上，开头的 <code>~</code> 会被环境变量 <code>HOME</code> 代替，如果变量未设置，则通过内置模块 <a href="https://docs.python.org/zh-cn/3.8/library/pwd.html#module-pwd" target="_blank" rel="noopener"><code>pwd</code></a> 在 password 目录中查找当前用户的主目录。以 <code>~user</code> 开头则直接在 password 目录中查找。在 Windows 上，如果设置了 <code>USERPROFILE</code>，就使用这个变量，否则会将 <code>HOMEPATH</code> 和 <code>HOMEDRIVE</code> 结合在一起使用。以 <code>~user</code> 开头则将上述方法生成路径的最后一截目录替换成 user。如果展开路径失败，或者路径不是以波浪号开头，则路径将保持不变。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>在 3.8 版更改:</em> Windows 不再使用 <code>HOME</code>。</p></li><li><p><code>os.path.expandvars</code>(<em>path</em>)</p><p>输入带有环境变量的路径作为参数，返回展开变量以后的路径。<code>$name</code> 或 <code>${name}</code> 形式的子字符串被环境变量 <em>name</em> 的值替换。格式错误的变量名称和对不存在变量的引用保持不变。在 Windows 上，除了 <code>$name</code> 和 <code>${name}</code> 外，还可以展开 <code>%name%</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.getatime</code>(<em>path</em>)</p><p>返回 <em>path</em> 的最后访问时间。返回值是一个浮点数，为纪元秒数（参见 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块）。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p></li><li><p><code>os.path.getmtime</code>(<em>path</em>)</p><p>返回 <em>path</em> 的最后修改时间。返回值是一个浮点数，为纪元秒数（参见 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块）。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.getctime</code>(<em>path</em>)</p><p>返回 <em>path</em> 在系统中的 ctime，在有些系统（比如 Unix）上，它是元数据的最后修改时间，其他系统（比如 Windows）上，它是 <em>path</em> 的创建时间。返回值是一个数，为纪元秒数（参见 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块）。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.getsize</code>(<em>path</em>)</p><p>返回 <em>path</em> 的大小，以字节为单位。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.isabs</code>(<em>path</em>)</p><p>如果 <em>path</em> 是一个绝对路径，则返回 <code>True</code>。在 Unix 上，它就是以斜杠开头，而在 Windows 上，它可以是去掉驱动器号后以斜杠（或反斜杠）开头。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.isfile</code>(<em>path</em>)</p><p>如果 <em>path</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>现有的</code></a> 常规文件，则返回 <code>True</code>。本方法会跟踪符号链接，因此，对于同一路径，<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>islink()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isfile" target="_blank" rel="noopener"><code>isfile()</code></a> 都可能为 <code>True</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.isdir</code>(<em>path</em>)</p><p>如果 <em>path</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>现有的</code></a> 目录，则返回 <code>True</code>。本方法会跟踪符号链接，因此，对于同一路径，<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>islink()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isdir" target="_blank" rel="noopener"><code>isdir()</code></a> 都可能为 <code>True</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.islink</code>(<em>path</em>)</p><p>如果 <em>path</em> 指向的 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>现有</code></a> 目录条目是一个符号链接，则返回 <code>True</code>。如果 Python 运行时不支持符号链接，则总是返回 <code>False</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.ismount</code>(<em>path</em>)</p><p>如果路径 <em>path</em> 是 <em>挂载点</em> （文件系统中挂载其他文件系统的点），则返回 <code>True</code>。在 POSIX 上，该函数检查 <em>path</em> 的父目录 <code>*path*/..</code> 是否在与 <em>path</em> 不同的设备上，或者 <code>*path*/..</code> 和 <em>path</em> 是否指向同一设备上的同一 inode（这一检测挂载点的方法适用于所有 Unix 和 POSIX 变体）。本方法不能可靠地检测同一文件系统上的绑定挂载 (bind mount)。在 Windows 上，盘符和共享 UNC 始终是挂载点，对于任何其他路径，将调用 <code>GetVolumePathName</code> 来查看它是否与输入的路径不同。<em>3.4 新版功能:</em> 支持在 Windows 上检测非根挂载点。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.join</code>(<em>path</em>, *<em>paths</em>)</p><p>合理地拼接一个或多个路径部分。返回值是 <em>path</em> 和 *<em>paths</em> 所有值的连接，每个非空部分后面都紧跟一个目录分隔符 (<code>os.sep</code>)，除了最后一部分。这意味着如果最后一部分为空，则结果将以分隔符结尾。如果参数中某个部分是绝对路径，则绝对路径前的路径都将被丢弃，并从绝对路径部分开始连接。在 Windows 上，遇到绝对路径部分（例如 <code>r&#39;\foo&#39;</code>）时，不会重置盘符。如果某部分路径包含盘符，则会丢弃所有先前的部分，并重置盘符。请注意，由于每个驱动器都有一个“当前目录”，所以 <code>os.path.join(&quot;c:&quot;, &quot;foo&quot;)</code> 表示驱动器 <code>C:</code> 上当前目录的相对路径 (<code>c:foo</code>)，而不是 <code>c:\foo</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 用于 <em>path</em> 和 <em>paths</em> 。</p></li><li><p><code>os.path.normcase</code>(<em>path</em>)</p><p>规范路径的大小写。在 Windows 上，将路径中的所有字符都转换为小写，并将正斜杠转换为反斜杠。在其他操作系统上返回原路径。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.normpath</code>(<em>path</em>)</p><p>通过折叠多余的分隔符和对上级目录的引用来标准化路径名，所以 <code>A//B</code>、<code>A/B/</code>、<code>A/./B</code> 和 <code>A/foo/../B</code> 都会转换成 <code>A/B</code>。这个字符串操作可能会改变带有符号链接的路径的含义。在 Windows 上，本方法将正斜杠转换为反斜杠。要规范大小写，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.normcase" target="_blank" rel="noopener"><code>normcase()</code></a>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.realpath</code>(<em>path</em>)</p><p>返回指定文件的规范路径，消除路径中存在的任何符号链接（如果操作系统支持）。注解 当发生符号链接循环时，返回的路径将是该循环的某个组成部分，但不能保证是哪个部分。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>在 3.8 版更改:</em> 在 Windows 上现在可以正确解析符号链接和交接点 (junction point)。</p></li><li><p><code>os.path.relpath</code>(<em>path</em>, <em>start=os.curdir</em>)</p><p>返回从当前目录或 <em>start</em> 目录（可选）到达 <em>path</em> 之间要经过的相对路径。这仅仅是对路径的计算，不会访问文件系统来确认 <em>path</em> 或 <em>start</em> 的存在性或属性。<em>start</em> 默认为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.samefile</code>(<em>path1</em>, <em>path2</em>)</p><p>如果两个路径都指向相同的文件或目录，则返回 <code>True</code>。这由设备号和 inode 号确定，在任一路径上调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 失败则抛出异常。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加了 Windows 支持。<em>在 3.4 版更改:</em> Windows现在使用与其他所有平台相同的实现。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.sameopenfile</code>(<em>fp1</em>, <em>fp2</em>)</p><p>如果文件描述符 <em>fp1</em> 和 <em>fp2</em> 指向相同文件，则返回 <code>True</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加了 Windows 支持。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.samestat</code>(<em>stat1</em>, <em>stat2</em>)</p><p>如果 stat 元组 <em>stat1</em> 和 <em>stat2</em> 指向相同文件，则返回 <code>True</code>。这些 stat 元组可能是由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fstat" target="_blank" rel="noopener"><code>os.fstat()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>os.lstat()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 返回的。本函数实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.samefile" target="_blank" rel="noopener"><code>samefile()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.sameopenfile" target="_blank" rel="noopener"><code>sameopenfile()</code></a> 底层所使用的比较过程。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.4 版更改:</em> 添加了 Windows 支持。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.split</code>(<em>path</em>)</p><p>将路径 <em>path</em> 拆分为一对，即 <code>(head, tail)</code>，其中，<em>tail</em> 是路径的最后一部分，而 <em>head</em> 里是除最后部分外的所有内容。<em>tail</em> 部分不会包含斜杠，如果 <em>path</em> 以斜杠结尾，则 <em>tail</em> 将为空。如果 <em>path</em> 中没有斜杠，<em>head</em> 将为空。如果 <em>path</em> 为空，则 <em>head</em> 和 <em>tail</em> 均为空。<em>head</em> 末尾的斜杠会被去掉，除非它是根目录（即它仅包含一个或多个斜杠）。在所有情况下，<code>join(head, tail)</code> 指向的位置都与 <em>path</em> 相同（但字符串可能不同）。另请参见函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.dirname" target="_blank" rel="noopener"><code>dirname()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.basename" target="_blank" rel="noopener"><code>basename()</code></a>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.splitdrive</code>(<em>path</em>)</p><p>将路径 <em>path</em> 拆分为一对，即 <code>(drive, tail)</code>，其中 <em>drive</em> 是挂载点或空字符串。在没有驱动器概念的系统上，<em>drive</em> 将始终为空字符串。在所有情况下，<code>drive + tail</code> 都与 <em>path</em> 相同。在 Windows 上，本方法将路径拆分为驱动器/UNC 根节点和相对路径。如果路径 path 包含盘符，则 drive 将包含冒号及冒号前面的所有内容。例如 <code>splitdrive(&quot;c:/dir&quot;)</code> 返回 <code>(&quot;c:&quot;, &quot;/dir&quot;)</code>。如果 path 是一个 UNC 路径，则 drive 将包含主机名和共享点，但不包括第四个分隔符。例如 <code>splitdrive(&quot;//host/computer/dir&quot;)</code> 返回 <code>(&quot;//host/computer&quot;, &quot;/dir&quot;)</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.splitext</code>(<em>path</em>)</p><p>将路径 <em>path</em> 拆分为一对，即 <code>(root, ext)</code>，使 <code>root + ext == path</code>，其中 <em>ext</em> 为空或以英文句点开头，且最多包含一个句点。路径前的句点将被忽略，例如 <code>splitext(&#39;.cshrc&#39;)</code> 返回 <code>(&#39;.cshrc&#39;, &#39;&#39;)</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.supports_unicode_filenames</code></p><p>如果（在文件系统限制下）允许将任意 Unicode 字符串用作文件名，则为 <code>True</code>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-os-path&quot;&gt;&lt;a href=&quot;#python-标准库-os-path&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 os.path&quot;&gt;&lt;/a&gt;python 标准库 os.path&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200215_nixingzhe.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="os.path" scheme="https://pinghailinfeng.gitee.io/tags/os-path/"/>
    
  </entry>
  
  <entry>
    <title>python standard library linecache</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/14/python-standard-library-linecache/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/14/python-standard-library-linecache/</id>
    <published>2020-02-14T12:20:03.000Z</published>
    <updated>2020-02-17T03:27:23.923Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200214_valentines.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>情人节快乐，愿有情人终成眷属!</p></blockquote><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/linecache.py" target="_blank" rel="noopener">Lib/linecache.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#module-linecache" target="_blank" rel="noopener"><code>linecache</code></a> 模块允许从一个 Python 源文件中获取任意的行，并会尝试使用缓存进行内部优化，常应用于从单个文件读取多行的场合。 此模块被 <a href="https://docs.python.org/zh-cn/3.8/library/traceback.html#module-traceback" target="_blank" rel="noopener"><code>traceback</code></a> 模块用来提取源码行以便包含在格式化的回溯中。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/tokenize.html#tokenize.open" target="_blank" rel="noopener"><code>tokenize.open()</code></a> 函数被用于打开文件。 此函数使用 <a href="https://docs.python.org/zh-cn/3.8/library/tokenize.html#tokenize.detect_encoding" target="_blank" rel="noopener"><code>tokenize.detect_encoding()</code></a> 来获取文件的编码格式；如果未指明编码格式，则默认编码为 UTF-8。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#module-linecache" target="_blank" rel="noopener"><code>linecache</code></a> 模块定义了下列函数：</p><ul><li><p><code>linecache.getline</code>(<em>filename</em>, <em>lineno</em>, <em>module_globals=None</em>)</p><p>从名为 <em>filename</em> 的文件中获取 <em>lineno</em> 行，此函数绝不会引发异常 — 出现错误时它将返回 <code>&#39;&#39;</code> (所有找到的行都将包含换行符作为结束)。如果找不到名为 <em>filename</em> 的文件，此函数会先在 <em>module_globals</em> 中检查 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a> <code>__loader__</code>。 如果存在这样的加载器并且它定义了 <code>get_source</code> 方法，则由该方法来确定源行 (如果 <code>get_source()</code> 返回 <code>None</code>，则该函数返回 <code>&#39;&#39;</code>)。 最后，如果 <em>filename</em> 是一个相对路径文件名，则它会在模块搜索路径 <code>sys.path</code> 中按条目的相对位置进行查找。</p></li><li><p><code>linecache.clearcache</code>()</p><p>清空缓存。 如果你不再需要之前使用 <a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#linecache.getline" target="_blank" rel="noopener"><code>getline()</code></a> 从文件读取的行即可使用此函数。</p></li><li><p><code>linecache.checkcache</code>(<em>filename=None</em>)</p><p>检查缓存有效性。 如果缓存中的文件在磁盘上发生了改变，而你需要更新后的版本即可使用此函数。 如果省略了 <em>filename</em>，它会检查缓存中的所有条目。</p></li><li><p><code>linecache.lazycache</code>(<em>filename</em>, <em>module_globals</em>)</p><p>捕获有关某个非基于文件的模块的足够细节信息，以允许稍后再通过 <a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#linecache.getline" target="_blank" rel="noopener"><code>getline()</code></a> 来获取其中的行，即使当稍后调用时 <em>module_globals</em> 为 <code>None</code>。 这可以避免在实际需要读取行之前执行 I/O，也不必始终保持模块全局变量。<em>3.5 新版功能.</em></p></li></ul><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> linecache</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>linecache.getline(linecache.__file__, <span class="number">8</span>)</span><br><span class="line"><span class="string">'import sys\n'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> linecache</span><br><span class="line"><span class="comment">## 获取指定前四条数据</span></span><br><span class="line">a = linecache.getlines(<span class="string">'aa.txt'</span>)[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">## 获取第四条数据</span></span><br><span class="line">a = linecache.getline(<span class="string">'aa.txt'</span>,<span class="number">4</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200214_valentines.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="linecache" scheme="https://pinghailinfeng.gitee.io/tags/linecache/"/>
    
  </entry>
  
  <entry>
    <title>python standard library tempfile</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/13/python-standard-library-tempfile/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/13/python-standard-library-tempfile/</id>
    <published>2020-02-13T09:17:49.000Z</published>
    <updated>2020-02-17T03:27:23.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-tempfile"><a href="#python-标准库-tempfile" class="headerlink" title="python 标准库 tempfile"></a>python 标准库 tempfile</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200213_car.jpeg?raw=true" alt></p><a id="more"></a><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/tempfile.py" target="_blank" rel="noopener">Lib/tempfile.py</a></p><hr><p>该模块用于创建临时文件和目录，它可以跨平台使用。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.NamedTemporaryFile" target="_blank" rel="noopener"><code>NamedTemporaryFile</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryDirectory" target="_blank" rel="noopener"><code>TemporaryDirectory</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.SpooledTemporaryFile" target="_blank" rel="noopener"><code>SpooledTemporaryFile</code></a> 是带有自动清理功能的高级接口，可用作上下文管理器。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 是低级函数，使用完毕需手动清理。</p><p>所有由用户调用的函数和构造函数都带有参数，这些参数可以设置临时文件和临时目录的路径和名称。该模块生成的文件名包括一串随机字符，在公共的临时目录中，这些字符可以让创建文件更加安全。为了保持向后兼容性，参数的顺序有些奇怪。所以为了代码清晰，建议使用关键字参数。</p><p>这个模块定义了以下内容供用户调用：</p><ul><li><p><code>tempfile.TemporaryFile</code>(<em>mode=’w+b’</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>**, </em>errors=None*)</p><p>返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-like-object" target="_blank" rel="noopener">file-like object</a> （文件类对象）作为临时存储区域。创建该文件使用了与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 相同的安全规则。它将在关闭后立即销毁（包括垃圾回收机制关闭该对象时）。在 Unix 下，该文件在目录中的条目根本不创建，或者创建文件后立即就被删除了，其他平台不支持此功能。您的代码不应依赖使用此功能创建的临时文件名称，因为它在文件系统中的名称可能是可见的，也可能是不可见的。</p><p>生成的对象可以用作上下文管理器（参见 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile-examples" target="_blank" rel="noopener">示例</a>）。完成上下文或销毁临时文件对象后，临时文件将从文件系统中删除。</p><p><em>mode</em> 参数默认值为 <code>&#39;w+b&#39;</code>，所以创建的文件不用关闭，就可以读取或写入。因为用的是二进制模式，所以无论存的是什么数据，它在所有平台上都表现一致。<em>buffering</em>、<em>encoding</em>、<em>errors</em> 和 <em>newline</em> 的含义与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 中的相同。</p><p>参数 <em>dir</em>、<em>prefix</em> 和 <em>suffix</em> 的含义和默认值都与它们在 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 中的相同。</p><p>在 POSIX 平台上，它返回的对象是真实的文件对象。在其他平台上，它是一个文件类对象 (file-like object)，它的 <code>file</code> 属性是底层的真实文件对象。</p><p>如果可用，则使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_TMPFILE" target="_blank" rel="noopener"><code>os.O_TMPFILE</code></a> 标志（仅限于 Linux，需要 3.11 及更高版本的内核）。</p><p>引发一个 <code>tempfile.mkstemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>在 3.5 版更改:</em> 如果可用，现在用的是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_TMPFILE" target="_blank" rel="noopener"><code>os.O_TMPFILE</code></a> 标志。</p><p><em>在 3.8 版更改:</em> 添加了 <em>errors</em> 参数。</p></li><li><p><code>tempfile.NamedTemporaryFile</code>(<em>mode=’w+b’</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>delete=True</em>, <em>**, </em>errors=None*) </p><p>此函数执行的操作与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 完全相同，但确保了该临时文件在文件系统中具有可见的名称（在 Unix 上表现为目录条目不取消链接）。从返回的文件类对象的 <code>name</code> 属性中可以检索到文件名。在临时文件仍打开时，是否允许用文件名第二次打开文件，在各个平台上是不同的（在 Unix 上可以，但在 Windows NT 或更高版本上不行）。如果 <em>delete</em> 为 true（默认值），则文件会在关闭后立即被删除。该函数返回的对象始终是文件类对象 (file-like object)，它的 <code>file</code> 属性是底层的真实文件对象。文件类对象可以像普通文件一样在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中使用。</p><p>引发一个 <code>tempfile.mkstemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>在 3.8 版更改:</em> 添加了 <em>errors</em> 参数。</p></li><li><p><code>tempfile.SpooledTemporaryFile</code>(<em>max_size=0</em>, <em>mode=’w+b’</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>**, </em>errors=None*) </p><p>此函数执行的操作与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 完全相同，但会将数据缓存在内存中，直到文件大小超过 <em>max_size</em>，或调用文件的 <code>fileno()</code> 方法为止，此时数据会被写入磁盘，并且写入操作与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 相同。</p><p>此函数生成的文件对象有一个额外的方法——<code>rollover()</code>，可以忽略文件大小，让文件立即写入磁盘。</p><p>返回的对象是文件类对象 (file-like object)，它的 <code>_file</code> 属性是 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.BytesIO" target="_blank" rel="noopener"><code>io.BytesIO</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.TextIOWrapper" target="_blank" rel="noopener"><code>io.TextIOWrapper</code></a> 对象（取决于指定的是二进制模式还是文本模式）或真实的文件对象（取决于是否已调用 <code>rollover()</code>）。文件类对象可以像普通文件一样在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中使用。</p><p><em>在 3.3 版更改:</em> 现在，文件的 truncate 方法可接受一个 <code>size</code> 参数。</p><p><em>在 3.8 版更改:</em> 添加了 <em>errors</em> 参数。</p></li><li><p><code>tempfile.TemporaryDirectory</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>) </p><p>此函数会安全地创建一个临时目录，且使用与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 相同的规则。此函数返回的对象可用作上下文管理器（参见 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile-examples" target="_blank" rel="noopener">示例</a>）。完成上下文或销毁临时目录对象后，新创建的临时目录及其所有内容将从文件系统中删除。</p><p>可以从返回对象的 <code>name</code> 属性中找到临时目录的名称。当返回的对象用作上下文管理器时，这个 <code>name</code> 会作为 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中 <code>as</code> 子句的目标（如果有 as 的话）。</p><p>可以调用 <code>cleanup()</code> 方法来手动清理目录。</p><p>引发一个 <code>tempfile.mkdtemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>3.2 新版功能.</em></p></li><li><p><code>tempfile.mkstemp</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>text=False</em>) </p><p>以最安全的方式创建一个临时文件。假设所在平台正确实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_EXCL" target="_blank" rel="noopener"><code>os.O_EXCL</code></a> 标志，则创建文件时不会有竞争的情况。该文件只能由创建者读写，如果所在平台用权限位来标记文件是否可执行，那么没有人有执行权。文件描述符不会过继给子进程。</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 不同，<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 用户用完临时文件后需要自行将其删除。</p><p>如果 <em>suffix</em> 不是 <code>None</code> 则文件名将以该后缀结尾，是 <code>None</code> 则没有后缀。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 不会在文件名和后缀之间加点，如果需要加一个点号，请将其放在 <em>suffix</em> 的开头。</p><p>如果 <em>prefix</em> 不是 <code>None</code>，则文件名将以该前缀开头，是 <code>None</code> 则使用默认前缀。默认前缀是 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefix" target="_blank" rel="noopener"><code>gettempprefix()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefixb" target="_blank" rel="noopener"><code>gettempprefixb()</code></a> 函数的返回值（自动调用合适的函数）。</p><p>如果 <em>dir</em> 不为 <code>None</code>，则在指定的目录创建文件，是 <code>None</code> 则使用默认目录。默认目录是从一个列表中选择出来的，这个列表不同平台不一样，但是用户可以设置 <em>TMPDIR</em>、<em>TEMP</em> 或 <em>TMP</em> 环境变量来设置目录的位置。因此，不能保证生成的临时文件路径很规范，比如，通过 <code>os.popen()</code> 将路径传递给外部命令时仍需要加引号。</p><p>如果 <em>suffix</em>、<em>prefix</em> 和 <em>dir</em> 中的任何一个不是 <code>None</code>，就要保证它们是同一数据类型。如果它们是 bytes，则返回的名称的类型就是 bytes 而不是 str。如果确实要用默认参数，但又想要返回值是 bytes 类型，请传入 <code>suffix=b&#39;&#39;</code>。</p><p>如果指定了 <em>text</em> 参数，它表示的是以二进制模式（默认）还是文本模式打开文件。在某些平台上，两种模式没有区别。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 返回一个元组，元组中第一个元素是句柄，它是一个系统级句柄，指向一个打开的文件（等同于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 的返回值），第二元素是该文件的绝对路径。</p><p>引发一个 <code>tempfile.mkstemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>在 3.5 版更改:</em> 现在，<em>suffix</em>、<em>prefix</em> 和 <em>dir</em> 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 str。<em>suffix</em> 和 <em>prefix</em> 现在可以接受 <code>None</code>，并且默认为 <code>None</code> 以使用合适的默认值。</p><p><em>在 3.6 版更改:</em> <em>dir</em> 参数现在可接受一个路径类对象 (<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a>)。</p></li><li><p><code>tempfile.mkdtemp</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>) </p><p>以最安全的方式创建一个临时目录，创建该目录时不会有竞争的情况。该目录只能由创建者读取、写入和搜索。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 用户用完临时目录后需要自行将其删除。</p><p><em>prefix</em>、<em>suffix</em> 和 <em>dir</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 中的相同。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 返回新目录的绝对路径。</p><p>引发一个 <code>tempfile.mkdtemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>在 3.5 版更改:</em> 现在，<em>suffix</em>、<em>prefix</em> 和 <em>dir</em> 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 str。<em>suffix</em> 和 <em>prefix</em> 现在可以接受 <code>None</code>，并且默认为 <code>None</code> 以使用合适的默认值。</p><p><em>在 3.6 版更改:</em> <em>dir</em> 参数现在可接受一个路径类对象 (<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a>)。</p></li><li><p><code>tempfile.gettempdir</code>() </p><p>返回放置临时文件的目录的名称。这个方法的返回值就是本模块所有函数的 <em>dir</em> 参数的默认值。</p><p>Python 搜索标准目录列表，以找到调用者可以在其中创建文件的目录。这个列表是：</p><ol><li><code>TMPDIR</code> 环境变量指向的目录。</li><li><code>TEMP</code> 环境变量指向的目录。</li><li><code>TMP</code> 环境变量指向的目录。</li><li>与平台相关的位置：<ul><li>在 Windows 上，依次为 <code>C:\TEMP</code>、<code>C:\TMP</code>、<code>\TEMP</code> 和 <code>\TMP</code>。</li><li>在所有其他平台上，依次为 <code>/tmp</code>、<code>/var/tmp</code> 和 <code>/usr/tmp</code>。</li></ul></li><li>不得已时，使用当前工作目录。</li></ol><p>搜索的结果会缓存起来，参见下面 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.tempdir" target="_blank" rel="noopener"><code>tempdir</code></a> 的描述。</p></li><li><p><code>tempfile.gettempdirb</code>()</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempdir" target="_blank" rel="noopener"><code>gettempdir()</code></a> 相同，但返回值为字节类型。<em>3.5 新版功能.</em></p></li><li><p><code>tempfile.gettempprefix</code>()</p><p>返回用于创建临时文件的文件名前缀，它不包含目录部分。</p></li><li><p><code>tempfile.gettempprefixb</code>()</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefix" target="_blank" rel="noopener"><code>gettempprefix()</code></a> 相同，但返回值为字节类型。<em>3.5 新版功能.</em></p></li></ul><p>本模块使用一个全局变量来存储由 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempdir" target="_blank" rel="noopener"><code>gettempdir()</code></a> 返回的临时文件目录路径。可以直接给它赋值，这样可以覆盖自动选择的路径，但是不建议这样做。本模块中的所有函数都带有一个 <em>dir</em> 参数，该参数可用于指定目录，这是推荐的方法。</p><ul><li><p><code>tempfile.tempdir</code></p><p>当设置为 <code>None</code> 以外的其他值时，此变量将决定本模块所有函数的 <em>dir</em> 参数的默认值。如果在调用除 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefix" target="_blank" rel="noopener"><code>gettempprefix()</code></a> 外的上述任何函数时 <code>tempdir</code> 为 <code>None</code> (默认值) 则它会按照 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempdir" target="_blank" rel="noopener"><code>gettempdir()</code></a> 中所描述的算法来初始化。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下是 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#module-tempfile" target="_blank" rel="noopener"><code>tempfile</code></a> 模块典型用法的一些示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> tempfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a temporary file and write some data to it</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp = tempfile.TemporaryFile()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.write(<span class="string">b'Hello world!'</span>)</span><br><span class="line"><span class="comment"># read data from file</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.seek(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.read()</span><br><span class="line"><span class="string">b'Hello world!'</span></span><br><span class="line"><span class="comment"># close the file, it will be removed</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a temporary file using a context manager</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> tempfile.TemporaryFile() <span class="keyword">as</span> fp:</span><br><span class="line"><span class="meta">... </span>    fp.write(<span class="string">b'Hello world!'</span>)</span><br><span class="line"><span class="meta">... </span>    fp.seek(<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span>    fp.read()</span><br><span class="line"><span class="string">b'Hello world!'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment"># file is now closed and removed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create a temporary directory using the context manager</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> tempfile.TemporaryDirectory() <span class="keyword">as</span> tmpdirname:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'created temporary directory'</span>, tmpdirname)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment"># directory and contents have been removed</span></span><br></pre></td></tr></table></figure><h2 id="已弃用的函数和变量"><a href="#已弃用的函数和变量" class="headerlink" title="已弃用的函数和变量"></a>已弃用的函数和变量</h2><p>创建临时文件有一种历史方法，首先使用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mktemp" target="_blank" rel="noopener"><code>mktemp()</code></a> 函数生成一个文件名，然后使用该文件名创建文件。不幸的是，这是不安全的，因为在调用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mktemp" target="_blank" rel="noopener"><code>mktemp()</code></a> 与随后尝试创建文件的进程之间的时间里，其他进程可能会使用该名称创建文件。解决方案是将两个步骤结合起来，立即创建文件。这个方案目前被 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 和上述其他函数所采用。</p><ul><li><p><code>tempfile.mktemp</code>(<em>suffix=’’</em>, <em>prefix=’tmp’</em>, <em>dir=None</em>)</p><p><em>2.3 版后已移除:</em> 使用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 来代替。返回一个绝对路径，这个路径指向的文件在调用本方法时不存在。<em>prefix</em>、<em>suffix</em> 和 <em>dir</em> 参数与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 中的同名参数类似，不同之处在于不支持字节类型的文件名，不支持 <code>suffix=None</code> 和 <code>prefix=None</code>。</p></li></ul><p>使用此功能可能会在程序中引入安全漏洞。当你开始使用本方法返回的文件执行任何操作时，可能有人已经捷足先登了。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mktemp" target="_blank" rel="noopener"><code>mktemp()</code></a> 的功能可以很轻松地用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.NamedTemporaryFile" target="_blank" rel="noopener"><code>NamedTemporaryFile()</code></a> 代替，当然需要传递 <code>delete=False</code> 参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = NamedTemporaryFile(delete=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.name</span><br><span class="line"><span class="string">'/tmp/tmptjujjt'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">b"Hello World!\n"</span>)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.unlink(f.name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exists(f.name)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-tempfile&quot;&gt;&lt;a href=&quot;#python-标准库-tempfile&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 tempfile&quot;&gt;&lt;/a&gt;python 标准库 tempfile&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200213_car.jpeg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="tempfile" scheme="https://pinghailinfeng.gitee.io/tags/tempfile/"/>
    
  </entry>
  
  <entry>
    <title>python standard library coroutines</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/12/python-standard-library-coroutines/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/12/python-standard-library-coroutines/</id>
    <published>2020-02-12T13:59:58.000Z</published>
    <updated>2020-02-17T03:27:23.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-coroutines-协程"><a href="#python-标准库-coroutines-协程" class="headerlink" title="python 标准库 coroutines 协程"></a>python 标准库 coroutines 协程</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200213_coroutine.jpg?raw=true" alt></p><a id="more"></a><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200213_writing.jpg?raw=true" alt></p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id2" target="_blank" rel="noopener">协程</a></h2><p> <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">Coroutines</a> declared with the async/await syntax is the preferred way of writing asyncio applications. For example, the following snippet of code (requires Python 3.7+) prints “hello”, waits 1 second, and then prints “world”: </p><p> <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">Coroutines</a> 通过 async/await 语法声明是编写异步应用程序的首选方式。例如下面的语法片段(需要Python 3.7+),我们实现了等待一秒,打印’’world“的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'hello'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>asyncio.run(main())</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><p> 注意：简单地调用一个协程并不会将其加入执行日程: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>main()</span><br><span class="line">&lt;coroutine object main at <span class="number">0x1053bb7c8</span>&gt;</span><br></pre></td></tr></table></figure><p>要真正运行一个协程，asyncio 提供了三种主要机制:</p><ul><li><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.run" target="_blank" rel="noopener"><code>asyncio.run()</code></a> 函数用来运行最高层级的入口点 “main()” 函数 (参见上面的示例。)</p></li><li><p>等待一个协程。以下代码段会在等待 1 秒后打印 “hello”，然后 <em>再次</em> 等待 2 秒后打印 “world”:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_after</span><span class="params">(delay, what)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    print(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>预期的输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">started at <span class="number">17</span>:<span class="number">13</span>:<span class="number">52</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finished at <span class="number">17</span>:<span class="number">13</span>:<span class="number">55</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>asyncio.create_task()</code></a> 函数用来并发运行作为 asyncio <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>任务</code></a> 的多个协程。 </p><p>让我们修改以上示例，<em>并发</em> 运行两个 <code>say_after</code> 协程:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task1 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">1</span>, <span class="string">'hello'</span>))</span><br><span class="line"></span><br><span class="line">    task2 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">2</span>, <span class="string">'world'</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait until both tasks are completed (should take</span></span><br><span class="line">    <span class="comment"># around 2 seconds.)</span></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><p>注意，预期的输出显示代码段的运行时间比之前快了 1 秒:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">started at <span class="number">17</span>:<span class="number">14</span>:<span class="number">32</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finished at <span class="number">17</span>:<span class="number">14</span>:<span class="number">34</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="可等待对象"><a href="#可等待对象" class="headerlink" title="可等待对象"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id3" target="_blank" rel="noopener">可等待对象</a></h2><p>如果一个对象可以在 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#await" target="_blank" rel="noopener"><code>await</code></a> 语句中使用，那么它就是 <strong>可等待</strong> 对象。许多 asyncio API 都被设计为接受可等待对象。</p><p><em>可等待</em> 对象有三种主要类型: <strong>协程</strong>, <strong>任务</strong> 和 <strong>Future</strong>.</p><p>协程</p><p>Python 协程属于 <em>可等待</em> 对象，因此可以在其他协程中被等待:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Nothing happens if we just call "nested()".</span></span><br><span class="line">    <span class="comment"># A coroutine object is created but not awaited,</span></span><br><span class="line">    <span class="comment"># so it *won't run at all*.</span></span><br><span class="line">    nested()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let's do it differently now and await it:</span></span><br><span class="line">    print(<span class="keyword">await</span> nested())  <span class="comment"># will print "42".</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>重要</p><p>在本文档中 “协程” 可用来表示两个紧密关联的概念:</p><ul><li><em>协程函数</em>: 定义形式为 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 的函数;</li><li><p><em>协程对象</em>: 调用 <em>协程函数</em> 所返回的对象。</p><p>asyncio 也支持旧式的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-generator-based-coro" target="_blank" rel="noopener">基于生成器的</a> 协程。 </p></li></ul><p>任务</p><p><em>任务</em> 被用来设置日程以便 <em>并发</em> 执行协程。</p><p>当一个协程通过 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>asyncio.create_task()</code></a> 等函数被打包为一个 <em>任务</em>，该协程将自动排入日程准备立即运行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Schedule nested() to run soon concurrently</span></span><br><span class="line">    <span class="comment"># with "main()".</span></span><br><span class="line">    task = asyncio.create_task(nested())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># "task" can now be used to cancel "nested()", or</span></span><br><span class="line">    <span class="comment"># can simply be awaited to wait until it is complete:</span></span><br><span class="line">    <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>Future 对象</p><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future</code></a> 是一种特殊的 <strong>低层级</strong> 可等待对象，表示一个异步操作的 <strong>最终结果</strong>。</p><p>当一个 Future 对象 <em>被等待</em>，这意味着协程将保持等待直到该 Future 对象在其他地方操作完毕。</p><p>在 asyncio 中需要 Future 对象以便允许通过 async/await 使用基于回调的代码。</p><p>通常情况下 <strong>没有必要</strong> 在应用层级的代码中创建 Future 对象。</p><p>Future 对象有时会由库和某些 asyncio API 暴露给用户，用作可等待对象:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> function_that_returns_a_future_object()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># this is also valid:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        function_that_returns_a_future_object(),</span><br><span class="line">        some_python_coroutine()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>一个很好的返回对象的低层级函数的示例是 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.loop.run_in_executor" target="_blank" rel="noopener"><code>loop.run_in_executor()</code></a>。</p><h2 id="运行-asyncio-程序"><a href="#运行-asyncio-程序" class="headerlink" title="运行 asyncio 程序"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id4" target="_blank" rel="noopener">运行 asyncio 程序</a></h2><p> <code>asyncio.run</code>(<em>coro</em>, <em>**, </em>debug=False*) </p><p>执行 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> <em>coro</em> 并返回结果。</p><p>此函数运行传入的协程，负责管理 asyncio 事件循环并 <em>完结异步生成器</em>。</p><p>当有其他 asyncio 事件循环在同一线程中运行时，此函数不能被调用。</p><p>如果 <em>debug</em> 为 <code>True</code>，事件循环将以调试模式运行。</p><p>此函数总是会创建一个新的事件循环并在结束时关闭之。它应当被用作 asyncio 程序的主入口点，理想情况下应当只被调用一次。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p> <em>3.7 新版功能.</em> </p><blockquote><p>  <code>asyncio.run()</code>源代码请移步至 <a href="https://github.com/python/cpython/tree/3.8/Lib/asyncio/runners.py" target="_blank" rel="noopener">Lib/asyncio/runners.py</a>.</p></blockquote><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id5" target="_blank" rel="noopener">创建任务</a></h2><ul><li><p><code>asyncio.create_task</code>(<em>coro</em>, <em>**, </em>name=None*)</p><p>将 <em>coro</em> <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程</a> 打包为一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 排入日程准备执行。返回 Task 对象。</p><p>If <em>name</em> is not <code>None</code>, it is set as the name of the task using <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.set_name" target="_blank" rel="noopener"><code>Task.set_name()</code></a>.</p><p>该任务会在 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener"><code>get_running_loop()</code></a> 返回的循环中执行，如果当前线程没有在运行的循环则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p><p>此函数 <strong>在 Python 3.7 中被加入</strong>。在 Python 3.7 之前，可以改用低层级的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.ensure_future" target="_blank" rel="noopener"><code>asyncio.ensure_future()</code></a> 函数。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># In Python 3.7+</span></span><br><span class="line">task = asyncio.create_task(coro())</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># This works in all Python versions but is less readable</span></span><br><span class="line">task = asyncio.ensure_future(coro())</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><em>3.7 新版功能.</em></p><p><em>在 3.8 版更改:</em> Added the <code>name</code> parameter.</p><h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id6" target="_blank" rel="noopener">休眠</a></h2><ul><li><p><em>coroutine</em> <code>asyncio.sleep</code>(<em>delay</em>, <em>result=None</em>, <em>**, </em>loop=None*)</p><p>阻塞 <em>delay</em> 指定的秒数。</p><p>如果指定了 <em>result</em>，则当协程完成时将其返回给调用者。</p><p><code>sleep()</code> 总是会挂起当前任务，以允许其他任务运行。</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><p>以下协程示例运行 5 秒，每秒显示一次当前日期:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">display_date</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    end_time = loop.time() + <span class="number">5.0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(datetime.datetime.now())</span><br><span class="line">        <span class="keyword">if</span> (loop.time() + <span class="number">1.0</span>) &gt;= end_time:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(display_date())</span><br></pre></td></tr></table></figure></li></ul><h2 id="并发运行任务"><a href="#并发运行任务" class="headerlink" title="并发运行任务"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id7" target="_blank" rel="noopener">并发运行任务</a></h2><ul><li><p><em>awaitable</em> <code>asyncio.gather</code>(*<em>aws</em>, <em>loop=None</em>, <em>return_exceptions=False</em>) </p><p><em>并发</em> 运行 <em>aws</em> 序列中的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a>。</p><p>如果 <em>aws</em> 中的某个可等待对象为协程，它将自动作为一个任务加入日程。</p><p>如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而成的列表。结果值的顺序与 <em>aws</em> 中可等待对象的顺序一致。</p><p>如果 <em>return_exceptions</em> 为 <code>False</code> (默认)，所引发的首个异常会立即传播给等待 <code>gather()</code> 的任务。<em>aws</em> 序列中的其他可等待对象 <strong>不会被取消</strong> 并将继续运行。</p><p>如果 <em>return_exceptions</em> 为 <code>True</code>，异常会和成功的结果一样处理，并聚合至结果列表。</p><p>如果 <code>gather()</code> <em>被取消</em>，所有被提交 (尚未完成) 的可等待对象也会 <em>被取消</em>。</p><p>如果 <em>aws</em> 序列中的任一 Task 或 Future 对象 <em>被取消</em>，它将被当作引发了 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 一样处理 – 在此情况下 <code>gather()</code> 调用 <strong>不会</strong> 被取消。这是为了防止一个已提交的 Task/Future 被取消导致其他 Tasks/Future 也被取消。</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(name, number)</span>:</span></span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: Compute factorial(<span class="subst">&#123;i&#125;</span>)..."</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        f *= i</span><br><span class="line">    print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: factorial(<span class="subst">&#123;number&#125;</span>) = <span class="subst">&#123;f&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        factorial(<span class="string">"A"</span>, <span class="number">2</span>),</span><br><span class="line">        factorial(<span class="string">"B"</span>, <span class="number">3</span>),</span><br><span class="line">        factorial(<span class="string">"C"</span>, <span class="number">4</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     Task A: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task A: factorial(2) = 2</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(3)...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(3)...</span></span><br><span class="line"><span class="comment">#     Task B: factorial(3) = 6</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(4)...</span></span><br><span class="line"><span class="comment">#     Task C: factorial(4) = 24</span></span><br></pre></td></tr></table></figure><p><em>在 3.7 版更改:</em> 如果 <em>gather</em> 本身被取消，则无论 <em>return_exceptions</em> 取值为何，消息都会被传播。</p></li></ul><h2 id="屏蔽取消操作"><a href="#屏蔽取消操作" class="headerlink" title="屏蔽取消操作"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id8" target="_blank" rel="noopener">屏蔽取消操作</a></h2><ul><li><p><em>awaitable</em> <code>asyncio.shield</code>(<em>aw</em>, <em>**, </em>loop=None*) </p><p>保护一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a> 防止其被 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>取消</code></a>。</p><p>如果 <em>aw</em> 是一个协程，它将自动作为任务加入日程。</p><p>以下语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = await shield(something())</span><br></pre></td></tr></table></figure><p>相当于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = await something()</span><br></pre></td></tr></table></figure><p><em>不同之处</em> 在于如果包含它的协程被取消，在 <code>something()</code> 中运行的任务不会被取消。从 <code>something()</code> 的角度看来，取消操作并没有发生。然而其调用者已被取消，因此 “await” 表达式仍然会引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a>。</p><p>如果通过其他方式取消 <code>something()</code> (例如在其内部操作) 则 <code>shield()</code> 也会取消。</p><p>如果希望完全忽略取消操作 (不推荐) 则 <code>shield()</code> 函数需要配合一个 try/except 代码段，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    res = await shield(something())</span><br><span class="line">except CancelledError:</span><br><span class="line">    res = None</span><br></pre></td></tr></table></figure><p>从 3.8版本加入，将于 3.10版本移除<em>loop</em> 形参。</p></li></ul><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id9" target="_blank" rel="noopener">超时</a></h2><ul><li><p><em>coroutine</em> <code>asyncio.wait_for</code>(<em>aw</em>, <em>timeout</em>, <em>**, </em>loop=None*) </p><p>等待 <em>aw</em> <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a> 完成，指定 timeout 秒数后超时。</p><p>如果 <em>aw</em> 是一个协程，它将自动作为任务加入日程。</p><p><em>timeout</em> 可以为 <code>None</code>，也可以为 float 或 int 型数值表示的等待秒数。如果 <em>timeout</em> 为 <code>None</code>，则等待直到完成。</p><p>如果发生超时，任务将取消并引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>.</p><p>要避免任务 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>取消</code></a>，可以加上 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.shield" target="_blank" rel="noopener"><code>shield()</code></a>。</p><p>函数将等待直到目标对象确实被取消，所以总等待时间可能超过 <em>timeout</em> 指定的秒数。</p><p>如果等待被取消，则 <em>aw</em> 指定的对象也会被取消。</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">eternity</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Sleep for one hour</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    print(<span class="string">'yay!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Wait for at most 1 second</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait_for(eternity(), timeout=<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">        print(<span class="string">'timeout!'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     timeout!</span></span><br></pre></td></tr></table></figure><p><em>在 3.7 版更改:</em> 当 <em>aw</em> 因超时被取消，<code>wait_for</code> 会等待 <em>aw</em> 被取消。之前版本则将立即引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>。</p></li></ul><h2 id="简单等待"><a href="#简单等待" class="headerlink" title="简单等待"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id10" target="_blank" rel="noopener">简单等待</a></h2><ul><li><p><em>coroutine</em> <code>asyncio.wait</code>(<em>aws</em>, <em>**, </em>loop=None<em>, </em>timeout=None<em>, </em>return_when=ALL_COMPLETED*) </p><p>并发运行 <em>aws</em> 指定的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a> 并阻塞线程直到满足 <em>return_when</em> 指定的条件。</p><p>返回两个 Task/Future 集合: <code>(done, pending)</code>。</p><p>用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">done, pending = await asyncio.wait(aws)</span><br></pre></td></tr></table></figure><p>如指定 <em>timeout</em> (float 或 int 类型) 则它将被用于控制返回之前等待的最长秒数。</p><p>请注意此函数不会引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>。当超时发生时，未完成的 Future 或 Task 将在指定秒数后被返回。</p><p><em>return_when</em> 指定此函数应在何时返回。它必须为以下常数之一:</p><p>| 常数              | 描述                                                         |<br>| :—————- | :———————————————————– |<br>| <code>FIRST_COMPLETED</code> | 函数将在任意可等待对象结束或取消时返回。                     |<br>| <code>FIRST_EXCEPTION</code> | 函数将在任意可等待对象因引发异常而结束时返回。当没有引发任何异常时它就相当于 <code>ALL_COMPLETED</code>。 |<br>| <code>ALL_COMPLETED</code>   | 函数将在所有可等待对象结束或取消时返回。                     |</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.wait_for" target="_blank" rel="noopener"><code>wait_for()</code></a> 不同，<code>wait()</code> 在超时发生时不会取消可等待对象。</p><p><em>3.8 版后已移除:</em> 如果 <em>aws</em> 中的某个可等待对象为协程，它将自动作为任务加入日程。直接向 <code>wait()</code> 传入协程对象已弃用，因为这会导致 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-example-wait-coroutine" target="_blank" rel="noopener">令人迷惑的行为</a>。</p><p>从 3.8版本加入，将于 3.10版本移除<em>loop</em> 形参。</p><blockquote><p>注解</p><p><code>wait()</code> 会自动将协程作为任务加入日程，以后将以 <code>(done, pending)</code> 集合形式返回显式创建的任务对象。因此以下代码并不会有预期的行为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; coro = foo()</span><br><span class="line">&gt; done, pending = <span class="keyword">await</span> asyncio.wait(&#123;coro&#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">if</span> coro <span class="keyword">in</span> done:</span><br><span class="line">&gt;     <span class="comment"># This branch will never be run!</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>以上代码段的修正方法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; task = asyncio.create_task(foo())</span><br><span class="line">&gt; done, pending = <span class="keyword">await</span> asyncio.wait(&#123;task&#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">if</span> task <span class="keyword">in</span> done:</span><br><span class="line">&gt;     <span class="comment"># Everything will work as expected now.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>​     <em>3.8 版后已移除:</em> 直接向 <code>wait()</code> 传入协程对象的方式已弃用。 </p><ul><li><p><code>asyncio.as_completed</code>(<em>aws</em>, <em>**, </em>loop=None<em>, </em>timeout=None*) </p><p>并发地运行 <em>aws</em> 集合中的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a>。返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future</code></a> 对象的迭代器。返回的每个 Future 对象代表来自剩余可等待对象集合的最早结果。</p><p>如果在所有 Future 对象完成前发生超时则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>。</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> as_completed(aws):</span><br><span class="line">    earliest_result = <span class="keyword">await</span> f</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="来自其他线程的日程安排"><a href="#来自其他线程的日程安排" class="headerlink" title="来自其他线程的日程安排"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id11" target="_blank" rel="noopener">来自其他线程的日程安排</a></h2><ul><li><p><code>asyncio.run_coroutine_threadsafe</code>(<em>coro</em>, <em>loop</em>)</p><p>向指定事件循环提交一个协程。线程安全。</p><p>返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>concurrent.futures.Future</code></a> 以等待来自其他 OS 线程的结果。</p><p>此函数应该从另一个 OS 线程中调用，而非事件循环运行所在线程。示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Create a coroutine</span><br><span class="line">coro = asyncio.sleep(1, result=3)</span><br><span class="line"></span><br><span class="line"># Submit the coroutine to a given loop</span><br><span class="line">future = asyncio.run_coroutine_threadsafe(coro, loop)</span><br><span class="line"></span><br><span class="line"># Wait for the result with an optional timeout argument</span><br><span class="line">assert future.result(timeout) == 3</span><br></pre></td></tr></table></figure><p>如果在协程内产生了异常，将会通知返回的 Future 对象。它也可被用来取消事件循环中的任务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    result = future.result(timeout)</span><br><span class="line">except asyncio.TimeoutError:</span><br><span class="line">    print(&apos;The coroutine took too long, cancelling the task...&apos;)</span><br><span class="line">    future.cancel()</span><br><span class="line">except Exception as exc:</span><br><span class="line">    print(f&apos;The coroutine raised an exception: &#123;exc!r&#125;&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(f&apos;The coroutine returned: &#123;result!r&#125;&apos;)</span><br></pre></td></tr></table></figure><p>查看 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-dev.html#asyncio-multithreading" target="_blank" rel="noopener">并发和多线程</a> 章节的文档。</p><p>不同与其他 asyncio 函数，此函数要求显式地传入 <em>loop</em> 参数。</p><p><em>3.5.1 新版功能.</em></p></li></ul><h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id12" target="_blank" rel="noopener">内省</a></h2><ul><li><p><code>asyncio.current_task</code>(<em>loop=None</em>)</p><p>返回当前运行的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 实例，如果没有正在运行的任务则返回 <code>None</code>。如果 <em>loop</em> 为 <code>None</code> 则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener"><code>get_running_loop()</code></a> 获取当前事件循环。<em>3.7 新版功能.</em></p></li><li><p><code>asyncio.all_tasks</code>(<em>loop=None</em>)</p><p>返回事件循环所运行的未完成的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 对象的集合。如果 <em>loop</em> 为 <code>None</code>，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener"><code>get_running_loop()</code></a> 获取当前事件循环。<em>3.7 新版功能.</em></p></li></ul><h2 id="Task-对象"><a href="#Task-对象" class="headerlink" title="Task 对象"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id13" target="_blank" rel="noopener">Task 对象</a></h2><ul><li><p><em>class</em> <code>asyncio.Task</code>(<em>coro</em>, <em>**, </em>loop=None<em>, </em>name=None*)</p><p>一个与 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future 类似</code></a> 的对象，可运行 Python <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程</a>。非线程安全。</p><p>Task 对象被用来在事件循环中运行协程。如果一个协程在等待一个 Future 对象，Task 对象会挂起该协程的执行并等待该 Future 对象完成。当该 Future 对象 <em>完成</em>，被打包的协程将恢复执行。</p><p>事件循环使用协同日程调度: 一个事件循环每次运行一个 Task 对象。而一个 Task 对象会等待一个 Future 对象完成，该事件循环会运行其他 Task、回调或执行 IO 操作。</p><p>使用高层级的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>asyncio.create_task()</code></a> 函数来创建 Task 对象，也可用低层级的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.loop.create_task" target="_blank" rel="noopener"><code>loop.create_task()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.ensure_future" target="_blank" rel="noopener"><code>ensure_future()</code></a> 函数。不建议手动实例化 Task 对象。</p><p>要取消一个正在运行的 Task 对象可使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>cancel()</code></a> 方法。调用此方法将使该 Task 对象抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常给打包的协程。如果取消期间一个协程正在等待一个 Future 对象，该 Future 对象也将被取消。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancelled" target="_blank" rel="noopener"><code>cancelled()</code></a> 可被用来检测 Task 对象是否被取消。如果打包的协程没有抑制 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常并且确实被取消，该方法将返回 <code>True</code>。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>asyncio.Task</code></a> 从 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future</code></a> 继承了其除 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_result" target="_blank" rel="noopener"><code>Future.set_result()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_exception" target="_blank" rel="noopener"><code>Future.set_exception()</code></a> 以外的所有 API。</p><p>Task 对象支持 <a href="https://docs.python.org/zh-cn/3.8/library/contextvars.html#module-contextvars" target="_blank" rel="noopener"><code>contextvars</code></a> 模块。当一个 Task 对象被创建，它将复制当前上下文，然后在复制的上下文中运行其协程。</p><p><em>在 3.7 版更改:</em> 加入对 <a href="https://docs.python.org/zh-cn/3.8/library/contextvars.html#module-contextvars" target="_blank" rel="noopener"><code>contextvars</code></a> 模块的支持。</p><p><em>在 3.8 版更改:</em> Added the <code>name</code> parameter.</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><ul><li><p><code>cancel</code>()</p><p>请求取消 Task 对象。这将安排在下一轮事件循环中抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常给被封包的协程。协程在之后有机会进行清理甚至使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> … … <code>except CancelledError</code> … <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 代码块抑制异常来拒绝请求。不同于 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.cancel" target="_blank" rel="noopener"><code>Future.cancel()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>Task.cancel()</code></a> 不保证 Task 会被取消，虽然抑制完全取消并不常见，也很不鼓励这样做。以下示例演示了协程是如何侦听取消请求的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel_me</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'cancel_me(): before sleep'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Wait for 1 hour</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        print(<span class="string">'cancel_me(): cancel sleep'</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'cancel_me(): after sleep'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Create a "cancel_me" Task</span></span><br><span class="line">    task = asyncio.create_task(cancel_me())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait for 1 second</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    task.cancel()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        print(<span class="string">"main(): cancel_me is cancelled now"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     cancel_me(): before sleep</span></span><br><span class="line"><span class="comment">#     cancel_me(): cancel sleep</span></span><br><span class="line"><span class="comment">#     cancel_me(): after sleep</span></span><br><span class="line"><span class="comment">#     main(): cancel_me is cancelled now</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>cancelled</code>()</p><p>如果 Task 对象 <em>被取消</em> 则返回 <code>True</code>。当使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>cancel()</code></a> 发出取消请求时 Task 会被 <em>取消</em>，其封包的协程将传播被抛入的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。</p></li><li><p><code>done</code>()</p><p>如果 Task 对象 <em>已完成</em> 则返回 <code>True</code>。当 Task 所封包的协程返回一个值、引发一个异常或 Task 本身被取消时，则会被认为 <em>已完成</em>。</p></li><li><p><code>result</code>()</p><p>返回 Task 的结果。如果 Task 对象 <em>已完成</em>，其封包的协程的结果会被返回 (或者当协程引发异常时，该异常会被重新引发。)如果 Task 对象 <em>被取消</em>，此方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。如果 Task 对象的结果还不可用，此方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 异常。</p></li><li><p><code>exception</code>()</p><p>返回 Task 对象的异常。如果所封包的协程引发了一个异常，该异常将被返回。如果所封包的协程正常返回则该方法将返回 <code>None</code>。如果 Task 对象 <em>被取消</em>，此方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。如果 Task 对象尚未 <em>完成</em>，此方法将引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 异常。</p></li><li><p><code>add_done_callback</code>(<em>callback</em>, <em>**, </em>context=None*)</p><p>添加一个回调，将在 Task 对象 <em>完成</em> 时被运行。此方法应该仅在低层级的基于回调的代码中使用。要了解更多细节请查看 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.add_done_callback" target="_blank" rel="noopener"><code>Future.add_done_callback()</code></a> 的文档。</p></li><li><p><code>remove_done_callback</code>(<em>callback</em>)</p><p>从回调列表中移除 <em>callback</em> 指定的回调。此方法应该仅在低层级的基于回调的代码中使用。要了解更多细节请查看 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.remove_done_callback" target="_blank" rel="noopener"><code>Future.remove_done_callback()</code></a> 的文档。</p></li><li><p><code>get_stack</code>(<em>**, </em>limit=None*)</p><p>返回此 Task 对象的栈框架列表。如果所封包的协程未完成，这将返回其挂起所在的栈。如果协程已成功完成或被取消，这将返回一个空列表。如果协程被一个异常终止，这将返回回溯框架列表。框架总是从按从旧到新排序。每个被挂起的协程只返回一个栈框架。可选的 <em>limit</em> 参数指定返回框架的数量上限；默认返回所有框架。返回列表的顺序要看是返回一个栈还是一个回溯：栈返回最新的框架，回溯返回最旧的框架。(这与 traceback 模块的行为保持一致。)</p></li><li><p><code>print_stack</code>(<em>**, </em>limit=None<em>, </em>file=None*)</p><p>打印此 Task 对象的栈或回溯。此方法产生的输出类似于 traceback 模块通过 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.get_stack" target="_blank" rel="noopener"><code>get_stack()</code></a> 所获取的框架。<em>limit</em> 参数会直接传递给 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.get_stack" target="_blank" rel="noopener"><code>get_stack()</code></a>。<em>file</em> 参数是输出所写入的 I/O 流；默认情况下输出会写入 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stderr" target="_blank" rel="noopener"><code>sys.stderr</code></a>。</p></li><li><p><code>get_coro</code>()</p><p>返回绑定到 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a>.的协程对象。<em>3.8 新版功能.</em></p></li><li><p><code>get_name</code>()</p><p>返回Task 名字。如果没有显式分配给Task一个名字,则默认的异步Task将分配给默认的生成的名字。<em>3.8 新版功能.</em></p></li><li><p><code>set_name</code>(<em>value</em>)</p><p>设置Task名字。参数值可以是任意数据类型,都将被转换成字符串。默认的Task实现，可以通过在task对象中实现 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a>函数显式输出。<em>3.8 新版功能.</em></p></li><li><p><em>classmethod</em> <code>all_tasks</code>(<em>loop=None</em>)</p><p>返回一个事件循环中所有任务的集合。默认情况下将返回当前事件循环中所有任务。如果 <em>loop</em> 为 <code>None</code>，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_event_loop" target="_blank" rel="noopener"><code>get_event_loop()</code></a> 函数来获取当前事件循环。从3.7版本就被废弃,3.9版本将会被移除。尽量不要作为一个task方法来使用,建议使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.all_tasks" target="_blank" rel="noopener"><code>asyncio.all_tasks()</code></a> 代替。</p></li><li><p><em>classmethod</em> <code>current_task</code>(<em>loop=None</em>)</p><p>返回当前运行任务或 <code>None</code>。如果 <em>loop</em> 为 <code>None</code>，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_event_loop" target="_blank" rel="noopener"><code>get_event_loop()</code></a> 函数来获取当前事件循环。</p><p>从3.7版本就被废弃,3.9版本将会被移除。尽量不要作为一个task方法来使用,建议使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.current_task" target="_blank" rel="noopener"><code>asyncio.current_task()</code></a> 代替。</p></li></ul><h2 id="基于生成器的协程"><a href="#基于生成器的协程" class="headerlink" title="基于生成器的协程"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id14" target="_blank" rel="noopener">基于生成器的协程</a></h2><blockquote><p>对基于生成器的协程的支持 <strong>已弃用</strong> 并计划在 Python 3.10 中移除。</p></blockquote><p>基于生成器的协程是 async/await 语法的前身。它们是使用 <code>yield from</code> 语句创建的 Python 生成器，可以等待 Future 和其他协程。</p><p>基于生成器的协程应该使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.coroutine" target="_blank" rel="noopener"><code>@asyncio.coroutine</code></a> 装饰，虽然这并非强制。</p><ul><li><p><a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a>`</p><p>用来标记基于生成器的协程的装饰器。此装饰器使得旧式的基于生成器的协程能与 async/await 代码相兼容:</p><p>此装饰器使得旧式的基于生成器的协程能与 async/await 代码相兼容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">old_style_coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> old_style_coroutine()</span><br></pre></td></tr></table></figure><p>此装饰器不应该被用于 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 协程。</p><p> 从3.8版本被废弃, 将于3.10版本移除:* 使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 代替。</p></li><li><p><code>asyncio.iscoroutine</code>(<em>obj</em>)</p><p>如果 <em>obj</em> 是一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程对象</a> 则返回 <code>True</code>。此方法不同于 <a href="https://docs.python.org/zh-cn/3.8/library/inspect.html#inspect.iscoroutine" target="_blank" rel="noopener"><code>inspect.iscoroutine()</code></a> 因为它对基于生成器的协程返回 <code>True</code>。</p></li><li><p><code>asyncio.iscoroutinefunction</code>(<em>func</em>)</p><p>如果 <em>func</em> 是一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程函数</a> 则返回 <code>True</code>。此方法不同于 <a href="https://docs.python.org/zh-cn/3.8/library/inspect.html#inspect.iscoroutinefunction" target="_blank" rel="noopener"><code>inspect.iscoroutinefunction()</code></a> 因为它对以 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.coroutine" target="_blank" rel="noopener"><code>@coroutine</code></a> 装饰的基于生成器的协程函数返回 <code>True</code>。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>转自 <a href="https://www.zhihu.com/question/35139020" target="_blank" rel="noopener">python协程</a></p><p>作者：侠三十六</p><p><strong>协程</strong></p><p>首先要明确，线程和进程都是系统帮咱们开辟的，不管是thread还是process他内部都是调用的系统的API,而对于协程来说它和系统毫无关系;</p><p>协程不同于线程的是，线程是抢占式的调度，而协程是协同式的调度，也就是说，协程需要自己做调度。</p><p>他就和程序员有关系，对于线程和进程来说，调度是由CPU来决定调度的;</p><p>对于协程来说，程序员就是上帝，你想让谁执行到哪里他就执行到哪里;</p><p>协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。</p><p><strong>适用场景：</strong>其实在其他语言中，协程的其实是意义不大的多线程即可已解决I/O的问题，但是在python因为他有GIL（Global Interpreter Lock 全局解释器锁 ）在同一时间只有一个线程在工作，所以：如果一个线程里面I/O操作特别多，协程就比较适用;</p><p>协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程。</p><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：</p><p>协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</p><p><strong>协程的好处：</strong></p><p>无需线程上下文切换的开销</p><p>无需原子操作锁定及同步的开销</p><p>方便切换控制流，简化编程模型</p><p>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</p><p><strong>缺点：</strong></p><p>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</p><p>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-coroutines-协程&quot;&gt;&lt;a href=&quot;#python-标准库-coroutines-协程&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 coroutines 协程&quot;&gt;&lt;/a&gt;python 标准库 coroutines 协程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200213_coroutine.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="coroutines" scheme="https://pinghailinfeng.gitee.io/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>python standard library weakref</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/11/python-standard-library-weakref/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/11/python-standard-library-weakref/</id>
    <published>2020-02-10T22:57:22.000Z</published>
    <updated>2020-02-11T13:27:57.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-weakref-弱引用"><a href="#python-标准库-weakref-弱引用" class="headerlink" title="python 标准库 weakref 弱引用"></a>python 标准库 weakref 弱引用</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/compress.jpg?raw=true" alt></p><a id="more"></a><p>通过<code>google Insights</code> 优化,我把图片进行了压缩,明显速度提升了15%，接下来压缩css和js.</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/weakref.py" target="_blank" rel="noopener">Lib/weakref.py</a> </p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块允许Python程序员创建对象的 <em>weak references</em> 。</p><p>在下文中，术语 <em>referent</em> 表示由弱引用引用的对象。</p><p>对对象的弱引用不能保证对象存活：当对像的引用只剩弱引用时， <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-garbage-collection" target="_blank" rel="noopener">garbage collection</a> 可以销毁引用并将其内存重用于其他内容。但是，在实际销毁对象之前，即使没有强引用，弱引用也一直能返回该对象。</p><p>弱引用的主要用途是实现保存大对象的高速缓存或映射，但又并希望大对象仅仅因为它出现在高速缓存或映射中而保持存活。</p><p>例如，如果您有许多大型二进制图像对象，则可能希望将名称与每个对象关联起来。如果您使用Python字典将名称映射到图像，或将图像映射到名称，则图像对象将保持活动状态，因为它们在字典中显示为值或键。 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块提供的 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 类可以替代Python字典，使用弱引用来构造映射，这些映射不会仅仅因为它们出现在映射对象中而使对象保持存活。例如，如果一个图像对象是 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 中的值，那么当对该图像对象的剩余引用是弱映射对象所持有的弱引用时，垃圾回收可以回收该对象并将其在弱映射对象中相应的条目删除。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 在它们的实现中使用弱引用，在弱引用上设置回调函数，当键或值被垃圾回收回收时通知弱字典。 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakSet" target="_blank" rel="noopener"><code>WeakSet</code></a> 实现了 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 接口，但像 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 一样，只持有其元素的弱引用。`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize" target="_blank" rel="noopener"><code>finalize</code></a> 提供了注册一个对象被垃圾收集时要调用的清理函数的方式。这比在原始弱引用上设置回调函数更简单，因为模块会自动确保对象被回收前终结器一直保持存活。</p><p>这些弱容器类型之一或者 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize" target="_blank" rel="noopener"><code>finalize</code></a> 就是大多数程序所需要的 - 通常不需要直接创建自己的弱引用。<a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块暴露了低级机制，以便于高级用途。</p><p>并非所有对象都可以被弱引用；可以被弱引用的对象包括类实例，用 Python（而不是用 C）编写的函数，实例方法、集合、冻结集合，某些 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">文件对象</a>，<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">生成器</a>，类型对象，套接字，数组，双端队列，正则表达式模式对象以及代码对象等。</p><p><em>在 3.2 版更改:</em> 添加了对thread.lock，threading.Lock和代码对象的支持。</p><p>几个内建类型如 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 不直接支持弱引用，但可以通过子类化添加支持:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">obj = Dict(red=<span class="number">1</span>, green=<span class="number">2</span>, blue=<span class="number">3</span>)   <span class="comment"># this object is weak referenceable</span></span><br></pre></td></tr></table></figure><p><strong>CPython implementation detail:</strong> 其他内置类型例如 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#tuple" target="_blank" rel="noopener"><code>tuple</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 不支持弱引用，即使通过子类化也不支持。</p><p>Extension types can easily be made to support weak references; see <a href="https://docs.python.org/zh-cn/3.8/extending/newtypes.html#weakref-support" target="_blank" rel="noopener">Weak Reference Support</a>.</p><ul><li><p><em>class</em> <code>weakref.`</code>ref`(<em>object</em>[, <em>callback</em>])</p><p>返回对 <em>对象</em> 的弱引用。如果原始对象仍然存活，则可以通过调用引用对象来检索原始对象；如果引用的原始对象不再存在，则调用引用对象将得到 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 。如果提供了 <em>回调</em> 而且值不是 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> ，并且返回的弱引用对象仍然存活，则在对象即将终结时将调用回调;弱引用对象将作为回调的唯一参数传递；指示物将不再可用。</p><p>许多弱引用也允许针对相同对象来构建。 为每个弱引用注册的回调将按从最近注册的回调到最早注册的回调的顺序被调用。</p><p>回调所引发的异常将记录于标准错误输出，但无法被传播；它们会按与对象的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法所引发的异常相同的方式被处理。</p><p>如果 <em>object</em> 可哈希，则弱引用也为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a>。 即使在 <em>object</em> 被删除之后它们仍将保持其哈希值。 如果 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#hash" target="_blank" rel="noopener"><code>hash()</code></a> 在 <em>object</em> 被删除之后才首次被调用，则该调用将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p><p>弱引用支持相等检测，但不支持排序比较。 如果被引用对象仍然存在，两个引用具有与它们的被引用对象一致的相等关系（无论 <em>callback</em> 是否相同）。 如果删除了任一被引用对象，则仅在两个引用对象为同一对象时两者才相等。</p><p>这是一个可子类化的类型而非一个工厂函数。</p><ul><li><p><strong><strong>callback</strong></strong> </p><p>这个只读属性会返回当前关联到弱引用的回调。 如果回调不存在或弱引用的被引用对象已不存在，则此属性的值为 <code>None</code>。 </p></li></ul></li><li><p><code>weakref.`</code>proxy`(<em>object</em>[, <em>callback</em>]) </p><p>返回 <em>object</em> 的一个使用弱引用的代理。 此函数支持在大多数上下文中使用代理，而不要求显式地对所使用的弱引用对象解除引用。 返回的对象类型将为 <code>ProxyType</code> 或 <code>CallableProxyType</code>，具体取决于 <em>object</em> 是否可调用。 Proxy 对象不是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a> 对象，无论被引用对象是否可哈希；这可避免与它们的基本可变性质相关的多种问题，并可防止它们被用作字典键。 <em>callback</em> 与 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref()</code></a> 函数的同名形参含义相同。</p><p><em>在 3.8 版更改:</em> 扩展代理对象所支持的运算符，包括矩阵乘法运算符 <code>@</code> 和 <code>@=</code>。</p></li><li><p><code>weakref.`</code>getweakrefcount`(<em>object</em>) </p><p>返回指向 <em>object</em> 的弱引用和代理的数量。 </p></li><li><p><code>weakref.`</code>getweakrefs`(<em>object</em>) </p><p>返回由指向 <em>object</em> 的所有弱引用和代理构成的列表。 </p></li><li><p><em>class</em> <code>weakref.`</code>WeakKeyDictionary`([<em>dict</em>]) </p><p>弱引用键的映射类。 当不再有对键的强引用时字典中的条目将被丢弃。 这可被用来将额外数据关联到一个应用中其他部分所拥有的对象而无需在那些对象中添加属性。 这对于重载了属性访问的对象来说特别有用。 </p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 对象具有一个额外方法可以直接公开内部引用。 这些引用不保证在它们被使用时仍然保持“存活”，因此这些引用的调用结果需要在使用前进行检测。 此方法可用于避免创建会导致垃圾回收器将保留键超出实际需要时长的引用。 </p></li><li><p><code>WeakKeyDictionary.`</code>keyrefs`() </p><p>返回包含对键的弱引用的可迭代对象。 </p></li><li><p><em>class</em> <code>weakref.`</code>WeakValueDictionary`([<em>dict</em>]) </p><p>弱引用值的映射类。 当不再有对键的强引用时字典中的条目将被丢弃。 </p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 对象具有一个额外方法，此方法存在与 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 对象的 <code>keyrefs()</code> 方法相同的问题。 </p></li><li><p><code>WeakValueDictionary.`</code>valuerefs`() </p><p> 返回包含对值的弱引用的可迭代对象。 </p></li><li><p><em>class</em> <code>weakref.`</code>WeakSet`([<em>elements</em>]) </p><p>保持对其元素弱引用的集合类。 当不再有对某个元素的强引用时元素将被丢弃。 </p></li><li><p><em>class</em> <code>weakref.`</code>WeakMethod`(<em>method</em>) </p><p>一个模拟对绑定方法（即在类中定义并在实例中查找的方法）进行弱引用的自定义 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref</code></a> 子类。 由于绑定方法是临时性的，标准弱引用无法保持它。 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakMethod" target="_blank" rel="noopener"><code>WeakMethod</code></a> 包含特别代码用来重新创建绑定方法，直到对象或初始函数被销毁: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"method called!"</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = weakref.ref(c.method)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = weakref.WeakMethod(c.method)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()</span><br><span class="line">&lt;bound method C.method of &lt;__main__.C object at <span class="number">0x7fc859830220</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()()</span><br><span class="line">method called!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> c</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.collect()</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p><em>class</em> <code>weakref.`</code>finalize`(<em>obj</em>, <em>func</em>, <strong>args<em>, </em></strong>kwargs*) </p><p>返回一个可调用的终结器对象，该对象将在 <em>obj</em> 作为垃圾回收时被调用。 与普通的弱引用不同，终结器将总是存活，直到引用对象被回收，这极大地简化了生存期管理。</p><p>终结器总是被视为 <em>存活</em> 直到它被调用（显式调用或在垃圾回收时隐式调用），调用之后它将 <em>死亡</em>。 调用存活的终结器将返回 <code>func(*arg, **kwargs)</code> 的求值结果，而调用死亡的终结器将返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p><p>在垃圾收集期间由终结器回调所引发异常将显示于标准错误输出，但无法被传播。 它们会按与对象的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法或弱引用的回调所引发异常相同的方式被处理。</p><p>当程序退出时，剩余的存活终结器会被调用，除非它们的 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 属性已被设为假值。 它们会按与创建时相反的顺序被调用。</p><p>终结器在 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-interpreter-shutdown" target="_blank" rel="noopener">interpreter shutdown</a> 的后期绝不会发起调用其回调函数，此时模块全局变量很可能已被替换为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p><ul><li><p><code>__call__</code>()</p><p>如果 <em>self</em> 为存活状态则将其标记为已死亡，并返回调用 <code>func(*args, **kwargs)</code> 的结果。 如果 <em>self</em> 已死亡则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p></li><li><p><code>detach</code>()</p><p>如果 <em>self</em> 为存活状态则将其标记为已死亡，并返回元组 <code>(obj, func, args, kwargs)</code>。 如果 <em>self</em> 已死亡则返 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p></li><li><p><code>peek</code>()</p><p>如果 <em>self</em> 为存活状态则返回元组 <code>(obj, func, args, kwargs)</code>。 如果 <em>self</em> 已死亡则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p></li><li><p><code>alive</code></p><p>如果终结器为存活状态则该特征属性为真值，否则为假值。</p></li><li><p><code>atexit</code></p><p>一个可写的布尔型特征属性，默认为真值。 当程序退出时，它会调用所有 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize.atexit" target="_blank" rel="noopener"><code>atexit</code></a> 为真值的剩余存活终结器。 它们会按与创建时相反的顺序被调用。</p></li></ul></li><li><p><code>weakref.`</code>ReferenceType`</p><p>弱引用对象的类型对象。</p></li><li><p><code>weakref.`</code>ProxyType`</p><p>不可调用对象的代理的类型对象。</p></li><li><p><code>weakref.`</code>CallableProxyType`</p><p>可调用对象的代理的类型对象。</p></li><li><p><code>weakref.`</code>ProxyTypes`</p><p>包含所有代理的类型对象的序列。 这可以用于更方便地检测一个对象是否是代理，而不必依赖于两种代理对象的名称。</p></li><li><p><em>exception</em> <code>weakref.`</code>ReferenceError`</p><p>当一个代理对象被使用但其下层的对象已被收集时所引发的异常。 这等价于标准的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ReferenceError" target="_blank" rel="noopener"><code>ReferenceError</code></a> 异常。</p></li></ul><blockquote><p><a href="https://www.python.org/dev/peps/pep-0205" target="_blank" rel="noopener"><strong>PEP 205</strong></a> - 弱引用</p><p>此特性的提议和理由，包括早期实现的链接和其他语言中类似特性的相关信息。</p></blockquote><h2 id="弱引用对象"><a href="#弱引用对象" class="headerlink" title="弱引用对象"></a>弱引用对象</h2><p>弱引用对象没有 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref.__callback__" target="_blank" rel="noopener"><code>ref.__callback__</code></a> 以外的方法和属性。 一个弱引用对象如果存在，就允许通过调用它来获取引用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Object</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = weakref.ref(o)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o2 = r()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o <span class="keyword">is</span> o2</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>如果引用已不存在，则调用引用对象将返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> o, o2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(r())</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><p>检测一个弱引用对象是否仍然存在应该使用表达式 <code>ref() is not None</code>。 通常，需要使用引用对象的应用代码应当遵循这样的模式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># r is a weak reference object</span></span><br><span class="line">o = r()</span><br><span class="line"><span class="keyword">if</span> o <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># referent has been garbage collected</span></span><br><span class="line">    print(<span class="string">"Object has been deallocated; can't frobnicate."</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Object is still live!"</span>)</span><br><span class="line">    o.do_something_useful()</span><br></pre></td></tr></table></figure><p>使用单独的“存活”测试会在多线程应用中制造竞争条件；其他线程可能导致某个弱引用在该弱引用被调用前就失效；上述的写法在多线程应用和单线程应用中都是安全的。</p><p>特别版本的 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref</code></a> 对象可以通过子类化来创建。 在 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 的实现中就使用了这种方式来减少映射中每个条目的内存开销。 这对于将附加信息关联到引用的情况最为适用，但也可以被用于在调用中插入额外处理来提取引用。</p><p>这个例子演示了如何将 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref</code></a> 的一个子类用于存储有关对象的附加信息并在引用被访问时影响其所返回的值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedRef</span><span class="params">(weakref.ref)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ob, callback=None, /, **annotations)</span>:</span></span><br><span class="line">        super(ExtendedRef, self).__init__(ob, callback)</span><br><span class="line">        self.__counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> annotations.items():</span><br><span class="line">            setattr(self, k, v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a pair containing the referent and the number of</span></span><br><span class="line"><span class="string">        times the reference has been called.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ob = super(ExtendedRef, self).__call__()</span><br><span class="line">        <span class="keyword">if</span> ob <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.__counter += <span class="number">1</span></span><br><span class="line">            ob = (ob, self.__counter)</span><br><span class="line">        <span class="keyword">return</span> ob</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这个简单的例子演示了一个应用如何使用对象 ID 来提取之前出现过的对象。 然后对象的 ID 可以在其它数据结构中使用，而无须强制对象保持存活，但处于存活状态的对象也仍然可以通过 ID 来提取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line">_id2obj_dict = weakref.WeakValueDictionary()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remember</span><span class="params">(obj)</span>:</span></span><br><span class="line">    oid = id(obj)</span><br><span class="line">    _id2obj_dict[oid] = obj</span><br><span class="line">    <span class="keyword">return</span> oid</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">id2obj</span><span class="params">(oid)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _id2obj_dict[oid]</span><br></pre></td></tr></table></figure><h2 id="终结器对象"><a href="#终结器对象" class="headerlink" title="终结器对象"></a>终结器对象</h2><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize" target="_blank" rel="noopener"><code>finalize</code></a> 的主要好处在于它能更简便地注册回调函数，而无须保留所返回的终结器对象。 例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Object</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kenny = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weakref.finalize(kenny, <span class="keyword">print</span>, <span class="string">"You killed Kenny!"</span>)  </span><br><span class="line">&lt;finalize object at ...; <span class="keyword">for</span> <span class="string">'Object'</span> at ...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> kenny</span><br><span class="line">You killed Kenny!</span><br></pre></td></tr></table></figure><p>终结器也可以被直接调用。 但是终结器最多只能对回调函数发起一次调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(x, y, z)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"CALLBACK"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y + z</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = weakref.finalize(obj, callback, <span class="number">1</span>, <span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> f.alive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> f() == <span class="number">6</span></span><br><span class="line">CALLBACK</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="keyword">not</span> f.alive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()                     <span class="comment"># callback not called because finalizer dead</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> obj                 <span class="comment"># callback not called because finalizer dead</span></span><br></pre></td></tr></table></figure><p>你可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize.detach" target="_blank" rel="noopener"><code>detach()</code></a> 方法来注销一个终结器。 该方法将销毁终结器并返回其被创建时传给构造器的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = weakref.finalize(obj, callback, <span class="number">1</span>, <span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.detach()                                           </span><br><span class="line">(&lt;...Object object ...&gt;, &lt;function callback ...&gt;, (<span class="number">1</span>, <span class="number">2</span>), &#123;<span class="string">'z'</span>: <span class="number">3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newobj, func, args, kwargs = _</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="keyword">not</span> f.alive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> newobj <span class="keyword">is</span> obj</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> func(*args, **kwargs) == <span class="number">6</span></span><br><span class="line">CALLBACK</span><br></pre></td></tr></table></figure><p>除非你将 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize.atexit" target="_blank" rel="noopener"><code>atexit</code></a> 属性设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>，否则终结器在程序退出时如果仍然存活就将被调用。 例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weakref.finalize(obj, <span class="keyword">print</span>, <span class="string">"obj dead or exiting"</span>)</span><br><span class="line">&lt;finalize object at ...; <span class="keyword">for</span> <span class="string">'Object'</span> at ...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exit()</span><br><span class="line">obj dead <span class="keyword">or</span> exiting</span><br></pre></td></tr></table></figure><h2 id="比较终结器与-del-方法"><a href="#比较终结器与-del-方法" class="headerlink" title="比较终结器与 __del__() 方法"></a>比较终结器与 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法</h2><p>假设我们想创建一个类，用它的实例来代表临时目录。 当以下事件中的某一个发生时，这个目录应当与其内容一起被删除：</p><ul><li>对象被作为垃圾回收，</li><li>对象的 <code>remove()</code> 方法被调用，或</li><li>程序退出。</li></ul><p>我们可以尝试使用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法来实现这个类，如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TempDir</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = tempfile.mkdtemp()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            shutil.rmtree(self.name)</span><br><span class="line">            self.name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removed</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.remove()</span><br></pre></td></tr></table></figure><p>从 Python 3.4 开始，<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法不会再阻止循环引用被作为垃圾回收，并且模块全局变量在 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-interpreter-shutdown" target="_blank" rel="noopener">interpreter shutdown</a> 期间不会被强制设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。 因此这段代码在 CPython 上应该会正常运行而不会出现任何问题。</p><p>然而，<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法的处理会严重地受到具体实现的影响，因为它依赖于解释器垃圾回收实现方式的内部细节。</p><p>更健壮的替代方式可以是定义一个终结器，只引用它所需要的特定函数和对象，而不是获取对整个对象状态的访问权:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TempDir</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = tempfile.mkdtemp()</span><br><span class="line">        self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._finalizer()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removed</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._finalizer.alive</span><br></pre></td></tr></table></figure><p>像这样定义后，我们的终结器将只接受一个对其完成正确清理目录任务所需细节的引用。 如果对象一直未被作为垃圾回收，终结器仍会在退出时被调用。</p><p>基于弱引用的终结器还具有另一项优势，就是它们可被用来为定义由第三方控制的类注册终结器，例如当一个模块被卸载时运行特定代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref, sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unloading_module</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># implicit reference to the module globals from the function body</span></span><br><span class="line">weakref.finalize(sys.modules[__name__], unloading_module)</span><br></pre></td></tr></table></figure><p><strong>备注</strong>:</p><p> 如果当程序退出时你恰好在守护线程中创建终结器对象，则有可能该终结器不会在退出时被调用。 但是，在一个守护线程中 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#atexit.register" target="_blank" rel="noopener"><code>atexit.register()</code></a>, <code>try: ... finally: ...</code> 和 <code>with: ...</code> 同样不能保证执行清理。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-weakref-弱引用&quot;&gt;&lt;a href=&quot;#python-标准库-weakref-弱引用&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 weakref 弱引用&quot;&gt;&lt;/a&gt;python 标准库 weakref 弱引用&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/compress.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="weakref" scheme="https://pinghailinfeng.gitee.io/tags/weakref/"/>
    
  </entry>
  
  <entry>
    <title>python standard library cmath</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/10/python-standard-library-cmath/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/10/python-standard-library-cmath/</id>
    <published>2020-02-10T04:21:53.000Z</published>
    <updated>2020-02-10T06:05:38.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-cmath"><a href="#python-标准库-cmath" class="headerlink" title="python 标准库 cmath"></a>python 标准库 cmath</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200210_butterfly.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>患难可以试验一个人的品格；非常的境遇方才可以显出非常的气节；风平浪静的海面，所有船只都可以并驱竞胜；命运的铁拳击中要害的时候，只有大勇大智的人才能够处之泰然。</p><p>​                                                                                                                                             –    莎士比亚</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>这一模块提供了一些关于复数的数学函数。 该模块的函数的参数为整数、浮点数或复数。 这些函数的参数也可为一个拥有 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__complex__" target="_blank" rel="noopener"><code>__complex__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__float__" target="_blank" rel="noopener"><code>__float__()</code></a> 方法的 Python 对象，这些方法分别用于将对象转换为复数和浮点数，这些函数作用于转换后的结果。</p><h2 id="到极坐标和从极坐标的转换"><a href="#到极坐标和从极坐标的转换" class="headerlink" title="到极坐标和从极坐标的转换"></a>到极坐标和从极坐标的转换</h2><p>使用 <em>矩形坐标</em> 或 <em>笛卡尔坐标</em> 在内部存储 Python 复数 <code>z</code>。 这完全取决于它的 <em>实部</em> <code>z.real</code> 和 <em>虚部</em> <code>z.imag</code>。 换句话说:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z == z.real + z.imag*<span class="number">1j</span></span><br></pre></td></tr></table></figure><p><em>极坐标</em> 提供了另一种复数的表示方法。在极坐标中，一个复数 <em>z</em> 由模量 <em>r</em> 和相位角 <em>phi</em> 来定义。模量 <em>r</em> 是从 <em>z</em> 到坐标原点的距离，而相位角 <em>phi</em> 是以弧度为单位的，逆时针的，从正X轴到连接原点和 <em>z</em> 的线段间夹角的角度。</p><p>下面的函数可用于原生直角坐标与极坐标的相互转换。</p><ul><li><p><code>cmath.phase</code>(<em>x</em>)</p><p>将 <em>x</em> 的相位 (也称为 <em>x</em> 的 <em>参数</em>) 返回为一个浮点数。<code>phase(x)</code> 相当于 <code>math.atan2(x.imag, x.real)</code>。 结果处于 [-<em>π</em>, <em>π</em>] 之间，以及这个操作的分支切断处于负实轴上，从上方连续。 在支持有符号零的系统上（这包涵大多数当前的常用系统），这意味着结果的符号与 <code>x.imag</code> 的符号相同，即使 <code>x.imag</code> 的值是 0:</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>phase(complex(<span class="number">-1.0</span>, <span class="number">0.0</span>))</span><br><span class="line"><span class="number">3.141592653589793</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phase(complex(<span class="number">-1.0</span>, <span class="number">-0.0</span>))</span><br><span class="line"><span class="number">-3.141592653589793</span></span><br></pre></td></tr></table></figure><ul><li><p><code>cmath.polar</code>(<em>x</em>)</p><p>在极坐标中返回 <em>x</em> 的表达方式。返回一个数对 <code>(r, phi)</code>，<em>r</em> 是 <em>x</em> 的模数，<em>phi</em> 是 <em>x</em> 的相位角。 <code>polar(x)</code> 相当于 <code>(abs(x), phase(x))</code>。</p></li><li><p><code>cmath.rect</code>(<em>r</em>, <em>phi</em>)</p><p>通过极坐标的 <em>r</em> 和 <em>phi</em> 返回复数 <em>x</em>。相当于 <code>r * (math.cos(phi) + math.sin(phi)*1j)</code>。</p></li></ul><h2 id="幂函数与对数函数"><a href="#幂函数与对数函数" class="headerlink" title="幂函数与对数函数"></a>幂函数与对数函数</h2><ul><li><p><code>cmath.exp</code>(<em>x</em>)</p><p>返回 <em>e</em> 的 <em>x</em> 次方，<em>e</em> 是自然对数的底数。</p></li><li><p><code>cmath.log</code>(<em>x</em>[, <em>base</em>])</p><p>返回给定 <em>base</em> 的 <em>x</em> 的对数。如果没有给定 <em>base</em>，返回 <em>x</em> 的自然对数。 从 0 到 -∞ 存在一个分歧点，沿负实轴之上连续。</p></li><li><p><code>cmath.log10</code>(<em>x</em>)</p><p>返回底数为 10 的 <em>x</em> 的对数。它具有与 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#cmath.log" target="_blank" rel="noopener"><code>log()</code></a> 相同的分歧点。</p></li><li><p><code>cmath.sqrt</code>(<em>x</em>)</p><p>返回 <em>x</em> 的平方根。 它具有与 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#cmath.log" target="_blank" rel="noopener"><code>log()</code></a> 相同的分歧点。</p></li></ul><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><ul><li><p><code>cmath.acos</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反余弦。这里有两个分歧点：一个沿着实轴从 1 向右延伸到 ∞，从下面连续延伸。另外一个沿着实轴从 -1 向左延伸到 -∞，从上面连续延伸。</p></li><li><p><code>cmath.asin</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反正弦。它与 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#cmath.acos" target="_blank" rel="noopener"><code>acos()</code></a> 有相同的分歧点。</p></li><li><p><code>cmath.atan</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反正切。它具有两个分歧点：一个沿着虚轴从 <code>1j</code> 延伸到 <code>∞j</code>，向右持续延伸。另一个是沿着虚轴从 <code>-1j</code> 延伸到 <code>-∞j</code> ，向左持续延伸。</p></li><li><p><code>cmath.cos</code>(<em>x</em>)</p><p>返回 <em>x</em> 的余弦。</p></li><li><p><code>cmath.sin</code>(<em>x</em>)</p><p>返回 <em>x</em> 的正弦。</p></li><li><p><code>cmath.tan</code>(<em>x</em>)</p><p>返回 <em>x</em> 的正切。</p></li></ul><h2 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h2><ul><li><p><code>cmath.acosh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反双曲余弦。它有一个分歧点沿着实轴从 1 到 -∞ 向左延伸，从上方持续延伸。</p></li><li><p><code>cmath.asinh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反双曲正弦。它有两个分歧点：一个沿着虚轴从 <code>1j</code> 向右持续延伸到 <code>∞j</code>。另一个是沿着虚轴从 <code>-1j</code> 向左持续延伸到 <code>-∞j</code>。</p></li><li><p><code>cmath.atanh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反双曲正切。它有两个分歧点：一个是沿着实轴从 <code>1</code> 延展到 <code>∞</code>，从下面持续延展。另一个是沿着实轴从 <code>-1</code> 延展到 <code>-∞</code>，从上面持续延展。</p></li><li><p><code>cmath.cosh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的双曲余弦值。</p></li><li><p><code>cmath.sinh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的双曲正弦值。</p></li><li><p><code>cmath.tanh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的双曲正切值。</p></li></ul><h2 id="分类函数"><a href="#分类函数" class="headerlink" title="分类函数"></a>分类函数</h2><ul><li><p><code>cmath.isfinite</code>(<em>x</em>)</p><p>如果 <em>x</em> 的实部和虚部都是有限的，则返回 <code>True</code>，否则返回 <code>False</code>。<em>3.2 新版功能.</em></p></li><li><p><code>cmath.isinf</code>(<em>x</em>)</p><p>如果 <em>x</em> 的实部或者虚部是无穷大的，则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p><code>cmath.isnan</code>(<em>x</em>)</p><p>如果 <em>x</em> 的实部或者虚部是 NaN，则返回 <code>True</code> ，否则返回 <code>False</code>。</p></li><li><p><code>cmath.isclose</code>(<em>a</em>, <em>b</em>, <em>**, </em>rel_tol=1e-09<em>, </em>abs_tol=0.0*)</p><p>若 <em>a</em> 和 <em>b</em> 的值比较接近则返回 <code>True</code>，否则返回 <code>False</code>。根据给定的绝对和相对容差确定两个值是否被认为是接近的。<em>rel_tol</em> 是相对容差 —— 它是 <em>a</em> 和 <em>b</em> 之间允许的最大差值，相对于 <em>a</em> 或 <em>b</em> 的较大绝对值。例如，要设置5％的容差，请传递 <code>rel_tol=0.05</code> 。默认容差为 <code>1e-09</code>，确保两个值在大约9位十进制数字内相同。 <em>rel_tol</em> 必须大于零。<em>abs_tol</em> 是最小绝对容差 —— 对于接近零的比较很有用。 <em>abs_tol</em> 必须至少为零。如果没有错误发生，结果将是： <code>abs(a-b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)</code> 。IEEE 754特殊值 <code>NaN</code> ， <code>inf</code> 和<code>-inf</code> 将根据IEEE规则处理。具体来说， <code>NaN</code> 不被认为接近任何其他值，包括 <code>NaN</code> 。 <code>inf</code> 和 <code>-inf</code> 只被认为接近自己。</p><blockquote><p><a href="https://www.python.org/dev/peps/pep-0485" target="_blank" rel="noopener"><strong>PEP 485</strong></a> —— 用于测试近似相等的函数</p></blockquote></li></ul><h2 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h2><ul><li><p><code>cmath.pi</code></p><p>数学常数 <em>π</em> ，作为一个浮点数。</p></li><li><p><code>cmath.e</code></p><p>数学常数 <em>e</em> ，作为一个浮点数。</p></li><li><p><code>cmath.tau</code></p><p>数学常数 <em>τ</em> ，作为一个浮点数。<em>3.6 新版功能.</em></p></li><li><p><code>cmath.inf</code></p><p>浮点正无穷大。相当于 <code>float(&#39;inf&#39;)</code>。<em>3.6 新版功能.</em></p></li><li><p><code>cmath.infj</code></p><p>具有零实部和正无穷虚部的复数。相当于 <code>complex(0.0, float(&#39;inf&#39;))</code>。<em>3.6 新版功能.</em></p></li><li><p><code>cmath.nan</code></p><p>浮点“非数字”（NaN）值。相当于 <code>float(&#39;nan&#39;)</code>。<em>3.6 新版功能.</em></p></li><li><p><code>cmath.nanj</code></p><p>具有零实部和 NaN 虚部的复数。相当于 <code>complex(0.0, float(&#39;nan&#39;))</code>。</p></li></ul><p>请注意，函数的选择与模块 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#module-math" target="_blank" rel="noopener"><code>math</code></a> 中的函数选择相似，但不完全相同。 拥有两个模块的原因是因为有些用户对复数不感兴趣，甚至根本不知道它们是什么。它们宁愿 <code>math.sqrt(-1)</code> 引发异常，也不想返回一个复数。 另请注意，被 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#module-cmath" target="_blank" rel="noopener"><code>cmath</code></a> 定义的函数始终会返回一个复数，尽管答案可以表示为一个实数（在这种情况下，复数的虚数部分为零）。</p><p>关于分歧点的注释：它们是沿着给定函数无法连续的曲线。它们是许多复杂函数的必要特征。假设您需要使用复杂函数进行计算，您将了解分歧点。请参阅几乎所有关于复杂变量的（不太基本）的书来进行启发。关于分歧点数值目的的正确选择信息，应提供以下良好参考.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-cmath&quot;&gt;&lt;a href=&quot;#python-标准库-cmath&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 cmath&quot;&gt;&lt;/a&gt;python 标准库 cmath&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200210_butterfly.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="cmath" scheme="https://pinghailinfeng.gitee.io/tags/cmath/"/>
    
  </entry>
  
  <entry>
    <title>python standard library fractions</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/09/python-standard-library-fractions/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/09/python-standard-library-fractions/</id>
    <published>2020-02-09T14:56:42.000Z</published>
    <updated>2020-02-10T03:35:04.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-fractions-分数"><a href="#python-标准库-fractions-分数" class="headerlink" title="python 标准库 fractions 分数"></a>python 标准库 fractions 分数</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200210_hope.jpg?raw=true" alt></p><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/fractions.py" target="_blank" rel="noopener">Lib/fractions.py</a></p><h2 id="模块概述"><a href="#模块概述" class="headerlink" title="模块概述"></a>模块概述</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#module-fractions" target="_blank" rel="noopener"><code>fractions</code></a> 模块支持分数运算。</p><p>分数实例可以由一对整数，一个分数，或者一个字符串构建而成。</p><ul><li><p><em>class</em> <code>fractions.Fraction</code>(<em>numerator=0</em>, <em>denominator=1</em>)</p></li><li><p><em>class</em> <code>fractions.Fraction</code>(<em>other_fraction</em>)</p></li><li><p><em>class</em> <code>fractions.Fraction</code>(<em>float</em>)</p></li><li><p><em>class</em> <code>fractions.Fraction</code>(<em>decimal</em>)</p></li><li><p><em>class</em> <code>fractions.Fraction</code>(<em>string</em>)</p><p>第一个版本要求 <em>numerator</em> 和 <em>denominator</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational" target="_blank" rel="noopener"><code>numbers.Rational</code></a> 的实例，并返回一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 实例，其值为 <code>numerator/denominator</code>。 如果 <em>denominator</em> 为 <code>0</code> 将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ZeroDivisionError" target="_blank" rel="noopener"><code>ZeroDivisionError</code></a>。 第二个版本要求 <em>other_fraction</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational" target="_blank" rel="noopener"><code>numbers.Rational</code></a> 的实例，并返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 实例且与传入值相等。 下两个版本接受 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>decimal.Decimal</code></a> 的实例，并返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 实例且与传入值完全相等。 请注意由于二进制浮点数通常存在的问题 (参见 <a href="https://docs.python.org/zh-cn/3.8/tutorial/floatingpoint.html#tut-fp-issues" target="_blank" rel="noopener">浮点算术：争议和限制</a>)，<code>Fraction(1.1)</code> 的参数并不会精确等于 11/10，因此 <code>Fraction(1.1)</code> 也 <em>不会</em> 返回用户所期望的 <code>Fraction(11, 10)</code>。 （请参阅下文中 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction.limit_denominator" target="_blank" rel="noopener"><code>limit_denominator()</code></a> 方法的文档。） 构造器的最后一个版本接受一个字符串或 unicode 实例。 此实例的通常形式为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sign] numerator [<span class="string">'/'</span> denominator]</span><br></pre></td></tr></table></figure><p>其中的可选项 <code>sign</code> 可以为 ‘+’ 或 ‘-‘ 并且 <code>numerator</code> 和 <code>denominator</code> (如果存在) 是十进制数码的字符串。 此外，<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 构造器所接受的任何表示一个有限值的字符串也都为 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 构造器所接受。 不论哪种形式的输入字符串也都可以带有前缀和/或后缀的空格符。 这里是一些示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">16</span>, <span class="number">-10</span>)</span><br><span class="line">Fraction(<span class="number">-8</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">123</span>)</span><br><span class="line">Fraction(<span class="number">123</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction()</span><br><span class="line">Fraction(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'3/7'</span>)</span><br><span class="line">Fraction(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">' -3/7 '</span>)</span><br><span class="line">Fraction(<span class="number">-3</span>, <span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'1.414213 \t\n'</span>)</span><br><span class="line">Fraction(<span class="number">1414213</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'-.125'</span>)</span><br><span class="line">Fraction(<span class="number">-1</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'7e-6'</span>)</span><br><span class="line">Fraction(<span class="number">7</span>, <span class="number">1000000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">2.25</span>)</span><br><span class="line">Fraction(<span class="number">9</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">1.1</span>)</span><br><span class="line">Fraction(<span class="number">2476979795053773</span>, <span class="number">2251799813685248</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(Decimal(<span class="string">'1.1'</span>))</span><br><span class="line">Fraction(<span class="number">11</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 类继承自抽象基类 <a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Rational" target="_blank" rel="noopener"><code>numbers.Rational</code></a>，并实现了该类的所有方法和操作。 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 实例是可哈希的，并应当被视为不可变对象。 此外，<a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 还具有以下属性和方法：</p><ul><li><p><code>numerator</code></p><p>最简分数形式的分子。</p></li><li><p><code>denominator</code></p><p>最简分数形式的分母。</p></li><li><p><code>as_integer_ratio</code>()</p><p>返回由两个整数组成的元组，两数之比等于该分数的值且其分母为正数。<em>3.8 新版功能.</em></p></li><li><p><code>from_float</code>(<em>flt</em>) : classmethod</p><p>此类方法可构造一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 来表示 <em>flt</em> 的精确值，该参数必须是一个 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>。 请注意 <code>Fraction.from_float(0.3)</code> 的值并不等于 <code>Fraction(3, 10)</code>。</p></li><li><p><code>from_decimal</code>(<em>dec</em>) : classmethod</p><p>此类方法可构造一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 来表示 <em>dec</em> 的精确值，该参数必须是一个 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>decimal.Decimal</code></a> 实例。</p></li><li><p><code>limit_denominator</code>(<em>max_denominator=1000000</em>)</p><p>找到并返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 使得其值最接近 <code>self</code> 并且分母不大于 max_denominator。 此方法适用于找出给定浮点数的有理数近似值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="string">'3.1415926535897932'</span>).limit_denominator(<span class="number">1000</span>)</span><br><span class="line">Fraction(<span class="number">355</span>, <span class="number">113</span>)</span><br></pre></td></tr></table></figure><p>或是用来恢复被表示为一个浮点数的有理数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi, cos</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(cos(pi/<span class="number">3</span>))</span><br><span class="line">Fraction(<span class="number">4503599627370497</span>, <span class="number">9007199254740992</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(cos(pi/<span class="number">3</span>)).limit_denominator()</span><br><span class="line">Fraction(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fraction(<span class="number">1.1</span>).limit_denominator()</span><br><span class="line">Fraction(<span class="number">11</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>__floor__</code>()</p><p>返回最大的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> <code>&lt;= self</code>。 此方法也可通过 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.floor" target="_blank" rel="noopener"><code>math.floor()</code></a> 函数来使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> floor</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>floor(Fraction(<span class="number">355</span>, <span class="number">113</span>))</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p><code>__ceil__</code>()</p><p>返回最小的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> <code>&gt;= self</code>。 此方法也可通过 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.ceil" target="_blank" rel="noopener"><code>math.ceil()</code></a> 函数来使用。</p></li><li><p><code>__round__</code>()</p></li><li><p><code>__round__</code>(<em>ndigits</em>)</p><p>第一个版本返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 使得其值最接近 <code>self</code>，位值为二分之一时只对偶数舍入。第二个版本会将 <code>self</code> 舍入到最接近 <code>Fraction(1, 10**ndigits)</code> 的倍数（如果 <code>ndigits</code> 为负值则为逻辑运算），位值为二分之一时同样只对偶数舍入。 此方法也可通过 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#round" target="_blank" rel="noopener"><code>round()</code></a> 函数来使用</p></li></ul></li></ul><ul><li><p><code>fractions.gcd</code>(<em>a</em>, <em>b</em>)</p><p>返回整数 <em>a</em> 和 <em>b</em> 的最大公约数。如果 <em>a</em> 或 <em>b</em> 之一非零，则 <code>gcd(a, b)</code> 的绝对值是能同时整除 <em>a</em> 和 <em>b</em> 的最大整数。若 <em>b</em> 非零，则 <code>gcd(a,b)</code> 与 <em>b</em> 同号；否则返回值与 <em>a</em> 同号。<code>gcd(0, 0)</code> 返回 <code>0</code>。</p><p><em>3.5 版后已移除:</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#math.gcd" target="_blank" rel="noopener"><code>math.gcd()</code></a> 取代.</p></li></ul><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-fractions-分数&quot;&gt;&lt;a href=&quot;#python-标准库-fractions-分数&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 fractions 分数&quot;&gt;&lt;/a&gt;python 标准库 fractions 分数&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200210_hope.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="fractions" scheme="https://pinghailinfeng.gitee.io/tags/fractions/"/>
    
  </entry>
  
  <entry>
    <title>python standard library json</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/08/python-standard-library-json/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/08/python-standard-library-json/</id>
    <published>2020-02-08T03:53:06.000Z</published>
    <updated>2020-02-10T03:43:31.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-json"><a href="#python-标准库-json" class="headerlink" title="python 标准库 json"></a>python 标准库 json</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20191223_blog_6.jpg?raw=true" alt></p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=25706282&auto=0&height=66"></iframe><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/json/__init__.py" target="_blank" rel="noopener">Lib/json/<strong>init</strong>.py</a></p><p> <a href="http://json.org/" target="_blank" rel="noopener">JSON (JavaScript Object Notation)</a>，由 <a href="https://tools.ietf.org/html/rfc7159.html" target="_blank" rel="noopener"><strong>RFC 7159</strong></a> (which obsoletes <a href="https://tools.ietf.org/html/rfc4627.html" target="_blank" rel="noopener"><strong>RFC 4627</strong></a>) 和 <a href="http://www.ecma-international.org/publications/standards/Ecma-404.htm" target="_blank" rel="noopener">ECMA-404</a> 指定，是一个受 <a href="https://en.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a> 的对象字面量语法启发的轻量级数据交换格式，尽管它不仅仅是一个严格意义上的 JavaScript 的字集。</p><p> <a href="https://docs.python.org/zh-cn/3.8/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 提供了与标准库 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#module-marshal" target="_blank" rel="noopener"><code>marshal</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 相似的API接口。 </p><p> 对基本的 Python 对象层次结构进行编码： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps([<span class="string">'foo'</span>, &#123;<span class="string">'bar'</span>: (<span class="string">'baz'</span>, <span class="literal">None</span>, <span class="number">1.0</span>, <span class="number">2</span>)&#125;])</span><br><span class="line"><span class="string">'["foo", &#123;"bar": ["baz", null, 1.0, 2]&#125;]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(<span class="string">"\"foo\bar"</span>))</span><br><span class="line"><span class="string">"\"foo\bar"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(<span class="string">'\u1234'</span>))</span><br><span class="line"><span class="string">"\u1234"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(<span class="string">'\\'</span>))</span><br><span class="line"><span class="string">"\\"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(&#123;<span class="string">"c"</span>: <span class="number">0</span>, <span class="string">"b"</span>: <span class="number">0</span>, <span class="string">"a"</span>: <span class="number">0</span>&#125;, sort_keys=<span class="literal">True</span>))</span><br><span class="line">&#123;<span class="string">"a"</span>: <span class="number">0</span>, <span class="string">"b"</span>: <span class="number">0</span>, <span class="string">"c"</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io = StringIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dump([<span class="string">'streaming API'</span>], io)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io.getvalue()</span><br><span class="line"><span class="string">'["streaming API"]'</span></span><br></pre></td></tr></table></figure><p> 紧凑编码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &#123;<span class="string">'4'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">7</span>&#125;], separators=(<span class="string">','</span>, <span class="string">':'</span>))</span><br><span class="line"><span class="string">'[1,2,3,&#123;"4":5,"6":7&#125;]'</span></span><br></pre></td></tr></table></figure><p>美化输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(&#123;<span class="string">'4'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">7</span>&#125;, sort_keys=<span class="literal">True</span>, indent=<span class="number">4</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"4"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">"6"</span>: <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON解码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'["foo", &#123;"bar":["baz", null, 1.0, 2]&#125;]'</span>)</span><br><span class="line">[<span class="string">'foo'</span>, &#123;<span class="string">'bar'</span>: [<span class="string">'baz'</span>, <span class="literal">None</span>, <span class="number">1.0</span>, <span class="number">2</span>]&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'"\\"foo\\bar"'</span>)</span><br><span class="line"><span class="string">'"foo\x08ar'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>io = StringIO(<span class="string">'["streaming API"]'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.load(io)</span><br><span class="line">[<span class="string">'streaming API'</span>]</span><br></pre></td></tr></table></figure><p> 特殊JSON对象解码: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">as_complex</span><span class="params">(dct)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="string">'__complex__'</span> <span class="keyword">in</span> dct:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> complex(dct[<span class="string">'real'</span>], dct[<span class="string">'imag'</span>])</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> dct</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'&#123;"__complex__": true, "real": 1, "imag": 2&#125;'</span>,</span><br><span class="line"><span class="meta">... </span>    object_hook=as_complex)</span><br><span class="line">(<span class="number">1</span>+<span class="number">2j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'1.1'</span>, parse_float=decimal.Decimal)</span><br><span class="line">Decimal(<span class="string">'1.1'</span>)</span><br></pre></td></tr></table></figure><p>扩展 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder" target="_blank" rel="noopener"><code>JSONEncoder</code></a>: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ComplexEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, obj)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> isinstance(obj, complex):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> [obj.real, obj.imag]</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># Let the base class default method raise the TypeError</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> json.JSONEncoder.default(self, obj)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(<span class="number">2</span> + <span class="number">1j</span>, cls=ComplexEncoder)</span><br><span class="line"><span class="string">'[2.0, 1.0]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ComplexEncoder().encode(<span class="number">2</span> + <span class="number">1j</span>)</span><br><span class="line"><span class="string">'[2.0, 1.0]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(ComplexEncoder().iterencode(<span class="number">2</span> + <span class="number">1j</span>))</span><br><span class="line">[<span class="string">'[2.0'</span>, <span class="string">', 1.0'</span>, <span class="string">']'</span>]</span><br></pre></td></tr></table></figure><p> 从命令行使用 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#module-json.tool" target="_blank" rel="noopener"><code>json.tool</code></a> 来验证并美化输出： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="string">'&#123;"json":"obj"&#125;'</span> | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"json"</span>: <span class="string">"obj"</span></span><br><span class="line">&#125;</span><br><span class="line">$ echo <span class="string">'&#123;1.2:3.4&#125;'</span> | python -m json.tool</span><br><span class="line">Expecting property name enclosed <span class="keyword">in</span> double quotes: line <span class="number">1</span> column <span class="number">2</span> (char <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p> 详细文档请参见 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json-commandline" target="_blank" rel="noopener">命令行界面</a>。 </p><blockquote><p> JSON 是 <a href="http://yaml.org/" target="_blank" rel="noopener">YAML</a> 1.2 的一个子集。由该模块的默认设置生成的 JSON （尤其是默认的 “分隔符” 设置值）也是 YAML 1.0 and 1.1 的一个子集。因此该模块也能够用于序列化为 YAML。 </p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li><p><code>json.dump</code>(<em>obj</em>, <em>fp</em>, <strong><em>, </em>skipkeys=False<em>, </em>ensure_ascii=True<em>, </em>check_circular=True<em>, </em>allow_nan=True<em>, </em>cls=None<em>, </em>indent=None<em>, </em>separators=None<em>, </em>default=None<em>, </em>sort_keys=False<em>, </em></strong>kw*) </p><p> 使用这个 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#py-to-json-table" target="_blank" rel="noopener">转换表</a> 将 <em>obj</em> 序列化为 JSON 格式化流形式的 <em>fp</em> (支持 <code>.write()</code> 的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-like-object" target="_blank" rel="noopener">file-like object</a>)。 </p><p>如果 <em>skipkeys</em> 是 true （默认为 <code>False</code>），那么那些不是基本对象（包括 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#bool" target="_blank" rel="noopener"><code>bool</code></a>、<code>None</code>）的字典的键会被跳过；否则引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> 模块始终产生 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 对象而非 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 对象。因此，<code>fp.write()</code> 必须支持 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 输入。</p><p>如果 <em>ensure_ascii</em> 是 true （即默认值），输出保证将所有输入的非 ASCII 字符转义。如果 <em>ensure_ascii</em> 是 false，这些字符会原样输出。</p><p>如果 <em>check_circular</em> 是为假值 (默认为 <code>True</code>)，那么容器类型的循环引用检验会被跳过并且循环引用会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a> (或者更糟的情况)。</p><p>如果 <em>allow_nan</em> 是 false（默认为 <code>True</code>），那么在对严格 JSON 规格范围外的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 类型值（<code>nan</code>、<code>inf</code> 和 <code>-inf</code>）进行序列化时会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。如果 <em>allow_nan</em> 是 true，则使用它们的 JavaScript 等价形式（<code>NaN</code>、<code>Infinity</code> 和 <code>-Infinity</code>）。</p><p>如果 <em>indent</em> 是一个非负整数或者字符串，那么 JSON 数组元素和对象成员会被美化输出为该值指定的缩进等级。如果缩进等级为零、负数或者 <code>&quot;&quot;</code>，则只会添加换行符。<code>None（默认值）选择最紧凑的表达。使用一个正整数会让每一层缩进同样数量的空格。如果 *indent* 是一个字符串（比如 &quot;\t&quot;</code>），那个字符串会被用于缩进每一层。</p><p><em>在 3.2 版更改:</em> 允许使用字符串作为 <em>indent</em> 而不再仅仅是整数。</p><p>当指定时，<em>separators</em> 应当是一个 <code>(item_separator, key_separator)</code> 元组。当 <em>indent</em> 为 <code>None</code> 时，默认值取 <code>(&#39;, &#39;, &#39;: &#39;)</code>，否则取 <code>(&#39;,&#39;, &#39;: &#39;)</code>。为了得到最紧凑的 JSON 表达式，你应该指定其为 <code>(&#39;,&#39;, &#39;:&#39;)</code> 以消除空白字符。</p><p><em>在 3.4 版更改:</em> 现当 <em>indent</em> 不是 <code>None</code> 时，采用 <code>(&#39;,&#39;, &#39;: &#39;)</code> 作为默认值。</p><p>当 <em>default</em> 被指定时，其应该是一个函数，每当某个对象无法被序列化时它会被调用。它应该返回该对象的一个可以被 JSON 编码的版本或者引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。如果没有被指定，则会直接引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p><p>如果 <em>sort_keys</em> 是 true（默认为 <code>False</code>），那么字典的输出会以键的顺序排序。</p><p>为了使用一个自定义的 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder" target="_blank" rel="noopener"><code>JSONEncoder</code></a> 子类（比如：覆盖了 <code>default()</code> 方法来序列化额外的类型）， 通过 <em>cls</em> 关键字参数来指定；否则将使用 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder" target="_blank" rel="noopener"><code>JSONEncoder</code></a>。</p></li><li><p>json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)</p><p> 使用这个 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#py-to-json-table" target="_blank" rel="noopener">转换表</a> 将 <em>obj</em> 序列化为 JSON 格式的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>。 其参数的含义与 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.dump" target="_blank" rel="noopener"><code>dump()</code></a> 中的相同。 </p></li><li><p><code>json.load</code>(<em>fp</em>, <strong><em>, </em>cls=None<em>, </em>object_hook=None<em>, </em>parse_float=None<em>, </em>parse_int=None<em>, </em>parse_constant=None<em>, </em>object_pairs_hook=None<em>, </em></strong>kw*) </p><p>使用这个 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json-to-py-table" target="_blank" rel="noopener">转换表</a> 将 <em>fp</em> (一个支持 <code>.read()</code> 并包含一个 JSON 文档的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-text-file" target="_blank" rel="noopener">text file</a> 或者 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a>) 反序列化为一个 Python 对象。</p><p><em>object_hook</em> 是一个可选的函数，它会被调用于每一个解码出的对象字面量（即一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>）。<em>object_hook</em> 的返回值会取代原本的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>。这一特性能够被用于实现自定义解码器（如 <a href="http://www.jsonrpc.org/" target="_blank" rel="noopener">JSON-RPC</a> 的类型提示)。</p><p><em>object_pairs_hook</em> 是一个可选的函数，它会被调用于每一个有序列表对解码出的对象字面量。 <em>object_pairs_hook</em> 的返回值将会取代原本的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 。这一特性能够被用于实现自定义解码器。如果 <em>object_hook</em> 也被定义， <em>object_pairs_hook</em> 优先。</p><p><em>在 3.1 版更改:</em> 添加了对 <em>object_pairs_hook</em> 的支持。</p><p><em>parse_float</em> ，如果指定，将与每个要解码 JSON 浮点数的字符串一同调用。默认状态下，相当于 <code>float(num_str)</code> 。可以用于对 JSON 浮点数使用其它数据类型和语法分析程序 （比如 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>decimal.Decimal</code></a> ）。</p><p><em>parse_int</em> ，如果指定，将与每个要解码 JSON 整数的字符串一同调用。默认状态下，相当于 <code>int(num_str)</code> 。可以用于对 JSON 整数使用其它数据类型和语法分析程序 （比如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> ）。</p><p><em>parse_constant</em> ，如果指定，将要与以下字符串中的一个一同调用： <code>&#39;-Infinity&#39;</code> ， <code>&#39;Infinity&#39;</code> ， <code>&#39;NaN&#39;</code> 。如果遇到无效的 JSON 数字则可以使用它引发异常。</p><p><em>在 3.1 版更改:</em> <em>parse_constant</em> 不再调用 ‘null’ ， ‘true’ ， ‘false’ 。</p><p>要使用自定义的 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecoder" target="_blank" rel="noopener"><code>JSONDecoder</code></a> 子类，用 <code>cls</code> 指定他；否则使用 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecoder" target="_blank" rel="noopener"><code>JSONDecoder</code></a> 。额外的关键词参数会通过类的构造函数传递。</p><p>如果反序列化的数据不是有效 JSON 文档，引发 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecodeError" target="_blank" rel="noopener"><code>JSONDecodeError</code></a> 错误。</p><p><em>在 3.6 版更改:</em> 所有的可选参数现在是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#keyword-only-parameter" target="_blank" rel="noopener">keyword-only</a> 的了。</p><p><em>在 3.6 版更改:</em> <em>fp</em> 现在可以是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a> 。输入编码应当是 UTF-8 ， UTF-16 或者 UTF-32 。</p></li><li><p><code>json.loads</code>(<em>s</em>, <strong><em>, </em>cls=None<em>, </em>object_hook=None<em>, </em>parse_float=None<em>, </em>parse_int=None<em>, </em>parse_constant=None<em>, </em>object_pairs_hook=None<em>, </em></strong>kw*) </p><p>使用这个 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json-to-py-table" target="_blank" rel="noopener">转换表</a> 将 <em>s</em> (一个包含 JSON 文档的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 实例) 反序列化为 Python 对象。</p><p>除了<em>encoding</em>被忽略和弃用自 Python 3.1 以来，其他参数的含义与 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.load" target="_blank" rel="noopener"><code>load()</code></a> 中相同。</p><p>如果反序列化的数据不是有效 JSON 文档，引发 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecodeError" target="_blank" rel="noopener"><code>JSONDecodeError</code></a> 错误。</p><p><em>Deprecated since version 3.1, will be removed in version 3.9:</em> <em>encoding</em> 关键字参数。</p><p><em>在 3.6 版更改:</em> <em>s</em> 现在可以为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 类型。 输入编码应为 UTF-8, UTF-16 或 UTF-32。</p></li></ul><h2 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h2><ul><li><p><em>class</em> <code>json.JSONDecoder</code>(<em>**, </em>object_hook=None<em>, </em>parse_float=None<em>, </em>parse_int=None<em>, </em>parse_constant=None<em>, </em>strict=True<em>, </em>object_pairs_hook=None*) </p><p>简单的JSON解码器。</p><p>默认情况下，解码执行以下翻译:</p><p>| JSON          | Python |<br>| :———— | :—– |<br>| object        | dict   |<br>| array         | list   |<br>| string        | str    |<br>| number (int)  | int    |<br>| number (real) | float  |<br>| true          | True   |<br>| false         | False  |<br>| null          | None   |</p></li></ul><p>​      它还将“NaN”、“Infinity”和“-Infinity”理解为它们对应的“float”值，这超出了JSON规范。</p><p>​    <em>object_hook</em> ，如果指定，会被每个解码的 JSON 对象的结果调用，并且返回值会替代给定 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 。它可被用于提供自定义反序列化（比如去支持 JSON-RPC 类的暗示）。</p><p>如果指定了 <em>object_pairs_hook</em> 则它将被调用并传入以对照值有序列表进行解码的每个 JSON 对象的结果。 <em>object_pairs_hook</em> 的结果值将被用来替代 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a>。 这一特性可被用于实现自定义解码器。 如果还定义了 <em>object_hook</em>，则 <em>object_pairs_hook</em> 的优先级更高。</p><p><em>在 3.1 版更改:</em> 添加了对 <em>object_pairs_hook</em> 的支持。</p><p><em>parse_float</em> ，如果指定，将与每个要解码 JSON 浮点数的字符串一同调用。默认状态下，相当于 <code>float(num_str)</code> 。可以用于对 JSON 浮点数使用其它数据类型和语法分析程序 （比如 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>decimal.Decimal</code></a> ）。</p><p><em>parse_int</em> ，如果指定，将与每个要解码 JSON 整数的字符串一同调用。默认状态下，相当于 <code>int(num_str)</code> 。可以用于对 JSON 整数使用其它数据类型和语法分析程序 （比如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> ）。</p><p><em>parse_constant</em> ，如果指定，将要与以下字符串中的一个一同调用： <code>&#39;-Infinity&#39;</code> ， <code>&#39;Infinity&#39;</code> ， <code>&#39;NaN&#39;</code> 。如果遇到无效的 JSON 数字则可以使用它引发异常。</p><p>如果 <em>strict</em> 为 false （默认为 <code>True</code> ），那么控制字符将被允许在字符串内。在此上下文中的控制字符编码在范围 0–31 内的字符，包括 <code>&#39;\t&#39;</code> (制表符）， <code>&#39;\n&#39;</code> ， <code>&#39;\r&#39;</code> 和 <code>&#39;\0&#39;</code> 。</p><p>如果反序列化的数据不是有效 JSON 文档，引发 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecodeError" target="_blank" rel="noopener"><code>JSONDecodeError</code></a> 错误。</p><p><em>在 3.6 版更改:</em> 所有形参现在都是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#keyword-only-parameter" target="_blank" rel="noopener">仅限关键字参数</a>。</p><ul><li><p><code>decode</code>(<em>s</em>) </p><p>返回 <em>s</em> 的 Python 表示形式（包含一个 JSON 文档的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 实例）。</p><p>如果给定的 JSON 文档无效则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecodeError" target="_blank" rel="noopener"><code>JSONDecodeError</code></a>。</p></li><li><p><code>raw_decode</code>(<em>s</em>) </p><p>从 <em>s</em> 中解码出 JSON 文档（以 JSON 文档开头的一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 对象）并返回一个 Python 表示形式为 2 元组以及指明该文档在 <em>s</em> 中结束位置的序号。</p><p>这可以用于从一个字符串解码JSON文档，该字符串的末尾可能有无关的数据。</p></li></ul><ul><li><p><em>lass</em> <code>json.JSONEncoder</code>(<em>**, </em>skipkeys=False<em>, </em>ensure_ascii=True<em>, </em>check_circular=True<em>, </em>allow_nan=True<em>, </em>sort_keys=False<em>, </em>indent=None<em>, </em>separators=None<em>, </em>default=None*) </p><p>用于Python数据结构的可扩展JSON编码器。</p><p>默认支持以下对象和类型：</p><p>| Python                              | JSON   |<br>| :———————————- | :—– |<br>| dict                                | object |<br>| list, tuple                         | array  |<br>| str                                 | string |<br>| int, float, int 和 float 派生的枚举 | number |<br>| True                                | true   |<br>| False                               | false  |<br>| None                                | null   |</p><p><em>在 3.4 版更改:</em> 添加了对 int 和 float 派生的枚举类的支持</p><p>为了将其拓展至识别其他对象，需要子类化并实现 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder.default" target="_blank" rel="noopener"><code>default()</code></a> 方法于另一种返回 <code>o</code> 的可序列化对象的方法如果可行，否则它应该调用超类实现（来引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> ）。</p><p>如果 <em>skipkeys</em> 为假值（默认），则尝试对不是 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 或 <code>None</code> 的键进行编码将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 如果 <em>skipkeys</em> 为真值，这些条目将被直接跳过。</p><p>如果 <em>ensure_ascii</em> 是 true （即默认值），输出保证将所有输入的非 ASCII 字符转义。如果 <em>ensure_ascii</em> 是 false，这些字符会原样输出。</p><p>如果 <em>check_circular</em> 为 true （默认），那么列表，字典，和自定义编码的对象在编码期间会被检查重复循环引用防止无限递归（无限递归将导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a> ）。否则，这样进行检查。</p><p>如果 <em>allow_nan</em> 为 true （默认），那么 <code>NaN</code> ， <code>Infinity</code> ，和 <code>-Infinity</code> 进行编码。此行为不符合 JSON 规范，但与大多数的基于 Javascript 的编码器和解码器一致。否则，它将是一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 来编码这些浮点数。</p><p>如果 <em>sort_keys</em> 为 true （默认为： <code>False</code> ），那么字典的输出是按照键排序；这对回归测试很有用，以确保可以每天比较 JSON 序列化。</p><p>如果 <em>indent</em> 是一个非负整数或者字符串，那么 JSON 数组元素和对象成员会被美化输出为该值指定的缩进等级。如果缩进等级为零、负数或者 <code>&quot;&quot;</code>，则只会添加换行符。<code>None（默认值）选择最紧凑的表达。使用一个正整数会让每一层缩进同样数量的空格。如果 *indent* 是一个字符串（比如 &quot;\t&quot;</code>），那个字符串会被用于缩进每一层。</p><p><em>在 3.2 版更改:</em> 允许使用字符串作为 <em>indent</em> 而不再仅仅是整数。</p><p>当指定时，<em>separators</em> 应当是一个 <code>(item_separator, key_separator)</code> 元组。当 <em>indent</em> 为 <code>None</code> 时，默认值取 <code>(&#39;, &#39;, &#39;: &#39;)</code>，否则取 <code>(&#39;,&#39;, &#39;: &#39;)</code>。为了得到最紧凑的 JSON 表达式，你应该指定其为 <code>(&#39;,&#39;, &#39;:&#39;)</code> 以消除空白字符。</p><p><em>在 3.4 版更改:</em> 现当 <em>indent</em> 不是 <code>None</code> 时，采用 <code>(&#39;,&#39;, &#39;: &#39;)</code> 作为默认值。</p><p>当 <em>default</em> 被指定时，其应该是一个函数，每当某个对象无法被序列化时它会被调用。它应该返回该对象的一个可以被 JSON 编码的版本或者引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。如果没有被指定，则会直接引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p><p><em>在 3.6 版更改:</em> 所有形参现在都是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#keyword-only-parameter" target="_blank" rel="noopener">仅限关键字参数</a>。</p><ul><li><p><code>default</code>(<em>o</em>) </p><p>在子类中实现这种方法使其返回 <em>o</em> 的可序列化对象，或者调用基础实现（引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> ）。</p><p>比如说，为了支持任意迭代器，你可以像这样实现默认设置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, o)</span>:</span></span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       iterable = iter(o)</span><br><span class="line">   <span class="keyword">except</span> TypeError:</span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       <span class="keyword">return</span> list(iterable)</span><br><span class="line">   <span class="comment"># Let the base class default method raise the TypeError</span></span><br><span class="line">   <span class="keyword">return</span> json.JSONEncoder.default(self, o)</span><br></pre></td></tr></table></figure></li><li><p><code>encode</code>(<em>o</em>) </p><p>返回 Python <em>o</em> 数据结构的 JSON 字符串表达方式。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.JSONEncoder().encode(&#123;<span class="string">"foo"</span>: [<span class="string">"bar"</span>, <span class="string">"baz"</span>]&#125;)</span><br><span class="line"><span class="string">'&#123;"foo": ["bar", "baz"]&#125;'</span></span><br></pre></td></tr></table></figure></li><li><p><code>iterencode</code>(<em>o</em>) </p><p>编码给定对象 <em>o</em> ，并且让每个可用的字符串表达方式。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> json.JSONEncoder().iterencode(bigobject):</span><br><span class="line">    mysocket.write(chunk)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><em>exception</em> <code>json.JSONDecodeError</code>(<em>msg</em>, <em>doc</em>, <em>pos</em>)</p><p>拥有以下附加属性的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 的子类：</p><ul><li><p><code>msg</code></p><p>未格式化的错误消息。</p></li><li><p><code>doc</code></p><p>正在解析的 JSON 文档。</p></li><li><p><code>pos</code></p><p>从文档开始解析失败的索引</p></li><li><p><code>lineno</code></p><p>定位的行号</p></li><li><p><code>colno</code></p><p>定位的列号</p></li></ul><h2 id="标准符合性和互操作性"><a href="#标准符合性和互操作性" class="headerlink" title="标准符合性和互操作性"></a>标准符合性和互操作性</h2><p>JSON 格式由 <a href="https://tools.ietf.org/html/rfc7159.html" target="_blank" rel="noopener"><strong>RFC 7159</strong></a> 和 <a href="http://www.ecma-international.org/publications/standards/Ecma-404.htm" target="_blank" rel="noopener">ECMA-404</a> 指定。此段落详细讲了这个模块符合 RFC 的级别。简单来说， <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONEncoder" target="_blank" rel="noopener"><code>JSONEncoder</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/json.html#json.JSONDecoder" target="_blank" rel="noopener"><code>JSONDecoder</code></a> 子类，和明确提到的参数以外的参数，不作考虑。</p><p>此模块不严格遵循于 RFC ，它实现了一些扩展是有效的 Javascript 但不是有效的 JSON。尤其是：</p><ul><li>无限和 NaN 数值是被接受并输出；</li><li>对象内的重复名称是接受的，并且仅使用最后一对属性-值对的值。</li></ul><p>自从 RFC 允许符合 RFC 的语法分析程序接收 不符合 RFC 的输入文本以来，这个模块的解串器在默认状态下默认符合 RFC 。</p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>RFC 要求使用 UTF-8 ， UTF-16 ，或 UTF-32 之一来表示 JSON ，为了最大互通性推荐使用 UTF-8 。</p><p>RFC允许，尽管不是必须的，这个模块的序列化默认设置为 <em>ensure_ascii=True</em> ，这样消除输出以便结果字符串至容纳 ASCII 字符。</p><p><em>ensure_ascii</em> 参数以外，此模块是严格的按照在 Python 对象和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>Unicode strings</code></a> 间的转换定义的，并且因此不能直接解决字符编码的问题。</p><p>RFC 禁止添加字符顺序标记（ BOM ）在 JSON 文本的开头，这个模块的序列化器不添加 BOM 标记在它的输出上。 RFC，准许 JSON 反序列化器忽略它们输入中的初始 BOM 标记，但不要求。此模块的反序列化器引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 当存在初始 BOM 标记。</p><p>RFC 不会明确禁止包含字节序列的 JSON 字符串这不对应有效的 Unicode 字符（比如 不成对的 UTF-16 的替代物），但是它确实指出它们可能会导致互操作性问题。默认下，模块对这样的序列接受和输出（当在原始 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 存在时）代码点。</p><h3 id="Infinite-和-NaN-数值"><a href="#Infinite-和-NaN-数值" class="headerlink" title="Infinite 和 NaN 数值"></a>Infinite 和 NaN 数值</h3><p>RFC 不允许 infinite 或者 NaN 数值的表达方式。尽管这样，默认情况下，此模块接受并且输出 <code>Infinity</code> ， <code>-Infinity</code>，和 <code>NaN</code> 好像它们是有效的JSON数字字面值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Neither of these calls raises an exception, but the results are not valid JSON</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(float(<span class="string">'-inf'</span>))</span><br><span class="line"><span class="string">'-Infinity'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(float(<span class="string">'nan'</span>))</span><br><span class="line"><span class="string">'NaN'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Same when deserializing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'-Infinity'</span>)</span><br><span class="line">-inf</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(<span class="string">'NaN'</span>)</span><br><span class="line">nan</span><br></pre></td></tr></table></figure><p>序列化器中， <em>allow_nan</em> 参数可用于替代这个行为。反序列化器中， <em>parse_constant</em> 参数，可用于替代这个行为。</p><h3 id="对象中的重复名称"><a href="#对象中的重复名称" class="headerlink" title="对象中的重复名称"></a>对象中的重复名称</h3><p>RFC 具体说明了 在 JSON对象里的名字应该是唯一的，但没有规定如何处理JSON对象中的重复名称。默认下，此模块不引发异常；作为替代，对于给定名它将忽略除姓-值对之外的所有对:</p><p>>&gt;&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; weird_json = &apos;&#123;&quot;x&quot;: 1, &quot;x&quot;: 2, &quot;x&quot;: 3&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; json.loads(weird_json)</span><br><span class="line">&#123;&apos;x&apos;: 3&#125;</span><br></pre></td></tr></table></figure><p>参数 <code>*object_pairs_hook*</code> 可以改变这个行为</p><h3 id="顶级非对象，非数组值"><a href="#顶级非对象，非数组值" class="headerlink" title="顶级非对象，非数组值"></a>顶级非对象，非数组值</h3><p>老版本的JSON声明遵循<a href="https://tools.ietf.org/html/rfc4627.html" target="_blank" rel="noopener"><strong>RFC 4627</strong></a> ,需要顶级的JSON 文本必须是JSON对象或数组(Python中的字典或列表),并且不能是null,boolean,number或字符串。<a href="https://tools.ietf.org/html/rfc7159.html" target="_blank" rel="noopener"><strong>RFC 7159</strong></a> 移除了这个限制,意味着无需在序列化和反序列化时实现该规范。</p><p>除此以外,为了获得最大限度的操作灵活性,你可以根据自己的实际情况选择是否遵循该规范。</p><h3 id="实现限制"><a href="#实现限制" class="headerlink" title="实现限制"></a>实现限制</h3><p>一些json 实现可能有下面的限制:</p><ul><li>可以接受的 JSON 文本大小 </li><li>对象和数组的最大层数</li><li>JSON numbers的范围以及小数位数。</li><li>JSON字符串的内容和最大长度</li></ul><p>json模块并不会强制这些限制,这取决于自定义Python数据类型自身的实现。</p><h2 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h2><p> <a href="https://docs.python.org/zh-cn/3.8/library/json.html#module-json.tool" target="_blank" rel="noopener"><code>json.tool</code></a> 模块实现了一个简易的命令行接口,用来验证和打印格式良好的JSON 对象。</p><p>如果没有设定可选参数<code>infile</code> and <code>outfile</code>,将会使用<a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a> and <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdout" target="_blank" rel="noopener"><code>sys.stdout</code></a> 标准输入输出代替。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="string">'&#123;"json": "obj"&#125;'</span> | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"json"</span>: <span class="string">"obj"</span></span><br><span class="line">&#125;</span><br><span class="line">$ echo <span class="string">'&#123;1.2:3.4&#125;'</span> | python -m json.tool</span><br><span class="line">Expecting property name enclosed <span class="keyword">in</span> double quotes: line <span class="number">1</span> column <span class="number">2</span> (char <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><p> <strong>infile</strong> </p><p>JSON 文件校验或美化打印。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python -m json.tool mp_films.json</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"And Now for Something Completely Different"</span>,</span><br><span class="line">        <span class="string">"year"</span>: <span class="number">1971</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"title"</span>: <span class="string">"Monty Python and the Holy Grail"</span>,</span><br><span class="line">        <span class="string">"year"</span>: <span class="number">1975</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>If <em>infile</em> is not specified, read from <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a>.</p><p> <strong>outfile</strong> </p><p> Write the output of the <em>infile</em> to the given <em>outfile</em>. Otherwise, write it to </p><p>输出到文件,如果没有设置则使用<a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdout" target="_blank" rel="noopener"><code>sys.stdout</code></a>(标准输出)</p><p> <strong>–sort-keys</strong> </p><p>根据输出的字典的键根据字母顺序排序</p><p> <strong>–json-lines</strong> </p><p>解析每一行作为单独的JSON对象</p><p> <code>-h, --help</code> </p><p>显示帮助信息</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-json&quot;&gt;&lt;a href=&quot;#python-标准库-json&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 json&quot;&gt;&lt;/a&gt;python 标准库 json&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20191223_blog_6.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="json" scheme="https://pinghailinfeng.gitee.io/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>python standard library types</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/07/python-standard-library-types/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/07/python-standard-library-types/</id>
    <published>2020-02-07T12:10:40.000Z</published>
    <updated>2020-02-10T02:35:57.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-types"><a href="#python-标准库-types" class="headerlink" title="python 标准库 types"></a>python 标准库 types</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200207_RIP.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>今天心情很沉重,李文亮医生一路走好！R.I.P</p></blockquote><p><a href="https://v.youku.com/v_show/id_XNDQ1MTYyMDI4OA==.html" target="_blank" rel="noopener">https://v.youku.com/v_show/id_XNDQ1MTYyMDI4OA==.html</a></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/types.py" target="_blank" rel="noopener">Lib/types.py</a></p><hr><p>此模块定义了一些工具函数，用于协助动态创建新的类型。</p><p>它还为某些对象类型定义了名称，这些名称由标准 Python 解释器所使用，但并不像内置的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 那样对外公开。</p><p>最后，它还额外提供了一些类型相关但重要程度不足以作为内置对象的工具类和函数。</p><h2 id="动态类型创建"><a href="#动态类型创建" class="headerlink" title="动态类型创建"></a>动态类型创建</h2><ul><li><p><code>types.new_class</code>(<em>name</em>, <em>bases=()</em>, <em>kwds=None</em>, <em>exec_body=None</em>) </p><p>使用适当的元类动态地创建一个类对象。</p><p>前三个参数是组成类定义头的部件：类名称，基类 (有序排列)，关键字参数 (例如 <code>metaclass</code>)。</p><p><em>exec_body</em> 参数是一个回调函数，用于填充新创建类的命名空间。 它应当接受类命名空间作为其唯一的参数并使用类内容直接更新命名空间。 如果未提供回调函数，则它就等效于传入 <code>lambda ns: ns</code>。</p><p><em>3.3 新版功能.</em></p></li><li><p><code>types.prepare_class</code>(<em>name</em>, <em>bases=()</em>, <em>kwds=None</em>) </p><p>计算适当的元类并创建类命名空间。</p><p>参数是组成类定义头的部件：类名称，基类 (有序排列) 以及关键字参数 (例如 <code>metaclass</code>)。</p><p>返回值是一个 3 元组: <code>metaclass, namespace, kwds</code></p><p><em>metaclass</em> 是适当的元类，<em>namespace</em> 是预备好的类命名空间而 <em>kwds</em> 是所传入 <em>kwds</em> 参数移除每个 <code>&#39;metaclass&#39;</code> 条目后的已更新副本。 如果未传入 <em>kwds</em> 参数，这将为一个空字典。</p><p><em>3.3 新版功能.</em></p><p><em>在 3.6 版更改:</em> 所返回元组中 <code>namespace</code> 元素的默认值已被改变。 现在当元类没有 <code>__prepare__</code> 方法时将会使用一个保留插入顺序的映射。</p></li><li><p><code>types.resolve_bases</code>(<em>bases</em>) </p><p>动态地解析 MRO 条目，具体描述见 <a href="https://www.python.org/dev/peps/pep-0560" target="_blank" rel="noopener"><strong>PEP 560</strong></a>。</p><p>此函数会在 <em>bases</em> 中查找不是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#type" target="_blank" rel="noopener"><code>type</code></a> 的实例的项，并返回一个元组，其中每个具有 <code>__mro_entries__</code> 方法的此种对象对象将被替换为调用该方法解包后的结果。 如果一个 <em>bases</em> 项是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#type" target="_blank" rel="noopener"><code>type</code></a> 的实例，或它不具有 <code>__mro_entries__</code> 方法，则它将不加改变地被包含在返回的元组中。</p></li></ul><h2 id="标准解释器类型"><a href="#标准解释器类型" class="headerlink" title="标准解释器类型"></a>标准解释器类型</h2><p>此模块为许多类型提供了实现 Python 解释器所要求的名称。 它刻意地避免了包含某些仅在处理过程中偶然出现的类型，例如 <code>listiterator</code> 类型。</p><p>此种名称的典型应用如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#issubclass" target="_blank" rel="noopener"><code>issubclass()</code></a> 检测。</p><p>如果你要实例化这些类型中的任何一种，请注意其签名在不同 Python 版本之间可能出现变化。</p><p>以下类型有相应的标准名称定义：</p><ul><li><p><code>types.FunctionType</code></p></li><li><p><code>types.LambdaType</code> </p><p>用户自定义函数以及由 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#lambda" target="_blank" rel="noopener"><code>lambda</code></a> 表达式所创建函数的类型。 </p></li><li><p><code>types.GeneratorType</code> </p><p><a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 迭代器对象的类型，由生成器函数创建。 </p></li><li><p><code>types.CoroutineType</code> </p><p><a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 对象的类型，由 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 函数创建。 </p></li><li><p><code>types.AsyncGeneratorType</code>  </p><p><a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-generator" target="_blank" rel="noopener">asynchronous generator</a> 迭代器对象的类型，由异步生成器函数创建。 </p></li><li><p><em>class</em> <code>types.CodeType</code>(<strong><em>kwargs</em>) </strong></p><p>代码对象的类型，例如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#compile" target="_blank" rel="noopener"><code>compile()</code></a> 的返回值。</p><p>引发 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>code.__new__</code> 附带参数 <code>code</code>, <code>filename</code>, <code>name</code>, <code>argcount</code>, <code>posonlyargcount</code>, <code>kwonlyargcount</code>, <code>nlocals</code>, <code>stacksize</code>, <code>flags</code>。</p><p>请注意被审核参数可能不匹配初始化器所要求的名称或位置。</p><ul><li><p><strong><code>replace</code>(*</strong>kwargs*)</p><p>返回代码对象的一个副本，使用指定的新字段值。</p></li></ul></li><li><p><code>types.CellType</code> </p><p>单元对象的类型：这种对象被用作函数中自由变量的容器。 </p></li><li><p><code>types.MethodType</code> </p><p>用户自定义类实例方法的类型。 </p></li><li><p><code>types.BuiltinFunctionType</code> </p></li><li><p><code>types.BuiltinMethodType</code> </p><p>内置函数例如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#len" target="_blank" rel="noopener"><code>len()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 以及内置类方法的类型。 （这里所说的“内置”是指“以 C 语言编写”。） </p></li><li><p><code>types.WrapperDescriptorType</code> </p><p>某些内置数据类型和基类的方法的类型，例如 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__init__" target="_blank" rel="noopener"><code>object.__init__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__lt__" target="_blank" rel="noopener"><code>object.__lt__()</code></a>。 </p></li><li><p><code>types.MethodWrapperType</code> </p><p>某些内置数据类型和基类的 <em>绑定</em> 方法的类型。 例如 <code>object().__str__</code> 所属的类型。 </p></li><li><p><code>types.MethodDescriptorType</code> </p><p>某些内置数据类型方法例如 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str.join" target="_blank" rel="noopener"><code>str.join()</code></a> 的类型。 </p></li><li><p><code>types.MethodDescriptorType</code> </p><p>某些内置数据类型 <em>非绑定</em> 类方法例如 <code>dict.__dict__[&#39;fromkeys&#39;]</code> 的类型 </p></li><li><p><code>types.ClassMethodDescriptorType</code> </p><p>某些内置数据类型 <em>非绑定</em> 类方法例如 <code>dict.__dict__[&#39;fromkeys&#39;]</code> 的类型。 </p><p><em>class</em> <code>types.ModuleType</code>(<em>name</em>, <em>doc=None</em>) </p></li></ul><p><a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-module" target="_blank" rel="noopener">模块</a> 的类型。 构造器接受待创建模块的名称及其作为可选项 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-docstring" target="_blank" rel="noopener">docstring</a>。</p><p>如果你希望设置各种由导入控制的属性，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/importlib.html#importlib.util.module_from_spec" target="_blank" rel="noopener"><code>importlib.util.module_from_spec()</code></a> 来创建一个新模块。</p><ul><li><p><code>__doc__</code></p><p>模块的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-docstring" target="_blank" rel="noopener">docstring</a>。 默认为 <code>None</code>。</p></li><li><p><code>__loader__</code></p><p>用于加载模块的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-loader" target="_blank" rel="noopener">loader</a>。 默认为 <code>None</code>。<em>在 3.4 版更改:</em> 默认为 <code>None</code>。 之前该属性为可选项。</p></li><li><p><code>__name__</code></p><p>模块的名字</p></li><li><p><code>__package__</code></p><p>一个模块所属的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-package" target="_blank" rel="noopener">package</a>。 如果模块为最高层级的（即不是任何特定包的组成部分）则该属性应设为 <code>&#39;&#39;</code>，否则它应设为特定包的名称 (如果模块本身也是一个包则名称可以为 <a href="https://docs.python.org/zh-cn/3.8/reference/import.html#__name__" target="_blank" rel="noopener"><code>__name__</code></a>)。 默认为 <code>None</code>。</p><p><em>class</em> <code>types.TracebackType</code>(<em>tb_next</em>, <em>tb_frame</em>, <em>tb_lasti</em>, <em>tb_lineno</em>) </p></li></ul><p>回溯对象的类型，例如 <code>sys.exc_info()[2]</code> 中的对象。</p><p>请查看 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#traceback-objects" target="_blank" rel="noopener">语言参考</a> 了解可用属性和操作的细节，以及动态地创建回溯对象的指南。</p><ul><li><p><code>types.FrameType</code></p><p>帧对象的类型，例如 <code>tb.tb_frame</code> 中的对象，其中 <code>tb</code> 是一个回溯对象。请查看 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#frame-objects" target="_blank" rel="noopener">语言参考</a> 了解可用属性和操作的细节。</p></li><li><p><code>types.GetSetDescriptorType</code></p><p> 使用 <code>PyGetSetDef</code> 在扩展模块中定义的对象的类型，例如 <code>FrameType.f_locals</code> 或 <code>array.array.typecode</code>。 此类型被用作对象属性的描述器；它的目的与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#property" target="_blank" rel="noopener"><code>property</code></a> 类型相同，但专门针对在扩展模块中定义的类。 </p></li><li><p><code>types.MemberDescriptorType</code></p><p>使用 <code>PyMemberDef</code> 在扩展模块中定义的对象的类型，例如 <code>datetime.timedelta.days</code>。 此类型被用作使用标准转换函数的简单 C 数据成员的描述器；它的目的与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#property" target="_blank" rel="noopener"><code>property</code></a> 类型相同，但专门针对在扩展模块中定义的类。</p><p><strong>CPython implementation detail:</strong> 在 Python 的其它实现中，此类型可能与 <code>GetSetDescriptorType</code> 完全相同。</p></li><li><p><em>class</em> <code>types.MappingProxyType</code>(<em>mapping</em>)</p><p>一个映射的只读代理。 它提供了对映射条目的动态视图，这意味着当映射发生改变时，视图会反映这些改变。</p><p><em>3.3 新版功能.</em></p><ul><li><p><code>key in proxy</code></p><p>如果下层的映射中存在键 <em>key</em> 则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p><code>proxy[key]</code></p><p>返回下层的映射中以 <em>key</em> 为键的项。 如果下层的映射中不存在键 <em>key</em> 则引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。</p></li><li><p><code>iter(proxy)</code></p><p>返回由下层映射的键为元素的迭代器。 这是 <code>iter(proxy.keys())</code> 的快捷方式。</p></li><li><p><code>len(proxy)</code></p><p>返回下层映射中的项数。</p></li><li><p><code>copy</code>()</p><p>返回下层映射的浅拷贝。</p></li><li><p><code>get</code>(<em>key</em>[, <em>default</em>])</p><p>如果 <em>key</em> 存在于下层映射中则返回 <em>key</em> 的值，否则返回 <em>default</em>。 如果 <em>default</em> 未给出则默认为 <code>None</code>，因而此方法绝不会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。</p></li><li><p><code>items</code>()</p><p>返回由下层映射的项 (<code>(键, 值)</code> 对) 组成的一个新视图。</p></li><li><p><code>keys</code>()</p><p>返回由下层映射的键组成的一个新视图。</p></li><li><p><code>values</code>()</p><p>返回由下层映射的值组成的一个新视图。</p></li></ul></li></ul><h2 id="附加工具类和函数"><a href="#附加工具类和函数" class="headerlink" title="附加工具类和函数"></a>附加工具类和函数</h2><ul><li><p>class* <code>types.SimpleNamespace</code> </p><p>一个简单的 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 子类，提供了访问其命名空间的属性，以及一个有意义的 repr。</p><p>不同于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a>，对于 <code>SimpleNamespace</code> 你可以添加和移除属性。 如果一个 <code>SimpleNamespace</code> 对象使用关键字参数进行初始化，这些参数会被直接加入下层命名空间。</p><p>此类型大致等价于以下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleNamespace</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, /, **kwargs)</span>:</span></span><br><span class="line">        self.__dict__.update(kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        keys = sorted(self.__dict__)</span><br><span class="line">        items = (<span class="string">"&#123;&#125;=&#123;!r&#125;"</span>.format(k, self.__dict__[k]) <span class="keyword">for</span> k <span class="keyword">in</span> keys)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;&#125;(&#123;&#125;)"</span>.format(type(self).__name__, <span class="string">", "</span>.join(items))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__dict__ == other.__dict__</span><br></pre></td></tr></table></figure><p> <code>SimpleNamespace</code> 可被用于替代 <code>class NS: pass</code>。 但是，对于结构化记录类型则应改用 <a href="https://docs.python.org/zh-cn/3.8/library/collections.html#collections.namedtuple" target="_blank" rel="noopener"><code>namedtuple()</code></a>。 </p></li><li><p><code>types.DynamicClassAttribute</code>(<em>fget=None</em>, <em>fset=None</em>, <em>fdel=None</em>, <em>doc=None</em>) </p></li></ul><p>在类上访问 <strong>getattr</strong> 的路由属性。</p><p>这是一个描述器，用于定义通过实例与通过类访问时具有不同行为的属性。 当实例访问时保持正常行为，但当类访问属性时将被路由至类的 <strong>getattr</strong> 方法；这是通过引发 AttributeError 来完成的。</p><p>这样就允许有在实例上激活的特征属性，同时又有在类上的同名虚拟属性（一个这样的例子是 Enum）。</p><h2 id="协程工具函数"><a href="#协程工具函数" class="headerlink" title="协程工具函数"></a>协程工具函数</h2><p> <code>types.coroutine</code>(<em>gen_func</em>) </p><p>此函数可将 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 函数转换为返回基于生成器的协程的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine-function" target="_blank" rel="noopener">coroutine function</a>。 基于生成器的协程仍然属于 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator-iterator" target="_blank" rel="noopener">generator iterator</a>，但同时又可被视为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 对象兼 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-awaitable" target="_blank" rel="noopener">awaitable</a>。 不过，它没有必要实现 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__await__" target="_blank" rel="noopener"><code>__await__()</code></a> 方法。</p><p>如果 <em>gen_func</em> 是一个生成器函数，它将被原地修改。</p><p>如果 <em>gen_func</em> 不是一个生成器函数，则它会被包装。 如果它返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.Generator" target="_blank" rel="noopener"><code>collections.abc.Generator</code></a> 的实例，该实例将被包装在一个 <em>awaitable</em> 代理对象中。 所有其他对象类型将被原样返回。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-types&quot;&gt;&lt;a href=&quot;#python-标准库-types&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 types&quot;&gt;&lt;/a&gt;python 标准库 types&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200207_RIP.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="types" scheme="https://pinghailinfeng.gitee.io/tags/types/"/>
    
  </entry>
  
  <entry>
    <title>python standard library statistics</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/06/python-standard-library-statistics/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/06/python-standard-library-statistics/</id>
    <published>2020-02-06T12:51:05.000Z</published>
    <updated>2020-02-11T13:27:57.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-statistics-数学统计函数"><a href="#python-标准库-statistics-数学统计函数" class="headerlink" title="python 标准库 statistics 数学统计函数"></a>python 标准库 statistics 数学统计函数</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200206update.jpg?raw=true" alt></p><a id="more"></a><blockquote><p> I have self-doubt. I have insecurity. I have fear of failure. I have nights when I show up at the arena and I’m like, ‘My back hurts, my feet hurt, my knees hurt. I don’t have it. I just want to chill.’ We all have self-doubt. You don’t deny it, but you also don’t capitulate to it. You embrace it.<br>我有自我怀疑。我有不安全感。我害怕失败。当我出现在竞技场的时候，我会说，‘我的背疼，我的脚疼，我的膝盖疼。我没有打赢的信心。我只是想冷静一下。’我们都有自我怀疑。你不要否认，但你也不屈服于它。你要拥抱它。 </p><p>​                                                                                                                                                  by   Kobe Bryant </p></blockquote><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27867449&auto=0&height=66"></iframe></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/statistics.py" target="_blank" rel="noopener">Lib/statistics.py</a></p><p><em>主要方法</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">==================  ==================================================</span><br><span class="line">Function            Description</span><br><span class="line">==================  ==================================================</span><br><span class="line">mean                Arithmetic mean (average) of data.</span><br><span class="line">fmean               Fast, floating point arithmetic mean.</span><br><span class="line">geometric_mean      Geometric mean of data.</span><br><span class="line">harmonic_mean       Harmonic mean of data.</span><br><span class="line">median              Median (middle value) of data.</span><br><span class="line">median_low          Low median of data.</span><br><span class="line">median_high         High median of data.</span><br><span class="line">median_grouped      Median, <span class="keyword">or</span> <span class="number">50</span>th percentile, of grouped data.</span><br><span class="line">mode                Mode (most common value) of data.</span><br><span class="line">multimode           List of modes (most common values of data).</span><br><span class="line">quantiles           Divide data into intervals <span class="keyword">with</span> equal probability.</span><br><span class="line">==================  ==================================================</span><br></pre></td></tr></table></figure><hr><p>该模块提供了用于计算数字 (<a href="https://docs.python.org/zh-cn/3.8/library/numbers.html#numbers.Real" target="_blank" rel="noopener"><code>Real</code></a>-valued) 数据的数理统计量的函数。</p><p>此模块并不是诸如 <a href="https://numpy.org/" target="_blank" rel="noopener">NumPy</a> ， <a href="https://www.scipy.org/" target="_blank" rel="noopener">SciPy</a> 等第三方库或者诸如 Minitab ， SAS ， Matlab 等针对专业统计学家的专有全功能统计软件包的竟品。此模块针对图形和科学计算器的水平。</p><p>除非明确注释，这些函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>Decimal</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a> 。当前不支持同其他类型（是否在数字塔中）的行为。混合类型的集合也是未定义的，并且依赖于实现。如果你输入的数据由混合类型组成，你应该能够使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 来确保一个一致的结果，比如： <code>map(float, input_data)</code> 。</p><h2 id="中心位置的平均值和度量"><a href="#中心位置的平均值和度量" class="headerlink" title="中心位置的平均值和度量"></a>中心位置的平均值和度量</h2><p> 这些函数计算一个整体或样本的平均值或者特定值 </p><table><thead><tr><th><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.mean" target="_blank" rel="noopener"><code>mean()</code></a></th><th>数据的算术平均数（“平均数”）。</th></tr></thead><tbody><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.fmean" target="_blank" rel="noopener"><code>fmean()</code></a></td><td>快速的，浮点算数平均数。</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.geometric_mean" target="_blank" rel="noopener"><code>geometric_mean()</code></a></td><td>数据的几何平均数</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.harmonic_mean" target="_blank" rel="noopener"><code>harmonic_mean()</code></a></td><td>数据的调和均值</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median" target="_blank" rel="noopener"><code>median()</code></a></td><td>数据的中位数（中间值）</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_low" target="_blank" rel="noopener"><code>median_low()</code></a></td><td>数据的低中位数</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_high" target="_blank" rel="noopener"><code>median_high()</code></a></td><td>数据的高中位数</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_grouped" target="_blank" rel="noopener"><code>median_grouped()</code></a></td><td>分组数据的中位数，即第50个百分点。</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.mode" target="_blank" rel="noopener"><code>mode()</code></a></td><td>离散的或标称的数据的单模（最常见的值）。</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.multimode" target="_blank" rel="noopener"><code>multimode()</code></a></td><td>离散的或标称的数据的模式列表（最常见的值）。</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.quantiles" target="_blank" rel="noopener"><code>quantiles()</code></a></td><td>将数据以相等的概率分为多个间隔。</td></tr></tbody></table><h2 id="传播措施"><a href="#传播措施" class="headerlink" title="传播措施"></a>传播措施</h2><p>这些函数计算多少总体或者样本偏离典型值或平均值的度量。</p><table><thead><tr><th><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.pstdev" target="_blank" rel="noopener"><code>pstdev()</code></a></th><th>数据的总体标准差</th></tr></thead><tbody><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.pvariance" target="_blank" rel="noopener"><code>pvariance()</code></a></td><td>数据的总体方差</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.stdev" target="_blank" rel="noopener"><code>stdev()</code></a></td><td>数据的样本标准差</td></tr><tr><td><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.variance" target="_blank" rel="noopener"><code>variance()</code></a></td><td>数据的样本方差</td></tr></tbody></table><h2 id="函数细节"><a href="#函数细节" class="headerlink" title="函数细节"></a>函数细节</h2><p>这些函数不需要对提供给它们的数据进行排序。但是，为了方便阅读，大多数例子展示的是已排序的序列。</p><ul><li><p><code>statistics.mean</code>(<em>data</em>)</p><p>返回 <em>data</em> 的样本算术平均数，形式为序列或迭代器。算术平均数是数据之和与数据点个数的商。通常称作“平均数”，尽管它指示诸多数学平均数之一。它是数据的中心位置的度量。若 <em>data</em> 为空，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。一些用法示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">2.8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean([<span class="number">-1.0</span>, <span class="number">2.5</span>, <span class="number">3.25</span>, <span class="number">5.75</span>])</span><br><span class="line"><span class="number">2.625</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction <span class="keyword">as</span> F</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean([F(<span class="number">3</span>, <span class="number">7</span>), F(<span class="number">1</span>, <span class="number">21</span>), F(<span class="number">5</span>, <span class="number">3</span>), F(<span class="number">1</span>, <span class="number">3</span>)])</span><br><span class="line">Fraction(<span class="number">13</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal <span class="keyword">as</span> D</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean([D(<span class="string">"0.5"</span>), D(<span class="string">"0.75"</span>), D(<span class="string">"0.625"</span>), D(<span class="string">"0.375"</span>)])</span><br><span class="line">Decimal(<span class="string">'0.5625'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>statistics.fmean</code>(<em>data</em>) </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将浮点数转换成 data 并且计算算术平均数。</span><br><span class="line"></span><br><span class="line">此函数的运行速度比 mean() 函数快并且它总是返回一个 float。 data 可以为序列或迭代器。 如果输入数据集为空，则会引发 StatisticsError。</span><br></pre></td></tr></table></figure></li><li><p><code>statistics.geometric_mean</code>(<em>data</em>) </p><p>返回 <em>data</em> 调和均值，该参数可以是序列或包含实数值的可迭代对象。</p><p>调和均值,也叫次相反均值，所有数据的倒数的算术平均数 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.mean" target="_blank" rel="noopener"><code>mean()</code></a> 的倒数。比如说，数据 <em>a</em> ， <em>b</em> ， <em>c</em> 的调和均值等于 <code>3/(1/a + 1/b + 1/c)</code> 。如果其中一个值为零，结果为零。</p><p>调和均值是一种均值类型，是数据中心位置的度量。它通常适合于求比率和比例的平均值，比如速率。</p><p>假设一辆车在 40 km/hr 的速度下行驶了 10 km ，然后又以 60 km/hr 的速度行驶了 10 km 。车辆的平均速率是多少？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>harmonic_mean([<span class="number">40</span>, <span class="number">60</span>])</span><br><span class="line"><span class="number">48.0</span></span><br></pre></td></tr></table></figure><p>假设一名投资者在三家公司各购买了等价值的股票，以 2.5， 3 ， 10 的 P/E (价格/收益) 率。投资者投资组合的平均市盈率是多少？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>harmonic_mean([<span class="number">2.5</span>, <span class="number">3</span>, <span class="number">10</span>])  <span class="comment"># For an equal investment portfolio.</span></span><br><span class="line"><span class="number">3.6</span></span><br></pre></td></tr></table></figure><p>如果 <em>data</em> 为空或者 任何一个元素的值小于零，会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a> 。</p><p>当前算法在输入中遇到零时会提前退出。这意味着不会测试后续输入的有效性。（此行为将来可能会更改。）</p></li><li><p><code>statistics.median</code>(<em>data</em>) </p><p>使用普通的“取中间两数平均值”方法返回数值数据的中位数（中间值）。 如果 <em>data</em> 为空，则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。 <em>data</em> 可以是序列或可迭代对象。</p><p>中位数是衡量中间位置的可靠方式，并且较少受到极端值的影响。 当数据点的总数为奇数时，将返回中间数据点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>当数据点的总数为偶数时，中位数将通过对两个中间值求平均进行插值得出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>])</span><br><span class="line"><span class="number">4.0</span></span><br></pre></td></tr></table></figure><p>这适用于当你的数据是离散的，并且你不介意中位数不是实际数据点的情况。</p><p>如果数据是有序的（支持排序操作）但不是数字（不支持加法），请考虑改用 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_low" target="_blank" rel="noopener"><code>median_low()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.median_high" target="_blank" rel="noopener"><code>median_high()</code></a>。</p></li><li><p><code>statistics.median_low</code>(<em>data</em>) </p><p>返回数值数据的低中位数。 如果 <em>data</em> 为空则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。 <em>data</em> 可以是序列或可迭代对象。</p><p>低中位数一定是数据集的成员。 当数据点总数为奇数时，将返回中间值。 当其为偶数时，将返回两个中间值中较小的那个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_low([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_low([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>])</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>当你的数据是离散的，并且你希望中位数是一个实际数据点而非插值结果时可以使用低中位数。</p></li><li><p><code>statistics.median_high</code>(<em>data</em>) </p><p>​    返回数据的高中位数。 如果 <em>data</em> 为空则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。 <em>data</em> 可以是序列或可迭代对象。</p><p>高中位数一定是数据集的成员。 当数据点总数为奇数时，将返回中间值。 当其为偶数时，将返回两个中间值中较大的那个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_high([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_high([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>])</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>当你的数据是离散的，并且你希望中位数是一个实际数据点而非插值结果时可以使用高中位数。</p></li><li><p><code>statistics.median_grouped</code>(<em>data</em>, <em>interval=1</em>) </p><p>返回分组的连续数据的中位数，根据第 50 个百分点的位置使用插值来计算。 如果 <em>data</em> 为空则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。 <em>data</em> 可以是序列或可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_grouped([<span class="number">52</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">54</span>])</span><br><span class="line"><span class="number">52.5</span></span><br></pre></td></tr></table></figure><p>在下面的示例中，数据已经过舍入，这样每个值都代表数据分类的中间点，例如 1 是 0.5–1.5 分类的中间点，2 是 1.5–2.5 分类的中间点，3 是 2.5–3.5 的中间点等待。 根据给定的数据，中间值应落在 3.5–4.5 分类之内，并可使用插值法来进行估算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_grouped([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">3.7</span></span><br></pre></td></tr></table></figure><p>可选参数 <em>interval</em> 表示分类间隔，默认值为 1。 改变分类间隔自然会改变插件结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_grouped([<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], interval=<span class="number">1</span>)</span><br><span class="line"><span class="number">3.25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>median_grouped([<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], interval=<span class="number">2</span>)</span><br><span class="line"><span class="number">3.5</span></span><br></pre></td></tr></table></figure><p>此函数不会检查数据点之间是否至少相隔 <em>interval</em> 的距离。</p></li><li><p><code>statistics.mode</code>(<em>data</em>) </p><p>根据离散或标称的 <em>data</em> 返回单个最觉的数据点。 此模式（如果存在）是最典型的值，并可用来度量中心的位置。</p><p>如果存在具有相同频率的多个模式，则返回在 <em>data</em> 中遇到的第一个。 如果想要其中最小或最大的一个，请使用 <code>min(multimode(data))</code> 或 <code>max(multimode(data))</code>。 如果输入的 <em>data</em> 为空，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p><p><code>mode</code> 将假定是离散数据并返回一个单一的值。 这是通常的学校教学中标准的处理方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mode([1, 1, 2, 3, 3, 3, 3, 4])</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>此模式的独特之处在于它是这个包中唯一还可应用于标称（非数字）数据的统计信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mode([&quot;red&quot;, &quot;blue&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;red&quot;, &quot;red&quot;])</span><br><span class="line">&apos;red&apos;</span><br></pre></td></tr></table></figure><p><em>在 3.8 版更改:</em> 现在会通过返回所遇到的第一个模式来处理多模数据集。 之前它会在遇到超过一个的模式时引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p></li><li><p><code>statistics.multimode</code>(<em>data</em>) </p><p>返回最频繁出现的值的列表，并按它们在 <em>data</em> 中首次出现的位置排序。 如果存在多种模式则将返回一个以上的模式，或者如果 <em>data</em> 为空则将返回空列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>multimode(<span class="string">'aabbbbccddddeeffffgg'</span>)</span><br><span class="line">[<span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'f'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>multimode(<span class="string">''</span>)</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p><em>3.8 新版功能.</em> </p></li><li><p><code>statistics.pstdev</code>(<em>data</em>, <em>mu=None</em>) </p><p>返回总体标准差（总体方差的平方根）。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.pvariance" target="_blank" rel="noopener"><code>pvariance()</code></a> 了解参数和其他细节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pstdev([<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">2.5</span>, <span class="number">2.75</span>, <span class="number">3.25</span>, <span class="number">4.75</span>])</span><br><span class="line"><span class="number">0.986893273527251</span></span><br></pre></td></tr></table></figure></li><li><p><code>statistics.pvariance</code>(<em>data</em>, <em>mu=None</em>) </p><p>返回非空序列或包含实数值的可迭代对象 <em>data</em> 的总体方差。 方差或称相对于均值的二阶距，是对数据变化幅度（延展度或分散度）的度量。 方差值较大表明数据的散布范围较大；方差值较小表明它紧密聚集于均值附近。</p><p>如果给出了可选的第二个参数 <em>mu</em>，它通常是 <em>data</em> 的均值。 它也可以被用来计算相对于一个非均值点的二阶距。 如果该参数省略或为 <code>None</code> (默认值)，则会自动进行算术均值的计算。</p><p>使用此函数可根据所有数值来计算方差。 要根据一个样本来估算方差，通常 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.variance" target="_blank" rel="noopener"><code>variance()</code></a> 函数是更好的选择。</p><p>如果 <em>data</em> 为空则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]</span><br><span class="line">&gt;&gt;&gt; pvariance(data)</span><br><span class="line">1.25</span><br></pre></td></tr></table></figure><p>如果你已经计算过数据的平均值，你可以将其作为可选的第二个参数 <em>mu</em> 传入以避免重复计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mu = mean(data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pvariance(data, mu)</span><br><span class="line"><span class="number">1.25</span></span><br></pre></td></tr></table></figure><p>同样也支持使用 Decimal 和 Fraction 值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal <span class="keyword">as</span> D</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pvariance([D(<span class="string">"27.5"</span>), D(<span class="string">"30.25"</span>), D(<span class="string">"30.25"</span>), D(<span class="string">"34.5"</span>), D(<span class="string">"41.75"</span>)])</span><br><span class="line">Decimal(<span class="string">'24.815'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction <span class="keyword">as</span> F</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pvariance([F(<span class="number">1</span>, <span class="number">4</span>), F(<span class="number">5</span>, <span class="number">4</span>), F(<span class="number">1</span>, <span class="number">2</span>)])</span><br><span class="line">Fraction(<span class="number">13</span>, <span class="number">72</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>statistics.stdev</code>(<em>data</em>, <em>xbar=None</em>) </p><p>返回样本标准差（样本方差的平方根）。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.variance" target="_blank" rel="noopener"><code>variance()</code></a> 了解参数和其他细节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>stdev([<span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">2.5</span>, <span class="number">2.75</span>, <span class="number">3.25</span>, <span class="number">4.75</span>])</span><br><span class="line"><span class="number">1.0810874155219827</span></span><br></pre></td></tr></table></figure></li><li><p><code>statistics.variance</code>(<em>data</em>, <em>xbar=None</em>) </p><p>返回包含至少两个实数值的可迭代对象 <em>data</em> 的样本方差。 方差或称相对于均值的二阶矩，是对数据变化幅度（延展度或分散度）的度量。 方差值较大表明数据的散布范围较大；方差值较小表明它紧密聚集于均值附近。</p><p>如果给出了可选的第二个参数 <em>xbar</em>，它应当是 <em>data</em> 的均值。 如果该参数省略或为 <code>None</code> (默认值)，则会自动进行均值的计算。</p><p>当你的数据是总体数据的样本时请使用此函数。 要根据整个总体数据来计算方差，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.pvariance" target="_blank" rel="noopener"><code>pvariance()</code></a>。</p><p>如果 <em>data</em> 包含的值少于两个则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]</span><br><span class="line">&gt;&gt;&gt; variance(data)</span><br><span class="line">1.3720238095238095</span><br></pre></td></tr></table></figure><p>如果你已经计算过数据的平均值，你可以将其作为可选的第二个参数 <em>xbar</em> 传入以避免重复计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m = mean(data)</span><br><span class="line">&gt;&gt;&gt; variance(data, m)</span><br><span class="line">1.3720238095238095</span><br></pre></td></tr></table></figure><p>此函数不会试图检查你所传入的 <em>xbar</em> 是否为真实的平均值。 使用任意值作为 <em>xbar</em> 可能导致无效或不可能的结果。</p><p>同样也支持使用 Decimal 和 Fraction 值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal <span class="keyword">as</span> D</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>variance([D(<span class="string">"27.5"</span>), D(<span class="string">"30.25"</span>), D(<span class="string">"30.25"</span>), D(<span class="string">"34.5"</span>), D(<span class="string">"41.75"</span>)])</span><br><span class="line">Decimal(<span class="string">'31.01875'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction <span class="keyword">as</span> F</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>variance([F(<span class="number">1</span>, <span class="number">6</span>), F(<span class="number">1</span>, <span class="number">2</span>), F(<span class="number">5</span>, <span class="number">3</span>)])</span><br><span class="line">Fraction(<span class="number">67</span>, <span class="number">108</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>statistics.quantiles</code>(<em>data</em>, <em>**, </em>n=4<em>, </em>method=’exclusive’*) </p><p>将 <em>data</em> 分隔为具有相等概率的 <em>n</em> 个连续区间。 返回分隔这些区间的 <code>n - 1</code> 个分隔点的列表。</p><p>将 <em>n</em> 设为 4 以使用四分位（默认值）。 将 <em>n</em> 设为 10 以使用十分位。 将 <em>n</em> 设为 100 以使用百分位，即给出 99 个分隔点来将 <em>data</em> 分隔为 100 个大小相等的组。 如果 <em>n</em> 小于 1 则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p><p><em>data</em> 可以是包含样本数据的任意可迭代对象。 为了获得有意义的结果，<em>data</em> 中数据点的数量应当大于 <em>n</em>。 如果数据点的数量小于两个则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p><p>分隔点是通过对两个最接近的数据点进行线性插值得到的。 例如，如果一个分隔点落在两个样本值 <code>100</code> 和 <code>112</code> 之间距离三分之一的位置，则分隔点的取值将为 <code>104</code>。</p><p><em>method</em> 用于计算分位值，它会由于 <em>data</em> 是包含还是排除总体的最低和最高可能值而有所不同。</p><p>默认 <em>method</em> 是 “唯一的” 并且被用于在总体中数据采样这样可以有比样本中找到的更多的极端值。落在 <em>m</em> 个排序数据点的第 <em>i-th</em> 个以下的总体部分被计算为 <code>i / (m + 1)</code> 。给定九个样本值，方法排序它们并且分配一下的百分位： 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90% 。</p><p>将 <em>method</em> 设为 “inclusive” 可用于描述总体数据或已明确知道包含有总体数据中最极端值的样本。 <em>data</em> 中的最小值会被作为第 0 个百分位而最大值会被作为第 100 个百分位。 总体数据里处于 <em>m</em> 个已排序数据点中 <em>第 i 个</em> 以下的部分会以 <code>(i - 1) / (m - 1)</code> 来计算。 给定 11 个样本值，该方法会对它们进行排序并赋予以下百分位: 0%, 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90%, 100%。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Decile cut points for empirically sampled data</span><br><span class="line">&gt;&gt;&gt; data = [105, 129, 87, 86, 111, 111, 89, 81, 108, 92, 110,</span><br><span class="line">...         100, 75, 105, 103, 109, 76, 119, 99, 91, 103, 129,</span><br><span class="line">...         106, 101, 84, 111, 74, 87, 86, 103, 103, 106, 86,</span><br><span class="line">...         111, 75, 87, 102, 121, 111, 88, 89, 101, 106, 95,</span><br><span class="line">...         103, 107, 101, 81, 109, 104]</span><br><span class="line">&gt;&gt;&gt; [round(q, 1) for q in quantiles(data, n=10)]</span><br><span class="line">[81.0, 86.2, 89.0, 99.4, 102.5, 103.6, 106.0, 109.8, 111.0]</span><br></pre></td></tr></table></figure><p><em>3.8 新版功能.</em></p></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>只定义了一个异常：</p><ul><li><p><em>exception</em> <code>statistics.StatisticsError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 的子类，表示统计相关的异常。</p></li></ul><h2 id="NormalDist对象"><a href="#NormalDist对象" class="headerlink" title="NormalDist对象"></a><code>NormalDist</code>对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 工具可用于创建和操纵 <a href="http://www.stat.yale.edu/Courses/1997-98/101/ranvar.htm" target="_blank" rel="noopener">随机变量</a> 的正态分布。 这个类将数据度量值的平均值和标准差作为单一实体来处理。</p><p>正态分布的概念来自于 <a href="https://en.wikipedia.org/wiki/Central_limit_theorem" target="_blank" rel="noopener">中央极限定理</a> 并且在统计学中有广泛的应用。</p><ul><li><p><em>class</em> <code>statistics.NormalDist</code>(<em>mu=0.0</em>, <em>sigma=1.0</em></p><p>返回一个新的 <em>NormalDist</em> 对象，其中 <em>mu</em> 代表 <a href="https://en.wikipedia.org/wiki/Arithmetic_mean" target="_blank" rel="noopener">算术平均值</a> 而 <em>sigma</em> 代表 <a href="https://en.wikipedia.org/wiki/Standard_deviation" target="_blank" rel="noopener">标准差</a>。</p><p>若 <em>sigma</em> 为负数，将会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>。</p><ul><li><p><code>mean</code></p><p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Arithmetic_mean" target="_blank" rel="noopener">算术平均值</a>。</p></li><li><p><code>median</code></p><p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Median" target="_blank" rel="noopener">中位数</a>。</p></li><li><p><code>mode</code></p><p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Mode_(statistics" target="_blank" rel="noopener">模式</a>)。</p></li><li><p><code>stdev</code></p><p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Standard_deviation" target="_blank" rel="noopener">标准差</a>。</p></li><li><p><code>variance</code><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist.variance" target="_blank" rel="noopener">¶</a></p><p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Variance" target="_blank" rel="noopener">方差</a>。 等于标准差的平方</p></li></ul></li><li><p><em>classmethod</em> <code>from_samples</code>(<em>data</em>)</p><p>传入使用 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.fmean" target="_blank" rel="noopener"><code>fmean()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.stdev" target="_blank" rel="noopener"><code>stdev()</code></a> 基于 <em>data</em> 估算出的 <em>mu</em> 和 <em>sigma</em> 形参创建一个正态分布实例。<em>data</em> 可以是任何 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterable" target="_blank" rel="noopener">iterable</a> 并且应当包含能被转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 类型的值。 如果 <em>data</em> 不包含至少两个元素，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.StatisticsError" target="_blank" rel="noopener"><code>StatisticsError</code></a>，因为估算中心值至少需要一个点而估算分散度至少需要两个点。</p></li><li><p><code>samples</code>(<em>n</em>, <em>**, </em>seed=None*)</p><p>对于给定的平均值和标准差生成 <em>n</em> 个随机样本。 返回一个由 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 值组成的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a>。当给定 <em>seed</em> 时，创建一个新的底层随机数生成器实例。 这适用于创建可重现的结果，即使对于多线程上下文也有效。</p></li><li><p><code>pdf</code>(<em>x</em>)</p><p>使用 <a href="https://en.wikipedia.org/wiki/Probability_density_function" target="_blank" rel="noopener">概率密度函数 (pdf)</a>，计算一个随机变量 <em>X</em> 趋向于给定值 <em>x</em> 的相对可能性。 在数学意义上，它是当 <em>dx</em> 趋向于零时比率 <code>P(x &lt;= X &lt; x+dx) / dx</code> 的极限。相对可能性的计算方法是用一个狭窄区间内某个样本出现的概率除以区间的宽度（因此使用“密度”一词）。 由于可能性是相对于其他点的，它的值可以大于 1.0。</p></li><li><p><code>cdf</code>(<em>x</em>)</p><p>使用 <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function" target="_blank" rel="noopener">累积分布函数 (cdf)</a>，计算一个随机变量 <em>X</em> 小于等于 <em>x</em> 的概率。 在数学上，它表示为 <code>P(X &lt;= x)</code>。</p></li><li><p><code>inv_cdf</code>(<em>p</em>)</p><p>计算反向累积分布函数，也称为 <a href="https://en.wikipedia.org/wiki/Quantile_function" target="_blank" rel="noopener">分位数函数</a> 或 <a href="https://www.statisticshowto.datasciencecentral.com/inverse-distribution-function/" target="_blank" rel="noopener">百分点</a> 函数。 在数学上，它表示为 <code>x : P(X &lt;= x) = p</code>。找出随机变量 <em>X</em> 的值 <em>x</em> 使得该变量小于等于该值的概率等于给定的概率 <em>p</em>。</p></li><li><p><code>overlap</code>(<em>other</em>)</p><p>测量两个正态概率分布之间的一致性。 返回介于 0.0 和 1.0 之间的值，给出 <a href="https://www.rasch.org/rmt/rmt101r.htm" target="_blank" rel="noopener">两个概率密度函数的重叠区域</a>。</p></li><li><p><code>quantiles</code>(<em>n=4</em>)</p><p>将指定正态分布划分为 <em>n</em> 个相等概率的连续分隔区。 返回这些分隔区对应的 (n - 1) 个分隔点的列表。将 <em>n</em> 设为 4 以使用四分位（默认值）。 将 <em>n</em> 设为 10 以使用十分位。将 <em>n</em> 设为 100 以使用百分位，即给出 99 个分隔点来将正态分布分隔为 100 个大小相等的组。</p></li></ul><p><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 的实例支持加上、减去、乘以或除以一个常量。 这些运算被用于转换和缩放。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; temperature_february = NormalDist(5, 2.5)             # Celsius</span><br><span class="line">&gt;&gt;&gt; temperature_february * (9/5) + 32                     # Fahrenheit</span><br><span class="line">NormalDist(mu=41.0, sigma=4.5)</span><br></pre></td></tr></table></figure><p>不允许一个常量除以 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 的实例，因为结果将不是正态分布。</p><p>由于正态分布是由独立变量的累加效应产生的，因此允许表示为 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 实例的 <a href="https://en.wikipedia.org/wiki/Sum_of_normally_distributed_random_variables" target="_blank" rel="noopener">两组独立正态分布的随机变量相加和相减</a>。 例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>birth_weights = NormalDist.from_samples([<span class="number">2.5</span>, <span class="number">3.1</span>, <span class="number">2.1</span>, <span class="number">2.4</span>, <span class="number">2.7</span>, <span class="number">3.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>drug_effects = NormalDist(<span class="number">0.4</span>, <span class="number">0.15</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined = birth_weights + drug_effects</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(combined.mean, <span class="number">1</span>)</span><br><span class="line"><span class="number">3.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(combined.stdev, <span class="number">1</span>)</span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure><h3 id="NormalDist-示例和用法"><a href="#NormalDist-示例和用法" class="headerlink" title="NormalDist 示例和用法"></a><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 示例和用法</h3><p><a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 适合用来解决经典概率问题。</p><p>举例来说，如果 <a href="https://nces.ed.gov/programs/digest/d17/tables/dt17_226.40.asp" target="_blank" rel="noopener">SAT 考试的历史数据</a> 显示分数呈平均值为 1060 且标准差为 195 的正态分布，则可以确定考试分数处于 1100 和 1200 之间的学生的百分比舍入到最接近的整数应为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sat = NormalDist(<span class="number">1060</span>, <span class="number">195</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fraction = sat.cdf(<span class="number">1200</span> + <span class="number">0.5</span>) - sat.cdf(<span class="number">1100</span> - <span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(fraction * <span class="number">100.0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">18.4</span></span><br></pre></td></tr></table></figure><p>求 SAT 分数的 <a href="https://en.wikipedia.org/wiki/Quartile" target="_blank" rel="noopener">四分位</a> 和 <a href="https://en.wikipedia.org/wiki/Decile" target="_blank" rel="noopener">十分位</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(round, sat.quantiles()))</span><br><span class="line">[<span class="number">928</span>, <span class="number">1060</span>, <span class="number">1192</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(round, sat.quantiles(n=<span class="number">10</span>)))</span><br><span class="line">[<span class="number">810</span>, <span class="number">896</span>, <span class="number">958</span>, <span class="number">1011</span>, <span class="number">1060</span>, <span class="number">1109</span>, <span class="number">1162</span>, <span class="number">1224</span>, <span class="number">1310</span>]</span><br></pre></td></tr></table></figure><p>为了估算一个不易解析的模型分布，<a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 可以生成用于 <a href="https://en.wikipedia.org/wiki/Monte_Carlo_method" target="_blank" rel="noopener">蒙特卡洛模拟</a> 的输入样本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(x, y, z)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> (<span class="number">3</span>*x + <span class="number">7</span>*x*y - <span class="number">5</span>*y) / (<span class="number">11</span> * z)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">100</span>_000</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = NormalDist(<span class="number">10</span>, <span class="number">2.5</span>).samples(n, seed=<span class="number">3652260728</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Y = NormalDist(<span class="number">15</span>, <span class="number">1.75</span>).samples(n, seed=<span class="number">4582495471</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = NormalDist(<span class="number">50</span>, <span class="number">1.25</span>).samples(n, seed=<span class="number">6582483453</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quantiles(map(model, X, Y, Z))       </span><br><span class="line">[<span class="number">1.4591308524824727</span>, <span class="number">1.8035946855390597</span>, <span class="number">2.175091447274739</span>]</span><br></pre></td></tr></table></figure><p>当样本量较大并且成功试验的可能性接近 50% 时，正态分布可以被用来模拟 <a href="http://mathworld.wolfram.com/BinomialDistribution.html" target="_blank" rel="noopener">二项分布</a>。</p><p>例如，一次开源会议有 750 名与会者和两个可分别容纳 500 人的会议厅。 会上有一场关于 Python 的演讲和一场关于 Ruby 的演讲。 在往届会议中，65% 的与会者更愿意去听关于 Python 的演讲。 假定人群的偏好没有发生改变，那么 Python 演讲的会议厅不超出其容量上限的可能性是多少？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">750</span>             <span class="comment"># Sample size</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = <span class="number">0.65</span>            <span class="comment"># Preference for Python</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = <span class="number">1.0</span> - p         <span class="comment"># Preference for Ruby</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>k = <span class="number">500</span>             <span class="comment"># Room capacity</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Approximation using the cumulative normal distribution</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(NormalDist(mu=n*p, sigma=sqrt(n*p*q)).cdf(k + <span class="number">0.5</span>), <span class="number">4</span>)</span><br><span class="line"><span class="number">0.8402</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Solution using the cumulative binomial distribution</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> comb, fsum</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(fsum(comb(n, r) * p**r * q**(n-r) <span class="keyword">for</span> r <span class="keyword">in</span> range(k+<span class="number">1</span>)), <span class="number">4</span>)</span><br><span class="line"><span class="number">0.8402</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Approximation using a simulation</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> seed, choices</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>seed(<span class="number">8675309</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">trial</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> choices((<span class="string">'Python'</span>, <span class="string">'Ruby'</span>), (p, q), k=n).count(<span class="string">'Python'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mean(trial() &lt;= k <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>_000))</span><br><span class="line"><span class="number">0.8398</span></span><br></pre></td></tr></table></figure><p>在机器学习问题中也经常会出现正态分布。</p><p>Wikipedia 上有一个 <a href="https://en.wikipedia.org/wiki/Naive_Bayes_classifier#Sex_classification" target="_blank" rel="noopener">朴素贝叶斯分类器的好例子</a>。 挑战的问题是根据对多个正态分布的特征测量值包括身高、体重和足部尺码来预测一个人的性别。</p><p>我们得到了由八个人的测量值组成的训练数据集。 假定这些测量值是正态分布的，因此我们用 <a href="https://docs.python.org/zh-cn/3.8/library/statistics.html#statistics.NormalDist" target="_blank" rel="noopener"><code>NormalDist</code></a> 来总结数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>height_male = NormalDist.from_samples([<span class="number">6</span>, <span class="number">5.92</span>, <span class="number">5.58</span>, <span class="number">5.92</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>height_female = NormalDist.from_samples([<span class="number">5</span>, <span class="number">5.5</span>, <span class="number">5.42</span>, <span class="number">5.75</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weight_male = NormalDist.from_samples([<span class="number">180</span>, <span class="number">190</span>, <span class="number">170</span>, <span class="number">165</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weight_female = NormalDist.from_samples([<span class="number">100</span>, <span class="number">150</span>, <span class="number">130</span>, <span class="number">150</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foot_size_male = NormalDist.from_samples([<span class="number">12</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">10</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foot_size_female = NormalDist.from_samples([<span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>接下来，我们遇到一个特征测量值已知但性别未知的新人：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ht = <span class="number">6.0</span>        <span class="comment"># height</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wt = <span class="number">130</span>        <span class="comment"># weight</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fs = <span class="number">8</span>          <span class="comment"># foot size</span></span><br></pre></td></tr></table></figure><p>从是男是女各 50% 的 <a href="https://en.wikipedia.org/wiki/Prior_probability" target="_blank" rel="noopener">先验概率</a> 出发，我们通过将该先验概率乘以给定性别的特征度量值的可能性累积值来计算后验概率：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; prior_male = 0.5</span><br><span class="line">&gt;&gt;&gt; prior_female = 0.5</span><br><span class="line">&gt;&gt;&gt; posterior_male = (prior_male * height_male.pdf(ht) *</span><br><span class="line">...                   weight_male.pdf(wt) * foot_size_male.pdf(fs))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; posterior_female = (prior_female * height_female.pdf(ht) *</span><br><span class="line">...                     weight_female.pdf(wt) * foot_size_female.pdf(fs))</span><br></pre></td></tr></table></figure><p>最终预测值应为最大后验概率值。 这种算法被称为 <a href="https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation" target="_blank" rel="noopener">maximum a posteriori</a> 或 MAP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'male'</span> <span class="keyword">if</span> posterior_male &gt; posterior_female <span class="keyword">else</span> <span class="string">'female'</span></span><br><span class="line"><span class="string">'female'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-statistics-数学统计函数&quot;&gt;&lt;a href=&quot;#python-标准库-statistics-数学统计函数&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 statistics 数学统计函数&quot;&gt;&lt;/a&gt;python 标准库 statistics 数学统计函数&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200206update.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_libray" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-libray/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="statistics" scheme="https://pinghailinfeng.gitee.io/tags/statistics/"/>
    
  </entry>
  
  <entry>
    <title>python standard library uuid</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/05/python-standard-library-uuid/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/05/python-standard-library-uuid/</id>
    <published>2020-02-05T14:07:38.000Z</published>
    <updated>2020-02-11T13:27:57.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-之-uuid"><a href="#python-标准库-之-uuid" class="headerlink" title="python 标准库 之 uuid"></a>python 标准库 之 uuid</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200205update.jpg?raw=true" alt></p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=413961275&auto=0&height=66"></iframe><h2 id="何谓UUID"><a href="#何谓UUID" class="headerlink" title="何谓UUID"></a>何谓UUID</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">UUID是<span class="number">128</span>位的全局唯一标识符，通常由<span class="number">32</span>字节的字符串表示。</span><br><span class="line">   它可以保证时间和空间的唯一性，也称为GUID，全称为：</span><br><span class="line">           UUID —— Universally Unique IDentifier      Python 中叫 UUID</span><br><span class="line">           UUID -- java.util.UUID                     Java 中也叫 UUID</span><br><span class="line">           GUID —— Globally Unique IDentifier         C<span class="comment">#  中叫 GUID</span></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">   它通过MAC地址、时间戳、命名空间、随机数、伪随机数来保证生成ID的唯一性。</span><br><span class="line">   UUID主要有五个算法，也就是五种方法来实现：</span><br><span class="line"></span><br><span class="line">      <span class="number">1</span>、uuid1()——基于时间戳</span><br><span class="line"></span><br><span class="line">              由MAC地址、当前时间戳、随机数生成。可以保证全球范围内的唯一性，</span><br><span class="line">              但MAC的使用同时带来安全性问题，局域网中可以使用IP来代替MAC。</span><br><span class="line"></span><br><span class="line">      <span class="number">2</span>、uuid2()——基于分布式计算环境DCE（Python中没有这个函数）</span><br><span class="line"></span><br><span class="line">               算法与uuid1相同，不同的是把时间戳的前<span class="number">4</span>位置换为POSIX的UID。</span><br><span class="line">               实际中很少用到该方法。</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span>、uuid3()——基于名字的MD5散列值</span><br><span class="line"></span><br><span class="line">               通过计算名字和命名空间的MD5散列值得到，保证了同一命名空间中不同名字的唯一性，</span><br><span class="line">               和不同命名空间的唯一性，但同一命名空间的同一名字生成相同的uuid。    </span><br><span class="line"></span><br><span class="line">      <span class="number">4</span>、uuid4()——基于随机数</span><br><span class="line"></span><br><span class="line">               由伪随机数得到，有一定的重复概率，该概率可以计算出来。</span><br><span class="line"></span><br><span class="line">      <span class="number">5</span>、uuid5()——基于名字的SHA<span class="number">-1</span>散列值</span><br><span class="line"></span><br><span class="line">               算法与uuid3相同，不同的是使用 Secure Hash Algorithm <span class="number">1</span> 算法</span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>Source code:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/uuid.py" target="_blank" rel="noopener">Lib/uuid.py</a> </p><p>  uuid模块包括：不可变对象UUID（UUID类）和函数uuid1()、uuid3()、uuid4()和uuid5()，后面的四个函数用于生成 <a href="http://tools.ietf.org/html/rfc4122.html" target="_blank" rel="noopener">RFC 4122</a> 规范中指定的第1、3、4、5版UUID。使用uuid1()或uuid4()可以获得一个唯一的ID，uuid1()包含了主机的网络名称，uuid4()不涉及网络主机名，仅生成一个随机UUID，因此从隐私保护角度uuid4()更加安全。 </p><h2 id="枚举类型的SafeUUID-类"><a href="#枚举类型的SafeUUID-类" class="headerlink" title="枚举类型的SafeUUID 类"></a>枚举类型的SafeUUID 类</h2><p> <em>class</em> <code>uuid.SafeUUID</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">safe = <span class="number">0</span></span><br><span class="line">unsafe = <span class="number">-1</span></span><br><span class="line">unknown = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="UUID-类-接口"><a href="#UUID-类-接口" class="headerlink" title="UUID 类(接口)"></a>UUID 类(接口)</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法:"></a>基本语法:</h3><p><em>class</em> <code>uuid.UUID</code>(<em>hex=None</em>, <em>bytes=None</em>, <em>bytes_le=None</em>, <em>fields=None</em>, <em>int=None</em>, <em>version=None</em>, <em>**, </em>is_safe=SafeUUID.unknown*) </p><p>下面的各种方法创建相同的UUID对象，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UUID(<span class="string">'&#123;12345678-1234-5678-1234-567812345678&#125;'</span>)</span><br><span class="line">UUID(<span class="string">'12345678123456781234567812345678'</span>)</span><br><span class="line">UUID(<span class="string">'urn:uuid:12345678-1234-5678-1234-567812345678'</span>)</span><br><span class="line">UUID(bytes=<span class="string">b'\x12\x34\x56\x78'</span>*<span class="number">4</span>)</span><br><span class="line">UUID(bytes_le=<span class="string">b'\x78\x56\x34\x12\x34\x12\x78\x56'</span> +</span><br><span class="line">              <span class="string">b'\x12\x34\x56\x78\x12\x34\x56\x78'</span>)</span><br><span class="line">UUID(fields=(<span class="number">0x12345678</span>, <span class="number">0x1234</span>, <span class="number">0x5678</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x567812345678</span>))</span><br><span class="line">UUID(int=<span class="number">0x12345678123456781234567812345678</span>)</span><br></pre></td></tr></table></figure><p>其中:</p><blockquote><p>如果尝试比较一个非UUID对象会引发<code>TypeError</code><br>使用str()函数强制转换一个uuid对象,将会生成一个从<code>12345678-1234-5678-1234-567812345678.</code>中创建的字符串</p></blockquote><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><ul><li><p><code>UUID.bytes</code></p><p>指定一个大端字节序的总长16字节的字节串来创建UUID对象；    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = uuid.UUID(<span class="string">'&#123;12345678-1234-5678-1234-567812345678&#125;'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.bytes</span><br><span class="line"><span class="string">b'\x124Vx\x124Vx\x124Vx\x124Vx'</span></span><br></pre></td></tr></table></figure></li><li><p><code>UUID.bytes_le</code></p><p>指定一个小端字节序的总长16字节的字节串来创建UUID对象；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.bytes_le</span><br><span class="line"><span class="string">b'xV4\x124\x12xV\x124Vx\x124Vx'</span></span><br></pre></td></tr></table></figure></li><li><p><code>UUID.fields</code></p><p>以元组形式存放的UUID的6个整数域，有六个单独的属性和两个派生属性：</p><p>| 域                                                           | 意义                   |<br>| :———————————————————– | :——————— |<br>| <code>time_low</code>                                                   | UUID的前32位           |<br>| <code>time_mid</code>                                                   | 接前一域的16位         |<br>| <code>time_hi_version</code>                                            | 接前一域的16位         |<br>| <code>clock_seq_hi_variant</code>                                       | 接前一域的8位          |<br>| <code>clock_seq_low</code>                                              | 接前一域的8位          |<br>| <code>node</code>                                                       | UUID的最后48位         |<br>| <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> | UUID的总长60位的时间戳 |<br>| <code>clock_seq</code>                                                  | 14位的序列号           |</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.fields</span><br><span class="line">(<span class="number">305419896</span>, <span class="number">4660</span>, <span class="number">22136</span>, <span class="number">18</span>, <span class="number">52</span>, <span class="number">95073701484152</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>UUID.hex</code></p><p> 以32个字符表示的UUID</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.hex</span><br><span class="line"><span class="string">'12345678123456781234567812345678'</span></span><br></pre></td></tr></table></figure></li><li><p><code>UUID.int</code></p><p> 以一个长度为128个二进制位的整数表示的UUID；</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.int</span><br><span class="line"><span class="number">24197857161011715162171839636988778104</span></span><br></pre></td></tr></table></figure></li><li><p><code>UUID.urn</code></p><p> 以 RFC 4122 中指定的URN形式表示的UUID；</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.urn</span><br><span class="line"><span class="string">'urn:uuid:12345678-1234-5678-1234-567812345678'</span></span><br></pre></td></tr></table></figure></li><li><p><code>UUID.variant</code></p><p>　UUID变体（variant），决定UUID内部的布局，已有的值为 RESERVED_NCS、RFC_4122、RESERVED_MICROSOFT 或 RESERVED_FUTURE；</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.variant</span><br><span class="line"><span class="string">'reserved for NCS compatibility'</span></span><br></pre></td></tr></table></figure><ul><li><p><code>UUID.version</code></p><p>返回UUID的版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.version</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>　这里由于u.variant == ‘reserved for NCS compatibility’，所以此处u.version为空。 </p></li><li><p><code>UUID.is_safe</code></p><p>枚举类型的<code>SafeUUID</code>对象,为了标识创建的UUID是否是线程安全的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.is_safe</span><br><span class="line">&lt;SafeUUID.unknown: <span class="literal">None</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3></li></ul><p><strong>关于属性variant，uuid模块定义了如下的常量</strong></p><p> uuid.RESERVED_NCS<br>　　该常量为兼容NCS而保留；<br>　　<br> uuid.RFC_4122<br>　　按照 RFC 4122 的规定来确定UUID的布局；<br>　　<br> uuid.RESERVED_MICROSOFT<br>　　该常量位兼容微软而保留<br> 　　<br> uuid.RESERVED_FUTURE<br>　　该常量为未来可能的定义保留 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以在Python中查看这些常量：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.RESERVED_NCS</span><br><span class="line"><span class="string">'reserved for NCS compatibility'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.RFC_4122</span><br><span class="line"><span class="string">'specified in RFC 4122'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.RESERVED_MICROSOFT</span><br><span class="line"><span class="string">'reserved for Microsoft compatibility'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.RESERVED_FUTURE</span><br><span class="line"><span class="string">'reserved for future definition'</span></span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p><code>uuid.getnode</code>() </p><p>  　获取硬件的地址并以48位二进制长度的正整数形式返回，这里所说的硬件地址是指网络接口的MAC地址，如果一个机器有多个网络接口，可能返回其中的任一个。如果获取失败，将按照RFC 4122的规定将随机返回的48位二进制整数的第8位设置成1。 </p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.getnode()</span><br><span class="line"><span class="number">202960192043486</span></span><br></pre></td></tr></table></figure></li><li><p><code>uuid.uuid1</code>(<em>node=None</em>, <em>clock_seq=None</em>) </p><p>  　利用主机ID、序列号和当前时间生成一个UUID，如果参数 <em>node</em> 没有给定，会调用 getnode() 来获取硬件地址。如果参数中指定了 <em>clock_seq</em> ，使用参数中给定的时钟序列作为序列号，否则使用一个随机的14位长的序列号。 </p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid1()</span><br><span class="line">UUID(<span class="string">'97344912-4827-11ea-9c91-b8975a2679de'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>uuid.uuid3</code>(<em>namespace</em>, <em>name</em>) </p><p> 基于命名空间标识符（实质上是一个UUID）和一个名称（实质上是一个字符串）的MD5哈希值生成UUID。 </p></li><li><p><code>uuid.uuid4</code>() </p><p>生成一个随机的UUID。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid4()</span><br><span class="line">UUID(<span class="string">'ff3c991e-df64-4cfc-900e-ef83c991b513'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>uuid.uuid5</code>(<em>namespace</em>, <em>name</em>) </p><p>基于命名空间标识符（实质上是一个UUID）和一个名称（实质上是一个字符串）的SHA-1哈希值生成UUID </p></li></ul><p>下面的几个标准uuid在使用<code>uuid3()</code> 或<code>uuid5()</code>的时候使用</p><ul><li><p><code>uuid.NAMESPACE_DNS</code></p><p> 　当指定该命名空间时，参数 <em>name</em> 是一个完全限定的（fully-qualified）域名 </p></li><li><p><code>uuid.NAMESPACE_URL</code> </p><p> 当指定该命名空间时，参数 <em>name</em> 是一个URL </p></li><li><p><code>uuid.NAMESPACE_OID</code> </p><p> 当指定该命名空间时，参数 <em>name</em> 是一个ISO OID </p></li><li><p><code>uuid.NAMESPACE_X500</code> </p><p> 当指定该命名空间时，参数 <em>name</em> 是一个DER格式或文本格式的X.500 DN。 </p></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID based on the host ID and current time</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid1()</span><br><span class="line">UUID(<span class="string">'a8098c1a-f86e-11da-bd1a-00112444be1e'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID using an MD5 hash of a namespace UUID and a name</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid3(uuid.NAMESPACE_DNS, <span class="string">'python.org'</span>)</span><br><span class="line">UUID(<span class="string">'6fa459ea-ee8a-3ca4-894e-db77e160355e'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a random UUID</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid4()</span><br><span class="line">UUID(<span class="string">'16fd2706-8baf-433b-82eb-8c7fada847da'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID using a SHA-1 hash of a namespace UUID and a name</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid5(uuid.NAMESPACE_DNS, <span class="string">'python.org'</span>)</span><br><span class="line">UUID(<span class="string">'886313e1-3b8a-5372-9b90-0c9aee199e5d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID from a string of hex digits (braces and hyphens ignored)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = uuid.UUID(<span class="string">'&#123;00010203-0405-0607-0809-0a0b0c0d0e0f&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># convert a UUID to a string of hex digits in standard form</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(x)</span><br><span class="line"><span class="string">'00010203-0405-0607-0809-0a0b0c0d0e0f'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># get the raw 16 bytes of the UUID</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.bytes</span><br><span class="line"><span class="string">b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID from a 16-byte string</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.UUID(bytes=x.bytes)</span><br><span class="line">UUID(<span class="string">'00010203-0405-0607-0809-0a0b0c0d0e0f'</span>)</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="如何去除UUID字符串中的横杠"><a href="#如何去除UUID字符串中的横杠" class="headerlink" title="如何去除UUID字符串中的横杠"></a>如何去除UUID字符串中的横杠</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uid = str(uuid.uuid4())</span><br><span class="line">suid = <span class="string">''</span>.join(uid.split(<span class="string">'-'</span>))</span><br><span class="line"><span class="comment">## 等价于</span></span><br><span class="line">print(uuid.uuid1().hex)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-之-uuid&quot;&gt;&lt;a href=&quot;#python-标准库-之-uuid&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 之 uuid&quot;&gt;&lt;/a&gt;python 标准库 之 uuid&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200205update.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="uuid" scheme="https://pinghailinfeng.gitee.io/tags/uuid/"/>
    
  </entry>
  
  <entry>
    <title>python standard library urllib robotparser</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/04/python-standard-library-urllib-robotparser/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/04/python-standard-library-urllib-robotparser/</id>
    <published>2020-02-04T03:07:52.000Z</published>
    <updated>2020-02-04T10:54:47.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-urllib-robotparser"><a href="#python-标准库-urllib-robotparser" class="headerlink" title="python 标准库 urllib.robotparser"></a>python 标准库 urllib.robotparser</h1><p><img src="https://pic.superbed.cn/item/5c8e72043a213b0417a25657" alt></p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1334059163&auto=0&height=66"></iframe><blockquote><p>一切终将过去,我们仍旧前行,如同黑暗中的舞者。 </p><p>​                                                              – 临风语录</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/urllib/robotparser.py" target="_blank" rel="noopener">Lib/urllib/robotparser.py</a> </p><p> <code>robotparser</code> 实现了一个用于分析 <code>robots.txt</code> 文件格式的解析器， 它含有一个检查给定用户代理是否可以访问给定资源的函数。它的目的是给那些品行端正的爬虫用的，或用来指导需要节流，否则就会被限制访问的其他抓取器。</p><h2 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h2><p> <code>robots.txt</code> 文件是一个简单的基于文本的访问控制系统，用于控制那些自动访问网络资源的程序（如「爬虫」，「抓取器」，等等）。文件由特定的用户代理程序标识的记录以及代理不允许访问的 URLs （或 URL 前缀） 的一个列表组成。 </p><p>以我的博客为例</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> hexo robots.txt</span><br><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: https://pinghailinfeng.gitee.io/sitemap.xml</span><br><span class="line">Sitemap: https://pinghailinfeng.gitee.io/baidusitemap.xml</span><br></pre></td></tr></table></figure><p><em>允许所有爬虫访问内容</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User-Agent:  *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br></pre></td></tr></table></figure><p>不允许爬虫访问的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><em>class</em> <code>urllib.robotparser.RobotFileParser</code>(<em>url=’’</em>)</p><p>核心类通过下面方法读取、解析 通过url访问的<code>robots.txt</code>文件</p><ul><li><p><code>set_url</code>(<em>url</em>)</p><p>设定需要读取 <code>robots.txt</code>文件url路径</p></li><li><p><code>read</code>()</p><p>读取制定URL路径对应的 <code>robots.txt</code> 文件</p></li><li><p><code>parse</code>(<em>lines</em>)</p><p>解析参数指定的行</p></li><li><p><code>can_fetch</code>(<em>useragent</em>, <em>url</em>)</p><p>如果<code>useragent</code>被允许抓取<code>url</code>对应的<code>robots.txt</code>文件中包含了允许的规则,则返回<code>True</code></p></li><li><p><code>mtime</code>()</p><p>返回最后一次抓取<code>robots.txt</code>文件的时间。这是一个对长时间运行的网络爬虫用检查周期性<code>robots.txt</code>文件是否更新的很有用的方法。 </p></li><li><p><code>modified</code>()</p><p>设定最后一次抓取 <code>robots.txt</code> 文件的时间。</p></li><li><p><code>crawl_delay</code>(<em>useragent</em>)</p><p>返回  从<code>robots.txt</code> 中 <code>useragent</code>定义的 <code>Crawl-delay</code>  的值。如果没有这个参数或 在<code>useragent</code>中声明的参数格式不正确,返回<code>None</code>。</p><p><em>3.6 新版功能.</em></p></li><li><p><code>request_rate</code>(<em>useragent</em>)</p><p>返回作为<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-named-tuple" target="_blank" rel="noopener"><code>命名元组</code></a>类型的从  robots.txt 文件中 定义的 <code>Request-rate</code>参数内容。如果没有这个参数或在 robots.txt 文件中定义的<code>useragent</code>参数格式不正确,则返回<code>None</code>。</p><p><em>3.6 新版功能.</em></p></li><li><p><code>site_maps</code>()</p><p>返回 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list()</code></a> 类型的<code>Sitemap</code>参数内容。如果参数不存在或参数格式不正确,都返回<code>None</code>。</p></li></ul><h2 id="官方栗子"><a href="#官方栗子" class="headerlink" title="官方栗子"></a>官方栗子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> urllib.robotparser</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp = urllib.robotparser.RobotFileParser()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp.set_url(<span class="string">"http://www.musi-cal.com/robots.txt"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp.read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rrate = rp.request_rate(<span class="string">"*"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rrate.requests</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rrate.seconds</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp.crawl_delay(<span class="string">"*"</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp.can_fetch(<span class="string">"*"</span>, <span class="string">"http://www.musi-cal.com/cgi-bin/search?city=San+Francisco"</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rp.can_fetch(<span class="string">"*"</span>, <span class="string">"http://www.musi-cal.com/"</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="分析知乎"><a href="#分析知乎" class="headerlink" title="分析知乎"></a>分析知乎</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">分析知乎 Robots 协议</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> urllib.robotparser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rp = urllib.robotparser.RobotFileParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 robots.txt 文件 URL</span></span><br><span class="line">rp.set_url(<span class="string">'https://www.zhihu.com/robots.txt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取操作必须有, 不然后面解析不到</span></span><br><span class="line">rp.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断网址是否运行爬取</span></span><br><span class="line">print(rp.can_fetch(<span class="string">'Googlebot'</span>, <span class="string">'https://www.zhihu.com/question/264161961/answer/278828570'</span>))</span><br><span class="line">print(rp.can_fetch(<span class="string">'*'</span>, <span class="string">'https://www.zhihu.com/question/264161961/answer/278828570'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回上次抓取分析 robots.txt 时间</span></span><br><span class="line">print(rp.mtime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前时间设置为上次抓取和分析 robots.txt 的时间</span></span><br><span class="line">rp.modified()</span><br><span class="line">print(rp.mtime())  <span class="comment"># 再次打印时间会有变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回 robots.txt 文件对请求速率限制的值</span></span><br><span class="line">print(rp.request_rate(<span class="string">'*'</span>))</span><br><span class="line">print(rp.request_rate(<span class="string">'MSNBot'</span>).requests)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回 robotx.txt 文件对抓取延迟限制的值</span></span><br><span class="line">print(rp.crawl_delay(<span class="string">'*'</span>))</span><br><span class="line">print(rp.crawl_delay(<span class="string">'MSNBot'</span>))</span><br></pre></td></tr></table></figure><h2 id="分析我自己博客"><a href="#分析我自己博客" class="headerlink" title="分析我自己博客"></a>分析我自己博客</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.robotparser</span><br><span class="line"></span><br><span class="line">blog_url = <span class="string">'https://pinghailinfeng.gitee.io/robots.txt'</span></span><br><span class="line">rp = urllib.robotparser.RobotFileParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 robots.txt 文件 URL</span></span><br><span class="line">rp.set_url(blog_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取操作必须有, 不然后面解析不到</span></span><br><span class="line">rp.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断网址是否运行爬取</span></span><br><span class="line">print(rp.can_fetch(<span class="string">'*'</span>,<span class="string">'https://pinghailinfeng.gitee.io/archives/'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回上次抓取分析 robots.txt 时间</span></span><br><span class="line">print(rp.mtime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前时间设置为上次抓取和分析 robots.txt 的时间</span></span><br><span class="line">rp.modified()</span><br><span class="line">print(rp.mtime())  <span class="comment"># 再次打印时间会有变化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(rp.crawl_delay(<span class="string">'*'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(rp.site_maps())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1580804333.889091</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1580804333.889091</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'https://pinghailinfeng.gitee.io/sitemap.xml'</span>, <span class="string">'https://pinghailinfeng.gitee.io/baidusitemap.xml'</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-urllib-robotparser&quot;&gt;&lt;a href=&quot;#python-标准库-urllib-robotparser&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 urllib.robotparser&quot;&gt;&lt;/a&gt;python 标准库 urllib.robotparser&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://pic.superbed.cn/item/5c8e72043a213b0417a25657&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="urllib.robotparser" scheme="https://pinghailinfeng.gitee.io/tags/urllib-robotparser/"/>
    
  </entry>
  
  <entry>
    <title>python standard library itertools</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/03/python-standard-library-itertools/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/03/python-standard-library-itertools/</id>
    <published>2020-02-03T09:53:35.000Z</published>
    <updated>2020-02-04T10:54:47.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-itertools"><a href="#python-标准库-itertools" class="headerlink" title="python 标准库 itertools"></a>python 标准库 itertools</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200203_Alita-Battle-Angel-2019.png?raw=true" alt></p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1348507017&auto=0&height=66"></iframe><h1 id="为高效循环而创建迭代器的函数"><a href="#为高效循环而创建迭代器的函数" class="headerlink" title="为高效循环而创建迭代器的函数"></a>为高效循环而创建迭代器的函数</h1><p>本模块实现一系列 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a> ，这些迭代器受到APL，Haskell和SML的启发。为了适用于Python，它们都被重新写过。</p><p>本模块标准化了一个快速、高效利用内存的核心工具集，这些工具本身或组合都很有用。它们一起形成了“迭代器代数”，这使得在纯Python中有可能创建简洁又高效的专用工具。</p><p>例如，SML有一个制表工具： <code>tabulate(f)</code>，它可产生一个序列 <code>f(0), f(1), ...</code>。在Python中可以组合 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.count" target="_blank" rel="noopener"><code>count()</code></a> 实现： <code>map(f, count())</code>。</p><p>这些内置工具同时也能很好地与 <a href="https://docs.python.org/zh-cn/3.8/library/operator.html#module-operator" target="_blank" rel="noopener"><code>operator</code></a> 模块中的高效函数配合使用。例如，我们可以将两个向量的点积映射到乘法运算符： <code>sum(map(operator.mul, vector1, vector2))</code> 。</p><p><strong>无穷迭代器：</strong></p><table><thead><tr><th style="text-align:left">迭代器</th><th style="text-align:left">实参</th><th style="text-align:left">结果</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.count" target="_blank" rel="noopener"><code>count()</code></a></td><td style="text-align:left">start, [step]</td><td style="text-align:left">start, start+step, start+2*step, …</td><td style="text-align:left"><code>count(10) --&gt; 10 11 12 13 14 ...</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.cycle" target="_blank" rel="noopener"><code>cycle()</code></a></td><td style="text-align:left">p</td><td style="text-align:left">p0, p1, … plast, p0, p1, …</td><td style="text-align:left"><code>cycle(&#39;ABCD&#39;) --&gt; A B C D A B C D ...</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.repeat" target="_blank" rel="noopener"><code>repeat()</code></a></td><td style="text-align:left">elem [,n]</td><td style="text-align:left">elem, elem, elem, … 重复无限次或n次</td><td style="text-align:left"><code>repeat(10, 3) --&gt; 10 10 10</code></td></tr></tbody></table><p><strong>根据最短输入序列长度停止的迭代器：</strong></p><table><thead><tr><th style="text-align:left">迭代器</th><th style="text-align:left">实参</th><th style="text-align:left">结果</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.accumulate" target="_blank" rel="noopener"><code>accumulate()</code></a></td><td style="text-align:left">p [,func]</td><td style="text-align:left">p0, p0+p1, p0+p1+p2, …</td><td style="text-align:left"><code>accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.chain" target="_blank" rel="noopener"><code>chain()</code></a></td><td style="text-align:left">p, q, …</td><td style="text-align:left">p0, p1, … plast, q0, q1, …</td><td style="text-align:left"><code>chain(&#39;ABC&#39;, &#39;DEF&#39;) --&gt; A B C D E F</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.chain.from_iterable" target="_blank" rel="noopener"><code>chain.from_iterable()</code></a></td><td style="text-align:left">iterable</td><td style="text-align:left">p0, p1, … plast, q0, q1, …</td><td style="text-align:left"><code>chain.from_iterable([&#39;ABC&#39;, &#39;DEF&#39;]) --&gt; A B C D E F</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.compress" target="_blank" rel="noopener"><code>compress()</code></a></td><td style="text-align:left">data, selectors</td><td style="text-align:left">(d[0] if s[0]), (d[1] if s[1]), …</td><td style="text-align:left"><code>compress(&#39;ABCDEF&#39;, [1,0,1,0,1,1]) --&gt; A C E F</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.dropwhile" target="_blank" rel="noopener"><code>dropwhile()</code></a></td><td style="text-align:left">pred, seq</td><td style="text-align:left">seq[n], seq[n+1], … 从pred首次真值测试失败开始</td><td style="text-align:left"><code>dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.filterfalse" target="_blank" rel="noopener"><code>filterfalse()</code></a></td><td style="text-align:left">pred, seq</td><td style="text-align:left">seq中pred(x)为假值的元素，x是seq中的元素。</td><td style="text-align:left"><code>filterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.groupby" target="_blank" rel="noopener"><code>groupby()</code></a></td><td style="text-align:left">iterable[, key]</td><td style="text-align:left">根据key(v)值分组的迭代器</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.islice" target="_blank" rel="noopener"><code>islice()</code></a></td><td style="text-align:left">seq, [start,] stop [, step]</td><td style="text-align:left">seq[start:stop:step]中的元素</td><td style="text-align:left"><code>islice(&#39;ABCDEFG&#39;, 2, None) --&gt; C D E F G</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.starmap" target="_blank" rel="noopener"><code>starmap()</code></a></td><td style="text-align:left">func, seq</td><td style="text-align:left">func(<em>seq[0]), func(</em>seq[1]), …</td><td style="text-align:left"><code>starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.takewhile" target="_blank" rel="noopener"><code>takewhile()</code></a></td><td style="text-align:left">pred, seq</td><td style="text-align:left">seq[0], seq[1], …, 直到pred真值测试失败</td><td style="text-align:left"><code>takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4</code></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.tee" target="_blank" rel="noopener"><code>tee()</code></a></td><td style="text-align:left">it, n</td><td style="text-align:left">it1, it2, … itn 将一个迭代器拆分为n个迭代器</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.zip_longest" target="_blank" rel="noopener"><code>zip_longest()</code></a></td><td style="text-align:left">p, q, …</td><td style="text-align:left">(p[0], q[0]), (p[1], q[1]), …</td><td style="text-align:left"><code>zip_longest(&#39;ABCD&#39;, &#39;xy&#39;, fillvalue=&#39;-&#39;) --&gt; Ax By C- D-</code></td></tr></tbody></table><p><strong>排列组合迭代器：</strong></p><table><thead><tr><th style="text-align:left">迭代器</th><th style="text-align:left">实参</th><th style="text-align:left">结果</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.product" target="_blank" rel="noopener"><code>product()</code></a></td><td style="text-align:left">p, q, … [repeat=1]</td><td style="text-align:left">笛卡尔积，相当于嵌套的for循环</td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.permutations" target="_blank" rel="noopener"><code>permutations()</code></a></td><td style="text-align:left">p[, r]</td><td style="text-align:left">长度r元组，所有可能的排列，无重复元素</td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.combinations" target="_blank" rel="noopener"><code>combinations()</code></a></td><td style="text-align:left">p, r</td><td style="text-align:left">长度r元组，有序，无重复元素</td></tr><tr><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.combinations_with_replacement" target="_blank" rel="noopener"><code>combinations_with_replacement()</code></a></td><td style="text-align:left">p, r</td><td style="text-align:left">长度r元组，有序，元素可重复</td></tr></tbody></table><table><thead><tr><th style="text-align:left">例子</th><th style="text-align:left">结果</th></tr></thead><tbody><tr><td style="text-align:left"><code>product(&#39;ABCD&#39;, repeat=2)</code></td><td style="text-align:left"><code>AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD</code></td></tr><tr><td style="text-align:left"><code>permutations(&#39;ABCD&#39;, 2)</code></td><td style="text-align:left"><code>AB AC AD BA BC BD CA CB CD DA DB DC</code></td></tr><tr><td style="text-align:left"><code>combinations(&#39;ABCD&#39;, 2)</code></td><td style="text-align:left"><code>AB AC AD BC BD CD</code></td></tr><tr><td style="text-align:left"><code>combinations_with_replacement(&#39;ABCD&#39;, 2)</code></td><td style="text-align:left"><code>AA AB AC AD BB BC BD CC CD DD</code></td></tr></tbody></table><h2 id="Itertools数"><a href="#Itertools数" class="headerlink" title="Itertools数"></a>Itertools数</h2><p>下列模块函数均创建并返回迭代器。有些迭代器不限制输出流长度，所以它们只应在能截断输出流的函数或循环中使用。</p><ul><li><p><code>itertools.accumulate</code>(<em>iterable</em>[, <em>func</em>, <em>**, </em>initial=None*])</p><p>创建一个迭代器，返回累积汇总值或其他双目运算函数的累积结果值（通过可选的 <em>func</em> 参数指定）。如果提供了 <em>func</em>，它应当为带有两个参数的函数。 输入 <em>iterable</em> 的元素可以是能被 <em>func</em> 接受为参数的任意类型。 （例如，对于默认的加法运算，元素可以是任何可相加的类型包括 <a href="https://docs.python.org/zh-cn/3.8/library/decimal.html#decimal.Decimal" target="_blank" rel="noopener"><code>Decimal</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/fractions.html#fractions.Fraction" target="_blank" rel="noopener"><code>Fraction</code></a>。）通常，输出的元素数量与输入的可迭代对象是一致的。 但是，如果提供了关键字参数 <em>initial</em>，则累加会以 <em>initial</em> 值开始，这样输出就比输入的可迭代对象多一个元素。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accumulate</span><span class="params">(iterable, func=operator.add, *, initial=None)</span>:</span></span><br><span class="line">    <span class="string">'Return running totals'</span></span><br><span class="line">    <span class="comment"># accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15</span></span><br><span class="line">    <span class="comment"># accumulate([1,2,3,4,5], initial=100) --&gt; 100 101 103 106 110 115</span></span><br><span class="line">    <span class="comment"># accumulate([1,2,3,4,5], operator.mul) --&gt; 1 2 6 24 120</span></span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    total = initial</span><br><span class="line">    <span class="keyword">if</span> initial <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            total = next(it)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">yield</span> total</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">        total = func(total, element)</span><br><span class="line">        <span class="keyword">yield</span> total</span><br></pre></td></tr></table></figure><p><em>func</em> 参数有几种用法。它可以被设为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#min" target="_blank" rel="noopener"><code>min()</code></a> 最终得到一个最小值，或者设为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#max" target="_blank" rel="noopener"><code>max()</code></a> 最终得到一个最大值，或设为 <a href="https://docs.python.org/zh-cn/3.8/library/operator.html#operator.mul" target="_blank" rel="noopener"><code>operator.mul()</code></a> 最终得到一个乘积。摊销表可通过累加利息和支付款项得到。给iterable设置初始值并只将参数 <em>func</em> 参数有几种用法。它可以被设为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#min" target="_blank" rel="noopener"><code>min()</code></a> 最终得到一个最小值，或者设为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#max" target="_blank" rel="noopener"><code>max()</code></a> 最终得到一个最大值，或设为 <a href="https://docs.python.org/zh-cn/3.8/library/operator.html#operator.mul" target="_blank" rel="noopener"><code>operator.mul()</code></a> 最终得到一个乘积。摊销表可通过累加利息和支付款项得到。给iterable设置初始值并只将参数 <em>func</em> 设为累加总数可以对一阶 <a href="https://en.wikipedia.org/wiki/Recurrence_relation" target="_blank" rel="noopener">递归关系</a> 建模。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(accumulate(data, operator.mul))     <span class="comment"># running product</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">12</span>, <span class="number">72</span>, <span class="number">144</span>, <span class="number">144</span>, <span class="number">1296</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(accumulate(data, max))              <span class="comment"># running maximum</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Amortize a 5% loan of 1000 with 4 annual payments of 90</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cashflows = [<span class="number">1000</span>, <span class="number">-90</span>, <span class="number">-90</span>, <span class="number">-90</span>, <span class="number">-90</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(accumulate(cashflows, <span class="keyword">lambda</span> bal, pmt: bal*<span class="number">1.05</span> + pmt))</span><br><span class="line">[<span class="number">1000</span>, <span class="number">960.0</span>, <span class="number">918.0</span>, <span class="number">873.9000000000001</span>, <span class="number">827.5950000000001</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>logistic_map = <span class="keyword">lambda</span> x, _:  r * x * (<span class="number">1</span> - x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="number">3.8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x0 = <span class="number">0.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inputs = repeat(x0, <span class="number">36</span>)     <span class="comment"># only the initial value is used</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[format(x, <span class="string">'.2f'</span>) <span class="keyword">for</span> x <span class="keyword">in</span> accumulate(inputs, logistic_map)]</span><br><span class="line">[<span class="string">'0.40'</span>, <span class="string">'0.91'</span>, <span class="string">'0.30'</span>, <span class="string">'0.81'</span>, <span class="string">'0.60'</span>, <span class="string">'0.92'</span>, <span class="string">'0.29'</span>, <span class="string">'0.79'</span>, <span class="string">'0.63'</span>,</span><br><span class="line"> <span class="string">'0.88'</span>, <span class="string">'0.39'</span>, <span class="string">'0.90'</span>, <span class="string">'0.33'</span>, <span class="string">'0.84'</span>, <span class="string">'0.52'</span>, <span class="string">'0.95'</span>, <span class="string">'0.18'</span>, <span class="string">'0.57'</span>,</span><br><span class="line"> <span class="string">'0.93'</span>, <span class="string">'0.25'</span>, <span class="string">'0.71'</span>, <span class="string">'0.79'</span>, <span class="string">'0.63'</span>, <span class="string">'0.88'</span>, <span class="string">'0.39'</span>, <span class="string">'0.91'</span>, <span class="string">'0.32'</span>,</span><br><span class="line"> <span class="string">'0.83'</span>, <span class="string">'0.54'</span>, <span class="string">'0.95'</span>, <span class="string">'0.20'</span>, <span class="string">'0.60'</span>, <span class="string">'0.91'</span>, <span class="string">'0.30'</span>, <span class="string">'0.80'</span>, <span class="string">'0.60'</span>]</span><br></pre></td></tr></table></figure><p>参考一个类似函数 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.reduce" target="_blank" rel="noopener"><code>functools.reduce()</code></a> ，它只返回一个最终累积值。</p><p><em>3.2 新版功能.</em></p><p><em>在 3.3 版更改:</em> 增加可选参数 <em>func</em> 。</p><p><em>在 3.8 版更改:</em> 添加了可选的 <em>initial</em> 形参。</p></li><li><p><code>itertools.chain</code>(<em>iterables</em>)</p><p>创建一个迭代器，它首先返回第一个可迭代对象中所有元素，接着返回下一个可迭代对象中所有元素，直到耗尽所有可迭代对象中的元素。可将多个序列处理为单个序列。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="comment"># chain('ABC', 'DEF') --&gt; A B C D E F</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">            <span class="keyword">yield</span> element</span><br></pre></td></tr></table></figure></li><li><p><em>classmethod</em> <code>chain.from_iterable</code>(<em>iterable</em>)</p><p>构建类似 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.chain" target="_blank" rel="noopener"><code>chain()</code></a> 迭代器的另一个选择。从一个单独的可迭代参数中得到链式输入，该参数是延迟计算的。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">from_iterable</span><span class="params">(iterables)</span>:</span></span><br><span class="line">    <span class="comment"># chain.from_iterable(['ABC', 'DEF']) --&gt; A B C D E F</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">            <span class="keyword">yield</span> element</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.combinations</code>(<em>iterable</em>, <em>r</em>)</p><p>返回由输入 <em>iterable</em> 中元素组成长度为 <em>r</em> 的子序列。组合按照字典序返回。所以如果输入 <em>iterable</em> 是有序的，生成的组合元组也是有序的。即使元素的值相同，不同位置的元素也被认为是不同的。如果元素各自不同，那么每个组合中没有重复元素。大致相当于:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinations</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    <span class="comment"># combinations('ABCD', 2) --&gt; AB AC AD BC BD CD</span></span><br><span class="line">    <span class="comment"># combinations(range(4), 3) --&gt; 012 013 023 123</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    <span class="keyword">if</span> r &gt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">  indices = list(range(r))</span><br><span class="line">    <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(r)):</span><br><span class="line">            <span class="keyword">if</span> indices[i] != i + n - r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        indices[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, r):</span><br><span class="line">            indices[j] = indices[j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure><p><code>combinations()</code> 的代码可被改写为 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.permutations" target="_blank" rel="noopener"><code>permutations()</code></a> 过滤后的子序列，（相对于元素在输入中的位置）元素不是有序的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinations</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    <span class="keyword">for</span> indices <span class="keyword">in</span> permutations(range(n), r):</span><br><span class="line">        <span class="keyword">if</span> sorted(indices) == list(indices):</span><br><span class="line">            <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure></li></ul><p>当 <code>0 &lt;= r &lt;= n</code> 时，返回项的个数是 <code>n! / r! / (n-r)!</code>；当 <code>r &gt; n</code> 时，返回项个数为0。</p><ul><li><p><code>itertools.combinations_with_replacement</code>(<em>iterable</em>, <em>r</em>)</p><p>返回由输入 <em>iterable</em> 中元素组成的长度为 <em>r</em> 的子序列，允许每个元素可重复出现。组合按照字典序返回。所以如果输入 <em>iterable</em> 是有序的，生成的组合元组也是有序的。不同位置的元素是不同的，即使它们的值相同。因此如果输入中的元素都是不同的话，返回的组合中元素也都会不同。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinations_with_replacement</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    <span class="comment"># combinations_with_replacement('ABC', 2) --&gt; AA AB AC BB BC CC</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">and</span> r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    indices = [<span class="number">0</span>] * r</span><br><span class="line">    <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(r)):</span><br><span class="line">            <span class="keyword">if</span> indices[i] != n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        indices[i:] = [indices[i] + <span class="number">1</span>] * (r - i)</span><br><span class="line">        <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure><p> <code>combinations_with_replacement() 的代码可被改写为</code>production()` 过滤后的子序列，（相对于元素在输入中的位置）元素不是有序的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinations_with_replacement</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    <span class="keyword">for</span> indices <span class="keyword">in</span> product(range(n), repeat=r):</span><br><span class="line">        <span class="keyword">if</span> sorted(indices) == list(indices):</span><br><span class="line">            <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>itertools.compress</code>(<em>data</em>, <em>selectors</em>)</p><p>创建一个迭代器，它返回 <em>data</em> 中经 <em>selectors</em> 真值测试为 <code>True</code> 的元素。迭代器在两者较短的长度处停止。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compress</span><span class="params">(data, selectors)</span>:</span></span><br><span class="line">    <span class="comment"># compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F</span></span><br><span class="line">    <span class="keyword">return</span> (d <span class="keyword">for</span> d, s <span class="keyword">in</span> zip(data, selectors) <span class="keyword">if</span> s)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>itertools.count</code>(<em>start=0</em>, <em>step=1</em>)</p><p>创建一个迭代器，它从 <em>start</em> 值开始，返回均匀间隔的值。常用于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 中的实参来生成连续的数据点。此外，还用于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#zip" target="_blank" rel="noopener"><code>zip()</code></a> 来添加序列号。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(start=<span class="number">0</span>, step=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment"># count(10) --&gt; 10 11 12 13 14 ...</span></span><br><span class="line">    <span class="comment"># count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...</span></span><br><span class="line">    n = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += step</span><br><span class="line">~</span><br></pre></td></tr></table></figure><p>当对浮点数计数时，替换为乘法代码有时精度会更好，例如： <code>(start + step * i for i in count())</code> 。<em>在 3.1 版更改:</em> 增加参数 <em>step</em> ，允许非整型。</p></li><li><p><code>itertools.cycle</code>(<em>iterable</em>)</p><p>创建一个迭代器，返回 <em>iterable</em> 中所有元素并保存一个副本。当取完 <em>iterable</em> 中所有元素，返回副本中的所有元素。无限重复。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cycle</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="comment"># cycle('ABCD') --&gt; A B C D A B C D A B C D ...</span></span><br><span class="line">    saved = []</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">yield</span> element</span><br><span class="line">        saved.append(element)</span><br><span class="line">    <span class="keyword">while</span> saved:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> saved:</span><br><span class="line">              <span class="keyword">yield</span> element</span><br></pre></td></tr></table></figure></li></ul><p>   `注意，该函数可能需要相当大的辅助空间（取决于 <em>iterable</em> 的长度）。</p><ul><li><p><code>itertools.dropwhile</code>(<em>predicate</em>, <em>iterable</em>)</p><p>创建一个迭代器，如果 <em>predicate</em> 为true，迭代器丢弃这些元素，然后返回其他元素。注意，迭代器在 <em>predicate</em> 首次为false之前不会产生任何输出，所以可能需要一定长度的启动时间。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropwhile</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1</span></span><br><span class="line">    iterable = iter(iterable)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">yield</span> x</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.filterfalse</code>(<em>predicate</em>, <em>iterable</em>)</p><p>创建一个迭代器，只返回 <em>iterable</em> 中 <em>predicate</em> 为 <code>False</code> 的元素。如果 <em>predicate</em> 是 <code>None</code>，返回真值测试为false的元素。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filterfalse</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># filterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8</span></span><br><span class="line">    <span class="keyword">if</span> predicate <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        predicate = bool</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>itertools.groupby</code>(<em>iterable</em>, <em>key=None</em>)</p><p>创建一个迭代器，返回 <em>iterable</em> 中连续的键和组。<em>key</em> 是一个计算元素键值函数。如果未指定或为 <code>None</code>，<em>key</em> 缺省为恒等函数（identity function），返回元素不变。一般来说，<em>iterable</em> 需用同一个键值函数预先排序。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.groupby" target="_blank" rel="noopener"><code>groupby()</code></a> 操作类似于Unix中的 <code>uniq</code>。当每次 <em>key</em> 函数产生的键值改变时，迭代器会分组或生成一个新组（这就是为什么通常需要使用同一个键值函数先对数据进行排序）。这种行为与SQL的GROUP BY操作不同，SQL的操作会忽略输入的顺序将相同键值的元素分在同组中。</p><p>返回的组本身也是一个迭代器，它与 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.groupby" target="_blank" rel="noopener"><code>groupby()</code></a> 共享底层的可迭代对象。因为源是共享的，当 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.groupby" target="_blank" rel="noopener"><code>groupby()</code></a> 对象向后迭代时，前一个组将消失。因此如果稍后还需要返回结果，可保存为列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">groups = []</span><br><span class="line">uniquekeys = []</span><br><span class="line">data = sorted(data, key=keyfunc)</span><br><span class="line"><span class="keyword">for</span> k, g <span class="keyword">in</span> groupby(data, keyfunc):</span><br><span class="line">    groups.append(list(g))      <span class="comment"># Store group iterator as a list</span></span><br><span class="line">    uniquekeys.append(k)</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.groupby" target="_blank" rel="noopener"><code>groupby()</code></a> 大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">groupby</span>:</span></span><br><span class="line">    <span class="comment"># [k for k, g in groupby('AAAABBBCCDAABBB')] --&gt; A B C D A B</span></span><br><span class="line">    <span class="comment"># [list(g) for k, g in groupby('AAAABBBCCD')] --&gt; AAAA BBB CC D</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable, key=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            key = <span class="keyword">lambda</span> x: x</span><br><span class="line">        self.keyfunc = key</span><br><span class="line">        self.it = iter(iterable)</span><br><span class="line">        self.tgtkey = self.currkey = self.currvalue = object()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.id = object()</span><br><span class="line">        <span class="keyword">while</span> self.currkey == self.tgtkey:</span><br><span class="line">            self.currvalue = next(self.it)    <span class="comment"># Exit on StopIteration</span></span><br><span class="line">            self.currkey = self.keyfunc(self.currvalue)</span><br><span class="line">        self.tgtkey = self.currkey</span><br><span class="line">        <span class="keyword">return</span> (self.currkey, self._grouper(self.tgtkey, self.id))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_grouper</span><span class="params">(self, tgtkey, id)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.id <span class="keyword">is</span> id <span class="keyword">and</span> self.currkey == tgtkey:</span><br><span class="line">            <span class="keyword">yield</span> self.currvalue</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.currvalue = next(self.it)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.currkey = self.keyfunc(self.currvalue)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>itertools.islice</code>(<em>iterable</em>, <em>stop</em>)</p></li><li><p><code>itertools.islice</code>(<em>iterable</em>, <em>start</em>, <em>stop</em>[, <em>step</em>])</p><p>创建一个迭代器，返回从 <em>iterable</em> 里选中的元素。如果 <em>start</em> 不是0，跳过 <em>iterable</em> 中的元素，直到到达 <em>start</em> 这个位置。之后迭代器连续返回元素，除非 <em>step</em> 设置的值很高导致被跳过。如果 <em>stop</em> 为 <code>None</code>，迭代器耗光为止；否则，在指定的位置停止。与普通的切片不同，<a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.islice" target="_blank" rel="noopener"><code>islice()</code></a> 不支持将 <em>start</em> ， <em>stop</em> ，或 <em>step</em> 设为负值。可用来从内部数据结构被压平的数据中提取相关字段（例如一个多行报告，它的名称字段出现在每三行上）。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">islice</span><span class="params">(iterable, *args)</span>:</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2) --&gt; A B</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2, 4) --&gt; C D</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 2, None) --&gt; C D E F G</span></span><br><span class="line">    <span class="comment"># islice('ABCDEFG', 0, None, 2) --&gt; A C E G</span></span><br><span class="line">    s = slice(*args)</span><br><span class="line">    start, stop, step = s.start <span class="keyword">or</span> <span class="number">0</span>, s.stop <span class="keyword">or</span> sys.maxsize, s.step <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">    it = iter(range(start, stop, step))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        nexti = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># Consume *iterable* up to the *start* position.</span></span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> zip(range(start), iterable):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(iterable):</span><br><span class="line">            <span class="keyword">if</span> i == nexti:</span><br><span class="line">                <span class="keyword">yield</span> element</span><br><span class="line">                nexti = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># Consume to *stop*.</span></span><br><span class="line">        <span class="keyword">for</span> i, element <span class="keyword">in</span> zip(range(i + <span class="number">1</span>, stop), iterable):</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>如果 <em>start</em> 为 <code>None</code>，迭代从0开始。如果 <em>step</em> 为 <code>None</code> ，步长缺省为1。</p></li><li><p><code>itertools.permutations</code>(<em>iterable</em>, <em>r=None</em>)</p><p>连续返回由 <em>iterable</em> 元素生成长度为 <em>r</em> 的排列。如果 <em>r</em> 未指定或为 <code>None</code> ，<em>r</em> 默认设置为 <em>iterable</em> 的长度，这种情况下，生成所有全长排列。排列依字典序发出。因此，如果 <em>iterable</em> 是已排序的，排列元组将有序地产出。即使元素的值相同，不同位置的元素也被认为是不同的。如果元素值都不同，每个排列中的元素值不会重复。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(iterable, r=None)</span>:</span></span><br><span class="line">    <span class="comment"># permutations('ABCD', 2) --&gt; AB AC AD BA BC BD CA CB CD DA DB DC</span></span><br><span class="line">    <span class="comment"># permutations(range(3)) --&gt; 012 021 102 120 201 210</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    r = n <span class="keyword">if</span> r <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> r</span><br><span class="line">    <span class="keyword">if</span> r &gt; n:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    indices = list(range(n))</span><br><span class="line">    cycles = list(range(n, n-r, <span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices[:r])</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(r)):</span><br><span class="line">            cycles[i] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cycles[i] == <span class="number">0</span>:</span><br><span class="line">                indices[i:] = indices[i+<span class="number">1</span>:] + indices[i:i+<span class="number">1</span>]</span><br><span class="line">                cycles[i] = n - i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = cycles[i]</span><br><span class="line">                indices[i], indices[-j] = indices[-j], indices[i]</span><br><span class="line">                <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices[:r])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.permutations" target="_blank" rel="noopener"><code>permutations()</code></a> 的代码也可被改写为 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.product" target="_blank" rel="noopener"><code>product()</code></a> 的子序列，只要将含有重复元素（来自输入中同一位置的）的项排除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutations</span><span class="params">(iterable, r=None)</span>:</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    r = n <span class="keyword">if</span> r <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> r</span><br><span class="line">    <span class="keyword">for</span> indices <span class="keyword">in</span> product(range(n), repeat=r):</span><br><span class="line">        <span class="keyword">if</span> len(set(indices)) == r:</span><br><span class="line">            <span class="keyword">yield</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br></pre></td></tr></table></figure><p>当 <code>0 &lt;= r &lt;= n</code> ，返回项个数为 <code>n! / (n-r)!</code> ；当 <code>r &gt; n</code> ，返回项个数为0。</p></li><li><p><code>itertools.product</code>(*<em>iterables</em>, <em>repeat=1</em>)</p><p>可迭代对象输入的笛卡儿积。大致相当于生成器表达式中的嵌套循环。例如， <code>product(A, B)</code> 和 <code>((x,y) for x in A for y in B)</code> 返回结果一样。</p><p>嵌套循环像里程表那样循环变动，每次迭代时将最右侧的元素向后迭代。这种模式形成了一种字典序，因此如果输入的可迭代对象是已排序的，笛卡尔积元组依次序发出。</p><p>要计算可迭代对象自身的笛卡尔积，将可选参数 <em>repeat</em> 设定为要重复的次数。例如，<code>product(A, repeat=4)</code> 和 <code>product(A, A, A, A)</code> 是一样的。</p><p>该函数大致相当于下面的代码，只不过实际实现方案不会在内存中创建中间结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span><span class="params">(*args, repeat=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="comment"># product('ABCD', 'xy') --&gt; Ax Ay Bx By Cx Cy Dx Dy</span></span><br><span class="line">    <span class="comment"># product(range(2), repeat=3) --&gt; 000 001 010 011 100 101 110 111</span></span><br><span class="line">    pools = [tuple(pool) <span class="keyword">for</span> pool <span class="keyword">in</span> args] * repeat</span><br><span class="line">    result = [[]]</span><br><span class="line">    <span class="keyword">for</span> pool <span class="keyword">in</span> pools:</span><br><span class="line">        result = [x+[y] <span class="keyword">for</span> x <span class="keyword">in</span> result <span class="keyword">for</span> y <span class="keyword">in</span> pool]</span><br><span class="line">    <span class="keyword">for</span> prod <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">yield</span> tuple(prod)</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.repeat</code>(<em>object</em>[, <em>times</em>])</p><p>创建一个迭代器，不断重复 <em>object</em> 。除非设定参数 <em>times</em> ，否则将无限重复。可用于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 函数中的参数，被调用函数可得到一个不变参数。也可用于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#zip" target="_blank" rel="noopener"><code>zip()</code></a> 的参数以在元组记录中创建一个不变的部分。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeat</span><span class="params">(object, times=None)</span>:</span></span><br><span class="line">    <span class="comment"># repeat(10, 3) --&gt; 10 10 10</span></span><br><span class="line">    <span class="keyword">if</span> times <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">yield</span> object</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(times):</span><br><span class="line">            <span class="keyword">yield</span> object</span><br></pre></td></tr></table></figure><p><em>repeat</em> 最常见的用途就是在 <em>map</em> 或 <em>zip</em> 提供一个常量流：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(pow, range(<span class="number">10</span>), repeat(<span class="number">2</span>)))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.starmap</code>(<em>function</em>, <em>iterable</em>)</p><p>创建一个迭代器，使用从可迭代对象中获取的参数来计算该函数。当参数对应的形参已从一个单独可迭代对象组合为元组时（数据已被“预组对”）可用此函数代替 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a> 与 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.starmap" target="_blank" rel="noopener"><code>starmap()</code></a> 之间的区别可以类比 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">starmap</span><span class="params">(function, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000</span></span><br><span class="line">    <span class="keyword">for</span> args <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">yield</span> function(*args)</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.takewhile</code>(<em>predicate</em>, <em>iterable</em>)</p><p>创建一个迭代器，只要 predicate 为真就从可迭代对象中返回元素。大致相当于:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takewhile</span><span class="params">(predicate, iterable)</span>:</span></span><br><span class="line">    <span class="comment"># takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> predicate(x):</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li><li><p><code>itertools.tee</code>(<em>iterable</em>, <em>n=2</em>)</p><p>从一个可迭代对象中返回 <em>n</em> 个独立的迭代器。下面的Python代码能帮助解释 <em>tee</em> 做了什么（尽管实际的实现更复杂，而且仅使用了一个底层的 FIFO 队列）。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tee</span><span class="params">(iterable, n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    deques = [collections.deque() <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(mydeque)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> mydeque:             <span class="comment"># when the local deque is empty</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    newval = next(it)   <span class="comment"># fetch a new value and</span></span><br><span class="line">                <span class="keyword">except</span> StopIteration:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> deques:        <span class="comment"># load it to all the deques</span></span><br><span class="line">                    d.append(newval)</span><br><span class="line">            <span class="keyword">yield</span> mydeque.popleft()</span><br><span class="line">    <span class="keyword">return</span> tuple(gen(d) <span class="keyword">for</span> d <span class="keyword">in</span> deques)</span><br></pre></td></tr></table></figure><p>一旦 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.tee" target="_blank" rel="noopener"><code>tee()</code></a> 实施了一次分裂，原有的 <em>iterable</em> 不应再被使用；否则tee对象无法得知 <em>iterable</em> 可能已向后迭代。</p><p><code>tee</code> 迭代器不是线程安全的。当同时使用由同一个 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.tee" target="_blank" rel="noopener"><code>tee()</code></a> 调用所返回的迭代器时可能引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>，即使原本的 <em>iterable</em> 是线程安全的。</p><p>该迭代工具可能需要相当大的辅助存储空间（这取决于要保存多少临时数据）。通常，如果一个迭代器在另一个迭代器开始之前就要使用大部份或全部数据，使用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list()</code></a> 会比 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.tee" target="_blank" rel="noopener"><code>tee()</code></a> 更快。</p></li><li><p><code>itertools.zip_longest</code>(*<em>iterables</em>, <em>fillvalue=None</em>)</p><p>创建一个迭代器，从每个可迭代对象中收集元素。如果可迭代对象的长度未对齐，将根据 <em>fillvalue</em> 填充缺失值。迭代持续到耗光最长的可迭代对象。大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip_longest</span><span class="params">(*args, fillvalue=None)</span>:</span></span><br><span class="line">    <span class="comment"># zip_longest('ABCD', 'xy', fillvalue='-') --&gt; Ax By C- D-</span></span><br><span class="line">    iterators = [iter(it) <span class="keyword">for</span> it <span class="keyword">in</span> args]</span><br><span class="line">    num_active = len(iterators)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> num_active:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        values = []</span><br><span class="line">        <span class="keyword">for</span> i, it <span class="keyword">in</span> enumerate(iterators):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                value = next(it)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                num_active -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> num_active:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                iterators[i] = repeat(fillvalue)</span><br><span class="line">                value = fillvalue</span><br><span class="line">            values.append(value)</span><br><span class="line">        <span class="keyword">yield</span> tuple(values)</span><br></pre></td></tr></table></figure><p>如果其中一个可迭代对象有无限长度，<a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.zip_longest" target="_blank" rel="noopener"><code>zip_longest()</code></a> 函数应封装在限制调用次数的场景中（例如 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.islice" target="_blank" rel="noopener"><code>islice()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.takewhile" target="_blank" rel="noopener"><code>takewhile()</code></a>）。除非指定， <em>fillvalue</em> 默认为 <code>None</code> 。</p></li></ul><h2 id="itertools-扩展"><a href="#itertools-扩展" class="headerlink" title="itertools 扩展"></a>itertools 扩展</h2><p>本节将展示如何使用现有的 itertools 作为基础构件来创建扩展的工具集。</p><p>基本上所有这些西方和许许多多其他的配方都可以通过 Python Package Index 上的 <a href="https://pypi.org/project/more-itertools/" target="_blank" rel="noopener">more-itertools 项目</a> 来安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install more-itertools</span><br></pre></td></tr></table></figure><p>扩展的工具提供了与底层工具集相同的高性能。保持了超棒的内存利用率，因为一次只处理一个元素，而不是将整个可迭代对象加载到内存。代码量保持得很小，以函数式风格将这些工具连接在一起，有助于消除临时变量。速度依然很快，因为倾向于使用“矢量化”构件来取代解释器开销大的 for 循环和 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span><span class="params">(n, iterable)</span>:</span></span><br><span class="line">    <span class="string">"Return first n items of the iterable as a list"</span></span><br><span class="line">    <span class="keyword">return</span> list(islice(iterable, n))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepend</span><span class="params">(value, iterator)</span>:</span></span><br><span class="line">    <span class="string">"Prepend a single value in front of an iterator"</span></span><br><span class="line">    <span class="comment"># prepend(1, [2, 3, 4]) -&gt; 1 2 3 4</span></span><br><span class="line">    <span class="keyword">return</span> chain([value], iterator)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tabulate</span><span class="params">(function, start=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"Return function(0), function(1), ..."</span></span><br><span class="line">    <span class="keyword">return</span> map(function, count(start))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tail</span><span class="params">(n, iterable)</span>:</span></span><br><span class="line">    <span class="string">"Return an iterator over the last n items"</span></span><br><span class="line">    <span class="comment"># tail(3, 'ABCDEFG') --&gt; E F G</span></span><br><span class="line">    <span class="keyword">return</span> iter(collections.deque(iterable, maxlen=n))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">(iterator, n=None)</span>:</span></span><br><span class="line">    <span class="string">"Advance the iterator n-steps ahead. If n is None, consume entirely."</span></span><br><span class="line">    <span class="comment"># Use functions that consume iterators at C speed.</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># feed the entire iterator into a zero-length deque</span></span><br><span class="line">        collections.deque(iterator, maxlen=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># advance to the empty slice starting at position n</span></span><br><span class="line">        next(islice(iterator, n, n), <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nth</span><span class="params">(iterable, n, default=None)</span>:</span></span><br><span class="line">    <span class="string">"Returns the nth item or a default value"</span></span><br><span class="line">    <span class="keyword">return</span> next(islice(iterable, n, <span class="literal">None</span>), default)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_equal</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="string">"Returns True if all the elements are equal to each other"</span></span><br><span class="line">    g = groupby(iterable)</span><br><span class="line">    <span class="keyword">return</span> next(g, <span class="literal">True</span>) <span class="keyword">and</span> <span class="keyword">not</span> next(g, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantify</span><span class="params">(iterable, pred=bool)</span>:</span></span><br><span class="line">    <span class="string">"Count how many times the predicate is true"</span></span><br><span class="line">    <span class="keyword">return</span> sum(map(pred, iterable))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padnone</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="string">"""Returns the sequence elements and then returns None indefinitely.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Useful for emulating the behavior of the built-in map() function.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> chain(iterable, repeat(<span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ncycles</span><span class="params">(iterable, n)</span>:</span></span><br><span class="line">    <span class="string">"Returns the sequence elements n times"</span></span><br><span class="line">    <span class="keyword">return</span> chain.from_iterable(repeat(tuple(iterable), n))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dotproduct</span><span class="params">(vec1, vec2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(map(operator.mul, vec1, vec2))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(list_of_lists)</span>:</span></span><br><span class="line">    <span class="string">"Flatten one level of nesting"</span></span><br><span class="line">    <span class="keyword">return</span> chain.from_iterable(list_of_lists)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeatfunc</span><span class="params">(func, times=None, *args)</span>:</span></span><br><span class="line">    <span class="string">"""Repeat calls to func with specified arguments.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Example:  repeatfunc(random.random)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> times <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> starmap(func, repeat(args))</span><br><span class="line">    <span class="keyword">return</span> starmap(func, repeat(args, times))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pairwise</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="string">"s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."</span></span><br><span class="line">    a, b = tee(iterable)</span><br><span class="line">    next(b, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">return</span> zip(a, b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(iterable, n, fillvalue=None)</span>:</span></span><br><span class="line">    <span class="string">"Collect data into fixed-length chunks or blocks"</span></span><br><span class="line">    <span class="comment"># grouper('ABCDEFG', 3, 'x') --&gt; ABC DEF Gxx"</span></span><br><span class="line">    args = [iter(iterable)] * n</span><br><span class="line">    <span class="keyword">return</span> zip_longest(*args, fillvalue=fillvalue)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">roundrobin</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="string">"roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"</span></span><br><span class="line">    <span class="comment"># Recipe credited to George Sakkis</span></span><br><span class="line">    num_active = len(iterables)</span><br><span class="line">    nexts = cycle(iter(it).__next__ <span class="keyword">for</span> it <span class="keyword">in</span> iterables)</span><br><span class="line">    <span class="keyword">while</span> num_active:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> next <span class="keyword">in</span> nexts:</span><br><span class="line">                <span class="keyword">yield</span> next()</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="comment"># Remove the iterator we just exhausted from the cycle.</span></span><br><span class="line">            num_active -= <span class="number">1</span></span><br><span class="line">            nexts = cycle(islice(nexts, num_active))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(pred, iterable)</span>:</span></span><br><span class="line">    <span class="string">'Use a predicate to partition entries into false entries and true entries'</span></span><br><span class="line">    <span class="comment"># partition(is_odd, range(10)) --&gt; 0 2 4 6 8   and  1 3 5 7 9</span></span><br><span class="line">    t1, t2 = tee(iterable)</span><br><span class="line">    <span class="keyword">return</span> filterfalse(pred, t1), filter(pred, t2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">powerset</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="string">"powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"</span></span><br><span class="line">    s = list(iterable)</span><br><span class="line">    <span class="keyword">return</span> chain.from_iterable(combinations(s, r) <span class="keyword">for</span> r <span class="keyword">in</span> range(len(s)+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unique_everseen</span><span class="params">(iterable, key=None)</span>:</span></span><br><span class="line">    <span class="string">"List unique elements, preserving order. Remember all elements ever seen."</span></span><br><span class="line">    <span class="comment"># unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D</span></span><br><span class="line">    <span class="comment"># unique_everseen('ABBCcAD', str.lower) --&gt; A B C D</span></span><br><span class="line">    seen = set()</span><br><span class="line">    seen_add = seen.add</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> filterfalse(seen.__contains__, iterable):</span><br><span class="line">            seen_add(element)</span><br><span class="line">            <span class="keyword">yield</span> element</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">            k = key(element)</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen_add(k)</span><br><span class="line">                <span class="keyword">yield</span> element</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unique_justseen</span><span class="params">(iterable, key=None)</span>:</span></span><br><span class="line">    <span class="string">"List unique elements, preserving order. Remember only the element just seen."</span></span><br><span class="line">    <span class="comment"># unique_justseen('AAAABBBCCDAABBB') --&gt; A B C D A B</span></span><br><span class="line">    <span class="comment"># unique_justseen('ABBCcAD', str.lower) --&gt; A B C A D</span></span><br><span class="line">    <span class="keyword">return</span> map(next, map(operator.itemgetter(<span class="number">1</span>), groupby(iterable, key)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter_except</span><span class="params">(func, exception, first=None)</span>:</span></span><br><span class="line">    <span class="string">""" Call a function repeatedly until an exception is raised.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Converts a call-until-exception interface to an iterator interface.</span></span><br><span class="line"><span class="string">    Like builtins.iter(func, sentinel) but uses an exception instead</span></span><br><span class="line"><span class="string">    of a sentinel to end the loop.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Examples:</span></span><br><span class="line"><span class="string">        iter_except(functools.partial(heappop, h), IndexError)   # priority queue iterator</span></span><br><span class="line"><span class="string">        iter_except(d.popitem, KeyError)                         # non-blocking dict iterator</span></span><br><span class="line"><span class="string">        iter_except(d.popleft, IndexError)                       # non-blocking deque iterator</span></span><br><span class="line"><span class="string">        iter_except(q.get_nowait, Queue.Empty)                   # loop over a producer Queue</span></span><br><span class="line"><span class="string">        iter_except(s.pop, KeyError)                             # non-blocking set iterator</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> first <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> first()            <span class="comment"># For database APIs needing an initial cast to db.first()</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">yield</span> func()</span><br><span class="line">    <span class="keyword">except</span> exception:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_true</span><span class="params">(iterable, default=False, pred=None)</span>:</span></span><br><span class="line">    <span class="string">"""Returns the first true value in the iterable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If no true value is found, returns *default*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If *pred* is not None, returns the first item</span></span><br><span class="line"><span class="string">    for which pred(item) is true.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># first_true([a,b,c], x) --&gt; a or b or c or x</span></span><br><span class="line">    <span class="comment"># first_true([a,b], x, f) --&gt; a if f(a) else b if f(b) else x</span></span><br><span class="line">    <span class="keyword">return</span> next(filter(pred, iterable), default)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_product</span><span class="params">(*args, repeat=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">"Random selection from itertools.product(*args, **kwds)"</span></span><br><span class="line">    pools = [tuple(pool) <span class="keyword">for</span> pool <span class="keyword">in</span> args] * repeat</span><br><span class="line">    <span class="keyword">return</span> tuple(random.choice(pool) <span class="keyword">for</span> pool <span class="keyword">in</span> pools)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_permutation</span><span class="params">(iterable, r=None)</span>:</span></span><br><span class="line">    <span class="string">"Random selection from itertools.permutations(iterable, r)"</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    r = len(pool) <span class="keyword">if</span> r <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> r</span><br><span class="line">    <span class="keyword">return</span> tuple(random.sample(pool, r))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_combination</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    <span class="string">"Random selection from itertools.combinations(iterable, r)"</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    indices = sorted(random.sample(range(n), r))</span><br><span class="line">    <span class="keyword">return</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_combination_with_replacement</span><span class="params">(iterable, r)</span>:</span></span><br><span class="line">    <span class="string">"Random selection from itertools.combinations_with_replacement(iterable, r)"</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    indices = sorted(random.randrange(n) <span class="keyword">for</span> i <span class="keyword">in</span> range(r))</span><br><span class="line">    <span class="keyword">return</span> tuple(pool[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nth_combination</span><span class="params">(iterable, r, index)</span>:</span></span><br><span class="line">    <span class="string">'Equivalent to list(combinations(iterable, r))[index]'</span></span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    <span class="keyword">if</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> r &gt; n:</span><br><span class="line">        <span class="keyword">raise</span> ValueError</span><br><span class="line">    c = <span class="number">1</span></span><br><span class="line">    k = min(r, n-r)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">        c = c * (n - k + i) // i</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">        index += c</span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= c:</span><br><span class="line">        <span class="keyword">raise</span> IndexError</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> r:</span><br><span class="line">        c, n, r = c*r//n, n<span class="number">-1</span>, r<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> index &gt;= c:</span><br><span class="line">            index -= c</span><br><span class="line">            c, n = c*(n-r)//n, n<span class="number">-1</span></span><br><span class="line">        result.append(pool[<span class="number">-1</span>-n])</span><br><span class="line">    <span class="keyword">return</span> tuple(result)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-itertools&quot;&gt;&lt;a href=&quot;#python-标准库-itertools&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 itertools&quot;&gt;&lt;/a&gt;python 标准库 itertools&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200203_Alita-Battle-Angel-2019.png?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="itertools" scheme="https://pinghailinfeng.gitee.io/tags/itertools/"/>
    
  </entry>
  
  <entry>
    <title>python standard library copy</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/02/python-standard-library-copy/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/02/python-standard-library-copy/</id>
    <published>2020-02-02T01:04:07.000Z</published>
    <updated>2020-02-04T10:54:47.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-copy"><a href="#python-标准库-copy" class="headerlink" title="python 标准库 copy"></a>python 标准库 copy</h1><p><img src="https://quotescover.com/wp-content/uploads/We-are-suffering-from-too__quotes-by-Marianne-Moore-22-1024x1024.png" alt></p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=562888&auto=0&height=66"></iframe><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/copy.py" target="_blank" rel="noopener">Lib/copy.py</a> </p><p>类层次结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Interface summary:</span><br><span class="line">        <span class="keyword">import</span> copy</span><br><span class="line">        x = copy.copy(y)        <span class="comment"># make a shallow copy of y</span></span><br><span class="line">        x = copy.deepcopy(y)    <span class="comment"># make a deep copy of y</span></span><br></pre></td></tr></table></figure><p>Python 中赋值语句不复制对象，而是在目标和对象之间创建绑定 (bindings) 关系。对于自身可变或者包含可变项的集合对象，开发者有时会需要生成其副本用于改变操作，进而避免改变原对象。本模块提供了通用的浅层复制和深层复制操作（如下所述）。</p><p>接口摘要：</p><ul><li><p><code>copy.copy</code>(<em>x</em>)</p><p>返回 <em>x</em> 的浅层复制。</p></li><li><p><code>copy.deepcopy</code>(<em>x</em>[, <em>memo</em>])</p><p>返回 <em>x</em> 的深层复制。</p></li><li><p><em>exception</em> <code>copy.error</code></p><p>针对模块特定错误引发。</p></li></ul><p>浅层复制和深层复制之间的区别仅与复合对象 (即包含其他对象的对象，如列表或类的实例) 相关:</p><ul><li>一个 <em>浅层复制</em> 会构造一个新的复合对象，然后（在可能的范围内）将原对象中找到的 <em>引用</em> 插入其中。</li><li>一个 <em>深层复制</em> 会构造一个新的复合对象，然后递归地将原始对象中所找到的对象的 <em>副本</em> 插入。</li></ul><p>深度复制操作通常存在两个问题, 而浅层复制操作并不存在这些问题：</p><ul><li>递归对象 (直接或间接包含对自身引用的复合对象) 可能会导致递归循环。</li><li>由于深层复制会复制所有内容，因此可能会过多复制（例如本应该在副本之间共享的数据）。</li></ul><p>The <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#copy.deepcopy" target="_blank" rel="noopener"><code>deepcopy()</code></a> function avoids these problems by:</p><ul><li>保留在当前复制过程中已复制的对象的 “备忘录” （<code>memo</code>） 字典；以及</li><li>允许用户定义的类重载复制操作或复制的组件集合。</li></ul><p>该模块不复制模块、方法、栈追踪（stack trace）、栈帧（stack frame）、文件、套接字、窗口、数组以及任何类似的类型。它通过不改变地返回原始对象来（浅层或深层地）“复制”函数和类；这与 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块处理这类问题的方式是相似的。</p><p>制作字典的浅层复制可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.copy" target="_blank" rel="noopener"><code>dict.copy()</code></a> 方法，而制作列表的浅层复制可以通过赋值整个列表的切片完成，例如，<code>copied_list = original_list[:]</code>。</p><p>类可以使用与控制序列化（pickling）操作相同的接口来控制复制操作，关于这些方法的描述信息请参考 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块。实际上，<a href="https://docs.python.org/zh-cn/3.8/library/copy.html#module-copy" target="_blank" rel="noopener"><code>copy</code></a> 模块使用的正是从 <a href="https://docs.python.org/zh-cn/3.8/library/copyreg.html#module-copyreg" target="_blank" rel="noopener"><code>copyreg</code></a> 模块中注册的 pickle 函数。</p><p>想要给一个类定义它自己的拷贝操作实现，可以通过定义特殊方法 <code>__copy__()</code> 和 <code>__deepcopy__()</code>。 调用前者以实现浅层拷贝操作，该方法不用传入额外参数。 调用后者以实现深层拷贝操作；它应传入一个参数即 <code>memo</code> 字典。 如果 <code>__deepcopy__()</code> 实现需要创建一个组件的深层拷贝，它应当调用 <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#copy.deepcopy" target="_blank" rel="noopener"><code>deepcopy()</code></a> 函数并以该组件作为第一个参数，而将 memo 字典作为第二个参数。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="字典拷贝"><a href="#字典拷贝" class="headerlink" title="字典拷贝"></a>字典拷贝</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">displayList</span><span class="params">(text, dictOfElements)</span> :</span></span><br><span class="line">    print(<span class="string">"--------"</span>)</span><br><span class="line">    print(text)</span><br><span class="line">    <span class="keyword">for</span> key , value <span class="keyword">in</span> dictOfElements.items():</span><br><span class="line">        print(key, <span class="string">" :: "</span>, value)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Dictionary of strings and ints</span></span><br><span class="line">    wordsDict = &#123;</span><br><span class="line">        <span class="string">"Hello"</span>: <span class="number">56</span>,</span><br><span class="line">        <span class="string">"at"</span> : <span class="number">23</span> ,</span><br><span class="line">        <span class="string">"test"</span> : <span class="number">43</span>,</span><br><span class="line">        <span class="string">"this"</span> : <span class="number">43</span>,</span><br><span class="line">        <span class="string">"who"</span> : [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Shallow Copying dictionaries using dict.copy()</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    print(<span class="string">"***** Shallow Copy *********"</span>)</span><br><span class="line">    </span><br><span class="line">    displayList(<span class="string">"Original Dictionary : "</span> , wordsDict)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># create a Shallow copy  the original dictionary</span></span><br><span class="line">    newDict = wordsDict.copy()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Modify the value of key in new dictionary</span></span><br><span class="line">    newDict[<span class="string">"at"</span>] = <span class="number">200</span></span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"Contents of copied dictionary changed"</span>)</span><br><span class="line"> </span><br><span class="line">    displayList(<span class="string">"Modified copied dictionary : "</span> , newDict)</span><br><span class="line">    </span><br><span class="line">    displayList(<span class="string">"Original Dictionary : "</span> , wordsDict)</span><br><span class="line"> </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Modify the contents of list object in shallow copied dictionary will </span></span><br><span class="line"><span class="string">    modify the contents of original dictionary too because its a shallow copy. </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    newDict[<span class="string">"who"</span>].append(<span class="number">222</span>)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"Contents of list in copied dictionary changed"</span>)</span><br><span class="line"> </span><br><span class="line">    displayList(<span class="string">"Modified copied dictionary : "</span> , newDict)</span><br><span class="line">    </span><br><span class="line">    displayList(<span class="string">"Original Dictionary : "</span> , wordsDict)</span><br><span class="line"> </span><br><span class="line">    print(<span class="string">"***** Deep Copy *******"</span>)</span><br><span class="line">    </span><br><span class="line">    displayList(<span class="string">"Original Dictionary : "</span> , wordsDict)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Create a deep copy of the dictionary</span></span><br><span class="line">    otherDict = copy.deepcopy(wordsDict)</span><br><span class="line">    </span><br><span class="line">    displayList(<span class="string">"Deep copy of  Dictionary : "</span> , otherDict)</span><br><span class="line">    </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Modify the contents of list object in deep copied dictionary will </span></span><br><span class="line"><span class="string">    have no impact on original dictionary because its a deep copy.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    newDict[<span class="string">"who"</span>].append(<span class="number">100</span>)</span><br><span class="line"> </span><br><span class="line">    displayList(<span class="string">"Modified Deep copy of Dictionary : "</span> , otherDict)</span><br><span class="line">    displayList(<span class="string">"Original Dictionary : "</span> , wordsDict)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">--------</span><br><span class="line">Original Dictionary : </span><br><span class="line">at  ::  <span class="number">23</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>]</span><br><span class="line">Contents of copied dictionary changed</span><br><span class="line">--------</span><br><span class="line">Modified copied dictionary : </span><br><span class="line">at  ::  <span class="number">200</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>]</span><br><span class="line">--------</span><br><span class="line">Original Dictionary : </span><br><span class="line">at  ::  <span class="number">23</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>]</span><br><span class="line">Contents of list <span class="keyword">in</span> copied dictionary changed</span><br><span class="line">--------</span><br><span class="line">Modified copied dictionary : </span><br><span class="line">at  ::  <span class="number">200</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">222</span>]</span><br><span class="line">--------</span><br><span class="line">Original Dictionary : </span><br><span class="line">at  ::  <span class="number">23</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">222</span>]</span><br><span class="line">***** Deep Copy *******</span><br><span class="line">--------</span><br><span class="line">Original Dictionary : </span><br><span class="line">at  ::  <span class="number">23</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">222</span>]</span><br><span class="line">--------</span><br><span class="line">Deep copy of  Dictionary : </span><br><span class="line">at  ::  <span class="number">23</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">222</span>]</span><br><span class="line">--------</span><br><span class="line">Modified Deep copy of Dictionary : </span><br><span class="line">at  ::  <span class="number">23</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">222</span>]</span><br><span class="line">--------</span><br><span class="line">Original Dictionary : </span><br><span class="line">at  ::  <span class="number">23</span></span><br><span class="line">this  ::  <span class="number">43</span></span><br><span class="line">Hello  ::  <span class="number">56</span></span><br><span class="line">test  ::  <span class="number">43</span></span><br><span class="line">who  ::  [<span class="number">56</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">222</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><h3 id="列表拷贝"><a href="#列表拷贝" class="headerlink" title="列表拷贝"></a>列表拷贝</h3><p>浅拷贝</p><p>使用 <code>=</code>赋值运算符 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">old_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="string">'a'</span>]]</span><br><span class="line">new_list = old_list</span><br><span class="line"></span><br><span class="line">new_list[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Old List:'</span>, old_list)</span><br><span class="line">print(<span class="string">'ID of Old List:'</span>, id(old_list))</span><br><span class="line"></span><br><span class="line">print(<span class="string">'New List:'</span>, new_list)</span><br><span class="line">print(<span class="string">'ID of New List:'</span>, id(new_list))</span><br></pre></td></tr></table></figure><p>使用<code>copy</code>浅拷贝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">old_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">new_list = copy.copy(old_list)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Old list:"</span>, old_list)</span><br><span class="line">print(<span class="string">"New list:"</span>, new_list)</span><br></pre></td></tr></table></figure><p>使用<code>deepcopy</code> 深拷贝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">old_list = [[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]]</span><br><span class="line">new_list = copy.deepcopy(old_list)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Old list:"</span>, old_list)</span><br><span class="line">print(<span class="string">"New list:"</span>, new_list)</span><br></pre></td></tr></table></figure><h3 id="类拷贝"><a href="#类拷贝" class="headerlink" title="类拷贝"></a>类拷贝</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'Point(<span class="subst">&#123;self.x!r&#125;</span>, <span class="subst">&#123;self.y!r&#125;</span>)'</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Point(<span class="number">23</span>, <span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = copy.copy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">Point(<span class="number">23</span>, <span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">Point(<span class="number">23</span>, <span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用copy模块的copy方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, topleft, bottomright)</span>:</span></span><br><span class="line">        self.topleft = topleft</span><br><span class="line">        self.bottomright = bottomright</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">f'Rectangle(<span class="subst">&#123;self.topleft!r&#125;</span>, '</span></span><br><span class="line">                <span class="string">f'<span class="subst">&#123;self.bottomright!r&#125;</span>)'</span>)</span><br><span class="line">rect = Rectangle(Point(<span class="number">0</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">srect = copy.copy(rect)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect</span><br><span class="line">Rectangle(Point(<span class="number">0</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>srect</span><br><span class="line">Rectangle(Point(<span class="number">0</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect <span class="keyword">is</span> srect</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect.topleft.x = <span class="number">999</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect</span><br><span class="line">Rectangle(Point(<span class="number">999</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>srect</span><br><span class="line">Rectangle(Point(<span class="number">999</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>drect = copy.deepcopy(srect)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>drect.topleft.x = <span class="number">222</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>drect</span><br><span class="line">Rectangle(Point(<span class="number">222</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect</span><br><span class="line">Rectangle(Point(<span class="number">999</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>srect</span><br><span class="line">Rectangle(Point(<span class="number">999</span>, <span class="number">1</span>), Point(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment">## 使用copy方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, topleft, bottomright)</span>:</span></span><br><span class="line">        self.topleft = topleft</span><br><span class="line">        self.bottomright = bottomright</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">f'Rectangle(<span class="subst">&#123;self.topleft!r&#125;</span>, '</span></span><br><span class="line">                <span class="string">f'<span class="subst">&#123;self.bottomright!r&#125;</span>)'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Rectangle(self.topleft, self.bottomright)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r1  = Rectangle(<span class="number">20</span>,<span class="number">30</span>)</span><br><span class="line">r2  =r1.copy()</span><br><span class="line">print(<span class="string">"r1:"</span>,r1)</span><br><span class="line">print(<span class="string">"r2:"</span>,r2)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r1: Rectangle(<span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r2: Rectangle(<span class="number">20</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure><h3 id="一个深入的例子"><a href="#一个深入的例子" class="headerlink" title="一个深入的例子"></a>一个深入的例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></span><br><span class="line">    x = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">CopyOfB = type(<span class="string">'CopyOfB'</span>, B.__bases__, dict(B.__dict__))</span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line">cob = CopyOfB()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> b.x   <span class="comment"># Prints '3'</span></span><br><span class="line"><span class="keyword">print</span> cob.x <span class="comment"># Prints '3'</span></span><br><span class="line"></span><br><span class="line">b.x = <span class="number">2</span></span><br><span class="line">cob.x = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> b.x   <span class="comment"># Prints '2'</span></span><br><span class="line"><span class="keyword">print</span> cob.x <span class="comment"># Prints '4'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line">    x = []</span><br><span class="line"></span><br><span class="line">CopyOfC = type(<span class="string">'CopyOfC'</span>, C.__bases__, dict(C.__dict__))</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">coc = CopyOfC()</span><br><span class="line"></span><br><span class="line">c.x.append(<span class="number">1</span>)</span><br><span class="line">coc.x.append(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> c.x   <span class="comment"># Prints '[1, 2]' (!)</span></span><br><span class="line"><span class="keyword">print</span> coc.x <span class="comment"># Prints '[1, 2]' (!)</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://stackoverflow.com/questions/17873384/how-to-deep-copy-a-list" target="_blank" rel="noopener">how to deep copy a list</a></p><p><a href="https://www.programiz.com/python-programming/shallow-deep-copy" target="_blank" rel="noopener">shallow-deep-copy</a></p><p><a href="https://stackoverflow.com/questions/9541025/how-to-copy-a-python-class" target="_blank" rel="noopener">how-to-copy-a-python-class</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最近学到一个新词:<code>共克时艰</code> 翻译成 英文 <code>We are suffering</code>,希望和朋友们共勉。</p><blockquote><p>我们都是蝴蝶翅膀上的那粒灰尘，被裹挟在龙卷风里，谁都晕头转向</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-copy&quot;&gt;&lt;a href=&quot;#python-标准库-copy&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 copy&quot;&gt;&lt;/a&gt;python 标准库 copy&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://quotescover.com/wp-content/uploads/We-are-suffering-from-too__quotes-by-Marianne-Moore-22-1024x1024.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="copy" scheme="https://pinghailinfeng.gitee.io/tags/copy/"/>
    
  </entry>
  
  <entry>
    <title>python standard library functools</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/01/python-standard-library-functools/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/01/python-standard-library-functools/</id>
    <published>2020-01-31T22:57:22.000Z</published>
    <updated>2020-02-03T10:23:40.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-functools-高阶函数工具"><a href="#python-标准库-functools-高阶函数工具" class="headerlink" title="python 标准库 functools 高阶函数工具"></a>python 标准库 functools 高阶函数工具</h1><p><img src="http://s3-eu-west-1.amazonaws.com/sup46/wp-content/uploads/2016/06/15100010/Attach-sup46.png" alt></p><a id="more"></a><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=539420&auto=0&height=66"></iframe><br>每日一词:</p><p>这里我们换种记忆方法 ,词根 <code>tach</code>代表 固定</p><blockquote><p>attach </p><p>英 [əˈtætʃ]  美 [əˈtætʃ]  </p><p>vt.&amp; vi. 贴上，系； 附上；</p><p>vt.（有时不受欢迎或未受邀请而）参加； 把…固定； 把…归因于； （使）与…有联系</p><p>vi. 从属； 附着； 伴随而来； 联在一起(to, upon)</p><p>attachment  n 邮件的附件</p><p>de 是反义前缀</p><p>detach v 分离</p><p>detached  adj  冷漠的,离群的</p><p>detachment  n 公平 </p></blockquote><p><a href="https://docs.python.org/zh-cn/3.8/library/functools.html#module-functools" target="_blank" rel="noopener"><code>functools</code></a> 模块应用于高阶函数，即参数或（和）返回值为其他函数的函数。 通常来说，此模块的功能适用于所有可调用对象。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/functools.html#module-functools" target="_blank" rel="noopener"><code>functools</code></a> 模块定义了以下函数:</p><ul><li><p><a href="mailto:`@functools.cache" target="_blank" rel="noopener">`@functools.cache</a>d_property`(<em>func</em>)</p><p>将一个类方法转换为特征属性，一次性计算该特征属性的值，然后将其缓存为实例生命周期内的普通属性。 类似于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#property" target="_blank" rel="noopener"><code>property()</code></a> 但增加了缓存功能。 对于在其他情况下实际不可变的高计算资源消耗的实例特征属性来说该函数非常有用。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSet</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sequence_of_numbers)</span>:</span></span><br><span class="line">        self._data = sequence_of_numbers</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cached_property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stdev</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> statistics.stdev(self._data)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cached_property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">variance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> statistics.variance(self._data)</span><br></pre></td></tr></table></figure><p><em>3.8 新版功能.</em></p><blockquote><p>此装饰器要求每个实例上的 <code>__dict__</code> 属性是可变的映射。 这意味着它将不适用于某些类型，例如元类（因为类型实例上的 <code>__dict__</code> 属性是类命名空间的只读代理），以及那些指定了 <code>__slots__</code> 但未包含 <code>__dict__</code> 作为所定义的空位之一的类（因为这样的类根本没有提供 <code>__dict__</code> 属性）。</p></blockquote></li><li><p><code>functools.cmp_to_key</code>(<em>func</em>)</p><p>将(旧式的)比较函数转换为新式的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-key-function" target="_blank" rel="noopener">key function</a> . 在类似于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#min" target="_blank" rel="noopener"><code>min()</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#max" target="_blank" rel="noopener"><code>max()</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.nlargest" target="_blank" rel="noopener"><code>heapq.nlargest()</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#heapq.nsmallest" target="_blank" rel="noopener"><code>heapq.nsmallest()</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.groupby" target="_blank" rel="noopener"><code>itertools.groupby()</code></a> 等函数的 key 参数中使用。此函数主要用作将 Python 2 程序转换至新版的转换工具，以保持对比较函数的兼容。比较函数意为一个可调用对象，该对象接受两个参数并比较它们，结果为小于则返回一个负数，相等则返回零，大于则返回一个正数。key function则是一个接受一个参数，并返回另一个用以排序的值的可调用对象。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(iterable, key=cmp_to_key(locale.strcoll))  <span class="comment"># locale-aware sort order</span></span><br></pre></td></tr></table></figure><p>有关排序示例和简要排序教程，请参阅 <a href="https://docs.python.org/zh-cn/3.8/howto/sorting.html#sortinghowto" target="_blank" rel="noopener">排序指南</a> 。<em>3.2 新版功能.</em></p></li><li><p><a href="mailto:`@functools.lr" target="_blank" rel="noopener">`@functools.lr</a>u_cache`(<em>user_function</em>)</p></li><li><p><a href="mailto:`@functools.lr" target="_blank" rel="noopener">`@functools.lr</a>u_cache`(<em>maxsize=128</em>, <em>typed=False</em>)</p><p>一个为函数提供缓存功能的装饰器，缓存 <em>maxsize</em> 组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或I/O函数的调用时间。</p><p>由于使用了字典存储缓存，所以该函数的固定参数和关键字参数必须是可哈希的。</p><p>不同模式的参数可能被视为不同从而产生多个缓存项，例如, f(a=1, b=2) 和 f(b=2, a=1) 因其参数顺序不同，可能会被缓存两次。</p><p>如果指定了 <em>user_function</em>，它必须是一个可调用对象。 这允许 <em>lru_cache</em> 装饰器被直接应用于一个用户自定义函数，让 <em>maxsize</em> 保持其默认值 128:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@lru_cache</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_vowels</span><span class="params">(sentence)</span>:</span></span><br><span class="line">    sentence = sentence.casefold()</span><br><span class="line">    <span class="keyword">return</span> sum(sentence.count(vowel) <span class="keyword">for</span> vowel <span class="keyword">in</span> <span class="string">'aeiou'</span>)</span><br></pre></td></tr></table></figure><p>如果 <em>maxsize</em> 设置为 <code>None</code> ，LRU功能将被禁用且缓存数量无上限。 <em>maxsize</em> 设置为2的幂时可获得最佳性能。</p><p>如果 <em>typed</em> 设置为true，不同类型的函数参数将被分别缓存。例如， <code>f(3)</code> 和 <code>f(3.0)</code> 将被视为不同而分别缓存。</p><p>为了衡量缓存的有效性以便调整 <em>maxsize</em> 形参，被装饰的函数带有一个 <code>cache_info()</code> 函数。当调用 <code>cache_info()</code> 函数时，返回一个具名元组，包含命中次数 <em>hits</em>，未命中次数 <em>misses</em> ，最大缓存数量 <em>maxsize</em> 和 当前缓存大小 <em>currsize</em>。在多线程环境中，命中数与未命中数是不完全准确的。</p><p>该装饰器也提供了一个用于清理/使缓存失效的函数 <code>cache_clear()</code> 。</p><p>原始的未经装饰的函数可以通过 <code>__wrapped__</code> 属性访问。它可以用于检查、绕过缓存，或使用不同的缓存再次装饰原始函数。</p><p><a href="https://en.wikipedia.org/wiki/Cache_algorithms#Examples" target="_blank" rel="noopener">“最久未使用算法”（LRU）缓存</a> 在“最近的调用是即将到来的调用的最佳预测因子”时性能最好（比如，新闻服务器上最受欢迎的文章倾向于每天更改）。 “缓存大小限制”参数保证缓存不会在长时间运行的进程比如说网站服务器上无限制的增加自身的大小。</p><p>一般来说，LRU缓存只在当你想要重用之前计算的结果时使用。因此，用它缓存具有副作用的函数、需要在每次调用时创建不同、易变的对象的函数或者诸如time（）或random（）之类的不纯函数是没有意义的。</p><p>静态 Web 内容的 LRU 缓存示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@lru_cache(maxsize=32)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pep</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="string">'Retrieve text of a Python Enhancement Proposal'</span></span><br><span class="line">    resource = <span class="string">'http://www.python.org/dev/peps/pep-%04d/'</span> % num</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> urllib.request.urlopen(resource) <span class="keyword">as</span> s:</span><br><span class="line">            <span class="keyword">return</span> s.read()</span><br><span class="line">    <span class="keyword">except</span> urllib.error.HTTPError:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Not Found'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">8</span>, <span class="number">290</span>, <span class="number">308</span>, <span class="number">320</span>, <span class="number">8</span>, <span class="number">218</span>, <span class="number">320</span>, <span class="number">279</span>, <span class="number">289</span>, <span class="number">320</span>, <span class="number">9991</span>:</span><br><span class="line"><span class="meta">... </span>    pep = get_pep(n)</span><br><span class="line"><span class="meta">... </span>    print(n, len(pep))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_pep.cache_info()</span><br><span class="line">CacheInfo(hits=<span class="number">3</span>, misses=<span class="number">8</span>, maxsize=<span class="number">32</span>, currsize=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>以下是使用缓存通过 <a href="https://zh.wikipedia.org/wiki/动态规划" target="_blank" rel="noopener">动态规划</a> 计算 <a href="https://zh.wikipedia.org/wiki/斐波那契数列" target="_blank" rel="noopener">斐波那契数列</a> 的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@lru_cache(maxsize=None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[fib(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">16</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">144</span>, <span class="number">233</span>, <span class="number">377</span>, <span class="number">610</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib.cache_info()</span><br><span class="line">CacheInfo(hits=<span class="number">28</span>, misses=<span class="number">16</span>, maxsize=<span class="literal">None</span>, currsize=<span class="number">16</span>)</span><br></pre></td></tr></table></figure><p><em>在 3.3 版更改:</em> 添加 <em>typed</em> 选项。</p><p><em>在 3.8 版更改:</em> 添加了 <em>user_function</em> 选项。</p></li><li><p><a href="mailto:`@functools.tota" target="_blank" rel="noopener">`@functools.tota</a>l_ordering`</p><p>给定一个声明一个或多个全比较排序方法的类，这个类装饰器实现剩余的方法。这减轻了指定所有可能的全比较操作的工作。</p><p>此类必须包含以下方法之一：<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__lt__" target="_blank" rel="noopener"><code>__lt__()</code></a> 、<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__le__" target="_blank" rel="noopener"><code>__le__()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__gt__" target="_blank" rel="noopener"><code>__gt__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__ge__" target="_blank" rel="noopener"><code>__ge__()</code></a>。另外，此类必须支持 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__eq__" target="_blank" rel="noopener"><code>__eq__()</code></a> 方法。</p><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@total_ordering</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_is_valid_operand</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (hasattr(other, <span class="string">"lastname"</span>) <span class="keyword">and</span></span><br><span class="line">                hasattr(other, <span class="string">"firstname"</span>))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._is_valid_operand(other):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">        <span class="keyword">return</span> ((self.lastname.lower(), self.firstname.lower()) ==</span><br><span class="line">                (other.lastname.lower(), other.firstname.lower()))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._is_valid_operand(other):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">        <span class="keyword">return</span> ((self.lastname.lower(), self.firstname.lower()) &lt;</span><br><span class="line">                (other.lastname.lower(), other.firstname.lower()))</span><br></pre></td></tr></table></figure><blockquote><p>虽然此装饰器使得创建具有良好行为的完全有序类型变得非常容易，但它 <em>确实</em> 是以执行速度更缓慢和派生比较方法的堆栈回溯更复杂为代价的。 如果性能基准测试表明这是特定应用的瓶颈所在，则改为实现全部六个富比较方法应该会轻松提升速度。 </p></blockquote><p> <em>在 3.4 版更改:</em> 现在已支持从未识别类型的下层比较函数返回 NotImplemented 异常。 </p></li><li><p><code>functools.partial</code>(<em>func</em>, <em>/</em>, <strong>args<em>, </em></strong>keywords*)</p><p> 返回一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#partial-objects" target="_blank" rel="noopener">部分对象</a>，当被调用时其行为类似于 <em>func</em> 附带位置参数 <em>args</em> 和关键字参数 <em>keywords</em> 被调用。 如果为调用提供了更多的参数，它们会被附加到 <em>args</em>。 如果提供了额外的关键字参数，它们会扩展并重载 <em>keywords</em>。 大致等价于: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial</span><span class="params">(func, /, *args, **keywords)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newfunc</span><span class="params">(*fargs, **fkeywords)</span>:</span></span><br><span class="line">        newkeywords = &#123;**keywords, **fkeywords&#125;</span><br><span class="line">        <span class="keyword">return</span> func(*args, *fargs, **newkeywords)</span><br><span class="line">    newfunc.func = func</span><br><span class="line">    newfunc.args = args</span><br><span class="line">    newfunc.keywords = keywords</span><br><span class="line">    <span class="keyword">return</span> newfunc</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial()</code></a> 会被“冻结了”一部分函数参数和/或关键字的部分函数应用所使用，从而得到一个具有简化签名的新对象。 例如，<a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial()</code></a> 可用来创建一个行为类似于 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int()</code></a> 函数的可调用对象，其中 <em>base</em> 参数默认为二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basetwo = partial(int, base=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basetwo.__doc__ = <span class="string">'Convert base 2 string to an int.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basetwo(<span class="string">'10010'</span>)</span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure></li><li><p><em>class</em> <code>functools.partialmethod</code>(<em>func</em>, <em>/</em>, <strong>args<em>, </em></strong>keywords*)</p><p>返回一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partialmethod" target="_blank" rel="noopener"><code>partialmethod</code></a> 描述器，其行为类似 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 但它被设计用作方法定义而非直接用作可调用对象。</p><p><em>func</em> 必须是一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-descriptor" target="_blank" rel="noopener">descriptor</a> 或可调用对象（同属两者的对象例如普通函数会被当作描述器来处理）。</p><p>当 <em>func</em> 是一个描述器（例如普通 Python 函数, <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#classmethod" target="_blank" rel="noopener"><code>classmethod()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#staticmethod" target="_blank" rel="noopener"><code>staticmethod()</code></a>, <code>abstractmethod()</code> 或其他 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partialmethod" target="_blank" rel="noopener"><code>partialmethod</code></a> 的实例）时, 对 <code>__get__</code> 的调用会被委托给底层的描述器，并会返回一个适当的 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#partial-objects" target="_blank" rel="noopener">部分对象</a> 作为结果。</p><p>当 <em>func</em> 是一个非描述器类可调用对象时，则会动态创建一个适当的绑定方法。 当用作方法时其行为类似普通 Python 函数：将会插入 <em>self</em> 参数作为第一个位置参数，其位置甚至会处于提供给 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partialmethod" target="_blank" rel="noopener"><code>partialmethod</code></a> 构造器的 <em>args</em> 和 <em>keywords</em> 之前。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Cell</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._alive = <span class="literal">False</span></span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">alive</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self._alive</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">set_state</span><span class="params">(self, state)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._alive = bool(state)</span><br><span class="line"><span class="meta">... </span>    set_alive = partialmethod(set_state, <span class="literal">True</span>)</span><br><span class="line"><span class="meta">... </span>    set_dead = partialmethod(set_state, <span class="literal">False</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Cell()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.alive</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.set_alive()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.alive</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li><li><p><code>functools.reduce</code>(<em>function</em>, <em>iterable</em>[, <em>initializer</em>])</p><p>将两个参数的 <em>function</em> 从左至右积累地应用到 <em>iterable</em> 的条目，以便将该可迭代对象缩减为单一的值。 例如，<code>reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])</code> 是计算 <code>((((1+2)+3)+4)+5)</code> 的值。 左边的参数 <em>x</em> 是积累值而右边的参数 <em>y</em> 则是来自 <em>iterable</em> 的更新值。 如果存在可选项 <em>initializer</em>，它会被放在参与计算的可迭代对象的条目之前，并在可迭代对象为空时作为默认值。 如果没有给出 <em>initializer</em> 并且 <em>iterable</em> 仅包含一个条目，则将返回第一项。</p><p>大致相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span><span class="params">(function, iterable, initializer=None)</span>:</span></span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    <span class="keyword">if</span> initializer <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        value = next(it)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = initializer</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> it:</span><br><span class="line">        value = function(value, element)</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><p>请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.accumulate" target="_blank" rel="noopener"><code>itertools.accumulate()</code></a> 了解有关可产生所有中间值的迭代器。</p></li><li><p><a href="mailto:`@functools.singledispatch" target="_blank" rel="noopener">`@functools.singledispatch</a>`</p><p>将一个函数转换为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-single-dispatch" target="_blank" rel="noopener">单分派</a> <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generic-function" target="_blank" rel="noopener">generic function</a>。</p><p>要定义一个泛型函数，应使用 <code>@singledispatch</code> 装饰器进行装饰。 请注意分派是作用于第一个参数的类型，要相应地创建你的函数:</p><p>>&gt;&gt;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@singledispatch</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(arg, verbose=False)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> verbose:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Let me just say,"</span>, end=<span class="string">" "</span>)</span><br><span class="line"><span class="meta">... </span>    print(arg)</span><br></pre></td></tr></table></figure><p>要将重载的实现添加到函数中，请使用泛型函数的 <code>register()</code> 属性。 它是一个装饰器。 对于带有类型标注的函数，该装饰器将自动推断第一个参数的类型:</p><p>>&gt;&gt;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@fun.register</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(arg: int, verbose=False)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> verbose:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Strength in numbers, eh?"</span>, end=<span class="string">" "</span>)</span><br><span class="line"><span class="meta">... </span>    print(arg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@fun.register</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(arg: list, verbose=False)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> verbose:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Enumerate this:"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i, elem <span class="keyword">in</span> enumerate(arg):</span><br><span class="line"><span class="meta">... </span>        print(i, elem)</span><br></pre></td></tr></table></figure><p>对于不使用类型标注的代码，可以将适当的类型参数显式地传给装饰器本身:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@fun.register(complex)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(arg, verbose=False)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> verbose:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Better than complicated."</span>, end=<span class="string">" "</span>)</span><br><span class="line"><span class="meta">... </span>    print(arg.real, arg.imag)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>要启用注册 lambda 和现有函数，可以使用函数形式的 <code>register()</code> 属性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">nothing</span><span class="params">(arg, verbose=False)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Nothing."</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun.register(type(<span class="literal">None</span>), nothing)</span><br></pre></td></tr></table></figure><p><code>register()</code> 属性将返回启用了装饰器堆栈、封存的未装饰函数，并会为每个变量单独创建单元测试:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@fun.register(float)</span><br><span class="line"><span class="meta">... </span>@fun.register(Decimal)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">fun_num</span><span class="params">(arg, verbose=False)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> verbose:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Half of your number:"</span>, end=<span class="string">" "</span>)</span><br><span class="line"><span class="meta">... </span>    print(arg / <span class="number">2</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun_num <span class="keyword">is</span> fun</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>在调用时，泛型函数会根据第一个参数的类型进行分派:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(<span class="string">"Hello, world."</span>)</span><br><span class="line">Hello, world.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(<span class="string">"test."</span>, verbose=<span class="literal">True</span>)</span><br><span class="line">Let me just say, test.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(<span class="number">42</span>, verbose=<span class="literal">True</span>)</span><br><span class="line">Strength in numbers, eh? 42</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun([<span class="string">'spam'</span>, <span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'spam'</span>], verbose=<span class="literal">True</span>)</span><br><span class="line">Enumerate this:</span><br><span class="line"><span class="number">0</span> spam</span><br><span class="line"><span class="number">1</span> spam</span><br><span class="line"><span class="number">2</span> eggs</span><br><span class="line"><span class="number">3</span> spam</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(<span class="literal">None</span>)</span><br><span class="line">Nothing.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun(<span class="number">1.23</span>)</span><br><span class="line"><span class="number">0.615</span></span><br></pre></td></tr></table></figure><p>在没有用于特定类型的已注册实现的情况下，则会使用其方法解析顺序来查找更通用的实现。 以 <code>@singledispatch</code> 装饰的原始函数将为最基本的 <code>object</code> 类型进行注册，这意味着它将在找不到更好的实现时被使用。</p><p>要检查泛型函数将为给定类型选择哪个实现，请使用 <code>dispatch()</code> 属性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun.dispatch(float)</span><br><span class="line">&lt;function fun_num at <span class="number">0x1035a2840</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun.dispatch(dict)    <span class="comment"># note: default implementation</span></span><br><span class="line">&lt;function fun at <span class="number">0x103fe0000</span>&gt;</span><br></pre></td></tr></table></figure><p>要访问所有忆注册实现，请使用只读的 <code>registry</code> 属性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun.registry.keys()</span><br><span class="line">dict_keys([&lt;class 'NoneType'&gt;, &lt;class 'int'&gt;, &lt;class 'object'&gt;,</span><br><span class="line">          &lt;class 'decimal.Decimal'&gt;, &lt;class 'list'&gt;,</span><br><span class="line">          &lt;<span class="class"><span class="keyword">class</span> '<span class="title">float</span>'&gt;])</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">fun</span>.<span class="title">registry</span>[<span class="title">float</span>]</span></span><br><span class="line"><span class="class">&lt;<span class="title">function</span> <span class="title">fun_num</span> <span class="title">at</span> 0<span class="title">x1035a2840</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">fun</span>.<span class="title">registry</span>[<span class="title">object</span>]</span></span><br><span class="line"><span class="class">&lt;<span class="title">function</span> <span class="title">fun</span> <span class="title">at</span> 0<span class="title">x103fe0000</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <em>在 3.7 版更改:</em> <code>register()</code> 属性支持使用类型标注。 </p></li><li><p><em>class</em> <code>functools.singledispatchmethod</code>(<em>func</em>)</p><p>将一个方法转换为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-single-dispatch" target="_blank" rel="noopener">单分派</a> <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generic-function" target="_blank" rel="noopener">generic function</a>。</p><p>要定义一个泛型方法，应使用 <code>@singledispatchmethod</code> 装饰器进行装饰。 请注意分派是作用于第一个非 self 或非 cls 参数的类型，要相应地创建你的函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Negator</span>:</span></span><br><span class="line"><span class="meta">    @singledispatchmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">neg</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"Cannot negate a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @neg.register</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(self, arg: int)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -arg</span><br><span class="line"></span><br><span class="line"><span class="meta">    @neg.register</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(self, arg: bool)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> arg</span><br></pre></td></tr></table></figure><p><code>@singledispatchmethod</code> 支持与其他装饰器如 <code>@classmethod</code> 相嵌套。 请注意如果要允许 <code>dispatcher.register</code>，则 <code>singledispatchmethod</code> 必须是 <em>最外层</em> 的装饰器。 下面的示例定义了 <code>Negator</code> 类，其中包含绑定到类的 <code>neg</code> 方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Negator</span>:</span></span><br><span class="line"><span class="meta">    @singledispatchmethod</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">neg</span><span class="params">(cls, arg)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"Cannot negate a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @neg.register</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(cls, arg: int)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> -arg</span><br><span class="line"></span><br><span class="line"><span class="meta">    @neg.register</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(cls, arg: bool)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> arg</span><br></pre></td></tr></table></figure><p>同样的模式也被用于其他类似的装饰器: <code>staticmethod</code>, <code>abstractmethod</code> 等等。</p><p> <em>3.8 新版功能.</em> </p></li><li><p><code>functools.update_wrapper</code>(<em>wrapper</em>, <em>wrapped</em>, <em>assigned=WRAPPER_ASSIGNMENTS</em>, <em>updated=WRAPPER_UPDATES</em>)</p><p>更新一个 <em>wrapper</em> 函数以使其类似于 <em>wrapped</em> 函数。 可选参数为指明原函数的哪些属性要直接被赋值给 wrapper 函数的匹配属性的元组，并且这些 wrapper 函数的属性将使用原函数的对应属性来更新。 这些参数的默认值是模块级常量 <code>WRAPPER_ASSIGNMENTS</code> (它将被赋值给 wrapper 函数的 <code>__module__</code>, <code>__name__</code>, <code>__qualname__</code>, <code>__annotations__</code> 和 <code>__doc__</code> 即文档字符串) 以及 <code>WRAPPER_UPDATES</code> (它将更新 wrapper 函数的 <code>__dict__</code> 即实例字典)。</p><p>为了允许出于内省和其他目的访问原始函数（例如绕过 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.lru_cache" target="_blank" rel="noopener"><code>lru_cache()</code></a> 之类的缓存装饰器），此函数会自动为 wrapper 添加一个指向被包装函数的 <code>__wrapped__</code> 属性。</p><p>此函数的主要目的是在 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-decorator" target="_blank" rel="noopener">decorator</a> 函数中用来包装被装饰的函数并返回包装器。 如果包装器函数未被更新，则被返回函数的元数据将反映包装器定义而不是原始函数定义，这通常没有什么用处。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.update_wrapper" target="_blank" rel="noopener"><code>update_wrapper()</code></a> 可以与函数之外的可调用对象一同使用。 在 <em>assigned</em> 或 <em>updated</em> 中命名的任何属性如果不存在于被包装对象则会被忽略（即该函数将不会尝试在包装器函数上设置它们）。 如果包装器函数自身缺少在 <em>updated</em> 中命名的任何属性则仍将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>。</p><p><em>3.2 新版功能:</em> 自动添加 <code>__wrapped__</code> 属性。</p><p><em>3.2 新版功能:</em> 默认拷贝 <code>__annotations__</code> 属性。</p><p><em>在 3.2 版更改:</em> 不存在的属性将不再触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>。</p><p><em>在 3.4 版更改:</em> <code>__wrapped__</code> 属性现在总是指向被包装的函数，即使该函数定义了 <code>__wrapped__</code> 属性。 (参见 <a href="https://bugs.python.org/issue17482" target="_blank" rel="noopener">bpo-17482</a>)</p><blockquote><p><strong>wrapped是被装饰的原函数</strong></p><p><strong>wrapper是被装饰器装饰后的新函数。</strong></p></blockquote><h3 id="补充例子："><a href="#补充例子：" class="headerlink" title="补充例子："></a>补充例子：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">f"before..."</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"after..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    求和运算</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(a + b)</span><br></pre></td></tr></table></figure><blockquote><p>1、原函数为add。</p><p>2、@outer会去执行outer装饰器，传入add函数，返回一个inner函数。</p><p>3、执行outer函数时，加载inner函数，此时会直接执行functools.wraps(func)返回一个可调用对象，即partial对象。</p><p>4、此时inner的装饰器实际上是@partial，partial会被调用，传入inner函数，执行partial内部的update_wrapper函数，将func的相应属性拷贝给inner函数，最后返回inner函数。这一步并没有生成新的函数，仅仅是改变了inner函数的属性。</p><p>5、把add指向inner函数。</p><p>6、调用add实际调用的是inner函数，inner函数内部持有原add函数的引用即func。</p><p><strong>update_wrapper函数参数对应：</strong></p><p><strong>wrapper指的是inner函数</strong></p><p><strong>wrapped指的是func即原始的add函数</strong></p></blockquote></li><li><p><a href="mailto:`@functools.wraps" target="_blank" rel="noopener">`@functools.wraps</a>`(<em>wrapped</em>, <em>assigned=WRAPPER_ASSIGNMENTS</em>, <em>updated=WRAPPER_UPDATES</em>)</p><p>这是一个便捷函数，用于在定义包装器函数时发起调用 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.update_wrapper" target="_blank" rel="noopener"><code>update_wrapper()</code></a> 作为函数装饰器。 它等价于 <code>partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated)</code>。 例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">... </span>    @wraps(f)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwds)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">'Calling decorated function'</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> f(*args, **kwds)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> wrapper</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@my_decorator</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""Docstring"""</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Called example function'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example()</span><br><span class="line">Calling decorated function</span><br><span class="line">Called example function</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.__name__</span><br><span class="line"><span class="string">'example'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.__doc__</span><br><span class="line"><span class="string">'Docstring'</span></span><br></pre></td></tr></table></figure><p>如果不使用这个装饰器工厂函数，则 example 函数的名称将变为 <code>&#39;wrapper&#39;</code>，并且 <code>example()</code> 原本的文档字符串将会丢失。 </p></li></ul><h2 id="partial-对象"><a href="#partial-对象" class="headerlink" title="partial 对象"></a><a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 对象是由 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial()</code></a> 创建的可调用对象。 它们具有三个只读属性：</p><ul><li><p><code>partial.func</code></p><p>一个可调用对象或函数。 对 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 对象的调用将被转发给 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial.func" target="_blank" rel="noopener"><code>func</code></a> 并附带新的参数和关键字。</p></li><li><p><code>partial.args</code></p><p>最左边的位置参数将放置在提供给 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 对象调用的位置参数之前。</p></li><li><p><code>partial.keywords</code></p><p>当调用 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 对象时将要提供的关键字参数。</p></li></ul><p><a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 对象与 <code>function</code> 对象的类似之处在于它们都是可调用、可弱引用的对象并可拥有属性。 但两者也存在一些重要的区别。 例如前者不会自动创建 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#definition.__name__" target="_blank" rel="noopener"><code>__name__</code></a> 和 <code>__doc__</code> 属性。 而且，在类中定义的 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.partial" target="_blank" rel="noopener"><code>partial</code></a> 对象的行为类似于静态方法，并且不会在实例属性查找期间转换为绑定方法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><code>functools.wraps</code>目的消除装饰器对原函数造成的影响,    通过对原函数相关属性拷贝,已达到装饰器不修改原函数的目的。</li><li><p><strong>wraps内部通过partial对象和update_wrapper函数实现</strong> </p></li><li><p><strong>partial是一个类，通过实现了双下方法new，自定义实例化对象过程，使得对象内部保留原函数和固定参数，通过实现双下方法call，使得对象可以像函数一样被调用，再通过内部保留的原函数和固定参数以及传入的其它参数进行原函数调用。</strong> </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-functools-高阶函数工具&quot;&gt;&lt;a href=&quot;#python-标准库-functools-高阶函数工具&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 functools 高阶函数工具&quot;&gt;&lt;/a&gt;python 标准库 functools 高阶函数工具&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://s3-eu-west-1.amazonaws.com/sup46/wp-content/uploads/2016/06/15100010/Attach-sup46.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="functools" scheme="https://pinghailinfeng.gitee.io/tags/functools/"/>
    
  </entry>
  
  <entry>
    <title>python standard library queue</title>
    <link href="https://pinghailinfeng.gitee.io/2020/01/31/python-standard-library-queue/"/>
    <id>https://pinghailinfeng.gitee.io/2020/01/31/python-standard-library-queue/</id>
    <published>2020-01-31T05:04:32.000Z</published>
    <updated>2020-02-03T10:23:40.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-queue"><a href="#python-标准库-queue" class="headerlink" title="python 标准库 queue"></a>python 标准库 queue</h1><p><img src="https://up.enterdesk.com/edpic/02/40/4a/02404af0eafff163c22ce10400cb5be9.jpg" alt></p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=4973554&auto=0&height=66"></iframe><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/queue.py" target="_blank" rel="noopener">Lib/queue.py</a> </p><p><a href="https://docs.python.org/zh-cn/3.8/library/queue.html#module-queue" target="_blank" rel="noopener"><code>queue</code></a> 模块实现了多生产者、多消费者队列。这特别适用于消息必须安全地在多线程间交换的线程编程。模块中的 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue" target="_blank" rel="noopener"><code>Queue</code></a> 类实现了所有所需的锁定语义。</p><p>模块实现了三种类型的队列，它们的区别仅仅是条目取回的顺序。在 FIFO 队列中，先添加的任务先取回。在 LIFO 队列中，最近被添加的条目先取回(操作类似一个堆栈)。优先级队列中，条目将保持排序( 使用 <a href="https://docs.python.org/zh-cn/3.8/library/heapq.html#module-heapq" target="_blank" rel="noopener"><code>heapq</code></a> 模块 ) 并且最小值的条目第一个返回。</p><p>在内部，这三个类型的队列使用锁来临时阻塞竞争线程；然而，它们并未被设计用于线程的重入性处理。</p><p>此外，模块实现了一个 “简单的” FIFO 队列类型， <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.SimpleQueue" target="_blank" rel="noopener"><code>SimpleQueue</code></a> ，这个特殊实现为小功能在交换中提供额外的保障。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/queue.html#module-queue" target="_blank" rel="noopener"><code>queue</code></a> 模块定义了下列类和异常：</p><ul><li><p><em>class</em> <code>queue.Queue</code>(<em>maxsize=0</em>)</p><p>Constructor for a FIFO queue. <em>maxsize</em> is an integer that sets the upperbound limit on the number of items that can be placed in the queue. Insertion will block once this size has been reached, until queue items are consumed. If <em>maxsize</em> is less than or equal to zero, the queue size is infinite.</p></li><li><p><em>class</em> <code>queue.LifoQueue</code>(<em>maxsize=0</em>)</p><p>LIFO 队列构造函数。 <em>maxsize</em> 是个整数，用于设置可以放入队列中的项目数的上限。当达到这个大小的时候，插入操作将阻塞至队列中的项目被消费掉。如果 <em>maxsize</em> 小于等于零，队列尺寸为无限大。</p></li><li><p><em>class</em> <code>queue.PriorityQueue</code>(<em>maxsize=0</em>)</p><p>优先级队列构造函数。 <em>maxsize</em> 是个整数，用于设置可以放入队列中的项目数的上限。当达到这个大小的时候，插入操作将阻塞至队列中的项目被消费掉。如果 <em>maxsize</em> 小于等于零，队列尺寸为无限大。最小值先被取出( 最小值条目是由 <code>sorted(list(entries))[0]</code> 返回的条目)。条目的典型模式是一个以下形式的元组： <code>(priority_number, data)</code> 。如果 <em>data</em> 元素没有可比性，数据将被包装在一个类中，忽略数据值，仅仅比较优先级数字 ：<code>from dataclasses import dataclass, field from typing import Any @dataclass(order=True) class PrioritizedItem:    priority: int    item: Any=field(compare=False)</code></p></li><li><p><em>class</em> <code>queue.SimpleQueue</code></p><p>无界的 FIFO 队列构造函数。简单的队列，缺少任务跟踪等高级功能。<em>3.7 新版功能.</em></p></li><li><p><em>exception</em> <code>queue.Empty</code></p><p>对空的 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue" target="_blank" rel="noopener"><code>Queue</code></a> 对象，调用非阻塞的 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.get" target="_blank" rel="noopener"><code>get()</code></a> (or <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.get_nowait" target="_blank" rel="noopener"><code>get_nowait()</code></a>) 时，引发的异常。</p></li><li><p><em>exception</em> <code>queue.Full</code></p><p>对满的 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue" target="_blank" rel="noopener"><code>Queue</code></a> 对象，调用非阻塞的 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.put" target="_blank" rel="noopener"><code>put()</code></a> (or <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.put_nowait" target="_blank" rel="noopener"><code>put_nowait()</code></a>) 时，引发的异常。</p></li></ul><h2 id="Queue对象"><a href="#Queue对象" class="headerlink" title="Queue对象"></a>Queue对象</h2><p>队列对象 (<a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue" target="_blank" rel="noopener"><code>Queue</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.LifoQueue" target="_blank" rel="noopener"><code>LifoQueue</code></a>, 或者 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.PriorityQueue" target="_blank" rel="noopener"><code>PriorityQueue</code></a>) 提供下列描述的公共方法。</p><ul><li><p><code>Queue.qsize</code>()</p><p>返回队列的大致大小。注意，qsize() &gt; 0 不保证后续的 get() 不被阻塞，qsize() &lt; maxsize 也不保证 put() 不被阻塞。</p></li><li><p><code>Queue.empty</code>()</p><p>如果队列为空，返回 <code>True</code> ，否则返回 <code>False</code> 。如果 empty() 返回 <code>True</code> ，不保证后续调用的 put() 不被阻塞。类似的，如果 empty() 返回 <code>False</code> ，也不保证后续调用的 get() 不被阻塞。</p></li><li><p><code>Queue.full</code>()</p><p>如果队列是满的返回 <code>True</code> ，否则返回 <code>False</code> 。如果 full() 返回 <code>True</code> 不保证后续调用的 get() 不被阻塞。类似的，如果 full() 返回 <code>False</code> 也不保证后续调用的 put() 不被阻塞。</p></li><li><p><code>Queue.put</code>(<em>item</em>, <em>block=True</em>, <em>timeout=None</em>)</p><p>将 <em>item</em> 放入队列。如果可选参数 <em>block</em> 是 true 并且 <em>timeout</em> 是 <code>None</code> (默认)，则在必要时阻塞至有空闲插槽可用。如果 <em>timeout</em> 是个正数，将最多阻塞 <em>timeout</em> 秒，如果在这段时间没有可用的空闲插槽，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Full" target="_blank" rel="noopener"><code>Full</code></a> 异常。反之 (<em>block</em> 是 false)，如果空闲插槽立即可用，则把 <em>item</em> 放入队列，否则引发 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Full" target="_blank" rel="noopener"><code>Full</code></a> 异常 ( 在这种情况下，<em>timeout</em> 将被忽略)。</p></li><li><p><code>Queue.put_nowait</code>(<em>item</em>)</p><p>相当于 <code>put(item, False)</code> 。</p></li><li><p><code>Queue.get</code>(<em>block=True</em>, <em>timeout=None</em>)</p><p>从队列中移除并返回一个项目。如果可选参数 <em>block</em> 是 true 并且 <em>timeout</em> 是 <code>None</code> (默认值)，则在必要时阻塞至项目可得到。如果 <em>timeout</em> 是个正数，将最多阻塞 <em>timeout</em> 秒，如果在这段时间内项目不能得到，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Empty" target="_blank" rel="noopener"><code>Empty</code></a> 异常。反之 (<em>block</em> 是 false) , 如果一个项目立即可得到，则返回一个项目，否则引发 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Empty" target="_blank" rel="noopener"><code>Empty</code></a> 异常 (这种情况下，<em>timeout</em> 将被忽略)。POSIX系统3.0之前，以及所有版本的Windows系统中，如果 <em>block</em> 是 true 并且 <em>timeout</em> 是 <code>None</code> ， 这个操作将进入基础锁的不间断等待。这意味着，没有异常能发生，尤其是 SIGINT 将不会触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyboardInterrupt" target="_blank" rel="noopener"><code>KeyboardInterrupt</code></a> 异常。</p></li><li><p><code>Queue.get_nowait</code>()</p><p>相当于 <code>get(False)</code> 。</p></li></ul><p>提供了两个方法，用于支持跟踪 排队的任务 是否 被守护的消费者线程 完整的处理。</p><ul><li><p><code>Queue.task_done</code>()</p><p>表示前面排队的任务已经被完成。被队列的消费者线程使用。每个 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.get" target="_blank" rel="noopener"><code>get()</code></a> 被用于获取一个任务， 后续调用 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.task_done" target="_blank" rel="noopener"><code>task_done()</code></a> 告诉队列，该任务的处理已经完成。如果 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.join" target="_blank" rel="noopener"><code>join()</code></a> 当前正在阻塞，在所有条目都被处理后，将解除阻塞(意味着每个 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.put" target="_blank" rel="noopener"><code>put()</code></a> 进队列的条目的 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.task_done" target="_blank" rel="noopener"><code>task_done()</code></a> 都被收到)。如果被调用的次数多于放入队列中的项目数量，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常 。</p></li><li><p><code>Queue.join</code>()</p><p>阻塞至队列中所有的元素都被接收和处理完毕。当条目添加到队列的时候，未完成任务的计数就会增加。每当消费者线程调用 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.task_done" target="_blank" rel="noopener"><code>task_done()</code></a> 表示这个条目已经被回收，该条目所有工作已经完成，未完成计数就会减少。当未完成计数降到零的时候， <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.join" target="_blank" rel="noopener"><code>join()</code></a> 阻塞被解除。</p></li></ul><p>如何等待排队的任务被完成的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = q.get()</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        do_work(item)</span><br><span class="line">        q.task_done()</span><br><span class="line"></span><br><span class="line">q = queue.Queue()</span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num_worker_threads):</span><br><span class="line">    t = threading.Thread(target=worker)</span><br><span class="line">    t.start()</span><br><span class="line">    threads.append(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> source():</span><br><span class="line">    q.put(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># block until all tasks are done</span></span><br><span class="line">q.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># stop workers</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num_worker_threads):</span><br><span class="line">    q.put(<span class="literal">None</span>)</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure><h2 id="SimpleQueue-对象"><a href="#SimpleQueue-对象" class="headerlink" title="SimpleQueue 对象"></a>SimpleQueue 对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.SimpleQueue" target="_blank" rel="noopener"><code>SimpleQueue</code></a> 对象提供下列描述的公共方法。</p><ul><li><p><code>SimpleQueue.qsize</code>()</p><p>返回队列的大致大小。注意，qsize() &gt; 0 不保证后续的 get() 不被阻塞。</p></li><li><p><code>SimpleQueue.empty</code>()</p><p>如果队列为空，返回 <code>True</code> ，否则返回 <code>False</code> 。如果 empty() 返回 <code>False</code> ，不保证后续调用的 get() 不被阻塞。</p></li><li><p><code>SimpleQueue.put</code>(<em>item</em>, <em>block=True</em>, <em>timeout=None</em>)</p><p>将 <em>item</em> 放入队列。此方法永不阻塞，始终成功（除了潜在的低级错误，例如内存分配失败）。可选参数 <em>block</em> 和 <em>timeout</em> 仅仅是为了保持 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.put" target="_blank" rel="noopener"><code>Queue.put()</code></a> 的兼容性而提供，其值被忽略。<strong>CPython implementation detail:</strong> This method has a C implementation which is reentrant. That is, a <code>put()</code> or <code>get()</code> call can be interrupted by another <code>put()</code> call in the same thread without deadlocking or corrupting internal state inside the queue. This makes it appropriate for use in destructors such as <code>__del__</code> methods or <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> callbacks.</p></li><li><p><code>SimpleQueue.put_nowait</code>(<em>item</em>)</p><p>相当于 <code>put(item)</code> ，仅为保持 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Queue.put_nowait" target="_blank" rel="noopener"><code>Queue.put_nowait()</code></a> 兼容性而提供。</p></li><li><p><code>SimpleQueue.get</code>(<em>block=True</em>, <em>timeout=None</em>)</p><p>从队列中移除并返回一个项目。如果可选参数 <em>block</em> 是 true 并且 <em>timeout</em> 是 <code>None</code> (默认值)，则在必要时阻塞至项目可得到。如果 <em>timeout</em> 是个正数，将最多阻塞 <em>timeout</em> 秒，如果在这段时间内项目不能得到，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Empty" target="_blank" rel="noopener"><code>Empty</code></a> 异常。反之 (<em>block</em> 是 false) , 如果一个项目立即可得到，则返回一个项目，否则引发 <a href="https://docs.python.org/zh-cn/3.8/library/queue.html#queue.Empty" target="_blank" rel="noopener"><code>Empty</code></a> 异常 (这种情况下，<em>timeout</em> 将被忽略)。</p></li><li><p><code>SimpleQueue.get_nowait</code>()</p><p>相当于 <code>get(False)</code> 。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="Queue的种类："><a href="#Queue的种类：" class="headerlink" title="Queue的种类："></a>Queue的种类：</h3><ul><li><p><strong>FIFO</strong>：</p><p><strong>Queue.Queue(maxsize=0)</strong></p></li></ul><p>FIFO即First in First Out,先进先出。Queue提供了一个基本的FIFO容器，使用方法很简单,maxsize是个整数，指明了队列中能存放的数据个数的上限。一旦达到上限，插入会导致阻塞，直到队列中的数据被消费掉。如果maxsize小于或者等于0，队列大小没有限制。</p><ul><li><strong>LIFO</strong></li></ul><p><strong>Queue.LifoQueue(maxsize=0)</strong></p><p>LIFO即Last in First Out,后进先出。与栈的类似，使用也很简单,maxsize用法同上</p><ul><li><strong>priority</strong></li></ul><p><strong>class Queue.PriorityQueue(maxsize=0)</strong></p><p>构造一个优先队列。maxsize用法同上。</p><h3 id="例子1：LifoQueue"><a href="#例子1：LifoQueue" class="headerlink" title="例子1：LifoQueue"></a>例子1：LifoQueue</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可以设置队列的长度 q=queue.LifoQueue(5)，意味着队列中最多存放5个元素,当队列满的时候自动进入阻塞状态</span></span><br><span class="line">q=queue.LifoQueue()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        q.put(i)</span><br><span class="line">        print(<span class="string">"数据%d被存入到队列中"</span> % i)</span><br><span class="line">    q.join()</span><br><span class="line">    print(<span class="string">'ok'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        value = q.get()</span><br><span class="line">        print(<span class="string">"数据%d从队列中取出"</span> % value)</span><br><span class="line">        q.task_done()</span><br><span class="line"> </span><br><span class="line">t1=threading.Thread(target=put,args=())</span><br><span class="line">t1.start()</span><br><span class="line">t2=threading.Thread(target=get,args=())</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">0</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">1</span>被存入到数据中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">2</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">3</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">4</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">5</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">6</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">7</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">8</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">9</span>被存入到队列中</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">9</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">8</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">7</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">6</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">5</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">4</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">3</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">2</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">1</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>数据<span class="number">0</span>从队列中取出</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ok</span><br></pre></td></tr></table></figure><h3 id="例子2：Priortity-Queue-in-Python"><a href="#例子2：Priortity-Queue-in-Python" class="headerlink" title="例子2：Priortity Queue in Python"></a>例子2：Priortity Queue in Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A simple implementation of Priority Queue </span></span><br><span class="line"><span class="comment"># using Queue. </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span><span class="params">(object)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        self.queue = [] </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join([str(i) <span class="keyword">for</span> i <span class="keyword">in</span> self.queue]) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># for checking if the queue is empty </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> len(self.queue) == [] </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># for inserting an element in the queue </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, data)</span>:</span> </span><br><span class="line">        self.queue.append(data) </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># for popping an element based on Priority </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">try</span>: </span><br><span class="line">            max = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.queue)): </span><br><span class="line">                <span class="keyword">if</span> self.queue[i] &gt; self.queue[max]: </span><br><span class="line">                    max = i </span><br><span class="line">            item = self.queue[max] </span><br><span class="line">            <span class="keyword">del</span> self.queue[max] </span><br><span class="line">            <span class="keyword">return</span> item </span><br><span class="line">        <span class="keyword">except</span> IndexError: </span><br><span class="line">            print() </span><br><span class="line">            exit() </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: </span><br><span class="line">    myQueue = PriorityQueue() </span><br><span class="line">    myQueue.insert(<span class="number">12</span>) </span><br><span class="line">    myQueue.insert(<span class="number">1</span>) </span><br><span class="line">    myQueue.insert(<span class="number">14</span>) </span><br><span class="line">    myQueue.insert(<span class="number">7</span>) </span><br><span class="line">    print(myQueue)             </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> myQueue.isEmpty(): </span><br><span class="line">        print(myQueue.delete())  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">12</span> <span class="number">1</span> <span class="number">14</span> <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>()</span><br></pre></td></tr></table></figure><h2 id="扩展-第三方队列"><a href="#扩展-第三方队列" class="headerlink" title="扩展:第三方队列"></a>扩展:第三方队列</h2><p>下面介绍五个第三方队列框架,看来造轮子也是个好方法，:)</p><ol><li><p><a href="http://www.celeryproject.org/" target="_blank" rel="noopener">Celery</a>  </p><p><a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html" target="_blank" rel="noopener">官方栗子</a></p></li><li><p><a href="http://python-rq.org/" target="_blank" rel="noopener">RQ</a> </p></li></ol><p>   一个栗子</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_words_at_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> len(resp.text.split())</span><br></pre></td></tr></table></figure><p>   创建一个RQ queue</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">from</span> rq <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">q = Queue(connection=Redis())</span><br></pre></td></tr></table></figure><p>   方法调用</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> count_words_at_url</span><br><span class="line">result = q.enqueue(</span><br><span class="line">             count_words_at_url, <span class="string">'http://nvie.com'</span>)</span><br></pre></td></tr></table></figure><p>   Worker实例</p>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rq worker</span><br><span class="line">*** Listening <span class="keyword">for</span> work on default</span><br><span class="line">Got count_words_at_url(<span class="string">'http://nvie.com'</span>) <span class="keyword">from</span> default</span><br><span class="line">Job result = <span class="number">818</span></span><br><span class="line">*** Listening <span class="keyword">for</span> work on default</span><br></pre></td></tr></table></figure><ol start="3"><li><p><a href="https://huey.readthedocs.io/en/latest/" target="_blank" rel="noopener">huey</a> </p><blockquote><p>一个轻量级队列框架</p></blockquote><p>一个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> huey <span class="keyword">import</span> RedisHuey, crontab</span><br><span class="line"></span><br><span class="line">huey = RedisHuey(<span class="string">'my-app'</span>, host=<span class="string">'redis.myapp.com'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@huey.task()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="meta">@huey.task(retries=2, retry_delay=60)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flaky_task</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment"># This task might fail, in which case it will be retried up to 2 times</span></span><br><span class="line">    <span class="comment"># with a delay of 60s between retries.</span></span><br><span class="line">    <span class="keyword">return</span> this_might_fail(url)</span><br><span class="line"></span><br><span class="line"><span class="meta">@huey.periodic_task(crontab(minute='0', hour='3'))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nightly_backup</span><span class="params">()</span>:</span></span><br><span class="line">    sync_all_data()</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p><a href="https://kuyruk.readthedocs.io/en/latest/" target="_blank" rel="noopener">kuyruk</a></p><p>创建Task</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tasks.py</span></span><br><span class="line"><span class="keyword">from</span> kuyruk <span class="keyword">import</span> Kuyruk</span><br><span class="line"></span><br><span class="line">kuyruk = Kuyruk()</span><br><span class="line"></span><br><span class="line"><span class="meta">@kuyruk.task()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> message</span><br></pre></td></tr></table></figure><p>发送Task 去 RabbitMQ</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tasks</span><br><span class="line">tasks.echo(<span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></table></figure><p>运行Worker</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kuyruk --app tasks.kuyruk worker</span><br></pre></td></tr></table></figure></li><li><p><a href="https://dramatiq.io/" target="_blank" rel="noopener"><strong>Dramatiq</strong></a>  </p><p>一个栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dramatiq</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dramatiq.actor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_words</span><span class="params">(url)</span>:</span></span><br><span class="line">     response = requests.get(url)</span><br><span class="line">     count = len(response.text.split(<span class="string">" "</span>))</span><br><span class="line">     print(<span class="string">f"There are <span class="subst">&#123;count&#125;</span> words at <span class="subst">&#123;url!r&#125;</span>."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Synchronously count the words on example.com in the current process</span></span><br><span class="line">count_words(<span class="string">"http://example.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># or send the actor a message so that it may perform the count</span></span><br><span class="line"><span class="comment"># later, in a separate process.</span></span><br><span class="line">count_words.send(<span class="string">"http://example.com"</span>)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-queue&quot;&gt;&lt;a href=&quot;#python-标准库-queue&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 queue&quot;&gt;&lt;/a&gt;python 标准库 queue&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://up.enterdesk.com/edpic/02/40/4a/02404af0eafff163c22ce10400cb5be9.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="queue" scheme="https://pinghailinfeng.gitee.io/tags/queue/"/>
    
  </entry>
  
</feed>
