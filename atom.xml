<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凭海临风的IT江湖</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pinghailinfeng.gitee.io/"/>
  <updated>2020-02-29T15:45:26.182Z</updated>
  <id>https://pinghailinfeng.gitee.io/</id>
  
  <author>
    <name>Jeff Sui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python standard library selectors</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/29/python-standard-library-selectors/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/29/python-standard-library-selectors/</id>
    <published>2020-02-29T13:52:55.000Z</published>
    <updated>2020-02-29T15:45:26.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-selectors-高级-I-O-复用库"><a href="#python-标准库-selectors-高级-I-O-复用库" class="headerlink" title="python 标准库 selectors  高级 I/O 复用库"></a>python 标准库 selectors  高级 I/O 复用库</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200229selectors.jpg?raw=true" alt></p><a id="more"></a><p><strong>源码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/selectors.py" target="_blank" rel="noopener">Lib/selectors.py</a></p><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>它的功能与linux的epoll，还是select模块,poll等类似；实现高效的I/O multiplexing,  常用于非阻塞的socket的编程中</p><p>模块定义了一个 BaseSelector的抽象基类， 以及它的子类，包括：EpollSelector, KqueueSelector等模块,</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Classes hierarchy:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseSelector</span><br><span class="line">+-- SelectSelector</span><br><span class="line">+-- PollSelector</span><br><span class="line">+-- EpollSelector</span><br><span class="line">+-- DevpollSelector</span><br><span class="line">+-- KqueueSelector</span><br></pre></td></tr></table></figure><p>模块定义了两个常量，用于描述 event Mask</p><table><thead><tr><th>常数</th><th>意义</th></tr></thead><tbody><tr><td><code>EVENT_READ</code></td><td>可读</td></tr><tr><td><code>EVENT_WRITE</code></td><td>可写</td></tr></tbody></table><p>模块定义了一个 SelectorKey类,是一个 <a href="https://docs.python.org/zh-cn/3.8/library/collections.html#collections.namedtuple" target="_blank" rel="noopener"><code>namedtuple</code></a> 类型, 一般用这个类的实例来描述一个已经注册的文件对象的状态，</p><p>常用属性:</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">fileobj</td><td style="text-align:left">表示已经注册的文件对象</td></tr><tr><td style="text-align:center">fd</td><td style="text-align:left">表示文件对象的描述符，是一个整数，它是文件对象的 fileno()方法的返回值</td></tr><tr><td style="text-align:center">events</td><td style="text-align:left">表示注册一个文件对象时，我们等待的events, 即上面的event Mask, 是可读呢还是可写</td></tr><tr><td style="text-align:center">data</td><td style="text-align:left">表示注册一个文件对象是邦定的data</td></tr></tbody></table><p><em>class</em> <code>selectors.BaseSelector</code></p><p>定义了一个抽象基类,能够注册和取消注册,通过一个可选的timeout,等待流中的I/O事件。抽象基类无法实例化,所以通常使用<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.DefaultSelector" target="_blank" rel="noopener"><code>DefaultSelector</code></a> 代替，或者<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectSelector" target="_blank" rel="noopener">SelectSelector`</a>, <a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.KqueueSelector" target="_blank" rel="noopener"><code>KqueueSelector</code></a> 来实现。如果你想声明一个操作系统平台支持的实现, <a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.BaseSelector" target="_blank" rel="noopener"><code>BaseSelector</code></a> 和他的子类支持 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-context-manager" target="_blank" rel="noopener">上下文管理</a> 实现。</p><ul><li><p><em>abstractmethod</em> <code>register</code>(<em>fileobj</em>, <em>events</em>, <em>data=None</em>)</p><p>用于注册一个文件对象或监控I/O事件的抽象方法。<strong>fileobj</strong> 参数是一个用于监控的对象。它可能是一个整形文件描述符或者是一个拥有 <code>fileno()</code>方法的对象。返回一个新创建的<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectorKey" target="_blank" rel="noopener">SelectorKey`</a> 类实例,或因为不存在的<code>event mask</code> 或文件描述符,或者该文件对象已经被注册过而引发<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。</p></li><li><p><em>abstractmethod</em> <code>unregister</code>(<em>fileobj</em>)</p><p>用于注销注册文件对象或移除监控I/O事件的抽象方法。该文件对象必须是之前已经注册的对象。返回值关联了<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectorKey" target="_blank" rel="noopener"><code>SelectorKey</code></a> 实例,或因为不存在的<code>event mask</code> 或文件描述符,或者该文件对象已经被注册过而引发<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。</p></li><li><p><code>modify</code>(<em>fileobj</em>, <em>events</em>, <em>data=None</em>)</p><p>用于修改一个注册过的文件对象，比如从监听可读变为监听可写；它其实就是register() 后再跟unregister(),       但是使用modify( ) 更高效；返回一个新创建的<a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectorKey" target="_blank" rel="noopener">SelectorKey`</a> 类实例,或因为不存在的<code>event mask</code> 或文件描述符,或者该文件对象已经被注册过而引发<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。</p></li><li><p><em>abstractmethod</em> <code>select</code>(<em>timeout=None</em>)</p><p>用于选择满足我们监听的event的文件对象的抽象方法。</p></li><li><p><code>close</code>()</p><p>关闭 selector,为了 要确保所有的资源被释放,最后一定要调用该方法。</p></li><li><p><code>get_key</code>(<em>fileobj</em>)</p><p>返回注册文件对象的 <a href="https://docs.python.org/zh-cn/3.8/library/selectors.html#selectors.SelectorKey" target="_blank" rel="noopener"><code>SelectorKey</code></a> 实例。该实例关联文件对象,若文件对象未注册,将抛出<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 异常。</p></li><li><p><em>abstractmethod</em> <code>get_map</code>()</p><p>返回selectors key 的文件对象的映射。</p></li><li><p><em>class</em> <code>selectors.DefaultSelector</code></p><p>默认的selector类,其中一个子类的别名，它自动选择为当前环境中最有效的Selector。</p><p><em>selectors模块默认会用epoll，如果你的系统中没有epoll(比如windows)则会自动使用select</em></p></li><li><p><em>class</em> <code>selectors.SelectSelector</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.select" target="_blank" rel="noopener"><code>select.select()</code></a>-based selector.</p></li><li><p><em>class</em> <code>selectors.PollSelector</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.poll" target="_blank" rel="noopener"><code>select.poll()</code></a>-based selector.</p></li><li><p><em>class</em> <code>selectors.EpollSelector</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.epoll" target="_blank" rel="noopener"><code>select.epoll()</code></a>-based selector.<code>fileno</code>()This returns the file descriptor used by the underlying <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.epoll" target="_blank" rel="noopener"><code>select.epoll()</code></a> object.</p></li><li><p><em>class</em> <code>selectors.DevpollSelector</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.devpoll" target="_blank" rel="noopener"><code>select.devpoll()</code></a>-based selector.<code>fileno</code>()This returns the file descriptor used by the underlying <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.devpoll" target="_blank" rel="noopener"><code>select.devpoll()</code></a> object.<em>3.5 新版功能.</em></p></li><li><p><em>class</em> <code>selectors.KqueueSelector</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.kqueue" target="_blank" rel="noopener"><code>select.kqueue()</code></a>-based selector.<code>fileno</code>()This returns the file descriptor used by the underlying <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.kqueue" target="_blank" rel="noopener"><code>select.kqueue()</code></a> object.</p></li></ul><h2 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h2><p>Here is a simple echo server implementation:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sel = selectors.DefaultSelector()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span><span class="params">(sock, mask)</span>:</span></span><br><span class="line">    conn, addr = sock.accept()  <span class="comment"># Should be ready</span></span><br><span class="line">    print(<span class="string">'accepted'</span>, conn, <span class="string">'from'</span>, addr)</span><br><span class="line">    conn.setblocking(<span class="literal">False</span>)</span><br><span class="line">    sel.register(conn, selectors.EVENT_READ, read)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(conn, mask)</span>:</span></span><br><span class="line">    data = conn.recv(<span class="number">1000</span>)  <span class="comment"># Should be ready</span></span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        print(<span class="string">'echoing'</span>, repr(data), <span class="string">'to'</span>, conn)</span><br><span class="line">        conn.send(data)  <span class="comment"># Hope it won't block</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'closing'</span>, conn)</span><br><span class="line">        sel.unregister(conn)</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">sock = socket.socket()</span><br><span class="line">sock.bind((<span class="string">'localhost'</span>, <span class="number">1234</span>))</span><br><span class="line">sock.listen(<span class="number">100</span>)</span><br><span class="line">sock.setblocking(<span class="literal">False</span>)</span><br><span class="line">sel.register(sock, selectors.EVENT_READ, accept)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    events = sel.select()</span><br><span class="line">    <span class="keyword">for</span> key, mask <span class="keyword">in</span> events:</span><br><span class="line">        callback = key.data</span><br><span class="line">        callback(key.fileobj, mask)</span><br></pre></td></tr></table></figure><h2 id="一个基于socket的客户端与服务器端实例"><a href="#一个基于socket的客户端与服务器端实例" class="headerlink" title="一个基于socket的客户端与服务器端实例"></a>一个基于socket的客户端与服务器端实例</h2><h3 id="基于socket的服务器端实例"><a href="#基于socket的服务器端实例" class="headerlink" title="基于socket的服务器端实例"></a>基于socket的服务器端实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">selectors_echo_server.py</span><br><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">mysel = selectors.DefaultSelector()</span><br><span class="line">keep_running = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(connection, mask)</span>:</span></span><br><span class="line">    <span class="string">"Callback for read events"</span></span><br><span class="line">    <span class="keyword">global</span> keep_running</span><br><span class="line"></span><br><span class="line">    client_address = connection.getpeername()</span><br><span class="line">    print(<span class="string">'read(&#123;&#125;)'</span>.format(client_address))</span><br><span class="line">    data = connection.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        <span class="comment"># A readable client socket has data</span></span><br><span class="line">        print(<span class="string">'  received &#123;!r&#125;'</span>.format(data))</span><br><span class="line">        connection.sendall(data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Interpret empty result as closed connection</span></span><br><span class="line">        print(<span class="string">'  closing'</span>)</span><br><span class="line">        mysel.unregister(connection)</span><br><span class="line">        connection.close()</span><br><span class="line">        <span class="comment"># Tell the main loop to stop</span></span><br><span class="line">        keep_running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span><span class="params">(sock, mask)</span>:</span></span><br><span class="line">    <span class="string">"Callback for new connections"</span></span><br><span class="line">    new_connection, addr = sock.accept()</span><br><span class="line">    print(<span class="string">'accept(&#123;&#125;)'</span>.format(addr))</span><br><span class="line">    new_connection.setblocking(<span class="literal">False</span>)</span><br><span class="line">    mysel.register(new_connection, selectors.EVENT_READ, read)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server_address = (<span class="string">'localhost'</span>, <span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'starting up on &#123;&#125; port &#123;&#125;'</span>.format(*server_address))</span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server.setblocking(<span class="literal">False</span>)</span><br><span class="line">server.bind(server_address)</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">mysel.register(server, selectors.EVENT_READ, accept)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> keep_running:</span><br><span class="line">    print(<span class="string">'waiting for I/O'</span>)</span><br><span class="line">    <span class="keyword">for</span> key, mask <span class="keyword">in</span> mysel.select(timeout=<span class="number">1</span>):</span><br><span class="line">        callback = key.data</span><br><span class="line">        callback(key.fileobj, mask)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'shutting down'</span>)</span><br><span class="line">mysel.close()</span><br></pre></td></tr></table></figure><h3 id="基于socket的客户端实例"><a href="#基于socket的客户端实例" class="headerlink" title="基于socket的客户端实例"></a>基于socket的客户端实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">selectors_echo_client.py</span><br><span class="line"><span class="keyword">import</span> selectors</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">mysel = selectors.DefaultSelector()</span><br><span class="line">keep_running = <span class="literal">True</span></span><br><span class="line">outgoing = [</span><br><span class="line">    <span class="string">b'It will be repeated.'</span>,</span><br><span class="line">    <span class="string">b'This is the message.  '</span>,</span><br><span class="line">]</span><br><span class="line">bytes_sent = <span class="number">0</span></span><br><span class="line">bytes_received = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Connecting is a blocking operation, so call setblocking()</span></span><br><span class="line"><span class="comment"># after it returns.</span></span><br><span class="line">server_address = (<span class="string">'localhost'</span>, <span class="number">10000</span>)</span><br><span class="line">print(<span class="string">'connecting to &#123;&#125; port &#123;&#125;'</span>.format(*server_address))</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.connect(server_address)</span><br><span class="line">sock.setblocking(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up the selector to watch for when the socket is ready</span></span><br><span class="line"><span class="comment"># to send data as well as when there is data to read.</span></span><br><span class="line">mysel.register(</span><br><span class="line">    sock,</span><br><span class="line">    selectors.EVENT_READ | selectors.EVENT_WRITE,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> keep_running:</span><br><span class="line">    print(<span class="string">'waiting for I/O'</span>)</span><br><span class="line">    <span class="keyword">for</span> key, mask <span class="keyword">in</span> mysel.select(timeout=<span class="number">1</span>):</span><br><span class="line">        connection = key.fileobj</span><br><span class="line">        client_address = connection.getpeername()</span><br><span class="line">        print(<span class="string">'client(&#123;&#125;)'</span>.format(client_address))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mask &amp; selectors.EVENT_READ:</span><br><span class="line">            print(<span class="string">'  ready to read'</span>)</span><br><span class="line">            data = connection.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> data:</span><br><span class="line">                <span class="comment"># A readable client socket has data</span></span><br><span class="line">                print(<span class="string">'  received &#123;!r&#125;'</span>.format(data))</span><br><span class="line">                bytes_received += len(data)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Interpret empty result as closed connection,</span></span><br><span class="line">            <span class="comment"># and also close when we have received a copy</span></span><br><span class="line">            <span class="comment"># of all of the data sent.</span></span><br><span class="line">            keep_running = <span class="keyword">not</span> (</span><br><span class="line">                data <span class="keyword">or</span></span><br><span class="line">                (bytes_received <span class="keyword">and</span></span><br><span class="line">                 (bytes_received == bytes_sent))</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mask &amp; selectors.EVENT_WRITE:</span><br><span class="line">            print(<span class="string">'  ready to write'</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> outgoing:</span><br><span class="line">                <span class="comment"># We are out of messages, so we no longer need to</span></span><br><span class="line">                <span class="comment"># write anything. Change our registration to let</span></span><br><span class="line">                <span class="comment"># us keep reading responses from the server.</span></span><br><span class="line">                print(<span class="string">'  switching to read-only'</span>)</span><br><span class="line">                mysel.modify(sock, selectors.EVENT_READ)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Send the next message.</span></span><br><span class="line">                next_msg = outgoing.pop()</span><br><span class="line">                print(<span class="string">'  sending &#123;!r&#125;'</span>.format(next_msg))</span><br><span class="line">                sock.sendall(next_msg)</span><br><span class="line">                bytes_sent += len(next_msg)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'shutting down'</span>)</span><br><span class="line">mysel.unregister(connection)</span><br><span class="line">connection.close()</span><br><span class="line">mysel.close()</span><br></pre></td></tr></table></figure><h3 id="Server和client交互"><a href="#Server和client交互" class="headerlink" title="Server和client交互"></a>Server和client交互</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ python3 source/selectors/selectors_echo_server.py</span><br><span class="line">starting up on localhost port <span class="number">10000</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">accept((<span class="string">'127.0.0.1'</span>, <span class="number">59850</span>))</span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">read((<span class="string">'127.0.0.1'</span>, <span class="number">59850</span>))</span><br><span class="line">  received <span class="string">b'This is the message.  It will be repeated.'</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">read((<span class="string">'127.0.0.1'</span>, <span class="number">59850</span>))</span><br><span class="line">  closing</span><br><span class="line">shutting down</span><br></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ python3 source/selectors/selectors_echo_client.py</span><br><span class="line">connecting to localhost port <span class="number">10000</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">client((<span class="string">'127.0.0.1'</span>, <span class="number">10000</span>))</span><br><span class="line">  ready to write</span><br><span class="line">  sending <span class="string">b'This is the message.  '</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">client((<span class="string">'127.0.0.1'</span>, <span class="number">10000</span>))</span><br><span class="line">  ready to write</span><br><span class="line">  sending <span class="string">b'It will be repeated.'</span></span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">client((<span class="string">'127.0.0.1'</span>, <span class="number">10000</span>))</span><br><span class="line">  ready to write</span><br><span class="line">  switching to read-only</span><br><span class="line">waiting <span class="keyword">for</span> I/O</span><br><span class="line">client((<span class="string">'127.0.0.1'</span>, <span class="number">10000</span>))</span><br><span class="line">  ready to read</span><br><span class="line">  received <span class="string">b'This is the message.  It will be repeated.'</span></span><br><span class="line">shutting down</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://pymotw.com/3/selectors/" target="_blank" rel="noopener">python标准库之selectors</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-selectors-高级-I-O-复用库&quot;&gt;&lt;a href=&quot;#python-标准库-selectors-高级-I-O-复用库&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 selectors  高级 I/O 复用库&quot;&gt;&lt;/a&gt;python 标准库 selectors  高级 I/O 复用库&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200229selectors.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="selectors" scheme="https://pinghailinfeng.gitee.io/tags/selectors/"/>
    
      <category term="socket" scheme="https://pinghailinfeng.gitee.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>python standard library turtle-2</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/28/python-standard-library-turtle-2/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/28/python-standard-library-turtle-2/</id>
    <published>2020-02-28T11:31:49.000Z</published>
    <updated>2020-02-28T12:21:30.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-turtle-海龟制图-续"><a href="#python-标准库-turtle-海龟制图-续" class="headerlink" title="python 标准库 turtle 海龟制图(续)"></a>python 标准库 turtle 海龟制图(续)</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/2020200228english.png?raw=true" alt></p><a id="more"></a><h3 id="使用事件"><a href="#使用事件" class="headerlink" title="使用事件"></a>使用事件</h3><ul><li><p><code>turtle.onclick</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p><p>参数<strong>fun</strong> – 一个函数，调用时将传入两个参数表示在画布上点击的坐标。<strong>btn</strong> – 鼠标按钮编号，默认值为 1 (鼠标左键)<strong>add</strong> – <code>True</code> 或 <code>False</code> – 如为 <code>True</code> 则将添加一个新绑定，否则将取代先前的绑定将 <em>fun</em> 指定的函数绑定到鼠标点击此海龟事件。如果 <em>fun</em> 值为 <code>None</code>，则移除现有的绑定。以下为使用匿名海龟即过程式的示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">turn</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="meta">... </span>    left(<span class="number">180</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>onclick(turn)  <span class="comment"># Now clicking into the turtle will turn it.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>onclick(<span class="literal">None</span>)  <span class="comment"># event-binding will be removed</span></span><br></pre></td></tr></table></figure></li><li><p><code>turtle.onrelease</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p><ul><li>参数</li></ul><p><strong>fun</strong> – 一个函数，调用时将传入两个参数表示在画布上点击的坐标。<strong>btn</strong> – 鼠标按钮编号，默认值为 1 (鼠标左键)<strong>add</strong> – <code>True</code> 或 <code>False</code> – 如为 <code>True</code> 则将添加一个新绑定，否则将取代先前的绑定</p><p>将 <em>fun</em> 指定的函数绑定到在此海龟上释放鼠标按键事件。如果 <em>fun</em> 值为 <code>None</code>，则移除现有的绑定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyTurtle</span><span class="params">(Turtle)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">glow</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.fillcolor(<span class="string">"red"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">unglow</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.fillcolor(<span class="string">""</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle = MyTurtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.onclick(turtle.glow)     <span class="comment"># clicking on turtle turns fillcolor red,</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.onrelease(turtle.unglow) <span class="comment"># releasing turns it to transparent.</span></span><br></pre></td></tr></table></figure></li><li><p><code>turtle.ondrag</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p><ul><li><p>参数</p><p><strong>fun</strong> – 一个函数，调用时将传入两个参数表示在画布上点击的坐标。<strong>btn</strong> – 鼠标按钮编号，默认值为 1 (鼠标左键)<strong>add</strong> – <code>True</code> 或 <code>False</code> – 如为 <code>True</code> 则将添加一个新绑定，否则将取代先前的绑定</p></li></ul><p>将 <em>fun</em> 指定的函数绑定到在此海龟上移动鼠标事件。如果 <em>fun</em> 值为 <code>None</code>，则移除现有的绑定。</p><p>注: 在海龟上移动鼠标事件之前应先发生在此海龟上点击鼠标事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; turtle.ondrag(turtle.goto)</span><br></pre></td></tr></table></figure><p>在此之后点击并拖动海龟可在屏幕上手绘线条 (如果画笔为落下)。</p></li></ul><h3 id="特殊海龟方法"><a href="#特殊海龟方法" class="headerlink" title="特殊海龟方法"></a>特殊海龟方法</h3><ul><li><p><code>turtle.begin_poly</code>()</p><p>开始记录多边形的顶点。当前海龟位置为多边形的第一个顶点。</p></li><li><p><code>turtle.end_poly</code>()</p><p>停止记录多边形的顶点。当前海龟位置为多边形的最后一个顶点。它将连线到第一个顶点。</p></li><li><p><code>turtle.get_poly</code>()</p><p>返回最新记录的多边形。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.begin_poly()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.end_poly()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = turtle.get_poly()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>register_shape(<span class="string">"myFavouriteShape"</span>, p)</span><br></pre></td></tr></table></figure></li></ul><ul><li><code>turtle.clone</code>()</li></ul><p>创建并返回海龟的克隆体，具有相同的位置、朝向和海龟属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mick = Turtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe = mick.clone()</span><br></pre></td></tr></table></figure><ul><li><p><code>turtle.getturtle</code>()</p></li><li><p><code>turtle.getpen</code>()</p></li></ul><p>返回海龟对象自身。唯一合理的用法: 作为一个函数来返回 “匿名海龟”:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pet = getturtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pet.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pet</span><br><span class="line">&lt;turtle.Turtle object at <span class="number">0</span>x...&gt;</span><br></pre></td></tr></table></figure><ul><li><code>turtle.getscreen</code>()</li></ul><p>返回作为海龟绘图场所的 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 类对象。该对象将可调用 TurtleScreen 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ts = turtle.getscreen()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ts</span><br><span class="line">&lt;turtle._Screen object at <span class="number">0</span>x...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ts.bgcolor(<span class="string">"pink"</span>)</span><br></pre></td></tr></table></figure><ul><li><p><code>turtle.setundobuffer</code>(<em>size</em>)</p><ul><li><p>参数</p><p><strong>size</strong> – 一个整型数值或 <code>None</code></p></li></ul></li></ul><p>设置或禁用撤消缓冲区。如果 <em>size</em> 为一个整型数则将开辟一个指定大小的空缓冲区。<em>size</em> 表示可使用 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.undo" target="_blank" rel="noopener"><code>undo()</code></a> 方法/函数撤消的海龟命令的次数上限。如果 <em>size</em> 为 <code>None</code> 则禁用撤消缓冲区。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setundobuffer(<span class="number">42</span>)</span><br></pre></td></tr></table></figure><ul><li><code>turtle.undobufferentries</code>()</li></ul><p>返回撤销缓冲区里的条目数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> undobufferentries():</span><br><span class="line"><span class="meta">... </span>    undo()</span><br></pre></td></tr></table></figure><h3 id="复合形状"><a href="#复合形状" class="headerlink" title="复合形状"></a>复合形状</h3><p>要使用由多个不同颜色多边形构成的复合海龟形状，你必须明确地使用辅助类 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Shape" target="_blank" rel="noopener"><code>Shape</code></a>，具体步骤如下:</p><ol><li><p>创建一个空 Shape 对象，类型为 “compound”。</p></li><li><p>按照需要使用 <code>addcomponent()</code> 方法向此对象添加多个部件。</p><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Shape(<span class="string">"compound"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>poly1 = ((<span class="number">0</span>,<span class="number">0</span>),(<span class="number">10</span>,<span class="number">-5</span>),(<span class="number">0</span>,<span class="number">10</span>),(<span class="number">-10</span>,<span class="number">-5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.addcomponent(poly1, <span class="string">"red"</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>poly2 = ((<span class="number">0</span>,<span class="number">0</span>),(<span class="number">10</span>,<span class="number">-5</span>),(<span class="number">-10</span>,<span class="number">-5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.addcomponent(poly2, <span class="string">"blue"</span>, <span class="string">"red"</span>)</span><br></pre></td></tr></table></figure></li><li><p>接下来将 Shape 对象添加到 Screen 对象的形状列表并使用它:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>register_shape(<span class="string">"myshape"</span>, s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shape(<span class="string">"myshape"</span>)</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Shape" target="_blank" rel="noopener"><code>Shape</code></a> 类在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.register_shape" target="_blank" rel="noopener"><code>register_shape()</code></a> 方法的内部以多种方式使用。应用程序编写者 <em>只有</em> 在使用上述的复合形状时才需要处理 Shape 类。</p></blockquote><h2 id="TurtleScreen-Screen-方法及对应函数"><a href="#TurtleScreen-Screen-方法及对应函数" class="headerlink" title="TurtleScreen/Screen 方法及对应函数"></a>TurtleScreen/Screen 方法及对应函数</h2><p>本节中的大部分示例都使用 TurtleScreen 类的一个实例，命名为 <code>screen</code>。</p><h3 id="窗口控制"><a href="#窗口控制" class="headerlink" title="窗口控制"></a>窗口控制</h3><ul><li><p><code>turtle.bgcolor</code>(*<em>args</em>)</p><p>参数<strong>args</strong> – 一个颜色字符串或三个取值范围 0..colormode 内的数值或一个取值范围相同的数值3元组设置或返回 TurtleScreen 的背景颜色。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgcolor()</span><br><span class="line"><span class="string">'orange'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgcolor(<span class="string">"#800080"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgcolor()</span><br><span class="line">(<span class="number">128.0</span>, <span class="number">0.0</span>, <span class="number">128.0</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>urtle.bgpic</code>(<em>picname=None</em>)</p><ul><li><p>参数</p><p><strong>picname</strong> – 一个字符串, gif-文件名, <code>&quot;nopic&quot;</code>, 或 <code>None</code></p></li></ul><p>设置背景图片或返回当前背景图片名称。如果 <em>picname</em> 为一个文件名，则将相应图片设为背景。如果 <em>picname</em> 为 <code>&quot;nopic&quot;</code>，则删除当前背景图片。如果 <em>picname</em> 为 <code>None</code>，则返回当前背景图片文件名。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgpic()</span><br><span class="line"><span class="string">'nopic'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgpic(<span class="string">"landscape.gif"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.bgpic()</span><br><span class="line"><span class="string">"landscape.gif"</span></span><br></pre></td></tr></table></figure></li><li><p><code>turtle.clear</code>()</p><p><code>turtle.clearscreen</code>()</p><p>从中删除所有海龟的全部绘图。将已清空的 TurtleScreen 重置为初始状态: 白色背景，无背景片，无事件绑定并启用追踪。</p><blockquote><p>此 TurtleScreen 方法作为全局函数时只有一个名字 <code>clearscreen</code>。全局函数 <code>clear</code> 所对应的是 Turtle 方法 <code>clear</code>。</p></blockquote></li><li><p><code>turtle.reset</code>()</p></li><li><p><code>turtle.resetscreen</code>()</p><p>重置屏幕上的所有海龟为其初始状态。</p></li><li><p><code>turtle.reset</code>()</p><p><code>turtle.resetscreen</code>()</p><p>重置屏幕上的所有海龟为其初始状态。</p><blockquote><p>此 TurtleScreen 方法作为全局函数时只有一个名字 <code>resetscreen</code>。全局函数 <code>reset</code> 所对应的是 Turtle 方法 <code>reset</code>。</p></blockquote></li><li><p><code>turtle.screensize</code>(<em>canvwidth=None</em>, <em>canvheight=None</em>, <em>bg=None</em>)</p><ul><li><p>参数</p><p><strong>canvwidth</strong> – 正整型数，以像素表示画布的新宽度值<strong>canvheight</strong> – 正整型数，以像素表示画面的新高度值<strong>bg</strong> – 颜色字符串或颜色元组，新的背景颜色</p></li></ul><p>如未指定任何参数，则返回当前的 (canvaswidth, canvasheight)。否则改变作为海龟绘图场所的画布大小。不改变绘图窗口。要观察画布的隐藏区域，可以使用滚动条。通过此方法可以令之前绘制于画布之外的图形变为可见。</p><p>可见。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.screensize()</span><br><span class="line">(<span class="number">400</span>, <span class="number">300</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.screensize(<span class="number">2000</span>,<span class="number">1500</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.screensize()</span><br><span class="line">(<span class="number">2000</span>, <span class="number">1500</span>)</span><br></pre></td></tr></table></figure><p>也可以用来寻找意外逃走的海龟 ;-)</p></li><li><p><code>turtle.setworldcoordinates</code>(<em>llx</em>, <em>lly</em>, <em>urx</em>, <em>ury</em>)</p><ul><li><p>参数</p><p><strong>llx</strong> – 一个数值, 画布左下角的 x-坐标</p><p><strong>lly</strong> – 一个数值, 画布左下角的 y-坐标</p><p><strong>urx</strong> – 一个数值, 画面右上角的 x-坐标</p><p><strong>ury</strong> – 一个数值, 画布右上角的 y-坐标</p></li></ul><p>设置用户自定义坐标系并在必要时切换模式为 “world”。这会执行一次 <code>screen.reset()</code>。如果 “world” 模式已激活，则所有图形将根据新的坐标系重绘。</p><p><strong>注意</strong>: 在用户自定义坐标系中，角度可能显得扭曲。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.setworldcoordinates(<span class="number">-50</span>,<span class="number">-7.5</span>,<span class="number">50</span>,<span class="number">7.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">72</span>):</span><br><span class="line"><span class="meta">... </span>    left(<span class="number">10</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line"><span class="meta">... </span>    left(<span class="number">45</span>); fd(<span class="number">2</span>)   <span class="comment"># a regular octagon</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="动画控制"><a href="#动画控制" class="headerlink" title="动画控制"></a>动画控制</h3><ul><li><p><code>turtle.delay</code>(<em>delay=None</em>)</p><ul><li><p>参数</p><p><strong>delay</strong> – 正整型数</p></li></ul><p>设置或返回以毫秒数表示的延迟值 <em>delay</em>。(这约等于连续两次画布刷新的间隔时间。) 绘图延迟越长，动画速度越慢。</p><p>可选参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.delay()</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.delay(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.delay()</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p><code>turtle.tracer</code>(<em>n=None</em>, <em>delay=None</em>)</p><p>参数<strong>n</strong> – 非负整型数<strong>delay</strong> – 非负整型数启用/禁用海龟动画并设置刷新图形的延迟时间。如果指定 <em>n</em> 值，则只有每第 n 次屏幕刷新会实际执行。(可被用来加速复杂图形的绘制。) 如果调用时不带参数，则返回当前保存的 n 值。第二个参数设置延迟值 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.delay" target="_blank" rel="noopener"><code>delay()</code></a>)。<code>&gt;&gt;&gt; screen.tracer(8, 25) &gt;&gt;&gt; dist = 2 &gt;&gt;&gt; for i in range(200): ...     fd(dist) ...     rt(90) ...     dist += 2</code></p></li><li><p><code>turtle.update</code>()</p><p>执行一次 TurtleScreen 刷新。在禁用追踪时使用。</p></li></ul><p>另参见 RawTurtle/Turtle 方法 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.speed" target="_blank" rel="noopener"><code>speed()</code></a>。</p><h3 id="使用屏幕事件"><a href="#使用屏幕事件" class="headerlink" title="使用屏幕事件"></a>使用屏幕事件</h3><ul><li><p><code>turtle.listen</code>(<em>xdummy=None</em>, <em>ydummy=None</em>)</p><p>设置焦点到 TurtleScreen (以便接收按键事件)。使用两个 Dummy 参数以便能够传递 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.listen" target="_blank" rel="noopener"><code>listen()</code></a> 给 onclick 方法。</p></li><li><p><code>turtle.onkey</code>(<em>fun</em>, <em>key</em>)</p></li><li><p><code>turtle.onkeyrelease</code>(<em>fun</em>, <em>key</em>)</p><ul><li><p>参数</p><p><strong>fun</strong> – 一个无参数的函数或 <code>None</code><strong>key</strong> – 一个字符串: 键 (例如 “a”) 或键标 (例如 “space”)</p></li></ul><p>绑定 <em>fun</em> 指定的函数到按键释放事件。如果 <em>fun</em> 值为 <code>None</code>，则移除事件绑定。注: 为了能够注册按键事件，TurtleScreen 必须得到焦点。(参见 method <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.listen" target="_blank" rel="noopener"><code>listen()</code></a> 方法。)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">... </span>    lt(<span class="number">60</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.onkey(f, <span class="string">"Up"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.listen()</span><br></pre></td></tr></table></figure></li><li><p><code>turtle.onkeypress</code>(<em>fun</em>, <em>key=None</em>)</p><ul><li><p>参数</p><p><strong>fun</strong> – 一个无参数的函数或 <code>None</code><strong>key</strong> – 一个字符串: 键 (例如 “a”) 或键标 (例如 “space”)</p></li></ul><p>绑定 <em>fun</em> 指定的函数到指定键的按下事件。如未指定键则绑定到任意键的按下事件。注: 为了能够注册按键事件，必须得到焦点。(参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.listen" target="_blank" rel="noopener"><code>listen()</code></a> 方法。)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    fd(<span class="number">50</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.onkey(f, <span class="string">"Up"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.listen()</span><br></pre></td></tr></table></figure></li><li><p><code>turtle.onclick</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p><p><code>turtle.onscreenclick</code>(<em>fun</em>, <em>btn=1</em>, <em>add=None</em>)</p><ul><li><p>参数</p><p><strong>fun</strong> – 一个函数，调用时将传入两个参数表示在画布上点击的坐标。<strong>btn</strong> – 鼠标按钮编号，默认值为 1 (鼠标左键)<strong>add</strong> – <code>True</code> 或 <code>False</code> – 如为 <code>True</code> 则将添加一个新绑定，否则将取代先前的绑定</p></li></ul><p>绑定 <em>fun</em> 指定的函数到鼠标点击屏幕事件。如果 <em>fun</em> 值为 <code>None</code>，则移除现有的绑定。</p><p>以下示例使用一个 TurtleScreen 实例 <code>screen</code> 和一个 Turtle 实例 turtle:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.onclick(turtle.goto) <span class="comment"># Subsequently clicking into the TurtleScreen will</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>                            <span class="comment"># make the turtle move to the clicked point.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.onclick(<span class="literal">None</span>)        <span class="comment"># remove event binding again</span></span><br></pre></td></tr></table></figure><blockquote><p> 此 TurtleScreen 方法作为全局函数时只有一个名字 <code>onscreenclick</code>。全局函数 <code>onclick</code> 所对应的是 Turtle 方法 <code>onclick</code>。</p></blockquote></li><li><p><code>turtle.ontimer</code>(<em>fun</em>, <em>t=0</em>)</p><ul><li><p>参数</p><p><strong>fun</strong> – 一个无参数的函数<strong>t</strong> – 一个数值 &gt;= 0</p></li></ul><p>安装一个计时器，在 <em>t</em> 毫秒后调用 <em>fun</em> 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>running = <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> running:</span><br><span class="line"><span class="meta">... </span>        fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">... </span>        lt(<span class="number">60</span>)</span><br><span class="line"><span class="meta">... </span>        screen.ontimer(f, <span class="number">250</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()   <span class="comment">### makes the turtle march around</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>running = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p><code>turtle.mainloop</code>()</p><p><code>turtle.done</code>()</p><p>开始事件循环 - 调用 Tkinter 的 mainloop 函数。必须作为一个海龟绘图程序的结束语句。如果一个脚本是在以 -n 模式 (无子进程) 启动的 IDLE 中运行时 <em>不可</em> 使用 - 用于实现海龟绘图的交互功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.mainloop()</span><br></pre></td></tr></table></figure></li></ul><h3 id="输入方法"><a href="#输入方法" class="headerlink" title="输入方法"></a>输入方法</h3><ul><li><p><code>turtle.textinput</code>(<em>title</em>, <em>prompt</em>)</p><p>参数<strong>title</strong> – 字符串<strong>prompt</strong> – 字符串弹出一个对话框窗口用来输入一个字符串。形参 title 为对话框窗口的标题，prompt 为一条文本，通常用来提示要输入什么信息。返回输入的字符串。如果对话框被取消则返回 <code>None</code>。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.textinput(<span class="string">"NIM"</span>, <span class="string">"Name of first player:"</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>turtle.numinput</code>(<em>title</em>, <em>prompt</em>, <em>default=None</em>, <em>minval=None</em>, <em>maxval=None</em>)</p><ul><li><p>参数</p><p><strong>title</strong> – 字符串<strong>prompt</strong> – 字符串<strong>default</strong> – 数值 (可选)<strong>minval</strong> – 数值 (可选)<strong>maxval</strong> – 数值 (可选)</p></li></ul><p>弹出一个对话框窗口用来输入一个数值。title 为对话框窗口的标题，prompt 为一条文本，通常用来描述要输入的数值信息。default: 默认值, minval: 可输入的最小值, maxval: 可输入的最大值。输入数值的必须在指定的 minval .. maxval 范围之内，否则将给出一条提示，对话框保持打开等待修改。返回输入的数值。如果对话框被取消则返回 <code>None</code>。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.numinput(<span class="string">"Poker"</span>, <span class="string">"Your stakes:"</span>, <span class="number">1000</span>, minval=<span class="number">10</span>, maxval=<span class="number">10000</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="设置与特殊方法"><a href="#设置与特殊方法" class="headerlink" title="设置与特殊方法"></a>设置与特殊方法</h3><p><code>turtle.mode</code>(<em>mode=None</em>)</p><ul><li><p>参数</p><p><strong>mode</strong> – 字符串 “standard”, “logo” 或 “world” 其中之一</p></li></ul><p>设置海龟模式 (“standard”, “logo” 或 “world”) 并执行重置。如未指定模式则返回当前的模式。</p><p>“standard” 模式与旧的 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 兼容。”logo” 模式与大部分 Logo 海龟绘图兼容。”world” 模式使用用户自定义的 “世界坐标系”。<strong>注意</strong>: 在此模式下，如果 <code>x/y</code> 单位比率不等于 1 则角度会显得扭曲。</p><table><thead><tr><th>模式</th><th>初始海龟朝向</th><th>正数角度</th></tr></thead><tbody><tr><td>“standard”</td><td>朝右 (东)</td><td>逆时针</td></tr><tr><td>“logo”</td><td>朝上 (北)</td><td>顺时针</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mode(<span class="string">"logo"</span>)   <span class="comment"># resets turtle heading to north</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mode()</span><br><span class="line"><span class="string">'logo'</span></span><br></pre></td></tr></table></figure><p><code>turtle.colormode</code>(<em>cmode=None</em>)</p><ul><li><p>参数</p><p><strong>cmode</strong> – 数值 1.0 或 255 其中之一</p></li></ul><p>返回颜色模式或将其设为 1.0 或 255。构成颜色三元组的 <em>r</em>, <em>g</em>, <em>b</em> 数值必须在 0..<em>cmode</em> 范围之内。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.colormode(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(<span class="number">240</span>, <span class="number">160</span>, <span class="number">80</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">     ...</span><br><span class="line">TurtleGraphicsError: bad color sequence: (<span class="number">240</span>, <span class="number">160</span>, <span class="number">80</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.colormode()</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.colormode(<span class="number">255</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.colormode()</span><br><span class="line"><span class="number">255</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(<span class="number">240</span>,<span class="number">160</span>,<span class="number">80</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.getcanvas</code>()</p><p>返回此 TurtleScreen 的 Canvas 对象。供了解 Tkinter 的 Canvas 对象内部机理的人士使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv = screen.getcanvas()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv</span><br><span class="line">&lt;turtle.ScrolledCanvas object ...&gt;</span><br></pre></td></tr></table></figure><p><code>turtle.getshapes</code>()</p><p>返回所有当前可用海龟形状的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.getshapes()</span><br><span class="line">[<span class="string">'arrow'</span>, <span class="string">'blank'</span>, <span class="string">'circle'</span>, ..., <span class="string">'turtle'</span>]</span><br></pre></td></tr></table></figure><p><code>turtle.register_shape</code>(<em>name</em>, <em>shape=None</em>)</p><p><code>turtle.addshape</code>(<em>name</em>, <em>shape=None</em>)</p><p>调用此函数有三种不同方式:</p><ol><li><p><em>name</em> 为一个 gif 文件的文件名， <em>shape</em> 为 <code>None</code>: 安装相应的图像形状。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.register_shape(<span class="string">"turtle.gif"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>当海龟转向时图像形状 <em>不会</em> 转动，因此无法显示海龟的朝向!</p></blockquote></li><li><p><em>name</em> 为指定的字符串，<em>shape</em> 为由坐标值对构成的元组: 安装相应的多边形形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.register_shape(<span class="string">"triangle"</span>, ((<span class="number">5</span>,<span class="number">-3</span>), (<span class="number">0</span>,<span class="number">5</span>), (<span class="number">-5</span>,<span class="number">-3</span>)))</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><em>name</em> 为指定的字符串， 为一个 (复合) <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Shape" target="_blank" rel="noopener"><code>Shape</code></a> 类对象: 安装相应的复合形状。</li></ol><p>将一个海龟形状加入 TurtleScreen 的形状列表。只有这样注册过的形状才能通过执行 <code>shape(shapename)</code> 命令来使用。</p><p><code>turtle.turtles</code>()</p><p>返回屏幕上的海龟列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> turtle <span class="keyword">in</span> screen.turtles():</span><br><span class="line"><span class="meta">... </span>    turtle.color(<span class="string">"red"</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.window_height</code>()</p><p>返回海龟窗口的高度。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.window_height()</span><br><span class="line"><span class="number">480</span></span><br></pre></td></tr></table></figure><p><code>turtle.window_width</code>()</p><p>返回海龟窗口的宽度。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.window_width()</span><br><span class="line"><span class="number">640</span></span><br></pre></td></tr></table></figure><h3 id="Screen-专有方法-而非继承自-TurtleScreen"><a href="#Screen-专有方法-而非继承自-TurtleScreen" class="headerlink" title="Screen 专有方法, 而非继承自 TurtleScreen"></a>Screen 专有方法, 而非继承自 TurtleScreen</h3><ul><li><p><code>turtle.bye</code>()</p><p>关闭海龟绘图窗口。</p></li><li><p><code>turtle.exitonclick</code>()</p><p>将 bye() 方法绑定到 Screen 上的鼠标点击事件。如果配置字典中 “using_IDLE” 的值为 <code>False</code> (默认值) 则同时进入主事件循环。注: 如果启动 IDLE 时使用了 <code>-n</code> 开关 (无子进程)，<code>turtle.cfg</code> 中此数值应设为 <code>True</code>。在此情况下 IDLE 本身的主事件循环同样会作用于客户脚本。</p></li><li><p><code>turtle.setup</code>(<em>width=_CFG[“width”], height=_CFG[“height”], startx=_CFG[“leftright”], starty=_CFG[“topbottom”]</em>)</p><p>设置主窗口的大小和位置。默认参数值保存在配置字典中，可通过 <code>turtle.cfg</code> 文件进行修改。</p><ul><li><strong>width</strong> – 如为一个整型数值，表示大小为多少像素，如为一个浮点数值，则表示屏幕的占比；默认为屏幕的 50%</li><li><strong>height</strong> – 如为一个整型数值，表示高度为多少像素，如为一个浮点数值，则表示屏幕的占比；默认为屏幕的 75%</li><li><strong>startx</strong> – 如为正值，表示初始位置距离屏幕左边缘多少像素，负值表示距离右边缘，<code>None</code> 表示窗口水平居中</li><li><strong>starty</strong> – 如为正值，表示初始位置距离屏幕上边缘多少像素，负值表示距离下边缘，<code>None</code> 表示窗口垂直居中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.setup (width=<span class="number">200</span>, height=<span class="number">200</span>, startx=<span class="number">0</span>, starty=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>             <span class="comment"># sets window to 200x200 pixels, in upper left of screen</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.setup(width=<span class="number">.75</span>, height=<span class="number">0.5</span>, startx=<span class="literal">None</span>, starty=<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>             <span class="comment"># sets window to 75% of screen by 50% of screen and centers</span></span><br></pre></td></tr></table></figure></li></ul><p><code>turtle.title</code>(<em>titlestring</em>)</p><ul><li><p>参数</p><p><strong>titlestring</strong> – 一个字符串，显示为海龟绘图窗口的标题栏文本</p></li></ul><p>设置海龟窗口标题为 <em>titlestring</em> 指定的文本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>screen.title(<span class="string">"Welcome to the turtle zoo!"</span>)</span><br></pre></td></tr></table></figure><h2 id="公共类"><a href="#公共类" class="headerlink" title="公共类"></a>公共类</h2><ul><li><p><em>class</em> <code>turtle.RawTurtle</code>(<em>canvas</em>)</p></li><li><p><em>class</em> <code>turtle.RawPen</code>(<em>canvas</em>)</p><p>参数<strong>canvas</strong> – 一个 <code>tkinter.Canvas</code> , <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ScrolledCanvas" target="_blank" rel="noopener"><code>ScrolledCanvas</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 类对象创建一个海龟。海龟对象具有 “Turtle/RawTurtle 方法” 一节所述的全部方法。</p></li><li><p><em>class</em> <code>turtle.Turtle</code></p><p>RawTurtle 的子类，具有相同的接口，但其绘图场所为默认的 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Screen" target="_blank" rel="noopener"><code>Screen</code></a> 类对象，在首次使用时自动创建。</p></li><li><p><em>class</em> <code>turtle.TurtleScreen</code>(<em>cv</em>)</p><p>参数<strong>cv</strong> – 一个 <code>tkinter.Canvas</code> 类对象提供面向屏幕的方法例如 <code>setbg()</code> 等。说明见上文。</p></li><li><p><em>class</em> <code>turtle.Screen</code></p><p>TurtleScreen 的子类，<a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#screenspecific" target="_blank" rel="noopener">增加了四个方法</a>.</p></li><li><p><em>class</em> <code>turtle.ScrolledCanvas</code>(<em>master</em>)</p><p>参数<strong>master</strong> – 可容纳 ScrolledCanvas 的 Tkinter 部件，即添加了滚动条的 Tkinter-canvas由 Screen 类使用，使其能够自动提供一个 ScrolledCanvas 作为海龟的绘图场所。</p></li><li><p><em>class</em> <code>turtle.Shape</code>(<em>type_</em>, <em>data</em>)</p><p>参数<strong>type_</strong> – 字符串 “polygon”, “image”, “compound” 其中之一实现形状的数据结构。<code>(type_, data)</code> 必须遵循以下定义:</p><p>| <em>type_</em>    | <em>data</em>                                                       |<br>| ———- | ———————————————————— |<br>| “polygon”  | 一个多边形元组，即由坐标值对构成的元组                       |<br>| “image”    | 一个图片 (此形式仅限内部使用!)                               |<br>| “compound” | <code>None</code> (复合形状必须使用 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Shape.addcomponent" target="_blank" rel="noopener"><code>addcomponent()</code></a> 方法来构建) |</p></li><li><p><code>addcomponent</code>(<em>poly</em>, <em>fill</em>, <em>outline=None</em>)</p><ul><li><p><strong>poly</strong> – 一个多边形，即由数值对构成的元组</p></li><li><p><strong>fill</strong> – 一种颜色，将用来填充 <em>poly</em> 指定的多边形</p></li><li><p><strong>outline</strong> – 一种颜色，用于多边形的轮廓 (如有指定)</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>poly = ((<span class="number">0</span>,<span class="number">0</span>),(<span class="number">10</span>,<span class="number">-5</span>),(<span class="number">0</span>,<span class="number">10</span>),(<span class="number">-10</span>,<span class="number">-5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Shape(<span class="string">"compound"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.addcomponent(poly, <span class="string">"red"</span>, <span class="string">"blue"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># ... add more components and then use register_shape()</span></span><br></pre></td></tr></table></figure><p>参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#compoundshapes" target="_blank" rel="noopener">复合形状</a>。<em>**</em></p></li></ul></li><li><p><em>class</em> <code>turtle.Vec2D</code>(<em>x</em>, <em>y</em>)</p><p>一个二维矢量类，用来作为实现海龟绘图的辅助类。也可能在海龟绘图程序中使用。派生自元组，因此矢量也属于元组!</p><p>提供的运算 (<em>a</em>, <em>b</em> 为矢量, <em>k</em> 为数值):</p><ul><li><code>a + b</code> 矢量加法</li><li><code>a - b</code> 矢量减法</li><li><code>a * b</code> 内积</li><li><code>k * a</code> 和 <code>a * k</code> 与标量相乘</li><li><code>abs(a)</code> a 的绝对值</li><li><code>a.rotate(angle)</code> 旋转</li></ul></li></ul><h2 id="帮助与配置"><a href="#帮助与配置" class="headerlink" title="帮助与配置"></a>帮助与配置</h2><h3 id="如何使用帮助"><a href="#如何使用帮助" class="headerlink" title="如何使用帮助"></a>如何使用帮助</h3><p>Screen 和 Turtle 类的公用方法以文档字符串提供了详细的文档。因此可以利用 Python 帮助工具获取这些在线帮助信息:</p><ul><li><p>当使用 IDLE 时，输入函数/方法调用将弹出工具提示显示其签名和文档字符串的头几行。</p></li><li><p>对文法或函数调用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#help" target="_blank" rel="noopener"><code>help()</code></a> 将显示其文档字符串:</p><p>>&gt;&gt;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(Screen.bgcolor)</span><br><span class="line">Help on method bgcolor <span class="keyword">in</span> module turtle:</span><br><span class="line"></span><br><span class="line">bgcolor(self, *args) unbound turtle.Screen method</span><br><span class="line">    Set <span class="keyword">or</span> <span class="keyword">return</span> backgroundcolor of the TurtleScreen.</span><br><span class="line"></span><br><span class="line">    Arguments (<span class="keyword">if</span> given): a color string <span class="keyword">or</span> three numbers</span><br><span class="line">    <span class="keyword">in</span> the range <span class="number">0.</span>.colormode <span class="keyword">or</span> a <span class="number">3</span>-tuple of such numbers.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &gt;&gt;&gt; screen.bgcolor(<span class="string">"orange"</span>)</span><br><span class="line">      &gt;&gt;&gt; screen.bgcolor()</span><br><span class="line">      <span class="string">"orange"</span></span><br><span class="line">      &gt;&gt;&gt; screen.bgcolor(<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">0.5</span>)</span><br><span class="line">      &gt;&gt;&gt; screen.bgcolor()</span><br><span class="line">      <span class="string">"#800080"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(Turtle.penup)</span><br><span class="line">Help on method penup <span class="keyword">in</span> module turtle:</span><br><span class="line"></span><br><span class="line">penup(self) unbound turtle.Turtle method</span><br><span class="line">    Pull the pen up -- no drawing when moving.</span><br><span class="line"></span><br><span class="line">    Aliases: penup | pu | up</span><br><span class="line"></span><br><span class="line">    No argument</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; turtle.penup()</span><br></pre></td></tr></table></figure></li></ul><p>方法对应函数的文档字符串的形式会有一些修改:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(bgcolor)</span><br><span class="line">Help on function bgcolor <span class="keyword">in</span> module turtle:</span><br><span class="line"></span><br><span class="line">bgcolor(*args)</span><br><span class="line">    Set <span class="keyword">or</span> <span class="keyword">return</span> backgroundcolor of the TurtleScreen.</span><br><span class="line"></span><br><span class="line">    Arguments (<span class="keyword">if</span> given): a color string <span class="keyword">or</span> three numbers</span><br><span class="line">    <span class="keyword">in</span> the range <span class="number">0.</span>.colormode <span class="keyword">or</span> a <span class="number">3</span>-tuple of such numbers.</span><br><span class="line"></span><br><span class="line">    Example::</span><br><span class="line"></span><br><span class="line">      &gt;&gt;&gt; bgcolor(<span class="string">"orange"</span>)</span><br><span class="line">      &gt;&gt;&gt; bgcolor()</span><br><span class="line">      <span class="string">"orange"</span></span><br><span class="line">      &gt;&gt;&gt; bgcolor(<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">0.5</span>)</span><br><span class="line">      &gt;&gt;&gt; bgcolor()</span><br><span class="line">      <span class="string">"#800080"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(penup)</span><br><span class="line">Help on function penup <span class="keyword">in</span> module turtle:</span><br><span class="line"></span><br><span class="line">penup()</span><br><span class="line">    Pull the pen up -- no drawing when moving.</span><br><span class="line"></span><br><span class="line">    Aliases: penup | pu | up</span><br><span class="line"></span><br><span class="line">    No argument</span><br><span class="line"></span><br><span class="line">    Example:</span><br><span class="line">    &gt;&gt;&gt; penup()</span><br></pre></td></tr></table></figure><p>这些修改版文档字符串是在导入时与方法对应函数的定义一起自动生成的。</p><h3 id="文档字符串翻译为不同的语言"><a href="#文档字符串翻译为不同的语言" class="headerlink" title="文档字符串翻译为不同的语言"></a>文档字符串翻译为不同的语言</h3><p>可使用工具创建一个字典，键为方法名，值为 Screen 和 Turtle 类公共方法的文档字符串。</p><ul><li><p><code>turtle.write_docstringdict</code>(<em>filename=”turtle_docstringdict”</em>)</p><p>参数<strong>filename</strong> – 一个字符串，表示文件名创建文档字符串字典并将其写入 filename 指定的 Python 脚本文件。此函数必须显示地调用 (海龟绘图类并不使用此函数)。文档字符串字典将被写入到 Python 脚本文件 <code>*filename*.py</code>。该文件可作为模板用来将文档字符串翻译为不同语言。</p></li></ul><p>如果你 (或你的学生) 想使用本国语言版本的 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 在线帮助，你必须翻译文档字符串并保存结果文件，例如 <code>turtle_docstringdict_german.py</code>.</p><p>如果你在 <code>turtle.cfg</code> 文件中加入了相应的条目，此字典将在导入模块时被读取并替代原有的英文版文档字符串。</p><p>在撰写本文档时已经有了德语和意大利语版的文档字符串字典。(更多需求请联系 <a href="mailto:glingl%40aon.at" target="_blank" rel="noopener">glingl@aon.at</a>)</p><h3 id="如何配置-Screen-和-Turtle"><a href="#如何配置-Screen-和-Turtle" class="headerlink" title="如何配置 Screen 和 Turtle"></a>如何配置 Screen 和 Turtle</h3><p>内置的默认配置是模仿旧 turtle 模块的外观和行为，以便尽可能地与其保持兼容。</p><p>如果你想使用不同的配置，以便更好地反映此模块的特性或是更适合你的需求，例如在课堂中使用，你可以准备一个配置文件 <code>turtle.cfg</code>，该文件将在导入模块时被读取并根据其中的设定修改模块配置。</p><p>内置的配置对应以下的 turtle.cfg:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">width = <span class="number">0.5</span></span><br><span class="line">height = <span class="number">0.75</span></span><br><span class="line">leftright = <span class="literal">None</span></span><br><span class="line">topbottom = <span class="literal">None</span></span><br><span class="line">canvwidth = <span class="number">400</span></span><br><span class="line">canvheight = <span class="number">300</span></span><br><span class="line">mode = standard</span><br><span class="line">colormode = <span class="number">1.0</span></span><br><span class="line">delay = <span class="number">10</span></span><br><span class="line">undobuffersize = <span class="number">1000</span></span><br><span class="line">shape = classic</span><br><span class="line">pencolor = black</span><br><span class="line">fillcolor = black</span><br><span class="line">resizemode = noresize</span><br><span class="line">visible = <span class="literal">True</span></span><br><span class="line">language = english</span><br><span class="line">exampleturtle = turtle</span><br><span class="line">examplescreen = screen</span><br><span class="line">title = Python Turtle Graphics</span><br><span class="line">using_IDLE = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>选定条目的简短说明:</p><ul><li>开头的四行对应 <code>Screen.setup()</code> 方法的参数。</li><li>第 5 和 6 行对应 <code>Screen.screensize()</code> 方法的参数。</li><li><em>shape</em> 可以是任何内置形状，即: arrow, turtle 等。更多信息可用 <code>help(shape)</code> 查看。</li><li>如果你想使用无填充色 (即令海龟变透明)，你必须写 <code>fillcolor = &quot;&quot;</code> (但 cfg 文件中所有非空字符串都不可加引号)。</li><li>如果你想令海龟反映其状态，你必须使用 <code>resizemode = auto</code>。</li><li>如果你设置语言例如 <code>language = italian</code> 则文档字符串字典 <code>turtle_docstringdict_italian.py</code> 将在导入模块时被加载 (如果导入路径即 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 的目录中存在此文件。</li><li><em>exampleturtle</em> 和 <em>examplescreen</em> 条目定义了相应对象在文档字符串中显示的名称。方法文档字符串转换为函数文档字符串时将从文档字符串中删去这些名称。</li><li><em>using_IDLE</em>: 如果你经常使用 IDLE 并启用其 -n 开关 (“无子进程”) 则应将此项设为 <code>True</code>，这将阻止 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.exitonclick" target="_blank" rel="noopener"><code>exitonclick()</code></a> 进入主事件循环。</li></ul><p><code>turtle.cfg</code> 文件可以保存于 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 所在目录，当前工作目录也可以有一个同名文件。后者会重载覆盖前者的设置。</p><p><code>Lib/turtledemo</code> 目录中也有一个 <code>turtle.cfg</code> 文件。你可以将其作为示例进行研究，并在运行演示时查看其作用效果 (但最好不要在演示查看器中运行)。</p><h2 id="turtledemo-—-演示脚本集"><a href="#turtledemo-—-演示脚本集" class="headerlink" title="turtledemo — 演示脚本集"></a><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtledemo" target="_blank" rel="noopener"><code>turtledemo</code></a> — 演示脚本集</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtledemo" target="_blank" rel="noopener"><code>turtledemo</code></a> 包汇集了一组演示脚本。这些脚本可以通过以下命令打开所提供的演示查看器运行和查看:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m turtledemo</span><br></pre></td></tr></table></figure><p>此外，你也可以单独运行其中的演示脚本。例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m turtledemo.bytedesign</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtledemo" target="_blank" rel="noopener"><code>turtledemo</code></a> 包目录中的内容:</p><ul><li>一个演示查看器 <code>__main__.py</code>，可用来查看脚本的源码并即时运行。</li><li>多个脚本文件，演示 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 模块的不同特性。所有示例可通过 Examples 菜单打开。也可以单独运行每个脚本。</li><li>一个 <code>turtle.cfg</code> 文件，作为说明如何编写并使用模块配置文件的示例模板。</li></ul><p>演示脚本清单如下:</p><table><thead><tr><th>名称</th><th>描述</th><th>相关特性</th></tr></thead><tbody><tr><td>bytedesign</td><td>复杂的传统海龟绘图模式</td><td><code>tracer()</code>, delay, <code>update()</code></td></tr><tr><td>chaos</td><td>绘制 Verhulst 动态模型，演示通过计算机的运算可能会生成令人惊叹的结果</td><td>世界坐标系</td></tr><tr><td>clock</td><td>绘制模拟时钟显示本机的当前时间</td><td>海龟作为表针, ontimer</td></tr><tr><td>colormixer</td><td>试验 r, g, b 颜色模式</td><td><code>ondrag()</code> 当鼠标拖动</td></tr><tr><td>forest</td><td>绘制 3 棵广度优先树</td><td>随机化</td></tr><tr><td>fractalcurves</td><td>绘制 Hilbert &amp; Koch 曲线</td><td>递归</td></tr><tr><td>lindenmayer</td><td>文化数学 (印度装饰艺术)</td><td>L-系统</td></tr><tr><td>minimal_hanoi</td><td>汉诺塔</td><td>矩形海龟作为汉诺盘 (shape, shapesize)</td></tr><tr><td>nim</td><td>玩经典的“尼姆”游戏，开始时有三堆小棒，与电脑对战。</td><td>海龟作为小棒，事件驱动 (鼠标, 键盘)</td></tr><tr><td>paint</td><td>超极简主义绘画程序</td><td><code>onclick()</code> 当鼠标点击</td></tr><tr><td>peace</td><td>初级技巧</td><td>海龟: 外观与动画</td></tr><tr><td>penrose</td><td>非周期性地使用风筝和飞镖形状铺满平面</td><td><code>stamp()</code> 印章</td></tr><tr><td>planet_and_moon</td><td>模拟引力系统</td><td>复合开关, <code>Vec2D</code> 类</td></tr><tr><td>round_dance</td><td>两两相对并不断旋转舞蹈的海龟</td><td>复合形状, clone shapesize, tilt, get_shapepoly, update</td></tr><tr><td>sorting_animate</td><td>动态演示不同的排序方法</td><td>简单对齐, 随机化</td></tr><tr><td>tree</td><td>一棵 (图形化的) 广度优先树 (使用生成器)</td><td><code>clone()</code> 克隆</td></tr><tr><td>two_canvases</td><td>简单设计</td><td>两块画布上的海龟</td></tr><tr><td>wikipedia</td><td>一个来自介绍海龟绘图的维基百科文章的图案</td><td><code>clone()</code>, <code>undo()</code></td></tr><tr><td>yinyang</td><td>另一个初级示例</td><td><code>circle()</code> 画圆</td></tr></tbody></table><p>祝你玩得开心！</p><h2 id="Python-2-6-之后的变化"><a href="#Python-2-6-之后的变化" class="headerlink" title="Python 2.6 之后的变化"></a>Python 2.6 之后的变化</h2><ul><li><code>Turtle.tracer()</code>, <code>Turtle.window_width()</code> 和 <code>Turtle.window_height()</code> 方法已被去除。具有这些名称和功能的方法现在只限于 <code>Screen</code> 类的方法。但其对应的函数仍然可用。(实际上在 Python 2.6 中这些方法就已经只是从对应的 <code>TurtleScreen</code>/<code>Screen</code> 类的方法复制而来。)</li><li><code>Turtle.fill()</code> 方法已被去除。<code>begin_fill()</code> 和 <code>end_fill()</code> 的行为则有细微改变: 现在每个填充过程必须以一个 <code>end_fill()</code> 调用来结束。</li><li>新增了一个 <code>Turtle.filling()</code> 方法。该方法返回一个布尔值: 如果填充过程正在进行为 <code>True</code>，否则为 <code>False</code>。此行为相当于 Python 2.6 中不带参数的 <code>fill()</code> 调用。</li></ul><h2 id="Python-3-0-之后的变化"><a href="#Python-3-0-之后的变化" class="headerlink" title="Python 3.0 之后的变化"></a>Python 3.0 之后的变化</h2><ul><li>新增了 <code>Turtle.shearfactor()</code>, <code>Turtle.shapetransform()</code> 和 <code>Turtle.get_shapepoly()</code> 方法。这样就可以使用所有标准线性变换来调整海龟形状。<code>Turtle.tiltangle()</code> 的功能已被加强: 现在可被用来获取或设置倾角。<code>Turtle.settiltangle()</code> 已弃用。</li><li>新增了 <code>Screen.onkeypress()</code> 方法作为对 <code>Screen.onkey()</code> 的补充，实际就是将行为绑定到 keyrelease 事件。后者相应增加了一个别名: <code>Screen.onkeyrelease()</code>。</li><li>新增了 <code>Screen.mainloop()</code> 方法。这样当仅需使用 Screen 和 Turtle 对象时不需要再额外导入 <code>mainloop()</code>。</li><li>新增了两个方法 <code>Screen.textinput()</code> 和 <code>Screen.numinput()</code>。用来弹出对话框接受输入并分别返回字符串和数值。</li><li>两个新的示例脚本 <code>tdemo_nim.py</code> 和 <code>tdemo_round_dance.py</code> 被加入到 <code>Lib/turtledemo</code> 目录中。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-turtle-海龟制图-续&quot;&gt;&lt;a href=&quot;#python-标准库-turtle-海龟制图-续&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 turtle 海龟制图(续)&quot;&gt;&lt;/a&gt;python 标准库 turtle 海龟制图(续)&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/2020200228english.png?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="turtle" scheme="https://pinghailinfeng.gitee.io/tags/turtle/"/>
    
  </entry>
  
  <entry>
    <title>python standard library turtle</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/27/python-standard-library-turtle/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/27/python-standard-library-turtle/</id>
    <published>2020-02-27T11:55:25.000Z</published>
    <updated>2020-02-28T11:30:50.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-turtle-海龟制图"><a href="#python-标准库-turtle-海龟制图" class="headerlink" title="python 标准库 turtle 海龟制图"></a>python 标准库 turtle 海龟制图</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200227turtle.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>turtle n  海龟</p><p>vi. 捕海龟，捕鳖； （船等）翻没，倾覆；</p></blockquote><p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/turtle.py" target="_blank" rel="noopener">Lib/turtle.py</a></p><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>海龟绘图很适合用来引导孩子学习编程。 最初来自于 Wally Feurzeig, Seymour Papert 和 Cynthia Solomon 于 1967 年所创造的 Logo 编程语言。</p><p>请想象绘图区有一只机器海龟，起始位置在 x-y 平面的 (0, 0) 点。先执行 <code>import turtle</code>，再执行 <code>turtle.forward(15)</code>，它将(在屏幕上)朝所面对的 x 轴正方向前进 15 像素，随着它的移动画出一条线段。再执行 <code>turtle.right(25)</code>，它将原地右转 25 度。</p><p>通过组合使用此类命令，可以轻松地绘制出精美的形状和图案。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 模块是基于 Python 标准发行版 2.5 以来的同名模块重新编写并进行了功能扩展。</p><p>新模块尽量保持了原模块的特点，并且(几乎)100%与其兼容。这就意味着初学编程者能够以交互方式使用模块的所有命令、类和方法——运行 IDLE 时注意加 <code>-n</code> 参数。</p><p>turtle 模块提供面向对象和面向过程两种形式的海龟绘图基本组件。由于它使用 <a href="https://docs.python.org/zh-cn/3.8/library/tkinter.html#module-tkinter" target="_blank" rel="noopener"><code>tkinter</code></a> 实现基本图形界面，因此需要安装了 Tk 支持的 Python 版本。</p><p>面向对象的接口主要使用“2+2”个类：</p><ol><li><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 类定义图形窗口作为绘图海龟的运动场。它的构造器需要一个 <code>tkinter.Canvas</code> 或 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ScrolledCanvas" target="_blank" rel="noopener"><code>ScrolledCanvas</code></a> 作为参数。应在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 作为某个程序的一部分的时候使用。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Screen" target="_blank" rel="noopener"><code>Screen()</code></a> 函数返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 子类的单例对象。此函数应在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 作为独立绘图工具时使用。作为一个单例对象，其所属的类是不可被继承的。</p><p>TurtleScreen/Screen 的所有方法还存在对应的函数，即作为面向过程的接口组成部分。</p></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.RawTurtle" target="_blank" rel="noopener"><code>RawTurtle</code></a> (别名: <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.RawPen" target="_blank" rel="noopener"><code>RawPen</code></a>) 类定义海龟对象在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.TurtleScreen" target="_blank" rel="noopener"><code>TurtleScreen</code></a> 上绘图。它的构造器需要一个 Canvas, ScrolledCanvas 或 TurtleScreen 作为参数，以指定 RawTurtle 对象在哪里绘图。</p><p>从 RawTurtle 派生出子类 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Turtle" target="_blank" rel="noopener"><code>Turtle</code></a> (别名: <code>Pen</code>)，该类对象在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Screen" target="_blank" rel="noopener"><code>Screen</code></a> 实例上绘图，如果实例不存在则会自动创建。</p><p>RawTurtle/Turtle 的所有方法也存在对应的函数，即作为面向过程的接口组成部分。</p></li></ol><p>过程式接口提供与 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Screen" target="_blank" rel="noopener"><code>Screen</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Turtle" target="_blank" rel="noopener"><code>Turtle</code></a> 类的方法相对应的函数。函数名与对应的方法名相同。当 Screen 类的方法对应函数被调用时会自动创建一个 Screen 对象。当 Turtle 类的方法对应函数被调用时会自动创建一个 (匿名的) Turtle 对象。</p><p>如果屏幕上需要有多个海龟，就必须使用面向对象的接口。</p><h2 id="可用的-Turtle-和-Screen-方法概览"><a href="#可用的-Turtle-和-Screen-方法概览" class="headerlink" title="可用的 Turtle 和 Screen 方法概览"></a>可用的 Turtle 和 Screen 方法概览</h2><h3 id="Turtle-方法"><a href="#Turtle-方法" class="headerlink" title="Turtle 方法"></a>Turtle 方法</h3><p>海龟动作</p><ul><li><p>移动和绘制</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.forward" target="_blank" rel="noopener"><code>forward()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.fd" target="_blank" rel="noopener"><code>fd()</code></a> 前进</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.backward" target="_blank" rel="noopener"><code>backward()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.bk" target="_blank" rel="noopener"><code>bk()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.back" target="_blank" rel="noopener"><code>back()</code></a> 后退</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.right" target="_blank" rel="noopener"><code>right()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.rt" target="_blank" rel="noopener"><code>rt()</code></a> 右转</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.left" target="_blank" rel="noopener"><code>left()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.lt" target="_blank" rel="noopener"><code>lt()</code></a> 左转</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.goto" target="_blank" rel="noopener"><code>goto()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setpos" target="_blank" rel="noopener"><code>setpos()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setposition" target="_blank" rel="noopener"><code>setposition()</code></a> 前往/定位</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setx" target="_blank" rel="noopener"><code>setx()</code></a> 设置x坐标</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.sety" target="_blank" rel="noopener"><code>sety()</code></a> 设置y坐标</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setheading" target="_blank" rel="noopener"><code>setheading()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.seth" target="_blank" rel="noopener"><code>seth()</code></a> 设置朝向</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.home" target="_blank" rel="noopener"><code>home()</code></a> 返回原点</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.circle" target="_blank" rel="noopener"><code>circle()</code></a> 画圆</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.dot" target="_blank" rel="noopener"><code>dot()</code></a> 画点</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.stamp" target="_blank" rel="noopener"><code>stamp()</code></a> 印章</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clearstamp" target="_blank" rel="noopener"><code>clearstamp()</code></a> 清除印章</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clearstamps" target="_blank" rel="noopener"><code>clearstamps()</code></a> 清除多个印章</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.undo" target="_blank" rel="noopener"><code>undo()</code></a> 撤消</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.speed" target="_blank" rel="noopener"><code>speed()</code></a> 速度</p></li><li><p>获取海龟的状态</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.position" target="_blank" rel="noopener"><code>position()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pos" target="_blank" rel="noopener"><code>pos()</code></a> 位置</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.towards" target="_blank" rel="noopener"><code>towards()</code></a> 目标方向</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.xcor" target="_blank" rel="noopener"><code>xcor()</code></a> x坐标</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ycor" target="_blank" rel="noopener"><code>ycor()</code></a> y坐标</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.heading" target="_blank" rel="noopener"><code>heading()</code></a> 朝向</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.distance" target="_blank" rel="noopener"><code>distance()</code></a> 距离</p></li><li><p>设置与度量单位</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.degrees" target="_blank" rel="noopener"><code>degrees()</code></a> 角度</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.radians" target="_blank" rel="noopener"><code>radians()</code></a> 弧度</p></li></ul><p>画笔控制</p><ul><li><p>绘图状态</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pendown" target="_blank" rel="noopener"><code>pendown()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pd" target="_blank" rel="noopener"><code>pd()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.down" target="_blank" rel="noopener"><code>down()</code></a> 画笔落下</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.penup" target="_blank" rel="noopener"><code>penup()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pu" target="_blank" rel="noopener"><code>pu()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.up" target="_blank" rel="noopener"><code>up()</code></a> 画笔抬起</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pensize" target="_blank" rel="noopener"><code>pensize()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.width" target="_blank" rel="noopener"><code>width()</code></a> 画笔粗细</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pen" target="_blank" rel="noopener"><code>pen()</code></a> 画笔</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.isdown" target="_blank" rel="noopener"><code>isdown()</code></a> 画笔是否落下</p></li><li><p>颜色控制</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.color" target="_blank" rel="noopener"><code>color()</code></a> 颜色</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pencolor" target="_blank" rel="noopener"><code>pencolor()</code></a> 画笔颜色</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.fillcolor" target="_blank" rel="noopener"><code>fillcolor()</code></a> 填充颜色</p></li><li><p>填充</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.filling" target="_blank" rel="noopener"><code>filling()</code></a> 是否填充</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.begin_fill" target="_blank" rel="noopener"><code>begin_fill()</code></a> 开始填充</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.end_fill" target="_blank" rel="noopener"><code>end_fill()</code></a> 结束填充</p></li><li><p>更多绘图控制</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.reset" target="_blank" rel="noopener"><code>reset()</code></a> 重置</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clear" target="_blank" rel="noopener"><code>clear()</code></a> 清空</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.write" target="_blank" rel="noopener"><code>write()</code></a> 书写</p></li></ul><p>海龟状态</p><ul><li><p>可见性</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.showturtle" target="_blank" rel="noopener"><code>showturtle()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.st" target="_blank" rel="noopener"><code>st()</code></a> 显示海龟</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.hideturtle" target="_blank" rel="noopener"><code>hideturtle()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ht" target="_blank" rel="noopener"><code>ht()</code></a> 隐藏海龟</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.isvisible" target="_blank" rel="noopener"><code>isvisible()</code></a> 是否可见</p></li><li><p>外观</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shape" target="_blank" rel="noopener"><code>shape()</code></a> 形状</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.resizemode" target="_blank" rel="noopener"><code>resizemode()</code></a> 大小调整模式</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shapesize" target="_blank" rel="noopener"><code>shapesize()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.turtlesize" target="_blank" rel="noopener"><code>turtlesize()</code></a> 形状大小</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shearfactor" target="_blank" rel="noopener"><code>shearfactor()</code></a> 剪切因子</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.settiltangle" target="_blank" rel="noopener"><code>settiltangle()</code></a> 设置倾角</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.tiltangle" target="_blank" rel="noopener"><code>tiltangle()</code></a> 倾角</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.tilt" target="_blank" rel="noopener"><code>tilt()</code></a> 倾斜</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shapetransform" target="_blank" rel="noopener"><code>shapetransform()</code></a> 变形</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.get_shapepoly" target="_blank" rel="noopener"><code>get_shapepoly()</code></a> 获取形状多边形</p></li></ul><p>使用事件</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onclick" target="_blank" rel="noopener"><code>onclick()</code></a> 当鼠标点击</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onrelease" target="_blank" rel="noopener"><code>onrelease()</code></a> 当鼠标释放</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ondrag" target="_blank" rel="noopener"><code>ondrag()</code></a> 当鼠标拖动</p><p>特殊海龟方法</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.begin_poly" target="_blank" rel="noopener"><code>begin_poly()</code></a> 开始记录多边形</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.end_poly" target="_blank" rel="noopener"><code>end_poly()</code></a> 结束记录多边形</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.get_poly" target="_blank" rel="noopener"><code>get_poly()</code></a> 获取多边形</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clone" target="_blank" rel="noopener"><code>clone()</code></a> 克隆</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getturtle" target="_blank" rel="noopener"><code>getturtle()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getpen" target="_blank" rel="noopener"><code>getpen()</code></a> 获取海龟画笔</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getscreen" target="_blank" rel="noopener"><code>getscreen()</code></a> 获取屏幕</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setundobuffer" target="_blank" rel="noopener"><code>setundobuffer()</code></a> 设置撤消缓冲区</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.undobufferentries" target="_blank" rel="noopener"><code>undobufferentries()</code></a> 撤消缓冲区条目数</p><h3 id="TurtleScreen-Screen-方法"><a href="#TurtleScreen-Screen-方法" class="headerlink" title="TurtleScreen/Screen 方法"></a>TurtleScreen/Screen 方法</h3><ul><li><p>窗口控制</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.bgcolor" target="_blank" rel="noopener"><code>bgcolor()</code></a> 背景颜色</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.bgpic" target="_blank" rel="noopener"><code>bgpic()</code></a> 背景图片</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clear" target="_blank" rel="noopener"><code>clear()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.clearscreen" target="_blank" rel="noopener"><code>clearscreen()</code></a> 清屏</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.reset" target="_blank" rel="noopener"><code>reset()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.resetscreen" target="_blank" rel="noopener"><code>resetscreen()</code></a> 重置</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.screensize" target="_blank" rel="noopener"><code>screensize()</code></a> 屏幕大小</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setworldcoordinates" target="_blank" rel="noopener"><code>setworldcoordinates()</code></a> 设置世界坐标系</p></li><li><p>动画控制</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.delay" target="_blank" rel="noopener"><code>delay()</code></a> 延迟</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.tracer" target="_blank" rel="noopener"><code>tracer()</code></a> 追踪</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.update" target="_blank" rel="noopener"><code>update()</code></a> 更新</p><p>使用屏幕事件</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.listen" target="_blank" rel="noopener"><code>listen()</code></a> 监听</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onkey" target="_blank" rel="noopener"><code>onkey()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onkeyrelease" target="_blank" rel="noopener"><code>onkeyrelease()</code></a> 当键盘按下并释放</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onkeypress" target="_blank" rel="noopener"><code>onkeypress()</code></a> 当键盘按下</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onclick" target="_blank" rel="noopener"><code>onclick()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.onscreenclick" target="_blank" rel="noopener"><code>onscreenclick()</code></a> 当点击屏幕</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.ontimer" target="_blank" rel="noopener"><code>ontimer()</code></a> 当达到定时</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mainloop" target="_blank" rel="noopener"><code>mainloop()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.done" target="_blank" rel="noopener"><code>done()</code></a> 主循环</p></li><li><p>设置与特殊方法</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a> 模式</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.colormode" target="_blank" rel="noopener"><code>colormode()</code></a> 颜色模式</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getcanvas" target="_blank" rel="noopener"><code>getcanvas()</code></a> 获取画布</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.getshapes" target="_blank" rel="noopener"><code>getshapes()</code></a> 获取形状</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.register_shape" target="_blank" rel="noopener"><code>register_shape()</code></a> | <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.addshape" target="_blank" rel="noopener"><code>addshape()</code></a> 添加形状</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.turtles" target="_blank" rel="noopener"><code>turtles()</code></a> 所有海龟</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.window_height" target="_blank" rel="noopener"><code>window_height()</code></a> 窗口高度</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.window_width" target="_blank" rel="noopener"><code>window_width()</code></a> 窗口宽度</p></li><li><p>输入方法</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.textinput" target="_blank" rel="noopener"><code>textinput()</code></a> 文本输入</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.numinput" target="_blank" rel="noopener"><code>numinput()</code></a> 数字输入</p></li><li><p>Screen 专有方法</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.bye" target="_blank" rel="noopener"><code>bye()</code></a> 退出</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.exitonclick" target="_blank" rel="noopener"><code>exitonclick()</code></a> 当点击时退出</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.setup" target="_blank" rel="noopener"><code>setup()</code></a> 设置</p><p><a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.title" target="_blank" rel="noopener"><code>title()</code></a> 标题</p></li></ul><h2 id="RawTurtle-Turtle-方法和对应函数"><a href="#RawTurtle-Turtle-方法和对应函数" class="headerlink" title="RawTurtle/Turtle 方法和对应函数"></a>RawTurtle/Turtle 方法和对应函数</h2><p>本节中的大部分示例都使用 Turtle 类的一个实例，命名为 <code>turtle</code>。</p><h3 id="海龟动作"><a href="#海龟动作" class="headerlink" title="海龟动作"></a>海龟动作</h3><ul><li><p><code>turtle.forward</code>(<em>distance</em>)</p></li><li><p><code>turtle.fd</code>(<em>distance</em>)</p><p>参数<strong>distance</strong> – 一个数值 (整型或浮点型)海龟前进 <em>distance</em> 指定的距离，方向为海龟的朝向。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.forward(<span class="number">25</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">25.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.forward(<span class="number">-75</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">-50.00</span>,<span class="number">0.00</span>)</span><br></pre></td></tr></table></figure></li></ul><p><code>turtle.back</code>(<em>distance</em>)</p><p><code>turtle.bk</code>(<em>distance</em>)</p><p><code>turtle.backward</code>(<em>distance</em>)</p><ul><li>参数  :<strong>distance</strong> – 一个数值</li></ul><p>海龟后退 <em>distance</em> 指定的距离，方向与海龟的朝向相反。不改变海龟的朝向。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.backward(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">-30.00</span>,<span class="number">0.00</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.right</code>(<em>angle</em>)</p><p><code>turtle.rt</code>(<em>angle</em>)</p><ul><li>参数：<strong>angle</strong> – 一个数值 (整型或浮点型)</li></ul><p>海龟右转 <em>angle</em> 个单位。(单位默认为角度，但可通过 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.degrees" target="_blank" rel="noopener"><code>degrees()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.radians" target="_blank" rel="noopener"><code>radians()</code></a> 函数改变设置。) 角度的正负由海龟模式确定，参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">22.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.right(<span class="number">45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">337.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.left</code>(<em>angle</em>)</p><p><code>turtle.lt</code>(<em>angle</em>)</p><ul><li>参数:<strong>angle</strong> – 一个数值 (整型或浮点型)</li></ul><p>海龟左转 <em>angle</em> 个单位。(单位默认为角度，但可通过 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.degrees" target="_blank" rel="noopener"><code>degrees()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.radians" target="_blank" rel="noopener"><code>radians()</code></a> 函数改变设置。) 角度的正负由海龟模式确定，参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">22.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">67.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.goto</code>(<em>x</em>, <em>y=None</em>)</p><p><code>turtle.setpos</code>(<em>x</em>, <em>y=None</em>)</p><p><code>turtle.setposition</code>(<em>x</em>, <em>y=None</em>)</p><ul><li>参数：<strong>x</strong> – 一个数值或数值对/向量<strong>y</strong> – 一个数值或 <code>None</code></li></ul><p>如果 <em>y</em> 为 <code>None</code>，<em>x</em> 应为一个表示坐标的数值对或 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Vec2D" target="_blank" rel="noopener"><code>Vec2D</code></a> 类对象 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pos" target="_blank" rel="noopener"><code>pos()</code></a> 返回的对象).</p><p>海龟移动到一个绝对坐标。如果画笔已落下将会画线。不改变海龟的朝向。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tp = turtle.pos()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tp</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setpos(<span class="number">60</span>,<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">60.00</span>,<span class="number">30.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setpos((<span class="number">20</span>,<span class="number">80</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">20.00</span>,<span class="number">80.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setpos(tp)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.setx</code>(<em>x</em>)</p><ul><li>参数:<strong>x</strong> – 一个数值 (整型或浮点型)</li></ul><p>设置海龟的横坐标为 <em>x</em>，纵坐标保持不变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">240.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setx(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">10.00</span>,<span class="number">240.00</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.sety</code>(<em>y</em>)</p><ul><li>参数:<strong>y</strong> – 一个数值 (整型或浮点型)</li></ul><p>设置海龟的纵坐标为 <em>y</em>，横坐标保持不变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">40.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.sety(<span class="number">-10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">-10.00</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.setheading</code>(<em>to_angle</em>)</p><p><code>turtle.seth</code>(<em>to_angle</em>)</p><ul><li>参数:<strong>to_angle</strong> – 一个数值 (整型或浮点型)</li></ul><p>设置海龟的朝向为 <em>to_angle</em>。以下是以角度表示的几个常用方向：</p><table><thead><tr><th>标准模式</th><th>logo 模式</th></tr></thead><tbody><tr><td>0 - 东</td><td>0 - 北</td></tr><tr><td>90 - 北</td><td>90 - 东</td></tr><tr><td>180 - 西</td><td>180 - 南</td></tr><tr><td>270 - 南</td><td>270 - 西</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.setheading(<span class="number">90</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.home</code>()</p><p>海龟移至初始坐标 (0,0)，并设置朝向为初始方向 (由海龟模式确定，参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a>)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">-10.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.circle</code>(<em>radius</em>, <em>extent=None</em>, <em>steps=None</em>)</p><p>三个参数:</p><ul><li><strong>radius</strong> – 一个数值</li><li><strong>extent</strong> – 一个数值 (或 <code>None</code>)</li><li><strong>steps</strong> – 一个整型数 (或 <code>None</code>)</li></ul><p>绘制一个 <em>radius</em> 指定半径的圆。圆心在海龟左边 <em>radius</em> 个单位；<em>extent</em> 为一个夹角，用来决定绘制圆的一部分。如未指定 <em>extent\</em>则绘制整个圆。如果 *extent<em> 不是完整圆周，则以当前画笔位置为一个端点绘制圆弧。如果 </em>radius<em> 为正值则朝逆时针方向绘制圆弧，否则朝顺时针方向。最终海龟的朝向会依据 </em>extent* 的值而改变。</p><p>圆实际是以其内切正多边形来近似表示的，其边的数量由 <em>steps</em> 指定。如果未指定边数则会自动确定。此方法也可用来绘制正多边形。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.circle(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">-0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.circle(<span class="number">120</span>, <span class="number">180</span>)  <span class="comment"># draw a semicircle</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">240.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">180.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.dot</code>(<em>size=None</em>, *<em>color</em>)</p><ul><li><p>参数</p><p><strong>size</strong> – 一个整型数 &gt;= 1 (如果指定)<strong>color</strong> – 一个颜色字符串或颜色数值元组</p></li></ul><p>绘制一个直径为 <em>size</em>，颜色为 <em>color</em> 的圆点。如果 <em>size</em> 未指定，则直径取 pensize+4 和 2*pensize 中的较大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.dot()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>); turtle.dot(<span class="number">20</span>, <span class="string">"blue"</span>); turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">100.00</span>,<span class="number">-0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.stamp</code>()</p><p>在海龟当前位置印制一个海龟形状。返回该印章的 stamp_id，印章可以通过调用 <code>clearstamp(stamp_id)</code> 来删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"blue"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.stamp()</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.clearstamp</code>(<em>stampid</em>)</p><ul><li><p>参数</p><p><strong>stampid</strong> – 一个整型数，必须是之前 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.stamp" target="_blank" rel="noopener"><code>stamp()</code></a> 调用的返回值</p></li></ul><p>删除 <em>stampid</em> 指定的印章。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">150.00</span>,<span class="number">-0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"blue"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>astamp = turtle.stamp()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">200.00</span>,<span class="number">-0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.clearstamp(astamp)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">200.00</span>,<span class="number">-0.00</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.clearstamps</code>(<em>n=None</em>)</p><ul><li><p>参数</p><p><strong>n</strong> – 一个整型数 (或 <code>None</code>)</p></li></ul><p>删除全部或前/后 <em>n</em> 个海龟印章。如果 <em>n</em> 为 <code>None</code> 则删除全部印章，如果 <em>n</em> &gt; 0 则删除前 <em>n</em> 个印章，否则如果 <em>n</em> &lt; 0 则删除后 <em>n</em> 个印章。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line"><span class="meta">... </span>    turtle.stamp(); turtle.fd(<span class="number">30</span>)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.clearstamps(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.clearstamps(<span class="number">-2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.clearstamps()</span><br></pre></td></tr></table></figure><p><code>turtle.undo</code>()</p><p>撤消 (或连续撤消) 最近的一个 (或多个) 海龟动作。可撤消的次数由撤消缓冲区的大小决定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    turtle.fd(<span class="number">50</span>); turtle.lt(<span class="number">80</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line"><span class="meta">... </span>    turtle.undo()</span><br></pre></td></tr></table></figure><p><code>turtle.speed</code>(<em>speed=None</em>)</p><ul><li><p>参数</p><p><strong>speed</strong> – 一个 0..10 范围内的整型数或速度字符串 (见下)</p></li></ul><p>设置海龟移动的速度为 0..10 表示的整型数值。如未指定参数则返回当前速度。</p><p>如果输入数值大于 10 或小于 0.5 则速度设为 0。速度字符串与速度值的对应关系如下:</p><ul><li>“fastest”: 0 最快</li><li>“fast”: 10 快</li><li>“normal”: 6 正常</li><li>“slow”: 3 慢</li><li>“slowest”: 1 最慢</li></ul><p>速度值从 1 到 10，画线和海龟转向的动画效果逐级加快。</p><p>注意: <em>speed</em> = 0 表示 <em>没有</em> 动画效果。forward/back 将使海龟向前/向后跳跃，同样的 left/right 将使海龟立即改变朝向。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed(<span class="string">'normal'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed()</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed(<span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.speed()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="获取海龟的状态"><a href="#获取海龟的状态" class="headerlink" title="获取海龟的状态"></a>获取海龟的状态</h3><p><code>turtle.position</code>()</p><p><code>turtle.pos</code>()</p><p>返回海龟当前的坐标 (x,y) (为 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.Vec2D" target="_blank" rel="noopener"><code>Vec2D</code></a> 矢量类对象)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">440.00</span>,<span class="number">-0.00</span>)</span><br></pre></td></tr></table></figure><p><code>urtle.towards</code>(<em>x</em>, <em>y=None</em>)</p><ul><li><p>参数</p><p><strong>x</strong> – 一个数值或数值对/矢量，或一个海龟实例<strong>y</strong> – 一个数值——如果 <em>x</em> 是一个数值，否则为 <code>None</code></p></li></ul><p>从海龟位置到由 (x,y)，矢量或另一海龟对应位置的连线的夹角。此数值依赖于海龟初始朝向 - 由 “standard”/“world” 或 “logo” 模式设置所决定)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.goto(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.towards(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="number">225.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.xcor</code>()</p><p>返回海龟的 x 坐标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.forward(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pos()</span><br><span class="line">(<span class="number">64.28</span>,<span class="number">76.60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(round(turtle.xcor(), <span class="number">5</span>))</span><br><span class="line"><span class="number">64.27876</span></span><br></pre></td></tr></table></figure><p><code>turtle.ycor</code>()</p><p>返回海龟的 y 坐标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.forward(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(turtle.pos())</span><br><span class="line">(<span class="number">50.00</span>,<span class="number">86.60</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(round(turtle.ycor(), <span class="number">5</span>))</span><br><span class="line"><span class="number">86.60254</span></span><br></pre></td></tr></table></figure><p><code>turtle.heading</code>()</p><p>返回海龟当前的朝向 (数值依赖于海龟模式参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.mode" target="_blank" rel="noopener"><code>mode()</code></a>)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">67</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">67.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.distance</code>(<em>x</em>, <em>y=None</em>)</p><ul><li><p>参数</p><p><strong>x</strong> – 一个数值或数值对/矢量，或一个海龟实例<strong>y</strong> – 一个数值——如果 <em>x</em> 是一个数值，否则为 <code>None</code></p></li></ul><p>返回从海龟位置到由 (x,y)，适量或另一海龟对应位置的单位距离。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.distance(<span class="number">30</span>,<span class="number">40</span>)</span><br><span class="line"><span class="number">50.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.distance((<span class="number">30</span>,<span class="number">40</span>))</span><br><span class="line"><span class="number">50.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe = Turtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>joe.forward(<span class="number">77</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.distance(joe)</span><br><span class="line"><span class="number">77.0</span></span><br></pre></td></tr></table></figure><h3 id="度量单位设置"><a href="#度量单位设置" class="headerlink" title="度量单位设置"></a>度量单位设置</h3><p><code>turtle.degrees</code>(<em>fullcircle=360.0</em>)</p><ul><li><p>参数</p><p><strong>fullcircle</strong> – 一个数值</p></li></ul><p>设置角度的度量单位，即设置一个圆周为多少 “度”。默认值为 360 度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">90</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br><span class="line"></span><br><span class="line">Change angle measurement unit to grad (also known <span class="keyword">as</span> gon,</span><br><span class="line">grade, <span class="keyword">or</span> gradian <span class="keyword">and</span> equals <span class="number">1</span>/<span class="number">100</span>-th of the right angle.)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.degrees(<span class="number">400.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.degrees(<span class="number">360</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.radians</code>()</p><p>设置角度的度量单位为弧度。其值等于 <code>degrees(2*math.pi)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.home()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">90</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">90.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.radians()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">1.5707963267948966</span></span><br></pre></td></tr></table></figure><h3 id="画笔控制"><a href="#画笔控制" class="headerlink" title="画笔控制"></a>画笔控制</h3><h4 id="绘图状态"><a href="#绘图状态" class="headerlink" title="绘图状态"></a>绘图状态</h4><ul><li><p><code>turtle.pendown</code>()</p></li><li><p><code>turtle.pd</code>()</p></li><li><p><code>turtle.down</code>()</p><p>画笔落下 – 移动时将画线。</p></li><li><p><code>turtle.penup</code>()</p></li><li><p><code>turtle.pu</code>()</p></li><li><p><code>turtle.up</code>()</p><p>画笔抬起 – 移动时不画线。</p></li><li><p><code>turtle.pensize</code>(<em>width=None</em>)</p></li><li><p><code>turtle.width</code>(<em>width=None</em>)<a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.width" target="_blank" rel="noopener">¶</a></p></li><li><p>参数</p><p><strong>width</strong> – 一个正数值</p></li></ul><p>设置线条的粗细为 <em>width</em> 或返回该值。如果 resizemode 设为 “auto” 并且 turtleshape 为多边形，该多边形也以同样组细的线条绘制。如未指定参数，则返回当前的 pensize。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pensize()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pensize(<span class="number">10</span>)   <span class="comment"># from here on lines of width 10 are drawn</span></span><br></pre></td></tr></table></figure><ul><li><p><code>turtle.pen</code>(<em>pen=None</em>, <em>**pendict</em>)</p><p><strong>pen</strong> – 一个包含部分或全部下列键的字典</p><p><strong>pendict</strong> – 一个或多个以下列键为关键字的关键字参数</p><p>返回或设置画笔的属性，以一个包含以下键值对的 “画笔字典” 表示:</p><ul><li>“shown”: True/False</li><li>“pendown”: True/False</li><li>“pencolor”: 颜色字符串或颜色元组</li><li>“fillcolor”: 颜色字符串或颜色元组</li><li>“pensize”: 正数值</li><li>“speed”: 0..10 范围内的数值</li><li>“resizemode”: “auto” 或 “user” 或 “noresize”</li><li>“stretchfactor”: (正数值, 正数值)</li><li>“outline”: 正数值</li><li>“tilt”: 数值</li></ul></li></ul><p>此字典可作为后续调用 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pen" target="_blank" rel="noopener"><code>pen()</code></a> 时的参数，以恢复之前的画笔状态。另外还可将这些属性作为关键词参数提交。使用此方式可以用一条语句设置画笔的多个属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pen(fillcolor=<span class="string">"black"</span>, pencolor=<span class="string">"red"</span>, pensize=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(turtle.pen().items())</span><br><span class="line">[(<span class="string">'fillcolor'</span>, <span class="string">'black'</span>), (<span class="string">'outline'</span>, <span class="number">1</span>), (<span class="string">'pencolor'</span>, <span class="string">'red'</span>),</span><br><span class="line"> (<span class="string">'pendown'</span>, <span class="literal">True</span>), (<span class="string">'pensize'</span>, <span class="number">10</span>), (<span class="string">'resizemode'</span>, <span class="string">'noresize'</span>),</span><br><span class="line"> (<span class="string">'shearfactor'</span>, <span class="number">0.0</span>), (<span class="string">'shown'</span>, <span class="literal">True</span>), (<span class="string">'speed'</span>, <span class="number">9</span>),</span><br><span class="line"> (<span class="string">'stretchfactor'</span>, (<span class="number">1.0</span>, <span class="number">1.0</span>)), (<span class="string">'tilt'</span>, <span class="number">0.0</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>penstate=turtle.pen()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"yellow"</span>, <span class="string">""</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.penup()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(turtle.pen().items())[:<span class="number">3</span>]</span><br><span class="line">[(<span class="string">'fillcolor'</span>, <span class="string">''</span>), (<span class="string">'outline'</span>, <span class="number">1</span>), (<span class="string">'pencolor'</span>, <span class="string">'yellow'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pen(penstate, fillcolor=<span class="string">"green"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(turtle.pen().items())[:<span class="number">3</span>]</span><br><span class="line">[(<span class="string">'fillcolor'</span>, <span class="string">'green'</span>), (<span class="string">'outline'</span>, <span class="number">1</span>), (<span class="string">'pencolor'</span>, <span class="string">'red'</span>)]</span><br></pre></td></tr></table></figure><p><code>turtle.isdown</code>()</p><p>如果画笔落下返回 <code>True</code>，如果画笔抬起返回 <code>False</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.penup()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.isdown()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pendown()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.isdown()</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="颜色控制"><a href="#颜色控制" class="headerlink" title="颜色控制"></a>颜色控制</h4><p><code>turtle.pencolor</code>(*<em>args</em>)</p><p>返回或设置画笔颜色。</p><p>允许以下四种输入格式:</p><ul><li><p><code>pencolor()</code></p><p>返回以颜色描述字符串或元组 (见示例) 表示的当前画笔颜色。可用作其他 color/pencolor/fillcolor 调用的输入。</p></li><li><p><code>pencolor(colorstring)</code></p><p>设置画笔颜色为 <em>colorstring</em> 指定的 Tk 颜色描述字符串，例如 <code>&quot;red&quot;</code>、<code>&quot;yellow&quot;</code> 或 <code>&quot;#33cc8c&quot;</code>。</p></li><li><p><code>pencolor((r, g, b))</code></p><p>设置画笔颜色为以 <em>r</em>, <em>g</em>, <em>b</em> 元组表示的 RGB 颜色。<em>r</em>, <em>g</em>, <em>b</em> 的取值范围应为 0..colormode，colormode 的值为 1.0 或 255 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.colormode" target="_blank" rel="noopener"><code>colormode()</code></a>)。</p></li><li><p><code>pencolor(r, g, b)</code></p><p>设置画笔颜色为以 <em>r</em>, <em>g</em>, <em>b</em> 表示的 RGB 颜色。<em>r</em>, <em>g</em>, <em>b</em> 的取值范围应为 0..colormode。如果 turtleshape 为多边形，该多边形轮廓也以新设置的画笔颜色绘制。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colormode()</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line"><span class="string">'red'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(<span class="string">"brown"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line"><span class="string">'brown'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup = (<span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.55</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(tup)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line">(<span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.5490196078431373</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colormode(<span class="number">255</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line">(<span class="number">51.0</span>, <span class="number">204.0</span>, <span class="number">140.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor(<span class="string">'#32c18f'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line">(<span class="number">50.0</span>, <span class="number">193.0</span>, <span class="number">143.0</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.fillcolor</code>(*<em>args</em>)</p><p>返回或设置填充颜色。</p><p>允许以下四种输入格式:</p><ul><li><p><code>fillcolor()</code></p><p>返回以颜色描述字符串或元组 (见示例) 表示的当前填充颜色。可用作其他 color/pencolor/fillcolor 调用的输入。</p></li><li><p><code>fillcolor(colorstring)</code></p><p>设置填充颜色为 <em>colorstring</em> 指定的 Tk 颜色描述字符串，例如 <code>&quot;red&quot;</code>、<code>&quot;yellow&quot;</code> 或 <code>&quot;#33cc8c&quot;</code>。</p></li><li><p><code>fillcolor((r, g, b))</code></p><p>设置填充颜色为以 <em>r</em>, <em>g</em>, <em>b</em> 元组表示的 RGB 颜色。<em>r</em>, <em>g</em>, <em>b</em> 的取值范围应为 0..colormode，colormode 的值为 1.0 或 255 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.colormode" target="_blank" rel="noopener"><code>colormode()</code></a>)。</p></li><li><p><code>fillcolor(r, g, b)</code></p><p>设置填充颜色为 <em>r</em>, <em>g</em>, <em>b</em> 表示的 RGB 颜色。<em>r</em>, <em>g</em>, <em>b</em> 的取值范围应为 0..colormode。如果 turtleshape 为多边形，该多边形内部也以新设置的填充颜色填充。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor(<span class="string">"violet"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor()</span><br><span class="line"><span class="string">'violet'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.pencolor()</span><br><span class="line">(<span class="number">50.0</span>, <span class="number">193.0</span>, <span class="number">143.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor((<span class="number">50</span>, <span class="number">193</span>, <span class="number">143</span>))  <span class="comment"># Integers, not floats</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor()</span><br><span class="line">(<span class="number">50.0</span>, <span class="number">193.0</span>, <span class="number">143.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor(<span class="string">'#ffffff'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fillcolor()</span><br><span class="line">(<span class="number">255.0</span>, <span class="number">255.0</span>, <span class="number">255.0</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.color</code>(*<em>args</em>)</p><p>返回或设置画笔颜色和填充颜色。</p><p>允许多种输入格式。使用如下 0 至 3 个参数:</p><ul><li><p><code>color()</code></p><p>返回以一对颜色描述字符串或元组表示的当前画笔颜色和填充颜色，两者可分别由 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pencolor" target="_blank" rel="noopener"><code>pencolor()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.fillcolor" target="_blank" rel="noopener"><code>fillcolor()</code></a> 返回。</p></li><li><p><code>color(colorstring)</code>, <code>color((r,g,b))</code>, <code>color(r,g,b)</code></p><p>输入格式与 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.pencolor" target="_blank" rel="noopener"><code>pencolor()</code></a> 相同，同时设置填充颜色和画笔颜色为指定的值。</p></li><li><p><code>color(colorstring1, colorstring2)</code>, <code>color((r1,g1,b1), (r2,g2,b2))</code></p><p>相当于 <code>pencolor(colorstring1)</code> 加 <code>fillcolor(colorstring2)</code>，使用其他输入格式的方法也与之类似。如果 turtleshape 为多边形，该多边形轮廓与填充也使用新设置的颜色。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"red"</span>, <span class="string">"green"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color()</span><br><span class="line">(<span class="string">'red'</span>, <span class="string">'green'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color(<span class="string">"#285078"</span>, <span class="string">"#a0c8f0"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>color()</span><br><span class="line">((<span class="number">40.0</span>, <span class="number">80.0</span>, <span class="number">120.0</span>), (<span class="number">160.0</span>, <span class="number">200.0</span>, <span class="number">240.0</span>))</span><br></pre></td></tr></table></figure><p>另参见: Screen 方法 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.colormode" target="_blank" rel="noopener"><code>colormode()</code></a>。</p><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><p><code>turtle.filling</code>()</p><p>返回填充状态 (填充为 <code>True</code>，否则为 <code>False</code>)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.begin_fill()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> turtle.filling():</span><br><span class="line"><span class="meta">... </span>   turtle.pensize(<span class="number">5</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>   turtle.pensize(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li><p><code>turtle.begin_fill</code>()<a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.begin_fill" target="_blank" rel="noopener">¶</a></p><p>在绘制要填充的形状之前调用。</p></li><li><p><code>turtle.end_fill</code>()</p><p>填充上次调用 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.begin_fill" target="_blank" rel="noopener"><code>begin_fill()</code></a> 之后绘制的形状。自相交多边形或多个形状间的重叠区域是否填充取决于操作系统的图形引擎、重叠的类型以及重叠的层数。 例如上面的 Turtle 多芒星可能会全部填充为黄色，也可能会有一些白色区域。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.color(<span class="string">"black"</span>, <span class="string">"red"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.begin_fill()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.circle(<span class="number">80</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.end_fill()</span><br></pre></td></tr></table></figure></li></ul><h4 id="更多绘图控制"><a href="#更多绘图控制" class="headerlink" title="更多绘图控制"></a>更多绘图控制</h4><ul><li><p><code>turtle.reset</code>()</p><p>从屏幕中删除海龟的绘图，海龟回到原点并设置所有变量为默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.goto(<span class="number">0</span>,<span class="number">-22</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.left(<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">-22.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.position()</span><br><span class="line">(<span class="number">0.00</span>,<span class="number">0.00</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.heading()</span><br><span class="line"><span class="number">0.0</span></span><br></pre></td></tr></table></figure></li><li><p><code>turtle.clear</code>()</p><p>从屏幕中删除指定海龟的绘图。不移动海龟。海龟的状态和位置以及其他海龟的绘图不受影响。</p></li><li><p><code>turtle.clear</code>()</p><p>从屏幕中删除指定海龟的绘图。不移动海龟。海龟的状态和位置以及其他海龟的绘图不受影响。</p></li><li><p><code>turtle.write</code>(<em>arg</em>, <em>move=False</em>, <em>align=”left”</em>, <em>font=(“Arial”</em>, <em>8</em>, <em>“normal”)</em>)</p><p>参数<strong>arg</strong> – 要书写到 TurtleScreen 的对象<strong>move</strong> – True/False<strong>align</strong> – 字符串 “left”, “center” 或 “right”<strong>font</strong> – 一个三元组 (fontname, fontsize, fonttype)书写文本 - <em>arg</em> 指定的字符串 - 到当前海龟位置，<em>align</em> 指定对齐方式 (“left”, “center” 或 right”)，font 指定字体。如果 <em>move</em> 为 True，画笔会移动到文本的右下角。默认 <em>move</em> 为 <code>False</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">turtle.write(<span class="string">"Home = "</span>, <span class="literal">True</span>, align=<span class="string">"center"</span>)</span><br><span class="line">turtle.write((<span class="number">0</span>,<span class="number">0</span>), <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="海龟状态"><a href="#海龟状态" class="headerlink" title="海龟状态"></a>海龟状态</h3><p>  可见性</p><ul><li><p><code>turtle.hideturtle</code>()</p></li><li><p><code>turtle.ht</code>()</p><p>使海龟不可见。当你绘制复杂图形时这是个好主意，因为隐藏海龟可显著加快绘制速度。<code>&gt;&gt;&gt; turtle.hideturtle()</code></p></li><li><p><code>turtle.showturtle</code>()</p><p><code>turtle.st</code>()</p><p>使海龟可见。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.showturtle()</span><br></pre></td></tr></table></figure></li><li><p><code>turtle.isvisible</code>()</p><p>如果海龟显示返回 <code>True</code>，如果海龟隐藏返回 <code>False</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.hideturtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.isvisible()</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.showturtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.isvisible()</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h4><ul><li><p><code>turtle.shape</code>(<em>name=None</em>)</p><ul><li><strong>name</strong> – 一个有效的形状名字符串</li></ul><p>设置海龟形状为 <em>name</em> 指定的形状名，如未指定形状名则返回当前的形状名。<em>name</em> 指定的形状名应存在于 TurtleScreen 的 shape 字典中。多边形的形状初始时有以下几种: “arrow”, “turtle”, “circle”, “square”, “triangle”, “classic”。要了解如何处理形状请参看 Screen 方法 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.register_shape" target="_blank" rel="noopener"><code>register_shape()</code></a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape()</span><br><span class="line"><span class="string">'classic'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"turtle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape()</span><br><span class="line"><span class="string">'turtle'</span></span><br></pre></td></tr></table></figure></li><li><p><code>turtle.resizemode</code>(<em>rmode=None</em>)<a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.resizemode" target="_blank" rel="noopener">¶</a></p><ul><li><p>参数</p><p><strong>rmode</strong> – 字符串 “auto”, “user”, “noresize” 其中之一</p></li></ul><p>设置大小调整模式为以下值之一: “auto”, “user”, “noresize”。如未指定 <em>rmode</em> 则返回当前的大小调整模式。不同的大小调整模式的效果如下:</p><ul><li>“auto”: 根据画笔粗细值调整海龟的外观。</li><li>“user”: 根据拉伸因子和轮廓宽度 (outline) 值调整海龟的外观，两者是由 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shapesize" target="_blank" rel="noopener"><code>shapesize()</code></a> 设置的。</li><li>“noresize”: 不调整海龟的外观大小。</li></ul><p>大小调整模式 (“user”) 会在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.shapesize" target="_blank" rel="noopener"><code>shapesize()</code></a> 带参数调用时生效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.resizemode()</span><br><span class="line"><span class="string">'noresize'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.resizemode(<span class="string">"auto"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.resizemode()</span><br><span class="line"><span class="string">'auto'</span></span><br></pre></td></tr></table></figure></li></ul><p><code>turtle.shapesize</code>(<em>stretch_wid=None</em>, <em>stretch_len=None</em>, <em>outline=None</em>)</p><p><code>turtle.turtlesize</code>(<em>stretch_wid=None</em>, <em>stretch_len=None</em>, <em>outline=None</em>)</p><ul><li><p>参数</p><p><strong>stretch_wid</strong> – 正数值<strong>stretch_len</strong> – 正数值<strong>outline</strong> – 正数值</p></li></ul><p>返回或设置画笔的属性 x/y-拉伸因子和/或轮廓。设置大小调整模式为 “user”。当且仅当大小调整模式设为 “user” 时海龟会基于其拉伸因子调整外观: <em>stretch_wid</em> 为垂直于其朝向的宽度拉伸因子，<em>stretch_len</em> 为平等于其朝向的长度拉伸因子，决定形状轮廓线的粗细。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize()</span><br><span class="line">(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.resizemode(<span class="string">"user"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize()</span><br><span class="line">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(outline=<span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize()</span><br><span class="line">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.shearfactor</code>(<em>shear=None</em>)</p><ul><li><p>参数</p><p><strong>shear</strong> – 数值 (可选)</p></li></ul><p>设置或返回当前的剪切因子。根据 share 指定的剪切因子即剪切角度的切线来剪切海龟形状。<em>不</em> 改变海龟的朝向 (移动方向)。如未指定 shear 参数: 返回当前的剪切因子即剪切角度的切线，与海龟朝向平行的线条将被剪切。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"circle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shearfactor(<span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shearfactor()</span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure><p><code>turtle.tilt</code>(<em>angle</em>)</p><ul><li><p>参数</p><p><strong>angle</strong> – 一个数值</p></li></ul><p>海龟形状自其当前的倾角转动 <em>angle</em> 指定的角度，但 <em>不</em> 改变海龟的朝向 (移动方向)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"circle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.tilt(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.tilt(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.settiltangle</code>(<em>angle</em>)</p><ul><li><p>参数</p><p><strong>angle</strong> – 一个数值</p></li></ul><p>旋转海龟形状使其指向 <em>angle</em> 指定的方向，忽略其当前的倾角，<em>不</em> 改变海龟的朝向 (移动方向)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"circle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.settiltangle(<span class="number">45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.settiltangle(<span class="number">-45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.fd(<span class="number">50</span>)</span><br></pre></td></tr></table></figure><p><em>3.1 版后已移除.</em></p><p><code>turtle.tiltangle</code>(<em>angle=None</em>)</p><ul><li><p>参数</p><p><strong>angle</strong> – 一个数值 (可选)</p></li></ul><p>设置或返回当前的倾角。如果指定 angle 则旋转海龟形状使其指向 angle 指定的方向，忽略其当前的倾角。<em>不</em> 改变海龟的朝向 (移动方向)。如果未指定 angle: 返回当前的倾角，即海龟形状的方向和海龟朝向 (移动方向) 之间的夹角。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.reset()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"circle"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.tilt(<span class="number">45</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.tiltangle()</span><br><span class="line"><span class="number">45.0</span></span><br></pre></td></tr></table></figure><p><code>turtle.shapetransform</code>(<em>t11=None</em>, <em>t12=None</em>, <em>t21=None</em>, <em>t22=None</em>)</p><ul><li><p>参数</p><p><strong>t11</strong> – 一个数值 (可选)<strong>t12</strong> – 一个数值 (可选)<strong>t21</strong> – 一个数值 (可选)<strong>t12</strong> – 一个数值 (可选)</p></li></ul><p>设置或返回海龟形状的当前变形矩阵。</p><p>如不指定任何矩阵元素，则返回以4元素元组表示的变形矩阵。否则使用指定元素设置变形矩阵改变海龟形状，矩阵第一排的值为 t11, t12，第二排的值为 t21, t22。行列式 t11 <em> t22 - t12 </em> t21 的值不能为零，否则会出错。根据指定的矩阵修改拉伸因子，剪切因子和倾角。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle = Turtle()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"square"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapesize(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shearfactor(<span class="number">-0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapetransform()</span><br><span class="line">(<span class="number">4.0</span>, <span class="number">-1.0</span>, <span class="number">-0.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p><code>turtle.get_shapepoly</code>()</p><p>返回以坐标值对元组表示的当前形状多边形。这可以用于定义一个新形状或一个复合形状的多个组成部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shape(<span class="string">"square"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.shapetransform(<span class="number">4</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>turtle.get_shapepoly()</span><br><span class="line">((<span class="number">50</span>, <span class="number">-20</span>), (<span class="number">30</span>, <span class="number">20</span>), (<span class="number">-50</span>, <span class="number">20</span>), (<span class="number">-30</span>, <span class="number">-20</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-turtle-海龟制图&quot;&gt;&lt;a href=&quot;#python-标准库-turtle-海龟制图&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 turtle 海龟制图&quot;&gt;&lt;/a&gt;python 标准库 turtle 海龟制图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200227turtle.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="turtle" scheme="https://pinghailinfeng.gitee.io/tags/turtle/"/>
    
  </entry>
  
  <entry>
    <title>python standard library 2to3</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/26/python-standard-library-2to3/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/26/python-standard-library-2to3/</id>
    <published>2020-02-26T15:17:12.000Z</published>
    <updated>2020-02-27T02:06:49.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-2to3-自动转换python2到3"><a href="#python-标准库-2to3-自动转换python2到3" class="headerlink" title="python 标准库 2to3 自动转换python2到3"></a>python 标准库 2to3 自动转换python2到3</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200226Memorize-Words-Quickly-Step-8-Version-3.jpg?raw=true" alt></p><a id="more"></a><p>2to3 是一个 Python 程序，它可以用来读取 Python 2.x 版本的代码，并使用一系列的 <em>修复器</em> 来将其转换为合法的 Python 3.x 代码。标准库中已经包含了丰富的修复器，这足以处理绝大多数代码。不过 2to3 的支持库 <a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#module-lib2to3" target="_blank" rel="noopener"><code>lib2to3</code></a> 是一个很灵活通用的库，所以你也可以为 2to3 编写你自己的修复器。<a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#module-lib2to3" target="_blank" rel="noopener"><code>lib2to3</code></a> 也可以用在那些需要自动处理 Python 代码的应用中。</p><h2 id="使用-2to3"><a href="#使用-2to3" class="headerlink" title="使用 2to3"></a>使用 2to3</h2><p>2to3 通常会作为脚本和 Python 解释器一起安装，你可以在 Python 根目录的 <code>Tools/scripts</code> 文件夹下找到它。</p><p>2to3 的基本调用参数是一个需要转换的文件或目录列表。对于目录，会递归地寻找其中的 Python 源码。</p><p>这里有一个 Python 2.x 的源码文件，<code>example.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Hello, &#123;0&#125;!"</span>.format(name)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"What's your name?"</span></span><br><span class="line">name = raw_input()</span><br><span class="line">greet(name)</span><br></pre></td></tr></table></figure><p>它可以在命令行中使用 2to3 转换成 Python 3.x 版本的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 example.py</span><br></pre></td></tr></table></figure><p>这个命令会打印出和源文件的区别。通过传入 <code>-w</code> 参数，2to3 也可以把需要的修改写回到原文件中（除非传入了 <code>-n</code> 参数，否则会为原始文件创建一个副本）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -w example.py</span><br></pre></td></tr></table></figure><p>在转换完成后，<code>example.py</code> 看起来像是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"Hello, &#123;0&#125;!"</span>.format(name))</span><br><span class="line">print(<span class="string">"What's your name?"</span>)</span><br><span class="line">name = input()</span><br><span class="line">greet(name)</span><br></pre></td></tr></table></figure><p>注释和缩进都会在转换过程中保持不变。</p><p>默认情况下，2to3 会执行 <a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#to3-fixers" target="_blank" rel="noopener">预定义修复器</a> 的集合。使用 <code>-l</code> 参数可以列出所有可用的修复器。使用 <code>-f</code> 参数可以明确指定需要使用的修复器集合。而使用 <code>-x</code> 参数则可以明确指定不使用的修复器。下面的例子会只使用 <code>imports</code> 和 <code>has_key</code> 修复器运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -f imports -f has_key example.py</span><br></pre></td></tr></table></figure><p>这个命令会执行除了 <code>apply</code> 之外的所有修复器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -x apply example.py</span><br></pre></td></tr></table></figure><p>有一些修复器是需要 <em>显式指定</em> 的，它们默认不会执行，必须在命令行中列出才会执行。比如下面的例子，除了默认的修复器以外，还会执行 <code>idioms</code> 修复器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -f all -f idioms example.py</span><br></pre></td></tr></table></figure><p>注意这里使用 <code>all</code> 来启用所有默认的修复器。</p><p>有些情况下 2to3 会找到源码中有一些需要修改，但是无法自动处理的代码。在这种情况下，2to3 会在差异处下面打印一个警告信息。你应该定位到相应的代码并对其进行修改，以使其兼容 Python 3.x。</p><p>2to3 也可以重构 doctests。使用 <code>-d</code> 开启这个模式。需要注意<em>只有</em> doctests 会被重构。这种模式下不需要文件是合法的 Python 代码。举例来说，reST 文档中类似 doctests 的示例也可以使用这个选项进行重构。</p><p><code>-v</code> 选项可以输出更多转换程序的详细信息。</p><p>由于某些 print 语句可被解读为函数调用或是语句，2to3 并不是总能读取包含 print 函数的文件。当 2to3 检测到存在 <code>from __future__ import print_function</code> 编译器指令时，会修改其内部语法将 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 解读为函数。这一变动也可以使用 <code>-p</code> 选项手动开启。使用 <code>-p</code> 来为已经转换过 print 语句的代码运行修复器。</p><p><code>-o</code> 或 <code>--output-dir</code> 选项可以指定将转换后的文件写入其他目录中。由于这种情况下不会覆写原始文件，所以创建副本文件毫无意义，因此也需要使用 <code>-n</code> 选项来禁用创建副本。</p><p><em>3.2.3 新版功能:</em> 增加了 <code>-o</code> 选项。</p><p><code>-W</code> 或 <code>--write-unchanged-files</code> 选项用来告诉 2to3 始终需要输出文件，即使没有任何改动。这在使用 <code>-o</code> 参数时十分有用，这样就可以将整个 Python 源码包完整地转换到另一个目录。这个选项隐含了 <code>-w</code> 选项，否则等于没有作用。</p><p><em>3.2.3 新版功能:</em> 增加了 <code>-W</code> 选项。</p><p><code>--add-suffix</code> 选项接受一个字符串，用来作为后缀附加在输出文件名后面的后面。由于写入的文件名与原始文件不同，所以没有必要创建副本，因此 <code>-n</code> 选项也是必要的。举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 -n -W --add-suffix=<span class="number">3</span> example.py</span><br></pre></td></tr></table></figure><p>这样会把转换后的文件写入 <code>example.py3</code> 文件。</p><p><em>3.2.3 新版功能:</em> 增加了 <code>--add-suffix</code> 选项。</p><p>将整个项目从一个目录转换到另一个目录可以用这样的命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="number">2</span>to3 --output-dir=python3-version/mycode -W -n python2-version/mycode</span><br></pre></td></tr></table></figure><h2 id="修复器"><a href="#修复器" class="headerlink" title="修复器"></a>修复器</h2><p>转换代码的每一个步骤都封装在修复器中。可以使用 <code>2to3 -l</code> 来列出可用的修复器。<a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#to3-using" target="_blank" rel="noopener">之前已经提到</a>，每个修复器都可以独立地打开或是关闭。下面会对各个修复器做更详细的描述。</p><ul><li><p><code>apply</code></p><p>移除对 <code>apply()</code> 的使用，举例来说，<code>apply(function, *args, **kwargs)</code> 会被转换成 <code>function(*args, **kwargs)</code>。</p></li><li><p><code>asserts</code></p><p>将已弃用的 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 方法替换为正确的。</p></li></ul><table><thead><tr><th style="text-align:left">Python 2.x</th><th style="text-align:left">Python 3.x</th></tr></thead><tbody><tr><td style="text-align:left"><code>failUnlessEqual(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertEqual" target="_blank" rel="noopener"><code>assertEqual(a, b)</code></a></td></tr><tr><td style="text-align:left"><code>assertEquals(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertEqual" target="_blank" rel="noopener"><code>assertEqual(a, b)</code></a></td></tr><tr><td style="text-align:left"><code>failIfEqual(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertNotEqual" target="_blank" rel="noopener"><code>assertNotEqual(a, b)</code></a></td></tr><tr><td style="text-align:left"><code>assertNotEquals(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertNotEqual" target="_blank" rel="noopener"><code>assertNotEqual(a, b)</code></a></td></tr><tr><td style="text-align:left"><code>failUnless(a)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertTrue" target="_blank" rel="noopener"><code>assertTrue(a)</code></a></td></tr><tr><td style="text-align:left"><code>assert_(a)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertTrue" target="_blank" rel="noopener"><code>assertTrue(a)</code></a></td></tr><tr><td style="text-align:left"><code>failIf(a)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertFalse" target="_blank" rel="noopener"><code>assertFalse(a)</code></a></td></tr><tr><td style="text-align:left"><code>failUnlessRaises(exc, cal)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertRaises" target="_blank" rel="noopener"><code>assertRaises(exc, cal)</code></a></td></tr><tr><td style="text-align:left"><code>failUnlessAlmostEqual(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertAlmostEqual" target="_blank" rel="noopener"><code>assertAlmostEqual(a, b)</code></a></td></tr><tr><td style="text-align:left"><code>assertAlmostEquals(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertAlmostEqual" target="_blank" rel="noopener"><code>assertAlmostEqual(a, b)</code></a></td></tr><tr><td style="text-align:left"><code>failIfAlmostEqual(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertNotAlmostEqual" target="_blank" rel="noopener"><code>assertNotAlmostEqual(a, b)</code></a></td></tr><tr><td style="text-align:left"><code>assertNotAlmostEquals(a, b)</code></td><td style="text-align:left"><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertNotAlmostEqual" target="_blank" rel="noopener"><code>assertNotAlmostEqual(a, b)</code></a></td></tr></tbody></table><ul><li><code>basestring</code></li></ul><ul><li><p><code>buffer</code></p><p>将 <code>buffer</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview</code></a>。这个修复器是可选的，因为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview</code></a> API 和 <code>buffer</code> 很相似，但不完全一样。</p></li><li><p><code>dict</code></p><p>修复字典迭代方法。<code>dict.iteritems()</code> 会转换成 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.items" target="_blank" rel="noopener"><code>dict.items()</code></a>，<code>dict.iterkeys()</code> 会转换成 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.keys" target="_blank" rel="noopener"><code>dict.keys()</code></a>，<code>dict.itervalues()</code> 会转换成 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.values" target="_blank" rel="noopener"><code>dict.values()</code></a>。类似的，<code>dict.viewitems()</code>，<code>dict.viewkeys()</code> 和 <code>dict.viewvalues()</code> 会分别转换成 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.items" target="_blank" rel="noopener"><code>dict.items()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.keys" target="_blank" rel="noopener"><code>dict.keys()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.values" target="_blank" rel="noopener"><code>dict.values()</code></a>。另外也会将原有的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.items" target="_blank" rel="noopener"><code>dict.items()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.keys" target="_blank" rel="noopener"><code>dict.keys()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict.values" target="_blank" rel="noopener"><code>dict.values()</code></a> 方法调用用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装一层。</p></li><li><p><code>except</code></p><p>将 <code>except X, T</code> 转换为 <code>except X as T</code>。</p></li><li><p><code>exec</code></p><p>将 <code>exec</code> 语句转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 函数调用。</p></li><li><p><code>execfile</code></p><p>移除 <code>execfile()</code> 的使用。<code>execfile()</code> 的实参会使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/functions.html#compile" target="_blank" rel="noopener"><code>compile()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 包装。</p></li><li><p><code>exitfunc</code></p><p>将对 <code>sys.exitfunc</code> 的赋值改为使用 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 模块代替。</p></li><li><p><code>filter</code></p><p>将 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#filter" target="_blank" rel="noopener"><code>filter()</code></a> 函数用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装一层。</p></li><li><p><code>funcattrs</code></p><p>修复已经重命名的函数属性。比如 <code>my_function.func_closure</code> 会被转换为 <code>my_function.__closure__</code>。</p></li><li><p><code>future</code></p><p>移除 <code>from __future__ import new_feature</code> 语句。</p></li><li><p><code>getcwdu</code></p><p>将 <code>os.getcwdu()</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getcwd" target="_blank" rel="noopener"><code>os.getcwd()</code></a>。</p></li><li><p><code>has_key</code></p><p>将 <code>dict.has_key(key)</code> 转换为 <code>key in dict</code>。</p></li><li><p><code>idioms</code></p><p>这是一个可选的修复器，会进行多种转换，将 Python 代码变成更加常见的写法。类似 <code>type(x) is SomeClass</code> 和 <code>type(x) == SomeClass</code> 的类型对比会被转换成 <code>isinstance(x, SomeClass)</code>。<code>while 1</code> 转换成 <code>while True</code>。这个修复器还会在合适的地方使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#sorted" target="_blank" rel="noopener"><code>sorted()</code></a> 函数。举个例子，这样的代码块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = list(some_iterable)</span><br><span class="line">L.sort()</span><br></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = sorted(some_iterable)</span><br></pre></td></tr></table></figure></li><li><p><code>import</code></p><p>检测 sibling imports，并将其转换成相对 import。</p></li><li><p><code>imports</code></p><p>处理标准库模块的重命名。</p></li><li><p><code>imports2</code></p><p>处理标准库中其他模块的重命名。这个修复器由于一些技术上的限制，因此和 <a href="https://docs.python.org/zh-cn/3.8/library/2to3.html#2to3fixer-imports" target="_blank" rel="noopener"><code>imports</code></a> 拆分开了。</p></li><li><p><code>input</code></p><p>将 <code>input(prompt)</code> 转换为 <code>eval(input(prompt))</code>。</p></li><li><p><code>intern</code></p><p>将 <code>intern()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.intern" target="_blank" rel="noopener"><code>sys.intern()</code></a>。</p></li><li><p><code>isinstance</code></p><p>修复 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#isinstance" target="_blank" rel="noopener"><code>isinstance()</code></a> 函数第二个实参中重复的类型。举例来说，<code>isinstance(x, (int, int))</code> 会转换为 <code>isinstance(x, int)</code>, <code>isinstance(x, (int, float, int))</code> 会转换为 <code>isinstance(x, (int, float))</code>。</p></li><li><p><code>itertools_imports</code></p><p>移除 <code>itertools.ifilter()</code>，<code>itertools.izip()</code> 以及 <code>itertools.imap()</code> 的 import。对 <code>itertools.ifilterfalse()</code> 的 import 也会替换成 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.filterfalse" target="_blank" rel="noopener"><code>itertools.filterfalse()</code></a>。</p></li><li><p><code>itertools</code></p><p>修改 <code>itertools.ifilter()</code>，<code>itertools.izip()</code> 和 <code>itertools.imap()</code> 的调用为对应的内建实现。<code>itertools.ifilterfalse()</code> 会替换成 <a href="https://docs.python.org/zh-cn/3.8/library/itertools.html#itertools.filterfalse" target="_blank" rel="noopener"><code>itertools.filterfalse()</code></a>。</p></li><li><p><code>long</code></p><p>将 <code>long</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a>。</p></li><li><p><code>map</code></p><p>用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a>。同时也会将 <code>map(None, x)</code> 替换为 <code>list(x)</code>。使用 <code>from future_builtins import map</code> 禁用这个修复器。</p></li><li><p><code>metaclass</code></p><p>将老的元类语法（类体中的 <code>__metaclass__ = Meta</code>）替换为新的（<code>class X(metaclass=Meta)</code>）。</p></li><li><p><code>methodattrs</code></p><p>修复老的方法属性名。例如 <code>meth.im_func</code> 会被转换为 <code>meth.__func__</code>。</p></li><li><p><code>ne</code></p><p>转换老的不等语法，将 <code>&lt;&gt;</code> 转为 <code>!=</code>。</p></li><li><p><code>next</code></p><p>将迭代器的 <code>next()</code> 方法调用转为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 函数。也会将 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 方法重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a>。</p></li><li><p><code>nonzero</code></p><p>将 <code>__nonzero__()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__bool__" target="_blank" rel="noopener"><code>__bool__()</code></a>。</p></li><li><p><code>numliterals</code></p><p>将八进制字面量转为新的语法。</p></li><li><p><code>operator</code></p><p>将 <a href="https://docs.python.org/zh-cn/3.8/library/operator.html#module-operator" target="_blank" rel="noopener"><code>operator</code></a> 模块中的许多方法调用转为其他的等效函数调用。如果有需要，会添加适当的 <code>import</code> 语句，比如 <code>import collections.abc</code>。有以下转换映射：</p></li></ul><table><thead><tr><th style="text-align:left">Python 2.x</th><th style="text-align:left">Python 3.x</th></tr></thead><tbody><tr><td style="text-align:left"><code>operator.isCallable(obj)</code></td><td style="text-align:left"><code>callable(obj)</code></td></tr><tr><td style="text-align:left"><code>operator.sequenceIncludes(obj)</code></td><td style="text-align:left"><code>operator.contains(obj)</code></td></tr><tr><td style="text-align:left"><code>operator.isSequenceType(obj)</code></td><td style="text-align:left"><code>isinstance(obj, collections.abc.Sequence)</code></td></tr><tr><td style="text-align:left"><code>operator.isMappingType(obj)</code></td><td style="text-align:left"><code>isinstance(obj, collections.abc.Mapping)</code></td></tr><tr><td style="text-align:left"><code>operator.isNumberType(obj)</code></td><td style="text-align:left"><code>isinstance(obj, numbers.Number)</code></td></tr><tr><td style="text-align:left"><code>operator.repeat(obj, n)</code></td><td style="text-align:left"><code>operator.mul(obj, n)</code></td></tr><tr><td style="text-align:left"><code>operator.irepeat(obj, n)</code></td><td style="text-align:left"><code>operator.imul(obj, n)</code></td></tr></tbody></table><ul><li><p><code>paren</code></p><p>在列表生成式中增加必须的括号。例如将 <code>[x for x in 1, 2]</code> 转换为 <code>[x for x in (1, 2)]</code>。</p></li><li><p><code>print</code></p><p>将 <code>print</code> 语句转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#print" target="_blank" rel="noopener"><code>print()</code></a> 函数。</p></li><li><p><code>raise</code></p><p>将 <code>raise E, V</code> 转换为 <code>raise E(V)</code>，将 <code>raise E, V, T</code> 转换为 <code>raise E(V).with_traceback(T)</code>。如果 <code>E</code> 是元组，这样的转换是不正确的，因为用元组代替异常的做法在 3.0 中已经移除了。</p></li><li><p><code>raw_input</code></p><p>将 <code>raw_input()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#input" target="_blank" rel="noopener"><code>input()</code></a>。</p></li><li><p><code>reduce</code></p><p>将 <code>reduce()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/functools.html#functools.reduce" target="_blank" rel="noopener"><code>functools.reduce()</code></a>。</p></li><li><p><code>reload</code></p><p>将 <code>reload()</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/importlib.html#importlib.reload" target="_blank" rel="noopener"><code>importlib.reload()</code></a>。</p></li><li><p><code>renames</code></p><p>将 <code>sys.maxint</code> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.maxsize" target="_blank" rel="noopener"><code>sys.maxsize</code></a>。</p></li><li><p><code>repr</code></p><p>将反引号 repr 表达式替换为 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a> 函数。</p></li><li><p><code>set_literal</code></p><p>将 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 构造函数替换为 set literals 写法。这个修复器是可选的。</p></li><li><p><code>standarderror</code></p><p>将 <code>StandardError</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a>。</p></li><li><p><code>sys_exc</code></p><p>将弃用的 <code>sys.exc_value</code>，<code>sys.exc_type</code>，<code>sys.exc_traceback</code> 替换为 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exc_info" target="_blank" rel="noopener"><code>sys.exc_info()</code></a> 的用法。</p></li><li><p><code>throw</code></p><p>修复生成器的 <code>throw()</code> 方法的 API 变更。</p></li><li><p><code>tuple_params</code></p><p>移除隐式的元组参数解包。这个修复器会插入临时变量。</p></li><li><p><code>types</code></p><p>修复 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#type" target="_blank" rel="noopener"><code>type</code></a> 模块中一些成员的移除引起的代码问题。</p></li><li><p><code>unicode</code></p><p>将 <code>unicode</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a>。</p></li><li><p><code>urllib</code></p><p>将 <a href="https://docs.python.org/zh-cn/3.8/library/urllib.html#module-urllib" target="_blank" rel="noopener"><code>urllib</code></a> 和 <code>urllib2</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/urllib.html#module-urllib" target="_blank" rel="noopener"><code>urllib</code></a> 包。</p></li><li><p><code>ws_comma</code></p><p>移除逗号分隔的元素之间多余的空白。这个修复器是可选的。</p></li><li><p><code>xrange</code></p><p>将 <code>xrange()</code> 重命名为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#range" target="_blank" rel="noopener"><code>range()</code></a>，并用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装原有的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#range" target="_blank" rel="noopener"><code>range()</code></a>。</p></li><li><p><code>xreadlines</code></p><p>将 <code>for x in file.xreadlines()</code> 转换为 <code>for x in file</code>。</p></li><li><p><code>zip</code></p><p>用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 包装 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#zip" target="_blank" rel="noopener"><code>zip()</code></a>。如果使用了 <code>from future_builtins import zip</code> 的话会禁用。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-2to3-自动转换python2到3&quot;&gt;&lt;a href=&quot;#python-标准库-2to3-自动转换python2到3&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 2to3 自动转换python2到3&quot;&gt;&lt;/a&gt;python 标准库 2to3 自动转换python2到3&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200226Memorize-Words-Quickly-Step-8-Version-3.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="2to3" scheme="https://pinghailinfeng.gitee.io/tags/2to3/"/>
    
  </entry>
  
  <entry>
    <title>python standard library unittest</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/25/python-standard-library-unittest/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/25/python-standard-library-unittest/</id>
    <published>2020-02-25T14:00:35.000Z</published>
    <updated>2020-02-27T02:06:49.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-unittest"><a href="#python-标准库-unittest" class="headerlink" title="python 标准库 unittest"></a>python 标准库 unittest</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200225unit-test.png?raw=true" alt></p><a id="more"></a><blockquote><p>今天又学到一种单词记忆方法</p><p><a href="https://www.wikihow.com/Memorize-Words-Quickly" target="_blank" rel="noopener">https://www.wikihow.com/Memorize-Words-Quickly</a> </p><p>基本原则我梳理了一下:</p><ol><li><p>Using Word Association and Mnemonic Devices</p></li><li><p>Visualizing Words </p></li><li><p>Using Sound and Music</p></li></ol></blockquote><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/unittest/__init__.py" target="_blank" rel="noopener">Lib/unittest/<strong>init</strong>.py</a></p><hr><p>（如果你已经对测试的概念比较熟悉了，你可能想直接跳转到这一部分 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#assert-methods" target="_blank" rel="noopener">断言方法</a>。）</p><p><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 单元测试框架是受到 JUnit 的启发，与其他语言中的主流单元测试框架有着相似的风格。其支持测试自动化，配置共享和关机代码测试。支持将测试样例聚合到测试集中，并将测试与报告框架独立。</p><p>为了实现这些，<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 通过面向对象的方式支持了一些重要的概念。</p><ul><li><p>测试脚手架</p><p><em>test fixture</em> 表示为了开展一项或多项测试所需要进行的准备工作，以及所有相关的清理操作。举个例子，这可能包含创建临时或代理的数据库、目录，再或者启动一个服务器进程。</p></li><li><p>测试用例</p><p>一个测试用例是一个独立的测试单元。它检查输入特定的数据时的响应。 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 提供一个基类： <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a> ，用于新建测试用例。</p></li><li><p>测试套件</p><p><em>test suite</em> 是一系列的测试用例，或测试套件，或两者皆有。它用于归档需要一起执行的测试。</p></li><li><p>测试运行器（test runner）</p><p><em>test runner</em> 是一个用于执行和输出测试结果的组件。这个运行器可能使用图形接口、文本接口，或返回一个特定的值表示运行测试的结果。</p></li></ul><p>参见</p><ul><li><p><a href="https://docs.python.org/zh-cn/3.8/library/doctest.html#module-doctest" target="_blank" rel="noopener"><code>doctest</code></a> — 文档测试模块</p><p>另一个风格完全不同的测试模块。</p></li><li><p><a href="https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm" target="_blank" rel="noopener">Simple Smalltalk Testing: With Patterns</a></p><p>Kent Beck 的原始论文阐述了关于使用共享模式的单元测试框架。</p></li><li><p><a href="https://docs.pytest.org/" target="_blank" rel="noopener">pytest</a></p><p>第三方单元测试框架拥有轻量级易编写用例的语法.例如 <code>assert func(10) == 42</code>.</p></li><li><p><a href="https://wiki.python.org/moin/PythonTestingToolsTaxonomy" target="_blank" rel="noopener">The Python Testing Tools Taxonomy</a></p><p>这是一个关于测试工具的清单,包括功能测试和模拟mock对象库。</p></li><li><p><a href="http://lists.idyll.org/listinfo/testing-in-python" target="_blank" rel="noopener">Testing in Python Mailing List</a></p><p>用于讨论Python中测试和测试工具的讨论组</p></li></ul><p><code>Tools/unittestgui/unittestgui.py</code>脚本是用来做探索测试和执行的GUI工具。这主要是为了更加方便那些新的单元测试用例。对于生产环境而言,建议还是使用例如 <a href="https://buildbot.net/" target="_blank" rel="noopener">Buildbot</a>, <a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins</a> or <a href="http://hudson-ci.org/" target="_blank" rel="noopener">Hudson</a> 这样的持续集成工具来执行测试。</p><h2 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 模块提供了一系列创建和运行测试的工具。这一段落演示了这些工具的一小部分，但也足以满足大部分用户的需求。</p><p>这是一段简短的代码，来测试三种字符串方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStringMethods</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_upper</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(<span class="string">'foo'</span>.upper(), <span class="string">'FOO'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_isupper</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertTrue(<span class="string">'FOO'</span>.isupper())</span><br><span class="line">        self.assertFalse(<span class="string">'Foo'</span>.isupper())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_split</span><span class="params">(self)</span>:</span></span><br><span class="line">        s = <span class="string">'hello world'</span></span><br><span class="line">        self.assertEqual(s.split(), [<span class="string">'hello'</span>, <span class="string">'world'</span>])</span><br><span class="line">        <span class="comment"># check that s.split fails when the separator is not a string</span></span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(TypeError):</span><br><span class="line">            s.split(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>继承 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>unittest.TestCase</code></a> 就创建了一个测试样例。上述三个独立的测试是三个类的方法，这些方法的命名都以 <code>test</code> 开头。 这个命名约定告诉测试运行者类的哪些方法表示测试。</p><p>每个测试的关键是：调用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertEqual" target="_blank" rel="noopener"><code>assertEqual()</code></a> 来检查预期的输出； 调用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertTrue" target="_blank" rel="noopener"><code>assertTrue()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertFalse" target="_blank" rel="noopener"><code>assertFalse()</code></a> 来验证一个条件；调用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.assertRaises" target="_blank" rel="noopener"><code>assertRaises()</code></a> 来验证抛出了一个特定的异常。使用这些方法而不是 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#assert" target="_blank" rel="noopener"><code>assert</code></a> 语句是为了让测试运行者能聚合所有的测试结果并产生结果报告。</p><p>通过 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener"><code>setUp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.tearDown" target="_blank" rel="noopener"><code>tearDown()</code></a> 方法，可以设置测试开始前与完成后需要执行的指令。 在 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#organizing-tests" target="_blank" rel="noopener">组织你的测试代码</a> 中，对此有更为详细的描述。</p><p>最后的代码块中，演示了运行测试的一个简单的方法。 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.main" target="_blank" rel="noopener"><code>unittest.main()</code></a> 提供了一个测试脚本的命令行接口。当在命令行运行该测试脚本，上文的脚本生成如以下格式的输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">3</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>在调用测试脚本时添加 <code>-v</code> 参数使 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.main" target="_blank" rel="noopener"><code>unittest.main()</code></a> 显示更为详细的信息，生成如以下形式的输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test_isupper (__main__.TestStringMethods) ... ok</span><br><span class="line">test_split (__main__.TestStringMethods) ... ok</span><br><span class="line">test_upper (__main__.TestStringMethods) ... ok</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">3</span> tests <span class="keyword">in</span> <span class="number">0.001</span>s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p> 以上例子演示了 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 中最常用的、足够满足许多日常测试需求的特性。文档的剩余部分详述该框架的完整特性。 </p><h2 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h2><p>unittest 模块可以通过命令行运行模块、类和独立测试方法的测试:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -m unittest test_module1 test_module2</span><br><span class="line">python -m unittest test_module.TestClass</span><br><span class="line">python -m unittest test_module.TestClass.test_method</span><br></pre></td></tr></table></figure><p>你可以传入模块名、类或方法名或他们的任意组合。</p><p>同样的，测试模块可以通过文件路径指定:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m unittest tests/test_something.py</span><br></pre></td></tr></table></figure><p>这样就可以使用 shell 的文件名补全指定测试模块。所指定的文件仍需要可以被作为模块导入。路径通过去除 ‘.py’ 、把分隔符转换为 ‘.’ 转换为模块名。若你需要执行不能被作为模块导入的测试文件，你需要直接执行该测试文件。</p><p>在运行测试时，你可以通过添加 -v 参数获取更详细（更多的冗余）的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m unittest -v test_module</span><br></pre></td></tr></table></figure><p>当运行时不包含参数，开始 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest-test-discovery" target="_blank" rel="noopener">探索性测试</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m unittest</span><br></pre></td></tr></table></figure><p>用于获取命令行选项列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m unittest -h</span><br></pre></td></tr></table></figure><p> <em>在 3.2 版更改:</em> 在早期版本中，只支持运行独立的测试方法，而不支持模块和类。 </p><h3 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h3><p><strong>unittest</strong> 支持下面的命令行选项:</p><ul><li><p><code>-b, --buffer</code></p><p>在测试运行时，标准输出流与标准错误流会被放入缓冲区。成功的测试的运行时输出会被丢弃；测试不通过时，测试运行中的输出会正常显示，错误会被加入到测试失败信息。</p></li><li><p><code>-c, --catch</code></p><p>当测试正在运行时， Control-C 会等待当前测试完成，并在完成后报告已执行的测试的结果。当再次按下 Control-C 时，引发平常的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyboardInterrupt" target="_blank" rel="noopener"><code>KeyboardInterrupt</code></a> 异常。See <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#signal-handling" target="_blank" rel="noopener">Signal Handling</a> for the functions that provide this functionality.</p></li><li><p><code>-f, --failfast</code></p><p>当出现第一个错误或者失败时，停止运行测试。</p></li><li><p><code>-k</code></p><p>只运行匹配模式或子串的测试方法和类。可以多次使用这个选项，以便包含匹配子串的所有测试用例。包含通配符（*）的模式使用 <a href="https://docs.python.org/zh-cn/3.8/library/fnmatch.html#fnmatch.fnmatchcase" target="_blank" rel="noopener"><code>fnmatch.fnmatchcase()</code></a> 对测试名称进行匹配。另外，该匹配是大小写敏感的。模式对测试加载器导入的测试方法全名进行匹配。例如，<code>-k foo</code> 可以匹配到 <code>foo_tests.SomeTest.test_something</code> 和 <code>bar_tests.SomeTest.test_foo</code> ，但是不能匹配到 <code>bar_tests.FooTest.test_something</code> 。</p></li><li><p><code>--locals</code></p><p>在回溯中显示局部变量。</p></li></ul><p><em>3.2 新版功能:</em> 添加命令行选项 <code>-b</code>, <code>-c</code> 和 <code>-f</code> 。</p><p><em>3.5 新版功能:</em> 命令行选项 <code>--locals</code> 。</p><p><em>3.7 新版功能:</em> 命令行选项 <code>-k</code> 。</p><p>命令行亦可用于探索性测试，以运行一个项目的所有测试或其子集。</p><h2 id="探索性测试"><a href="#探索性测试" class="headerlink" title="探索性测试"></a>探索性测试</h2><p><em>3.2 新版功能.</em></p><p>Unittest支持简单的测试搜索。若需要使用探索性测试，所有的测试文件必须是 <a href="https://docs.python.org/zh-cn/3.8/tutorial/modules.html#tut-modules" target="_blank" rel="noopener">modules</a> 或 <a href="https://docs.python.org/zh-cn/3.8/tutorial/modules.html#tut-packages" target="_blank" rel="noopener">packages</a> （包括 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-namespace-package" target="_blank" rel="noopener">namespace packages</a> )并可从项目根目录导入（即它们的文件名必须是有效的 <a href="https://docs.python.org/zh-cn/3.8/reference/lexical_analysis.html#identifiers" target="_blank" rel="noopener">identifiers</a> ）。</p><p>探索性测试在 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestLoader.discover" target="_blank" rel="noopener"><code>TestLoader.discover()</code></a> 中实现，但也可以通过命令行使用。它在命令行中的基本用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd project_directory</span><br><span class="line">python -m unittest discover</span><br></pre></td></tr></table></figure><blockquote><p>方便起见， <code>python -m unittest</code> 与 <code>python -m unittest discover</code> 等价。如果你需要向探索性测试传入参数，必须显式地使用 <code>discover</code> 子命令。</p></blockquote><p><code>discover</code> 有以下选项：</p><ul><li><p><code>-v, --verbose</code></p><p>更详细地输出结果。</p></li><li><p><code>-s, --start-directory directory</code></p><p>开始进行搜索的目录(默认值为当前目录 <code>.</code> )。</p></li><li><p><code>-p, --pattern pattern</code></p><p>用于匹配测试文件的模式（默认为 <code>test*.py</code> ）。</p></li><li><p><code>-t, --top-level-directory directory</code></p><p>指定项目的最上层目录（通常为开始时所在目录）。</p></li></ul><p><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#cmdoption-unittest-discover-s" target="_blank" rel="noopener"><code>-s</code></a> ，<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#cmdoption-unittest-discover-p" target="_blank" rel="noopener"><code>-p</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#cmdoption-unittest-discover-t" target="_blank" rel="noopener"><code>-t</code></a> 选项可以按顺序作为位置参数传入。以下两条命令是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m unittest discover -s project_directory -p <span class="string">"*_test.py"</span></span><br><span class="line">python -m unittest discover project_directory <span class="string">"*_test.py"</span></span><br></pre></td></tr></table></figure><p>正如可以传入路径那样，传入一个包名作为起始目录也是可行的，如 <code>myproject.subpackage.test</code> 。你提供的包名会被导入，它在文件系统中的位置会被作为起始目录。</p><blockquote><p>探索性测试通过导入测试对测试进行加载。在找到所有你指定的开始目录下的所有测试文件后，它把路径转换为包名并进行导入。如 <code>foo/bar/baz.py</code> 会被导入为 <code>foo.bar.baz</code> 。</p></blockquote><p>如果你有一个全局安装的包，并尝试对这个包的副本进行探索性测试，可能会从错误的地方开始导入。如果出现这种情况，测试会输出警告并退出。</p><p>如果你使用包名而不是路径作为开始目录，搜索时会假定它导入的是你想要的目录，所以你不会收到警告。</p><p>测试模块和包可以通过 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#load-tests-protocol" target="_blank" rel="noopener">load_tests protocol</a> 自定义测试的加载和搜索。</p><p><em>在 3.4 版更改:</em> 探索性测试支持命名空间包（ <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-namespace-package" target="_blank" rel="noopener">namespace packages</a> ）。</p><h2 id="组织你的测试代码"><a href="#组织你的测试代码" class="headerlink" title="组织你的测试代码"></a>组织你的测试代码</h2><p>单元测试的构建单位是 <em>test cases</em> ：独立的、包含执行条件与正确性检查的方案。在 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 中，测试用例表示为 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>unittest.TestCase</code></a> 的实例。通过编写 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a> 的子类或使用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.FunctionTestCase" target="_blank" rel="noopener"><code>FunctionTestCase</code></a> 编写你自己的测试用例。</p><p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a> 实例的测试代码必须是完全自含的，因此它可以独立运行，或与其它任意组合任意数量的测试用例一起运行。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a> 的最简单的子类需要实现一个测试方法（例如一个命名以 <code>test</code> 开头的方法）以执行特定的测试代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultWidgetSizeTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_default_widget_size</span><span class="params">(self)</span>:</span></span><br><span class="line">        widget = Widget(<span class="string">'The widget'</span>)</span><br><span class="line">        self.assertEqual(widget.size(), (<span class="number">50</span>, <span class="number">50</span>))</span><br></pre></td></tr></table></figure><p>可以看到，为了进行测试，我们使用了基类 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a> 提供的其中一个 <code>assert*()</code> 方法。若测试不通过，将会引发一个带有说明信息的异常，并且 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 会将这个测试用例标记为测试不通过。任何其它类型的异常将会被当做错误处理。</p><p>可能同时存在多个前置操作相同的测试，我们可以把测试的前置操作从测试代码中拆解出来，并实现测试前置方法 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener"><code>setUp()</code></a> 。在运行测试时，测试框架会自动地为每个单独测试调用前置方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.widget = Widget(<span class="string">'The widget'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_default_widget_size</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(self.widget.size(), (<span class="number">50</span>,<span class="number">50</span>),</span><br><span class="line">                         <span class="string">'incorrect default size'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_widget_resize</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.widget.resize(<span class="number">100</span>,<span class="number">150</span>)</span><br><span class="line">        self.assertEqual(self.widget.size(), (<span class="number">100</span>,<span class="number">150</span>),</span><br><span class="line">                         <span class="string">'wrong size after resize'</span>)</span><br></pre></td></tr></table></figure><blockquote><p> 多个测试运行的顺序由内置字符串排序方法对测试名进行排序的结果决定。 </p></blockquote><p>在测试运行时，若 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener"><code>setUp()</code></a> 方法引发异常，测试框架会认为测试发生了错误，因此测试方法不会被运行。</p><p>相似的，我们提供了一个 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.tearDown" target="_blank" rel="noopener"><code>tearDown()</code></a> 方法在测试方法运行后进行清理工作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.widget = Widget(<span class="string">'The widget'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.widget.dispose()</span><br></pre></td></tr></table></figure><p>若 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener"><code>setUp()</code></a> 成功运行，无论测试方法是否成功，都会运行 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.tearDown" target="_blank" rel="noopener"><code>tearDown()</code></a> 。</p><p>这样的一个测试代码运行的环境被称为 <em>test fixture</em> 。一个新的 TestCase 实例作为一个测试脚手架，用于运行各个独立的测试方法。在运行每个测试时，<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener"><code>setUp()</code></a> 、<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.tearDown" target="_blank" rel="noopener"><code>tearDown()</code></a> 和 <code>__init__()</code> 会被调用一次。</p><p>建议使用TestCase来实现根据测试实现的功能将测试组合在一起。·单元测试通机制,在一个测试集中的测试套件中组织的方式。</p><p>通常情况,调用<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.main" target="_blank" rel="noopener"><code>unittest.main()</code></a>来执行测试。</p><p>然而，如果你需要自定义你的测试套件的话，你可以参考以下方法组织你的测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">suite</span><span class="params">()</span>:</span></span><br><span class="line">    suite = unittest.TestSuite()</span><br><span class="line">    suite.addTest(WidgetTestCase(<span class="string">'test_default_widget_size'</span>))</span><br><span class="line">    suite.addTest(WidgetTestCase(<span class="string">'test_widget_resize'</span>))</span><br><span class="line">    <span class="keyword">return</span> suite</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    runner = unittest.TextTestRunner()</span><br><span class="line">    runner.run(suite())</span><br></pre></td></tr></table></figure><p>您可以将测试用例和测试套件的定义与它们要测试的代码放在相同的模块中（例如“ widget.py”），但是将测试代码放置在独立的模块中有很多优点，例如“ test_widget.py`：</p><p>你可以遵循以下原则：</p><ul><li>测试模块可以通过命令行方式单独运行</li><li>测试脚本可以很容易被隔离</li><li>在没有充分理由的情况下,尽量不要为了适配代码而修改测试代码。</li><li>测试代码的修改频率应低于其测试的代码。</li><li>测试的代码可以更容易地重构。</li><li>无论如何用c编写的模块都必须在一个模块中隔离,为什么必须要一致呢？</li><li>如果测试策略更改了,没必要去修改测试代码</li></ul><h2 id="复用已有的测试代码"><a href="#复用已有的测试代码" class="headerlink" title="复用已有的测试代码"></a>复用已有的测试代码</h2><p>一些用户希望直接使用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 运行已有的测试代码，而不需要把已有的每个测试函数转化为一个 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a> 的子类。</p><p>因此， <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a> 提供 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.FunctionTestCase" target="_blank" rel="noopener"><code>FunctionTestCase</code></a> 类。这个 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a> 的子类可用于打包已有的测试函数，并支持设置前置与后置函数。</p><p>假定有一个测试函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testSomething</span><span class="params">()</span>:</span></span><br><span class="line">    something = makeSomething()</span><br><span class="line">    <span class="keyword">assert</span> something.name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>可以创建等价的测试用例如下，其中前置和后置方法是可选的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testcase = unittest.FunctionTestCase(testSomething,</span><br><span class="line">                                     setUp=makeSomethingDB,</span><br><span class="line">                                     tearDown=deleteSomethingDB)</span><br></pre></td></tr></table></figure><blockquote><p> 尽管 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.FunctionTestCase" target="_blank" rel="noopener"><code>FunctionTestCase</code></a> 可以快速将一个已经存在的测试转换为基于<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#module-unittest" target="_blank" rel="noopener"><code>unittest</code></a>的系统,但是不推荐这么做。好好设计<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener"><code>TestCase</code></a>子类将会在未来重构代码变得更容易。</p></blockquote><p>在特定情况下,现有的测试可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/doctest.html#module-doctest" target="_blank" rel="noopener"><code>doctest</code></a>  模块。如果是那样,  会绑定<code>DocTestSuite</code> 类从已经存在的  <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestSuite" target="_blank" rel="noopener"><code>unittest.TestSuite</code></a> 自动构建 基于<a href="https://docs.python.org/zh-cn/3.8/library/doctest.html#module-doctest" target="_blank" rel="noopener"><code>doctest</code></a>  实例。</p><h2 id="忽略测试与预计的失败"><a href="#忽略测试与预计的失败" class="headerlink" title="忽略测试与预计的失败"></a>忽略测试与预计的失败</h2><p><em>3.1 新版功能.</em></p><p><code>Unittest</code> 支持忽略测试方法或者忽略整个测试。除此以外,还支持标注某个测试”强制失败”,但是在<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestResult" target="_blank" rel="noopener"><code>TestResult</code></a> 中不会体现这类测试为失败。</p><p>忽略测试可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.skip" target="_blank" rel="noopener"><code>skip()</code></a> <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-decorator" target="_blank" rel="noopener">decorator</a> 装饰器,或者其中一些条件变量,直接添加<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.SkipTest" target="_blank" rel="noopener"><code>SkipTest</code></a> 注解</p><p>忽略测试的基本用法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @unittest.skip("demonstrating skipping")</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_nothing</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fail(<span class="string">"shouldn't happen"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @unittest.skipIf(mylib.__version__ &lt; (1, 3),</span></span><br><span class="line">                     <span class="string">"not supported in this library version"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_format</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Tests that work for only a certain version of the library.</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @unittest.skipUnless(sys.platform.startswith("win"), "requires Windows")</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_windows_support</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># windows specific testing code</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_maybe_skipped</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> external_resource_available():</span><br><span class="line">            self.skipTest(<span class="string">"external resource not available"</span>)</span><br><span class="line">        <span class="comment"># test code that depends on the external resource</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在详细测试模式下运行以上测试例子时，程序输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test_format (__main__.MyTestCase) ... skipped <span class="string">'not supported in this library version'</span></span><br><span class="line">test_nothing (__main__.MyTestCase) ... skipped <span class="string">'demonstrating skipping'</span></span><br><span class="line">test_maybe_skipped (__main__.MyTestCase) ... skipped <span class="string">'external resource not available'</span></span><br><span class="line">test_windows_support (__main__.MyTestCase) ... skipped <span class="string">'requires Windows'</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">4</span> tests <span class="keyword">in</span> <span class="number">0.005</span>s</span><br><span class="line"></span><br><span class="line">OK (skipped=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>忽略测试类的写法跟忽略测试方法的写法相似:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@unittest.skip("showing class skipping")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySkippedTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_not_run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener"><code>TestCase.setUp()</code></a> 也可以忽略测试。可以用于所需资源不可用的情况下忽略接下来的测试。</p><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.expectedFailure" target="_blank" rel="noopener"><code>expectedFailure()</code></a> 装饰器表明这个测试预计失败。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpectedFailureTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"><span class="meta">    @unittest.expectedFailure</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_fail</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"broken"</span>)</span><br></pre></td></tr></table></figure><p>通过测试方法中调用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.skip" target="_blank" rel="noopener"><code>skip()</code></a>装饰器，可以轻松忽略那些希望被忽略的测试。除非传递的对象具有某个属性，否则此装饰器将起作用,如下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">skipUnlessHasattr</span><span class="params">(obj, attr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(obj, attr):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> func: func</span><br><span class="line">    <span class="keyword">return</span> unittest.skip(<span class="string">"&#123;!r&#125; doesn't have &#123;!r&#125;"</span>.format(obj, attr))</span><br></pre></td></tr></table></figure><p>下面的装饰器和异常处理可以直接忽略期望失败的测试:</p><ul><li><p><a href="mailto:`@unittest.skip" target="_blank" rel="noopener">`@unittest.skip</a>`(<em>reason</em>)</p><p>忽略被此装饰器装饰的测试。 <em>reason</em> 为测试被忽略的原因。</p></li><li><p><a href="mailto:`@unittest.skipIf" target="_blank" rel="noopener">`@unittest.skipIf</a>`(<em>condition</em>, <em>reason</em>)</p><p>当 <em>condition</em> 为真时，忽略被装饰的测试。</p></li><li><p><a href="mailto:`@unittest.skipUnless" target="_blank" rel="noopener">`@unittest.skipUnless</a>`(<em>condition</em>, <em>reason</em>)</p><p>忽略被装饰的测试，除非 <em>condition</em> 为真。</p></li><li><p><a href="mailto:`@unittest.expectedFailure" target="_blank" rel="noopener">`@unittest.expectedFailure</a>`</p><p>把测试标记为预计失败。如果测试不通过，会被认为测试成功；如果测试通过了，则被认为是测试失败。</p></li><li><p><em>exception</em> <code>unittest.SkipTest</code>(<em>reason</em>)</p><p>引发此异常以忽略一个测试。通常来说，你可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.skipTest" target="_blank" rel="noopener"><code>TestCase.skipTest()</code></a> 或其中一个忽略测试的装饰器实现忽略测试的功能，而不是直接引发此异常。</p></li></ul><p>被忽略的测试的 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener"><code>setUp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.tearDown" target="_blank" rel="noopener"><code>tearDown()</code></a> 不会被运行。被忽略的类的 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.setUpClass" target="_blank" rel="noopener"><code>setUpClass()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.tearDownClass" target="_blank" rel="noopener"><code>tearDownClass()</code></a> 不会被运行。被忽略的模组的 <code>setUpModule()</code> 和 <code>tearDownModule()</code> 不会被运行。</p><h2 id="使用-subtest-执行Distinguishing-test迭代"><a href="#使用-subtest-执行Distinguishing-test迭代" class="headerlink" title="使用 subtest 执行Distinguishing test迭代"></a>使用 subtest 执行Distinguishing test迭代</h2><p><em>3.4 新版功能.</em></p><p>如果测试之间的差异很小，例如某些参数，则unittest允许您使用<a href="https://docs.python.org/zh-cn/3.8/library/unittest.html#unittest.TestCase.subTest" target="_blank" rel="noopener"><code>subTest()</code></a> 的上下文装饰器</p><p>例如，以下测试:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumbersTest</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_even</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Test that numbers between 0 and 5 are all even.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">6</span>):</span><br><span class="line">            <span class="keyword">with</span> self.subTest(i=i):</span><br><span class="line">                self.assertEqual(i % <span class="number">2</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>可以得到以下输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">======================================================================</span><br><span class="line">FAIL: test_even (__main__.NumbersTest) (i=<span class="number">1</span>)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"subtests.py"</span>, line <span class="number">32</span>, <span class="keyword">in</span> test_even</span><br><span class="line">    self.assertEqual(i % <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">AssertionError: <span class="number">1</span> != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_even (__main__.NumbersTest) (i=<span class="number">3</span>)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"subtests.py"</span>, line <span class="number">32</span>, <span class="keyword">in</span> test_even</span><br><span class="line">    self.assertEqual(i % <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">AssertionError: <span class="number">1</span> != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_even (__main__.NumbersTest) (i=<span class="number">5</span>)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"subtests.py"</span>, line <span class="number">32</span>, <span class="keyword">in</span> test_even</span><br><span class="line">    self.assertEqual(i % <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">AssertionError: <span class="number">1</span> != <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果不使用子测试，则在第一次失败后执行将停止，并且错误将不那么容易诊断，因为不会显示<code>i</code>的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">======================================================================</span><br><span class="line">FAIL: test_even (__main__.NumbersTest)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"subtests.py"</span>, line <span class="number">32</span>, <span class="keyword">in</span> test_even</span><br><span class="line">    self.assertEqual(i % <span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">AssertionError: <span class="number">1</span> != <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-unittest&quot;&gt;&lt;a href=&quot;#python-标准库-unittest&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 unittest&quot;&gt;&lt;/a&gt;python 标准库 unittest&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200225unit-test.png?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="unittest" scheme="https://pinghailinfeng.gitee.io/tags/unittest/"/>
    
  </entry>
  
  <entry>
    <title>python standard library binascii</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/24/python-standard-library-binascii/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/24/python-standard-library-binascii/</id>
    <published>2020-02-24T15:25:31.000Z</published>
    <updated>2020-02-24T16:04:58.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-binascii"><a href="#python-标准库-binascii" class="headerlink" title="python 标准库 binascii"></a>python 标准库 binascii</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200224_Happy-Hero-Day.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>the love of father is like a mountain  父爱如山</p></blockquote><p><a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#module-binascii" target="_blank" rel="noopener"><code>binascii</code></a> 模块包含很多在二进制和二进制表示的各种ASCII码之间转换的方法。 通常情况不会直接使用这些函数，而是使用像 <a href="https://docs.python.org/zh-cn/3.8/library/uu.html#module-uu" target="_blank" rel="noopener"><code>uu</code></a> ， <a href="https://docs.python.org/zh-cn/3.8/library/base64.html#module-base64" target="_blank" rel="noopener"><code>base64</code></a> ，或 <a href="https://docs.python.org/zh-cn/3.8/library/binhex.html#module-binhex" target="_blank" rel="noopener"><code>binhex</code></a> 这样的封装模块。 为了执行效率高，<a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#module-binascii" target="_blank" rel="noopener"><code>binascii</code></a> 模块含有许多用 C 写的低级函数，这些底层函数被一些高级模块所使用。</p><blockquote><p> <code>a2b_*</code> 函数接受只含有 ASCII 码的Unicode 字符串。其他函数只接受 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> （例如 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 和其他支持缓冲区协议的对象）。</p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p><code>binascii.a2b_uu</code>(<em>string</em>)</p><p>将单行 uu 编码数据转换成二进制数据并返回。uu 编码每行的数据通常包含45 个（二进制）字节，最后一行除外。每行数据后面可能跟有空格。</p></li><li><p><code>binascii.b2a_uu</code>(<em>data</em>, <em>**, </em>backtick=False*)</p><p>将二进制数据转换为 ASCII 编码字符，返回值是转换后的行数据，包括换行符。 <em>data</em> 的长度最多为45。如果 <em>backtick</em> 为ture，则零由 <code>&#39;</code>‘` 而不是空格表示。<em>在 3.7 版更改:</em> 增加 <em>backtick</em> 形参。</p></li><li><p><code>binascii.a2b_base64</code>(<em>string</em>)</p><p>将 base64 数据块转换成二进制并以二进制数据形式返回。一次可以传递多行数据。</p></li><li><p><code>binascii.b2a_base64</code>(<em>data</em>, <em>**, </em>newline=True*)</p><p>将二进制数据转换为一行用 base64 编码的ASCII字符串。返回值是转换后的行数据，如果 <em>newline</em> 为true，则返回值包括换行符。该函数的输出符合：rfc：3548。<em>在 3.6 版更改:</em> 增加 <em>newline</em> 形参。</p></li><li><p><code>binascii.a2b_qp</code>(<em>data</em>, <em>header=False</em>)</p><p>将一个引号可打印的数据块转换成二进制数据并返回。一次可以转换多行。如果可选参数 <em>header</em> 存在且为true，则数据中的下划线将被解码成空格。</p></li><li><p><code>binascii.b2a_qp</code>(<em>data</em>, <em>quotetabs=False</em>, <em>istext=True</em>, <em>header=False</em>)</p><p>将二进制数据转换为一行或多行带引号可打印编码的ASCII字符串。返回值是转换后的行数据。如果可选参数 <em>quotetabs</em> 存在且为真值，则对所有制表符和空格进行编码。如果可选参数 <em>istext</em> 存在且为真值，则不对新行进行编码，但将对尾随空格进行编码。如果可选参数 <em>header</em> 存在且为true，则空格将被编码为下划线 <a href="https://tools.ietf.org/html/rfc1522.html" target="_blank" rel="noopener"><strong>RFC 1522</strong></a>。如果可选参数 <em>header</em> 存在且为假值，则也会对换行符进行编码;不进行换行转换编码可能会破坏二进制数据流。</p></li><li><p><code>binascii.a2b_hqx</code>(<em>string</em>)</p><p>将 binhex4 格式的 ASCII 数据不进行 RLE 解压缩直接转换为二进制数据。该字符串应包含完整数量的二进制字节，或者（在binhex4 数据最后部分）剩余位为零。</p></li><li><p><code>binascii.rledecode_hqx</code>(<em>data</em>)</p><p>根据 binhex4 标准对数据执行 RLE 解压缩。该算法在一个字节的数据后使用 <code>0x90</code> 作为重复指示符，然后计数。计数 <code>0</code> 指定字节值 <code>0x90</code> 。该例程返回解压缩的数据，输入数据以孤立的重复指示符结束的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#binascii.Incomplete" target="_blank" rel="noopener"><code>Incomplete</code></a> 异常。<em>在 3.2 版更改:</em> 仅接受 bytestring 或 bytearray 对象作为输入。</p></li><li><p><code>binascii.rlecode_hqx</code>(<em>data</em>)</p><p>在 <em>data</em> 上执行 binhex4 游程编码压缩并返回结果。</p></li><li><p><code>binascii.b2a_hqx</code>(<em>data</em>)</p><p>执行 hexbin4 类型二进制到 ASCII 码的转换并返回结果字符串。输入数据应经过 RLE 编码，且数据长度可被3整除（除了最后一个片段）。</p></li><li><p><code>binascii.crc_hqx</code>(<em>data</em>, <em>value</em>)</p><p>以 <em>value</em> 作为初始 CRC 计算 <em>data</em> 的16位 CRC 值，返回其结果。这里使用 CRC-CCITT 生成多项式 <em>x</em>16 + <em>x</em>12 + <em>x</em>5 + 1 ，通常表示为0x1021。该 CRC 被用于 binhex4 格式。</p></li><li><p><code>binascii.crc32</code>(<em>data</em>[, <em>value</em>])</p><p>计算 CRC-32 ，从 <em>value</em> 的初始 CRC 开始计算 <em>data</em> 的32位校验和。默认初始 CRC 为零。该算法与 ZIP 文件校验和一致。由于该算法被设计用作校验和算法，因此不适合用作通用散列算法。使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(binascii.crc32(<span class="string">b"hello world"</span>))</span><br><span class="line"><span class="comment"># Or, in two pieces:</span></span><br><span class="line">crc = binascii.crc32(<span class="string">b"hello"</span>)</span><br><span class="line">crc = binascii.crc32(<span class="string">b" world"</span>, crc)</span><br><span class="line">print(<span class="string">'crc32 = &#123;:#010x&#125;'</span>.format(crc))</span><br></pre></td></tr></table></figure><p><em>在 3.0 版更改:</em> 校验结果始终是无符号类型的。要在所有Python版本和平台上生成相同的数值，请使用 <code>crc32(data) &amp; 0xffffffff</code> 。</p></li><li><p><code>binascii.b2a_hex</code>(<em>data</em>[, <em>sep</em>[, <em>bytes_per_sep=1</em>]])</p></li><li><p><code>binascii.hexlify</code>(<em>data</em>[, <em>sep</em>[, <em>bytes_per_sep=1</em>]])</p><p>返回二进制数据 <em>data</em> 的十六进制表示形式。 <em>data</em> 的每个字节都被转换为相应的2位十六进制表示形式。因此返回的字节对象的长度是 <em>data</em> 的两倍。</p><p>使用：<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes.hex" target="_blank" rel="noopener"><code>bytes.hex()</code></a> 方法也可以方便地实现相似的功能（但仅返回文本字符串）。</p><p>如果指定了 <em>sep</em>，它必须为单字符 str 或 bytes 对象。 它将被插入每个 <em>bytes_per_sep</em> 输入字节之后。 分隔符位置默认从输出的右端开始计数，如果你希望从左端开始计数，请提供一个负的 <em>bytes_per_sep</em> 值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> binascii</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.b2a_hex(<span class="string">b'\xb9\x01\xef'</span>)</span><br><span class="line"><span class="string">b'b901ef'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.hexlify(<span class="string">b'\xb9\x01\xef'</span>, <span class="string">'-'</span>)</span><br><span class="line"><span class="string">b'b9-01-ef'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.b2a_hex(<span class="string">b'\xb9\x01\xef'</span>, <span class="string">b'_'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">b'b9_01ef'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>binascii.b2a_hex(<span class="string">b'\xb9\x01\xef'</span>, <span class="string">b' '</span>, <span class="number">-2</span>)</span><br><span class="line"><span class="string">b'b901 ef'</span></span><br></pre></td></tr></table></figure><p><em>在 3.8 版更改:</em> 添加了 <em>sep</em> 和 <em>bytes_per_sep</em> 形参。</p></li><li><p><code>binascii.a2b_hex</code>(<em>hexstr</em>)</p></li><li><p><code>binascii.unhexlify</code>(<em>hexstr</em>)</p><p>返回由十六进制字符串 <em>hexstr</em> 表示的二进制数据。此函数功能与 <a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#binascii.b2a_hex" target="_blank" rel="noopener"><code>b2a_hex()</code></a> 相反。 <em>hexstr</em> 必须包含偶数个十六进制数字（可以是大写或小写），否则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/binascii.html#binascii.Error" target="_blank" rel="noopener"><code>Error</code></a> 异常。</p><p>使用：<a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes.fromhex" target="_blank" rel="noopener"><code>bytes.fromhex()</code></a> 类方法也实现相似的功能（仅接受文本字符串参数，不限制其中的空白字符）。</p></li><li><p><em>exception</em> <code>binascii.Error</code></p><p>通常是因为编程错误引发的异常。</p></li><li><p><em>exception</em> <code>binascii.Incomplete</code></p><p>数据不完整引发的异常。通常不是编程错误导致的，可以通过读取更多的数据并再次尝试来处理该异常。</p></li></ul><blockquote><p>参见:</p><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/base64.html#module-base64" target="_blank" rel="noopener"><code>base64</code></a></p><p>支持在16，32，64，85进制中进行符合 RFC 协议的 base64 样式编码。</p><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/binhex.html#module-binhex" target="_blank" rel="noopener"><code>binhex</code></a></p><p>支持在 Macintosh 上使用的 binhex 格式。</p><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/uu.html#module-uu" target="_blank" rel="noopener"><code>uu</code></a></p><p>支持在 Unix 上使用的 UU 编码。</p><p>模块 <a href="https://docs.python.org/zh-cn/3.8/library/quopri.html#module-quopri" target="_blank" rel="noopener"><code>quopri</code></a></p><p>支持在 MIME 版本电子邮件中使用引号可打印编码。</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment"># 导入binascii模块</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"> </span><br><span class="line">a = <span class="string">b'BE27E8FFFF010203'</span></span><br><span class="line"><span class="comment"># 先把b'BE27E8FFFF010203'转换成二进制数据然后在用十六进制表示</span></span><br><span class="line">b = binascii.b2a_hex(a)</span><br><span class="line"><span class="comment"># 打印出：b'42453237453846464646303130323033'，例如B对应ascii码42，E对应ascii码45</span></span><br><span class="line">print(b)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 与b2a_hex相反，打印出：b'BE27E8FFFF010203'</span></span><br><span class="line">print(binascii.a2b_hex(b))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个功能和b2a_hex()一样</span></span><br><span class="line"><span class="comment"># 打印出：b'42453237453846464646303130323033'，例如B对应ascii码42，E对应ascii码45</span></span><br><span class="line">c = binascii.hexlify(a)</span><br><span class="line">print(c)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这个功能和a2b_hex()一样，打印出：b'BE27E8FFFF010203'</span></span><br><span class="line">print(binascii.unhexlify(c))</span><br></pre></td></tr></table></figure><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">a = <span class="string">'hello world'</span></span><br><span class="line"><span class="comment">#先把a转换成二进制数据然后在用十六进制表示</span></span><br><span class="line">b = binascii.b2a_hex(a)</span><br><span class="line">c = binascii.hexlify(a)<span class="comment">#和a2b_hex()功能是一样的,但是推荐用这个函数,具体不清楚= =</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;0:10s&#125;'</span>.format(<span class="string">'b2a_hex'</span>),</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(b),<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">print</span> b[i:i+<span class="number">2</span>],</span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment">#到这是不是发现了,利用b2a_hex()返回的字符串长度为原串的两倍,因为转换为十六进制,一个字节用两个字节表示了</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;0:10s&#125;'</span>.format(<span class="string">'hexlify'</span>),</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(c),<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">print</span> c[i:i+<span class="number">2</span>],   </span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'&#123;0:10s&#125;'</span>.format(<span class="string">'ord'</span>),</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">print</span> hex(ord(i))[<span class="number">2</span>:],<span class="comment">#手动转换为二进制十六进制</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#与b2a_hex相反</span></span><br><span class="line"><span class="keyword">print</span> binascii.a2b_hex(b)</span><br><span class="line"><span class="keyword">print</span> binascii.unhexlify(c)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">result:</span></span><br><span class="line"><span class="string">b2a_hex    68 65 6c 6c 6f 20 77 6f 72 6c 64</span></span><br><span class="line"><span class="string">hexlify    68 65 6c 6c 6f 20 77 6f 72 6c 64</span></span><br><span class="line"><span class="string">ord        68 65 6c 6c 6f 20 77 6f 72 6c 64</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">d1 = datetime.datetime(<span class="number">2019</span>,<span class="number">4</span>,<span class="number">7</span>)</span><br><span class="line">d2 = datetime.datetime(<span class="number">2020</span>,<span class="number">2</span>,<span class="number">24</span>)</span><br><span class="line">print(d2-d1)</span><br></pre></td></tr></table></figure><blockquote><p>父亲离开我已经过去了323天。</p><p>今天整理云盘,发现了父亲的照片。</p><p>心里很难受。</p><p>父亲平时少言寡语。不太喜欢和我们交流。</p><p>最后一次和父亲聊天,是19年3月底,医院住院的时候。</p><p>他说:鑫儿,昨天大夫查房和说我了,我是个定时炸弹,随时都会爆发。栓塞已经不是主要问题了。指了指心。这里是大问题。这个3到5分钟就过去了。父亲顿了顿,继续说：存着都在你妈那里，我要是万一哪天过去了,就找你妈要,你和你姐都有份,你姐身体不好,孩子还上大学,你就多让点你姐,你还年轻,以后还有机会赚钱。</p><p>我调侃道：您这是要交代后事啊?</p><p>父亲说,对啊，现在说了,我就了心思了。能活一天算一天。</p><p>我不知道该说些什么。只能扶着父亲在医院走廊里继续走啊，走啊。</p><p>想起我小时候拉着父亲的手过马路的情形。和这时候差不多。父亲的腿因为栓塞，没有劲,需要拄着拐杖才能慢慢挪动脚步。</p><p>谁能想到这次谈话,竟是永别。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-binascii&quot;&gt;&lt;a href=&quot;#python-标准库-binascii&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 binascii&quot;&gt;&lt;/a&gt;python 标准库 binascii&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200224_Happy-Hero-Day.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python standard library gc</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/23/python_standard_library_gc/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/23/python_standard_library_gc/</id>
    <published>2020-02-23T13:12:27.000Z</published>
    <updated>2020-02-24T16:14:33.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-gc"><a href="#python-标准库-gc" class="headerlink" title="python 标准库 gc"></a>python 标准库 gc</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200224_father.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>离开的时候,才会记得你。</p></blockquote><p>此模块提供可选的垃圾回收器的接口，提供的功能包括：关闭收集器、调整收集频率、设置调试选项。它同时提供对回收器找到但是无法释放的不可达对象的访问。由于 Python 使用了带有引用计数的回收器，如果你确定你的程序不会产生循环引用，你可以关闭回收器。可以通过调用 <code>gc.disable()</code> 关闭自动垃圾回收。若要调试一个存在内存泄漏的程序，调用 <code>gc.set_debug(gc.DEBUG_LEAK)</code> ；需要注意的是，它包含 <code>gc.DEBUG_SAVEALL</code> ，使得被垃圾回收的对象会被存放在 gc.garbage 中以待检查。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/gc.html#module-gc" target="_blank" rel="noopener"><code>gc</code></a> 模块提供下列函数：</p><ul><li><p><code>gc.enable</code>()</p><p>启用自动垃圾回收</p></li><li><p><code>gc.disable</code>()</p><p>停用自动垃圾回收</p></li><li><p><code>gc.isenabled</code>()</p><p>如果启用了自动回收则返回 <code>True</code>。</p></li><li><p><code>gc.collect</code>(<em>generation=2</em>)</p><p>若被调用时不包含参数，则启动完全的垃圾回收。可选的参数 <em>generation</em> 可以是一个整数，指明需要回收哪一代（从 0 到 2 ）的垃圾。当参数 <em>generation</em> 无效时，会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。返回发现的不可达对象的数目。每当运行完整收集或最高代 (2) 收集时，为多个内置类型所维护的空闲列表会被清空。 由于特定类型特别是 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#float" target="_blank" rel="noopener"><code>float</code></a> 的实现，在某些空闲列表中并非所有项都会被释放。</p></li><li><p><code>gc.set_debug</code>(<em>flags</em>)</p><p>设置垃圾回收器的调试标识位。调试信息会被写入 <code>sys.stderr</code> 。此文档末尾列出了各个标志位及其含义；可以使用位操作对多个标志位进行设置以控制调试器。</p></li><li><p><code>gc.get_debug</code>()</p><p>返回当前调试标识位。</p></li><li><p><code>gc.get_objects</code>(<em>generation=None</em>)</p><p>返回一个收集器所跟踪的所有对象的列表，所返回的列表除外。 如果 <em>generation</em> 不为 None，则只返回收集器所跟踪的属于该生成的对象。<em>在 3.8 版更改:</em> 新的 <em>generation</em> 形参。</p></li><li><p><code>gc.get_stats</code>()</p><p>返回一个包含三个字典对象的列表，每个字典分别包含对应代的从解释器开始运行的垃圾回收统计数据。字典的键的数目在将来可能发生改变，目前每个字典包含以下内容：<code>collections</code> 是该代被回收的次数；<code>collected</code> 是该代中被回收的对象总数；<code>uncollectable</code> 是在这一代中被发现无法收集的对象总数 （因此被移动到 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>garbage</code></a> 列表中）。<em>3.4 新版功能.</em></p></li><li><p><code>gc.set_threshold</code>(<em>threshold0</em>[, <em>threshold1</em>[, <em>threshold2</em>]])</p><p>设置垃圾回收阈值（收集频率）。 将 <em>threshold0</em> 设为零会禁用回收。垃圾回收器把所有对象分类为三代，取决于对象幸存于多少次垃圾回收。新创建的对象会被放在最年轻代（第 <code>0</code> 代）。如果一个对象幸存于一次垃圾回收，则该对象会被放入下一代。第 <code>2</code> 代是最老的一代，因此这一代的对象幸存于垃圾回收后，仍会留在第 <code>2</code> 代。为了判定何时需要进行垃圾回收，垃圾回收器会跟踪上一次回收后，分配和释放的对象的数目。当分配对象的数量减去释放对象的数量大于阈值 <em>threshold0</em> 时，回收器开始进行垃圾回收。起初只有第 <code>0</code> 代会被检查。当上一次第 <code>1</code> 代被检查后，第 <code>0</code> 代被检查的次数多于阈值 <em>threshold1</em> 时，第 <code>1</code> 代也会被检查。相似的， <em>threshold2</em> 设置了触发第 <code>2</code> 代被垃圾回收的第 <code>1</code> 代被垃圾回收的次数。</p></li><li><p><code>gc.get_count</code>()</p><p>将当前回收计数以形为 <code>(count0, count1, count2)</code> 的元组返回。</p></li><li><p><code>gc.get_threshold</code>()</p><p>将当前回收阈值以形为 <code>(threshold0, threshold1, threshold2)</code> 的元组返回。</p></li><li><p><code>gc.get_referrers</code>(*<em>objs</em>)</p><p>返回直接引用任意一个 <em>ojbs</em> 的对象列表。这个函数只定位支持垃圾回收的容器；引用了其它对象但不支持垃圾回收的扩展类型不会被找到。需要注意的是，已经解除对 <em>objs</em> 引用的对象，但仍存在于循环引用中未被回收时，仍然会被作为引用者出现在返回的列表当中。若要获取当前正在引用 <em>objs</em> 的对象，需要调用 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.collect" target="_blank" rel="noopener"><code>collect()</code></a> 然后再调用 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.get_referrers" target="_blank" rel="noopener"><code>get_referrers()</code></a> 。在使用 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.get_referrers" target="_blank" rel="noopener"><code>get_referrers()</code></a> 返回的对象时必须要小心，因为其中一些对象可能仍在构造中因此处于暂时的无效状态。不要把 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.get_referrers" target="_blank" rel="noopener"><code>get_referrers()</code></a> 用于调试以外的其它目的。</p></li><li><p><code>gc.get_referents</code>(*<em>objs</em>)</p><p>返回被任意一个参数中的对象直接引用的对象的列表。返回的被引用对象是被参数中的对象的C语言级别方法（若存在） <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_traverse" target="_blank" rel="noopener"><code>tp_traverse</code></a> 访问到的对象，可能不是所有的实际直接可达对象。只有支持垃圾回收的对象支持 <a href="https://docs.python.org/zh-cn/3.8/c-api/typeobj.html#c.PyTypeObject.tp_traverse" target="_blank" rel="noopener"><code>tp_traverse</code></a>  方法，并且此方法只会在需要访问涉及循环引用的对象时使用。因此，可以有以下例子：一个整数对其中一个参数是直接可达的，这个整数有可能出现或不出现在返回的结果列表当中。</p></li><li><p><code>gc.is_tracked</code>(<em>obj</em>)</p><p>当对象正在被垃圾回收器监控时返回 <code>True</code> ，否则返回 <code>False</code> 。一般来说，原子类的实例不会被监控，而非原子类（如容器、用户自定义的对象）会被监控。然而，会有一些特定类型的优化以便减少垃圾回收器在简单实例（如只含有原子性的键和值的字典）上的消耗。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(<span class="number">0</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(<span class="string">"a"</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked([])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(&#123;&#125;)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(&#123;<span class="string">"a"</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.is_tracked(&#123;<span class="string">"a"</span>: []&#125;)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li><li><p><code>gc.freeze</code>()</p><p>冻结 gc 所跟踪的所有对象 —— 将它们移至永久代并忽略所有未来的集合。 这可以在 POSIX fork() 调用之前使用以便令对写入复制保持友好或加速收集。 并且在 POSIX fork() 调用之前的收集也可以释放页面以供未来分配，这也可能导致写入时复制，因此建议在主进程中禁用 gc 并在 fork 之前冻结，而在子进程中启用 gc。<em>3.7 新版功能.</em></p></li><li><p><code>gc.unfreeze</code>()</p><p>解冻永久代中的对象，并将它们放回到年老代中。<em>3.7 新版功能.</em></p></li><li><p><code>gc.get_freeze_count</code>()</p><p>返回永久代中的对象数量。<em>3.7 新版功能.</em></p></li></ul><p>提供以下变量仅供只读访问（你可以修改但不应该重绑定它们）：</p><ul><li><p><code>gc.garbage</code></p><p>一个回收器发现不可达而又无法被释放的对象（不可回收对象）列表。 从 Python 3.4 开始，该列表在大多数时候都应该是空的，除非使用了含有非 <code>NULL</code> <code>tp_del</code> 空位的 C 扩展类型的实例。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.DEBUG_SAVEALL" target="_blank" rel="noopener"><code>DEBUG_SAVEALL</code></a> ，则所有不可访问对象将被添加至该列表而不会被释放。<em>在 3.2 版更改:</em> 当 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-interpreter-shutdown" target="_blank" rel="noopener">interpreter shutdown</a> 即解释器关闭时，若此列表非空，会产生 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ResourceWarning" target="_blank" rel="noopener"><code>ResourceWarning</code></a> ，即资源警告，在默认情况下此警告不会被提醒。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.DEBUG_UNCOLLECTABLE" target="_blank" rel="noopener"><code>DEBUG_UNCOLLECTABLE</code></a> ，所有无法被回收的对象会被打印。<em>在 3.4 版更改:</em> 根据 <a href="https://www.python.org/dev/peps/pep-0442" target="_blank" rel="noopener"><strong>PEP 442</strong></a> ，带有 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法的对象最终不再会进入 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>gc.garbage</code></a> 。</p></li><li><p><code>gc.callbacks</code></p><p>在垃圾回收器开始前和完成后会被调用的一系列回调函数。这些回调函数在被调用时使用两个参数： <em>phase</em> 和 <em>info</em> 。<em>phase</em> 可为以下两值之一：”start”: 垃圾回收即将开始。”stop”: 垃圾回收已结束。<em>info</em> is a dict providing more information for the callback. The following keys are currently defined:”generation”（代） ：正在被回收的最久远的一代。”collected”（已回收的 ）: 当<em>phase</em> 为 “stop” 时，被成功回收的对象的数目。”uncollectable”（不可回收的）: 当 <em>phase</em> 为 “stop” 时，不能被回收并被放入 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>garbage</code></a> 的对象的数目。应用程序可以把他们自己的回调函数加入此列表。主要的使用场景有：统计垃圾回收的数据，如：不同代的回收频率、回收所花费的时间。使应用程序可以识别和清理他们自己的在 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>garbage</code></a> 中的不可回收类型的对象。<em>3.3 新版功能.</em></p></li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>以下常量被用于 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.set_debug" target="_blank" rel="noopener"><code>set_debug()</code></a> ：</p><ul><li><p><code>gc.DEBUG_STATS</code></p><p>在回收完成后打印统计信息。当回收频率设置较高时，这些信息会比较有用。</p></li><li><p><code>gc.DEBUG_COLLECTABLE</code></p><p>当发现可回收对象时打印信息。</p></li><li><p><code>gc.DEBUG_UNCOLLECTABLE</code></p><p>打印找到的不可回收对象的信息（指不能被回收器回收的不可达对象）。这些对象会被添加到 <code>garbage</code> 列表中。<em>在 3.2 版更改:</em> 当 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-interpreter-shutdown" target="_blank" rel="noopener">interpreter shutdown</a> 时，即解释器关闭时，若 <a href="https://docs.python.org/zh-cn/3.8/library/gc.html#gc.garbage" target="_blank" rel="noopener"><code>garbage</code></a> 列表中存在对象，这些对象也会被打印输出。</p></li><li><p><code>gc.DEBUG_SAVEALL</code></p><p>设置后，所有回收器找到的不可达对象会被添加进 <em>garbage</em> 而不是直接被释放。这在调试一个内存泄漏的程序时会很有用。</p></li><li><p><code>gc.DEBUG_LEAK</code></p><p>调试内存泄漏的程序时，使回收器打印信息的调试标识位。（等价于 <code>DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_SAVEALL</code> ）。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-gc&quot;&gt;&lt;a href=&quot;#python-标准库-gc&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 gc&quot;&gt;&lt;/a&gt;python 标准库 gc&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200224_father.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="gc" scheme="https://pinghailinfeng.gitee.io/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>python standard library Built-in Exception</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/22/python-standard-library-Built-in-Exception/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/22/python-standard-library-Built-in-Exception/</id>
    <published>2020-02-22T14:47:29.000Z</published>
    <updated>2020-02-22T15:22:54.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-内置异常"><a href="#python-标准库-内置异常" class="headerlink" title="python 标准库 内置异常"></a>python 标准库 内置异常</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200221-happy-birthday.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词:</p><h1 id="worth"><a href="#worth" class="headerlink" title="worth"></a><strong>worth</strong></h1><p>n <strong>价值；意义；价值（十元、40 英镑等）的东西</strong></p><p>adj <strong>有…价值；值…钱；（指行动）值得；值得（费周折）</strong></p><p>web <strong>值得的；有……的价值；值…的</strong></p><p>短语:</p><p><strong>for all sb/it is worth</strong> 竭尽全力；拼命</p><p>for what its worth  非正式   （所说的只是个人意见）无论管不管用，不论好坏</p><p><strong>(the game is) not worth the candle</strong>  得不偿失<br>  <strong>not worth the paper its written/printed on</strong>  尤指 (法律上 )毫无价值</p><p>worth your/its salt   称职；胜任</p><p>worth sbs while    对…有好处（或用处）</p></blockquote><p>在 Python 中，所有异常必须为一个派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 的类的实例。 在带有提及一个特定类的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 子句的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句中，该子句也会处理任何派生自该类的异常类（但不处理 <em>它</em> 所派生出的异常类）。 通过子类化创建的两个不相关异常类永远是不等效的，既使它们具有相同的名称。</p><p>下面列出的内置异常可通过解释器或内置函数来生成。除非另有说明，它们都会具有一个提示导致错误详细原因的“关联值”。 这可以是一个字符串或由多个信息项（例如一个错误码和一个解释错误的字符串）组成的元组。 关联值通常会作为参数被传递给异常类的构造器。</p><p>用户代码可以引发内置异常。 这可被用于测试异常处理程序或报告错误条件，“就像” 在解释器引发了相同异常的情况时一样；但是请注意，没有任何机制能防止用户代码引发不适当的错误。</p><p>内置异常类可以被子类化以定义新的异常；鼓励程序员从 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 类或它的某个子类而不是从 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 来派生新的异常。 关于定义异常的更多信息可以在 Python 教程的 <a href="https://docs.python.org/zh-cn/3.8/tutorial/errors.html#tut-userexceptions" target="_blank" rel="noopener">用户自定义异常</a> 部分查看。</p><p>当在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#except" target="_blank" rel="noopener"><code>except</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句中引发（或重新引发）异常时，<code>__context__</code> 会被自动设为所捕获的最后一个异常；如果新的异常未被处理，则最终显示的回溯信息将包括原始的异常和最后的异常。</p><p>当引发一个新的异常（而不是简单地使用 <code>raise</code> 来重新引发当前在处理的异常）时，隐式的异常上下文可以通过使用带有 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#raise" target="_blank" rel="noopener"><code>raise</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 来补充一个显式的原因:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> new_exc <span class="keyword">from</span> original_exc</span><br></pre></td></tr></table></figure><p>跟在 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#from" target="_blank" rel="noopener"><code>from</code></a> 之后的表达式必须为一个异常或 <code>None</code>。 它将在所引发的异常上被设置为 <code>__cause__</code>。 设置 <code>__cause__</code> 还会隐式地将 <code>__suppress_context__</code> 属性设为 <code>True</code>，这样使用 <code>raise new_exc from None</code> 可以有效地将旧异常替换为新异常来显示其目的 (例如将 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a>)，同时让旧异常在 <code>__context__</code> 中保持可用状态以便在调试时进行内省。</p><p>除了异常本身的回溯以外，默认的回溯还会显示这些串连的异常。 <code>__cause__</code> 中的显式串连异常如果存在将总是显示。 <code>__context__</code> 中的隐式串连异常仅在 <code>__cause__</code> 为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 并且 <code>__suppress_context__</code> 为假值时显示。</p><p>不论在哪种情况下，异常本身总会在任何串连异常之后显示，以便回溯的最后一行总是显示所引发的最后一个异常。</p><h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><p>下列异常主要被用作其他异常的基类。</p><ul><li><p><em>exception</em> <code>BaseException</code></p><p>所有内置异常的基类。 它不应该被用户自定义类直接继承 (这种情况请使用 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a>)。 如果在此类的实例上调用 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a>，则会返回实例的参数表示，或者当没有参数时返回空字符串。</p><ul><li><p><code>args</code></p><p>传给异常构造器的参数元组。 某些内置异常 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>) 接受特定数量的参数并赋予此元组中的元素特殊的含义，而其他异常通常只接受一个给出错误信息的单独字符串。</p></li><li><p><code>with_traceback</code>(<em>tb</em>)</p><p>此方法将 <em>tb</em> 设为异常的新回溯信息并返回该异常对象。 它通常以如下的形式在异常处理程序中使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">except</span> SomeException:</span><br><span class="line">    tb = sys.exc_info()[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">raise</span> OtherException(...).with_traceback(tb)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><em>exception</em> <code>Exception</code></p><p>所有内置的非系统退出类异常都派生自此类。 所有用户自定义异常也应当派生自此类。</p></li><li><p><em>exception</em> <code>ArithmeticError</code></p><p>此基类用于派生针对各种算术类错误而引发的内置异常: <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OverflowError" target="_blank" rel="noopener"><code>OverflowError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ZeroDivisionError" target="_blank" rel="noopener"><code>ZeroDivisionError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FloatingPointError" target="_blank" rel="noopener"><code>FloatingPointError</code></a>。</p></li><li><p><em>exception</em> <code>BufferError</code></p><p>当与 <a href="https://docs.python.org/zh-cn/3.8/c-api/buffer.html#bufferobjects" target="_blank" rel="noopener">缓冲区</a> 相关的操作无法执行时将被引发。</p></li><li><p><em>exception</em> <code>LookupError</code></p><p>此基类用于派生当映射或序列所使用的键或索引无效时引发的异常: <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。 这可以通过 <a href="https://docs.python.org/zh-cn/3.8/library/codecs.html#codecs.lookup" target="_blank" rel="noopener"><code>codecs.lookup()</code></a> 来直接引发。</p></li></ul><h2 id="具体异常"><a href="#具体异常" class="headerlink" title="具体异常"></a>具体异常</h2><p>以下异常属于经常被引发的异常。</p><ul><li><p><em>exception</em> <code>AssertionError</code></p><p>当 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#assert" target="_blank" rel="noopener"><code>assert</code></a> 语句失败时将被引发。</p></li><li><p><em>exception</em> <code>AttributeError</code></p><p>当属性引用 (参见 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#attribute-references" target="_blank" rel="noopener">属性引用</a>) 或赋值失败时将被引发。 （当一个对象根本不支持属性引用或属性赋值时则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。）</p></li><li><p><em>exception</em> <code>EOFError</code></p><p>当 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#input" target="_blank" rel="noopener"><code>input()</code></a> 函数未读取任何数据即达到文件结束条件 (EOF) 时将被引发。 （另外，<code>io.IOBase.read()</code> 和 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.readline" target="_blank" rel="noopener"><code>io.IOBase.readline()</code></a> 方法在遇到 EOF 则将返回一个空字符串。）</p></li><li><p><em>exception</em> <code>FloatingPointError</code></p><p>目前未被使用。</p></li><li><p><em>exception</em> <code>GeneratorExit</code></p><p>当一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 或 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 被关闭时将被引发；参见 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#generator.close" target="_blank" rel="noopener"><code>generator.close()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#coroutine.close" target="_blank" rel="noopener"><code>coroutine.close()</code></a>。 它直接继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a>，因为从技术上来说它并不是一个错误。</p></li><li><p><em>exception</em> <code>ImportError</code></p><p>当 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句尝试加载模块遇到麻烦时将被引发。 并且当 <code>from ... import</code> 中的 “from list” 存在无法找到的名称时也会被引发。<code>name</code> 与 <code>path</code> 属性可通过对构造器使用仅关键字参数来设定。 设定后它们将分别表示被尝试导入的模块名称与触发异常的任意文件所在路径。<em>在 3.3 版更改:</em> 添加了 <code>name</code> 与 <code>path</code> 属性。</p></li><li><p><em>exception</em> <code>ModuleNotFoundError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ImportError" target="_blank" rel="noopener"><code>ImportError</code></a> 的子类，当一个模块无法被定位时将由 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 引发。 当在 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.modules" target="_blank" rel="noopener"><code>sys.modules</code></a> 中找到 <code>None</code> 时也会被引发。</p><p><em>3.6 新版功能.</em></p></li><li><p><em>exception</em> <code>IndexError</code></p><p>当序列抽取超出范围时将被引发。 （切片索引会被静默截短到允许的范围；如果指定索引不是整数则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 会被引发。）</p></li><li><p><em>exception</em> <code>KeyError</code></p><p>当在现有键集合中找不到指定的映射（字典）键时将被引发。</p></li><li><p><em>exception</em> <code>KeyboardInterrupt</code></p><p>当用户按下中断键 (通常为 Control-C 或 Delete) 时将被引发。 在执行期间，会定期检测中断信号。 该异常继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 以确保不会被处理 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的代码意外捕获，这样可以避免退出解释器。</p></li><li><p><em>exception</em> <code>MemoryError</code></p><p>当一个操作耗尽内存但情况仍可（通过删除一些对象）进行挽救时将被引发。 关联的值是一个字符串，指明是哪种（内部）操作耗尽了内存。 请注意由于底层的内存管理架构（C 的 <code>malloc()</code> 函数），解释器也许并不总是能够从这种情况下完全恢复；但它毕竟可以引发一个异常，这样就能打印出栈回溯信息，以便找出导致问题的失控程序。</p></li><li><p><em>exception</em> <code>NameError</code></p><p>当某个局部或全局名称未找到时将被引发。 此异常仅用于非限定名称。 关联的值是一条错误信息，其中包含未找到的名称。</p></li><li><p><em>exception</em> <code>NotImplementedError</code></p><p>此异常派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 在用户自定义的基类中，抽象方法应当在其要求所派生类重载该方法，或是在其要求所开发的类提示具体实现尚待添加时引发此异常。</p><blockquote><p>它不应当用来表示一个运算符或方法根本不能被支持 – 在此情况下应当让特定运算符 / 方法保持未定义，或者在子类中将其设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p><p><code>NotImplementedError</code> 和 <code>NotImplemented</code> 不可互换，即使它们有相似的名称和用途。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#NotImplemented" target="_blank" rel="noopener"><code>NotImplemented</code></a> 了解有关何时使用它们的详细说明。</p></blockquote></li><li><p><em>exception</em> <code>OSError</code>([<em>arg</em>])</p><p><em>exception</em> <code>OSError</code>(<em>errno</em>, <em>strerror</em>[, <em>filename</em>[, <em>winerror</em>[, <em>filename2</em>]]])</p><p>此异常在一个系统函数返回系统相关的错误时将被引发，此类错误包括 I/O 操作失败例如 “文件未找到” 或 “磁盘已满” 等（不包括非法参数类型或其他偶然性错误）。</p><p>构造器的第二种形式可设置如下所述的相应属性。 如果未指定这些属性则默认为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。 为了能向下兼容，如果传入了三个参数，则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException.args" target="_blank" rel="noopener"><code>args</code></a> 属性将仅包含由前两个构造器参数组成的 2 元组。</p><p>构造器实际返回的往往是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的某个子类，如下文 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#os-exceptions" target="_blank" rel="noopener">OS exceptions</a> 中所描述的。 具体的子类取决于最终的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 值。 此行为仅在直接或通过别名来构造 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 时发生，并且在子类化时不会被继承。</p><ul><li><p><code>errno</code></p><p>来自于 C 变量 <code>errno</code> 的数字错误码。</p></li><li><p><code>winerror</code></p><p>在 Windows 下，此参数将给出原生的 Windows 错误码。 而 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 属性将是该原生错误码在 POSIX 平台下的近似转换形式。在 Windows 下，如果 <em>winerror</em> 构造器参数是一个整数，则 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 属性会根据 Windows 错误码来确定，而 <em>errno</em> 参数会被忽略。 在其他平台上，<em>winerror</em> 参数会被忽略，并且 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.winerror" target="_blank" rel="noopener"><code>winerror</code></a> 属性将不存在。</p></li><li><p><code>strerror</code></p><p>操作系统所提供的相应错误信息。 它在 POSIX 平台中由 C 函数 <code>perror()</code> 来格式化，在 Windows 中则是由 <code>FormatMessage()</code>。</p></li><li><p><code>filename</code></p></li><li><p><code>filename2</code></p><p>对于与文件系统路径有关 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unlink" target="_blank" rel="noopener"><code>os.unlink()</code></a>) 的异常，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename" target="_blank" rel="noopener"><code>filename</code></a> 是传给函数的文件名。 对于涉及两个文件系统路径的函数 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a>)，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename2" target="_blank" rel="noopener"><code>filename2</code></a> 将是传给函数的第二个文件名。</p></li></ul><p><em>在 3.3 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EnvironmentError" target="_blank" rel="noopener"><code>EnvironmentError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IOError" target="_blank" rel="noopener"><code>IOError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#WindowsError" target="_blank" rel="noopener"><code>WindowsError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.error" target="_blank" rel="noopener"><code>socket.error</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/select.html#select.error" target="_blank" rel="noopener"><code>select.error</code></a> 与 <code>mmap.error</code> 已被合并到 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>，构造器可能返回其中一个子类。</p><p><em>在 3.4 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.filename" target="_blank" rel="noopener"><code>filename</code></a> 属性现在将是传给函数的原始文件名，而不是经过编码或基于文件系统编码进行解码之后的名称。 此外还添加了 <em>filename2</em> 构造器参数和属性。</p></li><li><p><em>exception</em> <code>OverflowError</code></p><p>当算术运算的结果大到无法表示时将被引发。 这对整数来说不可能发生（宁可引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#MemoryError" target="_blank" rel="noopener"><code>MemoryError</code></a> 也不会放弃尝试）。 但是出于历史原因，有时也会在整数超出要求范围的情况下引发 OverflowError。 因为在 C 中缺少对浮点异常处理的标准化，大多数浮点运算都不会做检查。</p></li><li><p><em>exception</em> <code>RecursionError</code></p><p>此异常派生自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。 它会在解释器检测发现超过最大递归深度 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getrecursionlimit" target="_blank" rel="noopener"><code>sys.getrecursionlimit()</code></a>) 时被引发。<em>3.5 新版功能:</em> 在此之前将只引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p></li><li><p><em>exception</em> <code>ReferenceError</code></p><p>此异常将在使用 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.proxy" target="_blank" rel="noopener"><code>weakref.proxy()</code></a> 函数所创建的弱引用来访问该引用的某个已被作为垃圾回收的属性时被引发。 有关弱引用的更多信息请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块。</p></li><li><p><em>exception</em> <code>RuntimeError</code></p><p>当检测到一个不归属于任何其他类别的错误时将被引发。 关联的值是一个指明究竟发生了什么问题的字符串。</p></li><li><p><em>exception</em> <code>StopIteration</code></p><p>由内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#next" target="_blank" rel="noopener"><code>next()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#iterator.__next__" target="_blank" rel="noopener"><code>__next__()</code></a> 方法所引发，用来表示该迭代器不能产生下一项。该异常对象只有一个属性 <code>value</code>，它在构造该异常时作为参数给出，默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。当一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">generator</a> 或 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> 函数返回时，将引发一个新的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 实例，函数返回的值将被用作异常构造器的 <code>value</code> 形参。如果某个生成器代码直接或间接地引发了 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a>，它会被转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> (并将 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 保留为导致新异常的原因)。<em>在 3.3 版更改:</em> 添加了 <code>value</code> 属性及其被生成器函数用作返回值的功能。<em>在 3.5 版更改:</em> 引入了通过 <code>from __future__ import generator_stop</code> 来实现 RuntimeError 转换，参见 <a href="https://www.python.org/dev/peps/pep-0479" target="_blank" rel="noopener"><strong>PEP 479</strong></a>。<em>在 3.7 版更改:</em> 默认对所有代码启用 <a href="https://www.python.org/dev/peps/pep-0479" target="_blank" rel="noopener"><strong>PEP 479</strong></a>: 在生成器中引发的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 错误将被转换为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p></li><li><p><em>exception</em> <code>StopAsyncIteration</code></p><p>必须由一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-asynchronous-iterator" target="_blank" rel="noopener">asynchronous iterator</a> 对象的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__anext__" target="_blank" rel="noopener"><code>__anext__()</code></a> 方法来引发以停止迭代操作。<em>3.5 新版功能.</em></p></li><li><p><em>exception</em> <code>SyntaxError</code></p><p>当解析器遇到语法错误时将被引发。 这可以发生在 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#import" target="_blank" rel="noopener"><code>import</code></a> 语句，对内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#exec" target="_blank" rel="noopener"><code>exec()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#eval" target="_blank" rel="noopener"><code>eval()</code></a> 的调用，或者读取原始脚本或标准输入（也包括交互模式）的时候。该类的实例包含有属性 <code>filename</code>, <code>lineno</code>, <code>offset</code> 和 <code>text</code> 用于方便地访问相应的详细信息。 异常实例的 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str()</code></a> 仅返回消息文本。</p></li><li><p><em>exception</em> <code>IndentationError</code></p><p>与不正确的缩进相关的语法错误的基类。 这是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#SyntaxError" target="_blank" rel="noopener"><code>SyntaxError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>TabError</code></p><p>当缩进包含对制表符和空格符不一致的使用时将被引发。 这是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndentationError" target="_blank" rel="noopener"><code>IndentationError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>SystemError</code></p><p>当解释器发现内部错误，但情况看起来尚未严重到要放弃所有希望时将被引发。 关联的值是一个指明发生了什么问题的字符串（表示为低层级的符号）。你应当将此问题报告给你所用 Python 解释器的作者或维护人员。 请确认报告 Python 解释器的版本号 (<code>sys.version</code>; 它也会在交互式 Python 会话开始时被打印出来)，具体的错误消息（异常所关联的值）以及可能触发该错误的程序源码。</p></li><li><p><em>exception</em> <code>SystemExit</code></p><p>此异常由 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 函数引发。 它继承自 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BaseException" target="_blank" rel="noopener"><code>BaseException</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 以确保不会被处理 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#Exception" target="_blank" rel="noopener"><code>Exception</code></a> 的代码意外捕获。 这允许此异常正确地向上传播并导致解释器退出。 如果它未被处理，则 Python 解释器就将退出；不会打印任何栈回溯信息。 构造器接受的可选参数与传递给 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 的相同。 如果该值为一个整数，则它指明系统退出状态码（会传递给 C 的 <code>exit()</code> 函数）；如果该值为 <code>None</code>，则退出状态码为零；如果该值为其他类型（例如字符串），则会打印对象的值并将退出状态码设为一。对 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.exit" target="_blank" rel="noopener"><code>sys.exit()</code></a> 的调用会被转换为一个异常以便能执行清理处理程序 (<a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> 语句的 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 子句)，并且使得调试器可以执行一段脚本而不必冒失去控制的风险。 如果绝对确实地需要立即退出（例如在调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>os.fork()</code></a> 之后的子进程中）则可使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os._exit" target="_blank" rel="noopener"><code>os._exit()</code></a>.<code>code</code>传给构造器的退出状态码或错误信息（默认为 <code>None</code>。）</p></li><li><p><em>exception</em> <code>TypeError</code></p><p>当一个操作或函数被应用于类型不适当的对象时将被引发。 关联的值是一个字符串，给出有关类型不匹配的详情。此异常可以由用户代码引发，以表明尝试对某个对象进行的操作不受支持也不应当受支持。 如果某个对象应当支持给定的操作但尚未提供相应的实现，所要引发的适当异常应为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a>。传入参数的类型错误 (例如在要求 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 时却传入了 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a>) 应当导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>，但传入参数的值错误 (例如传入要求范围之外的数值) 则应当导致 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。</p></li><li><p><em>exception</em> <code>UnboundLocalError</code></p><p>当在函数或方法中对某个局部变量进行引用，但该变量并未绑定任何值时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NameError" target="_blank" rel="noopener"><code>NameError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>UnicodeError</code></p><p>当发生与 Unicode 相关的编码或解码错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 的一个子类。<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 具有一些描述编码或解码错误的属性。 例如 <code>err.object[err.start:err.end]</code> 会给出导致编解码器失败的特定无效输入。<code>encoding</code>引发错误的编码名称。<code>reason</code>描述特定编解码器错误的字符串。<code>object</code>编解码器试图要编码或解码的对象。<code>start</code><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 中无效数据的开始位置索引。<code>end</code><a href="https://docs.python.org/zh-cn/3.8/library/functions.html#object" target="_blank" rel="noopener"><code>object</code></a> 中无效数据的末尾位置索引（不含）。</p></li><li><p><em>exception</em> <code>UnicodeEncodeError</code></p><p>当在编码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>UnicodeDecodeError</code></p><p>当在解码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>UnicodeTranslateError</code></p><p>在转写过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#UnicodeError" target="_blank" rel="noopener"><code>UnicodeError</code></a> 的一个子类。</p></li><li><p><em>exception</em> <code>ValueError</code></p><p>当操作或函数接收到具有正确类型但值不适合的参数，并且情况不能用更精确的异常例如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IndexError" target="_blank" rel="noopener"><code>IndexError</code></a> 来描述时将被引发。</p></li><li><p><em>exception</em> <code>ZeroDivisionError</code></p><p>当除法或取余运算的第二个参数为零时将被引发。 关联的值是一个字符串，指明操作数和运算的类型。</p></li></ul><p>下列异常被保留以与之前的版本相兼容；从 Python 3.3 开始，它们都是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的别名。</p><ul><li><em>exception</em> <code>EnvironmentError</code></li></ul><ul><li><em>exception</em> <code>IOError</code></li></ul><ul><li><p><em>exception</em> <code>WindowsError</code></p><p>限在 Windows 中可用。</p></li></ul><h3 id="OS-异常"><a href="#OS-异常" class="headerlink" title="OS 异常"></a>OS 异常</h3><p>下列异常均为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的子类，它们将根据系统错误代码被引发。</p><ul><li><p><em>exception</em> <code>BlockingIOError</code></p><p>当一个操作会被某个设置为非阻塞操作的对象（例如套接字）所阻塞时将被引发。 对应于 <code>errno</code> <code>EAGAIN</code>, <code>EALREADY</code>, <code>EWOULDBLOCK</code> 和 <code>EINPROGRESS</code>。除了 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 已有的属性，<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BlockingIOError" target="_blank" rel="noopener"><code>BlockingIOError</code></a> 还有一个额外属性：<code>characters_written</code>一个整数，表示在被阻塞前已写入到流的字符数。 当使用来自 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#module-io" target="_blank" rel="noopener"><code>io</code></a> 模块的带缓冲 I/O 类时此属性可用。</p></li><li><p><em>exception</em> <code>ChildProcessError</code></p><p>当一个子进程上的操作失败时将被引发。 对应于 <code>errno</code> <code>ECHILD</code>。</p></li><li><p><em>exception</em> <code>ConnectionError</code></p><p>与连接相关问题的基类。其子类有 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BrokenPipeError" target="_blank" rel="noopener"><code>BrokenPipeError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionAbortedError" target="_blank" rel="noopener"><code>ConnectionAbortedError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionRefusedError" target="_blank" rel="noopener"><code>ConnectionRefusedError</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionResetError" target="_blank" rel="noopener"><code>ConnectionResetError</code></a>。</p></li><li><p><em>exception</em> <code>BrokenPipeError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当试图写入另一端已被关闭的管道，或是试图写入已关闭写入的套接字时将被引发。 对应于 <code>errno</code> <code>EPIPE</code> 和 <code>ESHUTDOWN</code>。</p></li><li><p><em>exception</em> <code>ConnectionAbortedError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接尝试被对端中止时将被引发。 对应于 <code>errno</code> <code>ECONNABORTED</code>。</p></li><li><p><em>exception</em> <code>ConnectionRefusedError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接尝试被对端拒绝时将被引发。 对应于 <code>errno</code> <code>ECONNREFUSED</code>。</p></li><li><p><em>exception</em> <code>ConnectionResetError</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ConnectionError" target="_blank" rel="noopener"><code>ConnectionError</code></a> 的子类，当连接被对端重置时将被引发。 对应于 <code>errno</code> <code>ECONNRESET</code>。</p></li><li><p><em>exception</em> <code>FileExistsError</code></p><p>当试图创建一个已存在的文件或目录时将被引发。 对应于 <code>errno</code> <code>EEXIST</code>。</p></li><li><p><em>exception</em> <code>FileNotFoundError</code></p><p>当所请求的文件或目录不存在时将被引发。 对应于 <code>errno</code> <code>ENOENT</code>。</p></li><li><p><em>exception</em> <code>InterruptedError</code></p><p>当系统调用被输入信号中断时将被引发。 对应于 <code>errno</code> <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EINTR" target="_blank" rel="noopener"><code>EINTR</code></a>。<em>在 3.5 版更改:</em> 当系统调用被某个信号中断时，Python 现在会重试系统调用，除非该信号的处理程序引发了其它异常 (原理参见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>) 而不是引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a>。</p></li><li><p><em>exception</em> <code>IsADirectoryError</code></p><p>当请求对一个目录执行文件操作 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.remove" target="_blank" rel="noopener"><code>os.remove()</code></a>) 将被引发。 对应于 <code>errno</code> <code>EISDIR</code>。</p></li><li><p><em>exception</em> <code>NotADirectoryError</code></p><p>当请求对一个非目录对象执行目录操作 (例如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>os.listdir()</code></a>) 时将被引发。 对应于 <code>errno</code> <code>ENOTDIR</code>。</p></li><li><p><em>exception</em> <code>PermissionError</code></p><p>当在没有足够操作权限的情况下试图执行某个操作时将被引发 —— 例如缺少文件系统权限。 对应于 <code>errno</code> <code>EACCES</code> 和 <code>EPERM</code>。</p></li><li><p><em>exception</em> <code>ProcessLookupError</code></p><p>当给定的进程不存在时将被引发。 对应于 <code>errno</code> <code>ESRCH</code>。</p></li><li><p><em>exception</em> <code>TimeoutError</code></p><p>当一个系统函数发生系统级超时的情况下将被引发。 对应于 <code>errno</code> <code>ETIMEDOUT</code>。</p></li></ul><p><em>3.3 新版功能:</em> 添加了以上所有 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的子类。</p><blockquote><p>参见：<a href="https://www.python.org/dev/peps/pep-3151" target="_blank" rel="noopener"><strong>PEP 3151</strong></a> - 重写 OS 和 IO 异常的层次结构</p></blockquote><h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>下列异常被用作警告类别；请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/warnings.html#warning-categories" target="_blank" rel="noopener">警告类别</a> 文档了解详情。</p><ul><li><p><em>exception</em> <code>Warning</code></p><p>警告类别的基类。</p></li><li><p><em>exception</em> <code>UserWarning</code></p><p>用户代码所产生警告的基类。</p></li><li><p><em>exception</em> <code>DeprecationWarning</code></p><p>如果所发出的警告是针对其他 Python 开发者的，则以此作为与已弃用特性相关警告的基类。</p></li><li><p><em>exception</em> <code>PendingDeprecationWarning</code></p><p>对于已过时并预计在未来弃用，但目前尚未弃用的特性相关警告的基类。这个类很少被使用，因为针对未来可能的弃用发出警告的做法并不常见，而针对当前已有的弃用则推荐使用 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#DeprecationWarning" target="_blank" rel="noopener"><code>DeprecationWarning</code></a>。</p></li><li><p><em>exception</em> <code>SyntaxWarning</code></p><p>与模糊的语法相关的警告的基类。</p></li><li><p><em>exception</em> <code>RuntimeWarning</code></p><p>与模糊的运行时行为相关的警告的基类。</p></li><li><p><em>exception</em> <code>FutureWarning</code></p><p>如果所发出的警告是针对以 Python 所编写应用的最终用户的，则以此作为与已弃用特性相关警告的基类。</p></li><li><p><em>exception</em> <code>ImportWarning</code></p><p>与在模块导入中可能的错误相关的警告的基类。</p></li><li><p><em>exception</em> <code>UnicodeWarning</code></p><p>与 Unicode 相关的警告的基类。</p></li><li><p><em>exception</em> <code>BytesWarning</code></p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytearray" target="_blank" rel="noopener"><code>bytearray</code></a> 相关的警告的基类。</p></li><li><p><em>exception</em> <code>ResourceWarning</code></p><p>与资源使用相关的警告的基类。 会被默认的警告过滤器忽略。<em>3.2 新版功能.</em></p></li></ul><h2 id="异常层次结构"><a href="#异常层次结构" class="headerlink" title="异常层次结构"></a>异常层次结构</h2><p>内置异常的类层级结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- StopAsyncIteration</span><br><span class="line">      +-- ArithmeticError</span><br><span class="line">      |    +-- FloatingPointError</span><br><span class="line">      |    +-- OverflowError</span><br><span class="line">      |    +-- ZeroDivisionError</span><br><span class="line">      +-- AssertionError</span><br><span class="line">      +-- AttributeError</span><br><span class="line">      +-- BufferError</span><br><span class="line">      +-- EOFError</span><br><span class="line">      +-- ImportError</span><br><span class="line">      |    +-- ModuleNotFoundError</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br><span class="line">      +-- MemoryError</span><br><span class="line">      +-- NameError</span><br><span class="line">      |    +-- UnboundLocalError</span><br><span class="line">      +-- OSError</span><br><span class="line">      |    +-- BlockingIOError</span><br><span class="line">      |    +-- ChildProcessError</span><br><span class="line">      |    +-- ConnectionError</span><br><span class="line">      |    |    +-- BrokenPipeError</span><br><span class="line">      |    |    +-- ConnectionAbortedError</span><br><span class="line">      |    |    +-- ConnectionRefusedError</span><br><span class="line">      |    |    +-- ConnectionResetError</span><br><span class="line">      |    +-- FileExistsError</span><br><span class="line">      |    +-- FileNotFoundError</span><br><span class="line">      |    +-- InterruptedError</span><br><span class="line">      |    +-- IsADirectoryError</span><br><span class="line">      |    +-- NotADirectoryError</span><br><span class="line">      |    +-- PermissionError</span><br><span class="line">      |    +-- ProcessLookupError</span><br><span class="line">      |    +-- TimeoutError</span><br><span class="line">      +-- ReferenceError</span><br><span class="line">      +-- RuntimeError</span><br><span class="line">      |    +-- NotImplementedError</span><br><span class="line">      |    +-- RecursionError</span><br><span class="line">      +-- SyntaxError</span><br><span class="line">      |    +-- IndentationError</span><br><span class="line">      |         +-- TabError</span><br><span class="line">      +-- SystemError</span><br><span class="line">      +-- TypeError</span><br><span class="line">      +-- ValueError</span><br><span class="line">      |    +-- UnicodeError</span><br><span class="line">      |         +-- UnicodeDecodeError</span><br><span class="line">      |         +-- UnicodeEncodeError</span><br><span class="line">      |         +-- UnicodeTranslateError</span><br><span class="line">      +-- Warning</span><br><span class="line">           +-- DeprecationWarning</span><br><span class="line">           +-- PendingDeprecationWarning</span><br><span class="line">           +-- RuntimeWarning</span><br><span class="line">           +-- SyntaxWarning</span><br><span class="line">           +-- UserWarning</span><br><span class="line">           +-- FutureWarning</span><br><span class="line">           +-- ImportWarning</span><br><span class="line">           +-- UnicodeWarning</span><br><span class="line">           +-- BytesWarning</span><br><span class="line">           +-- ResourceWarning</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-内置异常&quot;&gt;&lt;a href=&quot;#python-标准库-内置异常&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 内置异常&quot;&gt;&lt;/a&gt;python 标准库 内置异常&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200221-happy-birthday.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="Exception" scheme="https://pinghailinfeng.gitee.io/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>python standard library cmd</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/21/python-standard-library-cmd/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/21/python-standard-library-cmd/</id>
    <published>2020-02-21T14:20:08.000Z</published>
    <updated>2020-02-22T15:14:11.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-cmd模块"><a href="#python-标准库-cmd模块" class="headerlink" title="python 标准库 cmd模块"></a>python 标准库 cmd模块</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200221_zhuakuang.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词:</p><p> collapse </p><p>近义词:</p><p>crash<br>breakdown<br>crumble<br>fall apart </p><p>例句:</p><p> 我曾经神经崩溃过。那是一次痛苦的经历。<br>I suffered a nervous breakdown. It was a traumatic experience </p><p> 他能明显地看出我快要精神崩溃了。<br>It was plain to him that I was having a nervous breakdown </p></blockquote><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/cmd.py" target="_blank" rel="noopener">Lib/cmd.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 类提供简单框架用于编写面向行的命令解释器。 这些通常对测试工具，管理工具和原型有用，这些工具随后将被包含在更复杂的接口中。</p><ul><li><p><em>class</em> <code>cmd.Cmd</code>(<em>completekey=’tab’</em>, <em>stdin=None</em>, <em>stdout=None</em>)</p><p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 实例或子类实例是面向行的解释器框架结构。 实例化 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 本身是没有充分理由的， 它作为自定义解释器类的超类是非常有用的为了继承 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 的方法并且封装动作方法。可选参数 <em>completekey</em> 是完成键的 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 名称；默认是 Tab 。如果 <em>completekey</em> 不是 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 并且 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 是可用的， 命令完成会自动完成。可选参数 <em>stdin</em> 和 <em>stdout</em> 指定了Cmd实例或子类实例将用于输入和输出的输入和输出文件对象。如果没有指定，他们将默认为 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdout" target="_blank" rel="noopener"><code>sys.stdout</code></a> 。如果你想要使用一个给定的 <em>stdin</em> ，确保将实例的 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.use_rawinput" target="_blank" rel="noopener"><code>use_rawinput</code></a> 属性设置为 <code>False</code> ，否则 <em>stdin</em> 将被忽略</p></li></ul><h2 id="Cmd-对象"><a href="#Cmd-对象" class="headerlink" title="Cmd 对象"></a>Cmd 对象</h2><p><a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 实例有下列方法：</p><ul><li><p><code>Cmd.cmdloop</code>(<em>intro=None</em>)</p><p>反复发出提示，接受输入，从收到的输入中解析出一个初始前缀，并分派给操作方法，将其余的行作为参数传递给它们。可选参数是在第一个提示之前发布的横幅或介绍字符串（这将覆盖 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.intro" target="_blank" rel="noopener"><code>intro</code></a> 类属性）。如果 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 继承模块被加载，输入将自动继承类似 <strong>bash</strong>的历史列表编辑（例如， Control-P 滚动回到最后一个命令， Control-N 转到下一个命令，以 Control-F 非破坏性的方式向右 Control-B 移动光标，破坏性地等）。输入的文件结束符被作为字符串传回 <code>&#39;EOF&#39;</code> 。解释器实例将会识别命令名称 <code>foo</code> 当且仅当它有方法 <code>do_foo()</code> 。有一个特殊情况，分派始于字符 <code>&#39;?&#39;</code> 的行到方法 <code>do_help()</code> 。另一种特殊情况，分派始于字符 <code>&#39;!&#39;</code> 的行到方法 <code>do_shell()</code> （如果定义了这个方法）这个方法将返回当 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.postcmd" target="_blank" rel="noopener"><code>postcmd()</code></a> 方法返回一个真值 。参数 <em>stop</em> 到 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.postcmd" target="_blank" rel="noopener"><code>postcmd()</code></a> 是命令对应的返回值 <code>do_*()</code> 的方法。如果激活了完成，全部命令将会自动完成，并且通过调用 <code>complete_foo()</code> 参数 <em>text</em> , <em>line</em>, <em>begidx</em> ,和 <em>endidx</em> 完成全部命令参数。 <em>text</em> 是我们试图匹配的字符串前缀，所有返回的匹配项必须以它为开头。 <em>line</em> 是删除了前导空格的当前的输入行， <em>begidx</em> 和 <em>endidx</em> 是前缀文本的开始和结束索引。，可以用于根据参数位置提供不同的完成。所有 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 的子类继承一个预定义 <code>do_help()</code> 。 这个方法使用参数 <code>&#39;bar&#39;</code> 调用， 调用对应的方法 <code>help_bar()</code> ，如果不存在，打印 <code>do_bar()</code> 的文档字符串，如果可用。没有参数的情况下， <code>do_help()</code> 方法会列出所有可用的帮助主题 （即所有具有相应的 <code>help_*()</code> 方法或命令的 文档字符串），也会列举所有未被记录的命令。</p></li><li><p><code>Cmd.onecmd</code>(<em>str</em>)</p><p>解释该参数，就好像它是为响应提示而键入的一样。 这可能会被覆盖，但通常不应该被覆盖; 请参阅： <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.precmd" target="_blank" rel="noopener"><code>precmd()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.postcmd" target="_blank" rel="noopener"><code>postcmd()</code></a> 方法，用于执行有用的挂钩。 返回值是一个标志，指示解释器对命令的解释是否应该停止。 如果命令 <em>str</em> 有一个 <code>do_*()</code> 方法，则返回该方法的返回值，否则返回 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.default" target="_blank" rel="noopener"><code>default()</code></a> 方法的返回值。</p></li><li><p><code>Cmd.emptyline</code>()</p><p>在响应提示输入空行时调用的方法。如果此方法未被覆盖，则重复输入的最后一个非空命令。</p></li><li><p><code>Cmd.default</code>(<em>line</em>)</p><p>当命令前缀不能被识别的时候在输入行调用的方法。如果此方法未被覆盖，它将输出一个错误信息并返回。</p></li><li><p><code>Cmd.completedefault</code>(<em>text</em>, <em>line</em>, <em>begidx</em>, <em>endidx</em>)</p><p>当没有特定于命令的 <code>complete_*()</code> 方法可用时，调用此方法完成输入行。默认情况下，它返回一个空列表。</p></li><li><p><code>Cmd.precmd</code>(<em>line</em>)</p><p>钩方法在命令行 <em>line</em> 被解释之前执行，但是在输入提示被生成和发出后。这个方法是一个在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 中的存根；它的存在是为了被子类覆盖。返回值被用作 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.onecmd" target="_blank" rel="noopener"><code>onecmd()</code></a> 方法执行的命令； <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.precmd" target="_blank" rel="noopener"><code>precmd()</code></a> 的实现或许会重写命令或者简单的返回 <em>line</em> 不变。</p></li><li><p><code>Cmd.postcmd</code>(<em>stop</em>, <em>line</em>)</p><p>钩方法只在命令调度完成后执行。这个方法是一个在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 中的存根；它的存在是为了子类被覆盖。 <em>line</em> 是被执行的命令行， <em>stop</em> 是一个表示在调用 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.postcmd" target="_blank" rel="noopener"><code>postcmd()</code></a> 之后是否终止执行的标志；这将作为 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.onecmd" target="_blank" rel="noopener"><code>onecmd()</code></a> 方法的返回值。这个方法的返回值被用作与 <em>stop</em> 相关联的内部标志的新值；返回 false 将导致解释继续。</p></li><li><p><code>Cmd.preloop</code>()</p><p>钩方法当 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 被调用时执行一次。方法是一个在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 中的存根；它的存在是为了被子类覆盖。</p></li><li><p><code>Cmd.postloop</code>()</p><p>钩方法在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 即将返回时执行一次。这个方法是一个在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 中的存根；塔顶存在是为了被子类覆盖。</p></li></ul><p>Instances of <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> subclasses have some public instance variables:</p><ul><li><p><code>Cmd.prompt</code></p><p>发出提示以请求输入。</p></li><li><p><code>Cmd.identchars</code></p><p>接受命令前缀的字符串。</p></li><li><p><code>Cmd.lastcmd</code></p><p>看到最后一个非空命令前缀。</p></li><li><p><code>Cmd.cmdqueue</code></p><p>排队的输入行列表。当需要新的输入时，在 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 中检查 cmdqueue 列表；如果它不是空的，它的元素将被按顺序处理，就像在提示符处输入一样。</p></li><li><p><code>Cmd.intro</code></p><p>要作为简介或横幅发出的字符串。 可以通过给 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 方法一个参数来覆盖它。</p></li><li><p><code>Cmd.doc_header</code></p><p>如果帮助输出具有记录命令的段落，则发出头文件。</p></li><li><p><code>Cmd.misc_header</code></p><p>如果帮助输出其他帮助主题的部分（即与 <code>do_*()</code> 方法没有关联的 <code>help_*()</code> 方法），则发出头文件。</p></li><li><p><code>Cmd.undoc_header</code></p><p>如果帮助输出未被记录命令的部分（即与 <code>help_*()</code> 方法没有关联的 <code>do_*()</code> 方法），则发出头文件。</p></li><li><p><code>Cmd.ruler</code></p><p>用于在帮助信息标题的下方绘制分隔符的字符，如果为空，则不绘制标尺线。 这个字符默认是 <code>&#39;=&#39;</code> 。</p></li><li><p><code>Cmd.use_rawinput</code></p><p>这是一个标志，默认为 true 。如果为 true ，, <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.cmdloop" target="_blank" rel="noopener"><code>cmdloop()</code></a> 使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#input" target="_blank" rel="noopener"><code>input()</code></a> 先是提示并且阅读下一个命令；如果为 false ， <code>sys.stdout.write()</code> 和 <code>sys.stdin.readline()</code> 被使用。（这意味着解释器将会自动支持类似于 <strong>Emacs</strong>的行编辑和命令历史记录按键操作，通过导入 <a href="https://docs.python.org/zh-cn/3.8/library/readline.html#module-readline" target="_blank" rel="noopener"><code>readline</code></a> 在支持它的系统上。）</p></li></ul><h2 id="Cmd-例子"><a href="#Cmd-例子" class="headerlink" title="Cmd 例子"></a>Cmd 例子</h2><p>这部分提供了一个简单的例子来介绍如何使用一部分在 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#module-turtle" target="_blank" rel="noopener"><code>turtle</code></a> 模块中的命令构建一个 shell 。</p><p>基础的 turtle 命令比如 <a href="https://docs.python.org/zh-cn/3.8/library/turtle.html#turtle.forward" target="_blank" rel="noopener"><code>forward()</code></a> 被添加进一个 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd" target="_blank" rel="noopener"><code>Cmd</code></a> 子类，方法名为 <code>do_forward()</code> 。参数被转换成数字并且分发至 turtle 模组中。 docstring 是 shell 提供的帮助实用程序。</p><p>例子也包含使用 <a href="https://docs.python.org/zh-cn/3.8/library/cmd.html#cmd.Cmd.precmd" target="_blank" rel="noopener"><code>precmd()</code></a> 方法实现基础的记录和回放的功能，这个方法负责将输入转换为小写并且将命令写入文件。 <code>do_playback()</code> 方法读取文件并添加记录命令至 <code>cmdqueue</code> 用于即时回放:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cmd, sys</span><br><span class="line"><span class="keyword">from</span> turtle <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TurtleShell</span><span class="params">(cmd.Cmd)</span>:</span></span><br><span class="line">    intro = <span class="string">'Welcome to the turtle shell.   Type help or ? to list commands.\n'</span></span><br><span class="line">    prompt = <span class="string">'(turtle) '</span></span><br><span class="line">    file = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ----- basic turtle commands -----</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_forward</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Move the turtle forward by the specified distance:  FORWARD 10'</span></span><br><span class="line">        forward(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_right</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Turn turtle right by given number of degrees:  RIGHT 20'</span></span><br><span class="line">        right(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_left</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Turn turtle left by given number of degrees:  LEFT 90'</span></span><br><span class="line">        left(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_goto</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Move turtle to an absolute position with changing orientation.  GOTO 100 200'</span></span><br><span class="line">        goto(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_home</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Return turtle to the home position:  HOME'</span></span><br><span class="line">        home()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_circle</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Draw circle with given radius an options extent and steps:  CIRCLE 50'</span></span><br><span class="line">        circle(*parse(arg))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_position</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Print the current turtle position:  POSITION'</span></span><br><span class="line">        print(<span class="string">'Current position is %d %d\n'</span> % position())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_heading</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Print the current turtle heading in degrees:  HEADING'</span></span><br><span class="line">        print(<span class="string">'Current heading is %d\n'</span> % (heading(),))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_color</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Set the color:  COLOR BLUE'</span></span><br><span class="line">        color(arg.lower())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_undo</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Undo (repeatedly) the last turtle action(s):  UNDO'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_reset</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Clear the screen and return turtle to center:  RESET'</span></span><br><span class="line">        reset()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_bye</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Stop recording, close the turtle window, and exit:  BYE'</span></span><br><span class="line">        print(<span class="string">'Thank you for using Turtle'</span>)</span><br><span class="line">        self.close()</span><br><span class="line">        bye()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ----- record and playback -----</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_record</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Save future commands to filename:  RECORD rose.cmd'</span></span><br><span class="line">        self.file = open(arg, <span class="string">'w'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_playback</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="string">'Playback commands from a file:  PLAYBACK rose.cmd'</span></span><br><span class="line">        self.close()</span><br><span class="line">        <span class="keyword">with</span> open(arg) <span class="keyword">as</span> f:</span><br><span class="line">            self.cmdqueue.extend(f.read().splitlines())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">precmd</span><span class="params">(self, line)</span>:</span></span><br><span class="line">        line = line.lower()</span><br><span class="line">        <span class="keyword">if</span> self.file <span class="keyword">and</span> <span class="string">'playback'</span> <span class="keyword">not</span> <span class="keyword">in</span> line:</span><br><span class="line">            print(line, file=self.file)</span><br><span class="line">        <span class="keyword">return</span> line</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.file:</span><br><span class="line">            self.file.close()</span><br><span class="line">            self.file = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="string">'Convert a series of zero or more numbers to an argument tuple'</span></span><br><span class="line">    <span class="keyword">return</span> tuple(map(int, arg.split()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    TurtleShell().cmdloop()</span><br></pre></td></tr></table></figure><p>这是一个示例会话，其中 turtle shell 显示帮助功能，使用空行重复命令，以及简单的记录和回放功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the turtle shell.   Type help or ? to list commands.</span><br><span class="line"></span><br><span class="line">(turtle) ?</span><br><span class="line"></span><br><span class="line">Documented commands (type help &lt;topic&gt;):</span><br><span class="line">========================================</span><br><span class="line">bye     color    goto     home  playback  record  right</span><br><span class="line">circle  forward  heading  left  position  reset   undo</span><br><span class="line"></span><br><span class="line">(turtle) help forward</span><br><span class="line">Move the turtle forward by the specified distance:  FORWARD <span class="number">10</span></span><br><span class="line">(turtle) record spiral.cmd</span><br><span class="line">(turtle) position</span><br><span class="line">Current position <span class="keyword">is</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">(turtle) heading</span><br><span class="line">Current heading <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">(turtle) reset</span><br><span class="line">(turtle) circle <span class="number">20</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">40</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">60</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">80</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">100</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">120</span></span><br><span class="line">(turtle) right <span class="number">30</span></span><br><span class="line">(turtle) circle <span class="number">120</span></span><br><span class="line">(turtle) heading</span><br><span class="line">Current heading <span class="keyword">is</span> <span class="number">180</span></span><br><span class="line"></span><br><span class="line">(turtle) forward <span class="number">100</span></span><br><span class="line">(turtle)</span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">100</span></span><br><span class="line">(turtle)</span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">400</span></span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">500</span></span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">400</span></span><br><span class="line">(turtle) right <span class="number">90</span></span><br><span class="line">(turtle) forward <span class="number">300</span></span><br><span class="line">(turtle) playback spiral.cmd</span><br><span class="line">Current position <span class="keyword">is</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Current heading <span class="keyword">is</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Current heading <span class="keyword">is</span> <span class="number">180</span></span><br><span class="line"></span><br><span class="line">(turtle) bye</span><br><span class="line">Thank you <span class="keyword">for</span> using Turtle</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-cmd模块&quot;&gt;&lt;a href=&quot;#python-标准库-cmd模块&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 cmd模块&quot;&gt;&lt;/a&gt;python 标准库 cmd模块&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200221_zhuakuang.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="cmd" scheme="https://pinghailinfeng.gitee.io/tags/cmd/"/>
    
  </entry>
  
  <entry>
    <title>python standard library os</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/20/python-standard-library-os/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/20/python-standard-library-os/</id>
    <published>2020-02-20T00:07:42.000Z</published>
    <updated>2020-02-22T15:14:11.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-os"><a href="#python-标准库-os" class="headerlink" title="python 标准库 os"></a>python 标准库 os</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200220_os.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词：</p><p> <a href="https://www.hujiang.com/ciku/bustle/" target="_blank" rel="noopener">bustle</a> v.[I] 1.闹哄哄地忙乱；匆忙；奔忙 2.充满 v.[T] 催促；使忙碌 n. 忙乱；喧扰 </p><p>短语：</p><p> hustle and bustle  熙熙攘攘</p><p> <a href="https://www.hujiang.com/ciku/bustle_in_and_out/" target="_blank" rel="noopener">bustle in and out</a> </p><p> <a href="https://www.hujiang.com/ciku/bustle_about/" target="_blank" rel="noopener">bustle about</a>  sth</p><p>近义词:</p><p>run out of one’s feet </p><p>on the fly<br>on the hump<br>on the jump </p></blockquote><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/os.py" target="_blank" rel="noopener">Lib/os.py</a></p><hr><p>本模块提供了一种使用与操作系统相关的功能的便捷式途径。 如果你只是想读写一个文件，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>，如果你想操作文件路径，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 模块，如果你想读取通过命令行给出的所有文件中的所有行，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/fileinput.html#module-fileinput" target="_blank" rel="noopener"><code>fileinput</code></a> 模块。 为了创建临时文件和目录，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#module-tempfile" target="_blank" rel="noopener"><code>tempfile</code></a> 模块，对于高级文件和目录处理，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 模块。</p><p>关于这些函数的可用性的说明：</p><ul><li>Python中所有依赖于操作系统的内置模块的设计都是这样，只要不同的操作系统某一相同的功能可用，它就使用相同的接口。例如，函数 <code>os.stat(path)</code> 以相同的格式返回关于 <em>path</em> 的状态信息（该格式源于 POSIX 接口）。</li><li>特定于某一操作系统的扩展通过操作 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块也是可用的，但是使用它们当然是对可移植性的一种威胁。</li><li>所有接受路径或文件名的函数都同时支持字节串和字符串对象，并在返回路径或文件名时使用相应类型的对象作为结果。</li><li>在 VxWorks 系统上，os.fork, os.execv 和 os.spawn<em>p</em> 不被支持。</li></ul><blockquote><p> 如果使用无效或无法访问的文件名与路径，或者其他类型正确但操作系统不接受的参数，此模块的所有函数都抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> （或者它的子类）。 </p></blockquote><ul><li><p><em>exception</em> <code>os.error</code></p><p>内建的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常的一个别名。</p></li><li><p><code>os.name</code></p><p>导入的依赖特定操作系统的模块的名称。以下名称目前已注册: <code>&#39;posix&#39;</code>, <code>&#39;nt&#39;</code>, <code>&#39;java&#39;</code>.</p></li></ul><blockquote><p><a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.platform" target="_blank" rel="noopener"><code>sys.platform</code></a> 有更详细的描述. <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.uname" target="_blank" rel="noopener"><code>os.uname()</code></a> 只给出系统提供的版本信息。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/platform.html#module-platform" target="_blank" rel="noopener"><code>platform</code></a> 模块对系统的标识有更详细的检查。</p></blockquote><h2 id="文件名，命令行参数，以及环境变量。"><a href="#文件名，命令行参数，以及环境变量。" class="headerlink" title="文件名，命令行参数，以及环境变量。"></a>文件名，命令行参数，以及环境变量。</h2><p>在 Python 中，使用字符串类型表示文件名、命令行参数和环境变量。 在某些系统上，在将这些字符串传递给操作系统之前，必须将这些字符串解码为字节。 Python 使用文件系统编码来执行此转换（请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getfilesystemencoding" target="_blank" rel="noopener"><code>sys.getfilesystemencoding()</code></a> ）。</p><p><em>在 3.1 版更改:</em> 在某些系统上，使用文件系统编码进行转换可能会失败。 在这种情况下，Python 会使用 <a href="https://docs.python.org/zh-cn/3.8/library/codecs.html#surrogateescape" target="_blank" rel="noopener">代理转义编码错误处理器</a>，这意味着在解码时，不可解码的字节被 Unicode 字符 U+DCxx 替换，并且这些字节在编码时再次转换为原始字节。</p><p>文件系统编码必须保证成功解码小于 128 的所有字节。如果文件系统编码无法提供此保证， API 函数可能会引发 UnicodeErrors 。</p><h2 id="进程参数"><a href="#进程参数" class="headerlink" title="进程参数"></a>进程参数</h2><p>这些函数和数据项提供了操作当前进程和用户的信息。</p><ul><li><p><code>os.ctermid</code>()</p><p>返回与进程控制终端对应的文件名。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.environ</code></p><p>一个表示字符串环境的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-mapping" target="_blank" rel="noopener">mapping</a> 对象。 例如，<code>environ[&#39;HOME&#39;]</code> 是你的主目录（在某些平台上）的路径名，相当于 C 中的 <code>getenv(&quot;HOME&quot;)</code>。这个映射是在第一次导入 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块时捕获的，通常作为 Python 启动时处理 <code>site.py</code> 的一部分。除了通过直接修改 <code>os.environ</code> 之外，在此之后对环境所做的更改不会反映在 <code>os.environ</code> 中。如果平台支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 函数，这个映射除了可以用于查询环境外还能用于修改环境。 当这个映射被修改时，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 将被自动调用。在Unix系统上，键和值会使用 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getfilesystemencoding" target="_blank" rel="noopener"><code>sys.getfilesystemencoding()</code></a> 和 <code>&#39;surrogateescape&#39;</code> 的错误处理。如果你想使用其他的编码，使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environb" target="_blank" rel="noopener"><code>environb</code></a>。注解 直接调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 并不会影响 <code>os.environ</code>，所以推荐直接修改 <code>os.environ</code>。注解 在某些平台上，包括 FreeBSD 和 Mac OS X，设置 <code>environ</code> 可能导致内存泄露。参阅 <code>putenv()</code> 的系统文档。如果平台没有提供 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a>, 为了使启动的子进程使用修改后的环境，一份修改后的映射会被传给合适的进程创建函数。如果平台支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> 函数，你可以通过删除映射中元素的方式来删除对应的环境变量。当一个元素被从 <code>os.environ</code> 删除时，以及 <code>pop()</code> 或 <code>clear()</code> 被调用时， <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> 会被自动调用。</p></li><li><p><code>os.environb</code></p><p>字节版本的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>environ</code></a>: 一个以字节串表示环境的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-mapping" target="_blank" rel="noopener">mapping</a> 对象。 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>environ</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environb" target="_blank" rel="noopener"><code>environb</code></a> 是同步的（修改 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environb" target="_blank" rel="noopener"><code>environb</code></a> 会更新 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>environ</code></a>，反之亦然）。只有在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_bytes_environ" target="_blank" rel="noopener"><code>supports_bytes_environ</code></a> 为 <code>True</code> 的时候 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environb" target="_blank" rel="noopener"><code>environb</code></a> 才是可用的。<em>3.2 新版功能.</em></p></li><li><p><code>os.chdir</code>(<em>path</em>)</p></li><li><p><code>os.fchdir</code>(<em>fd</em>)</p></li><li><p><code>os.getcwd</code>()</p><p>以上函数请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os-file-dir" target="_blank" rel="noopener">文件和目录</a> 。</p></li><li><p><code>os.fsencode</code>(<em>filename</em>)</p><p>编码 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">路径类</a> <em>文件名</em> 为文件系统接受的形式，使用 <code>&#39;surrogateescape&#39;</code> 代理转义编码错误处理器，在Windows系统上会使用 <code>&#39;strict&#39;</code> ；返回 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 字节类型不变。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsdecode" target="_blank" rel="noopener"><code>fsdecode()</code></a> 是此函数的逆向函数。<em>3.2 新版功能.**在 3.6 版更改:</em> 增加对实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>os.PathLike</code></a> 接口的对象的支持。</p></li><li><p><code>os.fsdecode</code>(<em>filename</em>)</p><p>从文件系统编码方式解码为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">路径类</a> 文件名，使用 <code>&#39;surrogateescape&#39;</code> 代理转义编码错误处理器，在Windows系统上会使用 <code>&#39;strict&#39;</code> ；返回 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 字符串不变。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsencode" target="_blank" rel="noopener"><code>fsencode()</code></a> 是此函数的逆向函数。<em>3.2 新版功能.**在 3.6 版更改:</em> 增加对实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>os.PathLike</code></a> 接口的对象的支持。</p></li><li><p><code>os.fspath</code>(<em>path</em>)</p><p>返回路径的文件系统表示。如果传入的是 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型的字符串，将原样返回。否则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike.__fspath__" target="_blank" rel="noopener"><code>__fspath__()</code></a> 将被调用，如果得到的是一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型的对象，那就返回这个值。其他所有情况则会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a> 异常。<em>3.6 新版功能.</em></p></li><li><p><em>class</em> <code>os.PathLike</code></p><p>某些对象用于表示文件系统中的路径（如 <a href="https://docs.python.org/zh-cn/3.8/library/pathlib.html#pathlib.PurePath" target="_blank" rel="noopener"><code>pathlib.PurePath</code></a> 对象），本类是这些对象的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-abstract-base-class" target="_blank" rel="noopener">抽象基类</a>。<em>3.6 新版功能.**abstractmethod</em> <code>__fspath__</code>()返回当前对象的文件系统表示。这个方法只应该返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 字符串或 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 字节串，请优先选择 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#str" target="_blank" rel="noopener"><code>str</code></a> 字符串。</p></li><li><p><code>os.getenv</code>(<em>key</em>, <em>default=None</em>)</p><p>如果存在，返回环境变量 <em>key</em> 的值，否则返回 <em>default</em>。 <em>key</em> ， <em>default</em> 和返回值均为 str 字符串类型。在Unix系统上，键和值会使用 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getfilesystemencoding" target="_blank" rel="noopener"><code>sys.getfilesystemencoding()</code></a> 和’surrogateescape’ 错误处理进行解码。如果你想使用其他的编码，使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getenvb" target="_blank" rel="noopener"><code>os.getenvb()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 大部分的Unix系统，Windows。</p></li><li><p><code>os.getenvb</code>(<em>key</em>, <em>default=None</em>)</p><p>如果存在环境变量 <em>key</em> 那么返回其值，否则返回 <em>default</em>。 <em>key</em> ， <em>default</em> 和返回值均为bytes字节串类型。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getenvb" target="_blank" rel="noopener"><code>getenvb()</code></a> 仅在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_bytes_environ" target="_blank" rel="noopener"><code>supports_bytes_environ</code></a> 为 <code>True</code> 时可用。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 大部分的Unix系统。<em>3.2 新版功能.</em></p></li><li><p><code>os.get_exec_path</code>(<em>env=None</em>)</p><p>返回将用于搜索可执行文件的目录列表，与在外壳程序中启动一个进程时相似。指定的 <em>env</em> 应为用于搜索 PATH 的环境变量字典。默认情况下，当 <em>env</em> 为 <code>None</code> 时，将会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>environ</code></a> 。<em>3.2 新版功能.</em></p></li><li><p><code>os.getegid</code>()</p><p>返回当前进程的有效组ID。对应当前进程执行文件的 “set id” 位。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.geteuid</code>()</p><p>返回当前进程的有效用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.getgid</code>()</p><p>返回当前进程的实际组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.getgrouplist</code>(<em>user</em>, <em>group</em>)</p><p>返回该用户所在的组 ID 列表。可能 <em>group</em> 参数没有在返回的列表中，实际上用户应该也是属于该 <em>group</em>。<em>group</em> 参数一般可以从储存账户信息的密码记录文件中找到。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.getgroups</code>()</p><p>返回当前进程对应的组ID列表<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p><blockquote><p>注解：在Mac OS X系统中，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 会和其他 Unix 平台有些不同。如果 Python 解释器是在 <code>10.5</code> 或更早版本中部署，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 返回当前用户进程相关的有效组ID列表。 该列表长度由于系统预设的接口限制，最长为 16。 而且在适当的权限下，返回结果还会因 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 而发生变化；如果 Python 解释器是在 <code>10.5</code> 以上版本中部署，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 返回进程所属有效用户 ID 所对应的用户的组 ID 列表，组用户列表可能因为进程的生存周期而发生变动，而且也不会因为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.setgroups" target="_blank" rel="noopener"><code>setgroups()</code></a> 的调用而发生，返回的组用户列表长度也没有长度 16 的限制。在部署中，Python 解释器用到的变量 <code>MACOSX_DEPLOYMENT_TARGET</code> 可以用 <a href="https://docs.python.org/zh-cn/3.8/library/sysconfig.html#sysconfig.get_config_var" target="_blank" rel="noopener"><code>sysconfig.get_config_var()</code></a>。</p></blockquote></li><li><p><code>os.getlogin</code>()</p><p>返回通过控制终端进程进行登录的用户名。在多数情况下，使用 <a href="https://docs.python.org/zh-cn/3.8/library/getpass.html#getpass.getuser" target="_blank" rel="noopener"><code>getpass.getuser()</code></a> 会更有效，因为后者会通过检查环境变量 <code>LOGNAME</code> 或 <code>USERNAME</code> 来查找用户，再由 <code>pwd.getpwuid(os.getuid())[0]</code> 来获取当前用户 ID 的登录名。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><code>os.getpgid</code>(<em>pid</em>)</p><p>根据进程id <em>pid</em> 返回进程的组 ID 列表。如果 <em>pid</em> 为 0，则返回当前进程的进程组 ID 列表<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.getpgrp</code>()</p><p>返回当时进程组的ID<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.getpid</code>()</p><p>返回当前进程ID</p></li><li><p><code>os.getppid</code>()</p><p>返回父进程ID。当父进程已经结束，在Unix中返回的ID是初始进程(1)中的一个，在Windows中仍然是同一个进程ID，该进程ID有可能已经被进行进程所占用。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加WIndows的支持。</p></li><li><p><code>os.getpriority</code>(<em>which</em>, <em>who</em>)</p><p>获取程序调度优先级。<em>which</em> 参数值可以是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PROCESS" target="_blank" rel="noopener"><code>PRIO_PROCESS</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PGRP" target="_blank" rel="noopener"><code>PRIO_PGRP</code></a>，或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_USER" target="_blank" rel="noopener"><code>PRIO_USER</code></a> 中的一个，<em>who</em> 是相对于 <em>which</em> (<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PROCESS" target="_blank" rel="noopener"><code>PRIO_PROCESS</code></a> 的进程标识符，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PGRP" target="_blank" rel="noopener"><code>PRIO_PGRP</code></a> 的进程组标识符和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_USER" target="_blank" rel="noopener"><code>PRIO_USER</code></a> 的用户ID)。当 <em>who</em> 为 0 时（分别）表示调用的进程，调用进程的进程组或调用进程所属的真实用户 ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.PRIO_PROCESS</code></p></li><li><p><code>os.PRIO_PGRP</code></p></li><li><p><code>os.PRIO_USER</code></p><p>函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getpriority" target="_blank" rel="noopener"><code>getpriority()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.setpriority" target="_blank" rel="noopener"><code>setpriority()</code></a> 的参数。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.getresuid</code>()</p><p>返回一个由 (ruid, euid, suid) 所组成的元组，分别表示当前进程的真实用户ID，有效用户ID和甲暂存用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p></li><li><p><code>os.getresgid</code>()</p><p>返回一个由 (rgid, egid, sgid) 所组成的元组，分别表示当前进程的真实组ID，有效组ID和暂存组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p></li><li><p><code>os.getuid</code>()</p><p>返回当前进程的真实用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.initgroups</code>(<em>username</em>, <em>gid</em>)</p><p>调用系统 initgroups()，使用指定用户所在的所有值来初始化组访问列表，包括指定的组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p></li><li><p><code>os.putenv</code>(<em>key</em>, <em>value</em>)</p><p>将名为 <em>key</em> 的环境变量值设置为 <em>value</em>。该变量名修改会影响由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>os.system()</code></a>， <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a> ，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>fork()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execv" target="_blank" rel="noopener"><code>execv()</code></a> 发起的子进程。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 大部分的Unix系统，Windows。注解 在一些平台，包括 FreeBSD 和 Mac OS X，设置 <code>environ</code> 可能导致内存泄露。详情参考 putenv 相关系统文档。当系统支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 时，<code>os.environ</code> 中的参数赋值会自动转换为对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 的调用。不过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.putenv" target="_blank" rel="noopener"><code>putenv()</code></a> 的调用不会更新 <code>os.environ</code>，因此最好使用 <code>os.environ</code> 对变量赋值。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.putenv</code>，附带参数 <code>key</code>, <code>value</code>。</p></li><li><p><code>os.setegid</code>(<em>egid</em>)</p><p>设置当前进程的有效组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.seteuid</code>(<em>euid</em>)</p><p>设置当前进程的有效用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.setgid</code>(<em>gid</em>)</p><p>设置当前进程的组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.setgroups</code>(<em>groups</em>)</p><p>将 <em>group</em> 参数值设置为与当进程相关联的附加组ID列表。<em>group</em> 参数必须为一个序列，每个元素应为每个组的数字ID。该操作通常只适用于超级用户。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。注解 在 Mac OS X 中，<em>groups</em> 的长度不能超过系统定义的最大有效组 ID 个数，一般为 16。 如果它没有返回与调用 setgroups() 所设置的相同的组列表，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getgroups" target="_blank" rel="noopener"><code>getgroups()</code></a> 的文档。</p></li><li><p><code>os.setpgrp</code>()</p><p>根据已实现的版本（如果有）来调用系统 <code>setpgrp()</code> 或 <code>setpgrp(0, 0)</code> 。相关说明，请参考 Unix 手册。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.setpgid</code>(<em>pid</em>, <em>pgrp</em>)</p><p>使用系统调用 <code>setpgid()</code>，将 <em>pid</em> 对应进程的组ID设置为 <em>pgrp</em>。相关说明，请参考 Unix 手册。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.setpriority</code>(<em>which</em>, <em>who</em>, <em>priority</em>)</p><p>设置程序调度优先级。 <em>which</em> 的值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PROCESS" target="_blank" rel="noopener"><code>PRIO_PROCESS</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PGRP" target="_blank" rel="noopener"><code>PRIO_PGRP</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_USER" target="_blank" rel="noopener"><code>PRIO_USER</code></a> 之一，而 <em>who</em> 会相对于 <em>which</em> (<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PROCESS" target="_blank" rel="noopener"><code>PRIO_PROCESS</code></a> 的进程标识符, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_PGRP" target="_blank" rel="noopener"><code>PRIO_PGRP</code></a> 的进程组标识符和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PRIO_USER" target="_blank" rel="noopener"><code>PRIO_USER</code></a> 的用户 ID) 被解析。 <em>who</em> 值为零 (分别) 表示调用进程，调用进程的进程组或调用进程的真实用户 ID。 <em>priority</em> 是范围在 -20 至 19 的值。 默认优先级为 0；较小的优先级数值会更优先被调度。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.setregid</code>(<em>rgid</em>, <em>egid</em>)</p><p>设置当前进程的真实和有效组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.setresgid</code>(<em>rgid</em>, <em>egid</em>, <em>sgid</em>)</p><p>设置当前进程的真实，有效和暂存组ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p></li><li><p><code>os.setresuid</code>(<em>ruid</em>, <em>euid</em>, <em>suid</em>)</p><p>设置当前进程的真实，有效和暂存用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.2 新版功能.</em></p></li><li><p><code>os.setreuid</code>(<em>ruid</em>, <em>euid</em>)</p><p>设置当前进程的真实和有效用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.getsid</code>(<em>pid</em>)</p><p>调用系统调用 <code>getsid()</code>。相关说明，请参考 Unix 手册。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.setsid</code>()</p><p>使用系统调用 <code>getsid()</code>。相关说明，请参考 Unix 手册。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.setuid</code>(<em>uid</em>)</p><p>设置当前进程的用户ID。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.strerror</code>(<em>code</em>)</p><p>根据 <em>code</em> 中的错误码返回错误消息。 在某些平台上当给出未知错误码时 <code>strerror()</code> 将返回 <code>NULL</code> 并会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。</p></li><li><p><code>os.supports_bytes_environ</code></p><p>如果操作系统上原生环境类型是字节型则为 <code>True</code> (例如在 Windows 上为 <code>False</code>)。<em>3.2 新版功能.</em></p></li><li><p><code>os.umask</code>(<em>mask</em>)</p><p>设定当前数值掩码并返回之前的掩码。</p></li><li><p><code>os.uname</code>()</p><p>返回当前操作系统的识别信息。返回值是一个有5个属性的对象：<code>sysname</code> - 操作系统名<code>nodename</code> - 机器在网络上的名称（需要先设定）<code>release</code> - 操作系统发行信息<code>version</code> - 操作系统版本信息<code>machine</code> - 硬件标识符为了向后兼容，该对象也是可迭代的，像是一个按照 <code>sysname</code>，<code>nodename</code>，<code>release</code>，<code>version</code>，和 <code>machine</code> 顺序组成的元组。有些系统会将 <code>nodename</code> 截短为 8 个字符或截短至前缀部分；获取主机名的一个更好方式是 <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.gethostname" target="_blank" rel="noopener"><code>socket.gethostname()</code></a> 或甚至可以用 <code>socket.gethostbyaddr(socket.gethostname())</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 较新的 Unix 版本。<em>在 3.3 版更改:</em> 返回结果的类型由元组变成一个类似元组的对象，同时具有命名的属性。</p></li><li><p><code>os.unsetenv</code>(<em>key</em>)</p><p>取消设置（删除）名为 <em>key</em> 的环境变量。变量名的改变会影响由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>os.system()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>fork()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execv" target="_blank" rel="noopener"><code>execv()</code></a> 触发的子进程。当系统支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> ，删除在 <code>os.environ</code> 中的变量会自动转换为对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> 的调用。但是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unsetenv" target="_blank" rel="noopener"><code>unsetenv()</code></a> 不能更新 <code>os.environ</code>，因此最好直接删除 <code>os.environ</code> 中的变量。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.unsetenv</code>，附带参数 <code>key</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 大部分的Unix系统。</p></li></ul><h2 id="创建文件对象"><a href="#创建文件对象" class="headerlink" title="创建文件对象"></a>创建文件对象</h2><p>这些函数创建新的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file objects</a> 。（参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>open()</code></a> 以获取打开文件描述符的相关信息。）</p><ul><li><p><code>os.fdopen</code>(<em>fd</em>, <strong>args<em>, </em></strong>kwargs*)</p><p>返回打开文件描述符 <em>fd</em> 对应文件的对象。类似内建 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 函数，二者接受同样的参数。不同之处在于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a> 第一个参数应该为整数。</p></li></ul><h2 id="文件描述符操作"><a href="#文件描述符操作" class="headerlink" title="文件描述符操作"></a>文件描述符操作</h2><p>这些函数对文件描述符所引用的 I/O 流进行操作。</p><p>文件描述符是一些小的整数，对应于当前进程所打开的文件。例如，标准输入的文件描述符通常是0，标准输出是1，标准错误是2。之后被进程打开的文件的文件描述符会被依次指定为3，4，5等。“文件描述符”这个词有点误导性，在 Unix 平台中套接字和管道也被文件描述符所引用。</p><p>当需要时，可以用 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 可以获得 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a> 所对应的文件描述符。需要注意的是，直接使用文件描述符会绕过文件对象的方法，会忽略如数据内部缓冲等情况。</p><ul><li><p><code>os.close</code>(<em>fd</em>)</p><p>关闭文件描述符 <em>fd</em>。注解 该功能适用于低级 I/O 操作，必须用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pipe" target="_blank" rel="noopener"><code>pipe()</code></a> 返回的文件描述符。若要关闭由内建函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a> 返回的 “文件对象”，则应使用其相应的 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.IOBase.close" target="_blank" rel="noopener"><code>close()</code></a> 方法。</p></li><li><p><code>os.closerange</code>(<em>fd_low</em>, <em>fd_high</em>)</p><p>关闭从 <em>fd_low</em> （包括）到 <em>fd_high</em> （排除）间的文件描述符，并忽略错误。类似（但快于）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> fd <span class="keyword">in</span> range(fd_low, fd_high):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.close(fd)</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p><code>os.copy_file_range</code>(<em>src</em>, <em>dst</em>, <em>count</em>, <em>offset_src=None</em>, <em>offset_dst=None</em>)</p><p>从文件描述符 <em>src</em> 复制 <em>count</em> 字节，从偏移量 <em>offset_src</em> 开始读取，到文件描述符 <em>dst</em>，从偏移量 <em>offset_dst</em> 开始写入。如果 <em>offset_src</em> 为 None，则 <em>src</em> 将从当前位置开始读取；<em>offset_dst</em> 同理。<em>src</em> 和 <em>dst</em> 指向的文件必须处于相同的文件系统，否则将会抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 被设为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EXDEV" target="_blank" rel="noopener"><code>errno.EXDEV</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 。此复制的完成没有额外的从内核到用户空间再回到内核的数据转移花费。另外，一些文件系统可能实现额外的优化。完成复制就如同打开两个二进制文件一样。返回值是复制的字节的数目。这可能低于需求的数目。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">Availability</a>: Linux kernel &gt;= 4.5 或 glibc &gt;= 2.27。<em>3.8 新版功能.</em></p></li><li><p><code>os.device_encoding</code>(<em>fd</em>)</p><p>如果连接到终端，则返回一个与 <em>fd</em> 关联的设备描述字符，否则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p></li><li><p><code>os.dup</code>(<em>fd</em>)</p><p>返回一个文件描述符 <em>fd</em> 的副本。该文件描述符的副本是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承的</a>。在 Windows 中，当复制一个标准流（0: stdin, 1: stdout, 2: stderr）时，新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">可继承的</a>。<em>在 3.4 版更改:</em> 新的文件描述符现在是不可继承的。</p></li><li><p><code>os.dup2</code>(<em>fd</em>, <em>fd2</em>, <em>inheritable=True</em>)</p><p>把文件描述符 <em>fd</em> 复制为 <em>fd2</em>，必要时先关闭后者。返回 <em>fd2</em>。新的文件描述符默认是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">可继承的</a>，除非在 <em>inheritable</em> 为 <code>False</code> 时，是不可继承的。<em>在 3.4 版更改:</em> 添加可选参数 <em>inheritable</em>。<em>在 3.7 版更改:</em> 成功时返回 <em>fd2</em>，以过去的版本中，总是返回 <code>None</code>。</p></li><li><p><code>os.fchmod</code>(<em>fd</em>, <em>mode</em>)</p><p>将 <em>fd</em> 指定文件的权限状态修改为 <em>mode</em>。可以参考 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>chmod()</code></a> 中列出 <em>mode</em> 的可用值。从Python 3.3开始，这相当于 <code>os.chmod(fd, mode)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chmod</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.fchown</code>(<em>fd</em>, <em>uid</em>, <em>gid</em>)</p><p>分别将 <em>fd</em> 指定文件的所有者和组 ID 修改为 <em>uid</em> 和 <em>gid</em> 的值。若不想变更其中的某个 ID，可将相应值设为 -1。参考 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chown" target="_blank" rel="noopener"><code>chown()</code></a>。从 Python 3.3 开始，这相当于 <code>os.chown(fd, uid, gid)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chown</code>，附带参数 <code>path</code>、<code>uid</code>、<code>gid</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.fdatasync</code>(<em>fd</em>)</p><p>强制将文件描述符 <em>fd</em> 指定文件写入磁盘。不强制更新元数据。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p><blockquote><p> 该功能在 MacOS 中不可用。 </p></blockquote></li><li><p><code>os.fpathconf</code>(<em>fd</em>, <em>name</em>)</p><p>返回与打开的文件有关的系统配置信息。<em>name</em> 指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX.1，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 <code>pathconf_names</code> 字典中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 <em>name</em>。如果 <em>name</em> 是一个字符串且不是已定义的名称，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。如果当前系统不支持 <em>name</em> 指定的配置名称，即使该名称存在于 <code>pathconf_names</code>，也会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，错误码为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EINVAL" target="_blank" rel="noopener"><code>errno.EINVAL</code></a>。从 Python 3.3 起，此功能等价于 <code>os.pathconf(fd, name)</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.fstat</code>(<em>fd</em>)</p><p>获取文件描述符 <em>fd</em> 的状态. 返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 对象。从 Python 3.3 起，此功能等价于 <code>os.stat(fd)</code>。</p><blockquote><p>参见：  <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 函数。</p></blockquote></li><li><p><code>os.fstatvfs</code>(<em>fd</em>)</p><p>返回文件系统的信息，该文件系统是文件描述符 <em>fd</em> 指向的文件所在的文件系统，与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.statvfs" target="_blank" rel="noopener"><code>statvfs()</code></a> 一样。从 Python 3.3 开始，它等效于 <code>os.statvfs(fd)</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.fsync</code>(<em>fd</em>)</p><p>强制将文件描述符 <em>fd</em> 指向的文件写入磁盘。在 Unix，这将调用原生 <code>fsync()</code> 函数；在 Windows，则是 MS <code>_commit()</code> 函数。如果要写入的是缓冲区内的 Python <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">文件对象</a> <em>f</em>，请先执行 <code>f.flush()</code>，然后执行 <code>os.fsync(f.fileno())</code>，以确保与 <em>f</em> 关联的所有内部缓冲区都写入磁盘。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><code>os.ftruncate</code>(<em>fd</em>, <em>length</em>)</p><p>截断文件描述符 <em>fd</em> 指向的文件，以使其最大为 <em>length</em> 字节。从 Python 3.3 开始，它等效于 <code>os.truncate(fd, length)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.truncate</code>，附带参数 <code>fd</code>, <code>length</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.5 版更改:</em> 添加了 Windows 支持</p></li><li><p><code>os.get_blocking</code>(<em>fd</em>)</p><p>获取文件描述符的阻塞模式：如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_NONBLOCK" target="_blank" rel="noopener"><code>O_NONBLOCK</code></a> 标志位，返回 <code>False</code>，如果该标志位被清除，返回 <code>True</code>。参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.set_blocking" target="_blank" rel="noopener"><code>set_blocking()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.socket.setblocking" target="_blank" rel="noopener"><code>socket.socket.setblocking()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.5 新版功能.</em></p></li><li><p><code>os.isatty</code>(<em>fd</em>)</p><p>如果文件描述符 <em>fd</em> 打开且已连接至 tty 设备（或类 tty 设备），返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p><code>os.lockf</code>(<em>fd</em>, <em>cmd</em>, <em>len</em>)</p><p>在打开的文件描述符上，使用、测试或删除 POSIX 锁。<em>fd</em> 是一个打开的文件描述符。<em>cmd</em> 指定要进行的操作，它们是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_LOCK" target="_blank" rel="noopener"><code>F_LOCK</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_TLOCK" target="_blank" rel="noopener"><code>F_TLOCK</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_ULOCK" target="_blank" rel="noopener"><code>F_ULOCK</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_TEST" target="_blank" rel="noopener"><code>F_TEST</code></a> 中的一个。<em>len</em> 指定哪部分文件需要锁定。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.lockf</code>，附带参数 <code>fd</code>、<code>cmd</code>、<code>len</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.F_LOCK</code></p></li><li><p><code>os.F_TLOCK</code></p></li><li><p><code>os.F_ULOCK</code></p></li><li><p><code>os.F_TEST</code></p><p>标志位，用于指定 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lockf" target="_blank" rel="noopener"><code>lockf()</code></a> 进行哪一种操作。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.lseek</code>(<em>fd</em>, <em>pos</em>, <em>how</em>)</p><p>将文件描述符 <em>fd</em> 的当前位置设置为 <em>pos</em>，位置的计算方式 <em>how</em> 如下：设置为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.SEEK_SET" target="_blank" rel="noopener"><code>SEEK_SET</code></a> 或 <code>0</code> 表示从文件开头计算，设置为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.SEEK_CUR" target="_blank" rel="noopener"><code>SEEK_CUR</code></a> 或 <code>1</code> 表示从文件当前位置计算，设置为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.SEEK_END" target="_blank" rel="noopener"><code>SEEK_END</code></a> 或 <code>2</code> 表示文件末尾计算。返回新指针位置，这个位置是从文件开头计算的，单位是字节。</p></li><li><p><code>os.SEEK_SET</code></p></li><li><p><code>os.SEEK_CUR</code></p></li><li><p><code>os.SEEK_END</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lseek" target="_blank" rel="noopener"><code>lseek()</code></a> 函数的参数，它们的值分别为 0、1 和 2。<em>3.3 新版功能:</em> 某些操作系统可能支持其他值，例如 <code>os.SEEK_HOLE</code> 或 <code>os.SEEK_DATA</code>。</p></li><li><p><code>os.open</code>(<em>path</em>, <em>flags</em>, <em>mode=0o777</em>, <em>**, </em>dir_fd=None*)</p><p>打开文件 <em>path</em>，根据 <em>flags</em> 设置各种标志位，并根据 <em>mode</em> 设置其权限状态。当计算 <em>mode</em> 时，会首先根据当前 umask 值将部分权限去除。本方法返回新文件的描述符。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承</a> 的。有关 flag 和 mode 取值的说明，请参见 C 运行时文档。标志位常量（如 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_RDONLY" target="_blank" rel="noopener"><code>O_RDONLY</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_WRONLY" target="_blank" rel="noopener"><code>O_WRONLY</code></a>）在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中定义。特别地，在 Windows 上需要添加 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_BINARY" target="_blank" rel="noopener"><code>O_BINARY</code></a> 才能以二进制模式打开文件。本函数带有 <em>dir_fd</em> 参数，支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>open</code>，附带参数 <code>path</code>、<code>mode</code>、<code>flags</code>。<em>在 3.4 版更改:</em> 新的文件描述符现在是不可继承的。</p><blockquote><p>注解：本函数适用于底层的 I/O。常规用途请使用内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>，该函数的 <code>read()</code> 和 <code>write()</code> 方法（及其他方法）会返回 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">文件对象</a>。要将文件描述符包装在文件对象中，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a>。</p></blockquote><p><em>3.3 新版功能:</em> <em>dir_fd</em> 参数。</p><p><em>在 3.5 版更改:</em> 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>以下常量是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>open()</code></a> 函数 <em>flags</em> 参数的选项。可以用按位或运算符 <code>|</code> 将它们组合使用。部分常量并非在所有平台上都可用。有关其可用性和用法的说明，请参阅 <em><a href="https://manpages.debian.org/open(2" target="_blank" rel="noopener">open(2)</a>)</em> 手册（Unix 上）或 <a href="https://msdn.microsoft.com/en-us/library/z0kc8e3z.aspx" target="_blank" rel="noopener">MSDN</a> （Windows 上）。</p><ul><li><p><code>os.O_RDONLY</code></p></li><li><p><code>os.O_WRONLY</code></p></li><li><p><code>os.O_RDWR</code></p></li><li><p><code>os.O_APPEND</code></p></li><li><p><code>os.O_CREAT</code></p></li><li><p><code>os.O_EXCL</code></p></li><li><p><code>os.O_TRUNC</code></p><p>上述常量在 Unix 和 Windows 上均可用。</p></li><li><p><code>os.O_DSYNC</code></p></li><li><p><code>os.O_RSYNC</code></p></li><li><p><code>os.O_SYNC</code></p></li><li><p><code>os.O_NDELAY</code></p></li><li><p><code>os.O_NONBLOCK</code></p></li><li><p><code>os.O_NOCTTY</code></p></li><li><p><code>os.O_CLOEXEC</code></p><p>这个常数仅在 Unix 系统中可用。<em>在 3.3 版更改:</em> 增加 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_CLOEXEC" target="_blank" rel="noopener"><code>O_CLOEXEC</code></a> 常量。</p></li><li><p><code>os.O_BINARY</code></p></li><li><p><code>os.O_NOINHERIT</code></p></li><li><p><code>os.O_SHORT_LIVED</code></p></li><li><p><code>os.O_TEMPORARY</code></p></li><li><p><code>os.O_RANDOM</code></p></li><li><p><code>os.O_SEQUENTIAL</code></p></li><li><p><code>os.O_TEXT</code></p><p>这个常数仅在 Windows 系统中可用。</p></li><li><p><code>os.O_ASYNC</code></p></li><li><p><code>os.O_DIRECT</code></p></li><li><p><code>os.O_DIRECTORY</code></p></li><li><p><code>os.O_NOFOLLOW</code></p></li><li><p><code>os.O_NOATIME</code></p></li><li><p><code>os.O_PATH</code></p></li><li><p><code>os.O_TMPFILE</code></p></li><li><p><code>os.O_SHLOCK</code></p></li><li><p><code>os.O_EXLOCK</code></p><p>上述常量是扩展常量，如果 C 库未定义它们，则不存在。<em>在 3.4 版更改:</em> 在支持的系统上增加 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_PATH" target="_blank" rel="noopener"><code>O_PATH</code></a>。增加 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_TMPFILE" target="_blank" rel="noopener"><code>O_TMPFILE</code></a>，仅在 Linux Kernel 3.11 或更高版本可用。</p></li><li><p><code>os.openpty</code>()</p><p>打开一对新的伪终端，返回一对文件描述符 <code>（主，从）</code>，分别为 pty 和 tty。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承</a> 的。对于（稍微）轻量一些的方法，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/pty.html#module-pty" target="_blank" rel="noopener"><code>pty</code></a> 模块。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 某些 Unix。<em>在 3.4 版更改:</em> 新的文件描述符不再可继承。</p></li><li><p><code>os.pipe</code>()</p><p>创建一个管道，返回一对分别用于读取和写入的文件描述符 <code>(r, w)</code>。新的文件描述符是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承</a> 的。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.4 版更改:</em> 新的文件描述符不再可继承。</p></li><li><p><code>os.pipe2</code>(<em>flags</em>)</p><p>创建带有 <em>flags</em> 标志位的管道。可通过对以下一个或多个值进行“或”运算来构造这些 <em>flags</em>：<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_NONBLOCK" target="_blank" rel="noopener"><code>O_NONBLOCK</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_CLOEXEC" target="_blank" rel="noopener"><code>O_CLOEXEC</code></a>。返回一对分别用于读取和写入的文件描述符 <code>(r, w)</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 某些 Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.posix_fallocate</code>(<em>fd</em>, <em>offset</em>, <em>len</em>)</p><p>确保为 <em>fd</em> 指向的文件分配了足够的磁盘空间，该空间从偏移量 <em>offset</em> 开始，到 <em>len</em> 字节为止。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.posix_fadvise</code>(<em>fd</em>, <em>offset</em>, <em>len</em>, <em>advice</em>)</p><p>声明即将以特定模式访问数据，使内核可以提前进行优化。数据范围是从 <em>fd</em> 所指向文件的 <em>offset</em> 开始，持续 <em>len</em> 个字节。<em>advice</em> 的取值是如下之一：<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_NORMAL" target="_blank" rel="noopener"><code>POSIX_FADV_NORMAL</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_SEQUENTIAL" target="_blank" rel="noopener"><code>POSIX_FADV_SEQUENTIAL</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_RANDOM" target="_blank" rel="noopener"><code>POSIX_FADV_RANDOM</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_NOREUSE" target="_blank" rel="noopener"><code>POSIX_FADV_NOREUSE</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_WILLNEED" target="_blank" rel="noopener"><code>POSIX_FADV_WILLNEED</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.POSIX_FADV_DONTNEED" target="_blank" rel="noopener"><code>POSIX_FADV_DONTNEED</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.POSIX_FADV_NORMAL</code></p></li><li><p><code>os.POSIX_FADV_SEQUENTIAL</code></p></li><li><p><code>os.POSIX_FADV_RANDOM</code></p></li><li><p><code>os.POSIX_FADV_NOREUSE</code></p></li><li><p><code>os.POSIX_FADV_WILLNEED</code></p></li><li><p><code>os.POSIX_FADV_DONTNEED</code></p><p>用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_fadvise" target="_blank" rel="noopener"><code>posix_fadvise()</code></a> 的 <em>advice</em> 参数的标志位，指定可能使用的访问模式。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.pread</code>(<em>fd</em>, <em>n</em>, <em>offset</em>)</p><p>从文件描述符 <em>fd</em> 所指向文件的偏移位置 <em>offset</em> 开始，读取至多 <em>n</em> 个字节，而保持文件偏移量不变。返回所读取字节的字节串 (bytestring)。如果到达了 <em>fd</em> 指向的文件末尾，则返回空字节对象。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.preadv</code>(<em>fd</em>, <em>buffers</em>, <em>offset</em>, <em>flags=0</em>)</p><p>从文件描述符 <em>fd</em> 所指向文件的偏移位置 <em>offset</em> 开始，将数据读取至可变 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 缓冲区 <em>buffers</em> 中，保持文件偏移量不变。将数据依次存放到每个缓冲区中，填满一个后继续存放到序列中的下一个缓冲区，来保存其余数据。flags 参数可以由零个或多个标志位进行按位或运算来得到：<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.RWF_HIPRI" target="_blank" rel="noopener"><code>RWF_HIPRI</code></a><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.RWF_NOWAIT" target="_blank" rel="noopener"><code>RWF_NOWAIT</code></a>返回实际读取的字节总数，该总数可以小于所有对象的总容量。操作系统可能对允许使用的缓冲区数量有限制（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 获取 <code>&#39;SC_IOV_MAX&#39;</code> 值）。本方法结合了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.readv" target="_blank" rel="noopener"><code>os.readv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pread" target="_blank" rel="noopener"><code>os.pread()</code></a> 的功能。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 2.6.30 或更高版本，FreeBSD 6.0 或更高版本，OpenBSD 2.7 或更高版本。使用标志位需要 Linux 4.6 或更高版本。<em>3.7 新版功能.</em></p></li><li><p><code>os.RWF_NOWAIT</code></p><p>不要等待无法立即获得的数据。如果指定了此标志，那么当需要从后备存储器中读取数据，或等待文件锁时，系统调用将立即返回。如果成功读取数据，则返回读取的字节数。如果未读取到数据，则返回 <code>-1</code>，并将错误码 errno 置为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EAGAIN" target="_blank" rel="noopener"><code>errno.EAGAIN</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 4.14 或更高版本。<em>3.7 新版功能.</em></p></li><li><p><code>os.RWF_HIPRI</code></p><p>高优先级读/写。允许基于块的文件系统对设备进行轮询，这样可以降低延迟，但可能会占用更多资源。目前在 Linux 上，此功能仅在使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_DIRECT" target="_blank" rel="noopener"><code>O_DIRECT</code></a> 标志打开的文件描述符上可用。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 4.6 或更高版本。<em>3.7 新版功能.</em></p></li><li><p><code>os.pwrite</code>(<em>fd</em>, <em>str</em>, <em>offset</em>)</p><p>将 <em>str</em> 中的字节串 (bytestring) 写入文件描述符 <em>fd</em> 的偏移位置 <em>offset</em> 处，保持文件偏移量不变。返回实际写入的字节数。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.pwritev</code>(<em>fd</em>, <em>buffers</em>, <em>offset</em>, <em>flags=0</em>)</p><p>将缓冲区 <em>buffers</em> 的内容写入文件描述符 <em>fd</em> 的偏移位置 <em>offset</em> 处，保持文件偏移量不变。缓冲区 <em>buffers</em> 必须是由 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 组成的序列。缓冲区以数组顺序处理。先写入第一个缓冲区的全部内容，再写入第二个缓冲区，照此继续。flags 参数可以由零个或多个标志位进行按位或运算来得到：<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.RWF_DSYNC" target="_blank" rel="noopener"><code>RWF_DSYNC</code></a><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.RWF_SYNC" target="_blank" rel="noopener"><code>RWF_SYNC</code></a>返回实际写入的字节总数。操作系统可能对允许使用的缓冲区数量有限制（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 获取 <code>&#39;SC_IOV_MAX&#39;</code> 值）。本方法结合了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.writev" target="_blank" rel="noopener"><code>os.writev()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pwrite" target="_blank" rel="noopener"><code>os.pwrite()</code></a> 的功能。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 2.6.30 或更高版本，FreeBSD 6.0 或更高版本，OpenBSD 2.7 或更高版本。使用标志位需要 Linux 4.7 或更高版本。<em>3.7 新版功能.</em></p></li><li><p><code>os.RWF_DSYNC</code></p><p>提供立即写入功能，等效于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_DSYNC" target="_blank" rel="noopener"><code>O_DSYNC</code></a> <code>open(2)</code> 标志。该标志仅作用于系统调用写入的数据。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 4.7 或更高版本。<em>3.7 新版功能.</em></p></li><li><p><code>os.RWF_SYNC</code></p><p>提供立即写入功能，等效于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_SYNC" target="_blank" rel="noopener"><code>O_SYNC</code></a> <code>open(2)</code> 标志。该标志仅作用于系统调用写入的数据。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 4.7 或更高版本。<em>3.7 新版功能.</em></p></li><li><p><code>os.read</code>(<em>fd</em>, <em>n</em>)</p><p>从文件描述符 <em>fd</em> 中读取至多 <em>n</em> 个字节。返回所读取字节的字节串 (bytestring)。如果到达了 <em>fd</em> 指向的文件末尾，则返回空字节对象。</p><blockquote><p> 该功能适用于低级 I/O 操作，必须用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pipe" target="_blank" rel="noopener"><code>pipe()</code></a> 返回的文件描述符。若要读取由内建函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a> 返回的 “文件对象”，则应使用其相应的 <code>read()</code> 或 <code>readline()</code> 方法。 </p></blockquote><p> <em>在 3.5 版更改:</em> 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。 </p></li><li><p><code>os.sendfile</code>(<em>out</em>, <em>in</em>, <em>offset</em>, <em>count</em>)</p><p><code>os.sendfile</code>(<em>out</em>, <em>in</em>, <em>offset</em>, <em>count</em>, [<em>headers</em>, ][<em>trailers</em>, ]<em>flags=0</em>)</p><p>将文件描述符 <em>in</em> 中的 <em>count</em> 字节复制到文件描述符 <em>out</em> 的偏移位置 <em>offset</em> 处。返回复制的字节数，如果到达 EOF，返回 0。</p><p>定义了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sendfile" target="_blank" rel="noopener"><code>sendfile()</code></a> 的所有平台均支持第一种函数用法。</p><p>在 Linux 上，将 <em>offset</em> 设置为 <code>None</code>，则从 <em>in</em> 的当前位置开始读取，并更新 <em>in</em> 的位置。</p><p>第二种函数用法可以在 Mac OS X 和 FreeBSD 上使用，其中，<em>headers</em> 和 <em>trailers</em> 是任意的缓冲区序列，它们分别在写入 <em>in</em> 的数据前、后被写入。返回值与第一种用法相同。</p><p>在 Mac OS X 和 FreeBSD 上，将 <em>count</em> 设为 0 表示持续复制直到 <em>in</em> 的结尾。</p><p>所有平台都支持将套接字作为 <em>out</em> 文件描述符，有些平台也支持其他类型（如常规文件或管道）。</p><p>跨平台应用程序不应使用 <em>headers</em>、<em>trailers</em> 和 <em>flags</em> 参数。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p><blockquote><p> 注解：有关 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sendfile" target="_blank" rel="noopener"><code>sendfile()</code></a> 的高级封装，参见 <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.socket.sendfile" target="_blank" rel="noopener"><code>socket.socket.sendfile()</code></a>。</p></blockquote></li><li><p><code>os.set_blocking</code>(<em>fd</em>, <em>blocking</em>)</p><p>设置指定文件描述符的阻塞模式：如果 blocking 为 <code>False</code>，则为该描述符设置 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_NONBLOCK" target="_blank" rel="noopener"><code>O_NONBLOCK</code></a> 标志位，反之则清除该标志位。参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.get_blocking" target="_blank" rel="noopener"><code>get_blocking()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/socket.html#socket.socket.setblocking" target="_blank" rel="noopener"><code>socket.socket.setblocking()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.5 新版功能.</em></p></li><li><p><code>os.SF_NODISKIO</code></p></li><li><p><code>os.SF_MNOWAIT</code></p></li><li><p><code>os.SF_SYNC</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sendfile" target="_blank" rel="noopener"><code>sendfile()</code></a> 函数的参数（假设当前实现支持这些参数）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.readv</code>(<em>fd</em>, <em>buffers</em>)</p><p>从文件描述符 <em>fd</em> 将数据读取至多个可变的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 缓冲区 <em>buffers</em> 中。将数据依次存放到每个缓冲区中，填满一个后继续存放到序列中的下一个缓冲区，来保存其余数据。返回实际读取的字节总数，该总数可以小于所有对象的总容量。操作系统可能对允许使用的缓冲区数量有限制（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 获取 <code>&#39;SC_IOV_MAX&#39;</code> 值）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.tcgetpgrp</code>(<em>fd</em>)</p><p>返回与 <em>fd</em> 指定的终端相关联的进程组（<em>fd</em> 是由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 返回的已打开的文件描述符）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.tcsetpgrp</code>(<em>fd</em>, <em>pg</em>)</p><p>设置与 <em>fd</em> 指定的终端相关联的进程组为 <em>pg\</em>（<em>fd</em> 是由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 返回的已打开的文件描述符）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.ttyname</code>(<em>fd</em>)</p><p>返回一个字符串，该字符串表示与文件描述符 <em>fd</em> 关联的终端。如果 <em>fd</em> 没有与终端关联，则抛出异常。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.write</code>(<em>fd</em>, <em>str</em>)</p><p>将 <em>str</em> 中的字节串 (bytestring) 写入文件描述符 <em>fd</em>。返回实际写入的字节数。</p><blockquote><p> 该功能适用于低级 I/O 操作，必须用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pipe" target="_blank" rel="noopener"><code>pipe()</code></a> 返回的文件描述符。若要写入由内建函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.popen" target="_blank" rel="noopener"><code>popen()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fdopen" target="_blank" rel="noopener"><code>fdopen()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdout" target="_blank" rel="noopener"><code>sys.stdout</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stderr" target="_blank" rel="noopener"><code>sys.stderr</code></a> 返回的 “文件对象”，则应使用其相应的 <code>write()</code> 方法。 </p></blockquote><p> <em>在 3.5 版更改:</em> 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。 </p></li><li><p><code>os.writev</code>(<em>fd</em>, <em>buffers</em>)</p><p>将缓冲区 <em>buffers</em> 的内容写入文件描述符 <em>fd</em>。缓冲区 <em>buffers</em> 必须是由 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">字节类对象</a> 组成的序列。缓冲区以数组顺序处理。先写入第一个缓冲区的全部内容，再写入第二个缓冲区，照此继续。</p><p>返回实际写入的字节总数。</p><p>操作系统可能对允许使用的缓冲区数量有限制（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 获取 <code>&#39;SC_IOV_MAX&#39;</code> 值）。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p><p><em>3.3 新版功能.</em></p></li></ul><h3 id="查询终端的尺寸"><a href="#查询终端的尺寸" class="headerlink" title="查询终端的尺寸"></a>查询终端的尺寸</h3><p><em>3.3 新版功能.</em></p><ul><li><p><code>os.get_terminal_size</code>(<em>fd=STDOUT_FILENO</em>)</p><p>返回终端窗口的尺寸，格式为 <code>(columns, lines)</code>，它是类型为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.terminal_size" target="_blank" rel="noopener"><code>terminal_size</code></a> 的元组。可选参数 <code>fd</code> （默认为 <code>STDOUT_FILENO</code> 或标准输出）指定应查询的文件描述符。如果文件描述符未连接到终端，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_terminal_size" target="_blank" rel="noopener"><code>shutil.get_terminal_size()</code></a> 是供常规使用的高阶函数，<code>os.get_terminal_size</code> 是其底层的实现。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><em>class</em> <code>os.terminal_size</code></p><p>元组的子类，存储终端窗口尺寸 <code>(columns, lines)</code>。<code>columns</code>终端窗口的宽度，单位为字符。<code>lines</code>终端窗口的高度，单位为字符。</p></li></ul><h3 id="文件描述符的继承"><a href="#文件描述符的继承" class="headerlink" title="文件描述符的继承"></a>文件描述符的继承</h3><p><em>3.4 新版功能.</em></p><p>每个文件描述符都有一个 “inheritable”（可继承）标志位，该标志位控制了文件描述符是否可以由子进程继承。从 Python 3.4 开始，由 Python 创建的文件描述符默认是不可继承的。</p><p>在 UNIX 上，执行新程序时，不可继承的文件描述符在子进程中是关闭的，其他文件描述符将被继承。</p><p>在 Windows 上，不可继承的句柄和文件描述符在子进程中是关闭的，但标准流（文件描述符 0、1 和 2 即标准输入、标准输出和标准错误）是始终继承的。如果使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 函数，所有可继承的句柄和文件描述符都将被继承。如果使用 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 模块，将关闭除标准流以外的所有文件描述符，并且仅当 <em>close_fds</em> 参数为 <code>False</code> 时才继承可继承的句柄。</p><ul><li><p><code>os.get_inheritable</code>(<em>fd</em>)</p><p>获取指定文件描述符的“可继承”标志位（为布尔值）。</p></li><li><p><code>os.set_inheritable</code>(<em>fd</em>, <em>inheritable</em>)</p><p>设置指定文件描述符的“可继承”标志位。</p></li><li><p><code>os.get_handle_inheritable</code>(<em>handle</em>)</p><p>获取指定句柄的“可继承”标志位（为布尔值）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。</p></li><li><p><code>os.set_handle_inheritable</code>(<em>handle</em>, <em>inheritable</em>)</p><p>设置指定句柄的“可继承”标志位。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。</p></li></ul><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>在某些 Unix 平台上，许多函数支持以下一项或多项功能：</p><ul><li><p><strong>指定文件描述符为参数：</strong> 通常在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中提供给函数的 <em>path</em> 参数必须是表示文件路径的字符串，但是，某些函数现在可以接受其 <em>path</em> 参数为打开文件描述符，该函数将对描述符指向的文件进行操作。（对于 POSIX 系统，Python 将调用以 <code>f</code> 开头的函数变体（如调用 <code>fchdir</code> 而不是 <code>chdir</code>）。）</p><p>可以用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_fd" target="_blank" rel="noopener"><code>os.supports_fd</code></a> 检查某个函数在你的平台上是否支持将 <em>path</em> 参数指定为文件描述符。如果不支持，使用该功能将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p><p>如果该函数还支持 <em>dir_fd</em> 或 <em>follow_symlinks</em> 参数，那么用文件描述符作为 <em>path</em> 后就不能再指定上述参数了。</p></li><li><p><strong>基于目录描述符的相对路径：</strong> 如果 <em>dir_fd</em> 不是 <code>None</code>，它就应该是一个指向目录的文件描述符，这时待操作的 path 应该是相对路径，相对路径是相对于前述目录的。如果 path 是绝对路径，则 <em>dir_fd</em> 将被忽略。（对于 POSIX 系统，Python 将调用该函数的变体，变体以 <code>at</code> 结尾，可能以 <code>f</code> 开头（如调用 <code>faccessat</code> 而不是 <code>access</code>）。</p><p>可以用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_dir_fd" target="_blank" rel="noopener"><code>os.supports_dir_fd</code></a> 检查某个函数在你的平台上是否支持 <em>dir_fd</em>。如果不支持，使用该功能将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p></li><li><p><strong>不跟踪符号链接：</strong> 如果 <em>follow_symlinks</em> 为 <code>False</code>，并且待操作路径的最后一个元素是符号链接，则该函数将在符号链接本身而不是链接所指向的文件上操作。（对于 POSIX 系统，Python 将调用该函数的 <code>l...</code> 变体。）</p><p>可以用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_follow_symlinks" target="_blank" rel="noopener"><code>os.supports_follow_symlinks</code></a> 检查某个函数在你的平台上是否支持 <em>follow_symlinks</em>。如果不支持，使用该功能将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p></li><li><p><code>os.access</code>(<em>path</em>, <em>mode</em>, <em>**, </em>dir_fd=None<em>, </em>effective_ids=False<em>, </em>follow_symlinks=True*)</p><p>使用 实际用户ID/用户组ID 测试对 <em>path</em> 的访问。请注意，大多数测试操作将使用 有效用户ID/用户组ID，因此可以在 suid/sgid 环境中运用此例程，来测试调用用户是否具有对 <em>path</em> 的指定访问权限。<em>mode</em> 为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.F_OK" target="_blank" rel="noopener"><code>F_OK</code></a> 时用于测试 <em>path</em> 是否存在，也可以对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.R_OK" target="_blank" rel="noopener"><code>R_OK</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.W_OK" target="_blank" rel="noopener"><code>W_OK</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.X_OK" target="_blank" rel="noopener"><code>X_OK</code></a> 中的一个或多个进行“或”运算来测试指定权限。允许访问则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#True" target="_blank" rel="noopener"><code>True</code></a>，否则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>。更多信息请参见 Unix 手册页 <em><a href="https://manpages.debian.org/access(2" target="_blank" rel="noopener">access(2)</a>)</em>。本函数支持指定 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。如果 <em>effective_ids</em> 为 <code>True</code>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>access()</code></a> 将使用 有效用户ID/用户组ID 而非 实际用户ID/用户组ID 进行访问检查。您的平台可能不支持 <em>effective_ids</em>，您可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_effective_ids" target="_blank" rel="noopener"><code>os.supports_effective_ids</code></a> 检查它是否可用。如果不可用，使用它时会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p><blockquote><p>注解：使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>access()</code></a> 来检查用户是否具有某项权限（如打开文件的权限），然后再使用 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 打开文件，这样做存在一个安全漏洞，因为用户可能会在检查和打开文件之间的时间里做其他操作。推荐使用 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-eafp" target="_blank" rel="noopener">EAFP</a> 技术。如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> os.access(<span class="string">"myfile"</span>, os.R_OK):</span><br><span class="line">&gt;     <span class="keyword">with</span> open(<span class="string">"myfile"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">&gt;         <span class="keyword">return</span> fp.read()</span><br><span class="line">&gt; <span class="keyword">return</span> <span class="string">"some default data"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>​      最好写成: </p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">try</span>:</span><br><span class="line">&gt;     fp = open(<span class="string">"myfile"</span>)</span><br><span class="line">&gt; <span class="keyword">except</span> PermissionError:</span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="string">"some default data"</span></span><br><span class="line">&gt; <span class="keyword">else</span>:</span><br><span class="line">&gt;     <span class="keyword">with</span> fp:</span><br><span class="line">&gt;         <span class="keyword">return</span> fp.read()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>即使 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>access()</code></a> 指示 I/O 操作会成功，但实际操作仍可能失败，尤其是对网络文件系统的操作，其权限语义可能超出常规的 POSIX 权限位模型。</p></blockquote><ul><li><p><code>os.F_OK</code></p></li><li><p><code>os.R_OK</code></p></li><li><p><code>os.W_OK</code></p></li><li><p><code>os.X_OK</code></p><p>作为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>access()</code></a> 的 <em>mode</em> 参数的可选值，分别测试 <em>path</em> 的存在性、可读性、可写性和可执行性。</p></li><li><p><code>os.chdir</code>(<em>path</em>)</p><p>将当前工作目录更改为 <em>path</em>。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。其中，描述符必须指向打开的目录，不能是打开的文件。本函数可以抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 及其子类的异常，如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileNotFoundError" target="_blank" rel="noopener"><code>FileNotFoundError</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#PermissionError" target="_blank" rel="noopener"><code>PermissionError</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotADirectoryError" target="_blank" rel="noopener"><code>NotADirectoryError</code></a> 异常。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chdir</code>，附带参数 <code>path</code>。<em>3.3 新版功能:</em> 在某些平台上新增支持将 <em>path</em> 参数指定为文件描述符。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.chflags</code>(<em>path</em>, <em>flags</em>, <em>**, </em>follow_symlinks=True*)</p><p>将 <em>path</em> 的 flags 设置为其他由数字表示的 <em>flags</em>。<em>flags</em> 可以用以下值按位或组合起来（以下值在 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中定义）：<a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_NODUMP" target="_blank" rel="noopener"><code>stat.UF_NODUMP</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_IMMUTABLE" target="_blank" rel="noopener"><code>stat.UF_IMMUTABLE</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_APPEND" target="_blank" rel="noopener"><code>stat.UF_APPEND</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_OPAQUE" target="_blank" rel="noopener"><code>stat.UF_OPAQUE</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_NOUNLINK" target="_blank" rel="noopener"><code>stat.UF_NOUNLINK</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_COMPRESSED" target="_blank" rel="noopener"><code>stat.UF_COMPRESSED</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.UF_HIDDEN" target="_blank" rel="noopener"><code>stat.UF_HIDDEN</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_ARCHIVED" target="_blank" rel="noopener"><code>stat.SF_ARCHIVED</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_IMMUTABLE" target="_blank" rel="noopener"><code>stat.SF_IMMUTABLE</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_APPEND" target="_blank" rel="noopener"><code>stat.SF_APPEND</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_NOUNLINK" target="_blank" rel="noopener"><code>stat.SF_NOUNLINK</code></a><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.SF_SNAPSHOT" target="_blank" rel="noopener"><code>stat.SF_SNAPSHOT</code></a>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chflags</code>，附带参数 <code>path</code>、<code>flags</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能:</em> <em>follow_symlinks</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.chmod</code>(<em>path</em>, <em>mode</em>, <em>**, </em>dir_fd=None<em>, </em>follow_symlinks=True*)</p><p>将 <em>path</em> 的 mode 更改为其他由数字表示的 <em>mode</em>。<em>mode</em> 可以用以下值之一，也可以将它们按位或组合起来（以下值在 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中定义）：</p><ul><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ISUID" target="_blank" rel="noopener"><code>stat.S_ISUID</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ISGID" target="_blank" rel="noopener"><code>stat.S_ISGID</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ENFMT" target="_blank" rel="noopener"><code>stat.S_ENFMT</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ISVTX" target="_blank" rel="noopener"><code>stat.S_ISVTX</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IREAD" target="_blank" rel="noopener"><code>stat.S_IREAD</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IWRITE" target="_blank" rel="noopener"><code>stat.S_IWRITE</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IEXEC" target="_blank" rel="noopener"><code>stat.S_IEXEC</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRWXU" target="_blank" rel="noopener"><code>stat.S_IRWXU</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRUSR" target="_blank" rel="noopener"><code>stat.S_IRUSR</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IWUSR" target="_blank" rel="noopener"><code>stat.S_IWUSR</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IXUSR" target="_blank" rel="noopener"><code>stat.S_IXUSR</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRWXG" target="_blank" rel="noopener"><code>stat.S_IRWXG</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRGRP" target="_blank" rel="noopener"><code>stat.S_IRGRP</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IWGRP" target="_blank" rel="noopener"><code>stat.S_IWGRP</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IXGRP" target="_blank" rel="noopener"><code>stat.S_IXGRP</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IRWXO" target="_blank" rel="noopener"><code>stat.S_IRWXO</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IROTH" target="_blank" rel="noopener"><code>stat.S_IROTH</code></a></li><li><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IWOTH" target="_blank" rel="noopener"><code>stat.S_IWOTH</code></a></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_IXOTH" target="_blank" rel="noopener"><code>stat.S_IXOTH</code></a></p><p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符</a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">指定基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。 </p></li></ul><blockquote><p> 尽管 Windows 支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>chmod()</code></a>，但只能用它设置文件的只读标志（<code>stat.S_IWRITE</code> 和 <code>stat.S_IREAD</code> 常量或对应的整数值）。所有其他标志位都会被忽略。</p></blockquote></li></ul><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chmod</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。</p><p><em>3.3 新版功能:</em> 添加了指定 <em>path</em> 为文件描述符的支持，以及 <em>dir_fd</em> 和 <em>follow_symlinks</em> 参数。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><ul><li><p><code>os.chown</code>(<em>path</em>, <em>uid</em>, <em>gid</em>, <em>**, </em>dir_fd=None<em>, </em>follow_symlinks=True*)</p><p>将 <em>path</em> 的用户和组 ID 分别修改为数字形式的 <em>uid</em> 和 <em>gid</em>。若要使其中某个 ID 保持不变，请将其置为 -1。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符</a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">指定基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。参见更高阶的函数 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.chown" target="_blank" rel="noopener"><code>shutil.chown()</code></a>，除了数字 ID 之外，它也接受名称。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chown</code>，附带参数 <code>path</code>、<code>uid</code>、<code>gid</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能:</em> 添加了指定 <em>path</em> 为文件描述符的支持，以及 <em>dir_fd</em> 和 <em>follow_symlinks</em> 参数。<em>在 3.6 版更改:</em> 支持 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.chroot</code>(<em>path</em>)</p><p>将当前进程的根目录更改为 <em>path</em>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.fchdir</code>(<em>fd</em>)</p><p>将当前工作目录更改为文件描述符 <em>fd</em> 指向的目录。fd 必须指向打开的目录而非文件。从 Python 3.3 开始，它等效于 <code>os.chdir(fd)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chdir</code>，附带参数 <code>path</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.getcwd</code>()</p><p>返回表示当前工作目录的字符串。</p></li><li><p><code>os.getcwdb</code>()</p><p>返回表示当前工作目录的字节串 (bytestring)。<em>在 3.8 版更改:</em> 在 Windows 上，本函数现在会使用 UTF-8 编码格式而不是 ANSI 代码页：请参看 <a href="https://www.python.org/dev/peps/pep-0529" target="_blank" rel="noopener"><strong>PEP 529</strong></a> 了解具体原因。 该函数在 Windows 上不再被弃用。</p></li><li><p><code>os.lchflags</code>(<em>path</em>, <em>flags</em>)</p><p>将 <em>path</em> 的 flags 设置为其他由数字表示的 <em>flags</em>，与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chflags" target="_blank" rel="noopener"><code>chflags()</code></a> 类似，但不跟踪符号链接。从 Python 3.3 开始，它等效于 <code>os.chflags(path, flags, follow_symlinks=False)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chflags</code>，附带参数 <code>path</code>、<code>flags</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.lchmod</code>(<em>path</em>, <em>mode</em>)</p><p>将 <em>path</em> 的权限状态修改为 <em>mode</em>。如果 path 是符号链接，则影响符号链接本身而非链接目标。可以参考 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>chmod()</code></a> 中列出 <em>mode</em> 的可用值。从 Python 3.3 开始，它等效于 <code>os.chmod(path, mode, follow_symlinks=False)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chmod</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.lchown</code>(<em>path</em>, <em>uid</em>, <em>gid</em>)</p><p>将 <em>path</em> 的用户和组 ID 分别修改为数字形式的 <em>uid</em> 和 <em>gid</em>，本函数不跟踪符号链接。从 Python 3.3 开始，它等效于 <code>os.chown(path, uid, gid, follow_symlinks=False)</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.chown</code>，附带参数 <code>path</code>、<code>uid</code>、<code>gid</code>、<code>dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.link</code>(<em>src</em>, <em>dst</em>, <em>**, </em>src_dir_fd=None<em>, </em>dst_dir_fd=None<em>, </em>follow_symlinks=True*)</p><p>创建一个指向 <em>src</em> 的硬链接，名为 <em>dst</em>。本函数支持将 <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 中的一个或两个指定为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>，支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.link</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加了对 Windows 的支持。<em>3.3 新版功能:</em> 添加 <em>src_dir_fd</em>、<em>dst_dir_fd</em> 和 <em>follow_symlinks</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p></li><li><p><code>os.listdir</code>(<em>path=’.’</em>)</p><p>返回一个列表，该列表包含了 <em>path</em> 中所有文件与目录的名称。该列表按任意顺序排列，并且不包含特殊条目 <code>&#39;.&#39;</code> 和 <code>&#39;..&#39;</code>，即使它们确实在目录中存在。<em>path</em> 可以是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。如果 <em>path</em> 是（直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入） <code>bytes</code> 类型，则返回的文件名也将是 <code>bytes</code> 类型，其他情况下是 <code>str</code> 类型。本函数也支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>，其中描述符必须指向目录。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.listdir</code>，附带参数 <code>path</code>。</p><blockquote><p>要将 <code>str</code> 类型的文件名编码为 <code>bytes</code>，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsencode" target="_blank" rel="noopener"><code>fsencode()</code></a>。</p></blockquote><p> <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 函数返回目录内文件名的同时，也返回文件属性信息，它在某些具体情况下能提供更好的性能。</p></li></ul><p><em>在 3.2 版更改:</em> <em>path</em> 变为可选参数。</p><p><em>3.3 新版功能:</em> 新增支持将 <em>path</em> 参数指定为打开的文件描述符。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><ul><li><code>os.lstat</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</li></ul><p>在给定路径上执行本函数，其操作相当于 <code>lstat()</code> 系统调用，类似于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 但不跟踪符号链接。返回值是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 对象。</p><p>在不支持符号链接的平台上，本函数是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 的别名。</p><p>从 Python 3.3 起，此功能等价于 <code>os.stat(path, dir_fd=dir_fd, follow_symlinks=False)</code>。</p><p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。</p><p><em>在 3.2 版更改:</em> 添加对 Windows 6.0 (Vista) 符号链接的支持。</p><p><em>在 3.3 版更改:</em> 添加了 <em>dir_fd</em> 参数。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p><p><em>在 3.8 版更改:</em> 目前在 Windows 上，遇到表示另一个路径的重解析点（即名称代理，包括符号链接和目录结点），本函数将打开它。其他种类的重解析点由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 交由操作系统解析。</p><ul><li><p><code>os.mkdir</code>(<em>path</em>, <em>mode=0o777</em>, <em>**, </em>dir_fd=None*)</p><p>创建一个名为 <em>path</em> 的目录，应用以数字表示的权限模式 <em>mode</em>。如果目录已存在，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileExistsError" target="_blank" rel="noopener"><code>FileExistsError</code></a> 异常。某些系统会忽略 <em>mode</em>。如果没有忽略它，那么将首先从它中减去当前的 umask 值。如果除最后 9 位（即 <em>mode</em> 八进制的最后 3 位）之外，还设置了其他位，则其他位的含义取决于各个平台。在某些平台上，它们会被忽略，应显式调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>chmod()</code></a> 进行设置。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。如果需要创建临时目录，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#module-tempfile" target="_blank" rel="noopener"><code>tempfile</code></a> 模块中的 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>tempfile.mkdtemp()</code></a> 函数。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.mkdir</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.makedirs</code>(<em>name</em>, <em>mode=0o777</em>, <em>exist_ok=False</em>)</p><p>递归目录创建函数。与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.mkdir" target="_blank" rel="noopener"><code>mkdir()</code></a> 类似，但会自动创建到达最后一级目录所需要的中间目录。<em>mode</em> 参数会传递给 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.mkdir" target="_blank" rel="noopener"><code>mkdir()</code></a>，用来创建最后一级目录，对于该参数的解释，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#mkdir-modebits" target="_blank" rel="noopener">mkdir() 中的描述</a>。要设置某些新建的父目录的权限，可以在调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.makedirs" target="_blank" rel="noopener"><code>makedirs()</code></a> 之前设置 umask。现有父目录的权限不会更改。如果 <em>exist_ok</em> 为 <code>False</code> (默认值)，则如果目标目录已存在将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileExistsError" target="_blank" rel="noopener"><code>FileExistsError</code></a>。</p><blockquote><p>如果要创建的路径元素包含 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pardir" target="_blank" rel="noopener"><code>pardir</code></a> (如 UNIX 系统中的 “..”) <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.makedirs" target="_blank" rel="noopener"><code>makedirs()</code></a> 将无法明确目标。</p></blockquote></li></ul><p>本函数能正确处理 UNC 路径。</p><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.mkdir</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。</p><p><em>3.2 新版功能:</em> <em>exist_ok</em> 参数。</p><p><em>在 3.4.1 版更改:</em> 在 Python 3.4.1 以前，如果 <em>exist_ok</em> 为 <code>True</code>，且目录已存在，且 <em>mode</em> 与现有目录的权限不匹配，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.makedirs" target="_blank" rel="noopener"><code>makedirs()</code></a> 仍会抛出错误。由于无法安全地实现此行为，因此在 Python 3.4.1 中将该行为删除。请参阅 <a href="https://bugs.python.org/issue21082" target="_blank" rel="noopener">bpo-21082</a>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>在 3.7 版更改:</em> <em>mode</em> 参数不再影响新创建的中间目录的权限。</p><ul><li><p><code>os.mkfifo</code>(<em>path</em>, <em>mode=0o666</em>, <em>**, </em>dir_fd=None*)</p><p>创建一个名为 <em>path</em> 的 FIFO（命名管道，一种先进先出队列），具有以数字表示的权限状态 <em>mode</em>。将从 mode 中首先减去当前的 umask 值。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。FIFO 是可以像常规文件一样访问的管道。FIFO 如果没有被删除（如使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unlink" target="_blank" rel="noopener"><code>os.unlink()</code></a>），会一直存在。通常，FIFO 用作“客户端”和“服务器”进程之间的汇合点：服务器打开 FIFO 进行读取，而客户端打开 FIFO 进行写入。请注意，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.mkfifo" target="_blank" rel="noopener"><code>mkfifo()</code></a> 不会打开 FIFO — 它只是创建汇合点。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.mknod</code>(<em>path</em>, <em>mode=0o600</em>, <em>device=0</em>, <em>**, </em>dir_fd=None*)</p><p>创建一个名为 <em>path</em> 的文件系统节点（文件，设备专用文件或命名管道）。<em>mode</em> 指定权限和节点类型，方法是将权限与下列节点类型 <code>stat.S_IFREG</code>、<code>stat.S_IFCHR</code>、<code>stat.S_IFBLK</code> 和 <code>stat.S_IFIFO</code> 之一（按位或）组合（这些常量可以在 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中找到）。对于 <code>stat.S_IFCHR</code> 和 <code>stat.S_IFBLK</code>，<em>device</em> 参数指定了新创建的设备专用文件（可能会用到 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.makedev" target="_blank" rel="noopener"><code>os.makedev()</code></a>），否则该参数将被忽略。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.major</code>(<em>device</em>)</p><p>提取主设备号，提取自原始设备号（通常是 <code>stat</code> 中的 <code>st_dev</code> 或 <code>st_rdev</code> 字段）。</p></li><li><p><code>os.minor</code>(<em>device</em>)</p><p>提取次设备号，提取自原始设备号（通常是 <code>stat</code> 中的 <code>st_dev</code> 或 <code>st_rdev</code> 字段）。</p></li><li><p><code>os.makedev</code>(<em>major</em>, <em>minor</em>)</p><p>将主设备号和次设备号组合成原始设备号。</p></li><li><p><code>os.pathconf</code>(<em>path</em>, <em>name</em>)</p><p>返回所给名称的文件有关的系统配置信息。<em>name</em> 指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX.1，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 <code>pathconf_names</code> 字典中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 <em>name</em>。如果 <em>name</em> 是一个字符串且不是已定义的名称，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。如果当前系统不支持 <em>name</em> 指定的配置名称，即使该名称存在于 <code>pathconf_names</code>，也会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，错误码为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EINVAL" target="_blank" rel="noopener"><code>errno.EINVAL</code></a>。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.pathconf_names</code></p><p>字典，表示映射关系，为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.pathconf" target="_blank" rel="noopener"><code>pathconf()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fpathconf" target="_blank" rel="noopener"><code>fpathconf()</code></a> 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.readlink</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</p><p>返回一个字符串，为符号链接指向的实际路径。其结果可以是绝对或相对路径。如果是相对路径，则可用 <code>os.path.join(os.path.dirname(path), result)</code> 转换为绝对路径。如果 <em>path</em> 是字符串对象（直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入），则结果也将是字符串对象，且此类调用可能会引发 UnicodeDecodeError。如果 <em>path</em> 是字节对象（直接传入或间接传入），则结果将会是字节对象。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。当尝试解析的路径可能含有链接时，请改用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.realpath" target="_blank" rel="noopener"><code>realpath()</code></a> 以正确处理递归和平台差异。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加对 Windows 6.0 (Vista) 符号链接的支持。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 在 Unix 上可以接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。<em>在 3.8 版更改:</em> 在 Windows 上接受 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 和字节对象。<em>在 3.8 版更改:</em> 增加了对目录链接的支持，且返回值改为了“替换路径”的形式（通常带有 <code>\\?\</code> 前缀），而不是先前那样返回可选的 “print name” 字段。</p></li><li><p><code>os.remove</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</p><p>移除（删除）文件 <em>path</em>。如果 <em>path</em> 是目录，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IsADirectoryError" target="_blank" rel="noopener"><code>IsADirectoryError</code></a> 异常。请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rmdir" target="_blank" rel="noopener"><code>rmdir()</code></a> 删除目录。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。在 Windows 上，尝试删除正在使用的文件会抛出异常。而在 Unix 上，虽然该文件的条目会被删除，但分配给文件的存储空间仍然不可用，直到原始文件不再使用为止。本函数在语义上与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.unlink" target="_blank" rel="noopener"><code>unlink()</code></a> 相同。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.remove</code>，附带参数 <code>path</code>、<code>dir_fd</code>。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.removedirs</code>(<em>name</em>)</p><p>递归删除目录。工作方式类似于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rmdir" target="_blank" rel="noopener"><code>rmdir()</code></a>，不同之处在于，如果成功删除了末尾一级目录，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.removedirs" target="_blank" rel="noopener"><code>removedirs()</code></a> 会尝试依次删除 <em>path</em> 中提到的每个父目录，直到抛出错误为止（但该错误会被忽略，因为这通常表示父目录不是空目录）。例如，<code>os.removedirs(&#39;foo/bar/baz&#39;)</code> 将首先删除目录 <code>&#39;foo/bar/baz&#39;</code>，然后如果 <code>&#39;foo/bar&#39;</code> 和 <code>&#39;foo&#39;</code> 为空，则继续删除它们。如果无法成功删除末尾一级目录，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.remove</code>，附带参数 <code>path</code>、<code>dir_fd</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.rename</code>(<em>src</em>, <em>dst</em>, <em>**, </em>src_dir_fd=None<em>, </em>dst_dir_fd=None*)</p><p>将文件或目录 <em>src</em> 重命名为 <em>dst</em>。如果 <em>dst</em> 已存在，则下列情况下将会操作失败，并抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 的子类：在 Windows 上，如果 <em>dst</em> 已存在，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileExistsError" target="_blank" rel="noopener"><code>FileExistsError</code></a> 异常。在 Unix 上，如果 <em>src</em> 是文件而 <em>dst</em> 是目录，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IsADirectoryError" target="_blank" rel="noopener"><code>IsADirectoryError</code></a> 异常，反之则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotADirectoryError" target="_blank" rel="noopener"><code>NotADirectoryError</code></a> 异常。如果两者都是目录且 <em>dst</em> 为空，则 <em>dst</em> 将被静默替换。如果 <em>dst</em> 是非空目录，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。如果两者都是文件，则在用户具有权限的情况下，将对 <em>dst</em> 进行静默替换。如果 <em>src</em> 和 <em>dst</em> 在不同的文件系统上，则本操作在某些 Unix 分支上可能会失败。如果成功，重命名操作将是一个原子操作（这是 POSIX 的要求）。本函数支持将 <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 中的一个或两个指定为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。如果需要在不同平台上都能替换目标，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.replace" target="_blank" rel="noopener"><code>replace()</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.rename</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。<em>3.3 新版功能:</em> <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p></li><li><p><code>os.renames</code>(<em>old</em>, <em>new</em>)</p><p>递归重命名目录或文件。工作方式类似 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>rename()</code></a>，除了会首先创建新路径所需的中间目录。重命名后，将调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.removedirs" target="_blank" rel="noopener"><code>removedirs()</code></a> 删除旧路径中不需要的目录。注解 如果用户没有权限删除末级的目录或文件，则本函数可能会无法建立新的目录结构。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.rename</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>old</em> 和 <em>new</em>。</p></li><li><p><code>os.replace</code>(<em>src</em>, <em>dst</em>, <em>**, </em>src_dir_fd=None<em>, </em>dst_dir_fd=None*)</p><p>将文件或目录 <em>src</em> 重命名为 <em>dst</em>。如果 <em>dst</em> 是目录，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。如果 <em>dst</em> 已存在且为文件，则在用户具有权限的情况下，将对其进行静默替换。如果 <em>src</em> 和 <em>dst</em> 在不同的文件系统上，本操作可能会失败。如果成功，重命名操作将是一个原子操作（这是 POSIX 的要求）。本函数支持将 <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 中的一个或两个指定为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.rename</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。<em>3.3 新版功能.**在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p></li><li><p><code>os.rmdir</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</p><p>移除（删除）目录 <em>path</em>。如果目录不存在或不为空，则会分别抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileNotFoundError" target="_blank" rel="noopener"><code>FileNotFoundError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。要删除整个目录树，可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree" target="_blank" rel="noopener"><code>shutil.rmtree()</code></a>。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.rmdir</code>，附带参数 <code>path</code>、<code>dir_fd</code>。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.scandir</code>(<em>path=’.’</em>)</p><p>返回一个迭代出 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry" target="_blank" rel="noopener"><code>os.DirEntry</code></a> 对象的迭代器，这些对象对应于 <em>path</em> 目录中的条目。条目的生成顺序是任意的，特殊条目 <code>&#39;.&#39;</code> 和 <code>&#39;..&#39;</code> 不包括在内。如果需要文件类型或文件属性信息，使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 代替 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>listdir()</code></a> 可以大大提高这部分代码的性能，因为如果操作系统在扫描目录时返回的是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry" target="_blank" rel="noopener"><code>os.DirEntry</code></a> 对象，则该对象包含了这些信息。所有 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry" target="_blank" rel="noopener"><code>os.DirEntry</code></a> 的方法都可能执行一次系统调用，但是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.is_dir" target="_blank" rel="noopener"><code>is_dir()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.is_file" target="_blank" rel="noopener"><code>is_file()</code></a> 通常只在有符号链接时才执行一次系统调用。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.stat" target="_blank" rel="noopener"><code>os.DirEntry.stat()</code></a> 在 Unix 上始终需要一次系统调用，而在 Windows 上只在有符号链接时才需要。<em>path</em> 可以是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。如果 <em>path</em> 是（直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入的） <code>bytes</code> 类型，那么每个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry" target="_blank" rel="noopener"><code>os.DirEntry</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.name" target="_blank" rel="noopener"><code>name</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.path" target="_blank" rel="noopener"><code>path</code></a> 属性将是 <code>bytes</code> 类型，其他情况下是 <code>str</code> 类型。本函数也支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>，其中描述符必须指向目录。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.scandir</code>，附带参数 <code>path</code>。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 迭代器支持 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-context-manager" target="_blank" rel="noopener">上下文管理</a> 协议，并具有以下方法：<code>scandir.close</code>()关闭迭代器并释放占用的资源。当迭代器迭代完毕，或垃圾回收，或迭代过程出错时，将自动调用本方法。但仍建议显式调用它或使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句。</p><p><em>3.6 新版功能.</em></p><p>下面的例子演示了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的简单用法，用来显示给定 <em>path</em> 中所有不以 <code>&#39;.&#39;</code> 开头的文件（不包括目录）。<code>entry.is_file()</code> 通常不会增加一次额外的系统调用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> os.scandir(path) <span class="keyword">as</span> it:</span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> it:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> entry.name.startswith(<span class="string">'.'</span>) <span class="keyword">and</span> entry.is_file():</span><br><span class="line">            print(entry.name)</span><br></pre></td></tr></table></figure><blockquote><p>在基于 Unix 的系统上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 使用系统的 <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html" target="_blank" rel="noopener">opendir()</a> 和 <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html" target="_blank" rel="noopener">readdir()</a> 函数。在 Windows 上，它使用 Win32 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418(v=vs.85" target="_blank" rel="noopener">FindFirstFileW</a>.aspx) 和 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364428(v=vs.85" target="_blank" rel="noopener">FindNextFileW</a>.aspx) 函数。</p></blockquote><p><em>.5 新版功能.</em></p><p><em>3.6 新版功能:</em> 添加了对 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-context-manager" target="_blank" rel="noopener">上下文管理</a> 协议和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir.close" target="_blank" rel="noopener"><code>close()</code></a> 方法的支持。如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 迭代器没有迭代完毕且没有显式关闭，其析构函数将发出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ResourceWarning" target="_blank" rel="noopener"><code>ResourceWarning</code></a> 警告。</p><p>本函数接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>在 3.7 版更改:</em> 在 Unix 上新增支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。</p></li><li><p><em>class</em> <code>os.DirEntry</code></p><p>由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 生成的对象，用于显示目录内某个条目的文件路径和其他文件属性。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 将在不进行额外系统调用的情况下，提供尽可能多的此类信息。每次进行 <code>stat()</code> 或 <code>lstat()</code> 系统调用时，<code>os.DirEntry</code> 对象会将结果缓存下来。</p><p><code>os.DirEntry</code> 实例不适合存储在长期存在的数据结构中，如果你知道文件元数据已更改，或者自调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 以来已经经过了很长时间，请调用 <code>os.stat(entry.path)</code> 来获取最新信息。</p><p>因为 <code>os.DirEntry</code> 方法可以进行系统调用，所以它也可能抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。如需精确定位错误，可以逐个调用 <code>os.DirEntry</code> 中的方法来捕获 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>，并适当处理。</p><p>为了能直接用作 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>，<code>os.DirEntry</code> 实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口。</p><p><code>os.DirEntry</code> 实例所包含的属性和方法如下：</p><ul><li><p><code>name</code></p><p>本条目的基本文件名，是根据 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数得出的相对路径。如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数是 <code>bytes</code> 类型，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.name" target="_blank" rel="noopener"><code>name</code></a> 属性也是 <code>bytes</code> 类型，否则为 <code>str</code>。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsdecode" target="_blank" rel="noopener"><code>fsdecode()</code></a> 解码 byte 类型的文件名。</p></li><li><p><code>path</code></p><p>本条目的完整路径：等效于 <code>os.path.join(scandir_path, entry.name)</code>，其中 <em>scandir_path</em> 就是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数。仅当 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数为绝对路径时，本路径才是绝对路径。如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">文件描述符</a>，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>path</code></a> 属性与上述 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.name" target="_blank" rel="noopener"><code>name</code></a> 属性相同。如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 的 <em>path</em> 参数是 <code>bytes</code> 类型，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>path</code></a> 属性也是 <code>bytes</code> 类型，否则为 <code>str</code>。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsdecode" target="_blank" rel="noopener"><code>fsdecode()</code></a> 解码 byte 类型的文件名。</p></li><li><p><code>inode</code>()</p><p>返回本条目的索引节点号 (inode number)。这一结果是缓存在 <code>os.DirEntry</code> 对象中的，请调用 <code>os.stat(entry.path, follow_symlinks=False).st_ino</code> 来获取最新信息。一开始没有缓存时，在 Windows 上需要一次系统调用，但在 Unix 上不需要。</p></li><li><p><code>is_dir</code>(<em>**, </em>follow_symlinks=True*)</p><p>如果本条目是目录，或是指向目录的符号链接，则返回 <code>True</code>。如果本条目是文件，或指向任何其他类型的文件，或该目录不再存在，则返回 <code>False</code>。如果 <em>follow_symlinks</em> 是 <code>False</code>，那么仅当本条目为目录时返回 <code>True</code> （不跟踪符号链接），如果本条目是任何类型的文件，或该文件不再存在，则返回 <code>False</code>。这一结果是缓存在 <code>os.DirEntry</code> 对象中的，且 <em>follow_symlinks</em> 为 <code>True</code> 和 <code>False</code> 时的缓存是分开的。请调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#stat.S_ISDIR" target="_blank" rel="noopener"><code>stat.S_ISDIR()</code></a> 来获取最新信息。一开始没有缓存时，大多数情况下不需要系统调用。特别是对于非符号链接，Windows 和 Unix 都不需要系统调用，除非某些 Unix 文件系统（如网络文件系统）返回了 <code>dirent.d_type == DT_UNKNOWN</code>。如果本条目是符号链接，则需要一次系统调用来跟踪它（除非 <em>follow_symlinks</em> 为 <code>False</code>）。本方法可能抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#PermissionError" target="_blank" rel="noopener"><code>PermissionError</code></a> 异常，但 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileNotFoundError" target="_blank" rel="noopener"><code>FileNotFoundError</code></a> 异常会被内部捕获且不会抛出。</p></li><li><p><code>is_file</code>(<em>**, </em>follow_symlinks=True*)</p><p>如果本条目是文件，或是指向文件的符号链接，则返回 <code>True</code>。如果本条目是目录，或指向目录，或指向其他非文件条目，或该文件不再存在，则返回 <code>False</code>。如果 <em>follow_symlinks</em> 是 <code>False</code>，那么仅当本条目为文件时返回 <code>True</code> （不跟踪符号链接），如果本条目是目录或其他非文件条目，或该文件不再存在，则返回 <code>False</code>。这一结果是缓存在 <code>os.DirEntry</code> 对象中的。缓存、系统调用、异常抛出都与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.DirEntry.is_dir" target="_blank" rel="noopener"><code>is_dir()</code></a> 一致。</p></li><li><p><code>is_symlink</code>()</p><p>如果本条目是符号链接（即使是断开的链接），返回 <code>True</code>。如果是目录或任何类型的文件，或本条目不再存在，返回 <code>False</code>。这一结果是缓存在 <code>os.DirEntry</code> 对象中的，请调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>os.path.islink()</code></a> 来获取最新信息。一开始没有缓存时，大多数情况下不需要系统调用。其实 Windows 和 Unix 都不需要系统调用，除非某些 Unix 文件系统（如网络文件系统）返回了 <code>dirent.d_type == DT_UNKNOWN</code>。本方法可能抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，如 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#PermissionError" target="_blank" rel="noopener"><code>PermissionError</code></a> 异常，但 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#FileNotFoundError" target="_blank" rel="noopener"><code>FileNotFoundError</code></a> 异常会被内部捕获且不会抛出。</p></li><li><p><code>stat</code>(<em>**, </em>follow_symlinks=True*)</p><p>返回本条目对应的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 对象。本方法默认会跟踪符号链接，要获取符号链接本身的 stat，请添加 <code>follow_symlinks=False</code> 参数。在 Unix 上，本方法需要一次系统调用。在 Windows 上，仅在 <em>follow_symlinks</em> 为 <code>True</code> 且该条目是一个重解析点（如符号链接或目录结点）时，才需要一次系统调用。在 Windows 上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 的 <code>st_ino</code>、<code>st_dev</code> 和 <code>st_nlink</code> 属性总是为零。请调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 以获得这些属性。这一结果是缓存在 <code>os.DirEntry</code> 对象中的，且 <em>follow_symlinks</em> 为 <code>True</code> 和 <code>False</code> 时的缓存是分开的。请调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 来获取最新信息。</p></li></ul><p>注意，<code>os.DirEntry</code> 和 <a href="https://docs.python.org/zh-cn/3.8/library/pathlib.html#pathlib.Path" target="_blank" rel="noopener"><code>pathlib.Path</code></a> 的几个属性和方法之间存在很好的对应关系。具体来说是 <code>name</code> 属性，以及 <code>is_dir()</code>、<code>is_file()</code>、<code>is_symlink()</code> 和 <code>stat()</code> 方法，在两个类中具有相同的含义。</p><p><em>3.5 新版功能.</em></p><p><em>在 3.6 版更改:</em> 添加了对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口的支持。在 Windows 上添加了对 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型路径的支持。</p></li><li><p><code>os.stat</code>(<em>path</em>, <em>**, </em>dir_fd=None<em>, </em>follow_symlinks=True*)</p><p>获取文件或文件描述符的状态。在所给路径上执行等效于 <code>stat()</code> 系统调用的操作。<em>path</em> 可以是字符串类型，或（直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入的） bytes 类型，或打开的文件描述符。返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 对象。</p><p>本函数默认会跟踪符号链接，要获取符号链接本身的 stat，请添加 <code>follow_symlinks=False</code> 参数，或使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>lstat()</code></a>。</p><p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。</p><p>在 Windows 上，传入 <code>follow_symlinks=False</code> 将禁用所有名称代理重解析点，其中包括符号链接和目录结点。其他类型的重解析点将直接打开，比如不像链接的或系统无法跟踪的重解析点。当多个链接形成一个链时，本方法可能会返回原始链接的 stat，无法完整遍历到非链接的对象。在这种情况下，要获取最终路径的 stat，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.realpath" target="_blank" rel="noopener"><code>os.path.realpath()</code></a> 函数尽可能地解析路径，并在解析结果上调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>lstat()</code></a>。这不适用于空链接或交接点，否则会抛出异常。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statinfo = os.stat(<span class="string">'somefile.txt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statinfo</span><br><span class="line">os.stat_result(st_mode=<span class="number">33188</span>, st_ino=<span class="number">7876932</span>, st_dev=<span class="number">234881026</span>,</span><br><span class="line">st_nlink=<span class="number">1</span>, st_uid=<span class="number">501</span>, st_gid=<span class="number">501</span>, st_size=<span class="number">264</span>, st_atime=<span class="number">1297230295</span>,</span><br><span class="line">st_mtime=<span class="number">1297230027</span>, st_ctime=<span class="number">1297230027</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>statinfo.st_size</span><br><span class="line"><span class="number">264</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fstat" target="_blank" rel="noopener"><code>fstat()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>lstat()</code></a> 函数。</p></blockquote><p><em>3.3 新版功能:</em> 增加 <em>dir_fd</em> 和 <em>follow_symlinks</em> 参数，可指定文件描述符代替路径。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>在 3.8 版更改:</em> 在 Windows 上，本方法将跟踪系统能解析的所有重解析点，并且传入 <code>follow_symlinks=False</code> 会停止跟踪所有名称代理重解析点。现在，如果操作系统遇到无法跟踪的重解析点，<em>stat</em> 将返回原始路径的信息，就像已指定 <code>follow_symlinks=False</code> 一样，而不会抛出异常。</p><p><em>class</em> <code>os.stat_result</code></p><p>本对象的属性大致对应于 <code>stat</code> 结构体成员，主要作为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fstat" target="_blank" rel="noopener"><code>os.fstat()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>os.lstat()</code></a> 的返回值。</p><p>属性：</p><ul><li><p><code>st_mode</code></p><p>文件模式：包括文件类型和文件模式位（即权限位）。</p></li><li><p><code>st_ino</code></p><p>与平台有关，但如果不为零，则根据 <code>st_dev</code> 值唯一地标识文件。通常：在 Unix 上该值表示索引节点号 (inode number)。在 Windows 上该值表示 <a href="https://msdn.microsoft.com/en-us/library/aa363788" target="_blank" rel="noopener">文件索引号</a> 。</p></li><li><p><code>st_dev</code></p><p>该文件所在设备的标识符。</p></li><li><p><code>st_nlink</code></p><p>硬链接的数量。</p></li><li><p><code>st_uid</code></p><p>文件所有者的用户 ID。</p></li><li><p><code>st_gid</code></p><p>文件所有者的用户组 ID。</p></li><li><p><code>st_size</code></p><p>文件大小（以字节为单位），文件可以是常规文件或符号链接。符号链接的大小是它包含的路径的长度，不包括末尾的空字节。</p></li></ul><p>时间戳：</p><ul><li><p><code>st_atime</code></p><p>最近的访问时间，以秒为单位。</p></li><li><p><code>st_mtime</code></p><p>最近的修改时间，以秒为单位。</p></li><li><p><code>st_ctime</code></p><p>取决于平台：在 Unix 上表示最近的元数据更改时间，在 Windows 上表示创建时间，以秒为单位。</p></li><li><p><code>st_atime_ns</code></p><p>最近的访问时间，以纳秒表示，为整数。</p></li><li><p><code>st_mtime_ns</code></p><p>最近的修改时间，以纳秒表示，为整数。</p></li><li><p><code>st_ctime_ns</code></p><p>取决于平台：在 Unix 上表示最近的元数据更改时间，在 Windows 上表示创建时间，以纳秒表示，为整数。</p></li></ul><blockquote><p> <code>st_atime</code>](<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime)、[`st_mtime`](https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime)" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime)、[`st_mtime`](https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime)</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime" target="_blank" rel="noopener"><code>st_ctime</code></a> 属性的确切含义和分辨率取决于操作系统和文件系统。例如，在使用 FAT 或 FAT32 文件系统的 Windows 上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime" target="_blank" rel="noopener"><code>st_mtime</code></a> 有 2 秒的分辨率，而 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime" target="_blank" rel="noopener"><code>st_atime</code></a> 仅有 1 天的分辨率。详细信息请参阅操作系统文档。</p><p>类似地，尽管 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime_ns" target="_blank" rel="noopener"><code>st_atime_ns</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime_ns" target="_blank" rel="noopener"><code>st_mtime_ns</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime_ns" target="_blank" rel="noopener"><code>st_ctime_ns</code></a> 始终以纳秒表示，但许多系统并不提供纳秒精度。在确实提供纳秒精度的系统上，用于存储 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime" target="_blank" rel="noopener"><code>st_atime</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime" target="_blank" rel="noopener"><code>st_mtime</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime" target="_blank" rel="noopener"><code>st_ctime</code></a> 的浮点对象无法保留所有精度，因此不够精确。如果需要确切的时间戳，则应始终使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime_ns" target="_blank" rel="noopener"><code>st_atime_ns</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime_ns" target="_blank" rel="noopener"><code>st_mtime_ns</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime_ns" target="_blank" rel="noopener"><code>st_ctime_ns</code></a>。</p></blockquote><p>在某些 Unix 系统上（如 Linux 上），以下属性可能也可用：</p><ul><li><p><code>st_blocks</code></p><p>为文件分配的字节块数，每块 512 字节。文件是稀疏文件时，它可能小于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_size" target="_blank" rel="noopener"><code>st_size</code></a>/512。</p></li><li><p><code>st_blksize</code></p><p>“首选的” 块大小，用于提高文件系统 I/O 效率。写入文件时块大小太小可能会导致读取-修改-重写效率低下。</p></li><li><p><code>st_rdev</code></p><p>设备类型（如果是 inode 设备）。</p></li><li><p><code>st_flags</code></p><p>用户定义的文件标志位。</p></li></ul><p>在其他 Unix 系统上（如 FreeBSD 上），以下属性可能可用（但仅当 root 使用它们时才被填充）：</p><ul><li><p><code>st_gen</code></p><p>文件生成号。</p></li><li><p><code>st_birthtime</code></p><p>文件创建时间。</p></li></ul><p>在 Solaris 及其衍生版本上，以下属性可能也可用：</p><ul><li><p><code>st_fstype</code></p><p>文件所在文件系统的类型的唯一标识，为字符串。</p></li></ul><p>在 Mac OS 系统上，以下属性可能也可用：</p><ul><li><p><code>st_rsize</code></p><p>文件的实际大小。</p></li><li><p><code>st_creator</code></p><p>文件的创建者。</p></li><li><p><code>st_type</code></p><p>文件类型。</p></li></ul><p>在 Windows 系统上，以下属性也可用：</p><ul><li><p><code>st_file_attributes</code></p><p>Windows 文件属性：<code>dwFileAttributes</code>，由 <code>GetFileInformationByHandle()</code> 返回的 <code>BY_HANDLE_FILE_INFORMATION</code> 结构体的成员之一。请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中的 <code>FILE_ATTRIBUTE_*</code> 常量。</p></li><li><p><code>st_reparse_tag</code></p><p>当 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_file_attributes" target="_blank" rel="noopener"><code>st_file_attributes</code></a> 存在 <code>FILE_ATTRIBUTE_REPARSE_POINT</code> 集合时，本字段包含重解析点类型标记。请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 模块中的 <code>IO_REPARSE_TAG_*</code> 常量。</p></li></ul><p>标准模块 <a href="https://docs.python.org/zh-cn/3.8/library/stat.html#module-stat" target="_blank" rel="noopener"><code>stat</code></a> 中定义了函数和常量，这些函数和常量可用于从 <code>stat</code> 结构体中提取信息。（在 Windows 上，某些项填充的是虚值。）</p><p>为了向后兼容，一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 实例还可以作为至少包含 10 个整数的元组访问，以提供 <code>stat</code> 结构中最重要（和可移植）的成员，整数顺序为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mode" target="_blank" rel="noopener"><code>st_mode</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ino" target="_blank" rel="noopener"><code>st_ino</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_dev" target="_blank" rel="noopener"><code>st_dev</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_nlink" target="_blank" rel="noopener"><code>st_nlink</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_uid" target="_blank" rel="noopener"><code>st_uid</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_gid" target="_blank" rel="noopener"><code>st_gid</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_size" target="_blank" rel="noopener"><code>st_size</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime" target="_blank" rel="noopener"><code>st_atime</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime" target="_blank" rel="noopener"><code>st_mtime</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime" target="_blank" rel="noopener"><code>st_ctime</code></a>。某些实现可能在末尾还有更多项。为了与旧版 Python 兼容，以元组形式访问 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result" target="_blank" rel="noopener"><code>stat_result</code></a> 始终返回整数。</p><p><em>3.3 新版功能:</em> 添加了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_atime_ns" target="_blank" rel="noopener"><code>st_atime_ns</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mtime_ns" target="_blank" rel="noopener"><code>st_mtime_ns</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ctime_ns" target="_blank" rel="noopener"><code>st_ctime_ns</code></a> 成员。</p><p><em>3.5 新版功能:</em> 在 Windows 上添加了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_file_attributes" target="_blank" rel="noopener"><code>st_file_attributes</code></a> 成员。</p><p><em>在 3.5 版更改:</em> 在 Windows 上，如果可用，会返回文件索引作为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_ino" target="_blank" rel="noopener"><code>st_ino</code></a> 的值。</p><p><em>3.7 新版功能:</em> 在 Solaris 及其衍生版本上添加了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_fstype" target="_blank" rel="noopener"><code>st_fstype</code></a> 成员。</p><p><em>3.8 新版功能:</em> 在 Windows 上添加了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_reparse_tag" target="_blank" rel="noopener"><code>st_reparse_tag</code></a> 成员。</p><p><em>在 3.8 版更改:</em> 在 Windows 上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat_result.st_mode" target="_blank" rel="noopener"><code>st_mode</code></a> 成员现在可以根据需要将特殊文件标识为 <code>S_IFCHR</code>、<code>S_IFIFO</code> 或 <code>S_IFBLK</code>。</p><ul><li><p><code>os.statvfs</code>(<em>path</em>)</p><p>在所给的路径上执行 <code>statvfs()</code> 系统调用。返回值是一个对象，其属性描述了所给路径上的文件系统，并且与 <code>statvfs</code> 结构体的成员相对应，即：<code>f_bsize</code>, <code>f_frsize</code>, <code>f_blocks</code>, <code>f_bfree</code>, <code>f_bavail</code>, <code>f_files</code>, <code>f_ffree</code>, <code>f_favail</code>, <code>f_flag</code>, <code>f_namemax</code>, <code>f_fsid</code>。</p><p>为 <code>f_flag</code> 属性位定义了两个模块级常量：如果存在 <code>ST_RDONLY</code> 位，则文件系统以只读挂载；如果存在 <code>ST_NOSUID</code> 位，则文件系统禁用或不支持 setuid/setgid 位。</p><p>为基于 GNU/glibc 的系统还定义了额外的模块级常量。它们是 <code>ST_NODEV</code> （禁止访问设备专用文件），<code>ST_NOEXEC</code> （禁止执行程序），<code>ST_SYNCHRONOUS</code> （写入后立即同步），<code>ST_MANDLOCK</code> （允许文件系统上的强制锁定），<code>ST_WRITE</code> （写入文件/目录/符号链接），<code>ST_APPEND</code> （仅追加文件），<code>ST_IMMUTABLE</code> （不可变文件），<code>ST_NOATIME</code> （不更新访问时间），<code>ST_NODIRATIME</code> （不更新目录访问时间），<code>ST_RELATIME</code> （相对于 mtime/ctime 更新访问时间）。</p><p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p><p><em>在 3.2 版更改:</em> 添加了 <code>ST_RDONLY</code> 和 <code>ST_NOSUID</code> 常量。</p><p><em>3.3 新版功能:</em> 新增支持将 <em>path</em> 参数指定为打开的文件描述符。</p><p><em>在 3.4 版更改:</em> 添加了 <code>ST_NODEV</code>、<code>ST_NOEXEC</code>、<code>ST_SYNCHRONOUS</code>、<code>ST_MANDLOCK</code>、<code>ST_WRITE</code>、<code>ST_APPEND</code>、<code>ST_IMMUTABLE</code>、<code>ST_NOATIME</code>、<code>ST_NODIRATIME</code> 和 <code>ST_RELATIME</code> 常量。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>3.7 新版功能:</em> 添加了 <code>f_fsid</code>。</p></li></ul><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.supports_dir_fd</span><br></pre></td></tr></table></figure><p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 对象，指示 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中的哪些函数接受一个打开的文件描述符作为 <em>dir_fd</em> 参数。不同平台提供的功能不同，且 Python 用于实现 <em>dir_fd</em> 参数的底层函数并非在 Python 支持的所有平台上都可用。考虑到一致性，支持 <em>dir_fd</em> 的函数始终允许指定描述符，但如果在底层不支持时调用了该函数，则会抛出异常。（在所有平台上始终支持将 <em>dir_fd</em> 指定为 <code>None</code>。）</p><p>要检查某个函数是否接受打开的文件描述符作为 <em>dir_fd</em> 参数，请在 <code>supports_dir_fd</code> 前使用 <code>in</code> 运算符。例如，如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 在当前平台上接受打开的文件描述符作为 <em>dir_fd</em> 参数，则此表达式的计算结果为 <code>True</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.stat <span class="keyword">in</span> os.supports_dir_fd</span><br></pre></td></tr></table></figure><p>目前 <em>dir_fd</em> 参数仅在 Unix 平台上有效，在 Windows 上均无效。</p><p><em>3.3 新版功能.</em></p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.supports_effective_ids</span><br></pre></td></tr></table></figure><p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 对象，指示 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>os.access()</code></a> 是否允许在当前平台上将其 <em>effective_ids</em> 参数指定为 <code>True</code>。（所有平台都支持将 <em>effective_ids</em> 指定为 <code>False</code>。）如果当前平台支持，则集合将包含 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>os.access()</code></a>，否则集合为空。</p><p>如果当前平台上的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>os.access()</code></a> 支持 <code>effective_ids=True</code>，则此表达式的计算结果为 <code>True</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.access <span class="keyword">in</span> os.supports_effective_ids</span><br></pre></td></tr></table></figure><p>目前仅 Unix 平台支持 <em>effective_ids</em>，Windows 不支持。</p><p><em>3.3 新版功能.</em></p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.supports_fd</span><br></pre></td></tr></table></figure><p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 对象，指示在当前平台上 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中的哪些函数接受一个打开的文件描述符作为 <em>path</em> 参数。不同平台提供的功能不同，且 Python 所使用到的底层函数（用于实现接受描述符作为 <em>path</em>）并非在 Python 支持的所有平台上都可用。</p><p>要判断某个函数是否接受打开的文件描述符作为 <em>path</em> 参数，请在 <code>supports_fd</code> 前使用 <code>in</code> 运算符。例如，如果 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chdir" target="_blank" rel="noopener"><code>os.chdir()</code></a> 在当前平台上接受打开的文件描述符作为 <em>path</em> 参数，则此表达式的计算结果为 <code>True</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.chdir <span class="keyword">in</span> os.supports_fd</span><br></pre></td></tr></table></figure><p><em>3.3 新版功能.</em></p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.supports_follow_symlinks</span><br></pre></td></tr></table></figure><p>一个 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 对象，指示在当前平台上 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块中的哪些函数的 <em>follow_symlinks</em> 参数可指定为 <code>False</code>。不同平台提供的功能不同，且 Python 用于实现 <em>follow_symlinks</em> 的底层函数并非在 Python 支持的所有平台上都可用。考虑到一致性，支持 <em>follow_symlinks</em> 的函数始终允许将其指定为 <code>False</code>，但如果在底层不支持时调用了该函数，则会抛出异常。（在所有平台上始终支持将 <em>follow_symlinks</em> 指定为 <code>True</code>。）</p><p>要检查某个函数的 <em>follow_symlinks</em> 参数是否可以指定为 <code>False</code>，请在 <code>supports_follow_symlinks</code> 前使用 <code>in</code> 运算符。例如，如果在当前平台上调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 时可以指定 <code>follow_symlinks=False</code>，则此表达式的计算结果为 <code>True</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.stat <span class="keyword">in</span> os.supports_follow_symlinks</span><br></pre></td></tr></table></figure><p><em>3.3 新版功能.</em></p></li><li><p><code>os.symlink</code>(<em>src</em>, <em>dst</em>, <em>target_is_directory=False</em>, <em>**, </em>dir_fd=None*)</p><p>创建一个指向 <em>src</em> 的符号链接，名为 <em>dst</em>。</p><p>在 Windows 上，符号链接可以表示文件或目录两种类型，并且不会动态改变类型。如果目标存在，则新建链接的类型将与目标一致。否则，如果 <em>target_is_directory</em> 为 <code>True</code>，则符号链接将创建为目录链接，为 <code>False</code> （默认）将创建为文件链接。在非 Windows 平台上，<em>target_is_directory</em> 被忽略。</p><p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a></p><blockquote><p>在 Windows 10 或更高版本上，如果启用了开发人员模式，非特权帐户可以创建符号链接。如果开发人员模式不可用/未启用，则需要 <em>SeCreateSymbolicLinkPrivilege</em> 权限，或者该进程必须以管理员身份运行。</p><p>当本函数由非特权账户调用时，抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p></blockquote><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.symlink</code>，附带参数 <code>src</code>、<code>dst</code>、<code>dir_fd</code>。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p><p><em>在 3.2 版更改:</em> 添加对 Windows 6.0 (Vista) 符号链接的支持。</p><p><em>3.3 新版功能:</em> 添加了 <em>dir_fd</em> 参数，现在在非 Windows 平台上允许 <em>target_is_directory</em> 参数。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>src</em> 和 <em>dst</em>。</p><p><em>在 3.8 版更改:</em> 针对启用了开发人员模式的 Windows，添加了非特权账户创建符号链接的支持。</p></li><li><p><code>os.sync</code>()</p><p>强制将所有内容写入磁盘。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.truncate</code>(<em>path</em>, <em>length</em>)</p><p>截断 <em>path</em> 对应的文件，以使其最大为 <em>length</em> 字节。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.truncate</code>，附带参数 <code>path</code>, <code>length</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>3.3 新版功能.**在 3.5 版更改:</em> 添加了 Windows 支持<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.unlink</code>(<em>path</em>, <em>**, </em>dir_fd=None*)</p><p>移除（删除）文件 <em>path</em>。该函数在语义上与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.remove" target="_blank" rel="noopener"><code>remove()</code></a> 相同，<code>unlink</code> 是其传统的 Unix 名称。请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.remove" target="_blank" rel="noopener"><code>remove()</code></a> 的文档以获取更多信息。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.remove</code>，附带参数 <code>path</code>、<code>dir_fd</code>。<em>3.3 新版功能:</em> <em>dir_fd</em> 参数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.utime</code>(<em>path</em>, <em>times=None</em>, <em>**, [</em>ns<em>, ]</em>dir_fd=None<em>, </em>follow_symlinks=True*)</p><p>设置文件 <em>path</em> 的访问时间和修改时间。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.utime" target="_blank" rel="noopener"><code>utime()</code></a> 有 <em>times</em> 和 <em>ns</em> 两个可选参数，它们指定了设置给 <em>path</em> 的时间，用法如下：  </p><ul><li>如果指定 <em>ns</em>，它必须是一个 <code>(atime_ns, mtime_ns)</code> 形式的二元组，其中每个成员都是一个表示纳秒的整数。</li><li>如果 <em>times</em> 不为 <code>None</code>，则它必须是 <code>(atime, mtime)</code> 形式的二元组，其中每个成员都是一个表示秒的 int 或 float。</li><li>如果 <em>times</em> 为 <code>None</code> 且未指定 <em>ns</em>，则相当于指定 <code>ns=(atime_ns, mtime_ns)</code>，其中两个时间均为当前时间。</li></ul><p>同时为 <em>times</em> 和 <em>ns</em> 指定元组会出错。</p><p>注意，根据操作系统记录访问时间和修改时间的分辨率，后续的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a> 调用可能不会返回此处设置的确切时间。请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>stat()</code></a>。保留精确时间的最佳方法是使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 结果对象中的 <em>st_atime_ns</em> 和 <em>st_mtime_ns</em> 字段，并将 <em>ns</em> 参数设置为 utime。</p><p>本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符</a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">指定基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。</p><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.utime</code>，附带参数 <code>path</code>、<code>times</code>、<code>ns</code>、<code>dir_fd</code>。</p><p><em>3.3 新版功能:</em> 新增支持将 <em>path</em> 参数指定为打开的文件描述符，以及支持 <em>dir_fd</em>、<em>follow_symlinks</em> 和 <em>ns</em> 参数。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.walk</code>(<em>top</em>, <em>topdown=True</em>, <em>onerror=None</em>, <em>followlinks=False</em>)</p><p>生成目录树中的文件名，方式是按上-&gt;下或下-&gt;上顺序浏览目录树。对于以 <em>top</em> 为根的目录树中的每个目录（包括 <em>top</em> 本身），它都会生成一个三元组 <code>(dirpath, dirnames, filenames)</code>。</p><p><em>dirpath</em> 是一个字符串，表示目录的路径。<em>dirnames</em> 是一个列表，内含 <em>dirpath</em> 中子目录的名称（不包括 <code>&#39;.&#39;</code> 和 <code>&#39;..&#39;</code> ）。<em>filenames</em> 也是列表，内含 <em>dirpath</em> 中文件（非目录）的名称。注意，列表中的名称不包含路径部分。要获取 <em>dirpath</em> 中文件或目录的完整路径（从 <em>top</em> 起始），请执行 <code>os.path.join(dirpath, name)</code>。</p><p>如果可选参数 <em>topdown</em> 为 <code>True</code> 或未指定，则在所有子目录的三元组之前生成父目录的三元组（目录是自上而下生成的）。如果 <em>topdown</em> 为 <code>False</code>，则在所有子目录的三元组生成之后再生成父目录的三元组（目录是自下而上生成的）。无论 <em>topdown</em> 为何值，在生成目录及其子目录的元组之前，都将检索全部子目录列表。</p><p>当 <em>topdown</em> 为 <code>True</code> 时，调用者可以就地修改 <em>dirnames</em> 列表（也许用到了 <a href="https://docs.python.org/zh-cn/3.8/reference/simple_stmts.html#del" target="_blank" rel="noopener"><code>del</code></a> 或切片），而 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 将仅仅递归到仍保留在 <em>dirnames</em> 中的子目录内。这可用于减少搜索、加入特定的访问顺序，甚至可在继续 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 之前告知 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 由调用者新建或重命名的目录的信息。当 <em>topdown</em> 为 <code>False</code> 时，修改 <em>dirnames</em> 对 walk 的行为没有影响，因为在自下而上模式中，<em>dirnames</em> 中的目录是在 <em>dirpath</em> 本身之前生成的。</p><p>默认将忽略 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>scandir()</code></a> 调用中的错误。如果指定了可选参数 <em>onerror</em>，它应该是一个函数。出错时它会被调用，参数是一个 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 实例。它可以报告错误然后继续遍历，或者抛出异常然后中止遍历。注意，可以从异常对象的 <code>filename</code> 属性中获取出错的文件名。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 默认不会递归进指向目录的符号链接。可以在支持符号链接的系统上将 <em>followlinks</em> 设置为 <code>True</code>，以访问符号链接指向的目录。</p><blockquote><p> 注意，如果链接指向自身的父目录，则将 <em>followlinks</em> 设置为 <code>True</code> 可能导致无限递归。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 不会记录它已经访问过的目录。 </p><p> 如果传入的是相对路径，请不要在恢复 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 之间更改当前工作目录。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 不会更改当前目录，并假定其调用者也不会更改当前目录。 </p></blockquote><p>下面的示例遍历起始目录内所有子目录，打印每个目录内的文件占用的字节数，CVS 子目录不会被遍历:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> join, getsize</span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">'python/Lib/email'</span>):</span><br><span class="line">    print(root, <span class="string">"consumes"</span>, end=<span class="string">" "</span>)</span><br><span class="line">    print(sum(getsize(join(root, name)) <span class="keyword">for</span> name <span class="keyword">in</span> files), end=<span class="string">" "</span>)</span><br><span class="line">    print(<span class="string">"bytes in"</span>, len(files), <span class="string">"non-directory files"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'CVS'</span> <span class="keyword">in</span> dirs:</span><br><span class="line">        dirs.remove(<span class="string">'CVS'</span>)  <span class="comment"># don't visit CVS directories</span></span><br></pre></td></tr></table></figure><p>在下一个示例（<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree" target="_blank" rel="noopener"><code>shutil.rmtree()</code></a> 的简单实现）中，必须使树自下而上遍历，因为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rmdir" target="_blank" rel="noopener"><code>rmdir()</code></a> 只允许在目录为空时删除目录:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Delete everything reachable from the directory named in "top",</span></span><br><span class="line"><span class="comment"># assuming there are no symbolic links.</span></span><br><span class="line"><span class="comment"># CAUTION:  This is dangerous!  For example, if top == '/', it</span></span><br><span class="line"><span class="comment"># could delete all your disk files.</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(top, topdown=<span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">        os.remove(os.path.join(root, name))</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> dirs:</span><br><span class="line">        os.rmdir(os.path.join(root, name))</span><br></pre></td></tr></table></figure></li></ul><p><em>在 3.5 版更改:</em> 现在，本函数调用的是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.scandir" target="_blank" rel="noopener"><code>os.scandir()</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>os.listdir()</code></a>，从而减少了调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 的次数而变得更快。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><ul><li><p><code>os.fwalk</code>(<em>top=’.’</em>, <em>topdown=True</em>, <em>onerror=None</em>, <em>**, </em>follow_symlinks=False<em>, </em>dir_fd=None*)</p><p>本方法的行为与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 完全一样，除了它产生的是 4 元组 <code>(dirpath, dirnames, filenames, dirfd)</code>，并且它支持 <code>dir_fd</code>。</p><p><em>dirpath</em>、<em>dirnames</em> 和 <em>filenames</em> 与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.walk" target="_blank" rel="noopener"><code>walk()</code></a> 输出的相同，<em>dirfd</em> 是指向目录 <em>dirpath</em> 的文件描述符。</p><p>本函数始终支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#dir-fd" target="_blank" rel="noopener">基于目录描述符的相对路径</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。但是请注意，与其他函数不同，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fwalk" target="_blank" rel="noopener"><code>fwalk()</code></a> 的 <em>follow_symlinks</em> 的默认值为 <code>False</code>。</p><blockquote><p> 由于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fwalk" target="_blank" rel="noopener"><code>fwalk()</code></a> 会生成文件描述符，而它们仅在下一个迭代步骤前有效，因此如果要将描述符保留更久，则应复制它们（比如使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.dup" target="_blank" rel="noopener"><code>dup()</code></a>）。 </p></blockquote><p>下面的示例遍历起始目录内所有子目录，打印每个目录内的文件占用的字节数，CVS 子目录不会被遍历:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> root, dirs, files, rootfd <span class="keyword">in</span> os.fwalk(<span class="string">'python/Lib/email'</span>):</span><br><span class="line">    print(root, <span class="string">"consumes"</span>, end=<span class="string">""</span>)</span><br><span class="line">    print(sum([os.stat(name, dir_fd=rootfd).st_size <span class="keyword">for</span> name <span class="keyword">in</span> files]),</span><br><span class="line">          end=<span class="string">""</span>)</span><br><span class="line">    print(<span class="string">"bytes in"</span>, len(files), <span class="string">"non-directory files"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'CVS'</span> <span class="keyword">in</span> dirs:</span><br><span class="line">        dirs.remove(<span class="string">'CVS'</span>)  <span class="comment"># don't visit CVS directories</span></span><br></pre></td></tr></table></figure></li></ul><p>在下一个示例中，必须使树自下而上遍历，因为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rmdir" target="_blank" rel="noopener"><code>rmdir()</code></a> 只允许在目录为空时删除目录:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Delete everything reachable from the directory named in "top",</span></span><br><span class="line"><span class="comment"># assuming there are no symbolic links.</span></span><br><span class="line"><span class="comment"># CAUTION:  This is dangerous!  For example, if top == '/', it</span></span><br><span class="line"><span class="comment"># could delete all your disk files.</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> root, dirs, files, rootfd <span class="keyword">in</span> os.fwalk(top, topdown=<span class="literal">False</span>):</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">        os.unlink(name, dir_fd=rootfd)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> dirs:</span><br><span class="line">        os.rmdir(name, dir_fd=rootfd)</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p><p>3<em>.3 新版功能.</em></p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>在 3.7 版更改:</em> 添加了对 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型路径的支持。</p><ul><li><p><code>os.memfd_create</code>(<em>name</em>[, <em>flags=os.MFD_CLOEXEC</em>])</p><p>创建一个匿名文件，返回指向该文件的文件描述符。<em>flags</em> 必须是系统上可用的 <code>os.MFD_*</code> 常量之一（或将它们按位“或”组合起来）。新文件描述符默认是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#fd-inheritance" target="_blank" rel="noopener">不可继承的</a>。</p><p><em>name</em> 提供的名称会被用作文件名，并且 <code>/proc/self/fd/</code> 目录中相应符号链接的目标将显示为该名称。显示的名称始终以 <code>memfd:</code> 为前缀，并且仅用于调试目的。名称不会影响文件描述符的行为，因此多个文件可以有相同的名称，不会有副作用。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 3.17 或更高版本，且装有 glibc 2.27 或更高版本。</p><p><em>3.8 新版功能.</em> </p></li><li><p><code>os.MFD_CLOEXEC</code></p></li><li><p><code>os.MFD_ALLOW_SEALING</code></p></li><li><p><code>os.MFD_HUGETLB</code></p></li><li><p><code>os.MFD_HUGE_SHIFT</code></p></li><li><p><code>os.MFD_HUGE_MASK</code></p></li><li><p><code>os.MFD_HUGE_64KB</code></p></li><li><p><code>os.MFD_HUGE_512KB</code></p></li><li><p><code>os.MFD_HUGE_1MB</code></p></li><li><p><code>os.MFD_HUGE_2MB</code></p></li><li><p><code>os.MFD_HUGE_8MB</code></p></li><li><p><code>os.MFD_HUGE_16MB</code></p></li><li><p><code>os.MFD_HUGE_32MB</code></p></li><li><p><code>os.MFD_HUGE_256MB</code></p></li><li><p><code>os.MFD_HUGE_512MB</code></p></li><li><p><code>os.MFD_HUGE_1GB</code></p></li><li><p><code>os.MFD_HUGE_2GB</code></p></li><li><p><code>os.MFD_HUGE_16GB</code></p><p>以上标志位可以传递给 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.memfd_create" target="_blank" rel="noopener"><code>memfd_create()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 3.17 或更高版本，且装有 glibc 2.27 或更高版本。<code>MFD_HUGE*</code> 标志仅在 Linux 4.14 及以上可用。</p><p><em>3.8 新版功能.</em></p></li></ul><h3 id="Linux-扩展属性"><a href="#Linux-扩展属性" class="headerlink" title="Linux 扩展属性"></a>Linux 扩展属性</h3><p><em>3.3 新版功能.</em></p><p>这些函数仅在 Linux 上可用。</p><ul><li><p><code>os.getxattr</code>(<em>path</em>, <em>attribute</em>, <em>**, </em>follow_symlinks=True*)</p><p>返回 <em>path</em> 的扩展文件系统属性 <em>attribute</em> 的值。<em>attribute</em> 可以是 bytes 或 str （直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入）。如果是 str，则使用文件系统编码来编码字符串。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.getxattr</code>，附带参数 <code>path</code>、<code>attribute</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>path</em> 和 <em>attribute</em>。</p></li><li><p><code>os.listxattr</code>(<em>path=None</em>, <em>**, </em>follow_symlinks=True*)</p><p>返回一个列表，包含 <em>path</em> 的所有扩展文件系统属性。列表中的属性都表示为字符串，它们是根据文件系统编码解码出来的。如果 <em>path</em> 为 <code>None</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listxattr" target="_blank" rel="noopener"><code>listxattr()</code></a> 将检查当前目录。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.listxattr</code>，附带参数 <code>path</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.removexattr</code>(<em>path</em>, <em>attribute</em>, <em>**, </em>follow_symlinks=True*)</p><p>从 <em>path</em> 中删除扩展文件系统属性 <em>attribute</em>。<em>attribute</em> 应该是 bytes 或 str （直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入）。如果是 str，则使用文件系统编码来编码字符串。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.removexattr</code>，附带参数 <code>path</code>、<code>attribute</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>path</em> 和 <em>attribute</em>。</p></li><li><p><code>os.setxattr</code>(<em>path</em>, <em>attribute</em>, <em>value</em>, <em>flags=0</em>, <em>**, </em>follow_symlinks=True*)</p><p>将 <em>path</em> 的扩展文件系统属性 <em>attribute</em> 设置为 <em>value</em>。<em>attribute</em> 必须是没有空字符的 bytes 或 str （直接传入或通过 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.PathLike" target="_blank" rel="noopener"><code>PathLike</code></a> 接口间接传入）。如果是 str，则应使用文件系统编码进行编码。<em>flags</em> 可以是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.XATTR_REPLACE" target="_blank" rel="noopener"><code>XATTR_REPLACE</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.XATTR_CREATE" target="_blank" rel="noopener"><code>XATTR_CREATE</code></a>。如果指定 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.XATTR_REPLACE" target="_blank" rel="noopener"><code>XATTR_REPLACE</code></a> 而该属性不存在，则抛出 <code>EEXISTS</code> 异常。如果指定 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.XATTR_CREATE" target="_blank" rel="noopener"><code>XATTR_CREATE</code></a> 而该属性已经存在，则不会创建该属性，抛出 <code>ENODATA</code> 异常。本函数支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#path-fd" target="_blank" rel="noopener">指定文件描述符为参数</a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#follow-symlinks" target="_blank" rel="noopener">不跟踪符号链接</a>。</p><blockquote><p> Linux kernel 2.6.39 以下版本的一个 bug 导致在某些文件系统上，flags 参数会被忽略。 </p></blockquote><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.setxattr</code>，附带参数 <code>path</code>、<code>attribute</code>、<code>value</code>、<code>flags</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 作为 <em>path</em> 和 <em>attribute</em>。</p></li><li><p><code>os.XATTR_SIZE_MAX</code></p><p>一条扩展属性的值的最大大小。在当前的 Linux 上是 64 KiB。</p></li><li><p><code>os.XATTR_CREATE</code></p><p>这是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.setxattr" target="_blank" rel="noopener"><code>setxattr()</code></a> 的 flags 参数的可取值，它表示该操作必须创建一个属性。</p></li><li><p><code>os.XATTR_REPLACE</code></p><p>这是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.setxattr" target="_blank" rel="noopener"><code>setxattr()</code></a> 的 flags 参数的可取值，它表示该操作必须替换现有属性。</p></li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>下列函数可用于创建和管理进程。</p><p>所有 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*</code></a> 函数都接受一个参数列表，用来给新程序加载到它的进程中。在所有情况下，传递给新程序的第一个参数是程序本身的名称，而不是用户在命令行上输入的参数。对于 C 程序员来说，这就是传递给 <code>main()</code> 函数的 <code>argv[0]</code>。例如，<code>os.execv(&#39;/bin/echo&#39;, [&#39;foo&#39;, &#39;bar&#39;])</code> 只会在标准输出上打印 <code>bar</code>，而 <code>foo</code> 会被忽略。</p><ul><li><p><code>os.abort</code>()</p><p>发送 <code>SIGABRT</code> 信号到当前进程。在 Unix 上，默认行为是生成一个核心转储。在 Windows 上，该进程立即返回退出代码 <code>3</code>。请注意，使用 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.signal" target="_blank" rel="noopener"><code>signal.signal()</code></a> 可以为 <code>SIGABRT</code> 注册 Python 信号处理程序，而调用本函数将不会调用按前述方法注册的程序。</p></li><li><p><code>os.add_dll_directory</code>(<em>path</em>)</p><p>将路径添加到 DLL 搜索路径。当需要解析扩展模块的依赖时（扩展模块本身通过 sys.path 解析），会使用该搜索路径，<a href="https://docs.python.org/zh-cn/3.8/library/ctypes.html#module-ctypes" target="_blank" rel="noopener"><code>ctypes</code></a> 也会使用该搜索路径。要移除目录，可以在返回的对象上调用 <strong>close()</strong>，也可以在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句内使用本方法。参阅 <a href="https://msdn.microsoft.com/44228cf2-6306-466c-8f16-f513cd3ba8b5" target="_blank" rel="noopener">Microsoft 文档</a> 获取如何加载 DLL 的信息。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.add_dll_directory</code>，附带参数 <code>path</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。<em>3.8 新版功能:</em> 早期版本的 CPython 解析 DLL 时用的是当前进程的默认行为。这会导致不一致，比如不是每次都会去搜索 <code>PATH</code> 和当前工作目录，且系统函数（如 <code>AddDllDirectory</code> ）失效。在 3.8 中，DLL 的两种主要加载方式现在可以显式覆盖进程的行为，以确保一致性。请参阅 <a href="https://docs.python.org/zh-cn/3.8/whatsnew/3.8.html#bpo-36085-whatsnew" target="_blank" rel="noopener">移植说明</a> 了解如何更新你的库。</p></li><li><p><code>os.execl</code>(<em>path</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>)</p></li><li><p><code>os.execle</code>(<em>path</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>, <em>env</em>)</p></li><li><p><code>os.execlp</code>(<em>file</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>)</p></li><li><p><code>os.execlpe</code>(<em>file</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>, <em>env</em>)</p></li><li><p><code>os.execv</code>(<em>path</em>, <em>args</em>)</p></li><li><p><code>os.execve</code>(<em>path</em>, <em>args</em>, <em>env</em>)</p></li><li><p><code>os.execvp</code>(<em>file</em>, <em>args</em>)</p></li><li><p><code>os.execvpe</code>(<em>file</em>, <em>args</em>, <em>env</em>)</p><p>这些函数都将执行一个新程序，以替换当前进程。它们没有返回值。在 Unix 上，新程序会加载到当前进程中，且进程号与调用者相同。过程中的错误会被报告为 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p><p>当前进程会被立即替换。打开的文件对象和描述符都不会刷新，因此如果这些文件上可能缓冲了数据，则应在调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*</code></a> 函数之前使用 <code>sys.stdout.flush()</code> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fsync" target="_blank" rel="noopener"><code>os.fsync()</code></a> 刷新它们。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*</code></a> 函数的 “l” 和 “v” 变体不同在于命令行参数的传递方式。如果在编码时固定了参数数量，则 “l” 变体可能是最方便的，各参数作为 <code>execl*()</code> 函数的附加参数传入即可。当参数数量可变时，”v” 变体更方便，参数以列表或元组的形式作为 <em>args</em> 参数传递。在这两种情况下，子进程的第一个参数都应该是即将运行的命令名称，但这不是强制性的。</p><p>结尾包含 “p” 的变体（<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execlp" target="_blank" rel="noopener"><code>execlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execlpe" target="_blank" rel="noopener"><code>execlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execvp" target="_blank" rel="noopener"><code>execvp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execvpe" target="_blank" rel="noopener"><code>execvpe()</code></a> ）将使用 <code>PATH</code> 环境变量来查找程序 <em>file</em>。当环境被替换时（使用下一段讨论的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*e</code></a> 变体之一），<code>PATH</code> 变量将来自于新环境。其他变体 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>execl()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execle" target="_blank" rel="noopener"><code>execle()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execv" target="_blank" rel="noopener"><code>execv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 不使用 <code>PATH</code> 变量来查找程序，因此 <em>path</em> 必须包含正确的绝对或相对路径。</p><p>对于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execle" target="_blank" rel="noopener"><code>execle()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execlpe" target="_blank" rel="noopener"><code>execlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execvpe" target="_blank" rel="noopener"><code>execvpe()</code></a> （都以 “e” 结尾），<em>env</em> 参数是一个映射，用于定义新进程的环境变量（代替当前进程的环境变量）。而函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>execl()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execlp" target="_blank" rel="noopener"><code>execlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execv" target="_blank" rel="noopener"><code>execv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execvp" target="_blank" rel="noopener"><code>execvp()</code></a> 会将当前进程的环境变量过继给新进程。</p><p>某些平台上的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 可以将 <em>path</em> 指定为打开的文件描述符。当前平台可能不支持此功能，可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_fd" target="_blank" rel="noopener"><code>os.supports_fd</code></a> 检查它是否支持。如果不可用，则使用它会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.exec</code>，附带参数 <code>path</code>、<code>args</code>、<code>env</code>。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p><p><em>3.3 新版功能:</em> 新增支持将 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 的 <em>path</em> 参数指定为打开的文件描述符。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os._exit</code>(<em>n</em>)</p><p>以状态码 <em>n</em> 退出进程，不会调用清理处理程序，不会刷新 stdio，等等。</p><blockquote><p> 退出的标准方法是使用 <code>sys.exit(n)</code>。而 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os._exit" target="_blank" rel="noopener"><code>_exit()</code></a> 通常只应在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>fork()</code></a> 出的子进程中使用。 </p></blockquote><p> 以下是已定义的退出代码，可以用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os._exit" target="_blank" rel="noopener"><code>_exit()</code></a>，尽管它们不是必需的。这些退出代码通常用于 Python 编写的系统程序，例如邮件服务器的外部命令传递程序。 </p><blockquote><p> 其中部分退出代码在部分 Unix 平台上可能不可用，因为平台间存在差异。如果底层平台定义了这些常量，那上层也会定义。 </p></blockquote></li><li><p><code>os.EX_OK</code></p><p>退出代码，表示未发生任何错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_USAGE</code></p><p>退出代码，表示命令使用不正确，如给出的参数数量有误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_DATAERR</code></p><p>退出代码，表示输入数据不正确。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_NOINPUT</code></p><p>退出代码，表示某个输入文件不存在或不可读。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_NOUSER</code></p><p>退出代码，表示指定的用户不存在。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_NOHOST</code></p><p>退出代码，表示指定的主机不存在。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_UNAVAILABLE</code></p><p>退出代码，表示所需的服务不可用。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_SOFTWARE</code></p><p>退出代码，表示检测到内部软件错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_OSERR</code></p><p>退出代码，表示检测到操作系统错误，例如无法 fork 或创建管道。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_OSFILE</code></p><p>退出代码，表示某些系统文件不存在、无法打开或发生其他错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_CANTCREAT</code></p><p>退出代码，表示无法创建用户指定的输出文件。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_IOERR</code></p><p>退出代码，表示对某些文件进行读写时发生错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_TEMPFAIL</code></p><p>退出代码，表示发生了暂时性故障。它可能并非意味着真正的错误，例如在可重试的情况下无法建立网络连接。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_PROTOCOL</code></p><p>退出代码，表示协议交换是非法的、无效的或无法解读的。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_NOPERM</code></p><p>退出代码，表示没有足够的权限执行该操作（但不适用于文件系统问题）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_CONFIG</code></p><p>退出代码，表示发生某种配置错误。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.EX_NOTFOUND</code></p><p>退出代码，表示的内容类似于“找不到条目”。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.fork</code>()</p><p>Fork 出一个子进程。在子进程中返回 <code>0</code>，在父进程中返回子进程的进程号。如果发生错误，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。注意，当从线程中使用 <code>fork()</code> 时，某些平台（包括 FreeBSD &lt;= 6.3 和 Cygwin）存在已知问题。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.fork</code>，没有附带参数。<em>在 3.8 版更改:</em> 不再支持在子解释器中调用 <code>fork()</code> （将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常）</p><p> 有关 SSL 模块与 fork() 结合的应用，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/ssl.html#module-ssl" target="_blank" rel="noopener"><code>ssl</code></a>。 </p><p> <a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix </p></li><li><p><code>os.forkpty</code>()</p><p>Fork 出一个子进程，使用新的伪终端作为子进程的控制终端。返回一对 <code>(pid, fd)</code>，其中 <em>pid</em> 在子进程中为 <code>0</code>，这是父进程中新子进程的进程号，而 <em>fd</em> 是伪终端主设备的文件描述符。对于更便于移植的方法，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/pty.html#module-pty" target="_blank" rel="noopener"><code>pty</code></a> 模块。如果发生错误，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.forkpty</code>，没有附带参数。<em>在 3.8 版更改:</em> 不再支持在子解释器中调用 <code>forkpty()</code> （将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a> 异常）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 某些 Unix。</p></li><li><p><code>os.kill</code>(<em>pid</em>, <em>sig</em>)</p><p>将信号 <em>sig</em> 发送至进程 <em>pid</em>。特定平台上可用的信号常量定义在 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#module-signal" target="_blank" rel="noopener"><code>signal</code></a> 模块中。Windows： <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.CTRL_C_EVENT" target="_blank" rel="noopener"><code>signal.CTRL_C_EVENT</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.CTRL_BREAK_EVENT" target="_blank" rel="noopener"><code>signal.CTRL_BREAK_EVENT</code></a> 信号是特殊信号，只能发送给共享同一个控制台窗口的控制台进程，如某些子进程。<em>sig</em> 取任何其他值将导致该进程被 TerminateProcess API 无条件终止，且退出代码为 <em>sig</em>。Windows 版本的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.kill" target="_blank" rel="noopener"><code>kill()</code></a> 还需要传入待结束进程的句柄。另请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/signal.html#signal.pthread_kill" target="_blank" rel="noopener"><code>signal.pthread_kill()</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.kill</code>，附带参数 <code>pid</code>、<code>sig</code>。<em>3.2 新版功能:</em> Windows 支持。</p></li><li><p><code>os.killpg</code>(<em>pgid</em>, <em>sig</em>)</p><p>将信号 <em>sig</em> 发送给进程组 <em>pgid</em>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.killpg</code>，附带参数 <code>pgid</code>、<code>sig</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.nice</code>(<em>increment</em>)</p><p>将进程的优先级（nice 值）增加 <em>increment</em>，返回新的 nice 值。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.plock</code>(<em>op</em>)</p><p>将程序段锁定到内存中。<em>op</em> 的值（定义在  中）决定了哪些段被锁定。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.popen</code>(<em>cmd</em>, <em>mode=’r’</em>, <em>buffering=-1</em>)</p><p>打开一个管道，它通往 / 接受自命令 <em>cmd</em>。返回值是连接到管道的文件对象，根据 <em>mode</em> 是 <code>&#39;r&#39;</code> （默认）还是 <code>&#39;w&#39;</code> 决定该对象可以读取还是写入。<em>buffering</em> 参数与内置函数 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 相应的参数含义相同。返回的文件对象只能读写文本字符串，不能是字节类型。</p><p>如果子进程成功退出，则 <code>close</code> 方法返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。如果发生错误，则返回子进程的返回码。在 POSIX 系统上，如果返回码为正，则它就是进程返回值左移一个字节后的值。如果返回码为负，则进程是被信号终止的，返回码取反后就是该信号。（例如，如果子进程被终止，则返回值可能是 <code>- signal.SIGKILL</code>。）在 Windows 系统上，返回值包含子进程的返回码（有符号整数）。</p><p>本方法是使用 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#subprocess.Popen" target="_blank" rel="noopener"><code>subprocess.Popen</code></a> 实现的，如需更强大的方法来管理和沟通子进程，请参阅该类的文档。</p></li><li><p><code>os.posix_spawn</code>(<em>path</em>, <em>argv</em>, <em>env</em>, <em>**, </em>file_actions=None<em>, </em>setpgroup=None<em>, </em>resetids=False<em>, </em>setsid=False<em>, </em>setsigmask=()<em>, </em>setsigdef=()<em>, </em>scheduler=None*)</p><p>包装 <code>posix_spawn()</code> C 库 API，使其可以从 Python 调用。</p><p>大多数用户应使用 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#subprocess.run" target="_blank" rel="noopener"><code>subprocess.run()</code></a> 代替 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_spawn" target="_blank" rel="noopener"><code>posix_spawn()</code></a>。</p><p>仅位置参数 (Positional-only arguments) <em>path</em>、<em>args</em> 和 <em>env</em> 与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execve" target="_blank" rel="noopener"><code>execve()</code></a> 中的类似。</p><p><em>path</em> 参数是可执行文件的路径，<em>path</em> 中应该包含目录。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_spawnp" target="_blank" rel="noopener"><code>posix_spawnp()</code></a> 可直接传入可执行文件名称，不带有目录。</p><p><em>file_actions</em> 参数可以是由元组组成的序列，序列描述了对子进程中指定文件描述符采取的操作，这些操作会在 C 库实现的 <code>fork()</code> 和 <code>exec()</code> 步骤间完成。每个元组的第一个元素必须是下面列出的三个类型指示符之一，用于描述元组剩余的元素：</p><ul><li><p><code>os.POSIX_SPAWN_OPEN</code></p><p>(<code>os.POSIX_SPAWN_OPEN</code>, <em>fd</em>, <em>path</em>, <em>flags</em>, <em>mode</em>)执行 <code>os.dup2(os.open(path, flags, mode), fd)</code>。</p></li><li><p><code>os.POSIX_SPAWN_CLOSE</code></p><p>(<code>os.POSIX_SPAWN_CLOSE</code>, <em>fd</em>)执行 <code>os.close(fd)</code>。</p></li><li><p><code>os.POSIX_SPAWN_DUP2</code></p><p>(<code>os.POSIX_SPAWN_DUP2</code>, <em>fd</em>, <em>new_fd</em>)执行 <code>os.dup2(fd, new_fd)</code>。</p></li></ul><p>这些元组对应于 C 库 <code>posix_spawn_file_actions_addopen()</code>， <code>posix_spawn_file_actions_addclose()</code> 和 <code>posix_spawn_file_actions_adddup2()</code> API 调用，它们为调用 <code>posix_spawn()</code> 自身做准备。</p><p><em>setpgroup</em> 参数将子进程的进程组设置为指定值。如果指定值为 0，则子进程的进程组 ID 将与其进程 ID 相同。如果未设置 <em>setpgroup</em> 值，则子进程将继承父进程的进程组 ID。本参数对应于 C 库 <code>POSIX_SPAWN_SETPGROUP</code> 标志。</p><p>如果 <em>resetids</em> 参数为 <code>True</code>，则会将子进程的有效用户 ID 和有效组 ID 重置为父进程的实际用户 ID 和实际组 ID。如果该参数为 <code>False</code>，则子进程保留父进程的有效用户 ID 和有效组 ID。无论哪种情况，若在可执行文件上启用了 “设置用户 ID” 和 “设置组 ID” 权限位，它们将覆盖有效用户 ID 和有效组 ID 的设置。本参数对应于 C 库 <code>POSIX_SPAWN_RESETIDS</code> 标志。</p><p>如果 <em>setsid</em> 参数为 <code>True</code>，它将为 posix_spawn 新建一个会话 ID。<em>setsid</em> 需要 <code>POSIX_SPAWN_SETSID</code> 或 <code>POSIX_SPAWN_SETSID_NP</code> 标志，否则会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。</p><p><em>setsigmask</em> 参数将信号掩码设置为指定的信号集合。如果未使用该参数，则子进程将继承父进程的信号掩码。本参数对应于 C 库 <code>POSIX_SPAWN_SETSIGMASK</code> 标志。</p><p><em>sigdef</em> 参数将集合中所有信号的操作全部重置为默认。本参数对应于 C 库 <code>POSIX_SPAWN_SETSIGDEF</code> 标志。</p><p><em>scheduler</em> 参数必须是一个元组，其中包含调度器策略（可选）以及携带了调度器参数的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_param" target="_blank" rel="noopener"><code>sched_param</code></a> 实例。在调度器策略所在位置为 <code>None</code> 表示未提供该值。本参数是 C 库 <code>POSIX_SPAWN_SETSCHEDPARAM</code> 和 <code>POSIX_SPAWN_SETSCHEDULER</code> 标志的组合。</p><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.posix_spawn</code>，附带参数 <code>path</code>、<code>argv</code>、<code>env</code>。</p><p><em>3.8 新版功能.</em></p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.posix_spawnp</code>(<em>path</em>, <em>argv</em>, <em>env</em>, <em>**, </em>file_actions=None<em>, </em>setpgroup=None<em>, </em>resetids=False<em>, </em>setsid=False<em>, </em>setsigmask=()<em>, </em>setsigdef=()<em>, </em>scheduler=None*)</p><p>包装 <code>posix_spawnp()</code> C 库 API，使其可以从 Python 调用。</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_spawn" target="_blank" rel="noopener"><code>posix_spawn()</code></a> 相似，但是系统会在 <code>PATH</code> 环境变量指定的目录列表中搜索可执行文件 <em>executable</em> （与 <code>execvp(3)</code> 相同）。</p><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.posix_spawn</code>，附带参数 <code>path</code>、<code>argv</code>、<code>env</code>。</p><p><em>3.8 新版功能.</em></p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.posix_spawn" target="_blank" rel="noopener"><code>posix_spawn()</code></a> 文档。</p></li><li><p><code>os.register_at_fork</code>(<em>**, </em>before=None<em>, </em>after_in_parent=None<em>, </em>after_in_child=None*)</p><p>注册可调用对象，在使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fork" target="_blank" rel="noopener"><code>os.fork()</code></a> 或类似的进程克隆 API 派生新的子进程时，这些对象会运行。参数是可选的，且为仅关键字 (Keyword-only) 参数。每个参数指定一个不同的调用点。</p><ul><li><em>before</em> 是一个函数，在 fork 子进程前调用。</li><li><em>after_in_parent</em> 是一个函数，在 fork 子进程后从父进程调用。</li><li><em>after_in_child</em> 是一个函数，从子进程中调用。</li></ul><p>只有希望控制权回到 Python 解释器时，才进行这些调用。典型的 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>子进程</code></a> 启动时不会触发它们，因为子进程不会重新进入解释器。</p><p>在注册的函数中，用于 fork 前运行的函数将按与注册相反的顺序调用。用于 fork 后（从父进程或子进程）运行的函数按注册顺序调用。</p><p>注意，第三方 C 代码的 <code>fork()</code> 调用可能不会调用这些函数，除非它显式调用了 <a href="https://docs.python.org/zh-cn/3.8/c-api/sys.html#c.PyOS_BeforeFork" target="_blank" rel="noopener"><code>PyOS_BeforeFork()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/c-api/sys.html#c.PyOS_AfterFork_Parent" target="_blank" rel="noopener"><code>PyOS_AfterFork_Parent()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/c-api/sys.html#c.PyOS_AfterFork_Child" target="_blank" rel="noopener"><code>PyOS_AfterFork_Child()</code></a>。</p><p>函数注册后无法注销。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p><p><em>3.7 新版功能.</em></p></li><li><p><code>os.spawnl</code>(<em>mode</em>, <em>path</em>, <em>…</em>)</p></li><li><p><code>os.spawnle</code>(<em>mode</em>, <em>path</em>, <em>…</em>, <em>env</em>)</p></li><li><p><code>os.spawnlp</code>(<em>mode</em>, <em>file</em>, <em>…</em>)</p></li><li><p><code>os.spawnlpe</code>(<em>mode</em>, <em>file</em>, <em>…</em>, <em>env</em>)</p></li><li><p><code>os.spawnv</code>(<em>mode</em>, <em>path</em>, <em>args</em>)</p></li><li><p><code>os.spawnve</code>(<em>mode</em>, <em>path</em>, <em>args</em>, <em>env</em>)</p></li><li><p><code>os.spawnvp</code>(<em>mode</em>, <em>file</em>, <em>args</em>)</p></li><li><p><code>os.spawnvpe</code>(<em>mode</em>, <em>file</em>, <em>args</em>, <em>env</em>)<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener">¶</a></p><p>在新进程中执行程序 <em>path</em>。</p><p>（注意，<a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 模块提供了更强大的工具来生成新进程并跟踪执行结果，使用该模块比使用这些函数更好。尤其应当检查 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#subprocess-replacements" target="_blank" rel="noopener">Replacing Older Functions with the subprocess Module</a> 部分。）</p><p><em>mode</em> 为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_NOWAIT" target="_blank" rel="noopener"><code>P_NOWAIT</code></a> 时，本函数返回新进程的进程号。<em>mode</em> 为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_WAIT" target="_blank" rel="noopener"><code>P_WAIT</code></a> 时，如果进程正常退出，返回退出代码，如果被终止，返回 <code>-signal</code>，其中 <em>signal</em> 是终止进程的信号。在 Windows 上，进程号实际上是进程句柄，因此可以与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 函数一起使用。</p><p>注意在 VxWorks 上，新进程被终止时，本函数不会返回 <code>-signal</code>，而是会抛出 OSError 异常。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 函数的 “l” 和 “v” 变体不同在于命令行参数的传递方式。如果在编码时固定了参数数量，则 “l” 变体可能是最方便的，各参数作为 <code>spawnl*()</code> 函数的附加参数传入即可。当参数数量可变时，”v” 变体更方便，参数以列表或元组的形式作为 <em>args</em> 参数传递。在这两种情况下，子进程的第一个参数都必须是即将运行的命令名称。</p><p>结尾包含第二个 “p” 的变体（<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlp" target="_blank" rel="noopener"><code>spawnlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlpe" target="_blank" rel="noopener"><code>spawnlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvp" target="_blank" rel="noopener"><code>spawnvp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener"><code>spawnvpe()</code></a>）将使用 <code>PATH</code> 环境变量来查找程序 <em>file</em>。当环境被替换时（使用下一段讨论的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*e</code></a> 变体之一），<code>PATH</code> 变量将来自于新环境。其他变体 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawnl()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnle" target="_blank" rel="noopener"><code>spawnle()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnv" target="_blank" rel="noopener"><code>spawnv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnve" target="_blank" rel="noopener"><code>spawnve()</code></a> 不使用 <code>PATH</code> 变量来查找程序，因此 <em>path</em> 必须包含正确的绝对或相对路径。</p><p>对于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnle" target="_blank" rel="noopener"><code>spawnle()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlpe" target="_blank" rel="noopener"><code>spawnlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnve" target="_blank" rel="noopener"><code>spawnve()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener"><code>spawnvpe()</code></a> （都以 “e” 结尾），<em>env</em> 参数是一个映射，用于定义新进程的环境变量（代替当前进程的环境变量）。而函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawnl()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlp" target="_blank" rel="noopener"><code>spawnlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnv" target="_blank" rel="noopener"><code>spawnv()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvp" target="_blank" rel="noopener"><code>spawnvp()</code></a> 会将当前进程的环境变量过继给新进程。注意，<em>env</em> 字典中的键和值必须是字符串。无效的键或值将导致函数出错，返回值为 <code>127</code>。</p><p>例如，以下对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlp" target="_blank" rel="noopener"><code>spawnlp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener"><code>spawnvpe()</code></a> 的调用是等效的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">  os.spawnlp(os.P_WAIT, <span class="string">'cp'</span>, <span class="string">'cp'</span>, <span class="string">'index.html'</span>, <span class="string">'/dev/null'</span>)</span><br><span class="line"></span><br><span class="line">  L = [<span class="string">'cp'</span>, <span class="string">'index.html'</span>, <span class="string">'/dev/null'</span>]</span><br><span class="line">os.spawnvpe(os.P_WAIT, <span class="string">'cp'</span>, L, os.environ)</span><br></pre></td></tr></table></figure><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.spawn</code>，附带参数 <code>mode</code>、<code>path</code>、<code>args</code>、<code>env</code>。</p></li></ul><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlp" target="_blank" rel="noopener"><code>spawnlp()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnlpe" target="_blank" rel="noopener"><code>spawnlpe()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvp" target="_blank" rel="noopener"><code>spawnvp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnvpe" target="_blank" rel="noopener"><code>spawnvpe()</code></a> 在 Windows 上不可用。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnle" target="_blank" rel="noopener"><code>spawnle()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnve" target="_blank" rel="noopener"><code>spawnve()</code></a> 在 Windows 上不是线程安全的，建议使用 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 模块替代。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><ul><li><p><code>os.P_NOWAIT</code></p></li><li><p><code>os.P_NOWAITO</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 系列函数的 <em>mode</em> 参数的可取值。如果给出这些值中的任何一个，则 <code>spawn*()</code> 函数将在创建新进程后立即返回，且返回值为进程号。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><code>os.P_WAIT</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 系列函数的 <em>mode</em> 参数的可取值。如果将 <em>mode</em> 指定为该值，则 <code>spawn*()</code> 函数将在新进程运行完毕后返回，运行成功则返回进程的退出代码，被信号终止则返回 <code>-signal</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><code>os.P_DETACH</code></p></li><li><p><code>os.P_OVERLAY</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 系列函数的 <em>mode</em> 参数的可取值。它们比上面列出的值可移植性差。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_DETACH" target="_blank" rel="noopener"><code>P_DETACH</code></a> 与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_NOWAIT" target="_blank" rel="noopener"><code>P_NOWAIT</code></a> 相似，但是新进程会与父进程的控制台脱离。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_OVERLAY" target="_blank" rel="noopener"><code>P_OVERLAY</code></a> 则会替换当前进程，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 函数将不会返回。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。</p></li><li><p><code>os.startfile</code>(<em>path</em>[, <em>operation</em>])</p><p>使用已关联的应用程序打开文件。当 <em>operation</em> 未指定或指定为 <code>&#39;open&#39;</code> 时，这类似于在 Windows 资源管理器中双击文件，或在交互式命令行中将文件名作为 <strong>start</strong> 命令的参数：通过扩展名相关联的应用程序（如果有）打开文件。当指定另一个 <em>operation</em> 时，它必须是一个“命令动词” (“command verb”)，该词指定对文件执行的操作。Microsoft 文档中的常用动词有 <code>&#39;print&#39;</code> 和 <code>&#39;edit&#39;</code> （用于文件），以及 <code>&#39;explore&#39;</code> 和 <code>&#39;find&#39;</code> （用于目录）。关联的应用程序启动后 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.startfile" target="_blank" rel="noopener"><code>startfile()</code></a> 就会立即返回。本函数没有等待应用程序关闭的选项，也没有办法检索应用程序的退出状态。<em>path</em> 参数是基于当前目录的相对路径。如果要使用绝对路径，请确保第一个字符不是斜杠 (<code>&#39;/&#39;</code>)，是斜杠的话底层的 Win32 <code>ShellExecute()</code> 函数将失效。使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.normpath" target="_blank" rel="noopener"><code>os.path.normpath()</code></a> 函数确保路径已针对 Win32 正确编码。为了减少解释器的启动开销，直到第一次调用本函数后，才解析 Win32 <code>ShellExecute()</code> 函数。如果无法解析该函数，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.startfile</code>，附带参数 <code>path</code>、<code>operation</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Windows。</p></li><li><p><code>os.system</code>(<em>command</em>)</p><p>在子 shell 中执行命令（字符串）。这是调用标准 C 函数 <code>system()</code> 来实现的，因此限制条件与该函数相同。对 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stdin" target="_blank" rel="noopener"><code>sys.stdin</code></a> 等的更改不会反映在执行命令的环境中。<em>command</em> 产生的任何输出将被发送到解释器标准输出流。在 Unix 上，返回值是进程的退出状态，编码格式与为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait" target="_blank" rel="noopener"><code>wait()</code></a> 指定的格式相同。注意，POSIX 没有指定 C 函数 <code>system()</code> 返回值的含义，因此 Python 函数的返回值与系统有关。在 Windows 上，返回值是运行 <em>command</em> 后系统 Shell 返回的值。该 Shell 由 Windows 环境变量 <code>COMSPEC</code>: 给出：通常是 <strong>cmd.exe</strong>，它会返回命令的退出状态。在使用非原生 Shell 的系统上，请查阅 Shell 的文档。<a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 模块提供了更强大的工具来生成新进程并跟踪执行结果，使用该模块比使用本函数更好。参阅 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#module-subprocess" target="_blank" rel="noopener"><code>subprocess</code></a> 文档中的 <a href="https://docs.python.org/zh-cn/3.8/library/subprocess.html#subprocess-replacements" target="_blank" rel="noopener">Replacing Older Functions with the subprocess Module</a> 部分以获取有用的帮助。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>os.system</code>，附带参数 <code>command</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><code>os.times</code>()</p><p>返回当前的全局进程时间。返回值是一个有 5 个属性的对象：<code>user</code> - 用户时间<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>system</code></a> - 系统时间<code>children_user</code> - 所有子进程的用户时间<code>children_system</code> - 所有子进程的系统时间<code>elapsed</code> - 从过去的固定时间点起，经过的真实时间为了向后兼容，该对象的行为也类似于五元组，按照 <code>user</code>，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>system</code></a>，<code>children_user</code>，<code>children_system</code> 和 <code>elapsed</code> 顺序组成。在 Unix 上请参阅 <em><a href="https://manpages.debian.org/times(2" target="_blank" rel="noopener">times(2)</a>)</em> 和 <em><a href="https://manpages.debian.org/times(3" target="_blank" rel="noopener">times(3)</a>)</em> 手册页，在 Windows 上请参阅 <a href="https://docs.microsoft.com/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocesstimes" target="_blank" rel="noopener">the GetProcessTimes MSDN</a> 。在 Windows 上，只有 <code>user</code> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>system</code></a> 是已知的，其他属性均为零。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.3 版更改:</em> 返回结果的类型由元组变成一个类似元组的对象，同时具有命名的属性。</p></li><li><p><code>os.wait</code>()</p><p>等待子进程执行完毕，返回一个元组，包含其 pid 和退出状态指示：一个 16 位数字，其低字节是终止该进程的信号编号，高字节是退出状态码（信号编号为零的情况下），如果生成了核心文件，则低字节的高位会置位。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.waitid</code>(<em>idtype</em>, <em>id</em>, <em>options</em>)</p><p>等待一个或多个子进程执行完毕。<em>idtype</em> 可以是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_PID" target="_blank" rel="noopener"><code>P_PID</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_PGID" target="_blank" rel="noopener"><code>P_PGID</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_ALL" target="_blank" rel="noopener"><code>P_ALL</code></a>。<em>id</em> 指定要等待的 pid。<em>options</em> 是由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WEXITED" target="_blank" rel="noopener"><code>WEXITED</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WSTOPPED" target="_blank" rel="noopener"><code>WSTOPPED</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WCONTINUED" target="_blank" rel="noopener"><code>WCONTINUED</code></a> 中的一个或多个进行或运算构造的，且额外可以与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WNOHANG" target="_blank" rel="noopener"><code>WNOHANG</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WNOWAIT" target="_blank" rel="noopener"><code>WNOWAIT</code></a> 进行或运算。返回值是一个对象，对应着 <code>siginfo_t</code> 结构体中的数据，即： <code>si_pid</code>, <code>si_uid</code>, <code>si_signo</code>, <code>si_status</code>, <code>si_code</code> 或 <code>None</code> （如果指定了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.WNOHANG" target="_blank" rel="noopener"><code>WNOHANG</code></a> 且没有子进程处于等待状态）。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.P_PID</code></p></li><li><p><code>os.P_PGID</code></p></li><li><p><code>os.P_ALL</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitid" target="_blank" rel="noopener"><code>waitid()</code></a> 的 <em>idtype</em> 参数的可取值。它们影响 <em>id</em> 的解释方式。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.WEXITED</code></p></li><li><p><code>os.WSTOPPED</code></p></li><li><p><code>os.WNOWAIT</code></p><p>用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitid" target="_blank" rel="noopener"><code>waitid()</code></a> 的 <em>options</em> 参数的标志位，指定要等待的子进程信号。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.CLD_EXITED</code></p></li><li><p><code>os.CLD_DUMPED</code></p></li><li><p><code>os.CLD_TRAPPED</code></p></li><li><p><code>os.CLD_CONTINUED</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitid" target="_blank" rel="noopener"><code>waitid()</code></a> 返回的结果中，<code>si_code</code> 的可取值。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。<em>3.3 新版功能.</em></p></li><li><p><code>os.waitpid</code>(<em>pid</em>, <em>options</em>)</p><p>本函数的细节在 Unix 和 Windows 上有不同之处。</p><p>在 Unix 上：等待进程号为 <em>pid</em> 的子进程执行完毕，返回一个元组，内含其进程 ID 和退出状态指示（编码与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait" target="_blank" rel="noopener"><code>wait()</code></a> 相同）。调用的语义受整数 <em>options</em> 的影响，常规操作下该值应为 <code>0</code>。</p><p>如果 <em>pid</em> 大于 <code>0</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 会获取该指定进程的状态信息。如果 <em>pid</em> 为 <code>0</code>，则获取当前进程所在进程组中的所有子进程的状态。如果 <em>pid</em> 为 <code>-1</code>，则获取当前进程的子进程状态。如果 <em>pid</em> 小于 <code>-1</code>，则获取进程组 <code>-pid</code> （ <em>pid</em> 的绝对值）中所有进程的状态。</p><p>当系统调用返回 -1 时，将抛出带有错误码的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p><p>在 Windows 上：等待句柄为 <em>pid</em> 的进程执行完毕，返回一个元组，内含 <em>pid</em> 以及左移 8 位后的退出状态码（移位简化了跨平台使用本函数）。小于或等于 <code>0</code> 的 <em>pid</em> 在 Windows 上没有特殊含义，且会抛出异常。整数值 <em>options</em> 无效。<em>pid</em> 可以指向任何 ID 已知的进程，不一定是子进程。调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*</code></a> 函数时传入 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.P_NOWAIT" target="_blank" rel="noopener"><code>P_NOWAIT</code></a> 将返回合适的进程句柄。</p><p><em>在 3.5 版更改:</em> 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#InterruptedError" target="_blank" rel="noopener"><code>InterruptedError</code></a> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p></li><li><p><code>os.wait3</code>(<em>options</em>)</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 相似，差别在于没有进程 ID 参数，且返回一个 3 元组，其中包括子进程 ID，退出状态指示和资源使用信息。关于资源使用信息的详情，请参考 <a href="https://docs.python.org/zh-cn/3.8/library/resource.html#module-resource" target="_blank" rel="noopener"><code>resource</code></a>.<a href="https://docs.python.org/zh-cn/3.8/library/resource.html#resource.getrusage" target="_blank" rel="noopener"><code>getrusage()</code></a>。option 参数与传入 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait4" target="_blank" rel="noopener"><code>wait4()</code></a> 的相同。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.wait4</code>(<em>pid</em>, <em>options</em>)</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 相似，差别在本方法返回一个 3 元组，其中包括子进程 ID，退出状态指示和资源使用信息。关于资源使用信息的详情，请参考 <a href="https://docs.python.org/zh-cn/3.8/library/resource.html#module-resource" target="_blank" rel="noopener"><code>resource</code></a>.<a href="https://docs.python.org/zh-cn/3.8/library/resource.html#resource.getrusage" target="_blank" rel="noopener"><code>getrusage()</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait4" target="_blank" rel="noopener"><code>wait4()</code></a> 的参数与 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 的参数相同。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WNOHANG</code></p><p>用于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 的选项，如果没有立即可用的子进程状态，则立即返回。在这种情况下，函数返回 <code>(0, 0)</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WCONTINUED</code></p><p>被任务控制 (job control) 停止的子进程，如果上次报告状态后已恢复运行，则此选项将报告这些子进程。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: 部分 Unix 系统。</p></li><li><p><code>os.WUNTRACED</code></p><p>已停止的子进程，如果自停止以来尚未报告其当前状态，则此选项将报告这些子进程。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li></ul><p>下列函数采用进程状态码作为参数，状态码由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.system" target="_blank" rel="noopener"><code>system()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.wait" target="_blank" rel="noopener"><code>wait()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.waitpid" target="_blank" rel="noopener"><code>waitpid()</code></a> 返回。它们可用于确定进程上发生的操作。</p><ul><li><p><code>os.WCOREDUMP</code>(<em>status</em>)</p><p>如果为该进程生成了核心转储，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WIFCONTINUED</code>(<em>status</em>)</p><p>如果进程被任务控制 (job control) 停止后，又重新继续运行，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WIFSTOPPED</code>(<em>status</em>)</p><p>如果进程已停止，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WIFSIGNALED</code>(<em>status</em>)</p><p>如果进程由于信号而退出，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WIFEXITED</code>(<em>status</em>)</p><p>如果进程使用 <em><a href="https://manpages.debian.org/exit(2" target="_blank" rel="noopener">exit(2)</a>)</em> 系统调用退出，返回 <code>True</code>，否则返回 <code>False</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WEXITSTATUS</code>(<em>status</em>)</p><p>如果 <code>WIFEXITED(status)</code> 为值，则将整数形参返回给 <em><a href="https://manpages.debian.org/exit(2" target="_blank" rel="noopener">exit(2)</a>)</em> 系统调用。 否则，返回值将没有任何意义。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WSTOPSIG</code>(<em>status</em>)</p><p>返回导致进程停止的信号。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.WTERMSIG</code>(<em>status</em>)</p><p>返回导致进程退出的信号。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li></ul><h2 id="调度器接口"><a href="#调度器接口" class="headerlink" title="调度器接口"></a>调度器接口</h2><p>这些函数控制操作系统如何为进程分配 CPU 时间。 它们仅在某些 Unix 平台上可用。 更多细节信息请查阅你所用 Unix 的指南页面。</p><p><em>3.3 新版功能.</em></p><p>以下调度策略如果被操作系统支持就会对外公开。</p><ul><li><p><code>os.SCHED_OTHER</code></p><p>默认调度策略。</p></li><li><p><code>os.SCHED_BATCH</code></p><p>用于 CPU 密集型进程的调度策略，它会尽量为计算机中的其余任务保留交互性。</p></li><li><p><code>os.SCHED_IDLE</code></p><p>用于极低优先级的后台任务的调度策略。</p></li><li><p><code>os.SCHED_SPORADIC</code></p><p>用于偶发型服务程序的调度策略。</p></li><li><p><code>os.SCHED_FIFO</code></p><p>先进先出的调度策略。</p></li><li><p><code>os.SCHED_RR</code></p><p>循环式的调度策略。</p></li><li><p><code>os.SCHED_RESET_ON_FORK</code></p><p>此旗标可与任何其他调度策略进行 OR 运算。 当带有此旗标的进程设置分叉时，其子进程的调度策略和优先级会被重置为默认值。</p></li><li><p><em>class</em> <code>os.sched_param</code>(<em>sched_priority</em>)</p><p>这个类表示在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_setparam" target="_blank" rel="noopener"><code>sched_setparam()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_setscheduler" target="_blank" rel="noopener"><code>sched_setscheduler()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_getparam" target="_blank" rel="noopener"><code>sched_getparam()</code></a> 中使用的可修改调度形参。 它属于不可变对象。目前它只有一个可能的形参：<code>sched_priority</code>一个调度策略的调度优先级。</p></li><li><p><code>os.sched_get_priority_min</code>(<em>policy</em>)</p><p>获取 <em>policy</em> 的最小优先级数值。 <em>policy</em> 是以上调度策略常量之一。</p></li><li><p><code>os.sched_get_priority_max</code>(<em>policy</em>)</p><p>获取 <em>policy</em> 的最高优先级数值。 <em>policy</em> 是以上调度策略常量之一。</p></li><li><p><code>os.sched_setscheduler</code>(<em>pid</em>, <em>policy</em>, <em>param</em>)</p><p>设置 PID 为 <em>pid</em> 的进程的调度策略。<em>pid</em> 为 0 指的是调用本方法的进程。<em>policy</em> 是以上调度策略常量之一。<em>param</em> 是一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_param" target="_blank" rel="noopener"><code>sched_param</code></a> 实例。</p></li><li><p><code>os.sched_getscheduler</code>(<em>pid</em>)</p><p>返回 PID 为 <em>pid</em> 的进程的调度策略。<em>pid</em> 为 0 指的是调用本方法的进程。返回的结果是以上调度策略常量之一。</p></li><li><p><code>os.sched_setparam</code>(<em>pid</em>, <em>param</em>)</p><p>设置 PID 为 <em>pid</em> 的进程的某个调度参数。<em>pid</em> 为 0 指的是调用本方法的进程。<em>param</em> 是一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_param" target="_blank" rel="noopener"><code>sched_param</code></a> 实例。</p></li><li><p><code>os.sched_getparam</code>(<em>pid</em>)</p><p>返回 PID 为 <em>pid</em> 的进程的调度参数为一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sched_param" target="_blank" rel="noopener"><code>sched_param</code></a> 实例。<em>pid</em> 为 0 指的是调用本方法的进程。</p></li><li><p><code>os.sched_rr_get_interval</code>(<em>pid</em>)</p><p>返回 PID 为 <em>pid</em> 的进程在时间片轮转调度下的时间片长度（单位为秒）。<em>pid</em> 为 0 指的是调用本方法的进程。</p></li><li><p><code>os.sched_yield</code>()</p><p>自愿放弃 CPU。</p></li><li><p><code>os.sched_setaffinity</code>(<em>pid</em>, <em>mask</em>)</p><p>将 PID 为 <em>pid</em> 的进程（为零则为当前进程）限制到一组 CPU 上。<em>mask</em> 是整数的可迭代对象，表示应将进程限制在其中的一组 CPU。</p></li><li><p><code>os.sched_getaffinity</code>(<em>pid</em>)</p><p>返回 PID 为 <em>pid</em> 的进程（为零则为当前进程）被限制到的那一组 CPU。</p></li></ul><h2 id="其他系统信息"><a href="#其他系统信息" class="headerlink" title="其他系统信息"></a>其他系统信息</h2><ul><li><p><code>os.confstr</code>(<em>name</em>)</p><p>返回字符串格式的系统配置信息。<em>name</em> 指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 <code>confstr_names</code> 字典的键中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 <em>name</em>。</p><p>如果 <em>name</em> 指定的配置值未定义，返回 <code>None</code>。</p><p>如果 <em>name</em> 是一个字符串且不是已定义的名称，将抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。如果当前系统不支持 <em>name</em> 指定的配置名称，即使该名称存在于 <code>confstr_names</code>，也会抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常，错误码为 <a href="https://docs.python.org/zh-cn/3.8/library/errno.html#errno.EINVAL" target="_blank" rel="noopener"><code>errno.EINVAL</code></a>。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>s.confstr_names</code></p><p>字典，表示映射关系，为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.confstr" target="_blank" rel="noopener"><code>confstr()</code></a> 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.cpu_count</code>()</p><p>返回系统的 CPU 数量。不确定则返回 <code>None</code>。该数量不同于当前进程可以使用的CPU数量。可用的CPU数量可以由 <code>len(os.sched_getaffinity(0))</code> 方法获得。<em>3.4 新版功能.</em></p></li><li><p><code>os.getloadavg</code>()</p><p>返回系统运行队列中最近 1、5 和 15 分钟内的平均进程数。无法获得平均负载则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.sysconf</code>(<em>name</em>)</p><p>返回整数格式的系统配置信息。如果 <em>name</em> 指定的配置值未定义，返回 <code>-1</code>。对 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.confstr" target="_blank" rel="noopener"><code>confstr()</code></a> 的 <em>name</em> 参数的注释在此处也适用。当前已知的配置名称在 <code>sysconf_names</code> 字典中提供。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li><li><p><code>os.sysconf_names</code></p><p>字典，表示映射关系，为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sysconf" target="_blank" rel="noopener"><code>sysconf()</code></a> 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix。</p></li></ul><p>以下数据值用于支持对路径本身的操作。所有平台都有定义。</p><p>对路径的高级操作在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 模块中定义。</p><ul><li><p><code>os.curdir</code></p><p>操作系统用来表示当前目录的常量字符串。在 Windows 和 POSIX 上是 <code>&#39;.&#39;</code>。在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 中也可用。</p></li></ul><ul><li><p><code>os.pardir</code></p><p>操作系统用来表示父目录的常量字符串。在 Windows 和 POSIX 上是 <code>&#39;..&#39;</code>。在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 中也可用。</p></li></ul><ul><li><p><code>os.defpath</code></p><p>在环境变量没有 <code>&#39;PATH&#39;</code> 键的情况下，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.execl" target="_blank" rel="noopener"><code>exec*p*</code></a> and <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.spawnl" target="_blank" rel="noopener"><code>spawn*p*</code></a> 使用的默认搜索路径。在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 中也可用。</p></li><li><p><code>os.linesep</code></p><p>当前平台用于分隔（或终止）行的字符串。它可以是单个字符，如 POSIX 上是 <code>&#39;\n&#39;</code>，也可以是多个字符，如 Windows 上是 <code>&#39;\r\n&#39;</code>。在写入以文本模式（默认模式）打开的文件时，请不要使用 <em>os.linesep</em> 作为行终止符，请在所有平台上都使用一个 <code>&#39;\n&#39;</code> 代替。</p></li><li><p><code>os.devnull</code></p><p>空设备的文件路径。如 POSIX 上为 <code>&#39;/dev/null&#39;</code>，Windows 上为 <code>&#39;nul&#39;</code>。在 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 中也可用。</p></li><li><p><code>os.RTLD_LAZY</code></p></li><li><p><code>os.RTLD_NOW</code></p></li><li><p><code>os.RTLD_GLOBAL</code></p></li><li><p><code>os.RTLD_LOCAL</code></p></li><li><p><code>os.RTLD_NODELETE</code></p></li><li><p><code>os.RTLD_NOLOAD</code></p></li><li><p><code>os.RTLD_DEEPBIND</code></p><p><a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.setdlopenflags" target="_blank" rel="noopener"><code>setdlopenflags()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.getdlopenflags" target="_blank" rel="noopener"><code>getdlopenflags()</code></a> 函数所使用的标志。请参阅 Unix 手册页 <em><a href="https://manpages.debian.org/dlopen(3" target="_blank" rel="noopener">dlopen(3)</a>)</em> 获取不同标志的含义。<em>3.3 新版功能.</em></p></li></ul><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><ul><li><p><code>os.getrandom</code>(<em>size</em>, <em>flags=0</em>)</p><p>获得最多为 <em>size</em> 的随机字节。本函数返回的字节数可能少于请求的字节数。</p><p>这些字节可用于为用户空间的随机数生成器提供种子，或用于加密目的。</p><p><code>getrandom()</code> 依赖于从设备驱动程序和其他环境噪声源收集的熵。不必要地读取大量数据将对使用 <code>/dev/random</code> 和 <code>/dev/urandom</code> 设备的其他用户产生负面影响。</p><p>flags 参数是一个位掩码，可以是零个或多个下列值以或运算组合： <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.GRND_RANDOM" target="_blank" rel="noopener"><code>os.GRND_RANDOM</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.GRND_NONBLOCK" target="_blank" rel="noopener"><code>GRND_NONBLOCK</code></a>。</p><p>另请参阅 <a href="http://man7.org/linux/man-pages/man2/getrandom.2.html" target="_blank" rel="noopener">Linux getrandom() 手册页</a> 。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>：Linux 3.17 或更高版本。</p><p><em>3.6 新版功能.</em></p></li><li><p><code>os.urandom</code>(<em>size</em>)</p><p>返回大小为 <em>size</em> 的字符串，它是适合加密使用的随机字节。本函数从系统指定的随机源获取随机字节。对于加密应用程序，返回的数据应有足够的不可预测性，尽管其确切的品质取决于操作系统的实现。在 Linux 上，如果 <code>getrandom()</code> 系统调用可用，它将以阻塞模式使用：阻塞直到系统的 urandom 熵池初始化完毕（内核收集了 128 位熵）。原理请参阅 <a href="https://www.python.org/dev/peps/pep-0524" target="_blank" rel="noopener"><strong>PEP 524</strong></a>。在 Linux 上，<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getrandom" target="_blank" rel="noopener"><code>getrandom()</code></a> 可以以非阻塞模式（使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.GRND_NONBLOCK" target="_blank" rel="noopener"><code>GRND_NONBLOCK</code></a> 标志）获取随机字节，或者轮询直到系统的 urandom 熵池初始化完毕。在类 Unix 系统上，随机字节是从 <code>/dev/urandom</code> 设备读取的。如果 <code>/dev/urandom</code> 设备不可用或不可读，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#NotImplementedError" target="_blank" rel="noopener"><code>NotImplementedError</code></a> 异常。在 Windows 上将使用 <code>CryptGenRandom()</code>。参见 <a href="https://docs.python.org/zh-cn/3.8/library/secrets.html#module-secrets" target="_blank" rel="noopener"><code>secrets</code></a> 模块提供了更高级的功能。所在平台会提供随机数生成器，有关其易于使用的接口，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/random.html#random.SystemRandom" target="_blank" rel="noopener"><code>random.SystemRandom</code></a>。<em>在 3.6.0 版更改:</em> 在 Linux 上，<code>getrandom()</code> 现在以阻塞模式使用，以提高安全性。<em>在 3.5.2 版更改:</em> 在 Linux 上，如果 <code>getrandom()</code> 系统调用阻塞（urandom 熵池尚未初始化完毕），则退回一步读取 <code>/dev/urandom</code>。<em>在 3.5 版更改:</em> 在 Linux 3.17 和更高版本上，现在使用 <code>getrandom()</code> 系统调用（如果可用）。在 OpenBSD 5.6 和更高版本上，现在使用 <code>getentropy()</code> C 函数。这些函数避免了使用内部文件描述符。</p></li><li><p><code>os.GRND_NONBLOCK</code></p><p>默认情况下，从 <code>/dev/random</code> 读取时，如果没有可用的随机字节，则 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getrandom" target="_blank" rel="noopener"><code>getrandom()</code></a> 会阻塞；从 <code>/dev/urandom</code> 读取时，如果熵池尚未初始化，则会阻塞。如果设置了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.GRND_NONBLOCK" target="_blank" rel="noopener"><code>GRND_NONBLOCK</code></a> 标志，则这些情况下 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.getrandom" target="_blank" rel="noopener"><code>getrandom()</code></a> 不会阻塞，而是立即抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#BlockingIOError" target="_blank" rel="noopener"><code>BlockingIOError</code></a> 异常。<em>3.6 新版功能.</em></p></li><li><p><code>os.GRND_RANDOM</code></p><p>如果设置了此标志位，那么将从 <code>/dev/random</code> 池而不是 <code>/dev/urandom</code> 池中提取随机字节。</p><p><em>3.6 新版功能.</em></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-os&quot;&gt;&lt;a href=&quot;#python-标准库-os&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 os&quot;&gt;&lt;/a&gt;python 标准库 os&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200220_os.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="os" scheme="https://pinghailinfeng.gitee.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>python standard library shutil</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/19/python-standard-library-shutil/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/19/python-standard-library-shutil/</id>
    <published>2020-02-19T13:24:47.000Z</published>
    <updated>2020-02-19T13:44:39.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-shutil-高阶文件操作"><a href="#python-标准库-shutil-高阶文件操作" class="headerlink" title="python 标准库 shutil 高阶文件操作"></a>python 标准库 shutil 高阶文件操作</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200219python3_sheet.png?raw=true" alt></p><a id="more"></a><p>收集了一些网上找到的学习python的资源,分享给大家。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/shutil.py" target="_blank" rel="noopener">Lib/shutil.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 模块提供了一系列对文件和文件集合的高阶操作。 特别是提供了一些支持文件拷贝和删除的函数。 对于单个文件的操作，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块。</p><blockquote><p>警告：即便是高阶文件拷贝函数 (<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>shutil.copy()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>shutil.copy2()</code></a>) 也无法拷贝所有的文件元数据。</p><p>在 POSIX 平台上，这意味着将丢失文件所有者和组以及 ACL 数据。 在 Mac OS 上，资源钩子和其他元数据不被使用。 这意味着将丢失这些资源并且文件类型和创建者代码将不正确。 在 Windows 上，将不会拷贝文件所有者、ACL 和替代数据流。</p></blockquote><h2 id="目录和文件操作"><a href="#目录和文件操作" class="headerlink" title="目录和文件操作"></a>目录和文件操作</h2><ul><li><p><code>shutil.copyfileobj</code>(<em>fsrc</em>, <em>fdst</em>[, <em>length</em>])</p><p>将文件类对象 <em>fsrc</em> 的内容拷贝到文件类对象 <em>fdst</em>。 整数值 <em>length</em> 如果给出则为缓冲区大小。 特别地， <em>length</em> 为负值表示拷贝数据时不对源数据进行分块循环处理；默认情况下会分块读取数据以避免不受控制的内存消耗。 请注意如果 <em>fsrc</em> 对象的当前文件位置不为 0，则只有从当前文件位置到文件末尾的内容会被拷贝。</p></li><li><p><code>shutil.copyfile</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>将名为 <em>src</em> 的文件的内容（不包括元数据）拷贝到名为 <em>dst</em> 的文件并以尽可能高效的方式返回 <em>dst</em>。 <em>src</em> 和 <em>dst</em> 均为路径类对象或以字符串形式给出的路径名。<em>dst</em> 必须是完整的目标文件名；对于接受目标目录路径的拷贝请参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a>。 如果 <em>src</em> 和 <em>dst</em> 指定了同一个文件，则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.SameFileError" target="_blank" rel="noopener"><code>SameFileError</code></a>。目标位置必须是可写的；否则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。 如果 <em>dst</em> 已经存在，它将被替换。 特殊文件如字符或块设备以及管道无法用此函数来拷贝。如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则将创建一个新的符号链接而不是拷贝 <em>src</em> 所指向的文件。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 曾经是引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#IOError" target="_blank" rel="noopener"><code>IOError</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a>。 增加了 <em>follow_symlinks</em> 参数。 现在是返回 <em>dst</em>。<em>在 3.4 版更改:</em> 引发 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.SameFileError" target="_blank" rel="noopener"><code>SameFileError</code></a> 而不是 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.Error" target="_blank" rel="noopener"><code>Error</code></a>。 由于前者是后者的子类，此改变是向后兼容的。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p></li><li><p><em>exception</em> <code>shutil.SameFileError</code></p><p>此异常会在 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfile" target="_blank" rel="noopener"><code>copyfile()</code></a> 中的源和目标为同一文件时被引发。<em>3.4 新版功能.</em></p></li><li><p><code>shutil.copymode</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>从 <em>src</em> 拷贝权限位到 <em>dst</em>。 文件的内容、所有者和分组将不受影响。 <em>src</em> 和 <em>dst</em> 均为路径类对象或字符串形式的路径名。 如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均为符号链接，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copymode" target="_blank" rel="noopener"><code>copymode()</code></a> 将尝试修改 <em>dst</em> 本身的模式（而非它所指向的文件）。 此功能并不是在所有平台上均可用；请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 了解详情。 如果 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copymode" target="_blank" rel="noopener"><code>copymode()</code></a> 无法修改本机平台上的符号链接，而它被要求这样做，它将不做任何操作即返回。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copymode</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 加入 <em>follow_symlinks</em> 参数。</p></li><li><p><code>shutil.copystat</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>从 <em>src</em> 拷贝权限位、最近访问时间、最近修改时间以及旗标到 <em>dst</em>。 在 Linux上，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 还会在可能的情况下拷贝“扩展属性”。 文件的内容、所有者和分组将不受影响。 <em>src</em> 和 <em>dst</em> 均为路径类对象或字符串形式的路径名。如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均指向符号链接，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 将作用于符号链接本身而非该符号链接所指向的文件 — 从 <em>src</em> 符号链接读取信息，并将信息写入 <em>dst</em> 符号链接。</p><blockquote><p>注解:</p><p>并非所有平台者提供检查和修改符号链接的功能。 Python 本身可以告诉你哪些功能是在本机上可用的。</p><ul><li>如果 <code>os.chmod in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 可以修改符号链接的权限位。</li><li>如果 <code>os.utime in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 可以修改符号链接的最近访问和修改时间。</li><li>如果 <code>os.chflags in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 可以修改符号链接的旗标。 (<code>os.chflags</code> 不是在所有平台上均可用。)</li></ul><p>在此功能部分或全部不可用的平台上，当被要求修改一个符号链接时，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 将尽量拷贝所有内容。 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 一定不会返回失败信息。</p><p>更多信息请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.supports_follow_symlinks" target="_blank" rel="noopener"><code>os.supports_follow_symlinks</code></a>。</p></blockquote><p>引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copystat</code> 附带参数 <code>src</code>, <code>dst</code>。</p><p><em>在 3.3 版更改:</em> 添加了 <em>follow_symlinks</em> 参数并且支持 Linux 扩展属性。</p></li><li><p><code>shutil.copy</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>将文件 <em>src</em> 拷贝到文件或目录 <em>dst</em>。 <em>src</em> 和 <em>dst</em> 应为字符串。 如果 <em>dst</em> 指定了一个目录，文件将使用 <em>src</em> 中的基准文件名拷贝到 <em>dst</em>。 返回新创建文件的路径。如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则 <em>dst</em> 也将被创建为符号链接。 如果 <em>follow_symlinks</em> 为真值且 <em>src</em> 为符号链接，<em>dst</em> 将成为 <em>src</em> 所指向的文件的一个副本。<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a> 会拷贝文件数据和文件的权限模式 (参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chmod" target="_blank" rel="noopener"><code>os.chmod()</code></a>)。 其他元数据，例如文件的创建和修改时间不会被保留。 要保留所有原有的元数据，请改用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copymode</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 添加了 <em>follow_symlinks</em> 参数。 现在会返回新创建文件的路径。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p></li><li><p><code>shutil.copy2</code>(<em>src</em>, <em>dst</em>, <em>**, </em>follow_symlinks=True*)</p><p>类似于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a>，区别在于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 还会尝试保留文件的元数据。当 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接时，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 会尝试将来自 <em>src</em> 符号链接的所有元数据拷贝到新创建的 <em>dst</em> 符号链接。 但是，此功能不是在所有平台上均可用。 在此功能部分或全部不可用的平台上，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 将尽量保留所有元数据；<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 一定不会由于无法保留文件元数据而引发异常。<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 会使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 来拷贝文件元数据。 请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 了解有关修改符号链接元数据的平台支持的更多信息。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copystat</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 添加了 <em>follow_symlinks</em> 参数，还会尝试拷贝扩展文件系统属性（目前仅限 Linux）。 现在会返回新创建文件的路径。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p></li><li><p><code>shutil.ignore_patterns</code>(*<em>patterns</em>)</p><p>这个工厂函数会创建一个函数，它可被用作 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 的 <em>ignore</em> 可调用对象参数，以忽略那些匹配所提供的 glob 风格的 <em>patterns</em> 之一的文件和目录。 参见以下示例。</p></li><li><p><code>shutil.copytree</code>(<em>src</em>, <em>dst</em>, <em>symlinks=False</em>, <em>ignore=None</em>, <em>copy_function=copy2</em>, <em>ignore_dangling_symlinks=False</em>, <em>dirs_exist_ok=False</em>)</p><p>将以 <em>src</em> 为根起点的整个目录树拷贝到名为 <em>dst</em> 的目录并返回目标目录。 <em>dirs_exist_ok</em> 指明是否要在 <em>dst</em> 或任何丢失的父目录已存在的情况下引发异常。目录的权限和时间会通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copystat" target="_blank" rel="noopener"><code>copystat()</code></a> 来拷贝，单个文件则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 来拷贝。如果 <em>symlinks</em> 为真值，源目录树中的符号链接会在新目录树中表示为符号链接，并且原链接的元数据在平台允许的情况下也会被拷贝；如果为假值或省略，则会将被链接文件的内容和元数据拷贝到新目录树。当 <em>symlinks</em> 为假值时，如果符号链接所指向的文件不存在，则会在拷贝进程的末尾将一个异常添加到 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.Error" target="_blank" rel="noopener"><code>Error</code></a> 异常中的错误列表。 如果你希望屏蔽此异常那就将可选的 <em>ignore_dangling_symlinks</em> 旗标设为真值。 请注意此选项在不支持 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.symlink" target="_blank" rel="noopener"><code>os.symlink()</code></a> 的平台上将不起作用。如果给出了 <em>ignore</em>，它必须是一个可调用对象，该对象将接受 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 所访问的目录以及 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.listdir" target="_blank" rel="noopener"><code>os.listdir()</code></a> 所返回的目录内容列表作为其参数。 由于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 是递归地被调用的，<em>ignore</em> 可调用对象对于每个被拷贝目录都将被调用一次。 该可调用对象必须返回一个相对于当前目录的目录和文件名序列（即其第二个参数的子集）；随后这些名称将在拷贝进程中被忽略。 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.ignore_patterns" target="_blank" rel="noopener"><code>ignore_patterns()</code></a> 可被用于创建这种基于 glob 风格模式来忽略特定名称的可调用对象。如果发生了（一个或多个）异常，将引发一个附带原因列表的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.Error" target="_blank" rel="noopener"><code>Error</code></a>。如果给出了 <em>copy_function</em>，它必须是一个将被用来拷贝每个文件的可调用对象。 它在被调用时会将源路径和目标路径作为参数传入。 默认情况下，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a> 将被使用，但任何支持同样签名（与 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a> 一致）都可以使用。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.copytree</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 当 <em>symlinks</em> 为假值时拷贝元数据。 现在会返回 <em>dst</em>。<em>在 3.2 版更改:</em> 添加了 <em>copy_function</em> 参数以允许提供定制的拷贝函数。 添加了 <em>ignore_dangling_symlinks</em> 参数以便在 <em>symlinks</em> 为假值时屏蔽符号链接错误。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。<em>3.8 新版功能:</em> <em>dirs_exist_ok</em> 形参。</p></li><li><p><code>shutil.rmtree</code>(<em>path</em>, <em>ignore_errors=False</em>, <em>onerror=None</em>)</p><p>删除一个完整的目录树；<em>path</em> 必须指向一个目录（但不能是一个目录的符号链接）。 如果 <em>ignore_errors</em> 为真值，删除失败导致的错误将被忽略；如果为假值或是省略，此类错误将通过调用由 <em>onerror</em> 所指定的处理程序来处理，或者如果此参数被省略则将引发一个异常。</p><blockquote><p>注解:</p><p>在支持必要的基于 fd 的函数的平台上，默认会使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree" target="_blank" rel="noopener"><code>rmtree()</code></a> 的可防御符号链接攻击的版本。 在其他平台上，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree" target="_blank" rel="noopener"><code>rmtree()</code></a> 较易遭受符号链接攻击：给定适当的时间和环境，攻击者可以操纵文件系统中的符号链接来删除他们在其他情况下无法访问的文件。 应用程序可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.rmtree.avoids_symlink_attacks" target="_blank" rel="noopener"><code>rmtree.avoids_symlink_attacks</code></a> 函数属性来确定此类情况具体是哪一些。</p></blockquote></li></ul><ul><li><p><code>shutil.move</code>(<em>src</em>, <em>dst</em>, <em>copy_function=copy2</em>)</p><p>递归地将一个文件或目录 (<em>src</em>) 移至另一位置 (<em>dst</em>) 并返回目标位置。如果目标是已存在的目录，则 <em>src</em> 会被移至该目录下。 如果目标已存在但不是目录，它可能会被覆盖，具体取决于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a> 的语义。如果目标是在当前文件系统中，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a>。 在其他情况下，<em>src</em> 将被拷贝至 <em>dst</em>，使用的函数为 <em>copy_function</em>，然后目标会被移除。 对于符号链接，则将在 <em>dst</em> 之下或以其本身为名称创建一个指向 <em>src</em> 目标的新符号链接，并且 <em>src</em> 将被移除。如果给出了 <em>copy_function</em>，则它必须为接受两个参数 <em>src</em> 和 <em>dst</em> 的可调用对象，并会在 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.rename" target="_blank" rel="noopener"><code>os.rename()</code></a> 无法使用时被用来将 <em>src</em> 拷贝到 <em>dest</em>。 如果源位置是一个目录，则会调用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a>，并向它传入 <code>copy_function()</code>。 默认的 <em>copy_function</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a>。 使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy" target="_blank" rel="noopener"><code>copy()</code></a> 作为 <em>copy_function</em> 允许在无法附带拷贝元数据时让移动操作成功执行，但其代价是不拷贝任何元数据。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.move</code> 附带参数 <code>src</code>, <code>dst</code>。<em>在 3.3 版更改:</em> 为异类文件系统添加了显式的符号链接处理，以便使它适应 GNU 的 <strong>mv</strong> 的行为。 现在会返回 <em>dst</em>。<em>在 3.5 版更改:</em> 增加了 <em>copy_function</em> 关键字参数。<em>在 3.8 版更改:</em> 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 参见 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil-platform-dependent-efficient-copy-operations" target="_blank" rel="noopener">依赖于具体平台的高效拷贝操作</a> 一节。</p></li><li><p><code>shutil.disk_usage</code>(<em>path</em>)</p><p>返回给定路径的磁盘使用统计数据，形式为一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-named-tuple" target="_blank" rel="noopener">named tuple</a>，其中包含 <em>total</em>, <em>used</em> 和 <em>free</em> 属性，分别表示总计、已使用和未使用空间的字节数。 <em>path</em> 可以是一个文件或是一个目录。<em>3.3 新版功能.**在 3.8 版更改:</em> 在 Windows 上，<em>path</em> 现在可以是一个文件或目录。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p></li><li><p><code>shutil.chown</code>(<em>path</em>, <em>user=None</em>, <em>group=None</em>)</p><p>修改给定 <em>path</em> 的所有者 <em>user</em> 和/或 <em>group</em>。<em>user</em> 可以是一个系统用户名或 uid；<em>group</em> 同样如此。 要求至少有一个参数。另请参阅下层的函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.chown" target="_blank" rel="noopener"><code>os.chown()</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.chown</code> 附带参数 <code>path</code>, <code>user</code>, <code>group</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">Availability</a>: Unix.<em>3.3 新版功能.</em></p></li><li><p><code>shutil.which</code>(<em>cmd</em>, <em>mode=os.F_OK | os.X_OK</em>, <em>path=None</em>)</p><p>返回当给定的 <em>cmd</em> 被调用时将要运行的可执行文件的路径。 如果没有 <em>cmd</em> 会被调用则返回 <code>None</code>。<em>mode</em> 是一个传递给 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.access" target="_blank" rel="noopener"><code>os.access()</code></a> 的权限掩码，在默认情况下将确定文件是否存在并且为可执行文件。当未指定 <em>path</em> 时，将会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.environ" target="_blank" rel="noopener"><code>os.environ()</code></a> 的结果，返回 “PATH” 的值或回退为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.defpath" target="_blank" rel="noopener"><code>os.defpath</code></a>。在 Windows 上当前目录总是会被添加为 <em>path</em> 的第一项，无论你是否使用默认值或提供你自己的路径，这是命令行终端在查找可执行文件时所采用的行为方式。 此外，当在 <em>path</em> 中查找 <em>cmd</em> 时，还会检查 <code>PATHEXT</code> 环境变量。 例如，如果你调用 <code>shutil.which(&quot;python&quot;)</code>，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.which" target="_blank" rel="noopener"><code>which()</code></a> 将搜索 <code>PATHEXT</code> 来确定它要在 <em>path</em> 目录中查找 <code>python.exe</code>。 例如，在 Windows 上:&gt;&gt;&gt;<code>&gt;&gt;&gt; shutil.which(&quot;python&quot;) &#39;C:\\Python33\\python.EXE&#39;</code><em>3.3 新版功能.**在 3.8 版更改:</em> 现在可以接受 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> 类型。 如果 <em>cmd</em> 的类型为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>，结果的类型也将为 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a>。</p></li><li><p><em>exception</em> <code>shutil.Error</code></p><p>此异常会收集在多文件操作期间所引发的异常。 对于 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a>，此异常参数将是一个由三元组 (<em>srcname</em>, <em>dstname</em>, <em>exception</em>) 构成的列表。</p></li></ul><h2 id="依赖于具体平台的高效拷贝操作"><a href="#依赖于具体平台的高效拷贝操作" class="headerlink" title="依赖于具体平台的高效拷贝操作"></a>依赖于具体平台的高效拷贝操作</h2><p>从 Python 3.8 开始，所有涉及文件拷贝的函数 (<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfile" target="_blank" rel="noopener"><code>copyfile()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/copy.html#module-copy" target="_blank" rel="noopener"><code>copy()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copy2" target="_blank" rel="noopener"><code>copy2()</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a>, 以及 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.move" target="_blank" rel="noopener"><code>move()</code></a>) 将会使用平台专属的 “fast-copy” 系统调用以便更高效地拷贝文件 (参见 <a href="https://bugs.python.org/issue33671" target="_blank" rel="noopener">bpo-33671</a>)。 “fast-copy” 意味着拷贝操作将发生于内核之中，避免像在 “<code>outfd.write(infd.read())</code>“ 中那样使用用户空间的缓冲区。</p><p>在 macOS 上将会使用 <a href="http://www.manpagez.com/man/3/copyfile/" target="_blank" rel="noopener">fcopyfile</a> 来拷贝文件内容（不含元数据）。</p><p>在 Linux 上将会使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.sendfile" target="_blank" rel="noopener"><code>os.sendfile()</code></a>。</p><p>在 Windows 上 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfile" target="_blank" rel="noopener"><code>shutil.copyfile()</code></a> 将会使用更大的默认缓冲区（1 MiB 而非 64 KiB）并且会使用基于 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#memoryview" target="_blank" rel="noopener"><code>memoryview()</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfileobj" target="_blank" rel="noopener"><code>shutil.copyfileobj()</code></a> 变种形式。</p><p>如果快速拷贝操作失败并且没有数据被写入目标文件，则 shutil 将在内部静默地回退到使用效率较低的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copyfileobj" target="_blank" rel="noopener"><code>copyfileobj()</code></a> 函数。</p><p><em>在 3.8 版更改.</em></p><h3 id="copytree-示例"><a href="#copytree-示例" class="headerlink" title="copytree 示例"></a>copytree 示例</h3><p>这个示例就是上面所描述的 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.copytree" target="_blank" rel="noopener"><code>copytree()</code></a> 函数的实现，其中省略了文档字符串。 它还展示了此模块所提供的许多其他函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copytree</span><span class="params">(src, dst, symlinks=False)</span>:</span></span><br><span class="line">    names = os.listdir(src)</span><br><span class="line">    os.makedirs(dst)</span><br><span class="line">    errors = []</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        srcname = os.path.join(src, name)</span><br><span class="line">        dstname = os.path.join(dst, name)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> symlinks <span class="keyword">and</span> os.path.islink(srcname):</span><br><span class="line">                linkto = os.readlink(srcname)</span><br><span class="line">                os.symlink(linkto, dstname)</span><br><span class="line">            <span class="keyword">elif</span> os.path.isdir(srcname):</span><br><span class="line">                copytree(srcname, dstname, symlinks)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                copy2(srcname, dstname)</span><br><span class="line">            <span class="comment"># XXX What about devices, sockets etc.?</span></span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> why:</span><br><span class="line">            errors.append((srcname, dstname, str(why)))</span><br><span class="line">        <span class="comment"># catch the Error from the recursive copytree so that we can</span></span><br><span class="line">        <span class="comment"># continue with other files</span></span><br><span class="line">        <span class="keyword">except</span> Error <span class="keyword">as</span> err:</span><br><span class="line">            errors.extend(err.args[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        copystat(src, dst)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> why:</span><br><span class="line">        <span class="comment"># can't copy file access times on Windows</span></span><br><span class="line">        <span class="keyword">if</span> why.winerror <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            errors.extend((src, dst, str(why)))</span><br><span class="line">    <span class="keyword">if</span> errors:</span><br><span class="line">        <span class="keyword">raise</span> Error(errors)</span><br></pre></td></tr></table></figure><p>另一个使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.ignore_patterns" target="_blank" rel="noopener"><code>ignore_patterns()</code></a> 辅助函数的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree, ignore_patterns</span><br><span class="line"></span><br><span class="line">copytree(source, destination, ignore=ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br></pre></td></tr></table></figure><p>这将会拷贝除 <code>.pyc</code> 文件和以 <code>tmp</code> 打头的文件或目录以外的所有条目.</p><p>另一个使用 <em>ignore</em> 参数来添加记录调用的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copytree</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_logpath</span><span class="params">(path, names)</span>:</span></span><br><span class="line">    logging.info(<span class="string">'Working in %s'</span>, path)</span><br><span class="line">    <span class="keyword">return</span> []   <span class="comment"># nothing will be ignored</span></span><br><span class="line"></span><br><span class="line">copytree(source, destination, ignore=_logpath)</span><br></pre></td></tr></table></figure><h3 id="rmtree-示例"><a href="#rmtree-示例" class="headerlink" title="rmtree 示例"></a>rmtree 示例</h3><p>这个例子演示了如何在 Windows 上删除一个目录树，其中部分文件设置了只读属性位。 它会使用 onerror 回调函数来清除只读属性位并再次尝试删除。 任何后续的失败都将被传播。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, stat</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_readonly</span><span class="params">(func, path, _)</span>:</span></span><br><span class="line">    <span class="string">"Clear the readonly bit and reattempt the removal"</span></span><br><span class="line">    os.chmod(path, stat.S_IWRITE)</span><br><span class="line">    func(path)</span><br><span class="line"></span><br><span class="line">shutil.rmtree(directory, onerror=remove_readonly)</span><br></pre></td></tr></table></figure><h2 id="归档操作"><a href="#归档操作" class="headerlink" title="归档操作"></a>归档操作</h2><p><em>3.2 新版功能.</em></p><p><em>在 3.5 版更改:</em> 添加了对 <em>xztar</em> 格式的支持。</p><p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <a href="https://docs.python.org/zh-cn/3.8/library/zipfile.html#module-zipfile" target="_blank" rel="noopener"><code>zipfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tarfile.html#module-tarfile" target="_blank" rel="noopener"><code>tarfile</code></a> 模块。</p><ul><li><p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p><p>创建一个归档文件（例如 zip 或 tar）并返回其名称。<em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “tar”, “gztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “bztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用) 或 “xztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用) 中的一个。<em>root_dir</em> 是一个目录，它将作为归档文件的根目录；例如，我们通常会在创建归档文件之前用 chdir 命令切换到 <em>root_dir</em>。<em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档文件中所有文件和目录共有的路径前缀。<em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。<em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。<em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logging.Logger" target="_blank" rel="noopener"><code>logging.Logger</code></a> 的实例。<em>verbose</em> 参数已不再使用并进入弃用状态。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。<em>在 3.8 版更改:</em> 现在对于通过 <code>format=&quot;tar&quot;</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p></li><li><p><code>shutil.get_archive_formats</code>()</p><p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_archive_format" target="_blank" rel="noopener"><code>register_archive_format()</code></a> 注册新的格式或为任何现有格式提供你自己的归档器。</p></li><li><p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>为 <em>name</em> 格式注册一个归档器。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name</em>，再加上要归档内容的 <em>base_dir</em> (其默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.make_archive" target="_blank" rel="noopener"><code>make_archive()</code></a> 传入的参数一致)。如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。<em>description</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_archive_formats" target="_blank" rel="noopener"><code>get_archive_formats()</code></a> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p></li><li><p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p><p>从支持的格式中移除归档格式 <em>name</em>。</p></li><li><p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p><p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。<em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。<em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册的其他格式。 如果未提供，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.unpack_archive" target="_blank" rel="noopener"><code>unpack_archive()</code></a> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。<em>在 3.7 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a> 作为 <em>filename</em> 和 <em>extract_dir</em>。</p></li><li><p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。可以提供 <em>description</em> 来描述该格式，它将被 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_unpack_formats" target="_blank" rel="noopener"><code>get_unpack_formats()</code></a> 返回。</p></li><li><p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p><p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p></li><li><p><code>shutil.get_unpack_formats</code>()</p><p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。<em>tar</em>: 未压缩的 tar 文件。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册新的格式或为任何现有格式提供你自己的解包器。</p></li></ul><p><em>3.2 新版功能.</em></p><p><em>在 3.5 版更改:</em> 添加了对 <em>xztar</em> 格式的支持。</p><p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <a href="https://docs.python.org/zh-cn/3.8/library/zipfile.html#module-zipfile" target="_blank" rel="noopener"><code>zipfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tarfile.html#module-tarfile" target="_blank" rel="noopener"><code>tarfile</code></a> 模块。</p><ul><li><p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p><p>创建一个归档文件（例如 zip 或 tar）并返回其名称。<em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “tar”, “gztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “bztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用) 或 “xztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用) 中的一个。<em>root_dir</em> 是一个目录，它将作为归档文件的根目录；例如，我们通常会在创建归档文件之前用 chdir 命令切换到 <em>root_dir</em>。<em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档文件中所有文件和目录共有的路径前缀。<em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。<em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。<em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logging.Logger" target="_blank" rel="noopener"><code>logging.Logger</code></a> 的实例。<em>verbose</em> 参数已不再使用并进入弃用状态。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。<em>在 3.8 版更改:</em> 现在对于通过 <code>format=&quot;tar&quot;</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p></li><li><p><code>shutil.get_archive_formats</code>()</p><p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_archive_format" target="_blank" rel="noopener"><code>register_archive_format()</code></a> 注册新的格式或为任何现有格式提供你自己的归档器。</p></li><li><p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>为 <em>name</em> 格式注册一个归档器。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name</em>，再加上要归档内容的 <em>base_dir</em> (其默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.make_archive" target="_blank" rel="noopener"><code>make_archive()</code></a> 传入的参数一致)。如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。<em>description</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_archive_formats" target="_blank" rel="noopener"><code>get_archive_formats()</code></a> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p></li><li><p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p><p>从支持的格式中移除归档格式 <em>name</em>。</p></li><li><p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p><p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。<em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。<em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册的其他格式。 如果未提供，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.unpack_archive" target="_blank" rel="noopener"><code>unpack_archive()</code></a> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。<em>在 3.7 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a> 作为 <em>filename</em> 和 <em>extract_dir</em>。</p></li><li><p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。可以提供 <em>description</em> 来描述该格式，它将被 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_unpack_formats" target="_blank" rel="noopener"><code>get_unpack_formats()</code></a> 返回。</p></li><li><p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p><p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p></li><li><p><code>shutil.get_unpack_formats</code>()</p><p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。<em>tar</em>: 未压缩的 tar 文件。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册新的格式或为任何现有格式提供你自己的解包器。</p></li></ul><p><em>3.2 新版功能.</em></p><p><em>在 3.5 版更改:</em> 添加了对 <em>xztar</em> 格式的支持。</p><p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <a href="https://docs.python.org/zh-cn/3.8/library/zipfile.html#module-zipfile" target="_blank" rel="noopener"><code>zipfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tarfile.html#module-tarfile" target="_blank" rel="noopener"><code>tarfile</code></a> 模块。</p><ul><li><p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p><p>创建一个归档文件（例如 zip 或 tar）并返回其名称。<em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “tar”, “gztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用), “bztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用) 或 “xztar” (如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用) 中的一个。<em>root_dir</em> 是一个目录，它将作为归档文件的根目录；例如，我们通常会在创建归档文件之前用 chdir 命令切换到 <em>root_dir</em>。<em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档文件中所有文件和目录共有的路径前缀。<em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。<em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。<em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <a href="https://docs.python.org/zh-cn/3.8/library/logging.html#logging.Logger" target="_blank" rel="noopener"><code>logging.Logger</code></a> 的实例。<em>verbose</em> 参数已不再使用并进入弃用状态。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。<em>在 3.8 版更改:</em> 现在对于通过 <code>format=&quot;tar&quot;</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p></li><li><p><code>shutil.get_archive_formats</code>()</p><p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_archive_format" target="_blank" rel="noopener"><code>register_archive_format()</code></a> 注册新的格式或为任何现有格式提供你自己的归档器。</p></li><li><p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>为 <em>name</em> 格式注册一个归档器。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name</em>，再加上要归档内容的 <em>base_dir</em> (其默认值为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.make_archive" target="_blank" rel="noopener"><code>make_archive()</code></a> 传入的参数一致)。如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。<em>description</em> 由 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_archive_formats" target="_blank" rel="noopener"><code>get_archive_formats()</code></a> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p></li><li><p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p><p>从支持的格式中移除归档格式 <em>name</em>。</p></li><li><p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p><p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。<em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。<em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册的其他格式。 如果未提供，<a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.unpack_archive" target="_blank" rel="noopener"><code>unpack_archive()</code></a> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a> <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。<em>在 3.7 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a> 作为 <em>filename</em> 和 <em>extract_dir</em>。</p></li><li><p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p><p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。<em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。可以提供 <em>description</em> 来描述该格式，它将被 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.get_unpack_formats" target="_blank" rel="noopener"><code>get_unpack_formats()</code></a> 返回。</p></li><li><p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p><p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p></li><li><p><code>shutil.get_unpack_formats</code>()</p><p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。默认情况下 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#module-shutil" target="_blank" rel="noopener"><code>shutil</code></a> 提供以下格式:<em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。<em>tar</em>: 未压缩的 tar 文件。<em>gztar</em>: gzip 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/zlib.html#module-zlib" target="_blank" rel="noopener"><code>zlib</code></a> 模块可用）。<em>bztar</em>: bzip2 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/bz2.html#module-bz2" target="_blank" rel="noopener"><code>bz2</code></a> 模块可用）。<em>xztar</em>: xz 压缩的 tar 文件（如果 <a href="https://docs.python.org/zh-cn/3.8/library/lzma.html#module-lzma" target="_blank" rel="noopener"><code>lzma</code></a> 模块可用）。你可以通过使用 <a href="https://docs.python.org/zh-cn/3.8/library/shutil.html#shutil.register_unpack_format" target="_blank" rel="noopener"><code>register_unpack_format()</code></a> 注册新的格式或为任何现有格式提供你自己的解包器。</p></li></ul><h3 id="归档程序示例"><a href="#归档程序示例" class="headerlink" title="归档程序示例"></a>归档程序示例</h3><p>在这个示例中，我们创建了一个 gzip 压缩的 tar 归档文件，其中包含用户的 <code>.ssh</code> 目录下的所有文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> shutil <span class="keyword">import</span> make_archive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>archive_name = os.path.expanduser(os.path.join(<span class="string">'~'</span>, <span class="string">'myarchive'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root_dir = os.path.expanduser(os.path.join(<span class="string">'~'</span>, <span class="string">'.ssh'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>make_archive(archive_name, <span class="string">'gztar'</span>, root_dir)</span><br><span class="line"><span class="string">'/Users/tarek/myarchive.tar.gz'</span></span><br></pre></td></tr></table></figure><p>结果归档文件中包含有:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tar -tzvf /Users/tarek/myarchive.tar.gz</span><br><span class="line">drwx------ tarek/staff       <span class="number">0</span> <span class="number">2010</span><span class="number">-02</span><span class="number">-01</span> <span class="number">16</span>:<span class="number">23</span>:<span class="number">40</span> ./</span><br><span class="line">-rw-r--r-- tarek/staff     <span class="number">609</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./authorized_keys</span><br><span class="line">-rwxr-xr-x tarek/staff      <span class="number">65</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./config</span><br><span class="line">-rwx------ tarek/staff     <span class="number">668</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_dsa</span><br><span class="line">-rwxr-xr-x tarek/staff     <span class="number">609</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_dsa.pub</span><br><span class="line">-rw------- tarek/staff    <span class="number">1675</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_rsa</span><br><span class="line">-rw-r--r-- tarek/staff     <span class="number">397</span> <span class="number">2008</span><span class="number">-06</span><span class="number">-09</span> <span class="number">13</span>:<span class="number">26</span>:<span class="number">54</span> ./id_rsa.pub</span><br><span class="line">-rw-r--r-- tarek/staff   <span class="number">37192</span> <span class="number">2010</span><span class="number">-02</span><span class="number">-06</span> <span class="number">18</span>:<span class="number">23</span>:<span class="number">10</span> ./known_hosts</span><br></pre></td></tr></table></figure><h2 id="查询输出终端的尺寸"><a href="#查询输出终端的尺寸" class="headerlink" title="查询输出终端的尺寸"></a>查询输出终端的尺寸</h2><ul><li><p><code>shutil.get_terminal_size</code>(<em>fallback=(columns</em>, <em>lines)</em>)</p><p>获取终端窗口的尺寸。</p><p>对于两个维度中的每一个，会分别检查环境变量 <code>COLUMNS</code> 和 <code>LINES</code>。 如果定义了这些变量并且其值为正整数，则将使用这些值。</p><p>如果未定义 <code>COLUMNS</code> 或 <code>LINES</code>，这是通常的情况，则连接到 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.__stdout__" target="_blank" rel="noopener"><code>sys.__stdout__</code></a> 的终端将通过发起调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.get_terminal_size" target="_blank" rel="noopener"><code>os.get_terminal_size()</code></a> 被查询。</p><p>如果由于系统不支持查询，或是由于我们未连接到某个终端而导致查询终端尺寸不成功，则会使用在 <code>fallback</code> 形参中给出的值。 <code>fallback</code> 默认为 <code>(80, 24)</code>，这是许多终端模拟器所使用的默认尺寸。</p><p>返回的值是一个 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.terminal_size" target="_blank" rel="noopener"><code>os.terminal_size</code></a> 类型的具名元组。</p><p>另请参阅: The Single UNIX Specification, Version 2, <a href="http://pubs.opengroup.org/onlinepubs/7908799/xbd/envvar.html#tag_002_003" target="_blank" rel="noopener">Other Environment Variables</a>.</p><p><em>3.3 新版功能.</em></p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">shutil主要API:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  shutil.copyfileobj(fsrc, fdst[, length=<span class="number">16</span>*<span class="number">1024</span>])    <span class="comment">#copy文件内容到另一个文件，可以copy指定大小的内容</span></span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>  shutil.copyfile(src,dst)   <span class="comment">#copy文件内容，是不是感觉上面的文件复制很麻烦？还需要自己手动用open函数打开文件，在这里就不需要了，事实上，copyfile调用了copyfileobj</span></span><br><span class="line"> </span><br><span class="line"><span class="number">3</span>  shutil.copymode(src,dst)   <span class="comment">#仅copy权限，不更改文件内容，组和用户。</span></span><br><span class="line"> </span><br><span class="line"><span class="number">4</span>  shutil.copystat(src,dst)    <span class="comment">#复制所有的状态信息，包括权限，组，用户，时间等</span></span><br><span class="line"> </span><br><span class="line"><span class="number">5</span>  shutil.copy(src,dst)   <span class="comment">#复制文件的内容以及权限，先copyfile后copymode</span></span><br><span class="line"> </span><br><span class="line"><span class="number">6</span>  shutil.copy2(src,dst)    <span class="comment">#复制文件的内容以及文件的所有状态信息。先copyfile后copystat</span></span><br><span class="line"> </span><br><span class="line"><span class="number">7</span>  shutil.copytree(src, dst, symlinks=<span class="literal">False</span>, ignore=<span class="literal">None</span>, copy_function=copy2,ignore_dangling_symlinks=<span class="literal">False</span>)   <span class="comment">#递归的复制文件内容及状态信息</span></span><br><span class="line"> </span><br><span class="line"><span class="number">8</span>  shutil.rmtree(path, ignore_errors=<span class="literal">False</span>, onerror=<span class="literal">None</span>)   <span class="comment">#递归地删除文件</span></span><br><span class="line"> </span><br><span class="line"><span class="number">9</span>  shutil.move(src, dst)    <span class="comment">#递归的移动文件</span></span><br><span class="line"> </span><br><span class="line"><span class="number">10</span>  make_archive(base_name, format, root_dir=<span class="literal">None</span>, base_dir=<span class="literal">None</span>, verbose=<span class="number">0</span>,dry_run=<span class="number">0</span>, owner=<span class="literal">None</span>, group=<span class="literal">None</span>, logger=<span class="literal">None</span>)  <span class="comment">#压缩打包</span></span><br><span class="line"> </span><br><span class="line">base_name：    压缩打包后的文件名或者路径名</span><br><span class="line"></span><br><span class="line">format：          压缩或者打包格式    <span class="string">"zip"</span>, <span class="string">"tar"</span>, <span class="string">"bztar"</span><span class="keyword">or</span> <span class="string">"gztar"</span></span><br><span class="line"></span><br><span class="line">root_dir :         将哪个目录或者文件打包（也就是源文件）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-shutil-高阶文件操作&quot;&gt;&lt;a href=&quot;#python-标准库-shutil-高阶文件操作&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 shutil 高阶文件操作&quot;&gt;&lt;/a&gt;python 标准库 shutil 高阶文件操作&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200219python3_sheet.png?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="shutil" scheme="https://pinghailinfeng.gitee.io/tags/shutil/"/>
    
  </entry>
  
  <entry>
    <title>using ffmpeg download yizhibo m3u8 type playback video</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/18/using-ffmpeg-download-yizhibo-m3u8-type-playback-video/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/18/using-ffmpeg-download-yizhibo-m3u8-type-playback-video/</id>
    <published>2020-02-18T15:20:04.000Z</published>
    <updated>2020-02-19T01:07:40.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-ffmpe-下载一直播-回放视频"><a href="#使用-ffmpe-下载一直播-回放视频" class="headerlink" title="使用 ffmpe 下载一直播 回放视频"></a>使用 ffmpe 下载一直播 回放视频</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200218_JohnWill.jpeg?raw=true" alt></p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>想下载一直播上的直播视频到本地,但是发现没有直接下载的途径,只能回放。</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>下播后,通过分享链接到qq,得到了在线观看回放的视频地址。F12 发现m3u8格式的链接地址。</p><p>复制该链接地址。</p><p>本地已经搭建了ffmpeg的环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PS &gt; ffmpeg</span><br><span class="line">ffmpeg version git-2019-11-20-d73f062 Copyright (c) 2000-2019 the FFmpeg developers</span><br><span class="line">  built with gcc 9.2.1 (GCC) 20191010</span><br><span class="line">  configuration: --enable-gpl --enable-version3 --enable-sdl2 --enable-fontconfig --enable-gnutls --enable-iconv --enable-libass --enable-libdav1d --enable-libbluray --enable-libfreetype --enable-libmp3lame --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-libopenjpeg --enable-libopus --enable-libshine --enable-libsnappy</span><br><span class="line">--enable-libsoxr --enable-libtheora --enable-libtwolame --enable-libvpx --enable-libwavpack --enable-libwebp --enable-libx264 --enable-libx265 --enable-libxml2 --enable-libzimg --enable-lzma --enable-zlib --enable-gmp --enable-libvidstab --enable-libvorbis --enable-libvo-amrwbenc --enable-libmysofa --enable-libspeex --enable-libxvid --enable-libaom --enable-libmfx --enable-ffnvcodec --enable-cuvid --enable-d3d11va --enable-nvenc --enable-nvdec --enable-dxva2 --enable-avisynth --enable-libopenmpt --enable-amf</span><br><span class="line">  libavutil      56. 36.100 / 56. 36.100</span><br><span class="line">  libavcodec     58. 62.100 / 58. 62.100</span><br><span class="line">  libavformat    58. 35.100 / 58. 35.100</span><br><span class="line">  libavdevice    58.  9.101 / 58.  9.101</span><br><span class="line">  libavfilter     7. 66.100 /  7. 66.100</span><br><span class="line">  libswscale      5.  6.100 /  5.  6.100</span><br><span class="line">  libswresample   3.  6.100 /  3.  6.100</span><br><span class="line">  libpostproc    55.  6.100 / 55.  6.100</span><br><span class="line">Hyper fast Audio and Video encoder</span><br><span class="line">usage: ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...</span><br><span class="line"></span><br><span class="line">Use -h to get full help or, even better, run 'man ffmpeg'</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>接下来使用 ffmpeg 解析上面网址中含有 m3u8的链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i "https://test.test/test.m3u8" -vcodec copy -acodec copy -absf aac_adtstoasc test.mp4</span><br></pre></td></tr></table></figure><p>经过漫长的等待,终于解析成功。视频可以直接播放。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-ffmpe-下载一直播-回放视频&quot;&gt;&lt;a href=&quot;#使用-ffmpe-下载一直播-回放视频&quot; class=&quot;headerlink&quot; title=&quot;使用 ffmpe 下载一直播 回放视频&quot;&gt;&lt;/a&gt;使用 ffmpe 下载一直播 回放视频&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200218_JohnWill.jpeg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ffmpeg" scheme="https://pinghailinfeng.gitee.io/categories/ffmpeg/"/>
    
    
      <category term="ffmpeg" scheme="https://pinghailinfeng.gitee.io/tags/ffmpeg/"/>
    
      <category term="m3u8" scheme="https://pinghailinfeng.gitee.io/tags/m3u8/"/>
    
  </entry>
  
  <entry>
    <title>python standard library dbm</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/17/python-standard-library-dbm/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/17/python-standard-library-dbm/</id>
    <published>2020-02-17T03:20:01.000Z</published>
    <updated>2020-02-17T13:30:34.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-dbm"><a href="#python-标准库-dbm" class="headerlink" title="python 标准库 dbm"></a>python 标准库 dbm</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200217_haiwang.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>要使整个人生都过得舒适、愉快，这是不可能的，因为人类必须具备一种能应付逆境的态度。</p><p>​                                                                                                                                  ——卢梭</p></blockquote><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/__init__.py" target="_blank" rel="noopener">Lib/dbm/<strong>init</strong>.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm" target="_blank" rel="noopener"><code>dbm</code></a> 是一种泛用接口，针对各种 DBM 数据库 — 包括 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a>。 如果未安装这些模块中的任何一种，则将使用 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 模块中慢速但简单的实现。 还有一个适用于 Oracle Berkeley DB 的 <a href="https://www.jcea.es/programacion/pybsddb.htm" target="_blank" rel="noopener">第三方接口</a>。</p><ul><li><p><em>exception</em> <code>dbm.error</code></p><p>一个元组，其中包含每个受支持的模块可引发的异常，另外还有一个名为 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.error" target="_blank" rel="noopener"><code>dbm.error</code></a> 的特殊异常作为第一项 — 后者最在引发 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.error" target="_blank" rel="noopener"><code>dbm.error</code></a> 时被使用。</p></li><li><p><code>dbm.whichdb</code>(<em>filename</em>)</p><p>此函数会猜测各种简单数据库模块中的哪一个是可用的 — <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 还是 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> — 应该被用来打开给定的文件。返回下列值中的一个：如果文件由于不可读或不存在而无法打开则返回 <code>None</code>；如果文件的格式无法猜测则返回空字符串 (<code>&#39;&#39;</code>)；或是包含所需模块名称的字符串，例如 <code>&#39;dbm.ndbm&#39;</code> 或 <code>&#39;dbm.gnu&#39;</code>。</p></li><li><p><code>dbm.open</code>(<em>file</em>, <em>flag=’r’</em>, <em>mode=0o666</em>)</p><p>打开数据库文件 <em>file</em> 并返回一个相应的对象。如果数据库文件已存在，则使用 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.whichdb" target="_blank" rel="noopener"><code>whichdb()</code></a> 函数来确定其类型和要使用的适当模块；如果文件不存在，则会使用上述可导入模块中的第一个。可选的 <em>flag</em> 参数可以是：’’</p><p>| 值    | 意义                                     |<br>| —– | —————————————- |<br>| <code>&#39;r&#39;</code> | 以只读方式打开现有数据库（默认）         |<br>| <code>&#39;w&#39;</code> | 以读写方式打开现有数据库                 |<br>| <code>&#39;c&#39;</code> | 以读写方式打开数据库，如果不存在则创建它 |<br>| <code>&#39;n&#39;</code> | 始终创建一个新的空数据库，以读写方式打开 |</p><p>  <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.open" target="_blank" rel="noopener"><code>open()</code></a> 所返回的对象支持与字典相同的基本功能；可以存储、获取和删除键及其对应的值，并可使用 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#in" target="_blank" rel="noopener"><code>in</code></a> 运算符和 <code>keys()</code> 方法，以及 <code>get()</code> 和 <code>setdefault()</code>。</p></li></ul><p><em>在 3.2 版更改:</em> 现在 <code>get()</code> 和 <code>setdefault()</code> 在所有数据库模块中均可用。</p><p><em>在 3.8 版更改:</em> 从只读数据库中删除键将引发数据库模块专属的错误而不是 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a>。</p><p>键和值总是被存储为字节串。 这意味着当使用字符串时它们会在被存储之前隐式地转换至默认编码格式。</p><p>这些对象也支持在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中使用，当语句结束时将自动关闭它们。</p><p><em>在 3.4 版更改:</em> 向 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.open" target="_blank" rel="noopener"><code>open()</code></a> 所返回的对象添加了上下文管理协议的原生支持。</p><p>以下示例记录了一些主机名和对应的标题，随后将数据库的内容打印出来。:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dbm</span><br><span class="line"></span><br><span class="line"><span class="comment"># Open database, creating it if necessary.</span></span><br><span class="line"><span class="keyword">with</span> dbm.open(<span class="string">'cache'</span>, <span class="string">'c'</span>) <span class="keyword">as</span> db:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Record some values</span></span><br><span class="line">    db[<span class="string">b'hello'</span>] = <span class="string">b'there'</span></span><br><span class="line">    db[<span class="string">'www.python.org'</span>] = <span class="string">'Python Website'</span></span><br><span class="line">    db[<span class="string">'www.cnn.com'</span>] = <span class="string">'Cable News Network'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Note that the keys are considered bytes now.</span></span><br><span class="line">    <span class="keyword">assert</span> db[<span class="string">b'www.python.org'</span>] == <span class="string">b'Python Website'</span></span><br><span class="line">    <span class="comment"># Notice how the value is now in bytes.</span></span><br><span class="line">    <span class="keyword">assert</span> db[<span class="string">'www.cnn.com'</span>] == <span class="string">b'Cable News Network'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Often-used methods of the dict interface work too.</span></span><br><span class="line">    print(db.get(<span class="string">'python.org'</span>, <span class="string">b'not present'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Storing a non-string key or value will raise an exception (most</span></span><br><span class="line">    <span class="comment"># likely a TypeError).</span></span><br><span class="line">    db[<span class="string">'www.yahoo.com'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># db is automatically closed when leaving the with statement.</span></span><br></pre></td></tr></table></figure><blockquote><p>参见:模块 <a href="https://docs.python.org/zh-cn/3.8/library/shelve.html#module-shelve" target="_blank" rel="noopener"><code>shelve</code></a></p><p>存储非字符串数据的持久化模块。</p></blockquote><p>以下部分描述了各个单独的子模块。</p><h2 id="dbm-gnu-—-GNU-对-dbm-的重解析"><a href="#dbm-gnu-—-GNU-对-dbm-的重解析" class="headerlink" title="dbm.gnu — GNU 对 dbm 的重解析"></a><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> — GNU 对 dbm 的重解析</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/gnu.py" target="_blank" rel="noopener">Lib/dbm/gnu.py</a></p><hr><p>此模块与 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm" target="_blank" rel="noopener"><code>dbm</code></a> 模块很相似，但是改用 GNU 库 <code>gdbm</code> 来提供某些附加功能。 请注意由 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 与 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 所创建的文件格式是不兼容的。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 模块提供了对 GNU DBM 库的接口。 <code>dbm.gnu.gdbm</code> 对象的行为类似于映射（字典），区别在于其键和值总是会在存储之前被转换为字节串。 打印 <code>gdbm</code> 对象不会打印出键和值，并且 <code>items()</code> 和 <code>values()</code> 等方法也不受支持。</p><ul><li><p><em>exception</em> <code>dbm.gnu.error</code></p><p>针对 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 专属错误例如 I/O 错误引发。 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 的引发则针对一般映射错误例如指定了不正确的键。</p></li><li><p><code>dbm.gnu.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p><p>打开一个 <code>gdbm</code> 数据库并返回 <code>gdbm</code> 对象。 <em>filename</em> 参数为数据库文件名称。</p><p>可选的 <em>flag</em> 参数可以是：</p><p>| 值    | 意义                                     |<br>| —– | —————————————- |<br>| <code>&#39;r&#39;</code> | 以只读方式打开现有数据库（默认）         |<br>| <code>&#39;w&#39;</code> | 以读写方式打开现有数据库                 |<br>| <code>&#39;c&#39;</code> | 以读写方式打开数据库，如果不存在则创建它 |<br>| <code>&#39;n&#39;</code> | 始终创建一个新的空数据库，以读写方式打开 |</p><p>下列附加字符可被添加至旗标以控制数据库的打开方式：</p><p>| 值    | 意义                                         |<br>| —– | ——————————————– |<br>| <code>&#39;f&#39;</code> | 以快速模式打开数据库。写入数据库将不会同步。 |<br>| <code>&#39;s&#39;</code> | 同步模式。这将导致数据库的更改立即写入文件。 |<br>| <code>&#39;u&#39;</code> | 不要锁定数据库。                             |</p><p>不是所有旗标都可用于所有版本的 <code>gdbm</code>。 模块常量 <code>open_flags</code> 为包含受支持旗标字符的字符串。 如果指定了无效的旗标则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.gnu.error" target="_blank" rel="noopener"><code>error</code></a>。</p><p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code>。</p><p>除了与字典类似的方法，<code>gdbm</code> 对象还有以下方法：</p></li><li><p><code>gdbm.firstkey</code>()</p><p>  使用此方法和 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.gnu.gdbm.nextkey" target="_blank" rel="noopener"><code>nextkey()</code></a> 方法可以循环遍历数据库中的每个键。 遍历的顺序是按照 <code>gdbm</code> 的内部哈希值，而不会根据键的值排序。 此方法将返回起始键。</p></li><li><p><code>gdbm.nextkey</code>(<em>key</em>)</p><p>  在遍历中返回 <em>key</em> 之后的的下一个键。 以下代码将打印数据库 <code>db</code> 中的每个键，而不会在内存中创建一个包含所有键的列表:<code>k = db.firstkey() while k != None:     print(k)     k = db.nextkey(k)</code></p></li><li><p><code>gdbm.reorganize</code>()</p><p>  如果你进行了大量删除操作并且想要缩减 <code>gdbm</code> 文件所使用的空间，此例程将可重新组织数据库。 除非使用此重组功能否则 <code>gdbm</code> 对象不会缩减数据库文件大小；在其他情况下，被删除的文件空间将会保留并在添加新的 (键, 值) 对时被重用。</p></li><li><p><code>gdbm.sync</code>()</p><p>  当以快速模式打开数据库时，此方法会将任何未写入数据强制写入磁盘。</p></li><li><p><code>gdbm.close</code>()<a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.gnu.gdbm.close" target="_blank" rel="noopener">¶</a></p><p>  关闭 <code>gdbm</code> 数据库。</p></li></ul><h2 id="dbm-ndbm-—-基于-ndbm-的接口"><a href="#dbm-ndbm-—-基于-ndbm-的接口" class="headerlink" title="dbm.ndbm — 基于 ndbm 的接口"></a><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> — 基于 ndbm 的接口</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/ndbm.py" target="_blank" rel="noopener">Lib/dbm/ndbm.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 模块提供了对 Unix “(n)dbm” 库的接口。 Dbm 对象的行为类似于映射（字典），区别在于其键和值总是被存储为字节串。 打印 <code>dbm</code> 对象不会打印出键和值，并且 <code>items()</code> 和 <code>values()</code> 等方法也不受支持。</p><p>此模块可与 “经典classic” ndbm 接口或 GNU GDBM 兼容接口一同使用。 在 Unix 上，<strong>configure</strong> 脚本将尝试定位适当的头文件来简化此模块的构建。</p><ul><li><p><em>exception</em> <code>dbm.ndbm.error</code></p><p>针对 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.ndbm" target="_blank" rel="noopener"><code>dbm.ndbm</code></a> 专属错误例如 I/O 错误引发。 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 的引发则针对一般映射错误例如指定了不正确的键。</p></li><li><p><code>dbm.ndbm.library</code></p><p>所使用的 <code>ndbm</code> 实现库的名称。</p></li><li><p><code>dbm.ndbm.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p><p>打开一个 dbm 数据库并返回 <code>ndbm</code> 对象。 <em>filename</em> 参数为数据库文件名称（不带 <code>.dir</code> 或 <code>.pag</code> 扩展名）。可选的 <em>flag</em> 参数必须是下列值之一：值意义<code>&#39;r&#39;</code>以只读方式打开现有数据库（默认）<code>&#39;w&#39;</code>以读写方式打开现有数据库<code>&#39;c&#39;</code>以读写方式打开数据库，如果不存在则创建它<code>&#39;n&#39;</code>始终创建一个新的空数据库，以读写方式打开可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code> (并将被当前的 umask 所修改)。除了与字典类似的方法，<code>ndbm</code> 对象还有以下方法：<code>ndbm.close</code>()关闭 <code>ndbm</code> 数据库。</p></li></ul><h2 id="dbm-dumb-—-便携式-DBM-实现"><a href="#dbm-dumb-—-便携式-DBM-实现" class="headerlink" title="dbm.dumb — 便携式 DBM 实现"></a><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> — 便携式 DBM 实现</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/dbm/dumb.py" target="_blank" rel="noopener">Lib/dbm/dumb.py</a></p><blockquote><p>注解:<a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 模块的目的是在更健壮的模块不可用时作为 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm" target="_blank" rel="noopener"><code>dbm</code></a> 模块的最终回退项。 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 不是为高速运行而编写的，也不像其他数据库模块一样被经常使用。</p></blockquote><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 模块提供了一个完全以 Python 编写的持久化字典类接口。 不同于 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.gnu" target="_blank" rel="noopener"><code>dbm.gnu</code></a> 等其他模块，它不需要外部库。 与其他持久化映射一样，它的键和值也总是被存储为字节串。</p><p>该模块定义以下内容：</p><ul><li><p><em>exception</em> <code>dbm.dumb.error</code></p><p>针对 <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#module-dbm.dumb" target="_blank" rel="noopener"><code>dbm.dumb</code></a> 专属错误例如 I/O 错误引发。 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 的引发则针对一般映射例如指定了不正确的键。</p></li><li><p><code>dbm.dumb.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p><p>打开一个 <code>dumbdbm</code> 数据库并返回 dumbdbm 对象。 <em>filename</em> 参数为数据库文件的主名称（不带任何特定扩展名）。 创建一个 dumbdbm 数据库时将创建多个带有 <code>.dat</code> 和 <code>.dir</code> 扩展名的文件。可选的 <em>flag</em> 参数可以是：</p><p>| 值    | 意义                                     |<br>| —– | —————————————- |<br>| <code>&#39;r&#39;</code> | 以只读方式打开现有数据库（默认）         |<br>| <code>&#39;w&#39;</code> | 以读写方式打开现有数据库                 |<br>| <code>&#39;c&#39;</code> | 以读写方式打开数据库，如果不存在则创建它 |<br>| <code>&#39;n&#39;</code> | 始终创建一个新的空数据库，以读写方式打开 |</p><p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code> (并将  被当前的 umask 所修改)。</p><p><em>在 3.5 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/dbm.html#dbm.dumb.open" target="_blank" rel="noopener"><code>open()</code></a> 在 flag 值为 <code>&#39;n&#39;</code> 时将总是创建一个新的数据库。</p><p><em>在 3.8 版更改:</em> 附带 <code>&#39;r&#39;</code> 旗标打开的数据库现在将是只读的。 附带 <code>&#39;r&#39;</code> 和 <code>&#39;w&#39;</code> 旗标的打开操作不会再创建数据库。</p><p>除了 <a href="https://docs.python.org/zh-cn/3.8/library/collections.abc.html#collections.abc.MutableMapping" target="_blank" rel="noopener"><code>collections.abc.MutableMapping</code></a> 类所提供的方法，<code>dumbdbm</code> 对象还提供了以下方法：</p></li><li><p><code>dumbdbm.sync</code>()</p><p>  同步磁盘上的目录和数据文件。 此方法会由 <code>Shelve.sync()</code> 方法来调用。</p></li><li><p><code>dumbdbm.close</code>()</p><p>  关闭 <code>dumbdbm</code> 数据库。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-dbm&quot;&gt;&lt;a href=&quot;#python-标准库-dbm&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 dbm&quot;&gt;&lt;/a&gt;python 标准库 dbm&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200217_haiwang.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="dbm" scheme="https://pinghailinfeng.gitee.io/tags/dbm/"/>
    
  </entry>
  
  <entry>
    <title>python standard library marshal</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/16/python-standard-library-marshal/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/16/python-standard-library-marshal/</id>
    <published>2020-02-16T01:24:24.000Z</published>
    <updated>2020-02-17T03:27:23.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="marshal-—-内部-Python-对象序列化"><a href="#marshal-—-内部-Python-对象序列化" class="headerlink" title="marshal — 内部 Python 对象序列化"></a><code>marshal</code> — 内部 Python 对象序列化</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200216_pijitailai.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词：</p><p>否极泰来( pi ji tai lai):</p><p> 否，读如痞(pǐ)又作“否极终泰”、“否去泰来”。天地相交，因而安泰。天与地不相交，叫做否。在这种情况下，君子应该收敛自己的才华，以避免小人陷害；不可追求荣誉富贵，以避免小人嫉妒。闭塞到了极点，则转向通泰。人们将这些观点概括为否极泰来或否极终泰。原指事物发展到一定程度，就要转化到它的对立面。后常以此形容情况从坏变好。</p><p>【出典】：</p><p>  《易·泰》：“天地交，泰。”《易·否》：“天地不交，否；君子以俭德辟难，不可荣以禄。”《易·杂卦》：“否泰反其类也。”</p><p>【例句】：</p><p>  《吴越春秋·句践入臣外传》：“时过于期，否终则泰。” 唐·白居易《遣怀诗》：“乐往必悲生，泰来犹否极。” 唐·韦庄《湘中作》：“否去泰来终可待。”</p><p>【英文】</p><p> after a storm comes a calm </p><p>【反义词】</p><p>乐极生悲  after joy comes sadness </p></blockquote><p>此模块包含一此能以二进制格式来读写 Python 值的函数。 这种格式是 Python 专属的，但是独立于特定的机器架构（即你可以在一台 PC 上写入某个 Python 值，将文件传到一台 Sun 上并在那里读取它）。 这种格式的细节有意不带文档说明；它可能在不同 Python 版本中发生改变（但这种情况极少发生）。 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#id2" target="_blank" rel="noopener">1</a></p><p>这不是一个通用的“持久化”模块。 对于通用的持久化以及通过 RPC 调用传递 Python 对象，请参阅 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/shelve.html#module-shelve" target="_blank" rel="noopener"><code>shelve</code></a> 等模块。 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#module-marshal" target="_blank" rel="noopener"><code>marshal</code></a> 模块主要是为了支持读写 <code>.pyc</code> 文件形式“伪编译”代码的 Python 模块。 因此，Python 维护者保留在必要时以不向下兼容的方式修改 marshal 格式的权利。 如果你要序列化和反序列化 Python 对象，请改用 <a href="https://docs.python.org/zh-cn/3.8/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> 模块 – 其执行效率相当，版本独立性有保证，并且 pickle 还支持比 marshal 更多样的对象类型。</p><p>警告<br><a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#module-marshal" target="_blank" rel="noopener"><code>marshal</code></a> 模块对于错误或恶意构建的数据来说是不安全的。 永远不要 unmarshal 来自不受信任的或未经验证的来源的数据。</p><p>不是所有 Python 对象类型都受支持；一般来说，此模块只能写入和读取不依赖于特定 Python 调用的对象。 下列类型是受支持的：布尔值、整数、浮点数、复数、字符串、字节串、字节数组、元组、列表、集合、冻结集合、字典和代码对象，需要了解的一点是元组、列表、集合、冻结集合和字典只在其所包含的值也是这些值时才受支持。 单例对象 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#Ellipsis" target="_blank" rel="noopener"><code>Ellipsis</code></a> and <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#StopIteration" target="_blank" rel="noopener"><code>StopIteration</code></a> 也可以被 marshal 和 unmarshal。 对于 <em>version</em> 低于 3 的格式，递归列表、集合和字典无法被写入（见下文）。</p><p>有些函数可以读/写文件，还有些函数可以操作字节类对象。</p><p>这个模块定义了以下函数：</p><ul><li><p><code>marshal.dump</code>(<em>value</em>, <em>file</em>[, <em>version</em>])</p><p>向打开的文件写入值。 值必须为受支持的类型。 文件必须为可写的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a>。如果值具有（或所包含的对象具有）不受支持的类型，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> — 但是将向文件写入垃圾数据。 对象也将不能正确地通过 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#marshal.load" target="_blank" rel="noopener"><code>load()</code></a> 重新读取。<em>version</em> 参数指明 <code>dump</code> 应当使用的数据格式（见下文）。</p></li><li><p><code>marshal.load</code>(<em>file</em>)</p><p>从打开的文件读取一个值并返回。 如果读不到有效的值（例如由于数据为不同 Python 版本的不兼容 marshal 格式），则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EOFError" target="_blank" rel="noopener"><code>EOFError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 文件必须为可读的 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a>。注解 如果通过 <a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#marshal.dump" target="_blank" rel="noopener"><code>dump()</code></a> marshal 了一个包含不受支持类型的对象，<a href="https://docs.python.org/zh-cn/3.8/library/marshal.html#marshal.load" target="_blank" rel="noopener"><code>load()</code></a> 将为不可 marshal 的类型替换 <code>None</code>。</p></li><li><p><code>marshal.dumps</code>(<em>value</em>[, <em>version</em>])</p><p>返回将通过 <code>dump(value, file)</code> 被写入一个文件的字节串对象。 值必须属于受支持的类型。 如果值属于（或包含的对象属于）不受支持的类型则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a>。<em>version</em> 参数指明 <code>dumps</code> 应当使用的数据类型（见下文）。</p></li><li><p><code>marshal.loads</code>(<em>bytes</em>)</p><p>将 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a> 转换为一个值。 如果找不到有效的值，则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#EOFError" target="_blank" rel="noopener"><code>EOFError</code></a>, <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。 输入的额外字节串会被忽略。</p></li></ul><p>此外，还定义了以下常量：</p><ul><li><p><code>marshal.version</code></p><p>指明模块所使用的格式。 第 0 版为历史格式，第 1 版为共享固化的字符串，第 2 版对浮点数使用二进制格式。 第 3 版添加了对于对象实例化和递归的支持。 目前使用的为第 4 版。</p></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> marshal</span><br><span class="line">data1 = [<span class="string">'abc'</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="string">'jb51'</span>]  <span class="comment">#几个测试数据</span></span><br><span class="line">data2 = &#123;<span class="number">1</span>:<span class="string">'aaa'</span>,<span class="string">"b"</span>:<span class="string">'dad'</span>&#125;</span><br><span class="line">data3 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">output_file = open(<span class="string">"a.txt"</span>,<span class="string">'wb'</span>)<span class="comment">#把这些数据序列化到文件中，注：文件必须以二进制模式打开</span></span><br><span class="line">marshal.dump(data1,output_file)</span><br><span class="line">marshal.dump(data2,output_file)</span><br><span class="line">marshal.dump(data3,output_file)</span><br><span class="line">output_file.close()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">input_file = open(<span class="string">'a.txt'</span>,<span class="string">'rb'</span>)<span class="comment">#从文件中读取序列化的数据</span></span><br><span class="line"><span class="comment">#data1 = []</span></span><br><span class="line">data1 = marshal.load(input_file)</span><br><span class="line">data2 = marshal.load(input_file)</span><br><span class="line">data3 = marshal.load(input_file)</span><br><span class="line"><span class="keyword">print</span> data1<span class="comment">#给同志们打印出结果看看</span></span><br><span class="line"><span class="keyword">print</span> data2</span><br><span class="line"><span class="keyword">print</span> data3</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">outstring = marshal.dumps(data1)<span class="comment">#marshal.dumps()返回是一个字节串，该字节串用于写入文件</span></span><br><span class="line">open(<span class="string">'out.txt'</span>,<span class="string">'wb'</span>).write(outstring)</span><br><span class="line"> </span><br><span class="line">file_data = open(<span class="string">'out.txt'</span>,<span class="string">'rb'</span>).read()</span><br><span class="line">real_data = marshal.loads(file_data)</span><br><span class="line">print(real_data)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;marshal-—-内部-Python-对象序列化&quot;&gt;&lt;a href=&quot;#marshal-—-内部-Python-对象序列化&quot; class=&quot;headerlink&quot; title=&quot;marshal — 内部 Python 对象序列化&quot;&gt;&lt;/a&gt;&lt;code&gt;marshal&lt;/code&gt; — 内部 Python 对象序列化&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200216_pijitailai.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python standard library os.path</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/15/python-standard-library-os-path/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/15/python-standard-library-os-path/</id>
    <published>2020-02-14T23:50:49.000Z</published>
    <updated>2020-02-17T13:18:03.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-os-path"><a href="#python-标准库-os-path" class="headerlink" title="python 标准库 os.path"></a>python 标准库 os.path</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200215_nixingzhe.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>每日一词</p><p> retrograde  [ˈrɛtrəɡreɪd] </p><p>v   directed or moving backwards. </p><p>n retrograder 逆行者</p><ol><li><p>倒行；不按正常方向行进。《孟子·滕文公下》：“当 尧 之时，水<a href="https://cidian.911cha.com/MjA1MXc=.html" target="_blank" rel="noopener">逆行</a>，氾滥於中国。”《史记·孝景本纪》：“彗星出东北。秋， 衡山 雨雹，大者五寸，深者二尺。荧惑<a href="https://cidian.911cha.com/MjA1MXc=.html" target="_blank" rel="noopener">逆行</a>，守北辰。”《后汉书·杨震传》：“ 丰 等闻，惶怖，会太史言星变<a href="https://cidian.911cha.com/MjA1MXc=.html" target="_blank" rel="noopener">逆行</a>，遂共譖 震 。”</p></li><li><p>指逆流而行。 </p></li></ol></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/posixpath.py" target="_blank" rel="noopener">Lib/posixpath.py</a> （用于 POSIX）和 <a href="https://github.com/python/cpython/tree/3.8/Lib/ntpath.py" target="_blank" rel="noopener">Lib/ntpath.py</a> （用于 Windows NT）</p><hr><p>该模块在路径名上实现了一些有用的功能：如需读取或写入文件，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> ；有关访问文件系统的信息，请参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#module-os" target="_blank" rel="noopener"><code>os</code></a> 模块。路径参数可以字符串或字节形式传递。我们鼓励应用程序将文件名表示为（Unicode）字符串。不幸的是，某些文件名在Unix上可能无法用字符串表示，因此在Unix上平台上需要支持任意文件名的应用程序，应使用字节对象来表示路径名。反之亦然，在Windows平台上仅使用字节对象，不能表示的所有文件名（以标准 <code>mbcs</code> 编码），因此Windows应用程序应使用字符串对象来访问所有文件。</p><p>与unix shell不同，Python不执行任何 <em>自动</em> 路径扩展。当应用程序需要类似shell的路径扩展时，可以显式调用诸如 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.expanduser" target="_blank" rel="noopener"><code>expanduser()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.expandvars" target="_blank" rel="noopener"><code>expandvars()</code></a> 之类的函数。 （另请参见 <a href="https://docs.python.org/zh-cn/3.8/library/glob.html#module-glob" target="_blank" rel="noopener"><code>glob</code></a> 模块。）</p><blockquote><p>参见 <a href="https://docs.python.org/zh-cn/3.8/library/pathlib.html#module-pathlib" target="_blank" rel="noopener"><code>pathlib</code></a> 模块提供高级路径对象。</p></blockquote><blockquote><p>所有这些函数都仅接受字节或字符串对象作为其参数。如果返回路径或文件名，则结果是相同类型的对象。</p></blockquote><blockquote><p>由于不同的操作系统具有不同的路径名称约定，因此标准库中有此模块的几个版本。<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#module-os.path" target="_blank" rel="noopener"><code>os.path</code></a> 模块始终是适合 Python 运行的操作系统的路径模块，因此可用于本地路径。但是，如果操作的路径 <em>总是</em> 以一种不同的格式显示，那么也可以分别导入和使用各个模块。它们都具有相同的接口：</p><ul><li><code>posixpath</code> 用于Unix 样式的路径</li><li><code>ntpath</code> 用于 Windows 路径</li></ul></blockquote><p><em>在 3.8 版更改:</em> <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>exists()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.lexists" target="_blank" rel="noopener"><code>lexists()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isdir" target="_blank" rel="noopener"><code>isdir()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isfile" target="_blank" rel="noopener"><code>isfile()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>islink()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.ismount" target="_blank" rel="noopener"><code>ismount()</code></a> 现在遇到系统层面上不可表示的字符或字节的路径时，会返回 <code>False</code>，而不是抛出异常。</p><ul><li><p><code>os.path.abspath</code>(<em>path</em>)</p><p>返回路径 <em>path</em> 的绝对路径（标准化的）。在大多数平台上，这等同于用 <code>normpath(join(os.getcwd(), path))</code> 的方式调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.normpath" target="_blank" rel="noopener"><code>normpath()</code></a> 函数。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.basename</code>(<em>path</em>)</p><p>返回路径 <em>path</em> 的基本名称。这是将 <em>path</em> 传入函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.split" target="_blank" rel="noopener"><code>split()</code></a> 之后，返回的一对值中的第二个元素。请注意，此函数的结果与Unix <strong>basename</strong> 程序不同。<strong>basename</strong> 在 <code>&#39;/foo/bar/&#39;</code> 上返回 <code>&#39;bar&#39;</code>，而 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.basename" target="_blank" rel="noopener"><code>basename()</code></a> 函数返回一个空字符串 (<code>&#39;&#39;</code>)。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.commonpath</code>(<em>paths</em>)</p><p>接受包含多个路径的序列 <em>paths</em>，返回 <em>paths</em> 的最长公共子路径。如果 <em>paths</em> 同时包含绝对路径和相对路径，或 <em>paths</em> 在不同的驱动器上，或 <em>paths</em> 为空，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ValueError" target="_blank" rel="noopener"><code>ValueError</code></a> 异常。与 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.commonprefix" target="_blank" rel="noopener"><code>commonprefix()</code></a> 不同，本方法返回有效路径。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>3.5 新版功能.**在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 序列。</p></li><li><p><code>os.path.commonprefix</code>(<em>list</em>)</p><p>接受包含多个路径的 <em>列表</em>，返回所有路径的最长公共前缀（逐字符比较）。如果 <em>列表</em> 为空，则返回空字符串 (<code>&#39;&#39;</code>)。</p><p>此函数是逐字符比较，因此可能返回无效路径。要获取有效路径，参见 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.commonpath" target="_blank" rel="noopener"><code>commonpath()</code></a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.commonprefix([<span class="string">'/usr/lib'</span>, <span class="string">'/usr/local/lib'</span>])</span><br><span class="line"><span class="string">'/usr/l'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.commonpath([<span class="string">'/usr/lib'</span>, <span class="string">'/usr/local/lib'</span>])</span><br><span class="line"><span class="string">'/usr'</span></span><br></pre></td></tr></table></figure><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.dirname</code>(<em>path</em>)</p><p>返回路径 <em>path</em> 的目录名称。这是将 <em>path</em> 传入函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.split" target="_blank" rel="noopener"><code>split()</code></a> 之后，返回的一对值中的第一个元素。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.exists</code>(<em>path</em>)</p><p>如果 <em>path</em> 指向一个已存在的路径或已打开的文件描述符，返回 <code>True</code>。对于失效的符号链接，返回 <code>False</code>。在某些平台上，如果使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 查询到目标文件没有执行权限，即使 <em>path</em> 确实存在，本函数也可能返回 <code>False</code>。<em>在 3.3 版更改:</em> <em>path</em> 现在可以是一个整数：如果该整数是一个已打开的文件描述符，返回 <code>True</code>，否则返回 <code>False</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.lexists</code>(<em>path</em>)</p><p>如果 <em>path</em> 指向一个已存在的路径，返回 <code>True</code>。对于失效的符号链接，也返回 <code>True</code>。在缺失 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>os.lstat()</code></a> 的平台上等同于 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>exists()</code></a>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.expanduser</code>(<em>path</em>)</p><p>在 Unix 和 Windows 上，将参数中开头部分的 <code>~</code> 或 <code>~user</code> 替换为当前 <em>用户</em> 的家目录并返回。在 Unix 上，开头的 <code>~</code> 会被环境变量 <code>HOME</code> 代替，如果变量未设置，则通过内置模块 <a href="https://docs.python.org/zh-cn/3.8/library/pwd.html#module-pwd" target="_blank" rel="noopener"><code>pwd</code></a> 在 password 目录中查找当前用户的主目录。以 <code>~user</code> 开头则直接在 password 目录中查找。在 Windows 上，如果设置了 <code>USERPROFILE</code>，就使用这个变量，否则会将 <code>HOMEPATH</code> 和 <code>HOMEDRIVE</code> 结合在一起使用。以 <code>~user</code> 开头则将上述方法生成路径的最后一截目录替换成 user。如果展开路径失败，或者路径不是以波浪号开头，则路径将保持不变。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>在 3.8 版更改:</em> Windows 不再使用 <code>HOME</code>。</p></li><li><p><code>os.path.expandvars</code>(<em>path</em>)</p><p>输入带有环境变量的路径作为参数，返回展开变量以后的路径。<code>$name</code> 或 <code>${name}</code> 形式的子字符串被环境变量 <em>name</em> 的值替换。格式错误的变量名称和对不存在变量的引用保持不变。在 Windows 上，除了 <code>$name</code> 和 <code>${name}</code> 外，还可以展开 <code>%name%</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.getatime</code>(<em>path</em>)</p><p>返回 <em>path</em> 的最后访问时间。返回值是一个浮点数，为纪元秒数（参见 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块）。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p></li><li><p><code>os.path.getmtime</code>(<em>path</em>)</p><p>返回 <em>path</em> 的最后修改时间。返回值是一个浮点数，为纪元秒数（参见 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块）。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.getctime</code>(<em>path</em>)</p><p>返回 <em>path</em> 在系统中的 ctime，在有些系统（比如 Unix）上，它是元数据的最后修改时间，其他系统（比如 Windows）上，它是 <em>path</em> 的创建时间。返回值是一个数，为纪元秒数（参见 <a href="https://docs.python.org/zh-cn/3.8/library/time.html#module-time" target="_blank" rel="noopener"><code>time</code></a> 模块）。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.getsize</code>(<em>path</em>)</p><p>返回 <em>path</em> 的大小，以字节为单位。如果该文件不存在或不可访问，则抛出 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#OSError" target="_blank" rel="noopener"><code>OSError</code></a> 异常。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.isabs</code>(<em>path</em>)</p><p>如果 <em>path</em> 是一个绝对路径，则返回 <code>True</code>。在 Unix 上，它就是以斜杠开头，而在 Windows 上，它可以是去掉驱动器号后以斜杠（或反斜杠）开头。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.isfile</code>(<em>path</em>)</p><p>如果 <em>path</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>现有的</code></a> 常规文件，则返回 <code>True</code>。本方法会跟踪符号链接，因此，对于同一路径，<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>islink()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isfile" target="_blank" rel="noopener"><code>isfile()</code></a> 都可能为 <code>True</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.isdir</code>(<em>path</em>)</p><p>如果 <em>path</em> 是 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>现有的</code></a> 目录，则返回 <code>True</code>。本方法会跟踪符号链接，因此，对于同一路径，<a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.islink" target="_blank" rel="noopener"><code>islink()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.isdir" target="_blank" rel="noopener"><code>isdir()</code></a> 都可能为 <code>True</code>。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.islink</code>(<em>path</em>)</p><p>如果 <em>path</em> 指向的 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.exists" target="_blank" rel="noopener"><code>现有</code></a> 目录条目是一个符号链接，则返回 <code>True</code>。如果 Python 运行时不支持符号链接，则总是返回 <code>False</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.ismount</code>(<em>path</em>)</p><p>如果路径 <em>path</em> 是 <em>挂载点</em> （文件系统中挂载其他文件系统的点），则返回 <code>True</code>。在 POSIX 上，该函数检查 <em>path</em> 的父目录 <code>*path*/..</code> 是否在与 <em>path</em> 不同的设备上，或者 <code>*path*/..</code> 和 <em>path</em> 是否指向同一设备上的同一 inode（这一检测挂载点的方法适用于所有 Unix 和 POSIX 变体）。本方法不能可靠地检测同一文件系统上的绑定挂载 (bind mount)。在 Windows 上，盘符和共享 UNC 始终是挂载点，对于任何其他路径，将调用 <code>GetVolumePathName</code> 来查看它是否与输入的路径不同。<em>3.4 新版功能:</em> 支持在 Windows 上检测非根挂载点。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.join</code>(<em>path</em>, *<em>paths</em>)</p><p>合理地拼接一个或多个路径部分。返回值是 <em>path</em> 和 *<em>paths</em> 所有值的连接，每个非空部分后面都紧跟一个目录分隔符 (<code>os.sep</code>)，除了最后一部分。这意味着如果最后一部分为空，则结果将以分隔符结尾。如果参数中某个部分是绝对路径，则绝对路径前的路径都将被丢弃，并从绝对路径部分开始连接。在 Windows 上，遇到绝对路径部分（例如 <code>r&#39;\foo&#39;</code>）时，不会重置盘符。如果某部分路径包含盘符，则会丢弃所有先前的部分，并重置盘符。请注意，由于每个驱动器都有一个“当前目录”，所以 <code>os.path.join(&quot;c:&quot;, &quot;foo&quot;)</code> 表示驱动器 <code>C:</code> 上当前目录的相对路径 (<code>c:foo</code>)，而不是 <code>c:\foo</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a> 用于 <em>path</em> 和 <em>paths</em> 。</p></li><li><p><code>os.path.normcase</code>(<em>path</em>)</p><p>规范路径的大小写。在 Windows 上，将路径中的所有字符都转换为小写，并将正斜杠转换为反斜杠。在其他操作系统上返回原路径。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.normpath</code>(<em>path</em>)</p><p>通过折叠多余的分隔符和对上级目录的引用来标准化路径名，所以 <code>A//B</code>、<code>A/B/</code>、<code>A/./B</code> 和 <code>A/foo/../B</code> 都会转换成 <code>A/B</code>。这个字符串操作可能会改变带有符号链接的路径的含义。在 Windows 上，本方法将正斜杠转换为反斜杠。要规范大小写，请使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.normcase" target="_blank" rel="noopener"><code>normcase()</code></a>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.realpath</code>(<em>path</em>)</p><p>返回指定文件的规范路径，消除路径中存在的任何符号链接（如果操作系统支持）。注解 当发生符号链接循环时，返回的路径将是该循环的某个组成部分，但不能保证是哪个部分。<em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p><p><em>在 3.8 版更改:</em> 在 Windows 上现在可以正确解析符号链接和交接点 (junction point)。</p></li><li><p><code>os.path.relpath</code>(<em>path</em>, <em>start=os.curdir</em>)</p><p>返回从当前目录或 <em>start</em> 目录（可选）到达 <em>path</em> 之间要经过的相对路径。这仅仅是对路径的计算，不会访问文件系统来确认 <em>path</em> 或 <em>start</em> 的存在性或属性。<em>start</em> 默认为 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.curdir" target="_blank" rel="noopener"><code>os.curdir</code></a>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.samefile</code>(<em>path1</em>, <em>path2</em>)</p><p>如果两个路径都指向相同的文件或目录，则返回 <code>True</code>。这由设备号和 inode 号确定，在任一路径上调用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 失败则抛出异常。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加了 Windows 支持。<em>在 3.4 版更改:</em> Windows现在使用与其他所有平台相同的实现。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.sameopenfile</code>(<em>fp1</em>, <em>fp2</em>)</p><p>如果文件描述符 <em>fp1</em> 和 <em>fp2</em> 指向相同文件，则返回 <code>True</code>。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.2 版更改:</em> 添加了 Windows 支持。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.samestat</code>(<em>stat1</em>, <em>stat2</em>)</p><p>如果 stat 元组 <em>stat1</em> 和 <em>stat2</em> 指向相同文件，则返回 <code>True</code>。这些 stat 元组可能是由 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.fstat" target="_blank" rel="noopener"><code>os.fstat()</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.lstat" target="_blank" rel="noopener"><code>os.lstat()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.stat" target="_blank" rel="noopener"><code>os.stat()</code></a> 返回的。本函数实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.samefile" target="_blank" rel="noopener"><code>samefile()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.sameopenfile" target="_blank" rel="noopener"><code>sameopenfile()</code></a> 底层所使用的比较过程。<a href="https://docs.python.org/zh-cn/3.8/library/intro.html#availability" target="_blank" rel="noopener">可用性</a>: Unix, Windows。<em>在 3.4 版更改:</em> 添加了 Windows 支持。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.split</code>(<em>path</em>)</p><p>将路径 <em>path</em> 拆分为一对，即 <code>(head, tail)</code>，其中，<em>tail</em> 是路径的最后一部分，而 <em>head</em> 里是除最后部分外的所有内容。<em>tail</em> 部分不会包含斜杠，如果 <em>path</em> 以斜杠结尾，则 <em>tail</em> 将为空。如果 <em>path</em> 中没有斜杠，<em>head</em> 将为空。如果 <em>path</em> 为空，则 <em>head</em> 和 <em>tail</em> 均为空。<em>head</em> 末尾的斜杠会被去掉，除非它是根目录（即它仅包含一个或多个斜杠）。在所有情况下，<code>join(head, tail)</code> 指向的位置都与 <em>path</em> 相同（但字符串可能不同）。另请参见函数 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.dirname" target="_blank" rel="noopener"><code>dirname()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/os.path.html#os.path.basename" target="_blank" rel="noopener"><code>basename()</code></a>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.splitdrive</code>(<em>path</em>)</p><p>将路径 <em>path</em> 拆分为一对，即 <code>(drive, tail)</code>，其中 <em>drive</em> 是挂载点或空字符串。在没有驱动器概念的系统上，<em>drive</em> 将始终为空字符串。在所有情况下，<code>drive + tail</code> 都与 <em>path</em> 相同。在 Windows 上，本方法将路径拆分为驱动器/UNC 根节点和相对路径。如果路径 path 包含盘符，则 drive 将包含冒号及冒号前面的所有内容。例如 <code>splitdrive(&quot;c:/dir&quot;)</code> 返回 <code>(&quot;c:&quot;, &quot;/dir&quot;)</code>。如果 path 是一个 UNC 路径，则 drive 将包含主机名和共享点，但不包括第四个分隔符。例如 <code>splitdrive(&quot;//host/computer/dir&quot;)</code> 返回 <code>(&quot;//host/computer&quot;, &quot;/dir&quot;)</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.splitext</code>(<em>path</em>)</p><p>将路径 <em>path</em> 拆分为一对，即 <code>(root, ext)</code>，使 <code>root + ext == path</code>，其中 <em>ext</em> 为空或以英文句点开头，且最多包含一个句点。路径前的句点将被忽略，例如 <code>splitext(&#39;.cshrc&#39;)</code> 返回 <code>(&#39;.cshrc&#39;, &#39;&#39;)</code>。</p><p><em>在 3.6 版更改:</em> 接受一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">类路径对象</a>。</p></li><li><p><code>os.path.supports_unicode_filenames</code></p><p>如果（在文件系统限制下）允许将任意 Unicode 字符串用作文件名，则为 <code>True</code>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-os-path&quot;&gt;&lt;a href=&quot;#python-标准库-os-path&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 os.path&quot;&gt;&lt;/a&gt;python 标准库 os.path&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200215_nixingzhe.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="os.path" scheme="https://pinghailinfeng.gitee.io/tags/os-path/"/>
    
  </entry>
  
  <entry>
    <title>python standard library linecache</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/14/python-standard-library-linecache/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/14/python-standard-library-linecache/</id>
    <published>2020-02-14T12:20:03.000Z</published>
    <updated>2020-02-17T03:27:23.923Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200214_valentines.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>情人节快乐，愿有情人终成眷属!</p></blockquote><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/linecache.py" target="_blank" rel="noopener">Lib/linecache.py</a></p><hr><p><a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#module-linecache" target="_blank" rel="noopener"><code>linecache</code></a> 模块允许从一个 Python 源文件中获取任意的行，并会尝试使用缓存进行内部优化，常应用于从单个文件读取多行的场合。 此模块被 <a href="https://docs.python.org/zh-cn/3.8/library/traceback.html#module-traceback" target="_blank" rel="noopener"><code>traceback</code></a> 模块用来提取源码行以便包含在格式化的回溯中。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/tokenize.html#tokenize.open" target="_blank" rel="noopener"><code>tokenize.open()</code></a> 函数被用于打开文件。 此函数使用 <a href="https://docs.python.org/zh-cn/3.8/library/tokenize.html#tokenize.detect_encoding" target="_blank" rel="noopener"><code>tokenize.detect_encoding()</code></a> 来获取文件的编码格式；如果未指明编码格式，则默认编码为 UTF-8。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#module-linecache" target="_blank" rel="noopener"><code>linecache</code></a> 模块定义了下列函数：</p><ul><li><p><code>linecache.getline</code>(<em>filename</em>, <em>lineno</em>, <em>module_globals=None</em>)</p><p>从名为 <em>filename</em> 的文件中获取 <em>lineno</em> 行，此函数绝不会引发异常 — 出现错误时它将返回 <code>&#39;&#39;</code> (所有找到的行都将包含换行符作为结束)。如果找不到名为 <em>filename</em> 的文件，此函数会先在 <em>module_globals</em> 中检查 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a> <code>__loader__</code>。 如果存在这样的加载器并且它定义了 <code>get_source</code> 方法，则由该方法来确定源行 (如果 <code>get_source()</code> 返回 <code>None</code>，则该函数返回 <code>&#39;&#39;</code>)。 最后，如果 <em>filename</em> 是一个相对路径文件名，则它会在模块搜索路径 <code>sys.path</code> 中按条目的相对位置进行查找。</p></li><li><p><code>linecache.clearcache</code>()</p><p>清空缓存。 如果你不再需要之前使用 <a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#linecache.getline" target="_blank" rel="noopener"><code>getline()</code></a> 从文件读取的行即可使用此函数。</p></li><li><p><code>linecache.checkcache</code>(<em>filename=None</em>)</p><p>检查缓存有效性。 如果缓存中的文件在磁盘上发生了改变，而你需要更新后的版本即可使用此函数。 如果省略了 <em>filename</em>，它会检查缓存中的所有条目。</p></li><li><p><code>linecache.lazycache</code>(<em>filename</em>, <em>module_globals</em>)</p><p>捕获有关某个非基于文件的模块的足够细节信息，以允许稍后再通过 <a href="https://docs.python.org/zh-cn/3.8/library/linecache.html#linecache.getline" target="_blank" rel="noopener"><code>getline()</code></a> 来获取其中的行，即使当稍后调用时 <em>module_globals</em> 为 <code>None</code>。 这可以避免在实际需要读取行之前执行 I/O，也不必始终保持模块全局变量。<em>3.5 新版功能.</em></p></li></ul><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> linecache</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>linecache.getline(linecache.__file__, <span class="number">8</span>)</span><br><span class="line"><span class="string">'import sys\n'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> linecache</span><br><span class="line"><span class="comment">## 获取指定前四条数据</span></span><br><span class="line">a = linecache.getlines(<span class="string">'aa.txt'</span>)[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">## 获取第四条数据</span></span><br><span class="line">a = linecache.getline(<span class="string">'aa.txt'</span>,<span class="number">4</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200214_valentines.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="linecache" scheme="https://pinghailinfeng.gitee.io/tags/linecache/"/>
    
  </entry>
  
  <entry>
    <title>python standard library tempfile</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/13/python-standard-library-tempfile/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/13/python-standard-library-tempfile/</id>
    <published>2020-02-13T09:17:49.000Z</published>
    <updated>2020-02-17T03:27:23.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-tempfile"><a href="#python-标准库-tempfile" class="headerlink" title="python 标准库 tempfile"></a>python 标准库 tempfile</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200213_car.jpeg?raw=true" alt></p><a id="more"></a><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/tempfile.py" target="_blank" rel="noopener">Lib/tempfile.py</a></p><hr><p>该模块用于创建临时文件和目录，它可以跨平台使用。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.NamedTemporaryFile" target="_blank" rel="noopener"><code>NamedTemporaryFile</code></a>、<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryDirectory" target="_blank" rel="noopener"><code>TemporaryDirectory</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.SpooledTemporaryFile" target="_blank" rel="noopener"><code>SpooledTemporaryFile</code></a> 是带有自动清理功能的高级接口，可用作上下文管理器。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 是低级函数，使用完毕需手动清理。</p><p>所有由用户调用的函数和构造函数都带有参数，这些参数可以设置临时文件和临时目录的路径和名称。该模块生成的文件名包括一串随机字符，在公共的临时目录中，这些字符可以让创建文件更加安全。为了保持向后兼容性，参数的顺序有些奇怪。所以为了代码清晰，建议使用关键字参数。</p><p>这个模块定义了以下内容供用户调用：</p><ul><li><p><code>tempfile.TemporaryFile</code>(<em>mode=’w+b’</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>**, </em>errors=None*)</p><p>返回一个 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-like-object" target="_blank" rel="noopener">file-like object</a> （文件类对象）作为临时存储区域。创建该文件使用了与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 相同的安全规则。它将在关闭后立即销毁（包括垃圾回收机制关闭该对象时）。在 Unix 下，该文件在目录中的条目根本不创建，或者创建文件后立即就被删除了，其他平台不支持此功能。您的代码不应依赖使用此功能创建的临时文件名称，因为它在文件系统中的名称可能是可见的，也可能是不可见的。</p><p>生成的对象可以用作上下文管理器（参见 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile-examples" target="_blank" rel="noopener">示例</a>）。完成上下文或销毁临时文件对象后，临时文件将从文件系统中删除。</p><p><em>mode</em> 参数默认值为 <code>&#39;w+b&#39;</code>，所以创建的文件不用关闭，就可以读取或写入。因为用的是二进制模式，所以无论存的是什么数据，它在所有平台上都表现一致。<em>buffering</em>、<em>encoding</em>、<em>errors</em> 和 <em>newline</em> 的含义与 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a> 中的相同。</p><p>参数 <em>dir</em>、<em>prefix</em> 和 <em>suffix</em> 的含义和默认值都与它们在 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 中的相同。</p><p>在 POSIX 平台上，它返回的对象是真实的文件对象。在其他平台上，它是一个文件类对象 (file-like object)，它的 <code>file</code> 属性是底层的真实文件对象。</p><p>如果可用，则使用 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_TMPFILE" target="_blank" rel="noopener"><code>os.O_TMPFILE</code></a> 标志（仅限于 Linux，需要 3.11 及更高版本的内核）。</p><p>引发一个 <code>tempfile.mkstemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>在 3.5 版更改:</em> 如果可用，现在用的是 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_TMPFILE" target="_blank" rel="noopener"><code>os.O_TMPFILE</code></a> 标志。</p><p><em>在 3.8 版更改:</em> 添加了 <em>errors</em> 参数。</p></li><li><p><code>tempfile.NamedTemporaryFile</code>(<em>mode=’w+b’</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>delete=True</em>, <em>**, </em>errors=None*) </p><p>此函数执行的操作与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 完全相同，但确保了该临时文件在文件系统中具有可见的名称（在 Unix 上表现为目录条目不取消链接）。从返回的文件类对象的 <code>name</code> 属性中可以检索到文件名。在临时文件仍打开时，是否允许用文件名第二次打开文件，在各个平台上是不同的（在 Unix 上可以，但在 Windows NT 或更高版本上不行）。如果 <em>delete</em> 为 true（默认值），则文件会在关闭后立即被删除。该函数返回的对象始终是文件类对象 (file-like object)，它的 <code>file</code> 属性是底层的真实文件对象。文件类对象可以像普通文件一样在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中使用。</p><p>引发一个 <code>tempfile.mkstemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>在 3.8 版更改:</em> 添加了 <em>errors</em> 参数。</p></li><li><p><code>tempfile.SpooledTemporaryFile</code>(<em>max_size=0</em>, <em>mode=’w+b’</em>, <em>buffering=None</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>**, </em>errors=None*) </p><p>此函数执行的操作与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 完全相同，但会将数据缓存在内存中，直到文件大小超过 <em>max_size</em>，或调用文件的 <code>fileno()</code> 方法为止，此时数据会被写入磁盘，并且写入操作与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 相同。</p><p>此函数生成的文件对象有一个额外的方法——<code>rollover()</code>，可以忽略文件大小，让文件立即写入磁盘。</p><p>返回的对象是文件类对象 (file-like object)，它的 <code>_file</code> 属性是 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.BytesIO" target="_blank" rel="noopener"><code>io.BytesIO</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/io.html#io.TextIOWrapper" target="_blank" rel="noopener"><code>io.TextIOWrapper</code></a> 对象（取决于指定的是二进制模式还是文本模式）或真实的文件对象（取决于是否已调用 <code>rollover()</code>）。文件类对象可以像普通文件一样在 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中使用。</p><p><em>在 3.3 版更改:</em> 现在，文件的 truncate 方法可接受一个 <code>size</code> 参数。</p><p><em>在 3.8 版更改:</em> 添加了 <em>errors</em> 参数。</p></li><li><p><code>tempfile.TemporaryDirectory</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>) </p><p>此函数会安全地创建一个临时目录，且使用与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 相同的规则。此函数返回的对象可用作上下文管理器（参见 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile-examples" target="_blank" rel="noopener">示例</a>）。完成上下文或销毁临时目录对象后，新创建的临时目录及其所有内容将从文件系统中删除。</p><p>可以从返回对象的 <code>name</code> 属性中找到临时目录的名称。当返回的对象用作上下文管理器时，这个 <code>name</code> 会作为 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> 语句中 <code>as</code> 子句的目标（如果有 as 的话）。</p><p>可以调用 <code>cleanup()</code> 方法来手动清理目录。</p><p>引发一个 <code>tempfile.mkdtemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>3.2 新版功能.</em></p></li><li><p><code>tempfile.mkstemp</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>text=False</em>) </p><p>以最安全的方式创建一个临时文件。假设所在平台正确实现了 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 的 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.O_EXCL" target="_blank" rel="noopener"><code>os.O_EXCL</code></a> 标志，则创建文件时不会有竞争的情况。该文件只能由创建者读写，如果所在平台用权限位来标记文件是否可执行，那么没有人有执行权。文件描述符不会过继给子进程。</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.TemporaryFile" target="_blank" rel="noopener"><code>TemporaryFile()</code></a> 不同，<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 用户用完临时文件后需要自行将其删除。</p><p>如果 <em>suffix</em> 不是 <code>None</code> 则文件名将以该后缀结尾，是 <code>None</code> 则没有后缀。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 不会在文件名和后缀之间加点，如果需要加一个点号，请将其放在 <em>suffix</em> 的开头。</p><p>如果 <em>prefix</em> 不是 <code>None</code>，则文件名将以该前缀开头，是 <code>None</code> 则使用默认前缀。默认前缀是 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefix" target="_blank" rel="noopener"><code>gettempprefix()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefixb" target="_blank" rel="noopener"><code>gettempprefixb()</code></a> 函数的返回值（自动调用合适的函数）。</p><p>如果 <em>dir</em> 不为 <code>None</code>，则在指定的目录创建文件，是 <code>None</code> 则使用默认目录。默认目录是从一个列表中选择出来的，这个列表不同平台不一样，但是用户可以设置 <em>TMPDIR</em>、<em>TEMP</em> 或 <em>TMP</em> 环境变量来设置目录的位置。因此，不能保证生成的临时文件路径很规范，比如，通过 <code>os.popen()</code> 将路径传递给外部命令时仍需要加引号。</p><p>如果 <em>suffix</em>、<em>prefix</em> 和 <em>dir</em> 中的任何一个不是 <code>None</code>，就要保证它们是同一数据类型。如果它们是 bytes，则返回的名称的类型就是 bytes 而不是 str。如果确实要用默认参数，但又想要返回值是 bytes 类型，请传入 <code>suffix=b&#39;&#39;</code>。</p><p>如果指定了 <em>text</em> 参数，它表示的是以二进制模式（默认）还是文本模式打开文件。在某些平台上，两种模式没有区别。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 返回一个元组，元组中第一个元素是句柄，它是一个系统级句柄，指向一个打开的文件（等同于 <a href="https://docs.python.org/zh-cn/3.8/library/os.html#os.open" target="_blank" rel="noopener"><code>os.open()</code></a> 的返回值），第二元素是该文件的绝对路径。</p><p>引发一个 <code>tempfile.mkstemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>在 3.5 版更改:</em> 现在，<em>suffix</em>、<em>prefix</em> 和 <em>dir</em> 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 str。<em>suffix</em> 和 <em>prefix</em> 现在可以接受 <code>None</code>，并且默认为 <code>None</code> 以使用合适的默认值。</p><p><em>在 3.6 版更改:</em> <em>dir</em> 参数现在可接受一个路径类对象 (<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a>)。</p></li><li><p><code>tempfile.mkdtemp</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>) </p><p>以最安全的方式创建一个临时目录，创建该目录时不会有竞争的情况。该目录只能由创建者读取、写入和搜索。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 用户用完临时目录后需要自行将其删除。</p><p><em>prefix</em>、<em>suffix</em> 和 <em>dir</em> 的含义与它们在 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 中的相同。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkdtemp" target="_blank" rel="noopener"><code>mkdtemp()</code></a> 返回新目录的绝对路径。</p><p>引发一个 <code>tempfile.mkdtemp</code> <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#auditing" target="_blank" rel="noopener">审计事件</a>，附带参数 <code>fullpath</code>。</p><p><em>在 3.5 版更改:</em> 现在，<em>suffix</em>、<em>prefix</em> 和 <em>dir</em> 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 str。<em>suffix</em> 和 <em>prefix</em> 现在可以接受 <code>None</code>，并且默认为 <code>None</code> 以使用合适的默认值。</p><p><em>在 3.6 版更改:</em> <em>dir</em> 参数现在可接受一个路径类对象 (<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-path-like-object" target="_blank" rel="noopener">path-like object</a>)。</p></li><li><p><code>tempfile.gettempdir</code>() </p><p>返回放置临时文件的目录的名称。这个方法的返回值就是本模块所有函数的 <em>dir</em> 参数的默认值。</p><p>Python 搜索标准目录列表，以找到调用者可以在其中创建文件的目录。这个列表是：</p><ol><li><code>TMPDIR</code> 环境变量指向的目录。</li><li><code>TEMP</code> 环境变量指向的目录。</li><li><code>TMP</code> 环境变量指向的目录。</li><li>与平台相关的位置：<ul><li>在 Windows 上，依次为 <code>C:\TEMP</code>、<code>C:\TMP</code>、<code>\TEMP</code> 和 <code>\TMP</code>。</li><li>在所有其他平台上，依次为 <code>/tmp</code>、<code>/var/tmp</code> 和 <code>/usr/tmp</code>。</li></ul></li><li>不得已时，使用当前工作目录。</li></ol><p>搜索的结果会缓存起来，参见下面 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.tempdir" target="_blank" rel="noopener"><code>tempdir</code></a> 的描述。</p></li><li><p><code>tempfile.gettempdirb</code>()</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempdir" target="_blank" rel="noopener"><code>gettempdir()</code></a> 相同，但返回值为字节类型。<em>3.5 新版功能.</em></p></li><li><p><code>tempfile.gettempprefix</code>()</p><p>返回用于创建临时文件的文件名前缀，它不包含目录部分。</p></li><li><p><code>tempfile.gettempprefixb</code>()</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefix" target="_blank" rel="noopener"><code>gettempprefix()</code></a> 相同，但返回值为字节类型。<em>3.5 新版功能.</em></p></li></ul><p>本模块使用一个全局变量来存储由 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempdir" target="_blank" rel="noopener"><code>gettempdir()</code></a> 返回的临时文件目录路径。可以直接给它赋值，这样可以覆盖自动选择的路径，但是不建议这样做。本模块中的所有函数都带有一个 <em>dir</em> 参数，该参数可用于指定目录，这是推荐的方法。</p><ul><li><p><code>tempfile.tempdir</code></p><p>当设置为 <code>None</code> 以外的其他值时，此变量将决定本模块所有函数的 <em>dir</em> 参数的默认值。如果在调用除 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempprefix" target="_blank" rel="noopener"><code>gettempprefix()</code></a> 外的上述任何函数时 <code>tempdir</code> 为 <code>None</code> (默认值) 则它会按照 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.gettempdir" target="_blank" rel="noopener"><code>gettempdir()</code></a> 中所描述的算法来初始化。</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下是 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#module-tempfile" target="_blank" rel="noopener"><code>tempfile</code></a> 模块典型用法的一些示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> tempfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a temporary file and write some data to it</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp = tempfile.TemporaryFile()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.write(<span class="string">b'Hello world!'</span>)</span><br><span class="line"><span class="comment"># read data from file</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.seek(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.read()</span><br><span class="line"><span class="string">b'Hello world!'</span></span><br><span class="line"><span class="comment"># close the file, it will be removed</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a temporary file using a context manager</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> tempfile.TemporaryFile() <span class="keyword">as</span> fp:</span><br><span class="line"><span class="meta">... </span>    fp.write(<span class="string">b'Hello world!'</span>)</span><br><span class="line"><span class="meta">... </span>    fp.seek(<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span>    fp.read()</span><br><span class="line"><span class="string">b'Hello world!'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment"># file is now closed and removed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create a temporary directory using the context manager</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> tempfile.TemporaryDirectory() <span class="keyword">as</span> tmpdirname:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'created temporary directory'</span>, tmpdirname)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment"># directory and contents have been removed</span></span><br></pre></td></tr></table></figure><h2 id="已弃用的函数和变量"><a href="#已弃用的函数和变量" class="headerlink" title="已弃用的函数和变量"></a>已弃用的函数和变量</h2><p>创建临时文件有一种历史方法，首先使用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mktemp" target="_blank" rel="noopener"><code>mktemp()</code></a> 函数生成一个文件名，然后使用该文件名创建文件。不幸的是，这是不安全的，因为在调用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mktemp" target="_blank" rel="noopener"><code>mktemp()</code></a> 与随后尝试创建文件的进程之间的时间里，其他进程可能会使用该名称创建文件。解决方案是将两个步骤结合起来，立即创建文件。这个方案目前被 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 和上述其他函数所采用。</p><ul><li><p><code>tempfile.mktemp</code>(<em>suffix=’’</em>, <em>prefix=’tmp’</em>, <em>dir=None</em>)</p><p><em>2.3 版后已移除:</em> 使用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 来代替。返回一个绝对路径，这个路径指向的文件在调用本方法时不存在。<em>prefix</em>、<em>suffix</em> 和 <em>dir</em> 参数与 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mkstemp" target="_blank" rel="noopener"><code>mkstemp()</code></a> 中的同名参数类似，不同之处在于不支持字节类型的文件名，不支持 <code>suffix=None</code> 和 <code>prefix=None</code>。</p></li></ul><p>使用此功能可能会在程序中引入安全漏洞。当你开始使用本方法返回的文件执行任何操作时，可能有人已经捷足先登了。<a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.mktemp" target="_blank" rel="noopener"><code>mktemp()</code></a> 的功能可以很轻松地用 <a href="https://docs.python.org/zh-cn/3.8/library/tempfile.html#tempfile.NamedTemporaryFile" target="_blank" rel="noopener"><code>NamedTemporaryFile()</code></a> 代替，当然需要传递 <code>delete=False</code> 参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = NamedTemporaryFile(delete=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.name</span><br><span class="line"><span class="string">'/tmp/tmptjujjt'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">b"Hello World!\n"</span>)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.unlink(f.name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exists(f.name)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-tempfile&quot;&gt;&lt;a href=&quot;#python-标准库-tempfile&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 tempfile&quot;&gt;&lt;/a&gt;python 标准库 tempfile&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200213_car.jpeg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="tempfile" scheme="https://pinghailinfeng.gitee.io/tags/tempfile/"/>
    
  </entry>
  
  <entry>
    <title>python standard library coroutines</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/12/python-standard-library-coroutines/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/12/python-standard-library-coroutines/</id>
    <published>2020-02-12T13:59:58.000Z</published>
    <updated>2020-02-17T03:27:23.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-coroutines-协程"><a href="#python-标准库-coroutines-协程" class="headerlink" title="python 标准库 coroutines 协程"></a>python 标准库 coroutines 协程</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200213_coroutine.jpg?raw=true" alt></p><a id="more"></a><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200213_writing.jpg?raw=true" alt></p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id2" target="_blank" rel="noopener">协程</a></h2><p> <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">Coroutines</a> declared with the async/await syntax is the preferred way of writing asyncio applications. For example, the following snippet of code (requires Python 3.7+) prints “hello”, waits 1 second, and then prints “world”: </p><p> <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">Coroutines</a> 通过 async/await 语法声明是编写异步应用程序的首选方式。例如下面的语法片段(需要Python 3.7+),我们实现了等待一秒,打印’’world“的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'hello'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>asyncio.run(main())</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><p> 注意：简单地调用一个协程并不会将其加入执行日程: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>main()</span><br><span class="line">&lt;coroutine object main at <span class="number">0x1053bb7c8</span>&gt;</span><br></pre></td></tr></table></figure><p>要真正运行一个协程，asyncio 提供了三种主要机制:</p><ul><li><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.run" target="_blank" rel="noopener"><code>asyncio.run()</code></a> 函数用来运行最高层级的入口点 “main()” 函数 (参见上面的示例。)</p></li><li><p>等待一个协程。以下代码段会在等待 1 秒后打印 “hello”，然后 <em>再次</em> 等待 2 秒后打印 “world”:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_after</span><span class="params">(delay, what)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    print(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>预期的输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">started at <span class="number">17</span>:<span class="number">13</span>:<span class="number">52</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finished at <span class="number">17</span>:<span class="number">13</span>:<span class="number">55</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>asyncio.create_task()</code></a> 函数用来并发运行作为 asyncio <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>任务</code></a> 的多个协程。 </p><p>让我们修改以上示例，<em>并发</em> 运行两个 <code>say_after</code> 协程:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task1 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">1</span>, <span class="string">'hello'</span>))</span><br><span class="line"></span><br><span class="line">    task2 = asyncio.create_task(</span><br><span class="line">        say_after(<span class="number">2</span>, <span class="string">'world'</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait until both tasks are completed (should take</span></span><br><span class="line">    <span class="comment"># around 2 seconds.)</span></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><p>注意，预期的输出显示代码段的运行时间比之前快了 1 秒:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">started at <span class="number">17</span>:<span class="number">14</span>:<span class="number">32</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">finished at <span class="number">17</span>:<span class="number">14</span>:<span class="number">34</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="可等待对象"><a href="#可等待对象" class="headerlink" title="可等待对象"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id3" target="_blank" rel="noopener">可等待对象</a></h2><p>如果一个对象可以在 <a href="https://docs.python.org/zh-cn/3.8/reference/expressions.html#await" target="_blank" rel="noopener"><code>await</code></a> 语句中使用，那么它就是 <strong>可等待</strong> 对象。许多 asyncio API 都被设计为接受可等待对象。</p><p><em>可等待</em> 对象有三种主要类型: <strong>协程</strong>, <strong>任务</strong> 和 <strong>Future</strong>.</p><p>协程</p><p>Python 协程属于 <em>可等待</em> 对象，因此可以在其他协程中被等待:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Nothing happens if we just call "nested()".</span></span><br><span class="line">    <span class="comment"># A coroutine object is created but not awaited,</span></span><br><span class="line">    <span class="comment"># so it *won't run at all*.</span></span><br><span class="line">    nested()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Let's do it differently now and await it:</span></span><br><span class="line">    print(<span class="keyword">await</span> nested())  <span class="comment"># will print "42".</span></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>重要</p><p>在本文档中 “协程” 可用来表示两个紧密关联的概念:</p><ul><li><em>协程函数</em>: 定义形式为 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 的函数;</li><li><p><em>协程对象</em>: 调用 <em>协程函数</em> 所返回的对象。</p><p>asyncio 也支持旧式的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-generator-based-coro" target="_blank" rel="noopener">基于生成器的</a> 协程。 </p></li></ul><p>任务</p><p><em>任务</em> 被用来设置日程以便 <em>并发</em> 执行协程。</p><p>当一个协程通过 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>asyncio.create_task()</code></a> 等函数被打包为一个 <em>任务</em>，该协程将自动排入日程准备立即运行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">nested</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Schedule nested() to run soon concurrently</span></span><br><span class="line">    <span class="comment"># with "main()".</span></span><br><span class="line">    task = asyncio.create_task(nested())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># "task" can now be used to cancel "nested()", or</span></span><br><span class="line">    <span class="comment"># can simply be awaited to wait until it is complete:</span></span><br><span class="line">    <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>Future 对象</p><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future</code></a> 是一种特殊的 <strong>低层级</strong> 可等待对象，表示一个异步操作的 <strong>最终结果</strong>。</p><p>当一个 Future 对象 <em>被等待</em>，这意味着协程将保持等待直到该 Future 对象在其他地方操作完毕。</p><p>在 asyncio 中需要 Future 对象以便允许通过 async/await 使用基于回调的代码。</p><p>通常情况下 <strong>没有必要</strong> 在应用层级的代码中创建 Future 对象。</p><p>Future 对象有时会由库和某些 asyncio API 暴露给用户，用作可等待对象:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> function_that_returns_a_future_object()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># this is also valid:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        function_that_returns_a_future_object(),</span><br><span class="line">        some_python_coroutine()</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>一个很好的返回对象的低层级函数的示例是 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.loop.run_in_executor" target="_blank" rel="noopener"><code>loop.run_in_executor()</code></a>。</p><h2 id="运行-asyncio-程序"><a href="#运行-asyncio-程序" class="headerlink" title="运行 asyncio 程序"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id4" target="_blank" rel="noopener">运行 asyncio 程序</a></h2><p> <code>asyncio.run</code>(<em>coro</em>, <em>**, </em>debug=False*) </p><p>执行 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-coroutine" target="_blank" rel="noopener">coroutine</a> <em>coro</em> 并返回结果。</p><p>此函数运行传入的协程，负责管理 asyncio 事件循环并 <em>完结异步生成器</em>。</p><p>当有其他 asyncio 事件循环在同一线程中运行时，此函数不能被调用。</p><p>如果 <em>debug</em> 为 <code>True</code>，事件循环将以调试模式运行。</p><p>此函数总是会创建一个新的事件循环并在结束时关闭之。它应当被用作 asyncio 程序的主入口点，理想情况下应当只被调用一次。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p> <em>3.7 新版功能.</em> </p><blockquote><p>  <code>asyncio.run()</code>源代码请移步至 <a href="https://github.com/python/cpython/tree/3.8/Lib/asyncio/runners.py" target="_blank" rel="noopener">Lib/asyncio/runners.py</a>.</p></blockquote><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id5" target="_blank" rel="noopener">创建任务</a></h2><ul><li><p><code>asyncio.create_task</code>(<em>coro</em>, <em>**, </em>name=None*)</p><p>将 <em>coro</em> <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程</a> 打包为一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 排入日程准备执行。返回 Task 对象。</p><p>If <em>name</em> is not <code>None</code>, it is set as the name of the task using <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.set_name" target="_blank" rel="noopener"><code>Task.set_name()</code></a>.</p><p>该任务会在 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener"><code>get_running_loop()</code></a> 返回的循环中执行，如果当前线程没有在运行的循环则会引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#RuntimeError" target="_blank" rel="noopener"><code>RuntimeError</code></a>。</p><p>此函数 <strong>在 Python 3.7 中被加入</strong>。在 Python 3.7 之前，可以改用低层级的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.ensure_future" target="_blank" rel="noopener"><code>asyncio.ensure_future()</code></a> 函数。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coro</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># In Python 3.7+</span></span><br><span class="line">task = asyncio.create_task(coro())</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># This works in all Python versions but is less readable</span></span><br><span class="line">task = asyncio.ensure_future(coro())</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><em>3.7 新版功能.</em></p><p><em>在 3.8 版更改:</em> Added the <code>name</code> parameter.</p><h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id6" target="_blank" rel="noopener">休眠</a></h2><ul><li><p><em>coroutine</em> <code>asyncio.sleep</code>(<em>delay</em>, <em>result=None</em>, <em>**, </em>loop=None*)</p><p>阻塞 <em>delay</em> 指定的秒数。</p><p>如果指定了 <em>result</em>，则当协程完成时将其返回给调用者。</p><p><code>sleep()</code> 总是会挂起当前任务，以允许其他任务运行。</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><p>以下协程示例运行 5 秒，每秒显示一次当前日期:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">display_date</span><span class="params">()</span>:</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    end_time = loop.time() + <span class="number">5.0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(datetime.datetime.now())</span><br><span class="line">        <span class="keyword">if</span> (loop.time() + <span class="number">1.0</span>) &gt;= end_time:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(display_date())</span><br></pre></td></tr></table></figure></li></ul><h2 id="并发运行任务"><a href="#并发运行任务" class="headerlink" title="并发运行任务"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id7" target="_blank" rel="noopener">并发运行任务</a></h2><ul><li><p><em>awaitable</em> <code>asyncio.gather</code>(*<em>aws</em>, <em>loop=None</em>, <em>return_exceptions=False</em>) </p><p><em>并发</em> 运行 <em>aws</em> 序列中的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a>。</p><p>如果 <em>aws</em> 中的某个可等待对象为协程，它将自动作为一个任务加入日程。</p><p>如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而成的列表。结果值的顺序与 <em>aws</em> 中可等待对象的顺序一致。</p><p>如果 <em>return_exceptions</em> 为 <code>False</code> (默认)，所引发的首个异常会立即传播给等待 <code>gather()</code> 的任务。<em>aws</em> 序列中的其他可等待对象 <strong>不会被取消</strong> 并将继续运行。</p><p>如果 <em>return_exceptions</em> 为 <code>True</code>，异常会和成功的结果一样处理，并聚合至结果列表。</p><p>如果 <code>gather()</code> <em>被取消</em>，所有被提交 (尚未完成) 的可等待对象也会 <em>被取消</em>。</p><p>如果 <em>aws</em> 序列中的任一 Task 或 Future 对象 <em>被取消</em>，它将被当作引发了 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 一样处理 – 在此情况下 <code>gather()</code> 调用 <strong>不会</strong> 被取消。这是为了防止一个已提交的 Task/Future 被取消导致其他 Tasks/Future 也被取消。</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(name, number)</span>:</span></span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: Compute factorial(<span class="subst">&#123;i&#125;</span>)..."</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        f *= i</span><br><span class="line">    print(<span class="string">f"Task <span class="subst">&#123;name&#125;</span>: factorial(<span class="subst">&#123;number&#125;</span>) = <span class="subst">&#123;f&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Schedule three calls *concurrently*:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        factorial(<span class="string">"A"</span>, <span class="number">2</span>),</span><br><span class="line">        factorial(<span class="string">"B"</span>, <span class="number">3</span>),</span><br><span class="line">        factorial(<span class="string">"C"</span>, <span class="number">4</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     Task A: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(2)...</span></span><br><span class="line"><span class="comment">#     Task A: factorial(2) = 2</span></span><br><span class="line"><span class="comment">#     Task B: Compute factorial(3)...</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(3)...</span></span><br><span class="line"><span class="comment">#     Task B: factorial(3) = 6</span></span><br><span class="line"><span class="comment">#     Task C: Compute factorial(4)...</span></span><br><span class="line"><span class="comment">#     Task C: factorial(4) = 24</span></span><br></pre></td></tr></table></figure><p><em>在 3.7 版更改:</em> 如果 <em>gather</em> 本身被取消，则无论 <em>return_exceptions</em> 取值为何，消息都会被传播。</p></li></ul><h2 id="屏蔽取消操作"><a href="#屏蔽取消操作" class="headerlink" title="屏蔽取消操作"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id8" target="_blank" rel="noopener">屏蔽取消操作</a></h2><ul><li><p><em>awaitable</em> <code>asyncio.shield</code>(<em>aw</em>, <em>**, </em>loop=None*) </p><p>保护一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a> 防止其被 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>取消</code></a>。</p><p>如果 <em>aw</em> 是一个协程，它将自动作为任务加入日程。</p><p>以下语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = await shield(something())</span><br></pre></td></tr></table></figure><p>相当于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = await something()</span><br></pre></td></tr></table></figure><p><em>不同之处</em> 在于如果包含它的协程被取消，在 <code>something()</code> 中运行的任务不会被取消。从 <code>something()</code> 的角度看来，取消操作并没有发生。然而其调用者已被取消，因此 “await” 表达式仍然会引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a>。</p><p>如果通过其他方式取消 <code>something()</code> (例如在其内部操作) 则 <code>shield()</code> 也会取消。</p><p>如果希望完全忽略取消操作 (不推荐) 则 <code>shield()</code> 函数需要配合一个 try/except 代码段，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    res = await shield(something())</span><br><span class="line">except CancelledError:</span><br><span class="line">    res = None</span><br></pre></td></tr></table></figure><p>从 3.8版本加入，将于 3.10版本移除<em>loop</em> 形参。</p></li></ul><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id9" target="_blank" rel="noopener">超时</a></h2><ul><li><p><em>coroutine</em> <code>asyncio.wait_for</code>(<em>aw</em>, <em>timeout</em>, <em>**, </em>loop=None*) </p><p>等待 <em>aw</em> <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a> 完成，指定 timeout 秒数后超时。</p><p>如果 <em>aw</em> 是一个协程，它将自动作为任务加入日程。</p><p><em>timeout</em> 可以为 <code>None</code>，也可以为 float 或 int 型数值表示的等待秒数。如果 <em>timeout</em> 为 <code>None</code>，则等待直到完成。</p><p>如果发生超时，任务将取消并引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>.</p><p>要避免任务 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>取消</code></a>，可以加上 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.shield" target="_blank" rel="noopener"><code>shield()</code></a>。</p><p>函数将等待直到目标对象确实被取消，所以总等待时间可能超过 <em>timeout</em> 指定的秒数。</p><p>如果等待被取消，则 <em>aw</em> 指定的对象也会被取消。</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">eternity</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Sleep for one hour</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    print(<span class="string">'yay!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Wait for at most 1 second</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait_for(eternity(), timeout=<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">        print(<span class="string">'timeout!'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     timeout!</span></span><br></pre></td></tr></table></figure><p><em>在 3.7 版更改:</em> 当 <em>aw</em> 因超时被取消，<code>wait_for</code> 会等待 <em>aw</em> 被取消。之前版本则将立即引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>。</p></li></ul><h2 id="简单等待"><a href="#简单等待" class="headerlink" title="简单等待"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id10" target="_blank" rel="noopener">简单等待</a></h2><ul><li><p><em>coroutine</em> <code>asyncio.wait</code>(<em>aws</em>, <em>**, </em>loop=None<em>, </em>timeout=None<em>, </em>return_when=ALL_COMPLETED*) </p><p>并发运行 <em>aws</em> 指定的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a> 并阻塞线程直到满足 <em>return_when</em> 指定的条件。</p><p>返回两个 Task/Future 集合: <code>(done, pending)</code>。</p><p>用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">done, pending = await asyncio.wait(aws)</span><br></pre></td></tr></table></figure><p>如指定 <em>timeout</em> (float 或 int 类型) 则它将被用于控制返回之前等待的最长秒数。</p><p>请注意此函数不会引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>。当超时发生时，未完成的 Future 或 Task 将在指定秒数后被返回。</p><p><em>return_when</em> 指定此函数应在何时返回。它必须为以下常数之一:</p><p>| 常数              | 描述                                                         |<br>| :—————- | :———————————————————– |<br>| <code>FIRST_COMPLETED</code> | 函数将在任意可等待对象结束或取消时返回。                     |<br>| <code>FIRST_EXCEPTION</code> | 函数将在任意可等待对象因引发异常而结束时返回。当没有引发任何异常时它就相当于 <code>ALL_COMPLETED</code>。 |<br>| <code>ALL_COMPLETED</code>   | 函数将在所有可等待对象结束或取消时返回。                     |</p><p>与 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.wait_for" target="_blank" rel="noopener"><code>wait_for()</code></a> 不同，<code>wait()</code> 在超时发生时不会取消可等待对象。</p><p><em>3.8 版后已移除:</em> 如果 <em>aws</em> 中的某个可等待对象为协程，它将自动作为任务加入日程。直接向 <code>wait()</code> 传入协程对象已弃用，因为这会导致 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-example-wait-coroutine" target="_blank" rel="noopener">令人迷惑的行为</a>。</p><p>从 3.8版本加入，将于 3.10版本移除<em>loop</em> 形参。</p><blockquote><p>注解</p><p><code>wait()</code> 会自动将协程作为任务加入日程，以后将以 <code>(done, pending)</code> 集合形式返回显式创建的任务对象。因此以下代码并不会有预期的行为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; coro = foo()</span><br><span class="line">&gt; done, pending = <span class="keyword">await</span> asyncio.wait(&#123;coro&#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">if</span> coro <span class="keyword">in</span> done:</span><br><span class="line">&gt;     <span class="comment"># This branch will never be run!</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>以上代码段的修正方法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">&gt;     <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; task = asyncio.create_task(foo())</span><br><span class="line">&gt; done, pending = <span class="keyword">await</span> asyncio.wait(&#123;task&#125;)</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">if</span> task <span class="keyword">in</span> done:</span><br><span class="line">&gt;     <span class="comment"># Everything will work as expected now.</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>​     <em>3.8 版后已移除:</em> 直接向 <code>wait()</code> 传入协程对象的方式已弃用。 </p><ul><li><p><code>asyncio.as_completed</code>(<em>aws</em>, <em>**, </em>loop=None<em>, </em>timeout=None*) </p><p>并发地运行 <em>aws</em> 集合中的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener">可等待对象</a>。返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future</code></a> 对象的迭代器。返回的每个 Future 对象代表来自剩余可等待对象集合的最早结果。</p><p>如果在所有 Future 对象完成前发生超时则将引发 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener"><code>asyncio.TimeoutError</code></a>。</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> as_completed(aws):</span><br><span class="line">    earliest_result = <span class="keyword">await</span> f</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="来自其他线程的日程安排"><a href="#来自其他线程的日程安排" class="headerlink" title="来自其他线程的日程安排"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id11" target="_blank" rel="noopener">来自其他线程的日程安排</a></h2><ul><li><p><code>asyncio.run_coroutine_threadsafe</code>(<em>coro</em>, <em>loop</em>)</p><p>向指定事件循环提交一个协程。线程安全。</p><p>返回一个 <a href="https://docs.python.org/zh-cn/3.8/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener"><code>concurrent.futures.Future</code></a> 以等待来自其他 OS 线程的结果。</p><p>此函数应该从另一个 OS 线程中调用，而非事件循环运行所在线程。示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Create a coroutine</span><br><span class="line">coro = asyncio.sleep(1, result=3)</span><br><span class="line"></span><br><span class="line"># Submit the coroutine to a given loop</span><br><span class="line">future = asyncio.run_coroutine_threadsafe(coro, loop)</span><br><span class="line"></span><br><span class="line"># Wait for the result with an optional timeout argument</span><br><span class="line">assert future.result(timeout) == 3</span><br></pre></td></tr></table></figure><p>如果在协程内产生了异常，将会通知返回的 Future 对象。它也可被用来取消事件循环中的任务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    result = future.result(timeout)</span><br><span class="line">except asyncio.TimeoutError:</span><br><span class="line">    print(&apos;The coroutine took too long, cancelling the task...&apos;)</span><br><span class="line">    future.cancel()</span><br><span class="line">except Exception as exc:</span><br><span class="line">    print(f&apos;The coroutine raised an exception: &#123;exc!r&#125;&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(f&apos;The coroutine returned: &#123;result!r&#125;&apos;)</span><br></pre></td></tr></table></figure><p>查看 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-dev.html#asyncio-multithreading" target="_blank" rel="noopener">并发和多线程</a> 章节的文档。</p><p>不同与其他 asyncio 函数，此函数要求显式地传入 <em>loop</em> 参数。</p><p><em>3.5.1 新版功能.</em></p></li></ul><h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id12" target="_blank" rel="noopener">内省</a></h2><ul><li><p><code>asyncio.current_task</code>(<em>loop=None</em>)</p><p>返回当前运行的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 实例，如果没有正在运行的任务则返回 <code>None</code>。如果 <em>loop</em> 为 <code>None</code> 则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener"><code>get_running_loop()</code></a> 获取当前事件循环。<em>3.7 新版功能.</em></p></li><li><p><code>asyncio.all_tasks</code>(<em>loop=None</em>)</p><p>返回事件循环所运行的未完成的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a> 对象的集合。如果 <em>loop</em> 为 <code>None</code>，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener"><code>get_running_loop()</code></a> 获取当前事件循环。<em>3.7 新版功能.</em></p></li></ul><h2 id="Task-对象"><a href="#Task-对象" class="headerlink" title="Task 对象"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id13" target="_blank" rel="noopener">Task 对象</a></h2><ul><li><p><em>class</em> <code>asyncio.Task</code>(<em>coro</em>, <em>**, </em>loop=None<em>, </em>name=None*)</p><p>一个与 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future 类似</code></a> 的对象，可运行 Python <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程</a>。非线程安全。</p><p>Task 对象被用来在事件循环中运行协程。如果一个协程在等待一个 Future 对象，Task 对象会挂起该协程的执行并等待该 Future 对象完成。当该 Future 对象 <em>完成</em>，被打包的协程将恢复执行。</p><p>事件循环使用协同日程调度: 一个事件循环每次运行一个 Task 对象。而一个 Task 对象会等待一个 Future 对象完成，该事件循环会运行其他 Task、回调或执行 IO 操作。</p><p>使用高层级的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener"><code>asyncio.create_task()</code></a> 函数来创建 Task 对象，也可用低层级的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.loop.create_task" target="_blank" rel="noopener"><code>loop.create_task()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.ensure_future" target="_blank" rel="noopener"><code>ensure_future()</code></a> 函数。不建议手动实例化 Task 对象。</p><p>要取消一个正在运行的 Task 对象可使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>cancel()</code></a> 方法。调用此方法将使该 Task 对象抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常给打包的协程。如果取消期间一个协程正在等待一个 Future 对象，该 Future 对象也将被取消。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancelled" target="_blank" rel="noopener"><code>cancelled()</code></a> 可被用来检测 Task 对象是否被取消。如果打包的协程没有抑制 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常并且确实被取消，该方法将返回 <code>True</code>。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>asyncio.Task</code></a> 从 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener"><code>Future</code></a> 继承了其除 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_result" target="_blank" rel="noopener"><code>Future.set_result()</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.set_exception" target="_blank" rel="noopener"><code>Future.set_exception()</code></a> 以外的所有 API。</p><p>Task 对象支持 <a href="https://docs.python.org/zh-cn/3.8/library/contextvars.html#module-contextvars" target="_blank" rel="noopener"><code>contextvars</code></a> 模块。当一个 Task 对象被创建，它将复制当前上下文，然后在复制的上下文中运行其协程。</p><p><em>在 3.7 版更改:</em> 加入对 <a href="https://docs.python.org/zh-cn/3.8/library/contextvars.html#module-contextvars" target="_blank" rel="noopener"><code>contextvars</code></a> 模块的支持。</p><p><em>在 3.8 版更改:</em> Added the <code>name</code> parameter.</p><p><em>Deprecated since version 3.8, will be removed in version 3.10:</em> <em>loop</em> 形参。</p><ul><li><p><code>cancel</code>()</p><p>请求取消 Task 对象。这将安排在下一轮事件循环中抛出一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常给被封包的协程。协程在之后有机会进行清理甚至使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#try" target="_blank" rel="noopener"><code>try</code></a> … … <code>except CancelledError</code> … <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> 代码块抑制异常来拒绝请求。不同于 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.cancel" target="_blank" rel="noopener"><code>Future.cancel()</code></a>，<a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>Task.cancel()</code></a> 不保证 Task 会被取消，虽然抑制完全取消并不常见，也很不鼓励这样做。以下示例演示了协程是如何侦听取消请求的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">cancel_me</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'cancel_me(): before sleep'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Wait for 1 hour</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">3600</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        print(<span class="string">'cancel_me(): cancel sleep'</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'cancel_me(): after sleep'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Create a "cancel_me" Task</span></span><br><span class="line">    task = asyncio.create_task(cancel_me())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Wait for 1 second</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    task.cancel()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        print(<span class="string">"main(): cancel_me is cancelled now"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected output:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     cancel_me(): before sleep</span></span><br><span class="line"><span class="comment">#     cancel_me(): cancel sleep</span></span><br><span class="line"><span class="comment">#     cancel_me(): after sleep</span></span><br><span class="line"><span class="comment">#     main(): cancel_me is cancelled now</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>cancelled</code>()</p><p>如果 Task 对象 <em>被取消</em> 则返回 <code>True</code>。当使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener"><code>cancel()</code></a> 发出取消请求时 Task 会被 <em>取消</em>，其封包的协程将传播被抛入的 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。</p></li><li><p><code>done</code>()</p><p>如果 Task 对象 <em>已完成</em> 则返回 <code>True</code>。当 Task 所封包的协程返回一个值、引发一个异常或 Task 本身被取消时，则会被认为 <em>已完成</em>。</p></li><li><p><code>result</code>()</p><p>返回 Task 的结果。如果 Task 对象 <em>已完成</em>，其封包的协程的结果会被返回 (或者当协程引发异常时，该异常会被重新引发。)如果 Task 对象 <em>被取消</em>，此方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。如果 Task 对象的结果还不可用，此方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 异常。</p></li><li><p><code>exception</code>()</p><p>返回 Task 对象的异常。如果所封包的协程引发了一个异常，该异常将被返回。如果所封包的协程正常返回则该方法将返回 <code>None</code>。如果 Task 对象 <em>被取消</em>，此方法会引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener"><code>CancelledError</code></a> 异常。如果 Task 对象尚未 <em>完成</em>，此方法将引发一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-exceptions.html#asyncio.InvalidStateError" target="_blank" rel="noopener"><code>InvalidStateError</code></a> 异常。</p></li><li><p><code>add_done_callback</code>(<em>callback</em>, <em>**, </em>context=None*)</p><p>添加一个回调，将在 Task 对象 <em>完成</em> 时被运行。此方法应该仅在低层级的基于回调的代码中使用。要了解更多细节请查看 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.add_done_callback" target="_blank" rel="noopener"><code>Future.add_done_callback()</code></a> 的文档。</p></li><li><p><code>remove_done_callback</code>(<em>callback</em>)</p><p>从回调列表中移除 <em>callback</em> 指定的回调。此方法应该仅在低层级的基于回调的代码中使用。要了解更多细节请查看 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-future.html#asyncio.Future.remove_done_callback" target="_blank" rel="noopener"><code>Future.remove_done_callback()</code></a> 的文档。</p></li><li><p><code>get_stack</code>(<em>**, </em>limit=None*)</p><p>返回此 Task 对象的栈框架列表。如果所封包的协程未完成，这将返回其挂起所在的栈。如果协程已成功完成或被取消，这将返回一个空列表。如果协程被一个异常终止，这将返回回溯框架列表。框架总是从按从旧到新排序。每个被挂起的协程只返回一个栈框架。可选的 <em>limit</em> 参数指定返回框架的数量上限；默认返回所有框架。返回列表的顺序要看是返回一个栈还是一个回溯：栈返回最新的框架，回溯返回最旧的框架。(这与 traceback 模块的行为保持一致。)</p></li><li><p><code>print_stack</code>(<em>**, </em>limit=None<em>, </em>file=None*)</p><p>打印此 Task 对象的栈或回溯。此方法产生的输出类似于 traceback 模块通过 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.get_stack" target="_blank" rel="noopener"><code>get_stack()</code></a> 所获取的框架。<em>limit</em> 参数会直接传递给 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task.get_stack" target="_blank" rel="noopener"><code>get_stack()</code></a>。<em>file</em> 参数是输出所写入的 I/O 流；默认情况下输出会写入 <a href="https://docs.python.org/zh-cn/3.8/library/sys.html#sys.stderr" target="_blank" rel="noopener"><code>sys.stderr</code></a>。</p></li><li><p><code>get_coro</code>()</p><p>返回绑定到 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener"><code>Task</code></a>.的协程对象。<em>3.8 新版功能.</em></p></li><li><p><code>get_name</code>()</p><p>返回Task 名字。如果没有显式分配给Task一个名字,则默认的异步Task将分配给默认的生成的名字。<em>3.8 新版功能.</em></p></li><li><p><code>set_name</code>(<em>value</em>)</p><p>设置Task名字。参数值可以是任意数据类型,都将被转换成字符串。默认的Task实现，可以通过在task对象中实现 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#repr" target="_blank" rel="noopener"><code>repr()</code></a>函数显式输出。<em>3.8 新版功能.</em></p></li><li><p><em>classmethod</em> <code>all_tasks</code>(<em>loop=None</em>)</p><p>返回一个事件循环中所有任务的集合。默认情况下将返回当前事件循环中所有任务。如果 <em>loop</em> 为 <code>None</code>，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_event_loop" target="_blank" rel="noopener"><code>get_event_loop()</code></a> 函数来获取当前事件循环。从3.7版本就被废弃,3.9版本将会被移除。尽量不要作为一个task方法来使用,建议使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.all_tasks" target="_blank" rel="noopener"><code>asyncio.all_tasks()</code></a> 代替。</p></li><li><p><em>classmethod</em> <code>current_task</code>(<em>loop=None</em>)</p><p>返回当前运行任务或 <code>None</code>。如果 <em>loop</em> 为 <code>None</code>，则会使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-eventloop.html#asyncio.get_event_loop" target="_blank" rel="noopener"><code>get_event_loop()</code></a> 函数来获取当前事件循环。</p><p>从3.7版本就被废弃,3.9版本将会被移除。尽量不要作为一个task方法来使用,建议使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.current_task" target="_blank" rel="noopener"><code>asyncio.current_task()</code></a> 代替。</p></li></ul><h2 id="基于生成器的协程"><a href="#基于生成器的协程" class="headerlink" title="基于生成器的协程"></a><a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#id14" target="_blank" rel="noopener">基于生成器的协程</a></h2><blockquote><p>对基于生成器的协程的支持 <strong>已弃用</strong> 并计划在 Python 3.10 中移除。</p></blockquote><p>基于生成器的协程是 async/await 语法的前身。它们是使用 <code>yield from</code> 语句创建的 Python 生成器，可以等待 Future 和其他协程。</p><p>基于生成器的协程应该使用 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.coroutine" target="_blank" rel="noopener"><code>@asyncio.coroutine</code></a> 装饰，虽然这并非强制。</p><ul><li><p><a href="mailto:`@asyncio.coroutine" target="_blank" rel="noopener">`@asyncio.coroutine</a>`</p><p>用来标记基于生成器的协程的装饰器。此装饰器使得旧式的基于生成器的协程能与 async/await 代码相兼容:</p><p>此装饰器使得旧式的基于生成器的协程能与 async/await 代码相兼容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">old_style_coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">await</span> old_style_coroutine()</span><br></pre></td></tr></table></figure><p>此装饰器不应该被用于 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 协程。</p><p> 从3.8版本被废弃, 将于3.10版本移除:* 使用 <a href="https://docs.python.org/zh-cn/3.8/reference/compound_stmts.html#async-def" target="_blank" rel="noopener"><code>async def</code></a> 代替。</p></li><li><p><code>asyncio.iscoroutine</code>(<em>obj</em>)</p><p>如果 <em>obj</em> 是一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程对象</a> 则返回 <code>True</code>。此方法不同于 <a href="https://docs.python.org/zh-cn/3.8/library/inspect.html#inspect.iscoroutine" target="_blank" rel="noopener"><code>inspect.iscoroutine()</code></a> 因为它对基于生成器的协程返回 <code>True</code>。</p></li><li><p><code>asyncio.iscoroutinefunction</code>(<em>func</em>)</p><p>如果 <em>func</em> 是一个 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#coroutine" target="_blank" rel="noopener">协程函数</a> 则返回 <code>True</code>。此方法不同于 <a href="https://docs.python.org/zh-cn/3.8/library/inspect.html#inspect.iscoroutinefunction" target="_blank" rel="noopener"><code>inspect.iscoroutinefunction()</code></a> 因为它对以 <a href="https://docs.python.org/zh-cn/3.8/library/asyncio-task.html#asyncio.coroutine" target="_blank" rel="noopener"><code>@coroutine</code></a> 装饰的基于生成器的协程函数返回 <code>True</code>。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>转自 <a href="https://www.zhihu.com/question/35139020" target="_blank" rel="noopener">python协程</a></p><p>作者：侠三十六</p><p><strong>协程</strong></p><p>首先要明确，线程和进程都是系统帮咱们开辟的，不管是thread还是process他内部都是调用的系统的API,而对于协程来说它和系统毫无关系;</p><p>协程不同于线程的是，线程是抢占式的调度，而协程是协同式的调度，也就是说，协程需要自己做调度。</p><p>他就和程序员有关系，对于线程和进程来说，调度是由CPU来决定调度的;</p><p>对于协程来说，程序员就是上帝，你想让谁执行到哪里他就执行到哪里;</p><p>协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。</p><p><strong>适用场景：</strong>其实在其他语言中，协程的其实是意义不大的多线程即可已解决I/O的问题，但是在python因为他有GIL（Global Interpreter Lock 全局解释器锁 ）在同一时间只有一个线程在工作，所以：如果一个线程里面I/O操作特别多，协程就比较适用;</p><p>协程，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程。</p><p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：</p><p>协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。</p><p><strong>协程的好处：</strong></p><p>无需线程上下文切换的开销</p><p>无需原子操作锁定及同步的开销</p><p>方便切换控制流，简化编程模型</p><p>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</p><p><strong>缺点：</strong></p><p>无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</p><p>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-coroutines-协程&quot;&gt;&lt;a href=&quot;#python-标准库-coroutines-协程&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 coroutines 协程&quot;&gt;&lt;/a&gt;python 标准库 coroutines 协程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200213_coroutine.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="coroutines" scheme="https://pinghailinfeng.gitee.io/tags/coroutines/"/>
    
  </entry>
  
  <entry>
    <title>python standard library weakref</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/11/python-standard-library-weakref/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/11/python-standard-library-weakref/</id>
    <published>2020-02-10T22:57:22.000Z</published>
    <updated>2020-02-11T13:27:57.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-weakref-弱引用"><a href="#python-标准库-weakref-弱引用" class="headerlink" title="python 标准库 weakref 弱引用"></a>python 标准库 weakref 弱引用</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/compress.jpg?raw=true" alt></p><a id="more"></a><p>通过<code>google Insights</code> 优化,我把图片进行了压缩,明显速度提升了15%，接下来压缩css和js.</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.8/Lib/weakref.py" target="_blank" rel="noopener">Lib/weakref.py</a> </p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块允许Python程序员创建对象的 <em>weak references</em> 。</p><p>在下文中，术语 <em>referent</em> 表示由弱引用引用的对象。</p><p>对对象的弱引用不能保证对象存活：当对像的引用只剩弱引用时， <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-garbage-collection" target="_blank" rel="noopener">garbage collection</a> 可以销毁引用并将其内存重用于其他内容。但是，在实际销毁对象之前，即使没有强引用，弱引用也一直能返回该对象。</p><p>弱引用的主要用途是实现保存大对象的高速缓存或映射，但又并希望大对象仅仅因为它出现在高速缓存或映射中而保持存活。</p><p>例如，如果您有许多大型二进制图像对象，则可能希望将名称与每个对象关联起来。如果您使用Python字典将名称映射到图像，或将图像映射到名称，则图像对象将保持活动状态，因为它们在字典中显示为值或键。 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块提供的 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 类可以替代Python字典，使用弱引用来构造映射，这些映射不会仅仅因为它们出现在映射对象中而使对象保持存活。例如，如果一个图像对象是 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 中的值，那么当对该图像对象的剩余引用是弱映射对象所持有的弱引用时，垃圾回收可以回收该对象并将其在弱映射对象中相应的条目删除。</p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 在它们的实现中使用弱引用，在弱引用上设置回调函数，当键或值被垃圾回收回收时通知弱字典。 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakSet" target="_blank" rel="noopener"><code>WeakSet</code></a> 实现了 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#set" target="_blank" rel="noopener"><code>set</code></a> 接口，但像 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 一样，只持有其元素的弱引用。`</p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize" target="_blank" rel="noopener"><code>finalize</code></a> 提供了注册一个对象被垃圾收集时要调用的清理函数的方式。这比在原始弱引用上设置回调函数更简单，因为模块会自动确保对象被回收前终结器一直保持存活。</p><p>这些弱容器类型之一或者 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize" target="_blank" rel="noopener"><code>finalize</code></a> 就是大多数程序所需要的 - 通常不需要直接创建自己的弱引用。<a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#module-weakref" target="_blank" rel="noopener"><code>weakref</code></a> 模块暴露了低级机制，以便于高级用途。</p><p>并非所有对象都可以被弱引用；可以被弱引用的对象包括类实例，用 Python（而不是用 C）编写的函数，实例方法、集合、冻结集合，某些 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-file-object" target="_blank" rel="noopener">文件对象</a>，<a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-generator" target="_blank" rel="noopener">生成器</a>，类型对象，套接字，数组，双端队列，正则表达式模式对象以及代码对象等。</p><p><em>在 3.2 版更改:</em> 添加了对thread.lock，threading.Lock和代码对象的支持。</p><p>几个内建类型如 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#list" target="_blank" rel="noopener"><code>list</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#dict" target="_blank" rel="noopener"><code>dict</code></a> 不直接支持弱引用，但可以通过子类化添加支持:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">obj = Dict(red=<span class="number">1</span>, green=<span class="number">2</span>, blue=<span class="number">3</span>)   <span class="comment"># this object is weak referenceable</span></span><br></pre></td></tr></table></figure><p><strong>CPython implementation detail:</strong> 其他内置类型例如 <a href="https://docs.python.org/zh-cn/3.8/library/stdtypes.html#tuple" target="_blank" rel="noopener"><code>tuple</code></a> 和 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#int" target="_blank" rel="noopener"><code>int</code></a> 不支持弱引用，即使通过子类化也不支持。</p><p>Extension types can easily be made to support weak references; see <a href="https://docs.python.org/zh-cn/3.8/extending/newtypes.html#weakref-support" target="_blank" rel="noopener">Weak Reference Support</a>.</p><ul><li><p><em>class</em> <code>weakref.`</code>ref`(<em>object</em>[, <em>callback</em>])</p><p>返回对 <em>对象</em> 的弱引用。如果原始对象仍然存活，则可以通过调用引用对象来检索原始对象；如果引用的原始对象不再存在，则调用引用对象将得到 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> 。如果提供了 <em>回调</em> 而且值不是 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a> ，并且返回的弱引用对象仍然存活，则在对象即将终结时将调用回调;弱引用对象将作为回调的唯一参数传递；指示物将不再可用。</p><p>许多弱引用也允许针对相同对象来构建。 为每个弱引用注册的回调将按从最近注册的回调到最早注册的回调的顺序被调用。</p><p>回调所引发的异常将记录于标准错误输出，但无法被传播；它们会按与对象的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法所引发的异常相同的方式被处理。</p><p>如果 <em>object</em> 可哈希，则弱引用也为 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a>。 即使在 <em>object</em> 被删除之后它们仍将保持其哈希值。 如果 <a href="https://docs.python.org/zh-cn/3.8/library/functions.html#hash" target="_blank" rel="noopener"><code>hash()</code></a> 在 <em>object</em> 被删除之后才首次被调用，则该调用将引发 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>。</p><p>弱引用支持相等检测，但不支持排序比较。 如果被引用对象仍然存在，两个引用具有与它们的被引用对象一致的相等关系（无论 <em>callback</em> 是否相同）。 如果删除了任一被引用对象，则仅在两个引用对象为同一对象时两者才相等。</p><p>这是一个可子类化的类型而非一个工厂函数。</p><ul><li><p><strong><strong>callback</strong></strong> </p><p>这个只读属性会返回当前关联到弱引用的回调。 如果回调不存在或弱引用的被引用对象已不存在，则此属性的值为 <code>None</code>。 </p></li></ul></li><li><p><code>weakref.`</code>proxy`(<em>object</em>[, <em>callback</em>]) </p><p>返回 <em>object</em> 的一个使用弱引用的代理。 此函数支持在大多数上下文中使用代理，而不要求显式地对所使用的弱引用对象解除引用。 返回的对象类型将为 <code>ProxyType</code> 或 <code>CallableProxyType</code>，具体取决于 <em>object</em> 是否可调用。 Proxy 对象不是 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-hashable" target="_blank" rel="noopener">hashable</a> 对象，无论被引用对象是否可哈希；这可避免与它们的基本可变性质相关的多种问题，并可防止它们被用作字典键。 <em>callback</em> 与 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref()</code></a> 函数的同名形参含义相同。</p><p><em>在 3.8 版更改:</em> 扩展代理对象所支持的运算符，包括矩阵乘法运算符 <code>@</code> 和 <code>@=</code>。</p></li><li><p><code>weakref.`</code>getweakrefcount`(<em>object</em>) </p><p>返回指向 <em>object</em> 的弱引用和代理的数量。 </p></li><li><p><code>weakref.`</code>getweakrefs`(<em>object</em>) </p><p>返回由指向 <em>object</em> 的所有弱引用和代理构成的列表。 </p></li><li><p><em>class</em> <code>weakref.`</code>WeakKeyDictionary`([<em>dict</em>]) </p><p>弱引用键的映射类。 当不再有对键的强引用时字典中的条目将被丢弃。 这可被用来将额外数据关联到一个应用中其他部分所拥有的对象而无需在那些对象中添加属性。 这对于重载了属性访问的对象来说特别有用。 </p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 对象具有一个额外方法可以直接公开内部引用。 这些引用不保证在它们被使用时仍然保持“存活”，因此这些引用的调用结果需要在使用前进行检测。 此方法可用于避免创建会导致垃圾回收器将保留键超出实际需要时长的引用。 </p></li><li><p><code>WeakKeyDictionary.`</code>keyrefs`() </p><p>返回包含对键的弱引用的可迭代对象。 </p></li><li><p><em>class</em> <code>weakref.`</code>WeakValueDictionary`([<em>dict</em>]) </p><p>弱引用值的映射类。 当不再有对键的强引用时字典中的条目将被丢弃。 </p><p><a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 对象具有一个额外方法，此方法存在与 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakKeyDictionary" target="_blank" rel="noopener"><code>WeakKeyDictionary</code></a> 对象的 <code>keyrefs()</code> 方法相同的问题。 </p></li><li><p><code>WeakValueDictionary.`</code>valuerefs`() </p><p> 返回包含对值的弱引用的可迭代对象。 </p></li><li><p><em>class</em> <code>weakref.`</code>WeakSet`([<em>elements</em>]) </p><p>保持对其元素弱引用的集合类。 当不再有对某个元素的强引用时元素将被丢弃。 </p></li><li><p><em>class</em> <code>weakref.`</code>WeakMethod`(<em>method</em>) </p><p>一个模拟对绑定方法（即在类中定义并在实例中查找的方法）进行弱引用的自定义 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref</code></a> 子类。 由于绑定方法是临时性的，标准弱引用无法保持它。 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakMethod" target="_blank" rel="noopener"><code>WeakMethod</code></a> 包含特别代码用来重新创建绑定方法，直到对象或初始函数被销毁: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"method called!"</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = weakref.ref(c.method)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = weakref.WeakMethod(c.method)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()</span><br><span class="line">&lt;bound method C.method of &lt;__main__.C object at <span class="number">0x7fc859830220</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()()</span><br><span class="line">method called!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> c</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gc.collect()</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p><em>class</em> <code>weakref.`</code>finalize`(<em>obj</em>, <em>func</em>, <strong>args<em>, </em></strong>kwargs*) </p><p>返回一个可调用的终结器对象，该对象将在 <em>obj</em> 作为垃圾回收时被调用。 与普通的弱引用不同，终结器将总是存活，直到引用对象被回收，这极大地简化了生存期管理。</p><p>终结器总是被视为 <em>存活</em> 直到它被调用（显式调用或在垃圾回收时隐式调用），调用之后它将 <em>死亡</em>。 调用存活的终结器将返回 <code>func(*arg, **kwargs)</code> 的求值结果，而调用死亡的终结器将返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p><p>在垃圾收集期间由终结器回调所引发异常将显示于标准错误输出，但无法被传播。 它们会按与对象的 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法或弱引用的回调所引发异常相同的方式被处理。</p><p>当程序退出时，剩余的存活终结器会被调用，除非它们的 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#module-atexit" target="_blank" rel="noopener"><code>atexit</code></a> 属性已被设为假值。 它们会按与创建时相反的顺序被调用。</p><p>终结器在 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-interpreter-shutdown" target="_blank" rel="noopener">interpreter shutdown</a> 的后期绝不会发起调用其回调函数，此时模块全局变量很可能已被替换为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p><ul><li><p><code>__call__</code>()</p><p>如果 <em>self</em> 为存活状态则将其标记为已死亡，并返回调用 <code>func(*args, **kwargs)</code> 的结果。 如果 <em>self</em> 已死亡则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p></li><li><p><code>detach</code>()</p><p>如果 <em>self</em> 为存活状态则将其标记为已死亡，并返回元组 <code>(obj, func, args, kwargs)</code>。 如果 <em>self</em> 已死亡则返 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p></li><li><p><code>peek</code>()</p><p>如果 <em>self</em> 为存活状态则返回元组 <code>(obj, func, args, kwargs)</code>。 如果 <em>self</em> 已死亡则返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。</p></li><li><p><code>alive</code></p><p>如果终结器为存活状态则该特征属性为真值，否则为假值。</p></li><li><p><code>atexit</code></p><p>一个可写的布尔型特征属性，默认为真值。 当程序退出时，它会调用所有 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize.atexit" target="_blank" rel="noopener"><code>atexit</code></a> 为真值的剩余存活终结器。 它们会按与创建时相反的顺序被调用。</p></li></ul></li><li><p><code>weakref.`</code>ReferenceType`</p><p>弱引用对象的类型对象。</p></li><li><p><code>weakref.`</code>ProxyType`</p><p>不可调用对象的代理的类型对象。</p></li><li><p><code>weakref.`</code>CallableProxyType`</p><p>可调用对象的代理的类型对象。</p></li><li><p><code>weakref.`</code>ProxyTypes`</p><p>包含所有代理的类型对象的序列。 这可以用于更方便地检测一个对象是否是代理，而不必依赖于两种代理对象的名称。</p></li><li><p><em>exception</em> <code>weakref.`</code>ReferenceError`</p><p>当一个代理对象被使用但其下层的对象已被收集时所引发的异常。 这等价于标准的 <a href="https://docs.python.org/zh-cn/3.8/library/exceptions.html#ReferenceError" target="_blank" rel="noopener"><code>ReferenceError</code></a> 异常。</p></li></ul><blockquote><p><a href="https://www.python.org/dev/peps/pep-0205" target="_blank" rel="noopener"><strong>PEP 205</strong></a> - 弱引用</p><p>此特性的提议和理由，包括早期实现的链接和其他语言中类似特性的相关信息。</p></blockquote><h2 id="弱引用对象"><a href="#弱引用对象" class="headerlink" title="弱引用对象"></a>弱引用对象</h2><p>弱引用对象没有 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref.__callback__" target="_blank" rel="noopener"><code>ref.__callback__</code></a> 以外的方法和属性。 一个弱引用对象如果存在，就允许通过调用它来获取引用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Object</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = weakref.ref(o)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o2 = r()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o <span class="keyword">is</span> o2</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>如果引用已不存在，则调用引用对象将返回 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> o, o2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(r())</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><p>检测一个弱引用对象是否仍然存在应该使用表达式 <code>ref() is not None</code>。 通常，需要使用引用对象的应用代码应当遵循这样的模式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># r is a weak reference object</span></span><br><span class="line">o = r()</span><br><span class="line"><span class="keyword">if</span> o <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># referent has been garbage collected</span></span><br><span class="line">    print(<span class="string">"Object has been deallocated; can't frobnicate."</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Object is still live!"</span>)</span><br><span class="line">    o.do_something_useful()</span><br></pre></td></tr></table></figure><p>使用单独的“存活”测试会在多线程应用中制造竞争条件；其他线程可能导致某个弱引用在该弱引用被调用前就失效；上述的写法在多线程应用和单线程应用中都是安全的。</p><p>特别版本的 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref</code></a> 对象可以通过子类化来创建。 在 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.WeakValueDictionary" target="_blank" rel="noopener"><code>WeakValueDictionary</code></a> 的实现中就使用了这种方式来减少映射中每个条目的内存开销。 这对于将附加信息关联到引用的情况最为适用，但也可以被用于在调用中插入额外处理来提取引用。</p><p>这个例子演示了如何将 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.ref" target="_blank" rel="noopener"><code>ref</code></a> 的一个子类用于存储有关对象的附加信息并在引用被访问时影响其所返回的值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedRef</span><span class="params">(weakref.ref)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ob, callback=None, /, **annotations)</span>:</span></span><br><span class="line">        super(ExtendedRef, self).__init__(ob, callback)</span><br><span class="line">        self.__counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> annotations.items():</span><br><span class="line">            setattr(self, k, v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return a pair containing the referent and the number of</span></span><br><span class="line"><span class="string">        times the reference has been called.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ob = super(ExtendedRef, self).__call__()</span><br><span class="line">        <span class="keyword">if</span> ob <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.__counter += <span class="number">1</span></span><br><span class="line">            ob = (ob, self.__counter)</span><br><span class="line">        <span class="keyword">return</span> ob</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这个简单的例子演示了一个应用如何使用对象 ID 来提取之前出现过的对象。 然后对象的 ID 可以在其它数据结构中使用，而无须强制对象保持存活，但处于存活状态的对象也仍然可以通过 ID 来提取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line">_id2obj_dict = weakref.WeakValueDictionary()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remember</span><span class="params">(obj)</span>:</span></span><br><span class="line">    oid = id(obj)</span><br><span class="line">    _id2obj_dict[oid] = obj</span><br><span class="line">    <span class="keyword">return</span> oid</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">id2obj</span><span class="params">(oid)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _id2obj_dict[oid]</span><br></pre></td></tr></table></figure><h2 id="终结器对象"><a href="#终结器对象" class="headerlink" title="终结器对象"></a>终结器对象</h2><p>使用 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize" target="_blank" rel="noopener"><code>finalize</code></a> 的主要好处在于它能更简便地注册回调函数，而无须保留所返回的终结器对象。 例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Object</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kenny = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weakref.finalize(kenny, <span class="keyword">print</span>, <span class="string">"You killed Kenny!"</span>)  </span><br><span class="line">&lt;finalize object at ...; <span class="keyword">for</span> <span class="string">'Object'</span> at ...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> kenny</span><br><span class="line">You killed Kenny!</span><br></pre></td></tr></table></figure><p>终结器也可以被直接调用。 但是终结器最多只能对回调函数发起一次调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(x, y, z)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"CALLBACK"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y + z</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = weakref.finalize(obj, callback, <span class="number">1</span>, <span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> f.alive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> f() == <span class="number">6</span></span><br><span class="line">CALLBACK</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="keyword">not</span> f.alive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()                     <span class="comment"># callback not called because finalizer dead</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> obj                 <span class="comment"># callback not called because finalizer dead</span></span><br></pre></td></tr></table></figure><p>你可以使用 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize.detach" target="_blank" rel="noopener"><code>detach()</code></a> 方法来注销一个终结器。 该方法将销毁终结器并返回其被创建时传给构造器的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = weakref.finalize(obj, callback, <span class="number">1</span>, <span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.detach()                                           </span><br><span class="line">(&lt;...Object object ...&gt;, &lt;function callback ...&gt;, (<span class="number">1</span>, <span class="number">2</span>), &#123;<span class="string">'z'</span>: <span class="number">3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>newobj, func, args, kwargs = _</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="keyword">not</span> f.alive</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> newobj <span class="keyword">is</span> obj</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> func(*args, **kwargs) == <span class="number">6</span></span><br><span class="line">CALLBACK</span><br></pre></td></tr></table></figure><p>除非你将 <a href="https://docs.python.org/zh-cn/3.8/library/weakref.html#weakref.finalize.atexit" target="_blank" rel="noopener"><code>atexit</code></a> 属性设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#False" target="_blank" rel="noopener"><code>False</code></a>，否则终结器在程序退出时如果仍然存活就将被调用。 例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weakref.finalize(obj, <span class="keyword">print</span>, <span class="string">"obj dead or exiting"</span>)</span><br><span class="line">&lt;finalize object at ...; <span class="keyword">for</span> <span class="string">'Object'</span> at ...&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exit()</span><br><span class="line">obj dead <span class="keyword">or</span> exiting</span><br></pre></td></tr></table></figure><h2 id="比较终结器与-del-方法"><a href="#比较终结器与-del-方法" class="headerlink" title="比较终结器与 __del__() 方法"></a>比较终结器与 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法</h2><p>假设我们想创建一个类，用它的实例来代表临时目录。 当以下事件中的某一个发生时，这个目录应当与其内容一起被删除：</p><ul><li>对象被作为垃圾回收，</li><li>对象的 <code>remove()</code> 方法被调用，或</li><li>程序退出。</li></ul><p>我们可以尝试使用 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法来实现这个类，如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TempDir</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = tempfile.mkdtemp()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            shutil.rmtree(self.name)</span><br><span class="line">            self.name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removed</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.remove()</span><br></pre></td></tr></table></figure><p>从 Python 3.4 开始，<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法不会再阻止循环引用被作为垃圾回收，并且模块全局变量在 <a href="https://docs.python.org/zh-cn/3.8/glossary.html#term-interpreter-shutdown" target="_blank" rel="noopener">interpreter shutdown</a> 期间不会被强制设为 <a href="https://docs.python.org/zh-cn/3.8/library/constants.html#None" target="_blank" rel="noopener"><code>None</code></a>。 因此这段代码在 CPython 上应该会正常运行而不会出现任何问题。</p><p>然而，<a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__del__" target="_blank" rel="noopener"><code>__del__()</code></a> 方法的处理会严重地受到具体实现的影响，因为它依赖于解释器垃圾回收实现方式的内部细节。</p><p>更健壮的替代方式可以是定义一个终结器，只引用它所需要的特定函数和对象，而不是获取对整个对象状态的访问权:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TempDir</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = tempfile.mkdtemp()</span><br><span class="line">        self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._finalizer()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removed</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._finalizer.alive</span><br></pre></td></tr></table></figure><p>像这样定义后，我们的终结器将只接受一个对其完成正确清理目录任务所需细节的引用。 如果对象一直未被作为垃圾回收，终结器仍会在退出时被调用。</p><p>基于弱引用的终结器还具有另一项优势，就是它们可被用来为定义由第三方控制的类注册终结器，例如当一个模块被卸载时运行特定代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref, sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unloading_module</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># implicit reference to the module globals from the function body</span></span><br><span class="line">weakref.finalize(sys.modules[__name__], unloading_module)</span><br></pre></td></tr></table></figure><p><strong>备注</strong>:</p><p> 如果当程序退出时你恰好在守护线程中创建终结器对象，则有可能该终结器不会在退出时被调用。 但是，在一个守护线程中 <a href="https://docs.python.org/zh-cn/3.8/library/atexit.html#atexit.register" target="_blank" rel="noopener"><code>atexit.register()</code></a>, <code>try: ... finally: ...</code> 和 <code>with: ...</code> 同样不能保证执行清理。 </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-weakref-弱引用&quot;&gt;&lt;a href=&quot;#python-标准库-weakref-弱引用&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 weakref 弱引用&quot;&gt;&lt;/a&gt;python 标准库 weakref 弱引用&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/compress.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="weakref" scheme="https://pinghailinfeng.gitee.io/tags/weakref/"/>
    
  </entry>
  
  <entry>
    <title>python standard library cmath</title>
    <link href="https://pinghailinfeng.gitee.io/2020/02/10/python-standard-library-cmath/"/>
    <id>https://pinghailinfeng.gitee.io/2020/02/10/python-standard-library-cmath/</id>
    <published>2020-02-10T04:21:53.000Z</published>
    <updated>2020-02-10T06:05:38.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-标准库-cmath"><a href="#python-标准库-cmath" class="headerlink" title="python 标准库 cmath"></a>python 标准库 cmath</h1><p><img src="https://github.com/jeffsui/app_image_resource/blob/master/20200210_butterfly.jpg?raw=true" alt></p><a id="more"></a><blockquote><p>患难可以试验一个人的品格；非常的境遇方才可以显出非常的气节；风平浪静的海面，所有船只都可以并驱竞胜；命运的铁拳击中要害的时候，只有大勇大智的人才能够处之泰然。</p><p>​                                                                                                                                             –    莎士比亚</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>这一模块提供了一些关于复数的数学函数。 该模块的函数的参数为整数、浮点数或复数。 这些函数的参数也可为一个拥有 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__complex__" target="_blank" rel="noopener"><code>__complex__()</code></a> 或 <a href="https://docs.python.org/zh-cn/3.8/reference/datamodel.html#object.__float__" target="_blank" rel="noopener"><code>__float__()</code></a> 方法的 Python 对象，这些方法分别用于将对象转换为复数和浮点数，这些函数作用于转换后的结果。</p><h2 id="到极坐标和从极坐标的转换"><a href="#到极坐标和从极坐标的转换" class="headerlink" title="到极坐标和从极坐标的转换"></a>到极坐标和从极坐标的转换</h2><p>使用 <em>矩形坐标</em> 或 <em>笛卡尔坐标</em> 在内部存储 Python 复数 <code>z</code>。 这完全取决于它的 <em>实部</em> <code>z.real</code> 和 <em>虚部</em> <code>z.imag</code>。 换句话说:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z == z.real + z.imag*<span class="number">1j</span></span><br></pre></td></tr></table></figure><p><em>极坐标</em> 提供了另一种复数的表示方法。在极坐标中，一个复数 <em>z</em> 由模量 <em>r</em> 和相位角 <em>phi</em> 来定义。模量 <em>r</em> 是从 <em>z</em> 到坐标原点的距离，而相位角 <em>phi</em> 是以弧度为单位的，逆时针的，从正X轴到连接原点和 <em>z</em> 的线段间夹角的角度。</p><p>下面的函数可用于原生直角坐标与极坐标的相互转换。</p><ul><li><p><code>cmath.phase</code>(<em>x</em>)</p><p>将 <em>x</em> 的相位 (也称为 <em>x</em> 的 <em>参数</em>) 返回为一个浮点数。<code>phase(x)</code> 相当于 <code>math.atan2(x.imag, x.real)</code>。 结果处于 [-<em>π</em>, <em>π</em>] 之间，以及这个操作的分支切断处于负实轴上，从上方连续。 在支持有符号零的系统上（这包涵大多数当前的常用系统），这意味着结果的符号与 <code>x.imag</code> 的符号相同，即使 <code>x.imag</code> 的值是 0:</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>phase(complex(<span class="number">-1.0</span>, <span class="number">0.0</span>))</span><br><span class="line"><span class="number">3.141592653589793</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phase(complex(<span class="number">-1.0</span>, <span class="number">-0.0</span>))</span><br><span class="line"><span class="number">-3.141592653589793</span></span><br></pre></td></tr></table></figure><ul><li><p><code>cmath.polar</code>(<em>x</em>)</p><p>在极坐标中返回 <em>x</em> 的表达方式。返回一个数对 <code>(r, phi)</code>，<em>r</em> 是 <em>x</em> 的模数，<em>phi</em> 是 <em>x</em> 的相位角。 <code>polar(x)</code> 相当于 <code>(abs(x), phase(x))</code>。</p></li><li><p><code>cmath.rect</code>(<em>r</em>, <em>phi</em>)</p><p>通过极坐标的 <em>r</em> 和 <em>phi</em> 返回复数 <em>x</em>。相当于 <code>r * (math.cos(phi) + math.sin(phi)*1j)</code>。</p></li></ul><h2 id="幂函数与对数函数"><a href="#幂函数与对数函数" class="headerlink" title="幂函数与对数函数"></a>幂函数与对数函数</h2><ul><li><p><code>cmath.exp</code>(<em>x</em>)</p><p>返回 <em>e</em> 的 <em>x</em> 次方，<em>e</em> 是自然对数的底数。</p></li><li><p><code>cmath.log</code>(<em>x</em>[, <em>base</em>])</p><p>返回给定 <em>base</em> 的 <em>x</em> 的对数。如果没有给定 <em>base</em>，返回 <em>x</em> 的自然对数。 从 0 到 -∞ 存在一个分歧点，沿负实轴之上连续。</p></li><li><p><code>cmath.log10</code>(<em>x</em>)</p><p>返回底数为 10 的 <em>x</em> 的对数。它具有与 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#cmath.log" target="_blank" rel="noopener"><code>log()</code></a> 相同的分歧点。</p></li><li><p><code>cmath.sqrt</code>(<em>x</em>)</p><p>返回 <em>x</em> 的平方根。 它具有与 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#cmath.log" target="_blank" rel="noopener"><code>log()</code></a> 相同的分歧点。</p></li></ul><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><ul><li><p><code>cmath.acos</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反余弦。这里有两个分歧点：一个沿着实轴从 1 向右延伸到 ∞，从下面连续延伸。另外一个沿着实轴从 -1 向左延伸到 -∞，从上面连续延伸。</p></li><li><p><code>cmath.asin</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反正弦。它与 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#cmath.acos" target="_blank" rel="noopener"><code>acos()</code></a> 有相同的分歧点。</p></li><li><p><code>cmath.atan</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反正切。它具有两个分歧点：一个沿着虚轴从 <code>1j</code> 延伸到 <code>∞j</code>，向右持续延伸。另一个是沿着虚轴从 <code>-1j</code> 延伸到 <code>-∞j</code> ，向左持续延伸。</p></li><li><p><code>cmath.cos</code>(<em>x</em>)</p><p>返回 <em>x</em> 的余弦。</p></li><li><p><code>cmath.sin</code>(<em>x</em>)</p><p>返回 <em>x</em> 的正弦。</p></li><li><p><code>cmath.tan</code>(<em>x</em>)</p><p>返回 <em>x</em> 的正切。</p></li></ul><h2 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h2><ul><li><p><code>cmath.acosh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反双曲余弦。它有一个分歧点沿着实轴从 1 到 -∞ 向左延伸，从上方持续延伸。</p></li><li><p><code>cmath.asinh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反双曲正弦。它有两个分歧点：一个沿着虚轴从 <code>1j</code> 向右持续延伸到 <code>∞j</code>。另一个是沿着虚轴从 <code>-1j</code> 向左持续延伸到 <code>-∞j</code>。</p></li><li><p><code>cmath.atanh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的反双曲正切。它有两个分歧点：一个是沿着实轴从 <code>1</code> 延展到 <code>∞</code>，从下面持续延展。另一个是沿着实轴从 <code>-1</code> 延展到 <code>-∞</code>，从上面持续延展。</p></li><li><p><code>cmath.cosh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的双曲余弦值。</p></li><li><p><code>cmath.sinh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的双曲正弦值。</p></li><li><p><code>cmath.tanh</code>(<em>x</em>)</p><p>返回 <em>x</em> 的双曲正切值。</p></li></ul><h2 id="分类函数"><a href="#分类函数" class="headerlink" title="分类函数"></a>分类函数</h2><ul><li><p><code>cmath.isfinite</code>(<em>x</em>)</p><p>如果 <em>x</em> 的实部和虚部都是有限的，则返回 <code>True</code>，否则返回 <code>False</code>。<em>3.2 新版功能.</em></p></li><li><p><code>cmath.isinf</code>(<em>x</em>)</p><p>如果 <em>x</em> 的实部或者虚部是无穷大的，则返回 <code>True</code>，否则返回 <code>False</code>。</p></li><li><p><code>cmath.isnan</code>(<em>x</em>)</p><p>如果 <em>x</em> 的实部或者虚部是 NaN，则返回 <code>True</code> ，否则返回 <code>False</code>。</p></li><li><p><code>cmath.isclose</code>(<em>a</em>, <em>b</em>, <em>**, </em>rel_tol=1e-09<em>, </em>abs_tol=0.0*)</p><p>若 <em>a</em> 和 <em>b</em> 的值比较接近则返回 <code>True</code>，否则返回 <code>False</code>。根据给定的绝对和相对容差确定两个值是否被认为是接近的。<em>rel_tol</em> 是相对容差 —— 它是 <em>a</em> 和 <em>b</em> 之间允许的最大差值，相对于 <em>a</em> 或 <em>b</em> 的较大绝对值。例如，要设置5％的容差，请传递 <code>rel_tol=0.05</code> 。默认容差为 <code>1e-09</code>，确保两个值在大约9位十进制数字内相同。 <em>rel_tol</em> 必须大于零。<em>abs_tol</em> 是最小绝对容差 —— 对于接近零的比较很有用。 <em>abs_tol</em> 必须至少为零。如果没有错误发生，结果将是： <code>abs(a-b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)</code> 。IEEE 754特殊值 <code>NaN</code> ， <code>inf</code> 和<code>-inf</code> 将根据IEEE规则处理。具体来说， <code>NaN</code> 不被认为接近任何其他值，包括 <code>NaN</code> 。 <code>inf</code> 和 <code>-inf</code> 只被认为接近自己。</p><blockquote><p><a href="https://www.python.org/dev/peps/pep-0485" target="_blank" rel="noopener"><strong>PEP 485</strong></a> —— 用于测试近似相等的函数</p></blockquote></li></ul><h2 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h2><ul><li><p><code>cmath.pi</code></p><p>数学常数 <em>π</em> ，作为一个浮点数。</p></li><li><p><code>cmath.e</code></p><p>数学常数 <em>e</em> ，作为一个浮点数。</p></li><li><p><code>cmath.tau</code></p><p>数学常数 <em>τ</em> ，作为一个浮点数。<em>3.6 新版功能.</em></p></li><li><p><code>cmath.inf</code></p><p>浮点正无穷大。相当于 <code>float(&#39;inf&#39;)</code>。<em>3.6 新版功能.</em></p></li><li><p><code>cmath.infj</code></p><p>具有零实部和正无穷虚部的复数。相当于 <code>complex(0.0, float(&#39;inf&#39;))</code>。<em>3.6 新版功能.</em></p></li><li><p><code>cmath.nan</code></p><p>浮点“非数字”（NaN）值。相当于 <code>float(&#39;nan&#39;)</code>。<em>3.6 新版功能.</em></p></li><li><p><code>cmath.nanj</code></p><p>具有零实部和 NaN 虚部的复数。相当于 <code>complex(0.0, float(&#39;nan&#39;))</code>。</p></li></ul><p>请注意，函数的选择与模块 <a href="https://docs.python.org/zh-cn/3.8/library/math.html#module-math" target="_blank" rel="noopener"><code>math</code></a> 中的函数选择相似，但不完全相同。 拥有两个模块的原因是因为有些用户对复数不感兴趣，甚至根本不知道它们是什么。它们宁愿 <code>math.sqrt(-1)</code> 引发异常，也不想返回一个复数。 另请注意，被 <a href="https://docs.python.org/zh-cn/3.8/library/cmath.html#module-cmath" target="_blank" rel="noopener"><code>cmath</code></a> 定义的函数始终会返回一个复数，尽管答案可以表示为一个实数（在这种情况下，复数的虚数部分为零）。</p><p>关于分歧点的注释：它们是沿着给定函数无法连续的曲线。它们是许多复杂函数的必要特征。假设您需要使用复杂函数进行计算，您将了解分歧点。请参阅几乎所有关于复杂变量的（不太基本）的书来进行启发。关于分歧点数值目的的正确选择信息，应提供以下良好参考.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python-标准库-cmath&quot;&gt;&lt;a href=&quot;#python-标准库-cmath&quot; class=&quot;headerlink&quot; title=&quot;python 标准库 cmath&quot;&gt;&lt;/a&gt;python 标准库 cmath&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/jeffsui/app_image_resource/blob/master/20200210_butterfly.jpg?raw=true&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/categories/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/categories/python/standard-library/"/>
    
    
      <category term="python" scheme="https://pinghailinfeng.gitee.io/tags/python/"/>
    
      <category term="standard_library" scheme="https://pinghailinfeng.gitee.io/tags/standard-library/"/>
    
      <category term="cmath" scheme="https://pinghailinfeng.gitee.io/tags/cmath/"/>
    
  </entry>
  
</feed>
